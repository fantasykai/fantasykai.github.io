<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>平凡日子里的挣扎</title>
      <link href="/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
      <url>/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openflow总结</title>
      <link href="/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
      <link href="/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
      <url>/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 日志规范</title>
      <link href="/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-王阳明</title>
      <link href="/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/"/>
      <url>/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/</url>
      
        <content type="html"><![CDATA[<p>你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-数字化转型核心</title>
      <link href="/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/"/>
      <url>/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/</url>
      
        <content type="html"><![CDATA[<p>数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-小程序带来了什么改变</title>
      <link href="/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/"/>
      <url>/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/</url>
      
        <content type="html"><![CDATA[<p>小程序带来了什么改变？</p><p>（1）用户缩短了完成操作所需的步骤</p><p>（2）开发者更容易上手，开发难度下降</p><p>（3）新的产品形态：更垂直，更细分，更社交，更具创意</p><p>（4）用户红利：基于微信的巨大流量</p><p>什么适合做小程序</p><p>1.行业</p><p>低频刚需，这一点也已经得到公认，尤其O2O</p><p>低频非刚需：工具类适合小程序</p><p>2.产品规模</p><p>功能复杂业务多：具有大量业务，比较适合小程序，往垂直化来做，如58搬家，生活缴费等。</p><p>功能简单业务多：把核心功能迁移至小程序。</p><p>功能简单业务少：可以完全移植，相对效果不会差。</p><p>功能复杂业务少：简化体验流程。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-互联网思维～</title>
      <link href="/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/"/>
      <url>/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/</url>
      
        <content type="html"><![CDATA[<p>前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述，那么，你应该还在每天挤地铁。”</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-张子选《藏地诗篇》</title>
      <link href="/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/"/>
      <url>/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/</url>
      
        <content type="html"><![CDATA[<p>向鱼问水，向马问路</p><p>向神佛打听我一生的出处</p><p>而我呀</p><p>我是疼在谁心头的一抔尘土</p><p>一尊佛祖，两世糊涂</p><p>来世的你呀，如何把今生的我一眼认出</p><p>——张子选《藏地诗篇》</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-刻意练习</title>
      <link href="/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/"/>
      <url>/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/</url>
      
        <content type="html"><![CDATA[<p>1、有目的的练习特点</p><p>定义明确的具体目标，可以有效地用于引导你的练习</p><p>有目的的练习是专注的</p><p>有目的的练习包含反馈</p><p>有目的的练习需要走出舒适区</p><p>总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。还要想办法保持你的动机。</p><p>2、刻意练习的特点</p><p>刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能</p><p>刻意练习发生在舒适区之外，要求不断地尝试那些刚好超出他当前能力范围的事物，需要人们付出最大限度的努力。</p><p>刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进</p><p>刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动</p><p>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。</p><p>如何运用刻意练习原则</p><p>在实践中，这往往归结为带有几个额外步骤的有目的的练习：</p><p>首先辨别杰出人物</p><p>然后推测是什么使他们变得如此杰出</p><p>接着再提出训练方法，这些方法使你也能像他们那样表现卓越</p><p>在自己的工作，仔细思考杰出的表现具有哪些特点，并尝试采用一些方法来度量，即使在你度量时一定存在着某种程度的主观意识也无妨。然后，寻找你所在行业或领域中评分最高、你认为对杰出表现十分关键的人。要记住，理想的情况是找到客观的、可复制的测量指标，以便前后一致地从普通从业者之中挑选出最优异的从业者。</p><p>运用刻意练习原则的人都面临一个重大挑战，那便是：要准确地判断最杰出人物做了些什么，使得他们在普通人中间“鹤立鸡群”。 在IT互联网行业，牛人很多。大多数牛人都有着做出牛逼产品的经历，比如微信之父张小龙、小米创始人雷军。是什么促使他们做出牛逼的产品？到底是什么是他们变得如此杰出？这几个问题其实是不好找到客观的、可复制的测量指标。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-数据化：一切皆可“量化”</title>
      <link href="/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/"/>
      <url>/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/</url>
      
        <content type="html"><![CDATA[<p>数据化：一切皆可“量化”</p><p>莫里的导航图，大数据的最早实践之一</p><p>许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。</p><p>数据从最不可能的地方提取出来</p><p>大数据的核心就是挖掘出庞大的数据库独有的价值</p><p>数据化，不是数字化</p><p>数据化，这是指一种把现象转变可制表分析的量化形式的过程。</p><p>量化一切，数据化的核心</p><p>计量和记录一起促成了数据的诞生，它们是数据化最早的根基</p><p>数字化带来了数据化，但是数字化无法取代数据化</p><p>当文字成为数据</p><p>但文字变成数据，它就大显神通了——人可以用之阅读，机器也可以用之分析。</p><p>当方位变成数据</p><p>“现实挖掘”这里指的是通过处理大量来自手机的数据，发现和预测人类行为。</p><p>位置信息一被数据化，新的用途就犹如雨后春笋般涌现出来，而新价值也会随之不断催生。</p><p>当沟通变成数据</p><p>Twitter情绪数据化</p><p>社交图谱  FICO</p><p>twitter情感分析以获得顾客反馈意见的汇总或对营销获得的效果进行判断</p><p>世间万物的数据化</p><p>只要一点想象，万千事物就能转化为数据形式，并一直带给我们惊喜。</p><p>物联网只是一种典型的数据化手段</p><p>有了大数据的帮助，我们不会再将世界看作是一连串wim认为或是自然或是社会现象的时间，我们会意识到本质上世界是由信息构成的。</p><p>将世界看作信息，看作可以理解的数据还有，为我们提供了一个从未有过的审视现实的视角。它是一种可以渗透到所有生活领域的世界观。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-更多，更杂，更好</title>
      <link href="/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/"/>
      <url>/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/</url>
      
        <content type="html"><![CDATA[<p>更多：不是随机样本，而是全体数据</p><p>样本&#x3D;总体</p><p>更杂：不是精确性，而是混杂性</p><p>允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。</p><p>大数据抵消了错误数据带来的不精确：</p><p>更好：不是因果关系，而是相关关系</p><p>建立在相关关系分析法上的预测是大数据的核心，我们通过大数据分析得到的是“是什么”（相关关系），而得不出“为什么”（因果关系）的结论。</p><p>通过大数据分析，寻找事物、数据之间的关联性来分析现象，而不是揭示其内部机制。往往通过大数据得出的结论只是一个可能性预测，而不知道其背后的原因。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="java问题排查工具单"><a href="#java问题排查工具单" class="headerlink" title="java问题排查工具单"></a>java问题排查工具单</h2><p>转自 作者：红魔七号<br>链接：<a href="https://yq.aliyun.com/articles/69520?utm_content=m_10360">https://yq.aliyun.com/articles/69520?utm_content=m_10360</a></p><p><em>摘要：</em> # 我的问题排查工具箱 ## 前言 平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。 闲话不多说，开搞。 ## Linux命令类 ###tail 最常用的tail -f tail -3</p><h1 id="我的问题排查工具箱"><a href="#我的问题排查工具箱" class="headerlink" title="我的问题排查工具箱"></a>我的问题排查工具箱</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。</p><p>闲话不多说，开搞。</p><h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>1 基础命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $4,$6&#125;&#x27; f.txt</span><br><span class="line">awk &#x27;&#123;print NR,$0&#125;&#x27; f.txt cpf.txt    </span><br><span class="line">awk &#x27;&#123;print FNR,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FNR,FILENAME,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&#x27; f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: &#x27;&#123;print $1,$2,$3,$4&#125;&#x27;</span><br></pre></td></tr></table></figure><p>2 匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/ldb/ &#123;print&#125;&#x27; f.txt   #匹配ldb</span><br><span class="line">awk &#x27;!/ldb/ &#123;print&#125;&#x27; f.txt  #不匹配ldb</span><br><span class="line">awk &#x27;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&#x27; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#x27;$5 ~ /ldb/ &#123;print&#125;&#x27; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find /usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure><h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgm -A -f vm-shopbase &#x27;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#x27;</span><br></pre></td></tr></table></figure><h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar  ##可以查看最近一天的各项指标</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc25b8f22e53818d5576c5d00dd52618.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar --live ##可以查看实时指标，默认五秒一刷</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b68910c5416fd85a99a49a092fc9ffbb.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aafdbfb515b817a2aceb270d1d470c19.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tsar --mem</span><br><span class="line">tsar --load</span><br><span class="line">tsar --cpu</span><br><span class="line">##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/cb46ef4e374e1502d3b672d04d48099a.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/079f3fa722bfa1991557469eb97c7273.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6dd77351ad4d1ad84cdbfba20c9d4c29.png" alt="screenshot.png"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|awk  &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">#查看当前连接，注意close_wait偏高的情况，比如如下</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/250a027410775cf5990d0db6e87ba927.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/639811da529750064e2f70867d6234e0.png" alt="screenshot.png"></p><h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ol><li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</p><p>@OnMethod(clazz &#x3D; “java.util.ArrayList”, method&#x3D;”add”, location &#x3D; @Location(value &#x3D; Kind.CALL, clazz &#x3D; “&#x2F;.<em>&#x2F;“, method &#x3D; “&#x2F;.</em>&#x2F;“))<br>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123;</span><br><span class="line">    println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod  + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance));</span><br><span class="line">    jstack();</span><br><span class="line">    println();</span><br><span class="line">    println(&quot;===========================&quot;);</span><br><span class="line">    println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><p>监控当前服务方法被调用时返回的值以及请求的参数</p><p>@OnMethod(clazz &#x3D; “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method&#x3D;”nav”, location &#x3D; @Location(value &#x3D; Kind.RETURN))<br>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result);</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。<br><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></p><p>注意:</p><ol><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ol><h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p><p><code>trace class method</code>: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:<a href="http://www.atatech.org/articles/52947">http://www.atatech.org/articles/52947</a>。</p><p>其他功能部分和btrace重合，可以选用，感兴趣的请移步。<br><a href="http://www.atatech.org/articles/26247">http://www.atatech.org/articles/26247</a></p><p>另外相关联的是arthas，他是基于Greys的，感兴趣的再移步<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc">http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc</a></p><h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>可以看看我之前写的一篇javOSize的简介<a href="http://www.atatech.org/articles/38546">http://www.atatech.org/articles/38546</a><br>官网请移步<a href="http://www.javosize.com/">http://www.javosize.com/</a></p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<br>官网请移步<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<br>详情请移步<a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p><h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛<br>详情请移步<a href="http://zprofiler.alibaba-inc.com/">zprofiler.alibaba-inc.com</a></p><h2 id="java三板斧，噢不对，是七把"><a href="#java三板斧，噢不对，是七把" class="headerlink" title="java三板斧，噢不对，是七把"></a>java三板斧，噢不对，是七把</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>我只用一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/jps -mlvV</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b156cb53250bf5f91811900c2575a91.png" alt="screenshot.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>普通用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc501bf424b3d2884e6ec118d14554a3.png" alt="screenshot.png"></p><p>native+java栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4c59dc2971f3d8778e1898d64266266a.png" alt="screenshot.png"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc879145e2994e9a09327407ed88382c.png" alt="screenshot.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p><p>1.查看堆的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/00d9eaef08cdb51263d202d26795036b.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3c08bccf81fef8b7bcae2b321012b503.png" alt="screenshot.png"></p><p>2.dump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</span><br></pre></td></tr></table></figure><p>3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/500ec6709fcd03a4fca2679615d54522.png" alt="screenshot.png"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/05743916a9187535c202fb410d30d50d.png" alt="screenshot.png"></p><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是&#x2F;opt&#x2F;taobao&#x2F;java&#x2F;，远程调试端口是8000.那么<br><code>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000</code>.</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/16332fcd45b20137bffc7a3b9a88b0f1.png" alt="screenshot.png"></p><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<br>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html</a></p><h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</span><br></pre></td></tr></table></figure><p>更详细的可见R大此贴<br><a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/356c11885a95e28736a605aecdc8083e.png" alt="screenshot.png"></p><h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p><h2 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h2><ol><li><p>你的类到底是从哪个文件加载进来的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br><span class="line">结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar]</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>应用挂了输出dump文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof</span><br><span class="line">集团的vm参数里边基本都有这个选项</span><br></pre></td></tr></table></figure></li></ol><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p><h3 id="mvn-dependency-tree-gt-x2F-dependency-txt"><a href="#mvn-dependency-tree-gt-x2F-dependency-txt" class="headerlink" title="mvn dependency:tree &gt; ~&#x2F;dependency.txt"></a>mvn dependency:tree &gt; ~&#x2F;dependency.txt</h3><p>打出所有依赖</p><h3 id="mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId"><a href="#mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId" class="headerlink" title="mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId"></a>mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId</h3><p>只打出指定groupId和artifactId的依赖关系</p><h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="greys-sc"><a href="#greys-sc" class="headerlink" title="greys:sc"></a>greys:sc</h3><p>greys的sc命令也能清晰的看到当前类是从哪里加载过来的</p><h3 id="tomcat-classloader-locate"><a href="#tomcat-classloader-locate" class="headerlink" title="tomcat-classloader-locate"></a>tomcat-classloader-locate</h3><p>通过以下url可以获知当前类是从哪里加载的<br>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a></p><h2 id="ALI-TOMCAT带给我们的惊喜-感谢-务观"><a href="#ALI-TOMCAT带给我们的惊喜-感谢-务观" class="headerlink" title="ALI-TOMCAT带给我们的惊喜(感谢@务观)"></a>ALI-TOMCAT带给我们的惊喜(感谢@务观)</h2><ol><li><p>列出容器加载的jar列表</p><p>curl <a href="http://localhost:8006/classloader/jars">http://localhost:8006/classloader/jars</a></p></li><li><p>列出当前当当前类加载的实际jar包位置，解决类冲突时有用</p><p>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4568b16d3db0daf98e852412b830f1a8.png" alt="screenshot.png"></p></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h3><p><a href="http://www.atatech.org/articles/33317">http://www.atatech.org/articles/33317</a></p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg|grep -i kill|less</span><br></pre></td></tr></table></figure><p>去找关键字oom_killer。找到的结果类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0</span><br><span class="line">[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 </span><br><span class="line">[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 </span><br><span class="line">[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span><br><span class="line">[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span><br></pre></td></tr></table></figure><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式:<br>log实际时间&#x3D;格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1970-01-01 UTC `echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&#x27; &#x27;)+12288812.926194&quot;|bc ` seconds&quot;</span><br></pre></td></tr></table></figure><p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步<a href="http://ifeve.com/guava-ratelimiter/">http://ifeve.com/guava-ratelimiter/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-运营该如何被定义和理解</title>
      <link href="/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/"/>
      <url>/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/</url>
      
        <content type="html"><![CDATA[<p>运营该如何被定义和理解<br>1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段</p><p>2.运营工作的流程：<br>1）制定策略：根据不同的产品形态及数据变化制定不用的策略</p><p>2）分解指标，规划工作：对目标进行拆解，向内向外的资源争取及分配，制定具体的工作计划</p><p>3）执行落地，达成目标：通过文案、活动、用户维系等具体运营手段来达成我们的目标</p><p>4）监测数据、调整方向：收集、分析数据及用户反馈，评估运营工作调整新的运营策略</p><p>3.运营的四个关键性思维</p><p>1.流程化思维：一个优秀的运营和一个普通人之间存在的一个核心差别，就是优秀的运营拿到一个问题后，会回归流程，先把整个问题流程梳理出来，然后再从流程中去寻找潜在的解决方案。“先有流程，再有解决方案”这一点，不止对运营，对于产品来说也是一样的。</p><p>2.精细化思维：运营做久了会发现，优秀的运营，很多时候是通过大量的细节和琐碎事务堆积出来一个神奇的产品。这就需要运营具备很强的精细化思维和精细化管理，必须要能够把自己关注的一个问题拆解为无数细小的执行细节，并且能够做到对于所有细节的掌控力。</p><p>3.杠杆思维：好的运营是有层次感的，需要先做好一件事情，再以这件事为一个核心杠杆，去撬动更多的事情和成果发生，比如先服务好一批种子用户，给他们制造大量的超出他们预期的体验，以此为杠杆，撬动他们帮我们宣传。</p><p>4.生态化思维：所谓生态，其实就是一个所有角色在其中都可以互为价值、和谐共存、共同驱动器发展和生存的一个大环境，比如一个好几百人的微信群，一个社区。而能否成功搭建起来生态，最重要的，就是你能够梳理清楚并理解一个生态间的各种价值关系。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/"/>
      <url>/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/</url>
      
        <content type="html"><![CDATA[<p>来源：王韵菲 </p><p><a href="http://www.evget.com/article/2015/11/16/22990.html">www.evget.com/article/2015/11/16/22990.html</a></p><p>本文中，小编搜集了7个最有影响的衡量标注，让你可以不依赖日志文件来了解应用程序。现在，让我们看看这些性能指标，并了解如何查看并收集它们：</p><p><strong>1.响应时间和吞吐量</strong></p><p>根据应用程序的响应时间可以知道程序完成传输数据所用的时间。也可以从HTTP请求级别，或者成为数据库级别来看。对那些缓慢的查询你需要做一些优化来缩短时间。吞吐量是另一个角度衡量传输数据的指标，是指单位时间内系统处理的客户请求的数量。</p><p>我们可以使用APMs（例如New Relic或AppDynamics）来衡量这些指标。使用这些工具，你可以在主报告仪表板中将平均响应时间与昨天的甚至上周的直接进行对比。这有助于我们观察新的部署是否会影响到我们的应用程序。你可以看到网络传输的百分比，测量HTTP完成请求需要多长时间。</p><p>推荐工具：</p><ul><li>AppDynamics</li><li>New Relic</li><li>Ruxit</li></ul><p>New Relic报告：Web传输百分比和吞吐量</p><p><strong>2.平均负载</strong></p><p>第二个应用广泛的指标是平均负载。我们习惯上会把平均负载分为这三步测量，分别是第5分钟、第15分钟和最后1分钟。要保证数量低于机器的内核数。一旦超过内核数，机器就会运行在压力状态下。</p><p>除了简单测量CPU使用率，还需要关注每个内核的队列中有多少进程。在内核使用率都是100%的情况下，队列中只有1个任务和有6个任务有很大不同。因此，平均负载不能只考虑CPU使用率。</p><p>推荐工具：</p><ul><li>htop</li></ul><p><strong>3.错误率</strong></p><p>大多数开发人员判断错误率是根据HTTP传输总失败百分比。但是他们忽略了一个更深层的东西：特定传输的错误率。这直接影响到您应用程序的运行状况。这可以显示出代码方法的错误以及错误或异常出现的次数。</p><p>但单纯的错误率数据对我们没有多大帮助。最重要的是我们要找到它们的根源并解决问题。随着Takipi的运行，我们要在日志文件中需找线索。你可以找到所有关于服务器状态的信息，包括堆栈跟踪、源代码和变量值。</p><p>推荐工具：</p><ul><li>Takipi</li></ul><p><strong>4.GC率和暂停时间</strong></p><p>异常行为垃圾收集器应用程序的吞吐量和响应时间采取深潜的主要原因之一。了解GC暂停频率和持续时间的关键是分析GC日志文件。要分析它们，你需要收集GC日志和JVM参数。你要注意观察不同指标之间的数据是如何相互影响的。</p><p>推荐工具：</p><ul><li>jClarity Censum</li><li>GCViewer</li></ul><p><strong>5.业务指标</strong></p><p>应用程序的性能不完全取决于响应时间和错误率。业务指标也是一方面，例如收益、用户数。</p><p>推荐工具：</p><ul><li>Grafana</li><li>The ELK stack</li><li>Datadog</li><li>Librato</li></ul><p><strong>6.正常运行时间和服务运行状态</strong></p><p>这一指标奠定了整个应用程序性能的基础。不仅可以当做一个提醒指标，也可以让你定义一段时间内的SKA。我们可以使用Pingdom的servlet功能进行运行状态检查。我们可以查到应用程序的所有传输，包括数据库和S3。</p><p>推荐工具：</p><ul><li>Pingdom</li></ul><p><strong>7.日志大小</strong></p><p>日志有一个缺点，它是一直在增加的。当您的服务器启动塞满了垃圾，一切都慢下来。因此，我们需要密切的关注日志大小。</p><p>目前通常的解决办法是使用logstash划分使用日志，并将它们发送并存储在Splunk、ELK或其他的日志管理工具中。</p><p>推荐工具：</p><ul><li>Splunk</li><li>Sumo Logic</li><li>Loggly</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-任何商业模式都来源于用户需求</title>
      <link href="/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/"/>
      <url>/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/</url>
      
        <content type="html"><![CDATA[<p>任何商业模式都来源于用户需求～</p><p>用户需求特点:更快，更多，更便宜，更好玩<br>需求处理:发现，分析，描述<br>产品设计步骤:<br>产品决策:需求是否全面，流程是否打的通，是否战略一致。<br>产品功能设计:基本功能，核心功能<br>用户体验原则:不要强迫用户，不要让用户思考，用户易操作，不破坏用户原则，超出用户预期。</p><p>网络运营<br>网络运营模型:来源量，转化率，活跃度，留存率<br>周期:种子期，爆发期，平台期<br>网络推广:用户互导，资源互换，购买流量</p><p>网络运营总结：<br>1 种子期是产品最难的阶段，留存率是关键，不在乎来多少人，而在乎有多少人留下来。种子期成功，产品成功一半。<br>2 爆发期是产品成功的标志，来源量是关键，产品形成口碑影响力，能成功的产品一定有爆发期。<br>3 平台期是用户爆发增长后有意控制产品节奏的时期，活跃度是关键，重点做好系统稳定和产品用户体验。<br>4 爆发期和平台期交替出现，产品才能不断稳定增长。</p><p>互联网商业模式:<br>循环:做好的产品，吸引用户，产生收入<br>形成比由之路:创造好产品 ，获取海量用户，引导用户消费。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-企业文化三要素</title>
      <link href="/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/"/>
      <url>/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/</url>
      
        <content type="html"><![CDATA[<p>企业文化三要素：</p><p>赋予员工使命：激发员工主人翁意识，从全人类层面考虑问题，打造使命的不可逾越性；</p><p>保障公司透明度：信息共享，给予员工充分信任，会议形成记录，达到有效沟通</p><p>保障员工发声权利：高层权力下放，员工拥有话语权，培养员工独立思考</p><p>谷歌如何招聘人才：</p><p>人才原则：慢工招人才，只招聘比自己优秀的人才</p><p>招聘流程：谷歌求职者调查测试，下属面试，横向面试</p><p>评估工具：采用qDroid, 多人多角度多流程评估面试者</p><p>如何重新定义团队：</p><p>打造“小而美”团队，消除内部地位象征，依据数据做决策，自我职业规划，关注优劣两极员工，保持高期待和高收益；</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly 的未来：将逐渐解锁整个“技能树”</title>
      <link href="/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/"/>
      <url>/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly-的未来：将逐渐解锁整个“技能树”"><a href="#WebAssembly-的未来：将逐渐解锁整个“技能树”" class="headerlink" title="WebAssembly 的未来：将逐渐解锁整个“技能树”"></a>WebAssembly 的未来：将逐渐解锁整个“技能树”</h1><ul><li><a href="https://www.oschina.net/news/101159/the-future-of-webassembly">原文</a></li></ul><p>WebAssembly 在2017年受到主流浏览器的支持，并发布了被 MVP 版本（Minimum Viable Product，最简可行产品）。虽然 WebAssembly 社区组致力于使 WebAssembly 向后相容，让现在开发的 WebAssembly 应用程式，仍可以在未来的浏览器中运作，但这并不代表 WebAssembly 功能已经完整，MVP 绝非最终版本。相反，WebAssembly 还将增加许多新功能，而这些新功能将从根本上颠覆 WebAssembly 所能实现的工作。</p><p>为消除人们对 WebAssembly 的误解，WebAssembly 社区组以 RPG 游戏中人物养成的“技能树”形式，对 <a href="https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/">WebAssembly 的未来发展路径</a>做了非常详细的解释。他们表示目前已经完全掌握这些技能中的前几项，后续需要慢慢解锁整个技能树。</p><p><img src="https://oscimg.oschina.net/oscnet/42ccc510cfd9d1d2670037cba32f3007d47.jpg" alt="img"></p><p>WebAssembly 在 MVP 版本阶段满足 4 个基本技能要求：编译、快速执行、压缩和线性内存分配。使用 WebAssembly 的人知道他们不想只支持 C 和 C ++，而是希望能够将许多不同的语言编译为 WebAssembly 。经 WebAssembly 编译器编译的应用需要能够快速执行，满足需求。而为了加速载入速度，WebAssembly 还需具备压缩能力，减少使用者的等待时间。另外，WebAssembly 需要有别于 JavaScript 使用内存方式，能够直接管理使用的内存，在加上安全因素的考量，WebAssembly 采用线性内存模式。</p><p><img src="https://oscimg.oschina.net/oscnet/48a0162ed0e0f848088cecfa4c9c0d6b5b4.jpg" alt="img"></p><p>社区组表示，WebAssembly 的下一个目标是平滑运行那些更重的应用程序，比如 Photoshop、Gmail 等。为确保此类应用能在浏览器中运行良好，他们需要解锁新一批的“技能”，包括支持多线程、SIMD（单指令流多数据流）、64位寻址、流式编译（在下载的同时编译 WebAssembly 文件）、分层编译器、隐式 HTTP 缓存以及一些其他改进。</p><p><img src="https://oscimg.oschina.net/oscnet/586022e01ab45f31b0d35d223ea932a8827.jpg" alt="img"></p><p>一旦以上功能全部就位，WebAssembly 又将进入下一个阶段 —— 与 JavaScript 互操作，包括 JS 和 WebAssembly 之间的快速调用、简便的数据交换、ES模块集成、工具链集成和向后兼容性。</p><p><img src="https://oscimg.oschina.net/oscnet/5d163b3cfd5ecd82788682365c270636ebe.jpg" alt="img"></p><p>此外，他们还想在 WebAssembly 中重写 JavaScript 框架的大部分内容，并使静态类型的 compile-to-js 语言可编译为 WebAssembly 。想要实现这两个目标，WebAssembly 还需要支持高阶的语言功能，包括垃圾回收、异常处理、调试以及尾调用（Tail calls）。</p><p><img src="https://oscimg.oschina.net/oscnet/c84da0e9a6a4992b6a2219bc3b6f65dc950.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/"/>
      <url>/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/</url>
      
        <content type="html"><![CDATA[<p><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率</p><p>本文的内容有些来自网络，有些来自平时工作和学习，当然这不重要，重要的是这些代码优化的细节是否真真正正地有用。那本文会保持长期更新，只要有遇到值得分享的代码优化细节，就会不定时地更新此文。</p><p><strong>代码优化细节</strong></p><p><strong>1、尽量指定类、方法的final修饰符</strong></p><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><p><strong>2、尽量重用对象</strong></p><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>3、尽可能使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><p><strong>4、及时关闭流</strong></p><p>Java编程过程中，进行数据库连接、I&#x2F;O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><p><strong>5、尽量减少对变量的重复计算</strong></p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><blockquote><p>for (int i &#x3D; 0; i &lt; list.size(); i++)</p><p>{…}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>for (int i &#x3D; 0, int length &#x3D; list.size(); i &lt; length; i++)</p><p>{…}</p></blockquote><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><p><strong>6、尽量采用懒加载的策略，即在需要的时候才创建</strong></p><p><strong>例如：</strong></p><blockquote><p>String str &#x3D; “aaa”;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　String str &#x3D; “aaa”;</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>7、慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p><p>根据网友们提出的意见，这一点我认为值得商榷</p><p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、</p><p><strong>HashSet等等，以StringBuilder为例：</strong></p><p>（1）StringBuilder()　　　　　　&#x2F;&#x2F; 默认分配16个字符的空间</p><p>（2）StringBuilder(int size)　　&#x2F;&#x2F; 默认分配size个字符的空间</p><p>（3）StringBuilder(String str)　&#x2F;&#x2F; 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><p><strong>10、当复制大量数据时，使用System.arraycopy()命令</strong></p><p><strong>11、乘法和除法使用移位操作</strong></p><p><strong>例如：</strong></p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val * 8;</p><p>　　b &#x3D; val &#x2F; 2;</p><p>}</p></blockquote><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： </p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val &lt;&lt; 3;</p><p>　　b &#x3D; val &gt;&gt; 1;</p><p>}</p></blockquote><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p><strong>12、循环内不要不断创建对象引用</strong></p><p><strong>例如：</strong></p><blockquote><p>for (int i &#x3D; 1; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    Object obj &#x3D; new Object();    </p><p>}</p></blockquote><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><blockquote><p>Object obj &#x3D; null;</p><p>for (int i &#x3D; 0; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    obj &#x3D; new Object();</p><p>}</p></blockquote><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><p><strong>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p><p><strong>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p><p><strong>15、不要将数组声明为public static final</strong></p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><p><strong>16、尽量在合适的场合使用单例</strong></p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><p><strong>17、尽量避免随意使用静态变量</strong></p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><blockquote><p>public class A</p><p>{</p><p>​    private static B b &#x3D; new B();  </p><p>}</p></blockquote><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><p><strong>18、及时清除不再需要的会话</strong></p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><p><strong>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><blockquote><p>if (list instanceof RandomAccess)</p><p>{</p><p>​    for (int i &#x3D; 0; i &lt; list.size(); i++){}</p><p>}</p><p>else</p><p>{</p><p>​    Iterator&lt;?&gt; iterator &#x3D; list.iterable();</p><p>​    while (iterator.hasNext()){iterator.next()}</p><p>}</p></blockquote><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><strong>20、使用同步代码块替代同步方法</strong></p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><strong>21、将常量声明为static final，并以大写命名</strong></p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><p><strong>22、不要创建一些不使用的对象，不要导入一些不使用的类</strong></p><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><p><strong>23、程序运行过程中避免使用反射</strong></p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><strong>24、使用数据库连接池和线程池</strong></p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><p><strong>25、使用带缓冲的输入输出流进行IO操作</strong></p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><p><strong>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</strong></p><p>这个，理解ArrayList和LinkedList的原理就知道了</p><p><strong>27、不要让public方法中有太多的形参</strong></p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><p><strong>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><blockquote><p>String str &#x3D; “123”;</p><p>if (str.equals(“123”))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>String str &#x3D; “123”;</p><p>if (“123”.equals(str))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这么做主要是可以避免空指针异常</p><p><strong>29、请知道，在java中if (i &#x3D;&#x3D; 1)和if (1 &#x3D;&#x3D; i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p><p>平时有人问，”if (i &#x3D;&#x3D; 1)”和”if (1&#x3D;&#x3D; i)”有没有区别，这就要从C&#x2F;C++讲起。</p><p>在C&#x2F;C++中，”if (i &#x3D;&#x3D; 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>C&#x2F;C++判断”i&#x3D;&#x3D;1”不成立，所以以0表示，即false。但是如果：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>万一程序员一个不小心，把”if (i &#x3D;&#x3D; 1)”写成”if (i &#x3D; 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C&#x2F;C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><blockquote><p>int i &#x3D; 2;</p><p>if (1 &#x3D;&#x3D; i)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这样，即使开发者不小心写成了”1 &#x3D; i”，C&#x2F;C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C&#x2F;C++这种”if (i &#x3D; 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i &#x3D;&#x3D; 1)”和”if (1 &#x3D;&#x3D; i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><p><strong>30、不要对数组使用toString()方法</strong></p><p><strong>看一下对数组使用toString()打印出来的是什么：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int[] is &#x3D; new int[]{1, 2, 3};</p><p>​    System.out.println(is.toString());</p><p>}</p></blockquote><p><strong>结果是：</strong></p><blockquote><p>[I@18a992f</p></blockquote><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<E>重写了Object的toString()方法。</p><p><strong>32、不要对超出范围的基本数据类型做向下强制转型</strong></p><p><strong>这绝不会得到想要的结果：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    long l &#x3D; 12345678901234L;</p><p>​    int i &#x3D; (int)l;</p><p>​    System.out.println(i);</p><p>}</p></blockquote><p><strong>我们可能期望得到其中的某几位，但是结果却是：</strong></p><blockquote><p><strong>1942892530</strong></p></blockquote><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l &#x3D; 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f &#x3D; 3.5f”</p><p>2、接下来再写一句”int ii &#x3D; l + i;”会报错，因为long + int是一个long，不能赋值给int</p><p><strong>33、公用的集合类中不使用的数据一定要及时remove掉</strong></p><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><p><strong>34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</strong></p><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int loopTime &#x3D; 50000;</p><p>​    Integer i &#x3D; 0;</p><p>​    long startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; String.valueOf(i);</p><p>​    }    </p><p>​    System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i.toString();</p><p>​    }    </p><p>​    System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i + “”;</p><p>​    }    </p><p>​    System.out.println(“i + “”：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>}</p></blockquote><p><strong>运行结果为：</strong></p><blockquote><p>String.valueOf()：11ms</p><p>Integer.toString()：5ms</p><p>i + “”：25ms</p></blockquote><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><p><strong>35、使用最有效率的方式去遍历Map</strong></p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    HashMap&lt;String, String&gt; hm &#x3D; new HashMap&lt;String, String&gt;();</p><p>​    hm.put(“111”, “222”);</p><p>​        </p><p>​    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet &#x3D; hm.entrySet();</p><p>​    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter &#x3D; entrySet.iterator();</p><p>​    while (iter.hasNext())</p><p>​    {</p><p>​        Map.Entry&lt;String, String&gt; entry &#x3D; iter.next();</p><p>​        System.out.println(entry.getKey() + “” + entry.getValue());</p><p>​    }</p><p>}</p></blockquote><p>如果你只是想遍历一下这个Map的key值，那用”Set<String> keySet &#x3D; hm.keySet();”会比较合适一些</p><p><strong>36、对资源的close()建议分开操作</strong></p><blockquote><p>意思是，比如我有这么一段代码：</p><p>try</p><p>{</p><p>​    XXX.close();</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>try</p><p>{</p><p>​    XXX.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p><p>try</p><p>{</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉</p><p><strong>后记</strong></p><p>优秀的代码来自每一点点小小的优化，关注每一个细节，不仅仅能提升程序运行效率，同样可以规避许多未知的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-新零售的本质</title>
      <link href="/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/"/>
      <url>/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/</url>
      
        <content type="html"><![CDATA[<p>零售的本质是把人和货连接在一起的场；新零售是一场效率革命。</p><p>1.新零售，是效率更高的零售</p><p>①场的效率</p><p>信息流；资金流；物流。</p><p>②人的效率</p><p>流量革命；转化率；客单价；复购率。</p><p>销售漏斗公式：销售额&#x3D;流量×转化率×客单价×复购率</p><p>该公式可以用来衡量销售额，却无法衡量销售的效率。</p><p>③货的效率</p><p>定倍率：商业世界最基础的逻辑之一，是衡量商业效率的重要指标。定倍率越低，效率越高。</p><p>未来，中国制造的趋势是：</p><p>低质高价和低质低价的商品，存活空间会越来越小，甚至被逐步淘汰；</p><p>高质低价的零售业，将迎来它的时代，而C2M（Customer-to- Manufactory，客对厂）模式是实现高质低价的一个有效手段。</p><p>2.新的商业思维</p><p>① 进化思维</p><p>② 本质思维</p><p>③ 系统思维</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-智识链</title>
      <link href="/2018/08/30/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00830/"/>
      <url>/2018/08/30/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00830/</url>
      
        <content type="html"><![CDATA[<p>食物链排名对个人相当不可控，但是还有另外一条链可以追求，我们不妨称之为 “智识链”。<br>智识，就是智慧和见识，智识不是一种资源。资源可以赠送，可以继承，可以一出生就有，智识不能。<br>资源可以出售变现，智识不能直接转换成钱。<br>智识是“三观”—对世界正确的认识，对人生合理的安排，知道什么东西是好东西；<br>智识还是历史的经验和做事的手段。</p><p>be part of something bigger than yourself</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP定理的含义</title>
      <link href="/2018/08/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2018/08/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CAP-定理的含义"><a href="#CAP-定理的含义" class="headerlink" title="CAP 定理的含义"></a>CAP 定理的含义</h1><p>转自阮一峰老师的博客 </p><p><a href="http://www.ruanyifeng.com/home.html">阮一峰</a></p><p>分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。</p><p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p><p>本文介绍该定理。它其实很好懂，而且是显而易见的。下面的内容主要参考了 Michael Whittaker 的<a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/">文章</a>。</p><h2 id="一、分布式系统的三个指标"><a href="#一、分布式系统的三个指标" class="headerlink" title="一、分布式系统的三个指标"></a>一、分布式系统的三个指标</h2><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg" alt="img"></p><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p><blockquote><ul><li>Consistency</li><li>Availability</li><li>Partition tolerance</li></ul></blockquote><p>它们的第一个字母分别是 C、A、P。</p><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><h2 id="二、Partition-tolerance"><a href="#二、Partition-tolerance" class="headerlink" title="二、Partition tolerance"></a>二、Partition tolerance</h2><p>先看 Partition tolerance，中文叫做”分区容错”。</p><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png" alt="img"></p><p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><h2 id="三、Consistency"><a href="#三、Consistency" class="headerlink" title="三、Consistency"></a>三、Consistency</h2><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png" alt="img"></p><p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png" alt="img"></p><p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png" alt="img"></p><p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png" alt="img"></p><p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png" alt="img"></p><h2 id="四、Availability"><a href="#四、Availability" class="headerlink" title="四、Availability"></a>四、Availability</h2><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p><p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p><h2 id="五、Consistency-和-Availability-的矛盾"><a href="#五、Consistency-和-Availability-的矛盾" class="headerlink" title="五、Consistency 和 Availability 的矛盾"></a>五、Consistency 和 Availability 的矛盾</h2><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p><p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><p>[更新 2018.7.17]</p><p>读者问，在什么场合，可用性高于一致性？</p><p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p><p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-什么是活跃起用户的产品</title>
      <link href="/2018/07/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00729/"/>
      <url>/2018/07/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00729/</url>
      
        <content type="html"><![CDATA[<p>“活跃起用户的产品”<br>1.专属性，营造独一无二的价值感；<br>2.情绪性，使人们的高唤醒情绪受到激发；<br>3.社交货币，即谈资，让大家有共同话题，刺激越来越多的人加入。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stereotype组件与Bean扫描</title>
      <link href="/2018/07/28/java/%20Stereotype%E7%BB%84%E4%BB%B6%E4%B8%8EBean%E6%89%AB%E6%8F%8F/"/>
      <url>/2018/07/28/java/%20Stereotype%E7%BB%84%E4%BB%B6%E4%B8%8EBean%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<p>在注解自动装载中介绍了通过注解（Annotation）自动向Bean中注入其他Bean的方法，本篇将介绍通过注解（Annotation）向容器添加Bean的方法。</p><p> Spring的核心容器提供了@Component和@Bean注解来标记如何向IoC容器添加Bean。在核心包中@Component又派生了@Service、@Controller和@Repository这三个注解（在其他的Spring工程或包中还有更多的派生），本文主要介绍@Component及其派生注解的使用。</p><h2 id="一个简单的使用例子"><a href="#一个简单的使用例子" class="headerlink" title="一个简单的使用例子"></a>一个简单的使用例子</h2><p>要想使用@Component等注解来向容器添加Bean，需要向IoC容器指明什么类有这个注解，所以Spring提供了一个扫描机制让使用者指定要检查的路径。配置非常简单，只要使用上下文的component-scan标签即可。我们通过下面的例子来简单说明如何配置。</p><p>例子中的代码仅用于说明问题，并不能运行。源码请到<a href="https://gitee.com/chkui-com/spring-core-sample%E8%87%AA%E8%A1%8Cclone%EF%BC%8C%E4%BE%8B%E5%AD%90%E5%9C%A8*chkui.springcore.example.hybrid.component*%E5%8C%85%E4%B8%AD%E3%80%82">https://gitee.com/chkui-com/spring-core-sample自行clone，例子在*chkui.springcore.example.hybrid.component*包中。</a></p><p>有一个接口和一个实现类作为要添加到IoC容器的Bean：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;public interface NameService &#123;String getName();</span><br><span class="line">&#125;</span><br><span class="line">package chkui.springcore.example.hybrid.component.bean;@Componentpublic class NameServiceImpl implements NameService&#123;@Override</span><br><span class="line">public String getName() &#123;return &quot;This is My Component&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现类NameServiceImpl上使用了@Component注解。</p><p>然后XML（&#x2F;spring-core-sample&#x2F;src&#x2F;main&#x2F;resources&#x2F;hybrid&#x2F;component）配置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;context:component-scan base-package=&quot;chkui.springcore.example.hybrid.component.bean&quot;/&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>XML配置文件中没有任何<bean>的声明，仅仅是通过component-scan启用了路径扫描功能，base-package指定了扫描的包路径。</p><p>然后我们加载这个XML运行Spring IoC容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component;public class SimpleScanApp &#123;public static void main(String[] args) &#123;</span><br><span class="line">print(new ClassPathXmlApplicationContext(&quot;hybrid/component/scanConfig.xml&quot;));</span><br><span class="line">&#125;</span><br><span class="line">private static void print(ApplicationContext context) &#123;</span><br><span class="line">    NameService service = context.getBean(NameService.class);</span><br><span class="line">    System.out.println(service.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后NameServiceImpl就会作为一个Bean添加到IoC容器中。</p><p>在 IOC功能扩展点 一文中已经介绍通过XML、@Component、@Bean任何一种方式去声明一个Bean都会转化为一个 BeanDefinition 的实现类交给BeanFactory来创建实例，所以实际上通过@Component注解和在XML文件中编写一个<bean>标签在结果上并没有什么区别——都是向容器添加了一个Bean实例。但是Spring偏偏提供了@Bean和@Component（以及他的派生注解）2个注解来声名Bean，这当中肯定是有一些差异的。</p><p>@Bean在后续的文章会介绍，它就等价与在XML编写一个<bean>标签。而@Component以及他的派生注解除了是一个IoC容器中的Bean还有许多附加的含义。</p><h2 id="Stereotype与功能分层"><a href="#Stereotype与功能分层" class="headerlink" title="Stereotype与功能分层"></a>Stereotype与功能分层</h2><p>观察@Bean和@Component两个注解的包，前者是在 <em>org.springframework.context.annotation</em> ，而后者是在 <em>org.springframework.stereotype</em> 。不仅仅是@Component，他的派生注解@Service、@Controller和@Repository都在这个包中，实际上它就是在告诉使用者这些注解提供<em>stereotype</em>的特性（或者称为功能、作用）。</p><p>那什么是<em>stereotype</em>特性呢？这很难通过Stereotype这个词的字面意思（这个词能翻译的意思很多，这里最接近的翻译应该是“旧规矩”或者“使固定”）来理解。</p><p>Stereotype特性最早出现在J2EE6中（忘记是哪个JSR提出的了），可以理解为围绕着“元数据”功能而发展出来的一种设计模式，虽然我很难说清楚他属于23个设计模式中的哪一个，但是这确实已经是一种约定俗成的做法，只要看到Stereotype就应该像看到“Factory——工厂模式”、“Adapter——适配器模式”、“Facade——外观模式”一样，一眼就知道他的作用。</p><p>Stereotype特性的目标就是为“组合模式的分层系统”按层标记一个类的功能。所谓的“组合模式的分层系统”实际上就是我们常用的Controller-Service-Dao这种分层模式，只不过有些系统可能会多几层（比如Controller和Service之间加个RPC框架什么的）。根据Stereotype特性的Java官网原文介绍，它是一个用来标记注解的注解（annotating annotation）。一个注解如果被@Stereotype标记证明他提供Stereotype模式的功能，例如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Stereotype @Target(TYPE) </span><br><span class="line">@Retention(RUNTIME) </span><br><span class="line">@interface controller &#123;&#125;@Stereotype @Target(TYPE) </span><br><span class="line">@Retention(RUNTIME) </span><br><span class="line">@interface service &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后我们在使用时可以为不同层的类打上这些标记，表示他们属于不同的分层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserService&#123;&#125;@Serviceclass UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;@Controllerclass UseController&#123;@Autowired</span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类的实例可能会被用于0到多个分层中（比如Spring的一个Bean既可以是Controller也可以是Service，只要标记对应的注解即可），但是通常情况下一个类最多只会用在一个分层中使用。简单的说Stereotype特性就是用注解来告诉框架某个类是属于系统功能中的哪一层。</p><p>Java的文档上要求提供Stereotype特性的注解需要用@Stereotype来标记。但是Spring的开发大神并没有理会这个事，@Component并没有使用@Stereotype来标记，但是他确实提供了Stereotype的模式。</p><p>在Stereotype模式下，Spring核心工程为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解。我们按照Stereotype的模式为对应的类标记3个注解，然后在引入MVC、ORM、JPA相关的框架之后这些注解会告诉框架对应的类扮演着什么样的功能角色，框架就能很清晰的根据注解提供相关的功能服务。</p><p>例如引入Spring-webmvc之后，一个类如果用@Controller注解标记了之后框架就知道他们都是处理前端请求的，MVC框架就会为他提供RequestMapping之类的功能。随后我们需要将框架调整为WebFlux，基本上直接更换依赖的Jar包就可以了，因为大家都是按照一个模式来开发的。</p><p>所以，如果我们的某个类是用于指定的分层功能，那么最好使用<em>org.springframework.stereotype</em>包中的注解来标记他所属的分层。如果类没有明确的功能（例如用于存储配置数据的类，或者Helper类），使用@Bean等其他方式添加到容器中更合适（@Bean会在后续的文章中介绍）。</p><p>使用Stereotype特性来标记分层，还有一个好处是即使工程的结构再复杂多样，都可以很轻松的使用注解（Annotation）来实现拦截器或者AOP功能。因为我们能够很清晰的知道每个分层的作用，开发AOP的功能就非常便利。</p><h2 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a>扫描配置</h2><p>本文开篇使用了一个简单的例子说明使用<a href="context:component-scan">context:component-scan</a>扫描功能来自动添加被注解标记的Bean。除了使用base-package属性还有其他的标签来控制扫描的路径。</p><p><a href="context:include-filter">context:include-filter</a>和<a href="context:exclude-filter">context:exclude-filter</a>标签用来指定包含和排除的过滤规则。他们提供2个参数——type和expression，用来指定过滤类型和过滤参数，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type=&quot;regex&quot;</span><br><span class="line">                expression=&quot;.*Stub.*Repository&quot;/&gt;</span><br><span class="line">        &lt;context:exclude-filter type=&quot;annotation&quot;</span><br><span class="line">                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>此外还可以使用use-default-filters属性来指定是否扫描默认注解（<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller、``@Configuration</code>），默认值为ture。如果设定成false，需要我们在include-filter中增加对应的annotation。</p><p>除了使用XML配置，还可以使用@ComponentScan注解来指定扫描的路径，他提供和XML配置一样的功能。在后续的文章会介绍纯Java配置的功能。</p><p>关于扫描的详细说明见官网的过滤规则说明。</p><h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h2><p>和普通的Bean一样，我们也可以在@Component上添加注解来指定Bean在IoC容器的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;@Service(&quot;implementNameService&quot;)public class NameServiceImpl implements NameService&#123;@Override</span><br><span class="line">public String getName() &#123;return &quot;This is My Component&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在容器中这个Bean的名称被命名为”implementNameService”。除了直接在注解上添加内容，我们还可以实现 BeanNameGenerator 接口来实现全局的命名方法。看下面这个例子。（源码请到<a href="https://gitee.com/chkui-com/spring-core-sample%E8%87%AA%E8%A1%8Cclone%EF%BC%8C%E4%BE%8B%E5%AD%90%E5%9C%A8*chkui.springcore.example.hybrid.component*%E5%8C%85%E4%B8%AD%E3%80%82%EF%BC%89">https://gitee.com/chkui-com/spring-core-sample自行clone，例子在*chkui.springcore.example.hybrid.component*包中。）</a></p><p>首先在XML中使用 “name-generator” 指定名称的生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:component-scan</span><br><span class="line">base-package=&quot;chkui.springcore.example.hybrid.component.bean&quot;</span><br><span class="line">name-generator=&quot;chkui.springcore.example.hybrid.component.bean.NameGenerator&quot; /&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>然后编写我们的命名生成规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;public class NameGenerator implements BeanNameGenerator &#123;@Override</span><br><span class="line">public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">AnnotatedBeanDefinition annotdef = AnnotatedBeanDefinition.class.cast(definition);</span><br><span class="line">AnnotationMetadata meta = annotdef.getMetadata();//生成规则:如果已经命名不做任何调整，如果未命名则在类名车后面增加”_NoDefinedName“字符串</span><br><span class="line">return Optional.of(meta).map(met -&gt; met.getAnnotationTypes()).map(set -&gt; set.toArray(new String[] &#123;&#125;))</span><br><span class="line">.map(array -&gt; array[0]).map(name -&gt; meta.getAnnotationAttributes(name)).map(entry -&gt; entry.get(&quot;value&quot;))</span><br><span class="line">.map(obj -&gt; &quot;&quot;.equals(obj) ? null : obj).orElse(definition.getBeanClassName() + &quot;_NoDefinedName&quot;)</span><br><span class="line">.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用索引提升启动速度"><a href="#使用索引提升启动速度" class="headerlink" title="使用索引提升启动速度"></a>使用索引提升启动速度</h2><p>通常情况下，即使是对整个classpath进行扫描并不会占用太多的时间，但是某些应用对启动时间有极高的要求，对此Spring提供了索引功能。索引功能并不复杂，就是第一次扫描之后生成一个静态文件记录所有的组件，然后下一次扫描就直接读取文件中的内容，而不去执行扫描过程。</p><p>首先引入spring-context-indexer包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;&lt;/dependencies&gt;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly(&quot;org.springframework:spring-context-indexer:5.0.7.RELEASE&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在运行后会生成一个 META-INF&#x2F;spring.components 的文件，之后只要运行工程发现这个文件都会直接使用他。可以通过环境变量或工程根目录的spring.properties中设置spring.index.ignore&#x3D;ture来禁用这个功能。</p><p>这个功能如果没有什么明确的需求，慎重使用，会提高工程的管理成本。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-论认知，论重构</title>
      <link href="/2018/07/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00721/"/>
      <url>/2018/07/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00721/</url>
      
        <content type="html"><![CDATA[<p>领导力是什么，领导力是领导大家去到从未到达过的地方</p><hr><p>论认知！</p><p>1、企业最大的资产是人，企业经营上最大的成本是人的认知力的成本。<br>2、可以花钱买到能干这个事情的人或者技术，但是认知力却是无法花钱培养的。<br>3、认知力就是你知道的和你看到的以及你经历过的，也包括你推理出来的，起源于自我脑力的不断进化，不断自我批判和升级，是不能停下来的。<br>4、一个很强认知力的人同时具备高度的事物分解能力，认知力的形成需要一个很长的过程。</p><p>论重构！<br>1、技术的重构:为了满足产品更新的速度而做出技术架构、技术组件、技术选型等的重构。<br>2、产品的重构:为了满足业务的利益目标而做出的产品功能、产品模式、产品方向等的重构。<br>3、组织重构:分为弹性重构和强制重构，弹性重构是在组织利益面前具体的动作触发完成，强制重构是战略性大规模调整是为了“未来”而做。<br>4、个人重构:是基于个人沉淀在短期、中长期而做出的方向、知识体系上的重构。<br>……<br>“重构”是痛苦的事情，但“重构”比迭代更具革命性和彻底性，应该取代所谓“迭代”的用法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-六商原则</title>
      <link href="/2018/07/17/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00717/"/>
      <url>/2018/07/17/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00717/</url>
      
        <content type="html"><![CDATA[<p>高层领导应该具备的六商原则</p><p>分别是智商、情商、韧商、学商、融商和形商。</p><p>（1）智商，同志者同谋，同智者相谋；</p><p>（2）情商，思方行圆，说别人爱听之言，做他人舒坦之事，当成人之美；</p><p>（3）韧商，倾否，而非否倾。自我反省；</p><p>笔记侠注：《易经》否卦有句爻辞“倾否，而非否倾”。颠覆封闭局面，而不是被封闭局面所颠覆。</p><p>（4）学商，学习如春起之苗，辍学如磨刀之石；</p><p>（5）融商，就是融合资源的能力。要学会整合资源，也就是羊毛出在牛身上，猪来买单；</p><p>（6）形商，是不是品牌不重要，像不像品牌才重要。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型总结</title>
      <link href="/2018/07/08/java/%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/08/java/%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型总结"><a href="#Java内存模型总结" class="headerlink" title="Java内存模型总结"></a>Java内存模型总结</h2><p>Hollis <a href="javascript:void(0);">架构师小秘圈</a> <em>7月5日</em></p><p>作者：Hollis，阿里资深攻城狮</p><p>来自：Hollis</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为什么要有内存模型</p><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p><h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><blockquote><p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p></blockquote><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p><p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p><p>那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><blockquote><p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p></blockquote><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p><p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p><p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><blockquote><p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p></blockquote><p>单核CPU只含有一套L1，L2，L3缓存；</p><p>如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><blockquote><p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p><p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p><p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p><p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p></blockquote><p>下图为一个单CPU双核的缓存结构。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjacnr9mmj20ly0bd7wh.jpg"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><blockquote><p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p><p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjaeger4aj20mj0am7wh.jpg"></p><h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><blockquote><p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p></blockquote><p>并发编程的问题</p><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p><p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>什么是内存模型</p><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>什么是Java内存模型</p><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf%EF%BC%89">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjafgo4uoj20b10abh1f.jpg"></p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p><strong>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</strong></p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Java内存模型的实现</p><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120537&idx=1&sn=f56201217c0ca6fde45ee12965b56296&chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&scene=21#wechat_redirect">synchronized的实现原理</a>文章中，介绍过，这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像<code>synchronized</code>关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用<code>synchronized</code>的原因。</p><p>但是<code>synchronized</code>是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录摘要-互联网4个关键词</title>
      <link href="/2018/07/08/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00708/"/>
      <url>/2018/07/08/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00708/</url>
      
        <content type="html"><![CDATA[<p>  互联网+时代的四个关键词，分别是专注、极致、口碑和快速，这四大特点</p><hr><p>极致有三个支撑点，<br>第一叫产品思维。’<br>第二个叫痛点思维。我们要了解客户的三个点，叫痛点、痒点和兴奋点。<br>第三个叫尖叫点思维。你的产品一定有一款，哪怕是一点点也行，让人产生尖叫的感觉。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11笔记</title>
      <link href="/2018/07/06/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00706/"/>
      <url>/2018/07/06/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00706/</url>
      
        <content type="html"><![CDATA[<p>  7-11 的核心是：绝大多数都是专用厂商，保证产能和品质；斥巨资（约 180 亿RMB）投入信息系统帮助精准选品、及时订货、门店管理与全链条信息同步；自品牌产品占 7 成以上，每年 SKU 替换率 70%，保证总能让大家买到又喜欢又新颖的产品。7-11 的成长路径非常值得深入研究，国内便利店只学到了门店的形态和关东煮！！背后的学问都在 IT 系统投入和厂商、物流、配送的后端建设。</p><hr><p>流量<em>转化率</em>客单价*复购率 X （付费会员体系） Y（内部员工赋能） &#x3D; Costco</p><hr><p>在互联网技术还没有普及的时候，7-11已经在使用细分的键盘。在结账那一刻，营业员会输入顾客的性别和年龄信息，小男，中男、青男、壮男、老男，多少岁的；小女、中女、青女、壮女、老女，多少岁的。</p><hr><p>从“众人”到“每人”，打造了“新个体”；</p><p>从“长尾”到“头牌”，打造了“新内容”；</p><p>从“低频”到“高频”，打造了“新连接”。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录摘要0705</title>
      <link href="/2018/07/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00705/"/>
      <url>/2018/07/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00705/</url>
      
        <content type="html"><![CDATA[<p>  战略不是不重要，而是很重要。但是怎么看待战略本身，以及如何在不断调整中推动战略执行更为重要。</p><hr><p>军队里流行这样一句话：战术有千百条，头一条就是肯打，离开了肯打，其他的全是白扯。理论玩得非常漂亮，天花乱坠，离开了肯打，一切皆空。</p><p>成功最大的敌人，不是没有机会，而是没有立刻行动。</p><hr><p>取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣</p><hr><h2 id="因为熵减的核心价值就是激活组织和组织中的人。"><a href="#因为熵减的核心价值就是激活组织和组织中的人。" class="headerlink" title="因为熵减的核心价值就是激活组织和组织中的人。"></a>因为熵减的核心价值就是激活组织和组织中的人。</h2><p>就是因为不确定的未来对战略制定的挑战越来越大，做到大致正确相当不容易，决策执行需要充满活力，决策制定、决策落实、决策调整更需要充满活力，用决策层的开放、努力、敢于自我批判、亲力亲为来弥补可能的战略能力缺失。’</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 演变总结</title>
      <link href="/2018/06/30/%E7%BD%91%E7%BB%9C/%20HTTP%20%E6%BC%94%E5%8F%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/30/%E7%BD%91%E7%BB%9C/%20HTTP%20%E6%BC%94%E5%8F%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HTTP-x2F-0-9"><a href="#一、HTTP-x2F-0-9" class="headerlink" title="一、HTTP&#x2F;0.9"></a>一、HTTP&#x2F;0.9</h2><p>HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></blockquote><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>服务器发送完毕，就关闭TCP连接。</p><h2 id="二、HTTP-x2F-1-0"><a href="#二、HTTP-x2F-1-0" class="headerlink" title="二、HTTP&#x2F;1.0"></a>二、HTTP&#x2F;1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP&#x2F;1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，这个格式与0.9版有很大变化。</p><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><blockquote><ul><li>text&#x2F;plain</li><li>text&#x2F;html</li><li>text&#x2F;css</li><li>image&#x2F;jpeg</li><li>image&#x2F;png</li><li>image&#x2F;svg+xml</li><li>audio&#x2F;mp4</li><li>video&#x2F;mp4</li><li>application&#x2F;javascript</li><li>application&#x2F;pdf</li><li>application&#x2F;zip</li><li>application&#x2F;atom+xml</li></ul></blockquote><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p><p>除了预定义的类型，厂商也可以自定义类型。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure></blockquote><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p><p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt; </span><br></pre></td></tr></table></figure></blockquote><h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate</span><br></pre></td></tr></table></figure></blockquote><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP&#x2F;1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></blockquote><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></blockquote><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2 id="三、HTTP-x2F-1-1"><a href="#三、HTTP-x2F-1-1" class="headerlink" title="三、HTTP&#x2F;1.1"></a>三、HTTP&#x2F;1.1</h2><p>1997年1月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></blockquote><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure></blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></blockquote><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></blockquote><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承。</p><h2 id="五、HTTP-x2F-2"><a href="#五、HTTP-x2F-2" class="headerlink" title="五、HTTP&#x2F;2"></a>五、HTTP&#x2F;2</h2><p>2015年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3。</p><h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP&#x2F;1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP&#x2F;2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP&#x2F;2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP&#x2F;2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有感随笔</title>
      <link href="/2018/06/21/%E6%9D%82%E8%AE%B0/%E6%9C%89%E6%84%9F%E9%9A%8F%E7%AC%94/"/>
      <url>/2018/06/21/%E6%9D%82%E8%AE%B0/%E6%9C%89%E6%84%9F%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>分享一些自己的理解：</p><p>1.消费市场正在以商品为核心转向以人为核心，更优的用户体验，让用户有专属感，有“谈资”；</p><p>2.企业思考的思路应该是不断的优化端到端的体验，形成闭环；</p><p>3.更优的供应链体系一定是这一闭环上的关键点；</p><p>对未来有助优化供应链体系的一些思路和见解：</p><p>1.SDN,IPv6,HTTP&#x2F;2的快速普及发展，降低了物联网的成本（通信，安全等）必将带来新一波物联网风潮；</p><p>2.区块链的玩好的话，在解决物联网，设备安全，隐私，协同工作等痛点上会产生更多的思路；</p><p>3.供应链体系，新零售借助于物联网的发展，配合区块链的应用必然产生更多的玩法，可能性；</p><p>4.目前形成闭环的成本还比较高，但未来潜力巨大；</p><p>5.未来真的很近；</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存机制及原理总结</title>
      <link href="/2018/05/19/%E7%BD%91%E7%BB%9C/%20HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/19/%E7%BD%91%E7%BB%9C/%20HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="彻底弄懂HTTP缓存机制及原理"><a href="#彻底弄懂HTTP缓存机制及原理" class="headerlink" title="彻底弄懂HTTP缓存机制及原理"></a><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></h1><p>感谢作者！</p><p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端架构师技术汇总</title>
      <link href="/2018/05/02/%E6%9D%82%E8%AE%B0/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/"/>
      <url>/2018/05/02/%E6%9D%82%E8%AE%B0/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="后端架构师技术汇总"><a href="#后端架构师技术汇总" class="headerlink" title="后端架构师技术汇总"></a>后端架构师技术汇总</h1><p>原文链接：<a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">github.com</a></p><blockquote><p>同步到博客来，随时关注github~</p></blockquote><p><strong>最后更新于20180502</strong></p><ul><li>数据结构<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2598%259F%25E5%2588%2597">队列</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259B%2586%25E5%2590%2588">集合</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2593%25BE%25E8%25A1%25A8%25E6%2595%25B0%25E7%25BB%2584">链表、数组</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AD%2597%25E5%2585%25B8%25E5%2585%25B3%25E8%2581%2594%25E6%2595%25B0%25E7%25BB%2584">字典、关联数组</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A0%2588">栈</a></li><li>树<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%258C%25E5%2585%25A8%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">完全二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%25B3%25E8%25A1%25A1%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">平衡二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%258F%2589%25E6%259F%25A5%25E6%2589%25BE%25E6%25A0%2591bst">二叉查找树（BST）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25A2%25E9%25BB%2591%25E6%25A0%2591">红黑树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23b-bb%25E6%25A0%2591">B-，B+，B*树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23lsm-%25E6%25A0%2591">LSM 树</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23bitset">BitSet</a></li></ul></li><li>常用算法<ul><li>排序、查找算法<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2580%2589%25E6%258B%25A9%25E6%258E%2592%25E5%25BA%258F">选择排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F">冒泡排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258F%2592%25E5%2585%25A5%25E6%258E%2592%25E5%25BA%258F">插入排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BF%25AB%25E9%2580%259F%25E6%258E%2592%25E5%25BA%258F">快速排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BD%2592%25E5%25B9%25B6%25E6%258E%2592%25E5%25BA%258F">归并排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%258C%25E5%25B0%2594%25E6%258E%2592%25E5%25BA%258F">希尔排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A0%2586%25E6%258E%2592%25E5%25BA%258F">堆排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25A1%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F">计数排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A1%25B6%25E6%258E%2592%25E5%25BA%258F">桶排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259F%25BA%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F">基数排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE">二分查找</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java-%25E4%25B8%25AD%25E7%259A%2584%25E6%258E%2592%25E5%25BA%258F%25E5%25B7%25A5%25E5%2585%25B7">Java 中的排序工具</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%2583%25E9%259A%2586%25E8%25BF%2587%25E6%25BB%25A4%25E5%2599%25A8">布隆过滤器</a></li><li>字符串比较<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kmp-%25E7%25AE%2597%25E6%25B3%2595">KMP 算法</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B7%25B1%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588%25E5%25B9%25BF%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588">深度优先、广度优先</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595">贪心算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%259E%25E6%25BA%25AF%25E7%25AE%2597%25E6%25B3%2595">回溯算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2589%25AA%25E6%259E%259D%25E7%25AE%2597%25E6%25B3%2595">剪枝算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592">动态规划</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%25B4%25E7%25B4%25A0%25E8%25B4%259D%25E5%258F%25B6%25E6%2596%25AF">朴素贝叶斯</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258E%25A8%25E8%258D%2590%25E7%25AE%2597%25E6%25B3%2595">推荐算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%2580%25E5%25B0%258F%25E7%2594%259F%25E6%2588%2590%25E6%25A0%2591%25E7%25AE%2597%25E6%25B3%2595">最小生成树算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%2580%25E7%259F%25AD%25E8%25B7%25AF%25E5%25BE%2584%25E7%25AE%2597%25E6%25B3%2595">最短路径算法</a></li></ul></li><li>并发<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%259A%25E7%25BA%25BF%25E7%25A8%258B">多线程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25BF%25E7%25A8%258B%25E5%25AE%2589%25E5%2585%25A8">线程安全</a></li><li>一致性、事务<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258B%25E5%258A%25A1-acid-%25E7%2589%25B9%25E6%2580%25A7">事务 ACID 特性</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258B%25E5%258A%25A1%25E7%259A%2584%25E9%259A%2594%25E7%25A6%25BB%25E7%25BA%25A7%25E5%2588%25AB">事务的隔离级别</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mvcc">MVCC</a></li></ul></li><li>锁<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java%25E4%25B8%25AD%25E7%259A%2584%25E9%2594%2581%25E5%2592%258C%25E5%2590%258C%25E6%25AD%25A5%25E7%25B1%25BB">Java中的锁和同步类</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25AC%25E5%25B9%25B3%25E9%2594%2581--%25E9%259D%259E%25E5%2585%25AC%25E5%25B9%25B3%25E9%2594%2581">公平锁 &amp; 非公平锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2582%25B2%25E8%25A7%2582%25E9%2594%2581">悲观锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B9%2590%25E8%25A7%2582%25E9%2594%2581--cas">乐观锁 &amp; CAS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23aba-%25E9%2597%25AE%25E9%25A2%2598">ABA 问题</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23copyonwrite%25E5%25AE%25B9%25E5%2599%25A8">CopyOnWrite容器</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ringbuffer">RingBuffer</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258F%25AF%25E9%2587%258D%25E5%2585%25A5%25E9%2594%2581--%25E4%25B8%258D%25E5%258F%25AF%25E9%2587%258D%25E5%2585%25A5%25E9%2594%2581">可重入锁 &amp; 不可重入锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%2592%25E6%2596%25A5%25E9%2594%2581--%25E5%2585%25B1%25E4%25BA%25AB%25E9%2594%2581">互斥锁 &amp; 共享锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25AD%25BB%25E9%2594%2581">死锁</a></li></ul></li></ul></li><li>操作系统<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%258E%259F%25E7%2590%2586">计算机原理</a></li><li>CPU<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%259A%25E7%25BA%25A7%25E7%25BC%2593%25E5%25AD%2598">多级缓存</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259B%25E7%25A8%258B">进程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25BF%25E7%25A8%258B">线程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%258F%25E7%25A8%258B">协程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23linux">Linux</a></li></ul></li><li>设计模式<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E7%259A%2584%25E5%2585%25AD%25E5%25A4%25A7%25E5%258E%259F%25E5%2588%2599">设计模式的六大原则</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%2323%25E7%25A7%258D%25E5%25B8%25B8%25E8%25A7%2581%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F">23种常见设计模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%259C%25BA%25E6%2599%25AF">应用场景</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F">单例模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25A3%25E4%25BB%25BB%25E9%2593%25BE%25E6%25A8%25A1%25E5%25BC%258F">责任链模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mvc">MVC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ioc">IOC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23aop">AOP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23uml">UML</a></li><li>微服务思想<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%25B7%25E5%25A8%2581%25E5%25AE%259A%25E5%25BE%258B">康威定律</a></li></ul></li></ul></li><li>运维 &amp; 统计 &amp; 技术支持<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%25B8%25E8%25A7%2584%25E7%259B%2591%25E6%258E%25A7">常规监控</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23apm">APM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%259F%25E8%25AE%25A1%25E5%2588%2586%25E6%259E%2590">统计分析</a></li><li>持续集成(CI&#x2F;CD)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23jenkins">Jenkins</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%258E%25AF%25E5%25A2%2583%25E5%2588%2586%25E7%25A6%25BB">环境分离</a></li></ul></li><li>自动化运维<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ansible">Ansible</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23puppet">puppet</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23chef">chef</a></li></ul></li><li>测试<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tdd-%25E7%2590%2586%25E8%25AE%25BA">TDD 理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E5%2585%2583%25E6%25B5%258B%25E8%25AF%2595">单元测试</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258E%258B%25E5%258A%259B%25E6%25B5%258B%25E8%25AF%2595">压力测试</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25A8%25E9%2593%25BE%25E8%25B7%25AF%25E5%258E%258B%25E6%25B5%258B">全链路压测</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ab-%25E7%2581%25B0%25E5%25BA%25A6%25E8%2593%259D%25E7%25BB%25BF%25E6%25B5%258B%25E8%25AF%2595">A&#x2F;B 、灰度、蓝绿测试</a></li></ul></li><li>虚拟化<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kvm">KVM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23xen">Xen</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openvz">OpenVZ</a></li></ul></li><li>容器技术<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23docker">Docker</a></li></ul></li><li>云技术<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openstack">OpenStack</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23devops">DevOps</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2596%2587%25E6%25A1%25A3%25E7%25AE%25A1%25E7%2590%2586">文档管理</a></li></ul></li><li>中间件<ul><li>Web Server<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23nginx">Nginx</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openresty">OpenResty</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23apache-httpd">Apache Httpd</a></li><li>Tomcat<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E5%258E%259F%25E7%2590%2586">架构原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25A1%2588">调优方案</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23jetty">Jetty</a></li></ul></li><li>缓存<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%25AC%25E5%259C%25B0%25E7%25BC%2593%25E5%25AD%2598">本地缓存</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25A2%25E6%2588%25B7%25E7%25AB%25AF%25E7%25BC%2593%25E5%25AD%2598">客户端缓存</a></li><li>服务端缓存<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23memcached">Memcached</a></li><li>Redis<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584">架构</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%259E%25E6%2594%25B6%25E7%25AD%2596%25E7%2595%25A5">回收策略</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tair">Tair</a></li></ul></li><li>消息队列<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B6%2588%25E6%2581%25AF%25E6%2580%25BB%25E7%25BA%25BF">消息总线</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B6%2588%25E6%2581%25AF%25E7%259A%2584%25E9%25A1%25BA%25E5%25BA%258F">消息的顺序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rabbitmq">RabbitMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rocketmq">RocketMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23activemq">ActiveMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kafka">Kafka</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23redis-%25E6%25B6%2588%25E6%2581%25AF%25E6%258E%25A8%25E9%2580%2581">Redis 消息推送</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23zeromq">ZeroMQ</a></li></ul></li><li>定时调度<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E6%259C%25BA%25E5%25AE%259A%25E6%2597%25B6%25E8%25B0%2583%25E5%25BA%25A6">单机定时调度</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E5%25AE%259A%25E6%2597%25B6%25E8%25B0%2583%25E5%25BA%25A6">分布式定时调度</a></li></ul></li><li>RPC<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23dubbo">Dubbo</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23thrift">Thrift</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23grpc">gRPC</a></li></ul></li><li>数据库中间件<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sharding-jdbc">Sharding Jdbc</a></li></ul></li><li>日志系统<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2597%25A5%25E5%25BF%2597%25E6%2590%259C%25E9%259B%2586">日志搜集</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2585%258D%25E7%25BD%25AE%25E4%25B8%25AD%25E5%25BF%2583">配置中心</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23api-%25E7%25BD%2591%25E5%2585%25B3">API 网关</a></li></ul></li><li>网络<ul><li>协议<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23osi-%25E4%25B8%2583%25E5%25B1%2582%25E5%258D%258F%25E8%25AE%25AE">OSI 七层协议</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tcpip">TCP&#x2F;IP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23http">HTTP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23http20">HTTP2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23https">HTTPS</a></li></ul></li><li>网络模型<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23epoll">Epoll</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java-nio">Java NIO</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kqueue">kqueue</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259E%25E6%258E%25A5%25E5%2592%258C%25E7%259F%25AD%25E8%25BF%259E%25E6%258E%25A5">连接和短连接</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A1%2586%25E6%259E%25B6">框架</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259Dzero-copy">零拷贝（Zero-copy）</a></li><li>序列化(二进制协议)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hessian">Hessian</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23protobuf">Protobuf</a></li></ul></li></ul></li><li>数据库<ul><li>基础理论<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E8%25AE%25BE%25E8%25AE%25A1%25E7%259A%2584%25E4%25B8%2589%25E5%25A4%25A7%25E8%258C%2583%25E5%25BC%258F">数据库设计的三大范式</a></li></ul></li><li>MySQL<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258E%259F%25E7%2590%2586">原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23innodb">InnoDB</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BC%2598%25E5%258C%2596">优化</a></li><li>索引<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2581%259A%25E9%259B%2586%25E7%25B4%25A2%25E5%25BC%2595-%25E9%259D%259E%25E8%2581%259A%25E9%259B%2586%25E7%25B4%25A2%25E5%25BC%2595">聚集索引, 非聚集索引</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%258D%25E5%2590%2588%25E7%25B4%25A2%25E5%25BC%2595">复合索引</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2587%25AA%25E9%2580%2582%25E5%25BA%2594%25E5%2593%2588%25E5%25B8%258C%25E7%25B4%25A2%25E5%25BC%2595ahi">自适应哈希索引(AHI)</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23explain">explain</a></li></ul></li><li>NoSQL<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mongodb">MongoDB</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hbase">Hbase</a></li></ul></li></ul></li><li>搜索引擎<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2590%259C%25E7%25B4%25A2%25E5%25BC%2595%25E6%2593%258E%25E5%258E%259F%25E7%2590%2586">搜索引擎原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23lucene">Lucene</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23elasticsearch">Elasticsearch</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23solr">Solr</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sphinx">sphinx</a></li></ul></li><li>性能<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2580%25A7%25E8%2583%25BD%25E4%25BC%2598%25E5%258C%2596%25E6%2596%25B9%25E6%25B3%2595%25E8%25AE%25BA">性能优化方法论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25B9%25E9%2587%258F%25E8%25AF%2584%25E4%25BC%25B0">容量评估</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23cdn-%25E7%25BD%2591%25E7%25BB%259C">CDN 网络</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259E%25E6%258E%25A5%25E6%25B1%25A0">连接池</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2580%25A7%25E8%2583%25BD%25E8%25B0%2583%25E4%25BC%2598">性能调优</a></li></ul></li><li>大数据<ul><li>流式计算<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23storm">Storm</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23flink">Flink</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kafka-stream">Kafka Stream</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%259C%25BA%25E6%2599%25AF-1">应用场景</a></li></ul></li><li>Hadoop<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hdfs">HDFS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mapreduce">MapReduce</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23yarn">Yarn</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23spark">Spark</a></li></ul></li><li>安全<ul><li>web 安全<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23xss">XSS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23csrf">CSRF</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sql-%25E6%25B3%25A8%25E5%2585%25A5">SQL 注入</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hash-dos">Hash Dos</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2584%259A%25E6%259C%25AC%25E6%25B3%25A8%25E5%2585%25A5">脚本注入</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25BC%258F%25E6%25B4%259E%25E6%2589%25AB%25E6%258F%258F%25E5%25B7%25A5%25E5%2585%25B7">漏洞扫描工具</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581">验证码</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ddos-%25E9%2598%25B2%25E8%258C%2583">DDoS 防范</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%2594%25A8%25E6%2588%25B7%25E9%259A%2590%25E7%25A7%2581%25E4%25BF%25A1%25E6%2581%25AF%25E4%25BF%259D%25E6%258A%25A4">用户隐私信息保护</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%258F%25E5%2588%2597%25E5%258C%2596%25E6%25BC%258F%25E6%25B4%259E">序列化漏洞</a></li><li>加密解密<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AF%25B9%25E7%25A7%25B0%25E5%258A%25A0%25E5%25AF%2586">对称加密</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2593%2588%25E5%25B8%258C%25E7%25AE%2597%25E6%25B3%2595">哈希算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259D%259E%25E5%25AF%25B9%25E7%25A7%25B0%25E5%258A%25A0%25E5%25AF%2586">非对称加密</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E5%25AE%2589%25E5%2585%25A8">服务器安全</a></li><li>数据安全<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%25B0%25E6%258D%25AE%25E5%25A4%2587%25E4%25BB%25BD">数据备份</a></li></ul></li><li>网络隔离<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2586%2585%25E5%25A4%2596%25E7%25BD%2591%25E5%2588%2586%25E7%25A6%25BB">内外网分离</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%2599%25BB%25E5%25BD%2595%25E8%25B7%25B3%25E6%259D%25BF%25E6%259C%25BA">登录跳板机</a></li></ul></li><li>授权、认证<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rbac">RBAC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23oauth20">OAuth2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258F%258C%25E5%259B%25A0%25E7%25B4%25A0%25E8%25AE%25A4%25E8%25AF%25812fa">双因素认证（2FA）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E7%2582%25B9%25E7%2599%25BB%25E5%25BD%2595sso">单点登录(SSO)</a></li></ul></li></ul></li><li>常用开源框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E6%25BA%2590%25E5%258D%258F%25E8%25AE%25AE">开源协议</a></li><li>日志框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23log4jlog4j2">Log4j、Log4j2</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23logback">Logback</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23orm">ORM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BD%2591%25E7%25BB%259C%25E6%25A1%2586%25E6%259E%25B6">网络框架</a></li><li>Web 框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23spring-%25E5%25AE%25B6%25E6%2597%258F">Spring 家族</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7%25E6%25A1%2586%25E6%259E%25B6">工具框架</a></li></ul></li><li>分布式设计<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%25A9%25E5%25B1%2595%25E6%2580%25A7%25E8%25AE%25BE%25E8%25AE%25A1">扩展性设计</a></li><li>稳定性 &amp; 高可用<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25A1%25AC%25E4%25BB%25B6%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1">硬件负载均衡</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BD%25AF%25E4%25BB%25B6%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1">软件负载均衡</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2599%2590%25E6%25B5%2581">限流</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%25B1%2582%25E5%25AE%25B9%25E7%2581%25BE">应用层容灾</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B7%25A8%25E6%259C%25BA%25E6%2588%25BF%25E5%25AE%25B9%25E7%2581%25BE">跨机房容灾</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25B9%25E7%2581%25BE%25E6%25BC%2594%25E7%25BB%2583%25E6%25B5%2581%25E7%25A8%258B">容灾演练流程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%25B3%25E6%25BB%2591%25E5%2590%25AF%25E5%258A%25A8">平滑启动</a></li></ul></li><li>数据库扩展<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AF%25BB%25E5%2586%2599%25E5%2588%2586%25E7%25A6%25BB%25E6%25A8%25A1%25E5%25BC%258F">读写分离模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E7%2589%2587%25E6%25A8%25A1%25E5%25BC%258F">分片模式</a></li></ul></li><li>服务治理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E6%25B3%25A8%25E5%2586%258C%25E4%25B8%258E%25E5%258F%2591%25E7%258E%25B0">服务注册与发现</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E8%25B7%25AF%25E7%2594%25B1%25E6%258E%25A7%25E5%2588%25B6">服务路由控制</a></li></ul></li><li>分布式一致<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23cap-%25E4%25B8%258E-base-%25E7%2590%2586%25E8%25AE%25BA">CAP 与 BASE 理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2594%2581">分布式锁</a></li><li>分布式一致性算法<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23paxos">PAXOS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23zab">Zab</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23raft">Raft</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23gossip">Gossip</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25A4%25E9%2598%25B6%25E6%25AE%25B5%25E6%258F%2590%25E4%25BA%25A4%25E5%25A4%259A%25E9%2598%25B6%25E6%25AE%25B5%25E6%258F%2590%25E4%25BA%25A4">两阶段提交、多阶段提交</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%2582%25E7%25AD%2589">幂等</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E4%25B8%2580%25E8%2587%25B4%25E6%2596%25B9%25E6%25A1%2588">分布式一致方案</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F-leader-%25E8%258A%2582%25E7%2582%25B9%25E9%2580%2589%25E4%25B8%25BE">分布式 Leader 节点选举</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tcctryconfirmcancel-%25E6%259F%2594%25E6%2580%25A7%25E4%25BA%258B%25E5%258A%25A1">TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F">分布式文件系统</a></li><li>唯一ID 生成<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25A8%25E5%25B1%2580%25E5%2594%25AF%25E4%25B8%2580id">全局唯一ID</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash%25E7%25AE%2597%25E6%25B3%2595">一致性Hash算法</a></li></ul></li><li>设计思想 &amp; 开发模式<ul><li>DDD(Domain-driven Design - 领域驱动设计)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2591%25BD%25E4%25BB%25A4%25E6%259F%25A5%25E8%25AF%25A2%25E8%2581%258C%25E8%25B4%25A3%25E5%2588%2586%25E7%25A6%25BBcqrs">命令查询职责分离(CQRS)</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25AB%25E8%25A1%2580%25E5%2585%2585%25E8%25A1%2580%25E6%25A8%25A1%25E5%259E%258B">贫血，充血模型</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23actor-%25E6%25A8%25A1%25E5%25BC%258F">Actor 模式</a></li><li>响应式编程<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23reactor">Reactor</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rxjava">RxJava</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23vertx">Vert.x</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23dodaf20">DODAF2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23serverless">Serverless</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23service-mesh">Service Mesh</a></li></ul></li><li>项目管理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E8%25AF%2584%25E5%25AE%25A1">架构评审</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2587%258D%25E6%259E%2584">重构</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581%25E8%25A7%2584%25E8%258C%2583">代码规范</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581-review">代码 Review</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rup">RUP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%259C%258B%25E6%259D%25BF%25E7%25AE%25A1%25E7%2590%2586">看板管理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23scrum">SCRUM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%258F%25E6%258D%25B7%25E5%25BC%2580%25E5%258F%2591">敏捷开发</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%2581%25E9%2599%2590%25E7%25BC%2596%25E7%25A8%258Bxp">极限编程（XP）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%2593%25E5%25AF%25B9%25E7%25BC%2596%25E7%25A8%258B">结对编程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23fmea%25E7%25AE%25A1%25E7%2590%2586%25E6%25A8%25A1%25E5%25BC%258F">FMEA管理模式</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2580%259A%25E7%2594%25A8%25E4%25B8%259A%25E5%258A%25A1%25E6%259C%25AF%25E8%25AF%25AD">通用业务术语</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258A%2580%25E6%259C%25AF%25E8%25B6%258B%25E5%258A%25BF">技术趋势</a></li><li>政策、法规<ul><li>法律<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25A5%25E6%25A0%25BC%25E9%2581%25B5%25E5%25AE%2588%25E5%2588%2591%25E6%25B3%2595253%25E6%25B3%2595%25E6%259D%25A1">严格遵守刑法253法条</a></li></ul></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E5%25B8%2588%25E7%25B4%25A0%25E8%25B4%25A8">架构师素质</a></li><li>团队管理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258B%259B%25E8%2581%2598">招聘</a></li></ul></li><li>资讯<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25A1%258C%25E4%25B8%259A%25E8%25B5%2584%25E8%25AE%25AF">行业资讯</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25AC%25E4%25BC%2597%25E5%258F%25B7%25E5%2588%2597%25E8%25A1%25A8">公众号列表</a></li><li>博客<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%25A2%25E9%2598%259F%25E5%258D%259A%25E5%25AE%25A2">团队博客</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2">个人博客</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%25BC%25E5%2590%2588%25E9%2597%25A8%25E6%2588%25B7%25E7%25A4%25BE%25E5%258C%25BA">综合门户、社区</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2597%25AE%25E7%25AD%2594%25E8%25AE%25A8%25E8%25AE%25BA%25E7%25B1%25BB%25E7%25A4%25BE%25E5%258C%25BA">问答、讨论类社区</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25A1%258C%25E4%25B8%259A%25E6%2595%25B0%25E6%258D%25AE%25E5%2588%2586%25E6%259E%2590">行业数据分析</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%2593%25E9%25A1%25B9%25E7%25BD%2591%25E7%25AB%2599">专项网站</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25B6%25E4%25BB%2596%25E7%25B1%25BB">其他类</a></li><li>推荐参考书<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259C%25A8%25E7%25BA%25BF%25E7%2594%25B5%25E5%25AD%2590%25E4%25B9%25A6">在线电子书</a></li><li>纸质书<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E5%258F%2591%25E6%2596%25B9%25E9%259D%25A2">开发方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E6%2596%25B9%25E9%259D%25A2">架构方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258A%2580%25E6%259C%25AF%25E7%25AE%25A1%25E7%2590%2586%25E6%2596%25B9%25E9%259D%25A2">技术管理方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259F%25BA%25E7%25A1%2580%25E7%2590%2586%25E8%25AE%25BA-1">基础理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7%25E6%2596%25B9%25E9%259D%25A2">工具方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE%25E6%2596%25B9%25E9%259D%25A2">大数据方面</a></li></ul></li></ul></li></ul></li><li>技术资源<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E6%25BA%2590%25E8%25B5%2584%25E6%25BA%2590">开源资源</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%258B%25E5%2586%258C%25E6%2596%2587%25E6%25A1%25A3%25E6%2595%2599%25E7%25A8%258B">手册、文档、教程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259C%25A8%25E7%25BA%25BF%25E8%25AF%25BE%25E5%25A0%2582">在线课堂</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BC%259A%25E8%25AE%25AE%25E6%25B4%25BB%25E5%258A%25A8">会议、活动</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%25B8%25E7%2594%25A8app">常用APP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%25BE%25E5%25B7%25A5%25E4%25BD%259C">找工作</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7">工具</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581%25E6%2589%2598%25E7%25AE%25A1">代码托管</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2596%2587%25E4%25BB%25B6%25E6%259C%258D%25E5%258A%25A1">文件服务</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%25BC%25E5%2590%2588%25E4%25BA%2591%25E6%259C%258D%25E5%258A%25A1%25E5%2595%2586">综合云服务商</a></li></ul></li></ul><p><strong>（Toc generated by simple-php-github-toc ）</strong></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lemon-flm/p/7877898.html">《java队列——queue详细分析》</a><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/mantu/p/5802393.html">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_33642117/article/details/52040345">《Java Set集合的详解》</a></li></ul><h2 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a>链表、数组</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wz249863091/article/details/52853360">《Java集合详解–什么是List》</a></li></ul><h2 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a>字典、关联数组</h2><ul><li><a href="https://link.juejin.im/?target=https://baike.xsoftlab.net/view/250.html">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/javazejian/article/details/53362993">《java数据结构与算法之栈（Stack）设计与实现》</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/java/java-stack-class.html">《Java Stack 类》</a></li><li>《java stack的详细实现分析》<ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/cai2016/article/details/52589952">《二叉树》</a></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>《完全二叉树》<ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/polly333/p/4798944.html">《浅谈数据结构-平衡二叉树》</a></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li></ul><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html">《浅谈算法和数据结构: 七 二叉查找树》</a></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul><li>《最容易懂得红黑树》<ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li></ul><h3 id="B-，B-，B-树"><a href="#B-，B-，B-树" class="headerlink" title="B-，B+，B*树"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/aqzwss/article/details/53074186">《B-树，B+树，B*树详解》</a></li><li>《B-树，B+树与B*树的优缺点比较》<ul><li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。</li></ul></li></ul><h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h3><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/dbanote/article/details/8897599">《LSM树 VS B+树》</a><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014774781/article/details/52105708">《LSM树（Log-Structured Merge Tree）存储引擎》</a><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/java/java-bitset-class.html">《Java Bitset类》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/caiandyong/article/details/51581160">《Java BitSet（位集）》</a></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/gane_cheng/article/details/52652705">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h2 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a>排序、查找算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/gane_cheng/article/details/52652705">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>《Java中的经典算法之选择排序（SelectionSort）》<ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>《冒泡排序的2种写法》<ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²)</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hapjin/p/5517667.html">《排序算法总结之插入排序》</a></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>《坐在马桶上看算法：快速排序》<ul><li>一侧比另外一次都大或小。</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>《图解排序算法(四)之归并排序》<ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。</li></ul></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>TODO</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>《图解排序算法(三)之堆排序》<ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul><li>《计数排序和桶排序》<ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/ahalei/1362789">《【啊哈！算法】最快最简单的排序——桶排序》</a></li><li>《排序算法（三）：计数排序与桶排序》<ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个通单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lemon_tree12138/article/details/51695211">《排序算法系列：基数排序》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/skywang12345/p/3603669.html">《基数排序》</a></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/coderising/p/5708632.html">《二分查找(java实现)》</a><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/maoyuanming0806/article/details/78176957">《java实现二分查找-两种方式》</a><ul><li>while + 递归。</li></ul></li></ul><h3 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a>Java 中的排序工具</h3><ul><li>《Arrays.sort和Collections.sort实现原理解析》<ul><li>Collections.sort算法调用的是合并排序。</li><li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000002729689">《布隆过滤器 – 空间效率很高的数据结构》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zdxiq000/article/details/57626464">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li><li>《基于Redis的布隆过滤器的实现》<ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li>《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》<ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2013/05/Knuth%25E2%2580%2593Morris%25E2%2580%2593Pratt_algorithm.html">《字符串匹配的KMP算法》</a></li></ul><h2 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a>深度优先、广度优先</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/0kk470/p/7555033.html">《广度优先搜索BFS和深度优先搜索DFS》</a></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/MrSaver/p/8641971.html">《算法：贪婪算法基础》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/a345017062/article/details/52443781">《常见算法及问题场景——贪心算法》</a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qfikh/article/details/51960331">《 五大常用算法之四：回溯法》</a></li></ul><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/luningcsdn/article/details/50930276">《α-β剪枝算法》</a></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/little-YTMM/p/5372680.html">《详解动态规划——邹博讲动态规划》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yao_zi_jie/article/details/54580283">《动态规划算法的个人理解》</a></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/amds123/article/details/70173402">《带你搞懂朴素贝叶斯分类算法》</a><ul><li>P(B|A)&#x3D;P(A|B)P(B)&#x2F;P(A)</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html">《贝叶斯推断及其互联网应用1》</a></li><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html">《贝叶斯推断及其互联网应用2》</a></li></ul><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01">《推荐算法综述》</a></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems">《TOP 10 开源的推荐系统简介》</a></li></ul><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/luoshixian099/article/details/51908175">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li></ul><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_35644234/article/details/60870719">《Dijkstra算法详解》</a></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><a href="https://link.juejin.im/?target=http://www.importnew.com/18459.html">《40个Java多线程问题总结》</a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhanht/p/5450325.html">《Java并发编程——线程安全及解决机制简介》</a></li></ul><h2 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a>一致性、事务</h2><h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012440687/article/details/52116108">《数据库事务ACID特性》</a></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化：所有事物串行处理（牺牲了效率）</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_33290787/article/details/51924963">《理解事务的4种隔离级别》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/z-sm/p/7245981.html">数据库事务的四大特性及事务隔离级别</a></li><li><a href="https://link.juejin.im/?target=http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">《MySQL的InnoDB的幻读问题 》</a><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><a href="https://link.juejin.im/?target=http://database.51cto.com/art/201804/570101.htm">《一篇文章带你读懂MySQL和InnoDB》</a><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/chenpingzhao/p/5065316.html">《【mysql】关于innodb中MVCC的一些理解》</a><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whoamiyang/article/details/51901888">《轻松理解MYSQL MVCC 实现机制》</a><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a>Java中的锁和同步类</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/qifengshi/p/6831055.html">《Java中的锁分类》</a><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/waterystone/p/4920797.html">《Java并发之AQS详解》</a></li><li><a href="https://link.juejin.im/?target=http://cuisuqiang.iteye.com/blog/2020146">《Java中信号量 Semaphore》</a><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/davidwang456/p/6094947.html">《java开发中的Mutex vs Semaphore》</a><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。</li></ul></li></ul><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li>《公平锁与非公平锁》<ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhiqian-ali/p/6200874.html">《【MySQL】悲观锁&amp;乐观锁》</a><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/Lawson/p/5008741.html">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zejin2008/p/5262751.html">《Mysql并发时经典常见的死锁原因及解决方法》</a></li></ul><h3 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a>乐观锁 &amp; CAS</h3><ul><li>《乐观锁的一种实现方式——CAS》<ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。</li></ul></li></ul><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/549294286/p/3766717.html">《Java CAS 和ABA问题》</a></li><li>《Java 中 ABA问题及避免》<ul><li>AtomicStampedReference 和 AtomicStampedReference。</li></ul></li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hapjin/p/4840107.html">《JAVA中写时复制(Copy-On-Write)Map实现》</a><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。</li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/a494303877/article/details/53404623">《聊聊并发-Java中的Copy-On-Write容器》</a></li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/l00l/p/4115001.html">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li></ul><h3 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a>可重入锁 &amp; 不可重入锁</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/dj3839/p/6580765.html">《可重入锁和不可重入锁》</a><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/baizhanshi/p/7211802.html">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h3 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。 共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/liang1101/p/6475555.html">《ReadWriteLock场景应用》</a></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yunfenglw/article/details/45950305">《“死锁”四个必要条件的合理解释》</a><ul><li>互斥、持有、不可剥夺、不可剥夺。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014039577/article/details/52351626">Java如何查看死锁？</a><ul><li>JConsole 可以识别死锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/bohu83/article/details/51135061">java多线程系列：死锁及检测</a><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000003692840">《操作系统基础知识——操作系统的原理，类型和结构》</a></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zero__007/article/details/54089730">《从Java视角理解CPU缓存和伪共享》</a></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/asdf_1024/article/details/78978437">《线程的生命周期及状态转换详解》</a></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>《终结python协程—-从yield到actor模型的实现》<ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无谓的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/linux/linux-command-manual.html">《Linux 命令大全》</a></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li>《设计模式的六大原则》<ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏代换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成&#x2F;聚合,而不是使用继承。</li></ul></li></ul><h2 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a>23种常见设计模式</h2><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/design-pattern/design-pattern-tutorial.html">《设计模式》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/susanws/p/5510229.html">《23种设计模式全解析》</a></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/62314/">《细数JDK里的设计模式》</a><ul><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是 <strong>一个返</strong>* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>空对象模式：如 java.util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hwaggLee/p/4510687.html">《Spring-涉及到的设计模式汇总》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012387062/article/details/54719114">《Mybatis使用的设计模式》</a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/YECrazy/article/details/79481964">《单例模式的三种实现 以及各自的优缺点》</a></li><li>《单例模式－－反射－－防止序列化破坏单例模式》<ul><li>使用枚举类型。</li></ul></li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>TODO</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>《MVC 模式》<ul><li>模型(model)－视图(view)－控制器(controller)</li></ul></li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/23277575">《理解 IOC》</a></li><li>《IOC 的理解与解释》<ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/yanquan345/blog/203415">《轻松理解AOP(面向切面编程)》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hongwz/p/5764917.html">《Spring AOP详解》</a></li><li>《Spring AOP的实现原理》<ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li>《Spring AOP 实现原理与 CGLIB 应用》<ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类</li></ul></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/uml_tutorial/">《UML教程》</a></li></ul><h2 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wintersun/p/6219259.html">《微服务架构设计》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/micro-service-technology-stack">《微服务架构技术栈选型手册》</a></li></ul><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><ul><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/8611">《微服务架构的理论基础 - 康威定律》</a><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><a href="https://link.juejin.im/?target=https://static.geekbang.org/PDF-%25E4%25BF%25AE%25E6%2594%25B9%25E7%2589%2588-%25E6%259E%2581%25E5%25AE%25A2%25E6%2597%25B6%25E9%2597%25B4-%25E5%259B%25BE%25E7%2589%2587-%25E6%259D%25A8%25E6%25B3%25A2-%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1%25E6%259E%25B6%25E6%259E%2584.pdf">《微服务架构核⼼20讲》</a></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a>常规监控</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/77849205">《腾讯业务系统监控的修炼之路》</a><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/news/67525/monitoring-tools">《开源还是商用？十大云运维监控工具横评》</a><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><a href="https://link.juejin.im/?target=http://developer.51cto.com/art/201612/525373.htm">《监控报警系统搭建及二次开发经验》</a></li></ul><p><strong>命令行监控工具</strong></p><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html">《常用命令行监控工具》</a><ul><li>top、sar、tsar、nload</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/96846/">《20个命令行工具监控 Linux 系统性能》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/feichexia/blog/196575">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM — Application Performance Management</p><ul><li><a href="https://link.juejin.im/?target=http://bigbully.github.io/Dapper-translation/">《Dapper，大规模分布式系统的跟踪系统》</a></li><li><a href="https://link.juejin.im/?target=http://opentracing.io">CNCF OpenTracing</a>，<a href="https://link.juejin.im/?target=https://github.com/opentracing-contrib/opentracing-specification-zh">中文版</a></li><li>主要开源软件，按字母排序<ul><li><a href="https://link.juejin.im/?target=https://github.com/apache/incubator-skywalking">Apache SkyWalking</a></li><li><a href="https://link.juejin.im/?target=https://github.com/dianping/cat">CAT</a></li><li><a href="https://link.juejin.im/?target=https://github.com/jaegertracing/jaeger">CNCF jaeger</a></li><li><a href="https://link.juejin.im/?target=https://github.com/naver/pinpoint">Pinpoint</a></li><li><a href="https://link.juejin.im/?target=https://github.com/openzipkin/zipkin">Zipkin</a></li></ul></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/apm-Pinpoint-practice">《开源APM技术选型与实战》</a><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><ul><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/25195217">《流量统计的基础：埋点》</a><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.25xt.com/company/17066.html">《APP埋点常用的统计工具、埋点目标和埋点内容》</a><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><a href="https://link.juejin.im/?target=https://tech.meituan.com/mt-mobile-analytics-practice.html">《美团点评前端无痕埋点实践》</a><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。</li></ul></li></ul><h2 id="持续集成-CI-x2F-CD"><a href="#持续集成-CI-x2F-CD" class="headerlink" title="持续集成(CI&#x2F;CD)"></a>持续集成(CI&#x2F;CD)</h2><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">《持续集成是什么？》</a></li><li><a href="https://link.juejin.im/?target=https://www.testwo.com/article/1170">《8个流行的持续集成工具》</a></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><ul><li><a href="https://link.juejin.im/?target=https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000">《使用Jenkins进行持续集成》</a></li></ul><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h3><p>开发、测试、生成环境分离。</p><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/sancuo/blog/214904">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul><h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h2><h3 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ansible.com.cn/">《Ansible中文权威指南》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/heiye123/articles/7855890.html">《Ansible基础配置和企业级项目实用案例》</a></li></ul><h3 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/keerya/p/8040071.html">《自动化运维工具——puppet详解》</a></li></ul><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h3><ul><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/">《Chef 的安装与使用》</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a>TDD 理论</h3><ul><li>《深度解读 - TDD（测试驱动开发）》<ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；</li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/happyzm/p/6482886.html">《Java单元测试之JUnit篇》</a></li><li>《JUnit 4 与 TestNG 对比》<ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。</li></ul></li><li>《单元测试主要的测试功能点》<ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。</li></ul></li></ul><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/blueheart20/article/details/52170790">《Apache ab 测试使用指南》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/binyue/p/6141088.html">《大型网站压力测试及优化方案》</a></li><li><a href="https://link.juejin.im/?target=http://news.chinabyte.com/466/14126966.shtml">《10大主流压力&#x2F;负载&#x2F;性能测试工具推荐》</a></li><li><a href="https://link.juejin.im/?target=http://quentinxxz.iteye.com/blog/2249799">《真实流量压测工具 tcpcopy应用浅析》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/jwentest/p/7136727.html">《nGrinder 简易使用教程》</a></li></ul><h3 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h3><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/30306892">《饿了么全链路压测的探索与实践》</a></li><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/28355759">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/27060fd61f72">《全链路压测经验》</a></li></ul><h3 id="A-x2F-B-、灰度、蓝绿测试"><a href="#A-x2F-B-、灰度、蓝绿测试" class="headerlink" title="A&#x2F;B 、灰度、蓝绿测试"></a>A&#x2F;B 、灰度、蓝绿测试</h3><ul><li><a href="https://link.juejin.im/?target=https://testerhome.com/topics/11165">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/purplegrape/1403123">《nginx 根据IP 进行灰度发布》</a></li><li><a href="https://link.juejin.im/?target=https://www.v2ex.com/t/344341">《蓝绿部署、A&#x2F;B 测试以及灰度发布》</a></li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/52910082">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><ul><li><a href="https://link.juejin.im/?target=http://blog.chinaunix.net/uid-20201831-id-5775661.html">《KVM详解，太详细太深入了，经典》</a></li><li><a href="https://link.juejin.im/?target=https://www.coderxing.com/kvm-install.html">《【图文】KVM 虚拟机安装详解》</a></li></ul><h3 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sddai/p/5931201.html">《Xen虚拟化基本原理详解》</a></li></ul><h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/longerzone/article/details/44829255">《开源Linux容器 OpenVZ 快速上手指南》</a></li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/SzeCheng/p/6822905.html">《几张图帮你理解 docker 基本原理及快速入门》</a></li><li><a href="https://link.juejin.im/?target=https://draveness.me/docker">《Docker 核心技术与实现原理》</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/docker/docker-tutorial.html">《Docker 教程》</a></li></ul><h2 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h2><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/klb561/p/8660264.html">《OpenStack构架知识梳理》</a></li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/jetzhang/p/6068773.html">《一分钟告诉你究竟DevOps是什么鬼？》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/detail-analysis-of-devops">《DevOps详解》</a></li></ul><h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h2><ul><li><a href="https://link.juejin.im/?target=http://www.confluence.cn/">Confluence-收费文档管理系统</a></li><li>GitLab?</li><li>Wiki</li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_25797077/article/details/52200722">《Ngnix的基本学习-多进程和Apache的比较》</a><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cunkouzh/p/5410154.html">《nginx与Apache的对比以及优缺点》</a><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li><a href="https://link.juejin.im/?target=http://openresty.org/cn/">官方网站</a></li><li>《浅谈 OpenResty》<ul><li>通过 Lua 模块可以在Nginx上进行开发。</li></ul></li></ul><h3 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a>Apache Httpd</h3><ul><li><a href="https://link.juejin.im/?target=http://httpd.apache.org/">官方网站</a></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hggen/p/6264475.html">《TOMCAT原理详解及请求过程》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/crazylqy/p/4706223.html">《Tomcat服务器原理详解》</a></li><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xlgen157387/article/details/79006434">《四张图带你了解Tomcat系统架构》</a></li><li><a href="https://link.juejin.im/?target=https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/">《JBoss vs. Tomcat: Choosing A Java Application Server》</a><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h4 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sunfenqing/p/7339058.html">《Tomcat 调优方案》</a><ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.chinaunix.net/uid-20662363-id-3012760.html">《tomcat http协议与ajp协议》</a></li><li><a href="https://link.juejin.im/?target=http://dmouse.iteye.com/blog/1354527">《AJP与HTTP比较和分析》</a><ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><ul><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/java/j-lo-jetty/">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li>《jetty和tomcat优势比较》<ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I&#x2F;O请求上更占优势，Tomcat默认采用BIO处理I&#x2F;O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。</li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/clementad/article/details/48229243">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li></ul><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html">《HashMap本地缓存》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html">《EhCache本地缓存》</a><ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html">《Guava Cache》</a><ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html">《Nginx本地缓存》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html">《Pagespeed—懒人工具，服务器端加速》</a></li></ul><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html">《浏览器端缓存》</a><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w">《H5 和移动端 WebView 缓存机制解析与实战》</a></li></ul><h2 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/Memcached/Memcached-tutorial.html">《Memcached 教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chenleixing/article/details/47035453">《深入理解Memcached原理》</a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/36e5cd400580">《Memcached软件工作原理》</a></li><li><a href="https://link.juejin.im/?target=http://zhihuzeye.com/archives/2361">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/liu251890347/article/details/37690045">《memcache 中 add 、 set 、replace 的区别》</a><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%2520Login%2520Sucess&&bduss=&ssnerror=0&traceid="><strong>《memcached全面剖析》</strong></a></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/redis/redis-tutorial.html">《Redis 教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wcf373722432/article/details/78678504">《redis底层原理》</a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><a href="https://link.juejin.im/?target=http://doc.redisfans.com/topic/persistence.html">《Redis持久化方式》</a><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chunlongyu/article/details/53346436">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/sunhuiliang85/article/details/73656830">《Redis单线程架构》</a></li></ul><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_29108585/article/details/63251491">《redis的回收策略》</a></li></ul><h3 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a>Tair</h3><ul><li><a href="https://link.juejin.im/?target=https://github.com/alibaba/tair">官方网站</a></li><li><a href="https://link.juejin.im/?target=http://blog.csdn.net/farphone/article/details/53522383">《Tair和Redis的对比》</a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/charlesblc/p/6045238.html">《消息队列-推&#x2F;拉模式学习 &amp; ActiveMQ及JMS学习》</a><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yunfeng482/article/details/72856762">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yanghua_kobe/article/details/43877281">《消息总线VS消息队列》</a></li></ul><h3 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cjsblog/p/8267892.html">《如何保证消费者接收消息的顺序》</a></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whoamiyang/article/details/54954780">《RabbitMQ的应用场景以及基本原理介绍》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/79ca08116d57">《消息队列之 RabbitMQ》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u013256816/article/details/55515234">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/824066d70da8">《RocketMQ 实战之快速入门》</a></li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wintersun/p/3962302.html">《ActiveMQ消息队列介绍》</a></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p><ul><li><a href="https://link.juejin.im/?target=http://kafka.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/allthesametome/article/details/47362451">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li><li><a href="https://link.juejin.im/?target=http://lxw1234.com/archives/2015/10/538.htm">《Kafka分区机制介绍与示例》</a></li></ul><h3 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_34212276/article/details/78455004">《Redis学习笔记之十：Redis用作消息队列》</a></li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><p>TODO</p><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><h3 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a>单机定时调度</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shuaiqing/p/7742382.html">《linux定时任务cron配置》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/daquan/blog/483305">《Linux cron运行原理》</a><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/drift-ice/p/3817269.html">《Quartz使用总结》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wenniuwuren/article/details/42082981/">《Quartz源码解析 —- 触发器按时启动原理》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/bab8e4e32952">《quartz原理揭秘和源码解读》</a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h3 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a>分布式定时调度</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_16216221/article/details/70314337">《这些优秀的国产分布式任务调度系统，你用过几个？》</a><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html">《Quartz任务调度的基本实现原理》</a><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的</li></ul></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/top_code/article/details/54615853">《从零开始实现RPC框架 - RPC原理及实现》</a><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/testcs_dn/article/details/78050590">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></li></ul><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li><a href="https://link.juejin.im/?target=http://dubbo.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/steven520213/p/7606598.html">dubbo实现原理简单介绍</a></li></ul><p>** SPI ** TODO</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><ul><li><a href="https://link.juejin.im/?target=http://thrift.apache.org/">官方网站</a></li><li>《Thrift RPC详解》<ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a href="https://link.juejin.im/?target=https://grpc.io/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/LBSer/p/4853234.html">《你应该知道的RPC原理》</a></li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><h3 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a>Sharding Jdbc</h3><ul><li><a href="https://link.juejin.im/?target=http://shardingjdbc.io/">官网</a></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a>日志搜集</h3><ul><li><a href="https://link.juejin.im/?target=http://cjting.me/misc/build-log-system-with-elkb/">《从零开始搭建一个ELKB日志收集系统》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lzw_2006/article/details/51280058">《用ELK搭建简单的日志收集分析系统》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/beginmind/p/6058194.html">《日志收集系统-探究》</a></li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com/ctripcorp/apollo">Apollo - 携程开源的配置中心应用</a><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011320740/article/details/78742625">《基于zookeeper实现统一配置管理》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shamo89/p/8016908.html">《 Spring Cloud Config 分布式配置中心使用教程》</a></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/dogdogwang/p/7151866.html">《servlet3.0 新特性——异步处理》</a></li></ul><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a href="https://link.juejin.im/?target=http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/">《API网关那些儿》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo">《谈API网关的背景、架构以及落地方案》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhanglh046/article/details/78651993">《使用Zuul构建API Gateway》</a></li><li><a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A">《HTTP API网关选择之一Kong介绍》</a></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/Robin-YB/p/6668762.html">《OSI七层协议模型、TCP&#x2F;IP四层模型学习笔记》</a></li></ul><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/onepixel/p/7092302.html">《深入浅出 TCP&#x2F;IP 协议》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whuslei/article/details/6667471/">《TCP协议中的三次握手和四次挥手》</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wangning528/p/6388464.html">《http协议详解(超详细)》</a></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhuyiquan/article/details/69257126">《HTTP 2.0 原理详细分析》</a></li><li>《HTTP2.0的基本单位为二进制帧》<ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhangshitong/p/6478721.html">《https原理通俗了解》</a><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/53213862">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/litaotao/1289790">《web优化必须了解的原理之I&#x2F;o的五种模型和web的三种工作模式》</a><ul><li>五种I&#x2F;O模型：阻塞I&#x2F;O，非阻塞I&#x2F;O，I&#x2F;O复用、事件(信号)驱动I&#x2F;O、异步I&#x2F;O，前四种I&#x2F;O属于同步操作，I&#x2F;O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/Anker/p/3265058.html">《select、poll、epoll之间的区别总结》</a><ul><li>select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><a href="https://link.juejin.im/?target=http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/">《select，poll，epoll比较 》</a><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/geason/p/5774096.html">《深入理解Java NIO》</a><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/skiof007/article/details/52873421">《BIO与NIO、AIO的区别》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u013074465/article/details/46276967">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html">《epoll使用详解（精髓）》</a></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/geason/p/5774096.html">《深入理解Java NIO》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xidianliuy/article/details/51612676">《Java NIO编写Socket服务器的一个例子》</a></li></ul><h3 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/luminocean/p/5631336.html">《kqueue用法简介》</a></li></ul><h2 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a>连接和短连接</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/pangguoping/p/5571422.html">《TCP&#x2F;IP系列——长连接与短连接的区别》</a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li>《Netty原理剖析》<ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h2 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a>零拷贝（Zero-copy）</h2><ul><li>《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》<ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h2 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a>序列化(二进制协议)</h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/happyday56/p/4268249.html">《Hessian原理分析》</a> Binary-RPC;不仅仅是序列化</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/antgan/article/details/52103966">《Protobuf协议的Java应用例子》</a> Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。</li><li><a href="https://link.juejin.im/?target=https://worktile.com/tech/share/prototol-buffers">《Protocol Buffers序列化协议及应用》</a><ul><li>关于协议的解释；缺点：可读性差;</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/eric520zenobia/article/details/53766571">《简单的使用 protobuf 和 protostuff》</a><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h3><ul><li>《数据库的三大范式以及五大约束》<ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://link.juejin.im/?target=http://www.admin10000.com/document/5372.html">《MySQL的InnoDB索引原理详解》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xifeijian/article/details/20316775">《MySQL存储引擎－－MyISAM与InnoDB区别》</a><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.2cto.com/database/201211/172380.html">《myisam和innodb索引实现的不同》</a></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/kailuncen/blog/1504217">《一篇文章带你读懂Mysql和InnoDB》</a></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><a href="https://link.juejin.im/?target=http://vdisk.weibo.com/s/muWOT">《MySQL36条军规》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhouyusheng/p/8038224.html">《MYSQL性能优化的最佳20+条经验》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/when_less_is_more/article/details/70187459">《SQL优化之道》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sivkun/p/7518540.html">《mysql数据库死锁的产生原因及解决办法》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/monkey_d_feilong/article/details/52291556">《导致索引失效的可能情况》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zy_281870667/article/details/51604540">《 MYSQL分页limit速度太慢优化方法》</a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a>聚集索引, 非聚集索引</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/no_endless/article/details/77073549">《MySQL 聚集索引&#x2F;非聚集索引简述》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zlcxbb/p/5757245.html">《MyISAM和InnoDB的索引实现》</a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/summer0space/p/7247778.html">《复合索引的优点和注意事项》</a></li></ul><h4 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a>自适应哈希索引(AHI)</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/Linux_ever/article/details/62043708">《InnoDB存储引擎——自适应哈希索引》</a></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000008131735">《MySQL 性能优化神器 Explain 使用分析》</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程</a></li><li>《Mongodb相对于关系型数据库的优缺点》<ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><ul><li><a href="https://link.juejin.im/?target=http://www.thebigdata.cn/HBase/35831.html">《简明 HBase 入门教程（开篇）》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/qiaoyihang/p/6246424.html">《深入学习HBase架构原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/youzhouliu/article/details/67632882">《传统的行存储和（HBase）列存储的区别》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lifuxiangcaohui/article/details/39891099">《Hbase与传统数据库的区别》</a><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014091123/article/details/73163088">《HBase Rowkey设计》</a><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h2><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/0193dc44135b">《倒排索引–搜索引擎入门》</a></li></ul><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/rodge-run/p/6551152.html">《Lucene入门简介》</a></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/laoyang360/article/details/52244917">《Elasticsearch学习，请先看这一篇！》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/cyony/article/details/65437708">《Elasticsearch索引原理》</a></li></ul><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011936655/article/details/51960005">《 Apache Solr入门教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/convict_eva/article/details/53537837">《elasticsearch与solr比较》</a></li></ul><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/101672/">《Sphinx 的介绍和原理探索》</a></li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread">《15天的性能优化工作，5方面的调优经验》</a><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/tenglizhe/article/details/44563135">《系统性能优化的几个方面》</a></li></ul><h2 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012528360/article/details/70054156">《联网性能与容量评估的方法论和典型案例》</a></li></ul><h2 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a>CDN 网络</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wxiaona/p/5867685.html">《CDN加速原理》</a></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/20536932">《国内有哪些比较好的 CDN？》</a></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/fysuccess/article/details/66972554">《主流Java数据库连接池比较与开发配置实战》</a></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yethyeth/article/details/73266455">《九大Java性能调试工具，必备至少一款》</a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h2><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ul><li><a href="https://link.juejin.im/?target=http://storm.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/uisoul/article/details/77989927">《最详细的Storm入门教程》</a></li></ul><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lisi1129/article/details/54844919">《Flink之一 Flink基本原理介绍》</a></li></ul><h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h3><ul><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/58382">《Kafka Stream调研：一种轻量级流计算模式》</a></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/houbin0912/article/details/72967178">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li><li><a href="https://link.juejin.im/?target=http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html">《史上最详细的Hadoop环境搭建》</a></li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000011575458">《【Hadoop学习】HDFS基本原理》</a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/oppo62258801/article/details/72884633">《用通俗易懂的大白话讲解Map&#x2F;Reduce原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/foye12/article/details/78358292">《 简单的map-reduce的java例子》</a></li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/codeOfLife/p/5492740.html">《初步掌握Yarn的架构及原理》</a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/tgzhu/p/5818374.html">《Spark(一): 基本架构及原理》</a></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_21956483/article/details/54377947">《xss攻击原理与解决方法》</a></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html">《CSRF原理及防范》</a></li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html">《SQL注入》</a></li></ul><h3 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a>Hash Dos</h3><ul><li>《邪恶的JAVA HASH DOS攻击》<ul><li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/92194?t=t1">《一种高级的DoS攻击-Hash碰撞攻击》</a></li><li><a href="https://link.juejin.im/?target=http://www.iteye.com/news/23939/">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li></ul><h3 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html">《上传文件漏洞原理及防范》</a></li></ul><h3 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html">《DVWA》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html">W3af</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xygg0801/article/details/53610640">OpenVAS详解</a></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/niaonao/article/details/51112686">《验证码原理分析及实现》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/jiangbianwanghai/blog/1031031">《详解滑动验证码的实现原理》</a><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/xcj26/p/5242758.html">《淘宝滑动验证码研究》</a></li></ul><h2 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a>DDoS 防范</h2><ul><li><a href="https://link.juejin.im/?target=http://netsecurity.51cto.com/art/201601/503799.htm">《学习手册：DDoS的攻击方式及防御手段》</a></li><li><a href="https://link.juejin.im/?target=http://netsecurity.51cto.com/art/201406/442756.htm">《免费DDoS攻击测试工具大合集》</a></li></ul><h2 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a>用户隐私信息保护</h2><ol><li>用户密码非明文保存，加动态slat。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a href="https://link.juejin.im/?target=https://zhidao.baidu.com/question/1988017976673661587.html">《个人隐私包括哪些》</a></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/20137108">《在互联网上，隐私的范围包括哪些？》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html">《用户密码保存》</a></li></ul><h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/">《Lib之过？Java反序列化漏洞通用利用分析》</a></li></ul><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>《常见对称加密算法》<ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html">《常用的哈希算法》</a><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhangruhong168/article/details/78033202">《基于Hash摘要签名的公网URL签名验证设计方案》</a></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p>《常见非对称加密算法》</p><ul><li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p></li><li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p></li><li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p><p><a href="https://link.juejin.im/?target=http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc">《区块链的加密技术》</a></p></li></ul></li></ul><h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><ul><li><a href="https://link.juejin.im/?target=http://www.freebuf.com/articles/system/121540.html">《Linux强化论：15步打造一个安全的Linux服务器》</a></li></ul><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>TODO</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><h3 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a>内外网分离</h3><p>TODO</p><h3 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/zero01/2062618">《搭建简易堡垒机》</a></li></ul><h2 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a>授权、认证</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zq8024/p/5003050.html">《基于组织角色的权限设计》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shijiaqi1066/p/3793894.html">《权限系统与RBAC模型概述》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/he90227/article/details/38663553">《Spring整合Shiro做权限控制模块详细案例分析》</a></li></ul><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">《理解OAuth 2.0》</a></li></ul><h3 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html">www.ruanyifeng.com/blog/2017/1…</a>)</li></ul><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a>单点登录(SSO)</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/ywlaker/p/6113927.html">《单点登录原理与简单实现》</a></li><li><a href="https://link.juejin.im/?target=https://github.com/apereo/cas">CAS单点登录框架</a></li></ul><h1 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h1><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html">《开源协议的选择》</a></li></ul><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h3 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a>Log4j、Log4j2</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012422446/article/details/51199724">《log4j 详细讲解》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/vbirdbest/article/details/71751835">《log4j2 实际使用详解》</a></li><li>《Log4j1,Logback以及Log4j2性能测试对比》<ul><li>Log4J 异步日志性能优异。</li></ul></li></ul><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/rulon147/article/details/52620541">《最全LogBack 详解、含java案例和配置说明》</a></li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ul><li>《ORM框架使用优缺点》<ul><li>主要目的是为了提高开发效率。</li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/winclpt/articles/7511672.html">《mybatis缓存机制详解》</a><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/baidu_32877851/article/details/53959268">《MyBatis学习之代码生成器Generator》</a></li></ul><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>TODO</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h2><h3 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a>Spring 家族</h3><p><strong>Spring</strong></p><ul><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/wkspring/">Spring 简明教程</a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a href="https://link.juejin.im/?target=http://projects.spring.io/spring-boot/">官方网站</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/Spring-Boot%25E5%259F%25BA%25E7%25A1%2580%25E6%2595%2599%25E7%25A8%258B/">《Spring Boot基础教程》</a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a href="https://link.juejin.im/?target=http://springboot.fun/">Spring Boot 中文索引站</a></li><li><a href="https://link.juejin.im/?target=https://springcloud.cc/">Spring Cloud 中文文档</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/Spring-Cloud%25E5%259F%25BA%25E7%25A1%2580%25E6%2595%2599%25E7%25A8%258B/">《Spring Cloud基础教程》</a></li></ul><h2 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/crazylqy/p/4872236.html">《Apache Commons 工具类介绍及简单使用》</a></li><li><a href="https://link.juejin.im/?target=http://ifeve.com/google-guava/">《Google guava 中文教程》</a></li></ul><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hemin1003/article/details/53633926">《架构师不可不知的十大可扩展架构》</a><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。</li></ul></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/38119">《可扩展性设计之数据切分》</a><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/deniro_li/article/details/78458306">《说说如何实现可扩展性的大型网站架构》</a><ul><li>分布式服务+消息队列。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chaofanwei/article/details/29191073">《大型网站技术架构（七）–网站的可扩展性架构》</a></li></ul><h2 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a>稳定性 &amp; 高可用</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hustspy1990/article/details/78008324">《系统设计：关于高可用系统的一些技术方案》</a><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coolshell.cn/articles/17459.html">《关于高可用的系统》</a><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。</li></ul></li></ul><h3 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wuyun-blog/p/6186198.html">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a><ul><li>主要是和F5对比。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lcword/p/5773296.html">《软&#x2F;硬件负载均衡产品 你知多少？》</a></li></ul><h3 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/tianzhiliang/articles/2317808.html">《几种负载均衡算法》</a> 轮寻、权重、负载、最少连接、QoS</li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html">《DNS负载均衡》</a><ul><li>配置简单，更新速度慢。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html">《Nginx负载均衡》</a><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/edisonchou/p/4281978.html">《借助LVS+Keepalived实现负载均衡 》</a><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.ttlsa.com/linux/haproxy-study-tutorial/">《HAProxy用法详解 全网最详细中文文档》</a><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.itpub.net/25704976/viewspace-1319781/">《Haproxy+Keepalived+MySQL实现读均衡负载》</a><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lylife/p/5584019.html">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>《谈谈高并发系统的限流》<ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li></ul></li></ul><h3 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a>应用层容灾</h3><ul><li><p><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000005988895">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p></li><li><p>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。</p></li><li><p>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</p></li><li><p>Hystrix设计原则：</p><ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 &#x3D; 请求失败数 &#x2F; 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。</li></ul></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/zeb_perfect/article/details/54135506">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/zeb_perfect/article/details/54135506">《缓存击穿、失效以及热点key问题》</a></p><ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul><h3 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a>跨机房容灾</h3><ul><li><a href="https://link.juejin.im/?target=http://dc.idcquan.com/ywgl/71559.shtml">《“异地多活”多机房部署经验谈》</a><ul><li>通过自研中间件进行数据同步。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/jeffreynicole/article/details/48135093">《异地多活（异地双活）实践经验》</a><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。</li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yoara/article/details/38013751">容灾技术及建设经验介绍</a></li></ul><h3 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a>容灾演练流程</h3><ul><li>《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》<ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h3 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a>平滑启动</h3><ul><li>平滑重启应用思路 1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011001084/article/details/73480432">《JVM安全退出（如何优雅的关闭java服务）》</a> 推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li><li><a href="https://link.juejin.im/?target=http://ju.outofmemory.cn/entry/337235">《常见Java应用如何优雅关闭》</a> Java、Srping、Dubbo 优雅关闭方式。</li></ul><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h3 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a>读写分离模式</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/houdj/p/6563771.html">《Mysql主从方案的实现》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/edisonchou/p/4133148.html">《搭建MySQL主从复制经典架构》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/nimasike/article/details/48048341">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhangsubai/p/6801764.html">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a><ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html">《MySQL Cluster 方式》</a></li></ul><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h3><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/32b3e91aa22c">《分库分表需要考虑的问题及方案》</a><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.2cto.com/database/201503/380348.html">《MySql分表和表分区详解》</a><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/jiaolongdy/article/details/51188798">《永不失联！如何实现微服务架构中的服务发现？》</a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u010963948/article/details/71730165">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><a href="https://link.juejin.im/?target=http://mobile.51cto.com/news-502394.htm">《基于Zookeeper的服务注册与发现》</a><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。</li></ul></li></ul><h3 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a>服务路由控制</h3><ul><li>《分布式服务框架学习笔记4 服务路由》<ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h2 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a>分布式一致</h2><h3 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a>CAP 与 BASE 理论</h3><ul><li>《从分布式一致性谈到CAP理论、BASE理论》<ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><p> 分布式锁</p><ul><li><a href="https://link.juejin.im/?target=http://www.hollischuang.com/archives/1716">《分布式锁的几种实现方式》</a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.tuicool.com/articles/VZJr6fY">《基于Zookeeper的分布式锁》</a><ul><li>清楚的原理描述 + Java 代码示例。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/0201zcr/p/5942748.html">《jedisLock—redis分布式锁实现》</a><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/albertfly/article/details/77412333">《Memcached 和 Redis 分布式锁方案》</a><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><h4 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/linbingdong/p/6253479.html">《分布式系列文章——Paxos算法原理与推导》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u010039929/article/details/70171672">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/leesf456/p/6012777.html">《【分布式】Zookeeper与Paxos》</a></li></ul><h4 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h4><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/fb527a64deee">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li></ul><h4 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h4><ul><li>《Raft 为什么是更易理解的分布式一致性算法》<ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/tianya23/530743">《Gossip算法》</a></li></ul><h4 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a>两阶段提交、多阶段提交</h4><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/95632/">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li></ul><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ul><li>《分布式系统—幂等性设计》<ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。</li></ul></li></ul><h3 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a>分布式一致方案</h3><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency">《分布式系统事务一致性解决方案》</a></li><li><a href="https://link.juejin.im/?target=https://weibo.com/ttarticle/p/show?id=2309403965965003062676">《保证分布式系统数据一致性的6种方案》</a></li></ul><h3 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a>分布式 Leader 节点选举</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/johnson_moon/article/details/78809995">《利用zookeeper实现分布式leader节点选举》</a></li></ul><h3 id="TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务"><a href="#TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务" class="headerlink" title="TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务"></a>TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务</h3><ul><li>《传统事务与柔性事务》<ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><ul><li><p><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/27666295">说说分布式文件存储系统-基本架构</a> ？</p></li><li><p>《各种分布式文件系统的比较》</p><ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h2 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a>唯一ID 生成</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/baiwa/p/5318432.html">《高并发分布式系统中生成全局唯一Id汇总》</a><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();”</li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hdu09075340/article/details/79103851">《TDDL 在分布式下的SEQUENCE原理》</a><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html">《一致性哈希算法》</a></li></ul><h1 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a>设计思想 &amp; 开发模式</h1><h2 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><hr><p><a href="https://link.juejin.im/?target=https://www.cnblogs.com/netfocus/p/5548025.html">《浅谈我对DDD领域驱动设计的理解》</a></p><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul><p><a href="https://link.juejin.im/?target=https://www.cnblogs.com/butterfly100/p/7827870.html">《领域驱动设计的基础知识总结》</a></p><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面&#x2F;展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/Leo_wl/p/3866629.html">《领域驱动设计(DDD)实现之路》</a><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.hollischuang.com/archives/553">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></li></ul><h3 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cnblogsfans/p/4551990.html">《领域驱动设计系列 (六)：CQRS》</a><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml">《DDD CQRS架构和传统架构的优缺点比较》</a><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/netfocus/p/4055346.html">《CQRS架构简介》</a><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.uml.org.cn/zjjs/201609221.asp">《深度长文：我对CQRS&#x2F;EventSourcing架构的思考》</a><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a>贫血，充血模型</h3><ul><li>《贫血，充血模型的解释以及一些经验》<ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a>Actor 模式</h2><p>TODO</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>TODO</p><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><p>TODO</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h3><p>TODO</p><p> DODAF2.0</p><ul><li><a href="https://link.juejin.im/?target=http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml">《DODAF2.0方法论》</a></li><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/xiaoyong/1553164">《DODAF2.0之能力视角如何落地》</a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>TODO</p><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p>TODO</p><ul><li><a href="https://link.juejin.im/?target=https://time.geekbang.org/article/2355">《什么是Service Mesh？》</a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a>架构评审</h2><ul><li><a href="https://link.juejin.im/?target=http://developer.51cto.com/art/201506/478486.htm">《架构设计之如何评审架构设计说明书》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wireless_com/article/details/45935591">《人人都是架构师：非功能性需求》</a></li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/architect-12-rules-complete/">《架构之重构的12条军规》</a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>TODO</p><h2 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h2><p>制度还是制度! 另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><a href="https://link.juejin.im/?target=http://www.sohu.com/a/229745352_181657">《为什么你做不好 Code Review？》</a><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/uxyheaven/article/details/49773619">《从零开始Code Review》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zuoping/p/5477047.html">《Code Review Checklist》</a></li><li><a href="https://link.juejin.im/?target=https://dzone.com/articles/java-code-review-checklist">《Java Code Review Checklist》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/legend0011/article/details/45585575">《如何用 gitlab 做 code review》</a></li></ul><h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/apanious/article/details/51011946">《运用RUP 4+1视图方法进行软件架构设计》</a></li></ul><h2 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a>看板管理</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/tkchen/article/details/51637643">《说说看板在项目中的应用》</a></li></ul><h2 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a>SCRUM</h2><p>SCRUM - 争球</p><ul><li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li><li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li><li>五个价值观：专注、勇气、公开、承诺、尊重。</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/inny100_100/article/details/54633757">《敏捷项目管理流程-Scrum框架最全总结！》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/superkunkun/article/details/52951142">《敏捷其实很简单3—敏捷方法之scrum》</a></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p><ul><li>《主流敏捷开发方法：极限编程XP》<ul><li>是一种指导开发人员的方法论。</li><li>4大价值：<ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a href="https://link.juejin.im/?target=http://www.baike.com/wiki/%25E7%25BB%2593%25E5%25AF%25B9%25E7%25BC%2596%25E7%25A8%258B">《结对编程》</a></li></ul><h2 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a>FMEA管理模式</h2><p>TODO</p><h1 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a>通用业务术语</h1><p>TODO</p><h1 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h1><p>TODO</p><h1 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a>政策、法规</h1><p>TODO</p><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h2><h3 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p><blockquote><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。</li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul></blockquote><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a href="https://link.juejin.im/?target=https://baike.baidu.com/item/%25E9%259D%259E%25E6%25B3%2595%25E8%258E%25B7%25E5%258F%2596%25E5%2585%25AC%25E6%25B0%2591%25E4%25B8%25AA%25E4%25BA%25BA%25E4%25BF%25A1%25E6%2581%25AF%25E7%25BD%25AA">《非法获取公民个人信息罪》</a></li></ul><h1 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a>架构师素质</h1><ul><li><p><a href="https://link.juejin.im/?target=http://hellojava.info/?p=430">《架构师画像》</a></p><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；</li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><p><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know">《关于架构优化和设计，架构师必须知道的事情》</a></p><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依懒、注意服务之间依懒所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。</li></ul></li><li><p><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/19841397">《如何才能真正的提高自己，成为一名出色的架构师？》</a></p></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129">《架构师的必备素质和成长途径》</a></p><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和祖内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。</li></ul></li><li><p><a href="https://link.juejin.im/?target=http://blog.51cto.com/frankfan/1248401">《架构设计师—你在哪层楼？》</a></p><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值</li></ul></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h1><p>TODO</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><h2 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a>行业资讯</h2><ul><li><a href="https://link.juejin.im/?target=http://36kr.com/">36kr</a></li><li><a href="https://link.juejin.im/?target=http://www.techweb.com.cn/">Techweb</a></li></ul><h2 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a>公众号列表</h2><p>TODO</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h3><ul><li><a href="https://link.juejin.im/?target=http://jm.taobao.org/">阿里中间件博客</a></li><li><a href="https://link.juejin.im/?target=https://tech.meituan.com">美团点评技术团队博客</a></li></ul><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/">阮一峰的网络日志</a></li><li><a href="https://link.juejin.im/?target=https://coolshell.cn/">酷壳 - COOLSHELL-陈皓</a></li><li><a href="https://link.juejin.im/?target=http://hellojava.info/">hellojava-阿里毕玄</a></li><li><a href="https://link.juejin.im/?target=http://cmsblogs.com/">Cm’s Blog</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li></ul><h2 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a>综合门户、社区</h2><p><strong>国内：</strong></p><ul><li><a href="https://link.juejin.im/?target=http://csdn.net">CSDN</a> 老牌技术社区、不必解释。</li><li><a href="https://link.juejin.im/?target=http://www.51cto.com/">51cto.com</a></li><li><a href="https://link.juejin.im/?target=http://www.iteye.com/">ITeye</a><ul><li>偏 Java 方向</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com">博客园</a></li><li><a href="https://link.juejin.im/?target=http://www.tom.net/">ChinaUnix</a><ul><li>偏 Linux 方向</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/">开源中国社区</a></li><li><a href="https://link.juejin.im/?target=http://www.open-open.com/">深度开源</a></li><li><a href="https://link.juejin.im/?target=http://www.jobbole.com/">伯乐在线</a><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.itpub.net/">ITPUB</a></li><li><a href="https://link.juejin.im/?target=https://cloud.tencent.com/developer/column">腾讯云— 云+社区</a></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/">阿里云— 云栖社区</a></li><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/">IBM DeveloperWorks</a></li><li><a href="https://link.juejin.im/?target=https://toutiao.io/">开发者头条</a></li><li><a href="https://link.juejin.im/?target=http://www.linkedkeeper.com">LinkedKeeper</a></li></ul><p><strong>国外：</strong></p><ul><li><a href="https://link.juejin.im/?target=https://dzone.com">DZone</a></li><li><a href="https://link.juejin.im/?target=https://www.reddit.com">Reddit</a></li></ul><h2 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a>问答、讨论类社区</h2><ul><li>segmentfault<ul><li>问答+专栏</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/">知乎</a></li><li><a href="https://link.juejin.im/?target=https://stackoverflow.com/">stackoverflow</a></li></ul><h2 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a>行业数据分析</h2><ul><li><a href="https://link.juejin.im/?target=http://report.iresearch.cn/">艾瑞网</a></li><li><a href="https://link.juejin.im/?target=https://www.questmobile.com.cn">QUEST MOBILE</a></li><li><a href="https://link.juejin.im/?target=http://data.stats.gov.cn/">国家数据</a></li></ul><h2 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a>专项网站</h2><ul><li>测试:<ul><li><a href="https://link.juejin.im/?target=http://www.ltesting.net/">领测国际</a></li><li><a href="https://link.juejin.im/?target=https://www.testwo.com/">测试窝</a></li><li><a href="https://link.juejin.im/?target=https://testerhome.com">TesterHome</a></li></ul></li><li>运维:<ul><li><a href="https://link.juejin.im/?target=http://www.yunweipai.com/">运维派</a></li><li><a href="https://link.juejin.im/?target=https://www.abcdocker.com/">Abcdocker</a></li></ul></li><li>Java:<ul><li>ImportNew<ul><li>专注于 Java 技术分享</li></ul></li><li>HowToDoInJava<ul><li>英文博客</li></ul></li></ul></li><li>安全<ul><li><a href="https://link.juejin.im/?target=https://www.2cto.com/">红黑联盟</a></li><li><a href="https://link.juejin.im/?target=http://www.freebuf.com/">FreeBuf</a></li></ul></li><li>大数据<ul><li><a href="https://link.juejin.im/?target=http://www.thebigdata.cn/">中国大数据</a></li></ul></li><li>其他专题网站：<ul><li>DockerInfo<ul><li>专注于 Docker 应用及咨询、教程的网站。</li></ul></li><li>Linux公社<ul><li>Linux 主题社区</li></ul></li></ul></li></ul><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com/TeamStuQ/skill-map">程序员技能图谱</a></li></ul><h2 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h2><h3 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a>在线电子书</h3><ul><li><a href="https://link.juejin.im/?target=https://github.com/forezp/SpringCloudLearning">《深入理解Spring Cloud与微服务构建》</a></li><li><a href="https://link.juejin.im/?target=http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf">《阿里技术参考图册-研发篇》</a></li><li><a href="https://link.juejin.im/?target=http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf">《阿里技术参考图册-算法篇》</a></li><li><a href="https://link.juejin.im/?target=http://dpurl.cn/n/1lqcX">《2018美团点评技术年货（合辑）》70M</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/architect/">InfoQ《架构师》月刊</a></li><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/architectroad/">《架构师之路》</a></li></ul><h3 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h3><h4 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h4><ul><li>《阿里巴巴Java开发手册》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=bVKwZQ">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E9%2598%25BF%25E9%2587%258C%25E5%25B7%25B4%25E5%25B7%25B4Java%25E5%25BC%2580%25E5%258F%2591%25E6%2589%258B%25E5%2586%258C">淘宝</a></li></ul><h4 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h4><ul><li>《软件架构师的12项修炼：技术技能篇》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=gXvRd8">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E8%25BD%25AF%25E4%25BB%25B6%25E6%259E%25B6%25E6%259E%2584%25E5%25B8%2588%25E7%259A%258412%25E9%25A1%25B9%25E4%25BF%25AE%25E7%2582%25BC%25EF%25BC%259A%25E6%258A%2580%25E6%259C%25AF%25E6%258A%2580%25E8%2583%25BD%25E7%25AF%2587">淘宝</a></li><li>《架构之美》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=xJit5I">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%259E%25B6%25E6%259E%2584%25E4%25B9%258B%25E7%25BE%258E">淘宝</a></li><li>《分布式服务架构》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=JS5Od9">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E6%259C%258D%25E5%258A%25A1%25E6%259E%25B6%25E6%259E%2584">淘宝</a></li><li>《聊聊架构》 <a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=FHooH4">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E8%2581%258A%25E8%2581%258A%25E6%259E%25B6%25E6%259E%2584">淘宝</a></li><li>《云原生应用架构实践》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=orkJSj">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BA%2591%25E5%258E%259F%25E7%2594%259F%25E5%25BA%2594%25E7%2594%25A8%25E6%259E%25B6%25E6%259E%2584%25E5%25AE%259E%25E8%25B7%25B5">淘宝</a></li><li>《亿级流量网站架构核心技术》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=RnOSP5">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BA%25BF%25E7%25BA%25A7%25E6%25B5%2581%25E9%2587%258F%25E7%25BD%2591%25E7%25AB%2599%25E6%259E%25B6%25E6%259E%2584%25E6%25A0%25B8%25E5%25BF%2583%25E6%258A%2580%25E6%259C%25AF">淘宝</a></li><li>《淘宝技术这十年》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=LwrDfD">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%25B7%2598%25E5%25AE%259D%25E6%258A%2580%25E6%259C%25AF%25E8%25BF%2599%25E5%258D%2581%25E5%25B9%25B4">淘宝</a></li><li>《企业IT架构转型之道-中台战略思想与架构实战》 <a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=89pAEm">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BC%2581%25E4%25B8%259AIT%25E6%259E%25B6%25E6%259E%2584%25E8%25BD%25AC%25E5%259E%258B%25E4%25B9%258B%25E9%2581%2593">淘宝</a></li></ul><h4 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a>技术管理方面</h4><ul><li>《CTO说》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=zhTZyr">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=CTO%25E8%25AF%25B4">淘宝</a></li><li>《技术管理之巅》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=LgRBUW">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%258A%2580%25E6%259C%25AF%25E7%25AE%25A1%25E7%2590%2586%25E4%25B9%258B%25E5%25B7%2585">淘宝</a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=jcRz2r">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E7%25BD%2591%25E6%2598%2593%25E4%25B8%2580%25E5%258D%2583%25E9%259B%25B6%25E4%25B8%2580%25E5%25A4%259C%25EF%25BC%259A%25E4%25BA%2592%25E8%2581%2594%25E7%25BD%2591%25E4%25BA%25A7%25E5%2593%2581%25E9%25A1%25B9%25E7%259B%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%25AE%259E%25E6%2588%2598">淘宝</a></li></ul><h4 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h4><ul><li>《数学之美》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=ghIES2">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%2595%25B0%25E5%25AD%25A6%25E4%25B9%258B%25E7%25BE%258E">淘宝</a></li><li>《编程珠玑》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=YmhdEu">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E7%25BC%2596%25E7%25A8%258B%25E7%258F%25A0%25E7%258E%2591">淘宝</a></li></ul><h4 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h4><p>TODO</p><h4 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a>大数据方面</h4><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h1><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com">github</a></li><li><a href="https://link.juejin.im/?target=https://www.apache.org/index.html">Apache 软件基金会</a></li></ul><h2 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a>手册、文档、教程</h2><p><strong>国内：</strong></p><ul><li><a href="https://link.juejin.im/?target=http://w3cschool.cn">W3Cschool</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/">Runoob.com</a><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><a href="https://link.juejin.im/?target=https://love2.io/">Love2.io</a><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a href="https://link.juejin.im/?target=http://gitbook.cn/">gitbook.cn</a><ul><li>付费电子书。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.apachecn.org/">ApacheCN</a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li>Quick Code<ul><li>免费在线技术教程。</li></ul></li><li>gitbook.com<ul><li>有部分中文电子书。</li></ul></li><li>Cheatography<ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li></ul><h2 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a>在线课堂</h2><ul><li><a href="https://link.juejin.im/?target=http://www.xuetuwuyou.com/">学徒无忧</a></li><li><a href="https://link.juejin.im/?target=https://time.geekbang.org/">极客时间</a></li><li><a href="https://link.juejin.im/?target=https://segmentfault.com/lives">segmentfault</a></li><li><a href="https://link.juejin.im/?target=https://new.stuq.org/course/explore">斯达克学院</a></li><li><a href="https://link.juejin.im/?target=http://nowcoder.com">牛客网</a></li><li><a href="https://link.juejin.im/?target=https://www.jikexueyuan.com/">极客学院</a></li><li><a href="https://link.juejin.im/?target=http://edu.51cto.com/">51CTO学院</a></li></ul><h2 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a>会议、活动</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/qcon/">QCon</a></li><li><a href="https://link.juejin.im/?target=https://archsummit.com">ArchSummit</a></li><li><a href="https://link.juejin.im/?target=http://www.thegitc.com/">GITC全球互联网技术大会</a></li></ul><p><strong>活动发布平台:</strong></p><ul><li><a href="https://link.juejin.im/?target=http://www.huodongxing.com/">活动行</a></li></ul><h2 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a>常用APP</h2><ul><li><a href="https://link.juejin.im/?target=https://time.geekbang.org">极客时间</a></li><li><a href="https://link.juejin.im/?target=https://www.igetget.com">得到</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><ul><li><a href="https://link.juejin.im/?target=https://www.zhipin.com">Boss直聘</a></li><li><a href="https://link.juejin.im/?target=https://www.lagou.com">拉勾网</a></li><li><a href="https://link.juejin.im/?target=https://www.liepin.com">猎聘</a></li><li><a href="https://link.juejin.im/?target=https://cn.100offer.com/">100Offer</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>极客搜索<ul><li>技术文章搜索引擎。</li></ul></li></ul><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h2><ul><li><a href="https://link.juejin.im/?target=https://coding.net">Coding</a></li><li><a href="https://link.juejin.im/?target=https://gitee.com/">码云</a></li></ul><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h2><ul><li>七牛</li><li>又拍云</li></ul><h2 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a>综合云服务商</h2><ul><li>阿里云</li><li>腾讯云</li><li>百度云</li><li>新浪云</li><li>金山云</li><li><a href="https://link.juejin.im/?target=https://amazonaws-china.com/cn/">亚马逊云(AWS)</a></li><li><a href="https://link.juejin.im/?target=https://cloud.google.com/?hl=zh-cn">谷歌云</a></li><li><a href="https://link.juejin.im/?target=https://azure.microsoft.com/zh-cn/">微软云</a></li></ul><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul><li><a href="https://link.juejin.im/?target=http://linode.com">Linode</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程总结</title>
      <link href="/2018/04/22/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/22/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p> 1、多线程有什么用？</p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。<strong>单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了</strong>。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p>2、创建线程的方式</p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心。</p><p>3、start()方法和run()方法的区别</p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p>4、Runnable接口和Callable接口的区别</p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future&#x2F;FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p>5、CyclicBarrier和CountDownLatch的区别</p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p>6、volatile关键字的作用</p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是<strong>Java代码–&gt;字节码–&gt;根据字节码执行对应的C&#x2F;C++代码–&gt;C&#x2F;C++代码被编译成汇编语言–&gt;和硬件电路交互</strong>，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p>7、什么是线程安全</p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p>8、Java中如何获取到线程dump文件</p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p>9、一个线程如果出现了运行时异常会怎么样</p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p><p>10、如何在两个线程之间共享数据</p><p>通过在线程之间共享对象就可以了，然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 </p><p>11、sleep方法和wait方法有什么区别</p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p>12、生产者消费者模型的作用是什么</p><p>这个问题很理论，但是很重要：</p><p>（1）<strong>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</strong>，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用</p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p>14、为什么wait()方法和notify()&#x2F;notifyAll()方法要在同步块中被调用</p><p>这是JDK强制的，wait()方法和notify()&#x2F;notifyAll()方法在调用前都必须先获得对象的锁</p><p>15、wait()方法和notify()&#x2F;notifyAll()方法在放弃对象监视器时有什么区别</p><p>wait()方法和notify()&#x2F;notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()&#x2F;notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器</strong>。</p><p>16、为什么要使用线程池</p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 </p><p>17、怎么检测一个线程是否持有对象监视器</p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着**”某条线程”指的是当前线程**。</p><p>18、synchronized和ReentrantLock的区别</p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>19、ConcurrentHashMap的并发度是什么</p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>20、ReadWriteLock是什么</p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，<strong>读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>21、FutureTask是什么</p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>22、Linux环境下如何查找哪个线程使用CPU最长</p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>23、Java编程写一个会导致死锁的程序</p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><p>24、怎么唤醒一个阻塞的线程</p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>25、不可变对象对多线程有什么帮助</p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p>26、什么是多线程的上下文切换</p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p><p>这里区分一下：</p><ol><li>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ol><p>28、Java中用到的线程调度算法是什么</p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>29、Thread.sleep(0)的作用是什么</p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>30、什么是自旋</p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p>31、什么是Java内存模型</p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了<strong>主内存和工作内存</strong>。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p>32、什么是CAS</p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：<strong>内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false</strong>。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p>33、什么是乐观锁和悲观锁</p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>34、什么是AQS</p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p>35、单例模式的线程安全性</p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：<strong>某个类的实例在多线程环境下只会被创建一次出来</strong>。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p>36、Semaphore有什么作用</p><p>Semaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n&#x3D;1，相当于变成了一个synchronized了。</p><p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）<strong>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问</strong>。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）<strong>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住</strong>。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。<strong>即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个</strong>。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p>38、线程类的构造方法、静态块是被哪个线程调用的</p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p>39、同步方法和同步块，哪个是更好的选择</p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好</strong>。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong>锁粗化</strong>的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新域名aimak.cn，挂载了婚礼互动，和博客了</title>
      <link href="/2018/04/14/%E6%9D%82%E8%AE%B0/%E6%96%B0%E5%9F%9F%E5%90%8Daimak.cn%EF%BC%8C%E6%8C%82%E8%BD%BD%E4%BA%86%E5%A9%9A%E7%A4%BC%E4%BA%92%E5%8A%A8%EF%BC%8C%E5%92%8C%E5%8D%9A%E5%AE%A2%E4%BA%86/"/>
      <url>/2018/04/14/%E6%9D%82%E8%AE%B0/%E6%96%B0%E5%9F%9F%E5%90%8Daimak.cn%EF%BC%8C%E6%8C%82%E8%BD%BD%E4%BA%86%E5%A9%9A%E7%A4%BC%E4%BA%92%E5%8A%A8%EF%BC%8C%E5%92%8C%E5%8D%9A%E5%AE%A2%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>.cc的域名不给备案了，之前备案步骤走了一些步骤了，太忙没来及完成步骤，后面直接不给.cc备案了，婚礼前，想到了做一个现场互动的东东，于是就又申请了一个新域名，aimak.cn 好吧，第一个.cn的域名，aimak(AI) ～哈</p></blockquote><p>哈哈，现场好多祝福弹幕～ 有空再整理心得撒！～ </p><ul><li><a href="http://wedding.aimak.cn/">微信端</a></li><li><a href="http://wedding.aimak.cn/wall">大屏幕</a></li></ul><p>最近又把博客搬一份到这个域名下面</p><ul><li><a href="https://blog.aimak.cn/">blog.aimak.cn</a>  支持HTTPS</li></ul><p>HTTPS 方案依然使用Let’s Encrypt</p><p>好吧，自己的服务器带宽只有1M～ 😂 </p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf 常用的th标签</title>
      <link href="/2018/03/24/java/%20thymeleaf%20%E5%B8%B8%E7%94%A8%E7%9A%84th%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/03/24/java/%20thymeleaf%20%E5%B8%B8%E7%94%A8%E7%9A%84th%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>功能介绍</th><th>案例</th></tr></thead><tbody><tr><td>th:id</td><td>替换id</td><td><code>&lt;input th:id=&quot;&#39;xxx&#39; + $&#123;collect.id&#125;&quot;/&gt;</code></td></tr><tr><td>th:text</td><td>文本替换</td><td><code>&lt;p th:text=&quot;$&#123;collect.description&#125;&quot;&gt;description&lt;/p&gt;</code></td></tr><tr><td>th:utext</td><td>支持html的文本替换</td><td><code>&lt;p th:utext=&quot;$&#123;htmlcontent&#125;&quot;&gt;conten&lt;/p&gt;</code></td></tr><tr><td>th:object</td><td>替换对象</td><td><code>&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</code></td></tr><tr><td>th:value</td><td>属性赋值</td><td><code>&lt;input th:value=&quot;$&#123;user.name&#125;&quot; /&gt;</code></td></tr><tr><td>th:with</td><td>变量赋值运算</td><td><code>&lt;div th:with=&quot;isEven=$&#123;prodStat.count&#125;%2==0&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:style</td><td>设置样式</td><td><code>th:style=&quot;&#39;display:&#39; + @&#123;($&#123;sitrue&#125; ? &#39;none&#39; : &#39;inline-block&#39;)&#125; + &#39;&#39;&quot;</code></td></tr><tr><td>th:onclick</td><td>点击事件</td><td><code>th:onclick=&quot;&#39;getCollect()&#39;&quot;</code></td></tr><tr><td>th:each</td><td>属性赋值</td><td><code>tr th:each=&quot;user,userStat:$&#123;users&#125;&quot;&gt;</code></td></tr><tr><td>th:if</td><td>判断条件</td><td><code>&lt;a th:if=&quot;$&#123;userId == collect.userId&#125;&quot; &gt;</code></td></tr><tr><td>th:unless</td><td>和th:if判断相反</td><td><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt;</code></td></tr><tr><td>th:href</td><td>链接地址</td><td><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td>th:switch</td><td>多路选择 配合th:case 使用</td><td><code>&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</code></td></tr><tr><td>th:case</td><td>th:switch的一个分支</td><td><code>&lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt;</code></td></tr><tr><td>th:fragment</td><td>布局标签，定义一个代码片段，方便其它地方引用</td><td><code>&lt;div th:fragment=&quot;alert&quot;&gt;</code></td></tr><tr><td>th:include</td><td>布局标签，替换内容到引入的文件</td><td><code>&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt;</code></td></tr><tr><td>th:replace</td><td>布局标签，替换整个标签到引入的文件</td><td><code>&lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:selected</td><td>selected选择框 选中</td><td><code>th:selected=&quot;($&#123;xxx.id&#125; == $&#123;configObj.dd&#125;)&quot;</code></td></tr><tr><td>th:src</td><td>图片类地址引入</td><td><code>&lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@&#123;/img/logo.png&#125;&quot; /&gt;</code></td></tr><tr><td>th:inline</td><td>定义js脚本可以使用变量</td><td><code>&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;</code></td></tr><tr><td>th:action</td><td>表单提交的地址</td><td><code>&lt;form action=&quot;subscribe.html&quot; th:action=&quot;@&#123;/subscribe&#125;&quot;&gt;</code></td></tr><tr><td>th:remove</td><td>删除某个属性</td><td><code>&lt;tr th:remove=&quot;all&quot;&gt;</code> 1.all:删除包含标签和所有的子节点。2.body:不包含标记删除,但删除其所有的子节点。3.tag:包含标记的删除,但不删除它的子节点。4.all-but-first:删除所有包含标签的子节点,除了第一个。5.none:什么也不做。这个值是有用的动态评估</td></tr><tr><td>th:attr</td><td>设置标签属性，多个属性可以用逗号分隔</td><td>比如 <code>th:attr=&quot;src=@&#123;/image/aa.jpg&#125;,title=#&#123;logo&#125;&quot;</code>，此标签不太优雅，一般用的比较少</td></tr></tbody></table><p>还有非常多的标签，这里只列出最常用的几个，由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:</p><pre><code>    include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。 </code></pre><blockquote><p>Thymeleaf 是一个非常灵活和优秀的前端页面模板引擎，使用 Thymeleaf 可以非常灵活的对页面进行布局，复用通用页面。Thymeleaf 提供了各种常用的语法，非常方便我们在前端页面中使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac高效工作的玩法配置总结</title>
      <link href="/2018/03/20/%E6%9D%82%E8%AE%B0/%20Mac%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%8E%A9%E6%B3%95%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/03/20/%E6%9D%82%E8%AE%B0/%20Mac%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%8E%A9%E6%B3%95%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Mac 上有很多提升工作效率的工具，及配置，以下是一些来自网络和自己的总结汇总，希望给小伙伴们带来帮助</p></blockquote><h2 id="1-硬件提升"><a href="#1-硬件提升" class="headerlink" title="1. 硬件提升"></a>1. 硬件提升</h2><p>MacBook Pro + 外接一台显示器，事半功倍～</p><h2 id="2-系统设置"><a href="#2-系统设置" class="headerlink" title="2. 系统设置"></a>2. 系统设置</h2><h3 id="2-1-设置触摸板轻触为单击"><a href="#2-1-设置触摸板轻触为单击" class="headerlink" title="2.1 设置触摸板轻触为单击"></a>2.1 设置触摸板轻触为单击</h3><p>通过轻点触摸板来实现点按，提高效率<br>打开<code>系统偏好设置</code>，点击<code>触摸板</code>图标，勾选<code>轻点来点按</code>选项，现在手指轻轻一碰触摸板，就达到鼠标单击的顺滑效果。</p><h3 id="2-2-设置三指拖移"><a href="#2-2-设置三指拖移" class="headerlink" title="2.2 设置三指拖移"></a>2.2 设置三指拖移</h3><p>点按拖动好累，可以设置为三指拖动<br>打开<code>系统偏好设置</code>，点击<code>辅助功能</code>图标，选中<code>鼠标和触摸板</code>,点击<code>触摸板选项...</code>,勾选<code>启动拖移</code>选项，下拉选择三指拖移，确认后，只要把鼠标指针指向窗口标题栏位置，就可以三个指头拖着窗口移动了～</p><h3 id="2-3-三指查词"><a href="#2-3-三指查词" class="headerlink" title="2.3 三指查词"></a>2.3 三指查词</h3><p>在浏览网页时，突然一些单词想英转中，亦或中转英，Mac可是支持的哦，简单设置一下即可<br>打开<code>系统便好设置</code>，点击<code>触摸板</code>，在<code>光标与点按</code>选项卡中，勾选<code>查询与数据检测器</code>。</p><p>网页上随意选中一个单词，三指点按触摸板，即可查询词语含义及中英文</p><h3 id="2-4-将Dock停靠在屏幕左边"><a href="#2-4-将Dock停靠在屏幕左边" class="headerlink" title="2.4 将Dock停靠在屏幕左边"></a>2.4 将Dock停靠在屏幕左边</h3><p>为什么要将<code>Dock</code>停靠在屏幕左边？MacBook的屏幕是一个长方形，如果你将<code>Dock</code>放在下面，那么屏幕的可用<code>宽度</code>就会减少，另外人眼阅读时的顺序是从左往右，因此<code>Dock</code>放在左边更适合将MacBook作为工作电脑的人。</p><p>打开<code>系统偏好设置</code>，点击<code>Dock</code>图标，</p><ol><li>将图标的<code>大小</code>调到合适大小</li><li>关闭<code>放大</code>特效（即鼠标放到Dock上图标放大的效果，此效果干扰注意力）</li><li>在<code>置于屏幕上的位置</code>一栏，选择<code>左边</code></li><li>勾选<code>将窗口最小化为应用图标</code></li><li>勾选<code>自动显示和隐藏Dock</code> 增加工作显示区域～</li></ol><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj53f3p8qj210q0ke773.jpg"><br>图2.3-1</p><h3 id="2-5-全键盘控制模式"><a href="#2-5-全键盘控制模式" class="headerlink" title="2.5 全键盘控制模式"></a>2.5 全键盘控制模式</h3><p>全键盘控制模式是什么？ 举一个例子，如下图所示，我正在写一个文档，此文档还没有保存，也没有文件名，如果不不小心点了<code>关闭</code>按钮，将会弹出一个对话框：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/d390b46f0e56030ee7731af9231d52b8a997c4ee"><br>图2.4-1</p><p>当前，<code>[Save]</code>按钮处于默认激活状态，按<code>回车</code>将会弹出保存对话框。但是如果我不想保存呢？ 只能通过鼠标或者触摸板来移动光标后点击<code>[Don&#39;t Save]</code>来取消保存。那我能不能通过键盘控制光标激活<code>[Don&#39;t Save]</code>按钮呢？ 答案是肯定的，做一个简单设置就好。</p><p>如图，首先打开<code>系统偏好设置</code>，点击<code>键盘</code>图标，选择<code>快捷键</code>这个Tab, 选中<code>所有控制</code></p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj56gp6toj210i0voznz.jpg"><br>图2.4-2</p><p>现在当我再次试图关闭一个未保存的文件时，新弹出的对话框如下，有了些许变化，在<code>[Don&#39;t Save]</code>按钮上多了一个蓝色的外框，当你按键盘上的<code>tab</code>键的时候，蓝色的外框会在3个按钮间切换。 假设现在蓝色的外框在<code>[Don&#39;t Save]</code>按钮上，你按下<code>回车</code>，却发现系统依然进入了<code>保存</code>文件对话框，为什么蓝色的外框不起作用呢？那是因为蓝色的外框选中的按钮是由<code>空格键</code>触发的，当你按下<code>空格键</code>，系统就会不保存文件直接退出。 这样当你不方便使用鼠标和触摸板的时候，可以更快速的和你的MacBook交互。</p><p>  <img src="http://img1.tbcdn.cn/L1/461/1/3abe8997fe7e3180655e05505d532fca0a37e640"><br>图2.4-3</p><h3 id="2-6-快速锁定屏幕-触发脚设置"><a href="#2-6-快速锁定屏幕-触发脚设置" class="headerlink" title="2.6 快速锁定屏幕-触发脚设置"></a>2.6 快速锁定屏幕-触发脚设置</h3><p>如果你长时间离开电脑，最好锁定你的屏幕，以<code>防止数据泄露</code>。 那如何快速的锁定你的MacBook呢？ 答案是只需要<code>一摸触摸板</code>或者<code>一甩鼠标</code>就可以了。</p><ul><li><p>打开<code>系统偏好设置</code>，点击<code>桌面和屏幕保护程序</code>图标，选择<code>屏幕保护程序</code>这个Tab，再点击<code>触发脚...</code>，在弹出的如下界面里面，右下角选择<code>启动屏幕保护程序</code>，点击OK确定。<img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj5c5ckwvj210m0uyafi.jpg"><br>图2.5-1</p></li><li><p>再打开<code>系统偏好设置</code>，点击<code>安全性与隐私</code>图标，在<code>通用</code>Tab内，勾选<code>进入睡眠或开始屏幕保护要求输入密码</code>。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj5guwpkkj210e0ew0uo.jpg"></p></li></ul><p>图2.5-2</p><p>现在当你离开电脑前时，记得<code>一摸触摸板</code>或者<code>一甩鼠标</code>将光标快速的移到屏幕的右下角，MacBook将立刻进入<code>屏幕保护</code>模式并且需要<code>密码</code>才能进入桌面。</p><h2 id="3-系统常用快捷键"><a href="#3-系统常用快捷键" class="headerlink" title="3. 系统常用快捷键"></a>3. 系统常用快捷键</h2><p>请<a href="https://support.apple.com/zh-cn/HT201236">点击</a>这个文档，学习系统快捷键，适当使用快捷键将会提升你的工作效率。</p><h2 id="4-日常软件推荐"><a href="#4-日常软件推荐" class="headerlink" title="4. 日常软件推荐"></a>4. 日常软件推荐</h2><h3 id="4-1-中文输入法"><a href="#4-1-中文输入法" class="headerlink" title="4.1 中文输入法"></a>4.1 中文输入法</h3><p>自带或搜狗吧，发现搜狗跟很多IDE一起玩时，不太兼容，我现在多已经习惯了自带输入法</p><h3 id="4-2-开源窗口管理软件-–-ShiftIt"><a href="#4-2-开源窗口管理软件-–-ShiftIt" class="headerlink" title="4.2 开源窗口管理软件 – ShiftIt"></a>4.2 开源窗口管理软件 – ShiftIt</h3><ol><li>想要文档在左半屏幕，IDE在右半屏幕？</li><li>终于搞好了外接显示器，你是否经常将某个窗口在笔记本和外接显示器屏幕之间直接来回拖动？</li></ol><p><a href="https://github.com/fikovnik/ShiftIt">ShiftIt</a>快速解决这样的需求，分屏软件千千万，在Mac上多是收费的，这是一款开源的，体验很6，当前app窗口中，快捷键按下<code>control+option+command + M</code>，则会立即进入全屏模式。</p><p>刚安装或重启时，可能会需要对<code>ShiftIt</code> 授权</p><p>打开<code>系统偏好设置</code>，点击<code>安全性和隐私</code>图标，在<code>隐私</code>Tab内，点击<code>辅助功能</code>，然后勾选<code>ShiftIt.app</code>（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。）</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj95z8j7cj210a0ton0b.jpg"><br>图4.2-2</p><p>如果你此时接上了外接显示器，快捷键按下<code>control+option+command+ N</code>，则当前左边显示器激活的最前端窗口将被立即发送到旁边的的显示器。</p><p>下面列举一些<code>ShiftIt</code>常用的快捷键，更多的快捷键和使用方式请查询其<a href="https://github.com/fikovnik/ShiftIt">ShiftIt</a>。</p><ul><li><p><code>control+option+command + M</code> ： 使当前窗口全屏</p></li><li><p><code>control+option+command + 方向键上键</code> ： 使当前窗口占用当前屏幕上半部分</p></li><li><p><code>control+option+command + 方向键下键</code> ： 使当前窗口占用当前屏幕下半部分</p></li><li><p><code>control+option+command + 方向键左键</code> ： 使当前窗口占用当前屏幕左半部分</p></li><li><p><code>control+option+command + 方向键右键</code> ： 使当前窗口占用当前屏幕右半部分</p></li><li><p><code>control+option+command + 1</code> ： 使当前窗口占用当前屏幕左上角</p></li><li><p><code>control+option+command + 2</code> ： 使当前窗口占用当前屏幕右上角</p></li><li><p><code>control+option+command + 3</code> ： 使当前窗口占用当前屏幕左下角</p></li><li><p><code>control+option+command + 4</code> ： 使当前窗口占用当前屏幕右下角</p></li><li><p><code>control+option+command + N</code> ： 将当前窗口发送到下一个显示器屏幕</p></li><li><p><code>control+option+command + P</code> ： 将当前窗口发送到前一个显示器屏幕</p></li></ul><h3 id="4-3-效率神器-–-Alfred"><a href="#4-3-效率神器-–-Alfred" class="headerlink" title="4.3 效率神器 – Alfred"></a>4.3 效率神器 – Alfred</h3><p>如果你曾经使用过MacBook，你应该接触过<a href="https://support.apple.com/zh-cn/HT204014">Spotlight</a>，就是屏幕中间弹出一个长条输入框，你输入文件名或者应用程序名，Spotlight将模糊查找到对应的候选项，按回车快速的打开你需要的文件或程序。</p><p><a href="http://www.alfredapp.com/">Alfred</a>的能力远远超过了Spotlight, 你可以直接下载免费版安装使用，Alfred另外还提供了更强大的工作流(Workflows)和剪切板(Clipboard)管理等高级功能，需要购买Powerpack。对于日常的操作，免费版已经足够使用了。</p><p>因为Alfred可以完全取代Spotlight，下面先删除Spotlight占用的快捷键<code>command + 空格</code>，以供Alfred将来使用。</p><p>打开<code>系统偏好设置</code>，选择<code>键盘</code>，切换到<code>快捷键</code>这个Tab下，点击Spotlight，取消对应的2个快捷键设置。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9khpvi9j21000vigpn.jpg"><br>图4.3-1</p><p>打开Alfred，在菜单栏点击Alfred图标，打开<code>Preferences...</code></p><p>如下图所示，设置Alfred的快捷键为<code>command + 空格</code></p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9nqs2snj21ok0mmjws.jpg"><br>图4.3-2</p><p>现在按下快捷键<code>command + 空格</code>，输入微信，Alfred将所有包含dash的应用程序，文档以及历史网址都列出来了，如下图所示，回车打开<code>微信</code>，<code>command+2</code>打开本微信Web开发者工具，你还可以移动键盘上下键或者光标来选择目标。<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9t38ywej20va0a83zp.jpg"></p><p>图4.3-3</p><p>更多关于Alfred的使用方式和无限想象力，请参考<a href="http://www.alfredapp.com/">官方网站</a>或者网上现有的大量的教程。</p><h3 id="4-4-快速切换和打开应用程序-—-Command-Tab-Plus-Manico-功效一样一样滴"><a href="#4-4-快速切换和打开应用程序-—-Command-Tab-Plus-Manico-功效一样一样滴" class="headerlink" title="4.4 快速切换和打开应用程序 — Command-Tab Plus | Manico (功效一样一样滴)"></a>4.4 快速切换和打开应用程序 — Command-Tab Plus | Manico (功效一样一样滴)</h3><p>MacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下<code>tab + command</code>，将看到如下图的样式：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/216e6046485410605dc1883952ae22f8a685e3c5"><br>图4.4-1</p><p>如果你想要却换到Firefox，需要再按一下<code>tab</code>，如果要切换到日历，需要按两下‘tab’，如果一次性打开10几个应用程序，你经常需要按十几下<code>tab</code>才能却换到想要的程序。</p><p><a href="http://commandtab.noteifyapp.com/">Command-Tab Plus</a>专为这个场景而设计，安装好后打开，默认快捷键是按住<code>option</code>，如图所示，此时按下数字<code>7</code>就能快速打开编号为<code>7</code>的<code>地图</code>。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/bd61382e4d329f7932dff65e7bf426a3bf6dc8cf"><br>图4.4-2</p><p>这些app会经常限时免购，可以关注一些公众号来获取</p><h3 id="4-5-随心所欲的复制粘贴以及无限想象-—-PopClip"><a href="#4-5-随心所欲的复制粘贴以及无限想象-—-PopClip" class="headerlink" title="4.5 随心所欲的复制粘贴以及无限想象 — PopClip"></a>4.5 随心所欲的复制粘贴以及无限想象 — PopClip</h3><ul><li>日常工作中，你有多少次是从一个应用程序复制一段文本然后粘贴到另外一个地方？</li><li>有多少次是复制一个网址然后打开浏览器粘贴到地址栏然后回车打开？</li><li>有多少次是复制一个名词，然后打开浏览器找到搜索引擎来搜索？</li></ul><p>这些重复的操作模式都是可以简化的，你唯一需要的就是<a href="http://pilotmoon.com/popclip/">PopClip</a>，当你选中一段文字（如下图，选中“当日收益”），PopClip就会弹出来一个快捷操作栏，你可以复制，剪切或者粘贴，更为强大的是，PopClip提供了很多免费的插件，例如使用指定的搜索引擎搜索选中的文字，或者选中英文单词做大小写转换等等。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/43e10d3e2589595b9b371620817878ffa49bf8f2"><br>图4.5-1</p><p>需要注意的是，PopClip需要你的授权才能弹出快捷状态栏，直接点击<code>打开 系统偏好设置</code>或者打开<code>系统偏好设置</code>，点击<code>安全性与隐私</code>图标，在<code>隐私</code>Tab内，点击<code>辅助功能</code>，然后勾选PopClip。（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。）</p><h3 id="4-6-增强资源管理器-—-XtraFinder"><a href="#4-6-增强资源管理器-—-XtraFinder" class="headerlink" title="4.6 增强资源管理器 — XtraFinder"></a>4.6 增强资源管理器 — XtraFinder</h3><p>MacBook自带的资源管理器(Finder)已经可以满足一般的需要，但是当你有大量文件维护操作后，你就需要一个更强大的Finder。<a href="https://www.trankynam.com/xtrafinder/">XtraFinder</a>完全集成到Finder里面，你根本感觉不出它是一个第三方的应用程序，同时还提供很多增强特性，比如：</p><ul><li><p>像浏览器那样的标签页(Tab)</p></li><li><p>支持双操作面板(Panel)</p></li><li><p>增强的全局快捷键，例如新建文件(New File)等</p></li><li><p>多彩的侧边栏图标</p></li><li><p>快速在当前文件夹打开终端</p></li><li><p>快速在当前文件夹新建文件</p><p><img src="http://img2.tbcdn.cn/L1/461/1/a9d636d1331d528d71ab9d720c7f64987b1b1350"></p></li></ul><p>图4.8-1</p><h3 id="4-7-随心所欲的全键盘控制-–-Shortcat"><a href="#4-7-随心所欲的全键盘控制-–-Shortcat" class="headerlink" title="4.7 随心所欲的全键盘控制 – Shortcat"></a>4.7 随心所欲的全键盘控制 – Shortcat</h3><p>在系统设置里面，我介绍了<code>全键盘控制模式</code>，但是此模式只能做简单的按钮控制，无法达到随心所欲的控制。下面介绍一款比较geek的软件，<a href="https://shortcatapp.com/">Shortcat</a>帮助你完全使用键盘来控制系统，供有键盘强迫症的同学使用。</p><p>  <img src="http://img3.tbcdn.cn/L1/461/1/5920267ce10a6f28b669919720f4d8b196b78ff9"><br>图4.9-1</p><h3 id="4-8-来杯鸡尾酒-—-Bartender"><a href="#4-8-来杯鸡尾酒-—-Bartender" class="headerlink" title="4.8 来杯鸡尾酒 — Bartender"></a>4.8 来杯鸡尾酒 — Bartender</h3><p>如果你看到这里，相信你已经被我推(hu)荐(you)的安装了一排软件，你的系统状态栏已经<code>人满为患</code>，有时候会因为当前激活的应用程序的菜单比较多挡住你要点击的状态栏图标，这个时候你需要一个<code>酒保</code>来帮你调理一下状态栏，<a href="http://www.macbartender.com/">Bartender 3</a>就可以自定义隐藏某些不常用的状态栏图标，特别适合处女座强迫症。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/ed09772f6172235bd4b9de1a10c182703e298a35"><br>图4.8-1</p><h3 id="4-9-markdown工具：-typora"><a href="#4-9-markdown工具：-typora" class="headerlink" title="4.9 markdown工具： typora"></a>4.9 markdown工具： typora</h3><p><a href="https://typora.io/">typora</a> 是一款所见即所得的markdown编辑工具，不像其他工具那样，左边写，右边预览效果，整体编辑简介很多还有各种高效特性，推荐之</p><h3 id="4-10-omini家族"><a href="#4-10-omini家族" class="headerlink" title="4.10 omini家族"></a>4.10 omini家族</h3><p><a href="https://www.omnigroup.com/">The Omni Group</a> 家族各种高效软件，件件精品，值得大家关注</p><p>The Omni Group 家族主要有四款：</p><ul><li>OmniFocus：GTD工具，主要用于个人事务的不同维度的清单管理</li><li>OmniGraffle：绘图神器，包括流程图、组织结构图、插图、脑图、原型等</li><li>OmniOutliner：写文章提纲必备</li><li>OmniPlan：项目管理工具，主要用于项目团队的进度、资源、成本管理</li></ul><h3 id="4-11-快速进入Shell"><a href="#4-11-快速进入Shell" class="headerlink" title="4.11 快速进入Shell"></a>4.11 快速进入Shell</h3><p><a href="http://zipzapmac.com/Go2Shell">go2shell</a>是一个对开发者来说非常有用的app, 使用它可以在Finder里快速进入shell环境.</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjcwzekeqj20bw09aaab.jpg"></p><p>图4.11-1</p><p>安装好以后, 打开Finder, 点击Finder上的图标即可进入terminal:</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjd3s6xoij21cm0j4mzd.jpg"></p><p>图4.11-2</p><h3 id="4-12-快速录屏–QuickTimePlayer"><a href="#4-12-快速录屏–QuickTimePlayer" class="headerlink" title="4.12 快速录屏–QuickTimePlayer"></a>4.12 快速录屏–QuickTimePlayer</h3><p>QuickTime Player是一个自带的录屏软件, 你可以用它来录制视屏,音频,以及屏幕操作. 对于开发者, 可以用它来记录屏幕操作, 做成动态图或视频, 供其它人学习; 对于普通工作者, 可以用QuickTime Player录制PPT讲座视频,右键图标，<code>新建影片录制</code></p><blockquote><p>Mac 上有太多的提高工作效率的工具了，我在这里在列一下其他一些常用工具，希望大家多多分享自己的工具和心得～</p></blockquote><ul><li><p>清理工具： cleanMyMac，会自动提醒，该清理啦～</p></li><li><p>api文档查询 ： dash （配合 alfred3 点工作流可以快速查找api文档） 命令行终端：iTerm2</p></li><li><p>文档编辑：sublime3 + 各种插件，vScode也不错</p></li><li><p>抓包工具（还可以用来模拟各种网络环境，给客户端当代理）： charles</p></li><li><p>接口管理及测试：postman</p></li><li><p>压缩工具： BetterZip</p></li><li><p>支持ntfs移动硬盘：好多人都是windows 转的mac ，之前的移动硬盘肯定很多资料，这里推荐两款可以让Mac支持写入NTFS格式硬盘的工具，<a href="https://www.tuxera.com/products/tuxera-ntfs-for-mac/">tuxera</a> （收费），<a href="http://enjoygineering.com/mounty/">Mounty for NTFS</a> (免费)</p></li><li><p>远程windows ： Microsoft Remote Desktop （微软官网下载的）</p></li><li><p>思维导图：xmind，mindnote</p></li><li><p>ftp管理（froklift）我现在基本是用scp命令啥的</p></li><li><p>翻墙：蓝灯 ／ ShadowsocksX （目前我用的ShadowsocksX ，买的VPS）</p></li></ul><p>… 好多好多吧，先举栗这些～</p><h2 id="5-开发环境配置"><a href="#5-开发环境配置" class="headerlink" title="5. 开发环境配置"></a>5. 开发环境配置</h2><p>好了，到了咱们开发环境的配置阶段，在配置开发环境前，建议先将OS X系统升级到最新版，同时去Mac <a href="http://www.apple.com/osx/apps/app-store/">App Store</a>下载最新版的<a href="https://developer.apple.com/xcode/">Xcode</a>，然后使用下面的命令安装Xcode command line tools，这将为你安装很多终端下面常用的命令，将来很可能会使用到：</p><p>Shell</p><table><thead><tr><th>1</th><th>xcode-select –install</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="5-1-命令行终端Terminal"><a href="#5-1-命令行终端Terminal" class="headerlink" title="5.1 命令行终端Terminal"></a>5.1 命令行终端Terminal</h3><p>在用户界面没有发明前，终端Terminal曾经是计算机的唯一交互方式，就算到了今天，很多服务器仍然只提供终端登陆来操作，作为开发测试运维相关人员，在日常工作中合理使用终端将大大提高工作效率。</p><h4 id="5-1-1-替换系统默认Shell-—-Oh-My-ZSH"><a href="#5-1-1-替换系统默认Shell-—-Oh-My-ZSH" class="headerlink" title="5.1.1 替换系统默认Shell — Oh My ZSH!"></a>5.1.1 替换系统默认Shell — Oh My ZSH!</h4><p><a href="http://www.gnu.org/software/bash/">Bash</a>作为大多数系统默认安装的Shell，大家都多少有所接触，<a href="http://www.zsh.org/">Zsh</a>和Bash类似都是一个Shell，但是Zsh更注重用户体验和与人的交互，OS X默认也安装好了Zsh，然而你想自己从头开始配置一个顺手的Zsh是比较浪费时间的，有人已经帮我们配置好了，这个流行的Zsh配置叫—<a href="http://ohmyz.sh/">Oh My ZSH!</a>，直观的效果如下图所示，不是是很炫酷，代码开源在<a href="https://github.com/robbyrussell/oh-my-zsh">github</a>。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpje803mrhj20xy0jewmh.jpg"><br>图5.1.1-1</p><ul><li>切换默认Shell到Zsh</li></ul><p>Mac OS X默认已经安装好了Zsh，你可以打开终端，输入<code>zsh --version</code>来确认，如果没有安装，请参考<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH">这个文档</a>。</p><p>打开终端输入下面的命令，切换默认Shell为Zsh：</p><p>Shell</p><table><thead><tr><th>1</th><th>chsh -s &#x2F;bin&#x2F;zsh</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>关闭终端重新打开后，你将默认使用zsh作为终端Shell。然而你会发现，终端并没有变得多酷炫，接着往下走，<code>安装Oh My ZSH!</code></p><ul><li>安装Oh My ZSH!</li></ul><p>打开终端输入下面的命令：</p><p>Shell</p><table><thead><tr><th>1</th><th>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>耐心等待一会儿，然后你就会发现你的终端变成了彩色的了。</p><p>  <img src="http://img3.tbcdn.cn/L1/461/1/379712ed6ac5b61c40224f663ccd4ce4c4ab0180"><br>图5.1.1-2</p><p>你可以修改终端的Profile，选择深色背景profile，这样就比较炫酷了。如果你对默认的<code>Oh My ZSH</code>的配色不满意，请参考<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes">这里</a>找到你喜欢的配色。</p><h4 id="5-1-2-替换系统默认终端-—-iTerm-2"><a href="#5-1-2-替换系统默认终端-—-iTerm-2" class="headerlink" title="5.1.2 替换系统默认终端 — iTerm 2"></a>5.1.2 替换系统默认终端 — iTerm 2</h4><p>经常使用终端，建议使用<a href="https://www.iterm2.com/">iTerm 2</a>来替代系统自带的终端。关于iTerm 2的特性，请看<a href="https://www.iterm2.com/features.html">这里</a>。</p><p>这里只介绍一个小技巧，我想设置一个快捷键假设为<code>Alt + .</code>(新Mac 不能直观的按功能键了，外接键盘可以设置为F12之类的)，在任意场合，我按一下快捷键<code>Alt + .</code>就弹出终端，输入一些命令执行后，再按一下<code>Alt + .</code>终端就自动隐藏，这对经常使用终端的人，例如经常ssh连接服务器的人来说实在太方便了。</p><p>设置过程如下：</p><ul><li><p>打开iTerm的<code>Preferences...</code>， 在<code>Profiles</code>Tab里面，点击下面的[<code>+</code>]添加一个新的profile，为什么要新建一个profile？答案是为了定制将来<code>弹出</code>的终端样式和大小等等参数。新的profile假设命名为guake，(注：guake这个名称是为了向Linux下的<a href="http://guake.org/">Guake</a>终端致敬)，你可以自己任意起个名称，下面会用到。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjelx1aidj21ec0uugqu.jpg"></p></li></ul><p>图5.1.2-1</p><p>再切换到<code>Window</code>Tab下，将<code>Style</code>，<code>Screen</code>和<code>Space</code>这3个值设置和下图一样。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjenm8g44j21e20rs79v.jpg"><br>图5.1.2-2</p><p>再切换到<code>Keys</code>Tab下，设置如下图所示的<code>Hotkey</code>Alt + .。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjeox6o93j21ga0rq10u.jpg"><br>图5.1.2-3</p><p>现在你按下<code>Alt + .</code>，就立即得到一个占满全屏的黑色命令行终端，再按一下Alt + .隐藏终端，非常的方便。</p><h3 id="5-2-终端下的命令管理-—-Homebrew"><a href="#5-2-终端下的命令管理-—-Homebrew" class="headerlink" title="5.2 终端下的命令管理 — Homebrew"></a>5.2 终端下的命令管理 — Homebrew</h3><p>Mac <a href="http://www.apple.com/osx/apps/app-store/">App Store</a>你一定非常熟悉了，它可以帮你下载和安装大部分常见的软件。</p><p>在终端下，我们也需要一个App Store一样的管理程序，当你需要安装某个终端下的新命令的时候，这个程序可以帮助我们自动下载该命令以及相关的依赖，甚至在下载以后做必要的编译和环境设置。</p><p><a href="http://brew.sh/index.html">Homebrew</a>就是这样一款终端下的命令程序包管理器，安装非常简单，复制如下命令在终端下运行，按回车并输入密码后等待安装成功：</p><p>Shell</p><table><thead><tr><th>1</th><th>&#x2F;usr&#x2F;bin&#x2F;ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是安装截图：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/d97a24018bf9c6a95000f66b46800f7c3d9ff208"><br>图5.2-1</p><p>curl和wget是命令行下面常用的命令，其中curl已经默认安装在OS X中了，但是wget没有默认安装，下面演示如何使用Homebrew来安装wget。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install wget</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是运行截图：<br>  <img src="http://img4.tbcdn.cn/L1/461/1/c821f88dc7fa44040ea4261a57f6906fcc41a822"><br>图5.2-2</p><h3 id="5-3-终端下管理非终端软件-—-Homebrew-Cask"><a href="#5-3-终端下管理非终端软件-—-Homebrew-Cask" class="headerlink" title="5.3 终端下管理非终端软件 — Homebrew Cask"></a>5.3 终端下管理非终端软件 — Homebrew Cask</h3><p>因为Apple不允许第三方的浏览器进入Mac App Store，如果你想要安装Google Chrome，只能去Google网站下载后运行安装文件。这一类App Store没有的非终端下的软件能不能享受Homebrew一样的命令行安装的便捷性呢？</p><p><a href="http://caskroom.io/">Homebrew Cask</a>就是这样一款终端下的程序管理器，它扩展了Homebrew，作为Mac App Store的有益补充，方便你快速维护日常软件的安装升级和卸载，复制如下命令在终端下运行，按回车后等待安装成功：</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install caskroom&#x2F;cask&#x2F;brew-cask</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是运行截图：</p><p>  <img src="http://img2.tbcdn.cn/L1/461/1/fcc161f5926170d0d2bb3ecaf9be280b563b1726"><br>图5.3-1</p><p>那如何使用Homebrew Cask来安装Google Chrome呢？ 首先使用<code>chrome</code>作为关键字查找一下：</p><p>Shell</p><table><thead><tr><th>1</th><th>&gt; brew cask search chrome &#x3D;&#x3D;&gt; Partial matches chrome-devtools chrome-remote-desktop-host chromecast google-chrome</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>上面的命令运行后列出了4个候选项，很明显最后一个<code>google-chrome</code>就是我们要安装的，继续输入</p><p>Shell</p><table><thead><tr><th>1</th><th>&gt; brew cask install google-chrome</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面只需要稍微等一会儿，最新版的Google Chrome就乖乖的安装在你的MacBook里面了。</p><h3 id="5-4-Java开发环境搭建"><a href="#5-4-Java开发环境搭建" class="headerlink" title="5.4 Java开发环境搭建"></a>5.4 Java开发环境搭建</h3><h4 id="5-4-1-安装Java和Maven"><a href="#5-4-1-安装Java和Maven" class="headerlink" title="5.4.1 安装Java和Maven"></a>5.4.1 安装Java和Maven</h4><p>现在OS X没有默认安装JDK，如果你在终端输入<code>java</code>，系统会引导你到Oracle网站去<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载</a>，然后自己点击下载文件来安装，这个过程一点都不酷，而且不能自动化。现在你有了Homebrew Cask，只要输入如下命令，Java就可以自动安装好啦。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew cask install java</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>现在最近版本的JDK是1.8，Homebrew默认安装最新版软件，如果你要安装非最新版的JDK，那么去Oracle网站下载吧，Homebrew的多版本支持不是很好用。</p><p>同样的，输入如下命令来安装Maven最新版。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install maven</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在开发中，你很可能会碰到这个错误<code>java.security.InvalidKeyException: Illegal key size or default parameters</code>，那是因为美国对出口软件<a href="http://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters">加密算法长度的限制</a>，你需要去如下链接下载补丁包：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">JCE Unlimited Policy for JDK 6</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">JCE Unlimited Policy for JDK 7</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JCE Unlimited Policy for JDK 8</a></li></ul><p>补丁替换路径为<code>$&#123;java.home&#125;/jre/lib/security/</code>，大约如下所示：</p><p>Shell</p><table><thead><tr><th>1</th><th>&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_51.jdk&#x2F;Contents&#x2F;Home&#x2F;jre&#x2F;lib&#x2F;security</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="5-4-2-安装版本控制软件-—-SmartGit-amp-SmartSVN"><a href="#5-4-2-安装版本控制软件-—-SmartGit-amp-SmartSVN" class="headerlink" title="5.4.2 安装版本控制软件 — SmartGit &amp; SmartSVN"></a>5.4.2 安装版本控制软件 — SmartGit &amp; SmartSVN</h4><p>如果代码就是生命，版本控制系统就是时光机。<a href="https://git-scm.com/">Git</a>和<a href="https://subversion.apache.org/">Subversion</a>分别是现在最流行的2个版本控制系统，<a href="http://www.syntevo.com/smartgit/">SmartGit</a>和<a href="http://www.smartsvn.com/download?file=smartsvn/smartsvn-macosx-8_6_7.dmg">SmartSVN</a>分别是他们的一个第三方客户端，当然他们有很多第三方客户端，我觉得SmartGit和SmartSVN是最好用的。</p><h4 id="5-4-3-安装和配置IDE-—-IntelliJ-IDEA"><a href="#5-4-3-安装和配置IDE-—-IntelliJ-IDEA" class="headerlink" title="5.4.3 安装和配置IDE — IntelliJ IDEA"></a>5.4.3 安装和配置IDE — IntelliJ IDEA</h4><p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>作为最智能的Java IDE，推荐所有Java开发人员使用，你可以在<a href="https://www.jetbrains.com/idea/download/">这里下载</a>安装文件，或者使用如下的Homebrew Cask命令来下载安装：</p><p>Shell</p><table><thead><tr><th>1</th><th>brew cask install intellij-idea</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><blockquote><p>其他一些高效办公的总结</p></blockquote><ul><li><a href="http://fantasykai.cc/2017/12/03/tools/chrome%20tools/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/">Chrome浏览器技巧总结</a></li><li><a href="http://fantasykai.cc/2017/10/14/mac/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/">收藏高效的小工具</a></li><li><a href="http://fantasykai.cc/2017/08/26/mac/iterm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/">iTerm2 快捷操作</a></li><li><a href="http://fantasykai.cc/2017/09/07/Linux/ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/">ssh 设置别名的方式访问服务器</a></li><li><a href="http://fantasykai.cc/2017/10/08/mac/oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/">oh-my-zsh的环境变量配置</a></li><li><a href="http://fantasykai.cc/2016/12/09/mac/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">brew常用命令</a></li><li><a href="https://sspai.com/post/27403">10 个实用技巧，让 Finder 带你飞</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sails守护进程启动</title>
      <link href="/2018/03/11/%E6%B5%8B%E8%AF%95/%20sails%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/03/11/%E6%B5%8B%E8%AF%95/%20sails%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>玩了下 sails ，发现 sails lift –prod 之类的，如果关闭终端窗口，服务就停止了，用 nohup 启动也没啥luan 用，汗，如何使用守护进程后台启动嘞，好吧，Google之 </p></blockquote><p>sails官网推荐 forever、pm2，大家可以根据个人喜好选择。</p><p>使用 forever</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g forever      安装守护进程</span><br><span class="line">forever start app.js --prod  开启守护进程</span><br><span class="line">forever list  显示运行的服务</span><br><span class="line">forever restartall  重启服务(建议用这个)</span><br><span class="line">forever stopall     停止12345</span><br></pre></td></tr></table></figure><p>使用 pm2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g pm2  安装守护进程</span><br><span class="line">pm2 start app.js -x  开启守护进程</span><br><span class="line">pm2 restart all      重启所有进程</span><br><span class="line">pm2 restart 0        重启指定进程</span><br><span class="line">pm2 stop all         停止</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用pm2</p></blockquote><p>生产环境可以这样启动</p><p>pm2 start app.js – –prod<br>sails默认支持 –prod的参数读取生产环境配置 那启动的时候传给他就可以<br>–之后的参数会传递到node app.js里执行</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python性能优化</title>
      <link href="/2018/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>优化算法时间复杂度</strong></p><p>算法的时间复杂度对程序的执行效率影响最大，在 Python 中可以通过选择合适的数据结构来优化时间复杂度，如 list 和 set 查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。</p><h3 id="减少冗余数据"><a href="#减少冗余数据" class="headerlink" title="减少冗余数据"></a><strong>减少冗余数据</strong></h3><p>如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。</p><h3 id="合理使用-copy-与-deepcopy"><a href="#合理使用-copy-与-deepcopy" class="headerlink" title="合理使用 copy 与 deepcopy"></a><strong>合理使用 copy 与 deepcopy</strong></h3><p>对于 dict 和 list 等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用 copy 包里的 copy 和 deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在 ipython 中运行）</p><blockquote><p>import copy</p><p>a &#x3D; range(100000)</p><p>%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)</p><p>%timeit -n 10 copy.deepcopy(a)</p><p>10 loops, best of 3: 1.55 ms per loop</p><p>10 loops, best of 3: 151 ms per loop</p></blockquote><p>timeit 后面的-n表示运行的次数，后两行对应的是两个 timeit 的输出，下同。由此可见后者慢一个数量级。</p><h3 id="使用-dict-或-set-查找元素"><a href="#使用-dict-或-set-查找元素" class="headerlink" title="使用 dict 或 set 查找元素"></a><strong>使用 dict 或 set 查找元素</strong></h3><p>python dict 和 set 都是使用 hash 表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)</p><blockquote><p>a &#x3D; range(1000)s &#x3D; set(a)d &#x3D; dict((i,1) for i in a)%timeit -n 10000 100 in d%timeit -n 10000 100 in s10000 loops, best of 3: 43.5 ns per loop10000 loops, best of 3: 49.6 ns per loop</p></blockquote><p>dict 的效率略高(占用的空间也多一些)。</p><h3 id="合理使用生成器（generator）和-yield"><a href="#合理使用生成器（generator）和-yield" class="headerlink" title="合理使用生成器（generator）和 yield"></a><strong>合理使用生成器（generator）和 yield</strong></h3><blockquote><p>%timeit -n 100 a &#x3D; (i for i in range(100000))%timeit -n 100 b &#x3D; [i for i in range(100000)]100 loops, best of 3: 1.54 ms per loop100 loops, best of 3: 4.56 ms per loop</p></blockquote><p>使用()得到的是一个 generator 对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如 set(i for i in range(100000))会比 set([i for i in range(100000)])快。</p><p>但是对于需要循环遍历的情况：</p><blockquote><p>%timeit -n 10 for x in (i for i in range(100000)): pass%timeit -n 10 for x in [i for i in range(100000)]: pass10 loops, best of 3: 6.51 ms per loop10 loops, best of 3: 5.54 ms per loop</p></blockquote><p>后者的效率反而更高，但是如果循环里有 break,用 generator 的好处是显而易见的。yield 也是用于创建 generator：</p><blockquote><p>def yield_func(ls):    </p><p>​    for i in ls:</p><p>​        yield i+1</p><p>def not_yield_func(ls):    </p><p>​    return [i+1 for i in ls]</p><p>ls &#x3D; range(1000000)%timeit -n 10 for i in yield_func(ls):pass</p><p>%timeit -n 10 for i in not_yield_func(ls):pass</p><p>10 loops, best of 3: 63.8 ms per loop</p><p>10 loops, best of 3: 62.9 ms per loop</p></blockquote><p>对于内存不是非常大的 list，可以直接返回一个 list，但是可读性 yield 更佳(人个喜好)。</p><p>python2.x 内置 generator 功能的有 xrange 函数、itertools 包等。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="优化循环"><a href="#优化循环" class="headerlink" title="优化循环"></a><strong>优化循环</strong></h3><p>循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：</p><blockquote><p>a &#x3D; range(10000)size_a &#x3D; len(a)%timeit -n 1000 for i in a: k &#x3D; len(a)%timeit -n 1000 for i in a: k &#x3D; size_a</p><p>1000 loops, best of 3: 569 µs per loop</p><p>1000 loops, best of 3: 256 µs per loop</p></blockquote><h3 id="优化包含多个判断表达式的顺序"><a href="#优化包含多个判断表达式的顺序" class="headerlink" title="优化包含多个判断表达式的顺序"></a><strong>优化包含多个判断表达式的顺序</strong></h3><p>对于 and，应该把满足条件少的放在前面，对于 or，把满足条件多的放在前面。如：</p><blockquote><p>a &#x3D; range(2000)  %timeit -n 100 [i for i in a if 10 &lt; i &lt; 20 or 1000 &lt; i &lt; 2000]%timeit -n 100 [i for i in a if 1000 &lt; i &lt; 2000 or 100 &lt; i &lt; 20]     %timeit -n 100 [i for i in a if i % 2 &#x3D;&#x3D; 0 and i &gt; 1900]%timeit -n 100 [i for i in a if i &gt; 1900 and i % 2 &#x3D;&#x3D; 0]</p><p>100 loops, best of 3: 287 µs per loop</p><p>100 loops, best of 3: 214 µs per loop</p><p>100 loops, best of 3: 128 µs per loop</p><p>100 loops, best of 3: 56.1 µs per loop</p></blockquote><h3 id="使用-join-合并迭代器中的字符串"><a href="#使用-join-合并迭代器中的字符串" class="headerlink" title="使用 join 合并迭代器中的字符串"></a><strong>使用 join 合并迭代器中的字符串</strong></h3><blockquote><p>In [1]: %%timeit   …: s &#x3D; ‘’   …: for i in a:   …:         s +&#x3D; i   …:10000 loops, best of 3: 59.8 µs per loopIn [2]: %%timeits &#x3D; ‘’.join(a)   …:100000 loops, best of 3: 11.8 µs per loop</p></blockquote><p>join 对于累加的方式，有大约5倍的提升。</p><h3 id="选择合适的格式化字符方式"><a href="#选择合适的格式化字符方式" class="headerlink" title="选择合适的格式化字符方式"></a><strong>选择合适的格式化字符方式</strong></h3><blockquote><p>s1, s2 &#x3D; ‘ax’, ‘bx’</p><p>%timeit -n 100000 ‘abc%s%s’ % (s1, s2)</p><p>%timeit -n 100000 ‘abc{0}{1}’.format(s1, s2)</p><p>%timeit -n 100000 ‘abc’ + s1 + s2</p><p>100000 loops, best of 3: 183 ns per loop</p><p>100000 loops, best of 3: 169 ns per loop</p><p>100000 loops, best of 3: 103 ns per loop</p></blockquote><p>三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得%的可读性最好)</p><h3 id="不借助中间变量交换两个变量的值"><a href="#不借助中间变量交换两个变量的值" class="headerlink" title="不借助中间变量交换两个变量的值"></a><strong>不借助中间变量交换两个变量的值</strong></h3><blockquote><p>In [3]: %%timeit -n 10000    a,b&#x3D;1,2   ….: c&#x3D;a;a&#x3D;b;b&#x3D;c;   ….:10000 loops, best of 3: 172 ns per loopIn [4]: %%timeit -n 10000</p><p>a,b&#x3D;1,2</p><p>a,b&#x3D;b,a   ….:</p><p>10000 loops, best of 3: 86 ns per loop</p></blockquote><p>使用a,b&#x3D;b,a而不是c&#x3D;a;a&#x3D;b;b&#x3D;c;来交换a,b的值，可以快1倍以上。</p><h3 id="使用-if-is"><a href="#使用-if-is" class="headerlink" title="使用 if is"></a><strong>使用 if is</strong></h3><blockquote><p>a &#x3D; range(10000)</p><p>%timeit -n 100 [i for i in a if i &#x3D;&#x3D; True]</p><p>%timeit -n 100 [i for i in a if i is True]</p><p>100 loops, best of 3: 531 µs per loop</p><p>100 loops, best of 3: 362 µs per loop</p></blockquote><p>使用 if is True 比 if &#x3D;&#x3D; True 将近快一倍。</p><h3 id="使用级联比较x-lt-y-lt-z"><a href="#使用级联比较x-lt-y-lt-z" class="headerlink" title="使用级联比较x &lt; y &lt; z"></a><strong>使用级联比较x &lt; y &lt; z</strong></h3><blockquote><p>x, y, z &#x3D; 1,2,3</p><p>%timeit -n 1000000 if x &lt; y &lt; z:pass</p><p>%timeit -n 1000000 if x &lt; y and y &lt; z:pass</p><p>1000000 loops, best of 3: 101 ns per loop</p><p>1000000 loops, best of 3: 121 ns per loop</p></blockquote><p>x &lt; y &lt; z效率略高，而且可读性更好。</p><h3 id="while-1-比-while-True-更快"><a href="#while-1-比-while-True-更快" class="headerlink" title="while 1 比 while True 更快"></a><strong>while 1 比 while True 更快</strong></h3><blockquote><p>def while_1():</p><p>​    n &#x3D; 100000</p><p>​    while 1:</p><p>​        n -&#x3D; 1</p><p>​        if n &lt;&#x3D; 0: break</p><p>def while_true():    n &#x3D; 100000    while True:        n -&#x3D; 1        if n &lt;&#x3D; 0: break    </p><p>m, n &#x3D; 1000000, 1000000 </p><p>%timeit -n 100 while_1()%timeit -n 100 while_true()</p><p>100 loops, best of 3: 3.69 ms per loop</p><p>100 loops, best of 3: 5.61 ms per loop</p></blockquote><p>while 1 比 while true 快很多，原因是在 python2.x 中，True 是一个全局变量，而非关键字。</p><h3 id="使用-而不是-pow"><a href="#使用-而不是-pow" class="headerlink" title="*使用*而不是 pow"></a>*<em>使用*<em>而不是 pow</em></em></h3><blockquote><p>%timeit -n 10000 c &#x3D; pow(2,20)%timeit -n 10000 c &#x3D; 2**2010000 loops, best of 3: 284 ns per loop10000 loops, best of 3: 16.9 ns per loop</p></blockquote><p>**就是快10倍以上！</p><h3 id="使用-cProfile-cStringIO-和-cPickle-等用c实现相同功能（分别对应profile-StringIO-pickle）的包"><a href="#使用-cProfile-cStringIO-和-cPickle-等用c实现相同功能（分别对应profile-StringIO-pickle）的包" class="headerlink" title="使用 cProfile, cStringIO 和 cPickle 等用c实现相同功能（分别对应profile, StringIO, pickle）的包"></a><strong>使用 cProfile, cStringIO 和 cPickle 等用c实现相同功能（分别对应profile, StringIO, pickle）的包</strong></h3><blockquote><p>import cPickle</p><p>import pickle</p><p>a &#x3D; range(10000)</p><p>%timeit -n 100 x &#x3D; cPickle.dumps(a)</p><p>%timeit -n 100 x &#x3D; pickle.dumps(a)</p><p>100 loops, best of 3: 1.58 ms per loop</p><p>100 loops, best of 3: 17 ms per loop</p></blockquote><p>由c实现的包，速度快10倍以上！</p><p><strong>使用最佳的反序列化方式</strong></p><p>下面比较了 eval, cPickle, json 方式三种对相应字符串反序列化的效率：</p><blockquote><p>import json</p><p>import cPickle</p><p>a &#x3D; range(10000)</p><p>s1 &#x3D; str(a)</p><p>s2 &#x3D; cPickle.dumps(a)</p><p>s3 &#x3D; json.dumps(a)</p><p>%timeit -n 100 x &#x3D; eval(s1)</p><p>%timeit -n 100 x &#x3D; cPickle.loads(s2)</p><p>%timeit -n 100 x &#x3D; json.loads(s3)</p><p>100 loops, best of 3: 16.8 ms per loop</p><p>100 loops, best of 3: 2.02 ms per loop</p><p>100 loops, best of 3: 798 µs per loop</p></blockquote><p>可见 json 比 cPickle 快近3倍，比 eval 快20多倍。</p><h3 id="使用C扩展-Extension"><a href="#使用C扩展-Extension" class="headerlink" title="使用C扩展(Extension)"></a><strong>使用C扩展(Extension)</strong></h3><p>目前主要有 CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得 Python 程序可以调用由C编译成的动态链接库，其特点分别是：</p><p>CPython 原生 API: 通过引入 Python.h 头文件，对应的C程序中可以直接使用Python 的数据结构。实现过程相对繁琐，但是有比较大的适用范围。</p><p>ctypes: 通常用于封装(wrap)C程序，让纯 Python 程序调用动态链接库（Windows 中的 dll 或 Unix 中的 so 文件）中的函数。如果想要在 python 中使用已经有C类库，使用 ctypes 是很好的选择，有一些基准测试下，python2+ctypes 是性能最好的方式。</p><p>Cython: Cython 是 CPython 的超集，用于简化编写C扩展的过程。Cython 的优点是语法简洁，可以很好地兼容 numpy 等包含大量C扩展的库。Cython 的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。</p><p>cffi: cffi 的就是 ctypes 在 pypy（详见下文）中的实现，同进也兼容 CPython。cffi提供了在 python 使用C类库的方式，可以直接在 python 代码中编写C代码，同时支持链接到已有的C类库。</p><p>使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。</p><h3 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a><strong>并行编程</strong></h3><p>因为 GIL 的存在，Python 很难充分利用多核 CPU 的优势。但是，可以通过内置的模块 multiprocessing 实现下面几种并行模式：</p><p>多进程：对于 CPU 密集型的程序，可以使用 multiprocessing 的 Process,Pool 等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。</p><p>多线程：对于 IO 密集型的程序，multiprocessing.dummy 模块使用 multiprocessing 的接口封装 threading，使得多线程编程也变得非常轻松(比如可以使用 Pool 的 map 接口，简洁高效)。</p><p>分布式：multiprocessing 中的 Managers 类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。</p><p>不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。</p><h3 id="终级大杀器：PyPy"><a href="#终级大杀器：PyPy" class="headerlink" title="终级大杀器：PyPy"></a><strong>终级大杀器：PyPy</strong></h3><p>PyPy 是用 RPython(CPython 的子集)实现的 Python，根据官网的基准测试数据，它比 CPython 实现的 Python 要快6倍以上。快的原因是使用了 Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前 pypy 中还保留着 GIL，不过正在进行的 STM 项目试图将 PyPy 变成没有 GIL 的 Python。</p><p>如果 python 程序中含有C扩展(非cffi的方式)，JIT 的优化效果会大打折扣，甚至比 CPython 慢（比 Numpy）。所以在 PyPy 中最好用纯 Python 或使用 cffi 扩展。</p><p>随着 STM，Numpy 等项目的完善，相信 PyPy 将会替代 CPython。</p><h3 id="使用性能分析工具"><a href="#使用性能分析工具" class="headerlink" title="使用性能分析工具"></a><strong>使用性能分析工具</strong></h3><p>除了上面在 ipython 使用到的 timeit 模块，还有 cProfile。cProfile 的使用方式也非常简单： python -m cProfile filename.py，filename.py 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p>[1] <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/">http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/</a></p><p>[2] <a href="http://maxburstein.com/blog/speeding-up-your-python-code/">http://maxburstein.com/blog/speeding-up-your-python-code/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9新特性</title>
      <link href="/2018/02/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/02/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Java9新特性之—目录结构"><a href="#1、Java9新特性之—目录结构" class="headerlink" title="1、Java9新特性之—目录结构"></a>1、Java9新特性之—目录结构</h1><p>​    包含jdk8及以前的jdk版本，所有目录结构以及目录含义如图：</p><p><img src="https://static.oschina.net/uploads/space/2018/0223/134757_QthE_3209213.png" alt="img"> </p><p><img src="https://static.oschina.net/uploads/space/2018/0223/134835_7knf_3209213.png" alt="img"></p><p>​    jdk9之后，目录结构发生变化如图：</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/134936_Br5K_3209213.png" alt="img"></p><p>​     这个新特性只要了解下就可以了，这个目录结构是方便为了接下来新特性做保证</p><h1 id="2、Java9新特性之—JShell工具"><a href="#2、Java9新特性之—JShell工具" class="headerlink" title="2、Java9新特性之—JShell工具"></a>2、Java9新特性之—JShell工具</h1><p>​       怎么理解，怎么用呢？这个只是针对于java9来说，相当于cmd工具，你可以和cmd一样，直接写方法等等，不过我认为只是适用于初学者做一些最简单的运算和写一些方法：</p><p>​        在cmd中打开这个工具：</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/141123_Zanv_3209213.png" alt="img"></p><p>​         进入工具后可以做一些简单的java操作</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/141217_v4Rg_3209213.png" alt="img"></p><p>​        。。。。等等，我认为只适用于初学者学习java不用其他编辑工具就可以学习java</p><h1 id="3、Java9新特性之—模块化"><a href="#3、Java9新特性之—模块化" class="headerlink" title="3、Java9新特性之—模块化"></a>3、Java9新特性之—模块化</h1><p>​        一个大型的项目，比如淘宝商城等，都会包含多个模块，比如订单模块，前台模块，后台管理模块，广告位模块，会员模块…..等等，各个模块之间会相互调用，不过这种情况下会很少，只针对特殊情况，如果一个项目有30个模块系统进行开发，但是只要某个单独模块运行时，都会带动所有的模块，这样对于jvm来说在内存和性能上会很低，所以，java9提供了这一个特性，某一个模块运行的时候，jvm只会启动和它有依赖的模块，并不会加载所有的模块到内存中，这样性能大大的提高了。写法上如下：</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/135741_hQRX_3209213.png" alt="img"></p><p>​        一个项目中的两个模块，模块之间通过module-info.java来关联，在IDEA编辑器右键创建package-info.java</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/135923_DO9V_3209213.png" alt="img"></p><p>​        在这个两个模块java9Demo和java9Test中，java9demo编写一个实体类Person,在java9Test调用这样一个过程</p><p>​        这个是java9Demo 将 java9Test 模块需要的文件导出 exports  把它所在的包导出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module java9Demo&#123;</span><br><span class="line">    exports com.mdxl.layer_cj.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后在java9Test模块中创建一个package-info.java,引入java9Demo模块导出包名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module java9Test&#123;</span><br><span class="line">    requires java9Demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接在java9Test中引入Person实体类了，这只是一个简单的例子。exports 控制着那些包可以被模块访问，所以不被导出的包不能被其他模块访问</p><h1 id="4、Java9新特性之—多版本兼容Jar包"><a href="#4、Java9新特性之—多版本兼容Jar包" class="headerlink" title="4、Java9新特性之—多版本兼容Jar包"></a>4、Java9新特性之—多版本兼容Jar包</h1><p>​        怎么理解呢？</p><p>​       好多公司用的jdk大部分还是老版本，jdk6,7 都有，他们都不敢升级主要是因为兼容的问题，但是java9做到了这一点，就是不管公司的项目是用的java6,7,8甚至5，他都可以兼容不出错，打个比方，你之前用的是iphone5，现在出现了iPhone6，iphone7，iphon8和iphone9，但是你不敢买9，因为你自己已经适应了iphone5的所有手机的运行流程，6,7,8每个手机的运行流程不一样，但是这个9很强大，它能够识别你现在所用的版本iphone是5，所以当你升级到iphone9的时候，你的这个手机运行流程还是iphone5的流程，只是在原有基础上拥有了更多的iphone9的所有优势。</p><h1 id="5、Java9新特性之—接口Interface的升级"><a href="#5、Java9新特性之—接口Interface的升级" class="headerlink" title="5、Java9新特性之—接口Interface的升级"></a>5、Java9新特性之—接口Interface的升级</h1><p>​        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface FilterProcess&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //java 7 及以前 特性  全局常量 和抽象方法</span><br><span class="line">    public static final String a =&quot;22&quot;;</span><br><span class="line">    boolean process(T t);</span><br><span class="line"></span><br><span class="line">    //java 8 特性 静态方法和默认方法</span><br><span class="line">    default void love()&#123;</span><br><span class="line">        System.out.println(&quot;java8 特性默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void haha()&#123;</span><br><span class="line">        System.out.println(&quot;java8 特性静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //java 8 特性 支持私有方法</span><br><span class="line">    private void java9()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、Java9新特性之—钻石操作符的升级"><a href="#6、Java9新特性之—钻石操作符的升级" class="headerlink" title="6、Java9新特性之—钻石操作符的升级"></a>6、Java9新特性之—钻石操作符的升级</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//java6及以前</span><br><span class="line">Map&lt;String,String&gt; map7 = new HashMap&lt;String,String&gt;();</span><br><span class="line">//java7和8 &lt;&gt;没有了数据类型</span><br><span class="line">Map&lt;String,String&gt; map8 = new HashMap&lt;&gt;();</span><br><span class="line">//java9 添加了匿名内部类的功能 后面添加了大括号&#123;&#125;  可以做一些细节的操作</span><br><span class="line">Map&lt;String,String&gt; map9 = new HashMap&lt;&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="7、Java9新特性之—异常处理try升级"><a href="#7、Java9新特性之—异常处理try升级" class="headerlink" title="7、Java9新特性之—异常处理try升级"></a>7、Java9新特性之—异常处理try升级</h1><p>​    首先看下jdk6,7,8,9 的try catch的比较</p><p>​    Java6处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//java7及以前写法  每一个流打开的时候都要关闭</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    InputStreamReader reader = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        reader = new InputStreamReader(System.in);</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        if (reader != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    java7,8 共同的处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//java7和8及 每一个流打开的时候都要关闭,但是在try的括号中来进行关闭</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    try(InputStreamReader reader =new InputStreamReader(System.in))&#123;</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    java9的处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//java9及 每一个流打开的时候都要关闭,但是在try的括号中来进行关闭，在</span><br><span class="line">//java8的基础上进一步升级 直接在try括号中直接写入 变量就好，如果有多个流，就用分号隔开</span><br><span class="line">//try(reader;writer)&#123;&#125;</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    InputStreamReader reader =new InputStreamReader(System.in);</span><br><span class="line">    try(reader)&#123;</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这下子应该一幕了然了吧</p><h1 id="8、Java9新特性之—特殊标识符增加限制"><a href="#8、Java9新特性之—特殊标识符增加限制" class="headerlink" title="8、Java9新特性之—特殊标识符增加限制"></a>8、Java9新特性之—特殊标识符增加限制</h1><p>​    java8 之前 String _ &#x3D;”hello”;  这样的标识符可以用，java9就用不到。</p><h1 id="9、Java9新特性之—String底层存储结构更换"><a href="#9、Java9新特性之—String底层存储结构更换" class="headerlink" title="9、Java9新特性之—String底层存储结构更换"></a>9、Java9新特性之—String底层存储结构更换</h1><p>​    java8之前 String的底层结构类型都是 char[] ,但是java9 就替换成 byte[] 这样来讲，更节省了空间和提高了性能</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144044_FEnG_3209213.png" alt="img"></p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144120_QBpj_3209213.png" alt="img"></p><p>​    之所以替换是因为 之前一直是最小单位是一个char，用到两个byte,但是java8是基于latin1的，而这个latin1编码可以用一个byte标识，所以当你数据明明可以用到一个byte的时候，我们用到了一个最小单位chat两个byte，就多出了一个byte的空间。所以java9在这一方面进行了更新，现在的java9 是基于ISO&#x2F;latin1&#x2F;Utf-16  ,latin1和ISO用一个byte标识,UTF-16用两个byte标识，java9会自动识别用哪个编码，当数据用到1byte，就会使用iSO或者latin1 ，当空间数据满足2byte的时候，自动使用utf-16,节省了很多空间</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144527_x6kt_3209213.png" alt="img"></p><p><em><strong><strong>同理，StringBuilder StringBuffer也更换了底层数据结构</strong></strong></em>********</p><h1 id="10、Java9新特性之—Stream-API-新方法的添加"><a href="#10、Java9新特性之—Stream-API-新方法的添加" class="headerlink" title="10、Java9新特性之—Stream API 新方法的添加"></a>10、Java9新特性之—Stream API 新方法的添加</h1><p>​    在原有Stream API 新添加了4个方法，takeWhile dropWhile ofNullable iterate(新重载方法)</p><p>​    首先解释 takeWhile 当达到一定条件就结束：输出结果为45 43，如图</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144923_sNmR_3209213.png" alt="img"></p><p>​    而 dropWhile 则和takeWhile 相反</p><p>​    ofNullable, 在java8中 Stream中的元素不能完全为null，否则空指针异常，而在java9的升级中，允许创建null</p><p>​    iterate 不加条件无线循环</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/145645_gggz_3209213.png" alt="img"></p><h1 id="11、Java9新特性之—引进HttpClient"><a href="#11、Java9新特性之—引进HttpClient" class="headerlink" title="11、Java9新特性之—引进HttpClient"></a>11、Java9新特性之—引进HttpClient</h1><p>​    以往我们都是通过maven添加httpclient ,java9直接引入即可</p><p>Java9所有特性都是为了提高性能和内存。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 安装opencv 报错，解决</title>
      <link href="/2018/02/11/%E6%9D%82%E8%AE%B0/%20mac%20%E5%AE%89%E8%A3%85opencv%20%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/02/11/%E6%9D%82%E8%AE%B0/%20mac%20%E5%AE%89%E8%A3%85opencv%20%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="mac-安装opencv-报错，解决"><a href="#mac-安装opencv-报错，解决" class="headerlink" title="mac 安装opencv 报错，解决"></a>mac 安装opencv 报错，解决</h3><p>安装成功后，引入 cv2 报错</p><p>Python 3.6.4<br>[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin<br>Type “help”, “copyright”, “credits” or “license” for more information.</p><blockquote><blockquote><blockquote><p>import cv2<br>ceback (most recent call last):<br>ile “<stdin>“, line 1, in <module><br>ortError: dlopen(&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;3.4.0_1&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;cv2.cpython-36m-darwin.so, 2): Library not loaded: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;jack&#x2F;lib&#x2F;libjack.0.dylib<br>eferenced from: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;ffmpeg&#x2F;lib&#x2F;libavcodec.57.dylib<br>eason: image not found</p></blockquote></blockquote></blockquote><p>最终通过下面命令解决：</p><p>​brew install opencv3 –with-contrib –with-python3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS分析</title>
      <link href="/2018/01/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAS%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAS%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CAS，Compare And Swap，即比较并交换。Doug lea大神在同步组件中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090001.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090001_thumb.png" alt="201703090001"></a></p><h2 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h2><p>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(this.value == A)&#123;</span><br><span class="line">this.value = B</span><br><span class="line">return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure><p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p><p>valueOffset为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p><p>value当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p><p>我们就以AtomicInteger的addAndGet()方法来做说明，先看源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final int addAndGet(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要是看compareAndSwapInt方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>该方法为本地方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值（有位伙伴告诉我他面试的时候就问到这四个变量是啥意思…+_+）。该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看openjdk的源码。</p><p>CAS可以保证一次的读-改-写操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点儿复杂了。</p><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><p><em>总线加锁</em>：总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p><p><strong>缓存加锁</strong>：其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p><h2 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h2><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p><p><strong>循环时间太长</strong></p><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><p><strong>只能保证一个共享变量原子操作</strong></p><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><p><strong>ABA问题</strong></p><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>用一个例子来阐述ABA问题所带来的影响。</p><p>有如下链表</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090002.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090002_thumb.png" alt="201703090002"></a></p><p>假如我们想要把B替换为A，也就是compareAndSet(this,A,B)。线程1执行B替换A操作，线程2主要执行如下动作，A 、B出栈，然后C、A入栈，最终该链表如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090003.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090003_thumb.png" alt="201703090003"></a></p><p>完成后线程1发现仍然是A，那么compareAndSet(this,A,B)成功，但是这时会存在一个问题就是B.next &#x3D; null,compareAndSet(this,A,B)后，会导致C丢失，改栈仅有一个B元素，平白无故把C给丢失了。</p><p>CAS的ABA隐患问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。对于上面的案例应该线程1会失败。</p><p>AtomicStampedReference的compareAndSet()方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。源码部门很好理解预期的引用 &#x3D;&#x3D; 当前引用，预期的标识 &#x3D;&#x3D; 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static class Pair&lt;T&gt; &#123;</span><br><span class="line">      final T reference;</span><br><span class="line">      final int stamp;</span><br><span class="line">      private Pair(T reference, int stamp) &#123;</span><br><span class="line">          this.reference = reference;</span><br><span class="line">          this.stamp = stamp;</span><br><span class="line">      &#125;</span><br><span class="line">      static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">          return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private volatile Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。如set方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void set(V newReference, int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    if (newReference != current.reference || newStamp != current.stamp)</span><br><span class="line">        this.pair = Pair.of(newReference, newStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将通过一个例子可以可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将100 —&gt; 110 —&gt; 100，线程2执行 100 —&gt;120，看两者之间的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //AtomicInteger</span><br><span class="line">        Thread at1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                atomicInteger.compareAndSet(100,110);</span><br><span class="line">                atomicInteger.compareAndSet(110,100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread at2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      // at1,执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        at1.start();</span><br><span class="line">        at2.start();</span><br><span class="line"></span><br><span class="line">        at1.join();</span><br><span class="line">        at2.join();</span><br><span class="line"></span><br><span class="line">        //AtomicStampedReference</span><br><span class="line"></span><br><span class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //让 tsf2先获取stamp，导致预期时间戳不一致</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1</span><br><span class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int stamp = atomicStampedReference.getStamp();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tsf1.start();</span><br><span class="line">        tsf2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090004_2.jpg"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090004_2_thumb.jpg" alt="201703090004_2"></a></p><p>运行结果充分展示了AtomicInteger的ABA问题和AtomicStampedReference解决ABA问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis相关总结2</title>
      <link href="/2018/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%932/"/>
      <url>/2018/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><blockquote><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</p></blockquote><h3 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h3><p>1 、Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</p><p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p><p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p><p>4、 redis的速度比memcached快很多</p><p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis与Memcached的区别与比较"></p><p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached与Redis》</strong>：<a href="https://link.juejin.im/?target=https://www.imooc.com/article/23549">www.imooc.com/article/235…</a></p><h3 id="Redis与Memcached的选择"><a href="#Redis与Memcached的选择" class="headerlink" title="Redis与Memcached的选择"></a>Redis与Memcached的选择</h3><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis；</p><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。详细了解请参考：《Redis事务介绍（四）》：<a href="https://link.juejin.im/?target=https://blog.csdn.net/cuipeng0916/article/details/53698774">blog.csdn.net&#x2F;cuipeng0916…</a></p><p>redis监控：锁的介绍</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="Redis常见数据结构使用场景"><a href="#Redis常见数据结构使用场景" class="headerlink" title="Redis常见数据结构使用场景"></a>Redis常见数据结构使用场景</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h4><blockquote><p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote><p><strong>常用命令：</strong> hget,hset,hgetall 等。</p></blockquote><p>Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p><p><strong>举个例子：</strong> 最近做的一个电商网站项目的首页就使用了redis的hash数据结构进行缓存，因为一个网站的首页访问量是最大的，所以通常网站的首页可以通过redis缓存来提高性能和并发量。我用<strong>jedis客户端</strong>来连接和操作我搭建的redis集群或者单机redis，利用jedis可以很容易的对redis进行相关操作，总的来说从搭一个简单的集群到实现redis作为缓存的整个步骤不难。感兴趣的可以看我昨天写的这篇文章：</p><p><strong>《一文轻松搞懂redis集群原理及搭建与使用》：</strong> <a href="https://link.juejin.im/?target=https://juejin.im/post/5ad54d76f265da23970759d3">juejin.im&#x2F;post&#x2F;5ad54d…</a></p><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote><p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。</p><p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote><p><strong>常用命令：</strong> sadd,spop,smembers,sunion 等</p></blockquote><p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p><h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote><p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p><h3 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）</h3><p>   相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据</li></ol><h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决?"></a>Redis的并发竞争问题如何解决?</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p><p> 1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。   2.服务器角度，利用setnx实现锁。</p><p> 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h3 id="Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><p><strong>Redis内存回收:LRU算法（写的很不错，推荐）</strong>：<a href="https://link.juejin.im/?target=https://www.cnblogs.com/WJ5888/p/4371647.html">www.cnblogs.com/WJ5888/p/43…</a></p><h3 id="Redis-大量数据插入"><a href="#Redis-大量数据插入" class="headerlink" title="Redis 大量数据插入"></a>Redis 大量数据插入</h3><p>官方文档给的解释：<a href="https://link.juejin.im/?target=http://www.redis.cn/topics/mass-insert.html">www.redis.cn/topics/mass…</a></p><h3 id="Redis-分区的优势、不足以及分区类型"><a href="#Redis-分区的优势、不足以及分区类型" class="headerlink" title="Redis 分区的优势、不足以及分区类型"></a>Redis 分区的优势、不足以及分区类型</h3><p>官方文档提供的讲解：<a href="https://link.juejin.im/?target=http://www.redis.net.cn/tutorial/3524.html">www.redis.net.cn/tutorial/35…</a></p><h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><p><strong>《redis的持久化和缓存机制》</strong> ：<a href="https://link.juejin.im/?target=https://blog.csdn.net/tr1912/article/details/70197085?foxhandler=RssReadRenderProcessHandler">blog.csdn.net&#x2F;tr1912&#x2F;arti…</a></p><p>扩容的话可以通过redis集群实现，之前做项目的时候用过自己搭的redis集群 然后写了一篇关于redis集群的文章：<strong>《一文轻松搞懂redis集群原理及搭建与使用》</strong>：<a href="https://link.juejin.im/?target=https://juejin.im/post/5ad54d76f265da23970759d3">juejin.im&#x2F;post&#x2F;5ad54d…</a></p><h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案:"></a>Redis常见性能问题和解决方案:</h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li></ol><h3 id="Redis与消息队列"><a href="#Redis与消息队列" class="headerlink" title="Redis与消息队列"></a>Redis与消息队列</h3><blockquote><p>作者：翁伟 链接：<a href="https://www.zhihu.com/question/20795043/answer/345073457">https://www.zhihu.com/question/20795043/answer/345073457</a></p></blockquote><p>不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做去消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque： antirez&#x2F;disque:<a href="https://link.juejin.im/?target=https://github.com/antirez/disque">github.com&#x2F;antirez&#x2F;dis…</a>部署、协议等方面都跟redis非常类似，并且支持集群，延迟消息等等。</p><p>我在做网站过程接触比较多的还是使用redis做缓存，比如秒杀系统，首页缓存等等。</p><h2 id="好文Mark"><a href="#好文Mark" class="headerlink" title="好文Mark"></a>好文Mark</h2><p><strong>非常非常推荐下面几篇文章。。。</strong></p><p><strong>《Redis深入之道：原理解析、场景使用以及视频解读》</strong>：<a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/28073983">zhuanlan.zhihu.com&#x2F;p&#x2F;28073983</a>: 主要介绍了：Redis集群开源的方案、Redis协议简介及持久化Aof文件解析、Redis短连接性能优化等等内容，文章干货太大，容量很大，建议时间充裕可以看看。另外文章里面还提供了视频讲解，可以说是非常非常用心了。</p><p><strong>《阿里云Redis混合存储典型场景：如何轻松搭建视频直播间系统》：</strong><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/582487?utm_content=m_46529">yq.aliyun.com&#x2F;articles&#x2F;58…</a>: 主要介绍视频直播间系统，以及如何使用阿里云Redis混合存储实例方便快捷的构建大数据量，低延迟的视频直播间服务。还介绍到了我们之前提高过的redis的数据结构的使用场景</p><p><strong>《美团在Redis上踩过的一些坑-5.redis cluster遇到的一些问》</strong>：<a href="https://link.juejin.im/?target=http://carlosfu.iteye.com/blog/2254573">carlosfu.iteye.com&#x2F;blog&#x2F;225457…</a>：主要介绍了redis集群的两个常见问题，然后分享了 一些关于redis集群不错的文章。</p><p><strong>参考：</strong></p><p><a href="https://www.cnblogs.com/Survivalist/p/8119891.html">https://www.cnblogs.com/Survivalist/p/8119891.html</a></p><p><a href="http://www.redis.net.cn/tutorial/3524.html">http://www.redis.net.cn/tutorial/3524.html</a></p><p><a href="https://redis.io/">https://redis.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 总结</title>
      <link href="/2018/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%20Redis%20%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%20Redis%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后在性能调优等方面进行更深入的介绍和指导。</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>概述</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Redis 是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。</p><p>Redis 支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs 等。</p><p>Redis 具备 LRU 淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过 Redis Sentinel 实现的高可用方案，同时还支持通过 Redis Cluster 实现的数据自动分片能力。</p><p>Redis 的主要功能都基于单线程模型实现，也就是说 Redis 使用一个线程来服务所有的客户端请求，同时 Redis 采用了非阻塞式 IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p><blockquote><ul><li>Redis 是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li><li>Redis 的速度非常快（因为使用非阻塞式 IO，且大部分命令的算法时间复杂度都是 O(1))</li><li>使用高耗时的 Redis 命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为 O(N) 的 KEYS 命令，严格禁止在生产环境中使用）</li></ul></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="Redis-的数据结构和相关常用命令"><a href="#Redis-的数据结构和相关常用命令" class="headerlink" title="Redis 的数据结构和相关常用命令"></a>Redis 的数据结构和相关常用命令</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>本节中将介绍 Redis 支持的主要数据结构，以及相关的常用 Redis 命令。本节只对 Redis 命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的 Redis 命令集，或了解某个命令的详细使用方法，请参考官方文档：<a href="https://redis.io/commands">https://redis.io/commands</a></p><h3 id="常用命令一、Key"><a href="#常用命令一、Key" class="headerlink" title="常用命令一、Key"></a><strong>常用命令一、Key</strong></h3><p>Redis 采用 Key-Value 型的基本数据结构，任何二进制序列都可以作为 Redis 的 Key 使用（例如普通的字符串或一张 JPEG 图片）<br><strong>关于 Key 的一些注意事项：</strong></p><p>不要使用过长的 Key。例如使用一个 1024 字节的 key 就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</p><p>Key 短到缺失了可读性也是不好的，例如”u1000flw” 比起”user:1000:followers” 来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</p><p>最好使用统一的规范来设计 Key，比如”object-type:id:attr”，以这一规范设计出的 Key 可能是”user:1000” 或”comment:1234:reply-to”</p><p>Redis 允许的最大 Key 长度是 512MB（对 Value 的长度限制也是 512MB）</p><h3 id="常用命令二、String"><a href="#常用命令二、String" class="headerlink" title="常用命令二、String"></a><strong>常用命令二、String</strong></h3><p>String 是 Redis 的基础数据类型，Redis 没有 Int、Float、Boolean 等数据类型的概念，所有的基本类型在 Redis 中都以 String 体现。</p><p>与 String 相关的常用命令：</p><blockquote><ul><li>SET：为一个 key 设置 value，可以配合 EX&#x2F;PX 参数指定 key 的有效期，通过 NX&#x2F;XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li><li>GET：获取某个 key 对应的 value，时间复杂度 O(1)</li><li>GETSET：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li><li>MSET：为多个 key 设置 value，时间复杂度 O(N)</li><li>MSETNX：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li><li>MGET：获取多个 key 对应的 value，时间复杂度 O(N)</li></ul></blockquote><p>上文提到过，Redis 的基本数据类型只有 String，但 Redis 可以把 String 作为整型或浮点型数字来使用，主要体现在 INCR、DECR 类的命令上：</p><blockquote><ul><li>INCR：将 key 对应的 value 值自增 1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li><li>INCRBY：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li><li>DECR&#x2F;DECRBY：同 INCR&#x2F;INCRBY，自增改为自减。</li></ul></blockquote><p>INCR&#x2F;DECR 系列命令要求操作的 value 类型为 String，并可以转换为 64 位带符号的整型数字，否则会返回错误。</p><p>也就是说，进行 INCR&#x2F;DECR 系列命令的 value，必须在 [-2^63 ~ 2^63 - 1] 范围内。</p><p>前文提到过，Redis 采用单线程模型，天然是线程安全的，这使得 INCR&#x2F;DECR 命令可以非常便利的实现高并发场景下的精确控制。</p><ul><li><p><strong>例 1：库存控制</strong></p><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。</p><p>设置库存总量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET inv:remain &quot;100&quot;</span><br></pre></td></tr></table></figure><p>库存扣减 + 余量校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR inv:remain</span><br></pre></td></tr></table></figure><p>当 DECR 命令返回值大于等于 0 时，说明库存余量校验通过，如果返回小于 0 的值，则说明库存已耗尽。</p><p>假设同时有 300 个并发请求进行库存扣减，Redis 能够确保这 300 个请求分别得到 99 到 - 200 的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p></li><li><p><strong>例 2：自增序列生成</strong></p><p>实现类似于 RDBMS 的 Sequence 功能，生成一系列唯一的序列号</p><p>设置序列起始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET sequence &quot;10000&quot;</span><br></pre></td></tr></table></figure><p>获取一个序列值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR sequence</span><br></pre></td></tr></table></figure><p>直接将返回值作为序列使用即可。</p><p>获取一批（如 100 个）序列值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY sequence 100</span><br></pre></td></tr></table></figure><p>假设返回值为 N，那么 [N - 99 ~ N] 的数值都是可用的序列值。</p><p>当多个客户端同时向 Redis 申请自增序列时，Redis 能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p></li></ul><h3 id="常用命令三、List"><a href="#常用命令三、List" class="headerlink" title="常用命令三、List"></a><strong>常用命令三、List</strong></h3><p>Redis 的 List 是链表型的数据结构，可以使用 LPUSH&#x2F;RPUSH&#x2F;LPOP&#x2F;RPOP 等命令在 List 的两端执行插入元素和弹出元素的操作。虽然 List 也支持在特定 index 上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。</p><p>与 List 相关的常用命令：</p><blockquote><ul><li>LPUSH：向指定 List 的左侧（即头部）插入 1 个或多个元素，返回插入后的 List 长度。时间复杂度 O(N)，N 为插入元素的数量</li><li>RPUSH：同 LPUSH，向指定 List 的右侧（即尾部）插入 1 或多个元素</li><li>LPOP：从指定 List 的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li><li>RPOP：同 LPOP，从指定 List 的右侧（即尾部）移除 1 个元素并返回</li><li>LPUSHX&#x2F;RPUSHX：与 LPUSH&#x2F;RPUSH 类似，区别在于，LPUSHX&#x2F;RPUSHX 操作的 key 如果不存在，则不会进行任何操作</li><li>LLEN：返回指定 List 的长度，时间复杂度 O(1)</li><li>LRANGE：返回指定 List 中指定范围的元素（双端包含，即 LRANGE key 0 10 会返回 11 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List，避免使用 LRANGE key 0 -1 这样的完整遍历操作。</li></ul></blockquote><p>应谨慎使用的 List 相关命令：</p><blockquote><ul><li>LINDEX：返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 - 1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度 O(N)</li><li>LSET：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度 O(N)，如果操作的是头 &#x2F; 尾部的元素，则时间复杂度为 O(1)</li><li>LINSERT：向指定 List 中指定元素之前 &#x2F; 之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 - 1。如果指定 key 不存在，不会进行任何操作，时间复杂度 O(N)</li></ul></blockquote><p>由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 List 进行遍历，命令的耗时无法预估，在 List 长度大的情况下耗时会明显增加，应谨慎使用。</p><p>换句话说，Redis 的 List 实际是设计来用于实现队列，而不是用于实现类似 ArrayList 这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用 Redis 的 List 数据结构。</p><p>为了更好支持队列的特性，Redis 还提供了一系列阻塞式的操作命令，如 BLPOP&#x2F;BRPOP 等，能够实现类似于 BlockingQueue 的能力，即在 List 为空时，阻塞该连接，直到 List 中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（<a href="https://redis.io/topics/data-types-intro%EF%BC%89">https://redis.io/topics/data-types-intro）</a> 中”Blocking operations on lists” 一节。</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h2 id="常用命令四、Hash"><a href="#常用命令四、Hash" class="headerlink" title="常用命令四、Hash"></a>常用命令四、Hash</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>Hash 即哈希表，Redis 的 Hash 和传统的哈希表一样，是一种 field-value 型的数据结构，可以理解成将 HashMap 搬入 Redis。</p><p>Hash 非常适合用于表现对象类型的数据，用 Hash 中的 field 对应对象的 field 即可。</p><p>Hash 的优点包括：</p><blockquote><ul><li>可以实现二元查找，如” 查找 ID 为 1000 的用户的年龄”</li><li>比起将整个对象序列化后作为 String 存储的方法，Hash 能够有效地减少网络传输的消耗</li><li>当使用 Hash 维护一个集合时，提供了比 List 效率高得多的随机访问命令</li></ul></blockquote><p>与 Hash 相关的常用命令：</p><blockquote><ul><li>HSET：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li><li>HGET：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li><li>HMSET&#x2F;HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N 为一次操作的 field 数量</li><li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li><li>HEXISTS：判断指定 Hash 中 field 是否存在，存在返回 1，不存在返回 0，时间复杂度 O(1)</li><li>HDEL：删除指定 Hash 中的 field（1 个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li><li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li></ul></blockquote><p>应谨慎使用的 Hash 相关命令：</p><blockquote><ul><li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li><li>HKEYS&#x2F;HVALS：返回指定 Hash 中所有的 field&#x2F;value，时间复杂度 O(N)</li></ul></blockquote><p>上述三个命令都会对 Hash 进行完整遍历，Hash 中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历，具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h2 id="常用命令五、Set"><a href="#常用命令五、Set" class="headerlink" title="常用命令五、Set"></a>常用命令五、Set</h2><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><p>Redis Set 是无序的，不可重复的 String 集合。</p><p>与 Set 相关的常用命令：</p><blockquote><ul><li>SADD：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li><li>SREM：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li><li>SRANDMEMBER：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li><li>SPOP：从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li><li>SCARD：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li><li>SISMEMBER：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li><li>SMOVE：将指定 member 从一个 Set 移至另一个 Set</li></ul></blockquote><p>慎用的 Set 相关命令：</p><blockquote><ul><li>SMEMBERS：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li><li>SUNION&#x2F;SUNIONSTORE：计算多个 Set 的并集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li><li>SINTER&#x2F;SINTERSTORE：计算多个 Set 的交集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li><li>SDIFF&#x2F;SDIFFSTORE：计算 1 个 Set 与 1 或多个 Set 的差集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数。</li></ul></blockquote><p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），如果需要做并集 &#x2F; 交集 &#x2F; 差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行。</p><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h2 id="常用命令六、Sorted-Set"><a href="#常用命令六、Sorted-Set" class="headerlink" title="常用命令六、Sorted Set"></a>常用命令六、Sorted Set</h2><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><p>Redis Sorted Set 是有序的、不可重复的 String 集合。Sorted Set 中的每个元素都需要指派一个分数 (score)，Sorted Set 会根据 score 对元素进行升序排序。如果多个 member 拥有相同的 score，则以字典序进行升序排序。</p><p>Sorted Set 非常适合用于实现排名。</p><p>Sorted Set 的主要命令：</p><blockquote><ul><li>ZADD：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li><li>ZREM：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li><li>ZCOUNT：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li><li>ZCARD：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li><li>ZSCORE：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li><li>ZRANK&#x2F;ZREVRANK：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li><li>ZINCRBY：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li></ul></blockquote><p>慎用的 Sorted Set 相关命令：</p><blockquote><ul><li>ZRANGE&#x2F;ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M 为本次返回的 member 数</li><li>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序 &#x2F; 降序排序，min 和 max 可以指定为 - inf 和 + inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li><li>ZREMRANGEBYRANK&#x2F;ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围 &#x2F; 指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li></ul></blockquote><p>上述几个命令，应尽量避免传递 [0 -1] 或 [-inf +inf] 这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h2 id="常用命令七、Bitmap-和-HyperLogLog"><a href="#常用命令七、Bitmap-和-HyperLogLog" class="headerlink" title="常用命令七、Bitmap 和 HyperLogLog"></a>常用命令七、Bitmap 和 HyperLogLog</h2><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><p>Redis 的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令，请参考官方文档 <a href="https://redis.io/topics/data-types-intro">https://redis.io/topics/data-types-intro</a> 中的相关章节</p><p>Bitmap 在 Redis 中不是一种实际的数据类型，而是一种将 String 作为 Bitmap 使用的方法。可以理解为将 String 转换为 bit 数组。使用 Bitmap 来存储 true&#x2F;false 类型的简单数据极为节省空间。</p><p>HyperLogLogs 是一种主要用于数量统计的数据结构，它和 Set 类似，维护一个不可重复的 String 集合，但是 HyperLogLogs 并不维护具体的 member 内容，只维护 member 的个数。也就是说，HyperLogLogs 只能用于计算一个集合中不重复的元素数量，所以它比 Set 要节省很多内存空间。</p><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><blockquote><ul><li>EXISTS：判断指定的 key 是否存在，返回 1 代表存在，0 代表不存在，时间复杂度 O(1)</li><li>DEL：删除指定的 key 及其对应的 value，时间复杂度 O(N)，N 为删除的 key 数量</li><li>EXPIRE&#x2F;PEXPIRE：为一个 key 设置有效期，单位为秒或毫秒，时间复杂度 O(1)</li><li>TTL&#x2F;PTTL：返回一个 key 剩余的有效时间，单位为秒或毫秒，时间复杂度 O(1)</li><li>RENAME&#x2F;RENAMENX：将 key 重命名为 newkey。使用 RENAME 时，如果 newkey 已经存在，其值会被覆盖；使用 RENAMENX 时，如果 newkey 已经存在，则不会进行任何操作，时间复杂度 O(1)</li><li>TYPE：返回指定 key 的类型，string, list, set, zset, hash。时间复杂度 O(1)</li><li>CONFIG GET：获得 Redis 某配置项的当前值，可以使用 * 通配符，时间复杂度 O(1)</li><li>CONFIG SET：为 Redis 某个配置项设置新值，时间复杂度 O(1)</li><li>CONFIG REWRITE：让 Redis 重新加载 redis.conf 中的配置</li></ul></blockquote><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h2 id="Redis-性能调优"><a href="#Redis-性能调优" class="headerlink" title="Redis 性能调优"></a>Redis 性能调优</h2><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><p>尽管 Redis 是一个非常快速的内存数据存储媒介，也并不代表 Redis 不会产生性能问题。<br>前文中提到过，Redis 采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得 Redis 对每个任务的执行效率更加敏感。</p><p>针对 Redis 的性能优化，主要从下面几个层面入手：</p><blockquote><ul><li><p>最初的也是最重要的，确保没有让 Redis 执行耗时长的命令</p></li><li><p>使用 pipelining 将连续执行的命令组合执行</p></li><li><p>操作系统的 Transparent huge pages 功能必须关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></li><li><p>如果在虚拟机中运行 Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过.&#x2F;redis-cli —intrinsic-latency 100 命令查看固有延迟。同时如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis。</p></li><li><p>检查数据持久化策略</p></li><li><p>考虑引入读写分离机制</p></li></ul></blockquote><h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h2><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在文本和官方文档中均对每个命令的时间复杂度有说明。</p><p>通常来说，O(1) 的命令是安全的，O(N) 命令在使用时需要注意，如果 N 的数量级不可预知，则应避免使用。例如对一个 field 数未知的 Hash 数据执行 HGETALL&#x2F;HKEYS&#x2F;HVALS 命令，通常来说这些命令执行的很快，但如果这个 Hash 中的 field 数量极多，耗时就会成倍增长。</p><p>又如使用 SUNION 对两个 Set 执行 Union 操作，或使用 SORT 对 List&#x2F;Set 执行排序操作等时，都应该严加注意。</p><p>避免在使用这些 O(N) 命令时发生问题主要有几个办法：</p><blockquote><ul><li>不要把 List 当做列表使用，仅当做队列来使用</li><li>通过机制严格控制 Hash、Set、Sorted Set 的大小</li><li>可能的话，将排序、并集、交集等操作放在客户端执行</li><li>绝对禁止使用 KEYS 命令</li><li>避免一次性遍历集合类型的所有成员，而应使用 SCAN 类的命令进行分批的，游标式的遍历</li></ul></blockquote><p>Redis 提供了 SCAN 命令，可以对 Redis 中存储的所有 key 进行游标式的遍历，避免使用 KEYS 命令带来的性能问题。同时还有 SSCAN&#x2F;HSCAN&#x2F;ZSCAN 等命令，分别用于对 Set&#x2F;Hash&#x2F;Sorted Set 中的元素进行游标式遍历。SCAN 类命令的使用请参考官方文档：<a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p><p>Redis 提供了 Slow Log 功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than xxxms  #执行时间慢于xxx毫秒的命令计入Slow Logslowlog-max-len xxx  #Slow Log的长度，即最大纪录多少条Slow Log</span><br></pre></td></tr></table></figure><p>使用** SLOWLOG GET [number]** 命令，可以输出最近进入 Slow Log 的 number 条命令。<br>使用** SLOWLOG RESET** 命令，可以重置 Slow Log</p><h3 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h3><blockquote><ul><li><p>尽可能使用长连接或连接池，避免频繁创建销毁连接</p></li><li><p>客户端进行的批量数据操作，应使用 Pipeline 特性在一次交互中完成。具体请参照本文的 Pipelining 章节</p><p>​</p></li></ul></blockquote><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h3><p>Redis 的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p><blockquote><ul><li>AOF + fsync always 的设置虽然能够绝对确保数据安全，但每个操作都会触发一次 fsync，会对 Redis 的性能有比较明显的影响</li><li>AOF + fsync every second 是比较好的折中方案，每秒 fsync 一次</li><li>AOF + fsync never 会提供 AOF 持久化方案下的最优性能<br>使用 RDB 持久化通常会提供比使用 AOF 更高的性能，但需要注意 RDB 的策略配置</li><li>每一次 RDB 快照和 AOF Rewrite 都需要 Redis 主进程进行 fork 操作。fork 操作本身可能会产生较高的耗时，与 CPU 和 Redis 占用的内存大小有关。根据具体的情况合理配置 RDB 快照和 AOF Rewrite 时机，避免过于频繁的 fork 带来的延迟</li></ul></blockquote><blockquote><p>Redis 在 fork 子进程时需要将内存分页表拷贝至子进程，以占用了 24GB 内存的 Redis 实例为例，共需要拷贝 24GB &#x2F; 4kB * 8 &#x3D; 48MB 的数据。在使用单 Xeon 2.27Ghz 的物理机上，这一 fork 操作耗时 216ms。</p><p>可以通过 INFO 命令返回的 latest_fork_usec 字段查看上一次 fork 操作的耗时（微秒）</p></blockquote><h3 id="Swap-引发的延迟"><a href="#Swap-引发的延迟" class="headerlink" title="Swap 引发的延迟"></a><strong>Swap 引发的延迟</strong></h3><p>当 Linux 将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现不正常的延迟。Swap 通常在物理内存不足或一些进程在进行大量 I&#x2F;O 操作时发生，应尽可能避免上述两种情况的出现。</p><p>&#x2F;proc&#x2F;&#x2F;smaps 文件中会保存进程的 swap 记录，通过查看这个文件，能够判断 Redis 的延迟是否由 Swap 产生。如果这个文件中记录了较大的 Swap size，则说明延迟很有可能是 Swap 造成的。</p><h3 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h3><p>当同一秒内有大量 key 过期时，也会引发 Redis 的延迟。在使用时应尽量将 key 的失效时间错开。</p><h3 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a>引入读写分离机制</h3><p>Redis 的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。</p><p>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。</p><p>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p><p>关于读写分离的具体说明，请参见后续章节</p><h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h2 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a>主从复制与集群分片</h2><h2 id="-19"><a href="#-19" class="headerlink" title=""></a></h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis 支持一主多从的主从复制架构。一个 Master 实例负责处理所有的写请求，Master 将写操作同步至所有 Slave。</p><p>借助 Redis 的主从复制，可以实现读写分离和高可用：</p><blockquote><ul><li>实时性要求不是特别高的读请求，可以在 Slave 上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的 Redis 命令，可以专门规划出 1 个或几个 Slave 用于服务这些统计任务</li><li>借助 Redis Sentinel 可以实现高可用，当 Master crash 后，Redis Sentinel 能够自动将一个 Slave 晋升为 Master，继续提供服务</li></ul></blockquote><p>启用主从复制非常简单，只需要配置多个 Redis 实例，在作为 Slave 的 Redis 实例中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379  #指定Master的IP和端口</span><br></pre></td></tr></table></figure><p>当 Slave 启动后，会从 Master 进行一次冷启动数据同步，由 Master 触发 BGSAVE 生成 RDB 文件推送给 Slave 进行导入，导入完成后 Master 再将增量数据通过 Redis Protocol 同步给 Slave。之后主从之间的数据便一直以 Redis Protocol 进行同步</p><h3 id="使用-Sentinel-做自动-failover"><a href="#使用-Sentinel-做自动-failover" class="headerlink" title="使用 Sentinel 做自动 failover"></a><strong>使用 Sentinel 做自动 failover</strong></h3><hr><p>Redis 的主从复制功能本身只是做数据同步，并不提供监控和自动 failover 能力，要通过主从复制功能来实现 Redis 的高可用，还需要引入一个组件：Redis Sentinel</p><p>Redis Sentinel 是 Redis 官方开发的监控组件，可以监控 Redis 实例的状态，通过 Master 节点自动发现 Slave 节点，并在监测到 Master 节点失效时选举出一个新的 Master，并向所有 Redis 实例推送新的主从配置。</p><p>Redis Sentinel 需要至少部署 3 个实例才能形成选举关系。</p><p>关键配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  #Master实例的IP、端口，以及选举需要的赞成票数sentinel down-after-milliseconds mymaster 60000  #多长时间没有响应视为Master失效sentinel failover-timeout mymaster 180000  #两次failover尝试间的间隔时长sentinel parallel-syncs mymaster 1  #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span><br></pre></td></tr></table></figure><p>另外需要注意的是，Redis Sentinel 实现的自动 failover 不是在同一个 IP 和端口上完成的，也就是说自动 failover 产生的新 Master 提供服务的 IP 和端口与之前的 Master 是不一样的，所以要实现 HA，还要求客户端必须支持 Sentinel，能够与 Sentinel 交互获得新 Master 的信息才行。</p><h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h2><h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><p>为何要做集群分片：</p><blockquote><ul><li>Redis 中存储的数据量大，一台主机的物理内存已经无法容纳</li><li>Redis 的写请求并发量大，一个 Redis 实例以无法承载</li></ul></blockquote><p>当上述两个问题出现时，就必须要对 Redis 进行分片了。</p><p>Redis 的分片方案有很多种，例如很多 Redis 的客户端都自行实现了分片功能，也有向 Twemproxy 这样的以代理方式实现的 Redis 分片方案。然而首选的方案还应该是 Redis 官方在 3.0 版本中推出的 Redis Cluster 分片方案。</p><p>本文不会对 Redis Cluster 的具体安装和部署细节进行介绍，重点介绍 Redis Cluster 带来的好处与弊端。</p><h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-的能力"><a href="#Redis-Cluster-的能力" class="headerlink" title="Redis Cluster 的能力"></a>Redis Cluster 的能力</h2><blockquote><ul><li>能够自动将数据分散在多个节点上</li><li>当访问的 key 不在当前分片上时，能够自动将请求转发至正确的分片</li><li>当集群中部分节点失效时仍能提供服务</li></ul></blockquote><p>其中第三点是基于主从复制来实现的，Redis Cluster 的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了 Redis Sentinel 这一额外的组件，由 Redis Cluster 负责进行一个分片内部的节点监控和自动 failover。</p><h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-分片原理"><a href="#Redis-Cluster-分片原理" class="headerlink" title="Redis Cluster 分片原理"></a>Redis Cluster 分片原理</h2><p>Redis Cluster 中共有 16384 个 hash slot，Redis 会计算每个 key 的 CRC16，将结果与 16384 取模，来决定该 key 存储在哪一个 hash slot 中，同时需要指定 Redis Cluster 中每个数据分片负责的 Slot 数。Slot 的分配在任何时间点都可以进行重新分配。</p><p>客户端在对 key 进行读写操作时，可以连接 Cluster 中的任意一个分片，如果操作的 key 不在此分片负责的 Slot 范围内，Redis Cluster 会自动将请求重定向到正确的分片上。</p><h3 id="-24"><a href="#-24" class="headerlink" title=""></a></h3><h2 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h2><p>在基础的分片原则上，Redis 还支持 hash tags 功能，以 hash tags 要求的格式明明的 key，将会确保进入同一个 Slot 中。例如：{uiv}user:1000 和 {uiv}user:1001 拥有同样的 hash tag {uiv}，会保存在同一个 Slot 中。</p><p>使用 Redis Cluster 时，pipelining、事务和 LUA Script 功能涉及的 key 必须在同一个数据分片上，否则将会返回错误。如要在 Redis Cluster 中使用上述功能，就必须通过 hash tags 来确保一个 pipeline 或一个事务中操作的所有 key 都位于同一个 Slot 中。</p><blockquote><p>有一些客户端（如 Redisson）实现了集群化的 pipelining 操作，可以自动将一个 pipeline 里的命令按 key 所在的分片进行分组，分别发到不同的分片上执行。但是 Redis 不支持跨分片的事务，事务和 LUA Script 还是必须遵循所有 key 在一个分片上的规则要求。</p></blockquote><h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a>主从复制 vs 集群分片</h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？</p><p>从各个方面看，Redis Cluster 都是优于主从复制的方案</p><blockquote><ul><li>Redis Cluster 能够解决单节点上数据量过大的问题</li><li>Redis Cluster 能够解决单节点访问压力过大的问题</li><li>Redis Cluster 包含了主从复制的能力</li></ul></blockquote><p>那是不是代表 Redis Cluster 永远是优于主从复制的选择呢？</p><p>并不是。</p><p>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用 Redis Cluster 的弊端包括：</p><blockquote><ul><li>维护难度增加。在使用 Redis Cluster 时，需要维护的 Redis 实例数倍增，需要监控的主机数量也相应增加，数据备份 &#x2F; 持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行 reshard 操作，远比主从模式下增加一个 Slave 的复杂度要高。</li><li>客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</li><li>性能优化难度增加。你可能需要在多个分片上查看 Slow Log 和 Swap 日志才能定位性能问题。</li><li>事务和 LUA Script 的使用成本增加。在 Redis Cluster 中使用事务和 LUA Script 特性有严格的限制条件，事务和 Script 中操作的 key 必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的 key 进行额外的规划和规范要求。如果应用的场景中大量涉及事务和 Script 的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</li></ul></blockquote><p>所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用 Redis Cluster。<br>下面是一些建议：</p><p>需要在 Redis 中存储的数据有多大？未来 2 年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用 LRU 算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出 Redis 需要使用的物理内存。</p><p>用于部署 Redis 的主机物理内存有多大？有多少可以分配给 Redis 使用？对比 (1) 中的内存需求评估，是否足够用？</p><p>Redis 面临的并发写压力会有多大？在不使用 pipelining 时，Redis 的写性能可以超过 10 万次 &#x2F; 秒（更多的 benchmark 可以参考 <a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a> ）</p><p>在使用 Redis 时，是否会使用到 pipelining 和事务功能？使用的场景多不多？<br>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对 Redis 的容量需求，且 Redis 面临的并发写压力距离 Benchmark 值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用 pipelining 和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java性能优化</title>
      <link href="/2017/12/17/java/%20java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2017/12/17/java/%20java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>你是否正打算优化hashCode()方法？是否想要绕开正则表达式？Lukas Eder介绍了很多简单方便的性能优化小贴士以及扩展程序性能的技巧。</p><p>最近“全网域（Web Scale）”一词被炒得火热，人们也正在通过扩展他们的应用程序架构来使他们的系统变得更加“全网域”。但是究竟什么是全网域？或者说如何确保全网域？</p><h2 id="扩展的不同方面"><a href="#扩展的不同方面" class="headerlink" title="扩展的不同方面"></a>扩展的不同方面</h2><p>全网域被炒作的最多的是扩展负载（Scaling load），比如支持单个用户访问的系统也可以支持10 个、100个、甚至100万个用户访问。在理想情况下，我们的系统应该保持尽可能的“无状态化（stateless）”。即使必须存在状态，也可以在网络的不同处理终端上转化并进行传输。当负载成为瓶颈时候，可能就不会出现延迟。所以对于单个请求来说，耗费50到100毫秒也是可以接受的。这就是所谓的横向扩展（Scaling out）。</p><p>扩展在全网域优化中的表现则完全不同，比如确保成功处理一条数据的算法也可成功处理10条、100条甚至100万条数据。无论这种度量类型是是否可行，事件复杂度（大O符号）是最佳描述。延迟是性能扩展杀手。你会想尽办法将所有的运算处理在同一台机器上进行。这就是所谓的纵向扩展（Scaling up）。</p><p>如果天上能掉馅饼的话（当然这是不可能的），我们或许能把横向扩展和纵向扩展组合起来。但是，今天我们只打算介绍下面几条提升效率的简单方法。</p><h2 id="大O符号"><a href="#大O符号" class="headerlink" title="大O符号"></a>大O符号</h2><p>Java 7的 ForkJoinPool 和Java8 的并行数据流（parallel Stream） 都对并行处理有所帮助。当在多核处理器上部署Java程序时表现尤为明显，因所有的处理器都可以访问相同的内存。</p><p>所以，这种并行处理较之在跨网络的不同机器上进行扩展，根本的好处是几乎可以完全消除延迟。</p><p>但不要被并行处理的效果所迷惑！请谨记下面两点：</p><ul><li>并行处理会吃光处理器资源。并行处理为批处理带来了极大的好处，但同时也是非同步服务器（如HTTP）的噩梦。有很多原因可以解释，为什么在过去的几十年中我们一直在使用单线程的Servlet模型。并行处理仅在纵向扩展时才能带来实际的好处。</li><li>并行处理对算法复杂度没有影响。如果你的算法的时间复杂度为 O(nlogn)，让算法在 c 个处理器上运行，事件复杂度仍然为 O(nlogn&#x2F;c)， 因为 c 只是算法中的一个无关紧要的常量。你节省的仅仅是时钟时间（wall-clock time），实际的算法复杂度并没有降低。</li></ul><p>降低算法复杂度毫无疑问是改善性能最行之有效的办法。比如对于一个 HashMap 实例的 lookup() 方法来说，事件复杂度 O(1) 或者空间复杂度 O(1) 是最快的。但这种情况往往是不可能的，更别提轻易地实现。</p><p>如果你不能降低算法的复杂度，也可以通过找到算法中的关键点并加以改善的方法，来起到改善性能的作用。假设我们有下面这样的算法示意图：</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fnyolwd0qhj20a209ajrn.jpg"></p><p>该算法的整体时间复杂度为 O(N3)，如果按照单独访问顺序计算也可得出复杂度为 O(N x O x P)。但是不管怎样，在我们分析这段代码时会发现一些奇怪的场景：</p><ul><li>在开发环境中，通过测试数据可以看到：左分支（N-&gt;M-&gt;Heavy operation）的时间复杂度 M 的值要大于右边的 O 和 P，所以在我们的分析器中仅仅看到了左分支。</li><li>在生产环境中，你的维护团队可能会通过 AppDynamics、DynaTrace 或其它小工具发现，真正导致问题的罪魁祸首是右分支（N -&gt; O -&gt; P -&gt; Easy operation or also *N.O.P.E.*）。</li></ul><p>在没有生产数据参照的情况下，我们可能会轻易的得出要优化“高开销操作”的结论。但我们做出的优化对交付的产品没有起到任何效果。</p><p>优化的金科玉律不外乎以下内容：</p><ul><li>良好的设计将会使优化变得更加容易。</li><li>过早的优化并不能解决多有的性能问题，但是不良的设计将会导致优化难度的增加。</li></ul><p>理论就先谈到这里。假设我们已经发现了问题出现在了右分支上，很有可能是因产品中的简单处理因耗费了大量的时间而失去响应（假设N、O和 P 的值非常大）， 请注意文章中提及的左分支的时间复杂度为 O(N3)。这里所做出的努力并不能扩展，但可以为用户节省时间，将困难的性能改善推迟到后面再进行。</p><p>这里有10条改善Java性能的小建议：</p><h2 id="1、使用StringBuilder"><a href="#1、使用StringBuilder" class="headerlink" title="1、使用StringBuilder"></a>1、使用StringBuilder</h2><p>StingBuilder 应该是在我们的Java代码中默认使用的，应该避免使用 + 操作符。或许你会对 StringBuilder 的语法糖（syntax sugar）持有不同意见，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;a&quot; + args.length + &quot;b&quot;;</span><br></pre></td></tr></table></figure><p>将会被编译为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0  new java.lang.StringBuilder [16] 3  dup 4  ldc &lt;String &quot;a&quot;&gt; [18] 6  invokespecial java.lang.StringBuilder(java.lang.String) [20] 9  aload_0 [args]10  arraylength11  invokevirtual java.lang.StringBuilder.append(int) : java.lang.StringBuilder [23]14  ldc &lt;String &quot;b&quot;&gt; [27]16  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [29]19  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [32]22  astore_1 [x]</span><br></pre></td></tr></table></figure><p>但究竟发生了什么？接下来是否需要用下面的部分来对 String 进行改善呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;a&quot; + args.length + &quot;b&quot;;if (args.length == 1)    x = x + args[0];</span><br></pre></td></tr></table></figure><p>现在使用到了第二个 StringBuilder，而且这个 StringBuilder 不会消耗堆中额外的内存，但却给 GC 带来了压力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder x = new StringBuilder(&quot;a&quot;);x.append(args.length);x.append(&quot;b&quot;);if (args.length == 1);    x.append(args[0]);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上面的样例中，如果你是依靠Java编译器来隐式生成实例的话，那么编译的效果几乎和是否使用了 StringBuilder 实例毫无关系。请记住：在  N.O.P.E 分支中，每次CPU的循环的时间到白白的耗费在GC或者为 StringBuilder 分配默认空间上了，我们是在浪费 N x O x P 时间。</p><p>一般来说，使用 StringBuilder 的效果要优于使用 + 操作符。如果可能的话请在需要跨多个方法传递引用的情况下选择 StringBuilder，因为 String 要消耗额外的资源。JOOQ在生成复杂的SQL语句便使用了这样的方式。在整个抽象语法树（AST Abstract Syntax Tree）SQL传递过程中仅使用了一个 StringBuilder 。</p><p>更加悲剧的是，如果你仍在使用 StringBuffer 的话，那么用 StringBuilder 代替 StringBuffer 吧，毕竟需要同步字符串的情况真的不多。</p><h2 id="2、避免使用正则表达式"><a href="#2、避免使用正则表达式" class="headerlink" title="2、避免使用正则表达式"></a>2、避免使用正则表达式</h2><p>正则表达式给人的印象是快捷简便。但是在 N.O.P.E 分支中使用正则表达式将是最糟糕的决定。如果万不得已非要在计算密集型代码中使用正则表达式的话，至少要将 Pattern 缓存下来，避免反复编译Pattern。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final Pattern HEAVY_REGEX =    Pattern.compile(&quot;(((X)*Y)*Z)*&quot;);</span><br></pre></td></tr></table></figure><p>如果仅使用到了如下这样简单的正则表达式的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] parts = ipAddress.split(&quot;//.&quot;);</span><br></pre></td></tr></table></figure><p>这是最好还是用普通的 char[] 数组或者是基于索引的操作。比如下面这段可读性比较差的代码其实起到了相同的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int length = ipAddress.length();int offset = 0;int part = 0;for (int i = 0; i &lt; length; i++) &#123;    if (i == length - 1 ||            ipAddress.charAt(i + 1) == &#x27;.&#x27;) &#123;        parts[part] =            ipAddress.substring(offset, i + 1);        part++;        offset = i + 2;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码同时表明了过早的优化是没有意义的。虽然与 split() 方法相比较，这段代码的可维护性比较差。</p><p><strong>挑战：</strong>聪明的小伙伴能想出更快的算法吗？</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>正则表达式是十分有用，但是在使用时也要付出代价。尤其是在 N.O.P.E 分支深处时，要不惜一切代码避免使用正则表达式。还要小心各种使用到正则表达式的JDK字符串方法，比如 String.replaceAll() 或 String.split()。可以选择用比较流行的开发库，比如 Apache Commons Lang 来进行字符串操作。</p><h2 id="3、不要使用iterator-方法"><a href="#3、不要使用iterator-方法" class="headerlink" title="3、不要使用iterator()方法"></a>3、不要使用iterator()方法</h2><p>这条建议不适用于一般的场合，仅适用于在 N.O.P.E 分支深处的场景。尽管如此也应该有所了解。Java 5格式的循环写法非常的方便，以至于我们可以忘记内部的循环方法，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (String value : strings) &#123;    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><p>当每次代码运行到这个循环时，如果 strings 变量是一个 Iterable 的话，代码将会自动创建一个Iterator 的实例。如果使用的是 ArrayList 的话，虚拟机会自动在堆上为对象分配3个整数类型大小的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;    int cursor;    int lastRet = -1;    int expectedModCount = modCount;    // ...</span><br></pre></td></tr></table></figure><p>也可以用下面等价的循环方式来替代上面的 for 循环，仅仅是在栈上“浪费”了区区一个整形，相当划算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int size = strings.size();for (int i = 0; i &lt; size; i++) &#123;    String value : strings.get(i);    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><p>如果循环中字符串的值是不怎么变化，也可用数组来实现循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (String value : stringArray) &#123;    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>无论是从易读写的角度来说，还是从API设计的角度来说迭代器、Iterable接口和 foreach 循环都是非常好用的。但代价是，使用它们时是会额外在堆上为每个循环子创建一个对象。如果循环要执行很多很多遍，请注意避免生成无意义的实例，最好用基本的指针循环方式来代替上述迭代器、Iterable接口和 foreach 循环。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>一些与上述内容持反对意见的看法（尤其是用指针操作替代迭代器）详见Reddit上的讨论。</p><h2 id="4、不要调用高开销方法"><a href="#4、不要调用高开销方法" class="headerlink" title="4、不要调用高开销方法"></a>4、不要调用高开销方法</h2><p>有些方法的开销很大。以 N.O.P.E 分支为例，我们没有提到叶子的相关方法，不过这个可以有。假设我们的JDBC驱动需要排除万难去计算 ResultSet.wasNull() 方法的返回值。我们自己实现的SQL框架可能像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (type == Integer.class) &#123;    result = (T) wasNull(rs,        Integer.valueOf(rs.getInt(index)));&#125;// And then...static final &lt;T&gt; T wasNull(ResultSet rs, T value)throws SQLException &#123;    return rs.wasNull() ? null : value;&#125;</span><br></pre></td></tr></table></figure><p>在上面的逻辑中，每次从结果集中取得 int 值时都要调用 ResultSet.wasNull() 方法，但是 getInt() 的方法定义为：</p><blockquote><p>返回类型：变量值；如果SQL查询结果为NULL，则返回0。</p></blockquote><p>所以一个简单有效的改善方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;T extends Number&gt; T wasNull(    ResultSet rs, T value)throws SQLException &#123;    return (value == null ||           (value.intValue() == 0 &amp;&amp; rs.wasNull()))        ? null : value;&#125;</span><br></pre></td></tr></table></figure><p>这是轻而易举的事情。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>将方法调用缓存起来替代在叶子节点的高开销方法，或者在方法约定允许的情况下避免调用高开销方法。</p><h2 id="5、使用原始类型和栈"><a href="#5、使用原始类型和栈" class="headerlink" title="5、使用原始类型和栈"></a>5、使用原始类型和栈</h2><p>上面介绍了来自 jOOQ的例子中使用了大量的泛型，导致的结果是使用了 byte、 short、 int 和 long 的包装类。但至少泛型在Java 10或者Valhalla项目中被专门化之前，不应该成为代码的限制。因为可以通过下面的方法来进行替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//存储在堆上Integer i = 817598;</span><br></pre></td></tr></table></figure><p>……如果这样写的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 存储在栈上int i = 817598;</span><br></pre></td></tr></table></figure><p>在使用数组时情况可能会变得更加糟糕：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//在堆上生成了三个对象Integer[] i = &#123; 1337, 424242 &#125;;</span><br></pre></td></tr></table></figure><p>……如果这样写的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 仅在堆上生成了一个对象int[] i = &#123; 1337, 424242 &#125;;</span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>当我们处于 *N.O.P.E. *分支的深处时，应该极力避免使用包装类。这样做的坏处是给GC带来了很大的压力。GC将会为清除包装类生成的对象而忙得不可开交。</p><p>所以一个有效的优化方法是使用基本数据类型、定长数组，并用一系列分割变量来标识对象在数组中所处的位置。</p><p>遵循LGPL协议的 trove4j 是一个Java集合类库，它为我们提供了优于整形数组 int[] 更好的性能实现。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>下面的情况对这条规则例外：因为 boolean 和 byte 类型不足以让JDK为其提供缓存方法。我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean a1 = true; // ... syntax sugar for:Boolean a2 = Boolean.valueOf(true);Byte b1 = (byte) 123; // ... syntax sugar for:Byte b2 = Byte.valueOf((byte) 123);</span><br></pre></td></tr></table></figure><p>其它整数基本类型也有类似情况，比如 char、short、int、long。</p><p>不要在调用构造方法时将这些整型基本类型自动装箱或者调用 TheType.valueOf() 方法。</p><p>也不要在包装类上调用构造方法，除非你想得到一个不在堆上创建的实例。这样做的好处是为你为同事献上一个巨坑的愚人节笑话。</p><h2 id="非堆存储"><a href="#非堆存储" class="headerlink" title="非堆存储"></a>非堆存储</h2><p>当然了，如果你还想体验下堆外函数库的话，尽管这可能参杂着不少战略决策，而并非最乐观的本地方案。一篇由Peter Lawrey和 Ben Cotton撰写的关于非堆存储的很有意思文章请点击： OpenJDK与HashMap——让老手安全地掌握（非堆存储！）新技巧。</p><h2 id="6、避免递归"><a href="#6、避免递归" class="headerlink" title="6、避免递归"></a>6、避免递归</h2><p>现在，类似Scala这样的函数式编程语言都鼓励使用递归。因为递归通常意味着能分解到单独个体优化的尾递归（tail-recursing）。如果你使用的编程语言能够支持那是再好不过。不过即使如此，也要注意对算法的细微调整将会使尾递归变为普通递归。</p><p>希望编译器能自动探测到这一点，否则本来我们将为只需使用几个本地变量就能搞定的事情而白白浪费大量的堆栈框架（stack frames）。</p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>这节中没什么好说的，除了在 <em>N.O.P.E</em> 分支尽量使用迭代来代替递归。</p><h2 id="7、使用entrySet"><a href="#7、使用entrySet" class="headerlink" title="7、使用entrySet()"></a>7、使用entrySet()</h2><p>当我们想遍历一个用键值对形式保存的 Map 时，必须要为下面的代码找到一个很好的理由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;    V value : map.get(key);&#125;</span><br></pre></td></tr></table></figure><p>更不用说下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K, V&gt; entry : map.entrySet()) &#123;    K key = entry.getKey();    V value = entry.getValue();&#125;</span><br></pre></td></tr></table></figure><p>在我们使用 <em>N.O.P.E.</em> 分支应该慎用map。因为很多看似时间复杂度为 O(1) 的访问操作其实是由一系列的操作组成的。而且访问本身也不是免费的。至少，如果不得不使用map的话，那么要用 entrySet() 方法去迭代！这样的话，我们要访问的就仅仅是Map.Entry的实例。</p><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>在需要迭代键值对形式的Map时一定要用 entrySet() 方法。</p><h2 id="9、使用EnumSet或EnumMap"><a href="#9、使用EnumSet或EnumMap" class="headerlink" title="9、使用EnumSet或EnumMap"></a>9、使用EnumSet或EnumMap</h2><p>在某些情况下，比如在使用配置map时，我们可能会预先知道保存在map中键值。如果这个键值非常小，我们就应该考虑使用 EnumSet 或 EnumMap，而并非使用我们常用的 HashSet 或 HashMap。下面的代码给出了很清楚的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] vals;public V put(K key, V value) &#123;    // ...    int index = key.ordinal();    vals[index] = maskNull(value);    // ...&#125;</span><br></pre></td></tr></table></figure><p>上段代码的关键实现在于，我们用数组代替了哈希表。尤其是向map中插入新值时，所要做的仅仅是获得一个由编译器为每个枚举类型生成的常量序列号。如果有一个全局的map配置（例如只有一个实例），在增加访问速度的压力下，EnumMap 会获得比 HashMap 更加杰出的表现。原因在于 EnumMap 使用的堆内存比 HashMap 要少 一位（bit），而且 HashMap 要在每个键值上都要调用 hashCode() 方法和 equals() 方法。</p><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>Enum 和 EnumMap 是亲密的小伙伴。在我们用到类似枚举（enum-like）结构的键值时，就应该考虑将这些键值用声明为枚举类型，并将之作为 EnumMap 键。</p><h2 id="9、优化自定义hasCode-方法和equals-方法"><a href="#9、优化自定义hasCode-方法和equals-方法" class="headerlink" title="9、优化自定义hasCode()方法和equals()方法"></a>9、优化自定义hasCode()方法和equals()方法</h2><p>在不能使用EnumMap的情况下，至少也要优化 hashCode() 和 equals() 方法。一个好的 hashCode() 方法是很有必要的，因为它能防止对高开销 equals() 方法多余的调用。</p><p>在每个类的继承结构中，需要容易接受的简单对象。让我们看一下jOOQ的 org.jooq.Table 是如何实现的？</p><p>最简单、快速的 hashCode() 实现方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractTable一个通用Table的基础实现：@Overridepublic int hashCode() &#123;    // [#1938] 与标准的QueryParts相比，这是一个更加高效的hashCode()实现    return name.hashCode();&#125;</span><br></pre></td></tr></table></figure><p>name即为表名。我们甚至不需要考虑schema或者其它表属性，因为表名在数据库中通常是唯一的。并且变量 name 是一个字符串，它本身早就已经缓存了一个 hashCode() 值。</p><p>这段代码中注释十分重要，因继承自 AbstractQueryPart 的 AbstractTable 是任意抽象语法树元素的基本实现。普通抽象语法树元素并没有任何属性，所以不能对优化 hashCode() 方法实现抱有任何幻想。覆盖后的 hashCode() 方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractQueryPart一个通用抽象语法树基础实现：@Overridepublic int hashCode() &#123;    // 这是一个可工作的默认实现。    // 具体实现的子类应当覆盖此方法以提高性能。    return create().renderInlined(this).hashCode();&#125;</span><br></pre></td></tr></table></figure><p>换句话说，要触发整个SQL渲染工作流程（rendering workflow）来计算一个普通抽象语法树元素的hash代码。</p><p>equals() 方法则更加有趣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractTable通用表的基础实现：@Overridepublic boolean equals(Object that) &#123;    if (this == that) &#123;        return true;    &#125;    // [#2144] 在调用高开销的AbstractQueryPart.equals()方法前，    // 可以及早知道对象是否不相等。    if (that instanceof AbstractTable) &#123;        if (StringUtils.equals(name,            (((AbstractTable&lt;?&gt;) that).name))) &#123;            return super.equals(that);        &#125;        return false;    &#125;    return false;&#125;</span><br></pre></td></tr></table></figure><p>首先，不要过早使用 equals() 方法（不仅在*N.O.P.E.*中），如果：</p><ul><li>this &#x3D;&#x3D; argument</li><li>this“不兼容：参数</li></ul><p>注意：如果我们过早使用 instanceof 来检验兼容类型的话，后面的条件其实包含了argument &#x3D;&#x3D; null。</p><p>在我们对以上几种情况的比较结束后，应该能得出部分结论。比如jOOQ的 Table.equals() 方法说明是，用来比较两张表是否相同。不论具体实现类型如何，它们必须要有相同的字段名。比如下面两个元素是不可能相同的：</p><ul><li>com.example.generated.Tables.MY_TABLE</li><li>DSL.tableByName(“MY_OTHER_TABLE”)</li></ul><p>如果我们能方便地判断传入参数是否等于实例本身（this），就可以在返回结果为 false 的情况下放弃操作。如果返回结果为 true，我们还可以进一步对父类（super）实现进行判断。在比较过的大多数对象都不等的情况下，我们可以尽早结束方法来节省CPU的执行时间。</p><blockquote><p>一些对象的相似度比其它对象更高。</p></blockquote><p>在jOOQ中，大多数的表实例是由jOOQ的代码生成器生成的，这些实例的 equals() 方法都经过了深度优化。而数十种其它的表类型（衍生表 （derived tables）、表值函数（table-valued functions）、数组表（array tables）、连接表（joined tables）、数据透视表（pivot tables）、公用表表达式（common table expressions）等，则保持 equals() 方法的基本实现。</p><h2 id="10、考虑使用set而并非单个元素"><a href="#10、考虑使用set而并非单个元素" class="headerlink" title="10、考虑使用set而并非单个元素"></a>10、考虑使用set而并非单个元素</h2><p>最后，还有一种情况可以适用于所有语言而并非仅仅同Java有关。除此以外，我们以前研究的* N.O.P.E. *分支也会对了解从 O(N3) 到 O(n log n)有所帮助。</p><p>不幸的是，很多程序员的用简单的、本地算法来考虑问题。他们习惯按部就班地解决问题。这是命令式（imperative）的“是&#x2F;或”形式的函数式编程风格。这种编程风格在由纯粹命令式编程向面对象式编程向函数式编程转换时，很容易将“更大的场景（bigger picture）”模型化，但是这些风格都缺少了只有在SQL和R语言中存在的：</p><p>声明式编程。</p><p>在SQL中，我们可以在不考虑算法影响下声明要求数据库得到的效果。数据库可以根据数据类型，比如约束（constraints）、键（key）、索引（indexes）等不同来采取最佳的算法。</p><p>在理论上，我们最初在SQL和关系演算（relational calculus）后就有了基本的想法。在实践中，SQL的供应商们在过去的几十年中已经实现了基于开销的高效优化器CBOs (Cost-Based Optimisers) 。然后到了2010版，我们才终于将SQL的所有潜力全部挖掘出来。</p><p>但是我们还不需要用set方式来实现SQL。所有的语言和库都支持Sets、collections、bags、lists。使用set的主要好处是能使我们的代码变的简洁明了。比如下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeSet INTERSECT SomeOtherSet</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Java 8以前的写法Set result = new HashSet();for (Object candidate : someSet)    if (someOtherSet.contains(candidate))        result.add(candidate);// 即使采用Java 8也没有很大帮助someSet.stream()       .filter(someOtherSet::contains)       .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p>有些人可能会对函数式编程和Java 8能帮助我们写出更加简单、简洁的算法持有不同的意见。但这种看法不一定是对的。我们可以把命令式的Java 7循环转换成Java 8的Stream collection，但是我们还是采用了相同的算法。但SQL风格的表达式则是不同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeSet INTERSECT SomeOtherSet</span><br></pre></td></tr></table></figure><p>上面的代码在不同的引擎上可以有1000种不同的实现。我们今天所研究的是，在调用 INTERSECT 操作之前，更加智能地将两个set自动的转化为 EnumSet 。甚至我们可以在不需要调用底层的 Stream.parallel() 方法的情况下进行并行 INTERSECT 操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们讨论了关于*N.O.P.E.*分支的优化。比如深入高复杂性的算法。作为jOOQ的开发者，我们很乐于对SQL的生成进行优化。</p><ul><li>每条查询都用唯一的StringBuilder来生成。</li><li>模板引擎实际上处理的是字符而并非正则表达式。</li><li>选择尽可能的使用数组，尤其是在对监听器进行迭代时。</li><li>对JDBC的方法敬而远之。</li><li>等等。</li></ul><p>jOOQ处在“食物链的底端”，因为它是在离开JVM进入到DBMS时，被我们电脑程序所调用的最后一个API。位于食物链的底端意味着任何一条线路在jOOQ中被执行时都需要* N x O x P* 的时间，所以我要尽早进行优化。</p><p>我们的业务逻辑可能没有*N.O.P.E.*分支那么复杂。但是基础框架有可能十分复杂（本地SQL框架、本地库等）。所以需要按照我们今天提到的原则，用Java Mission Control 或其它工具进行复查，确认是否有需要优化的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx相关状态码总结</title>
      <link href="/2017/12/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目的旨在对http状态码含义做一个基本解释，不会太深入讨论每个状态码</p></blockquote><h1 id="http状态码分类"><a href="#http状态码分类" class="headerlink" title="http状态码分类"></a>http状态码分类</h1><ol><li>消息类（1字头）</li><li>成功类（2字头）</li><li>重定向类（3字头）</li><li>请求错误类（4字头）</li><li>服务器错误类（5、6字头）</li></ol><p>中途可能会穿插nginx自定义的http状态码，nginx状态码本身不属于http状态码了，只是在nginx内部自己定义的一套状态码，但是在nginx日志中，却经常出现</p><h1 id="请求错误类（客户端错误）"><a href="#请求错误类（客户端错误）" class="headerlink" title="请求错误类（客户端错误）"></a>请求错误类（客户端错误）</h1><h2 id="400"><a href="#400" class="headerlink" title="400"></a>400</h2><p>400的英文含义<code>400 Request Header Or Cookie Too Large</code>，顾名思义，头信息或者Cookie信息太多了<br>复现这个状态码只需要添加够长的头信息或者Cookie信息即可，构造一个curl请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --header &quot;Cookie:sidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidisidisisidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisi.....&quot; http://localhost:80</span><br></pre></td></tr></table></figure><p>执行这个curl命令可以看到提示：<br><img src="http://leanote.com/api/file/getImage?fileId=56c696edab64413c8b000739" alt="img"></p><h2 id="401"><a href="#401" class="headerlink" title="401"></a>401</h2><p>401的含义是<code>401 Authorization Required</code>,顾名思义，就是需要权限认证，但是客户端又没有通过认证。复现这个状态码必须对nginx调整成认证模式。现在，将nginx调成认证模式，nginx的server模块配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;    auth_basic &quot;secret&quot;;#认证模式    auth_basic_user_file /usr/local/nginx/passwd.db;#密码文件    root   html2;    index  index.html index.htm;&#125;</span><br></pre></td></tr></table></figure><p>接下来生成密码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# htpasswd -c /usr/local/nginx/passwd.db yongxiongzhongNew password: Re-type new password: Adding password for user yongxiongzhong</span><br></pre></td></tr></table></figure><p>更改权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 /usr/local/nginx/passwd.db</span><br></pre></td></tr></table></figure><p>平滑重启nginx之后，再次访问网页可以看到认证界面<br><img src="http://leanote.com/api/file/getImage?fileId=56c74371ab64413b37000dae" alt="img"><br>点击取消按钮，则可以看到以下这个页面<br><img src="http://leanote.com/api/file/getImage?fileId=56c743b6ab64413c8b000e2a" alt="img"></p><h2 id="403"><a href="#403" class="headerlink" title="403"></a>403</h2><p>403的出现，大部分是没有对文件进行授权。<code>403 Forbidden</code>顾名思义就是禁止访问，重现这个状态码只需要修改访问文件的权限，比如给nginx网站根目录中的index文件减少权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 0 /usr/local/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>当我们再次访问这个文件是，就会出现403错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c74731ab64413c8b000e39" alt="img"></p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>404算是我们经常碰到的状态码，<code>404 Not Found</code>当我们访问一个不存在的文件时，就会出现这个错误<br>在URL地址栏上随便访问一个不存在的文件，就会出现<br><img src="http://leanote.com/api/file/getImage?fileId=56c748b5ab64413c8b000e40" alt="img"><br>在实际生产环境中，这样的404页面并不好看，所以可以通过在server中配置自定义404页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page  404              /my_404.html;</span><br></pre></td></tr></table></figure><p>其中在网站根目录新建my_404.html然后写入自定义内容。平滑重启nginx之后，再次访问一些不存在的页面时会提示如下：<br><img src="http://leanote.com/api/file/getImage?fileId=56ca69f9ab64413b37001d8a" alt="img"></p><h2 id="405"><a href="#405" class="headerlink" title="405"></a>405</h2><p>405状态码并不算常见，它表示<code>405 Not Allowed</code>。http请求可以支持GET，POST，PUT，DELETE方式。默认情况下，如果你对一个html静态文件进行post请求的话，就会出现405错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c74c92ab64413b37000dd9" alt="img"></p><h2 id="413"><a href="#413" class="headerlink" title="413"></a>413</h2><p>413也是比较容易出现的一种状态码，413的出现常常伴随着<code>413 Request Entity Too Large</code>表示请求实体过大导致。用户上传的Content-Length大于nginx设定的最大值时。比如上传一张很大的图片，就会出现413错误码<br><img src="http://leanote.com/api/file/getImage?fileId=56c89aa1ab64413b3700152d" alt="img"><br>这个是由参数client_max_body_size控制的，默认是1M。有点小，所以一般线上环境调成以下配置即可消除上面的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size 8m;</span><br></pre></td></tr></table></figure><h2 id="414"><a href="#414" class="headerlink" title="414"></a>414</h2><p>一般出现这个错误的时候，也伴随着一段英文提示<code>414 Request-URI Too Large</code>，也就是说我们请求的url太长了，如果我们把一个很长的url放在浏览器地址栏上，浏览器的保护措施，并不会出现414报错。所以要重现这个414错误码，只能通过curl命令。申请如下一个很长的url,篇幅问题，最后用…代替：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/?key=abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefg....</span><br></pre></td></tr></table></figure><p>运行这个curl命令，就可以看到414错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c89ca0ab64413b37001539" alt="图片标题"><br>在nginx中，以下两个参数共同决定这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_sizelarge_client_header_buffers</span><br></pre></td></tr></table></figure><h2 id="499-nginx-status"><a href="#499-nginx-status" class="headerlink" title="499(nginx status)"></a>499(nginx status)</h2><p>499这个状态码并不是http协议中定义的status code，而是nginx自己定义的一个状态码。<br>当客户端主动断开连接的时候，nginx就会返回499的状态码。按照这个状态码的定义，复现这个状态码很容易，只要在nginx返回结果之前断开客户端连接。所以，下一个data.php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpsleep(10);//睡觉10秒钟</span><br></pre></td></tr></table></figure><p>然后在浏览器访问<a href="http://localhost:8000/data.php">http://localhost:8000/data.php</a>,注意，在10秒之内关闭浏览器以断开客户端连接。然后在查看nginx访问日志就能看到499错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c9b087ab64413b37001a89" alt="img"><br>值得一提的是，在线上环境中，如果并发量大的话，nginx未能及时处理完请求，导致客户端“不干了”，这是会大量爆发499错误。这种情况可以用ab工具测试，ab工具中，-n为请求次数，-c为并发量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 100 -c 100 http://127.0.0.1:8000/data.php</span><br></pre></td></tr></table></figure><p>再观察我们的nginx访问日志，会发现大量的499<br><img src="http://leanote.com/api/file/getImage?fileId=56c9b174ab64413c8b001a58" alt="img"></p><h1 id="服务端错误"><a href="#服务端错误" class="headerlink" title="服务端错误"></a>服务端错误</h1><h2 id="500"><a href="#500" class="headerlink" title="500"></a>500</h2><p>http状态码500表示内部服务器错误，这个错误一般是php代码出现error导致，如果你没有关闭php错误提示，当写一个错误的php脚本时，网页上会出现以下错误提示<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a0f1ab64413c8b0019f2" alt="img"><br>但是一般情况下这些错误我们并不希望就这样暴露给客户端，因为将这些错误信息暴露是一件很危险的事情，别人可以通过你的错误猜测系统漏洞。所以在线上一般是关闭错误显示，关闭方式为：编辑php-fpm.conf关闭错误信息，保存php-fpm以下设置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_flag[display_errors] = off</span><br></pre></td></tr></table></figure><p>平滑重启php-fpm进程之后，再次访问一个包含错误语法的php错误的时候，会报500错误。<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a272ab64413c8b0019fe" alt="img"></p><h2 id="502"><a href="#502" class="headerlink" title="502"></a>502</h2><p>当出现502这个错误的时候，也伴随着一句英文<code>502 bad geteway</code>，很醒目的一段问题，出现这个错误的时候，因为这是服务端错误，可以定位<code>挂掉了</code>。Nginx 502错误的原因比较多，是因为在代理模式下后端服务器出现问题引起的。这些错误一般都不是nginx本身的问题，一定要从后端找原因。比如这里复现一种后端php-fpm进程挂掉的情况，关闭php-fpm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `ps aux | grep php-fpm | grep -v grep | awk -F &#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;`</span><br></pre></td></tr></table></figure><p>再次访问我们的php文件时候，然后就可以看到网站挂掉的情况<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a4a0ab64413c8b001a0b" alt="img"></p><h2 id="503"><a href="#503" class="headerlink" title="503"></a>503</h2><p>注意，出现503的时候服务没挂，出现503的时候伴随着<code>503 Service Temporarily Unavailable</code>,这句话告诉我们服务是暂时性不可用，nginx官方文档上有说明这一点，</p><blockquote><p>Sets the shared memory zone and the maximum allowed number of connections for a given key value. When this limit is exceeded, the server will return the 503 (Service Temporarily Unavailable) error in reply to a request.</p></blockquote><p>简单的说，就是在控制请求频率和并发数，详细配置可以参考nginx官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn">http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn</a><br>这里只复现一种可能的情况，将nginx配置如下(两个核心配置，省去了很多)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http &#123;    limit_conn_zone $binary_remote_addr zone=addr:10m;    server &#123;        limit_conn addr 1;#并发数为1，好测试</span><br></pre></td></tr></table></figure><p>注意测试的时候，不是所有的连接都算进去，也就是并发数为1，并不代表只能并发1，nginx说明：</p><blockquote><p>Not all connections are counted. A connection is counted only if it has a request processed by the server and the whole request header has already been read.</p></blockquote><p>然后采用ab测试工具，运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 2 -c 2 http://127.0.0.1:8000/data.php</span><br></pre></td></tr></table></figure><p>查看nginx访问日志，可以看到503报错信息<br><img src="http://leanote.com/api/file/getImage?fileId=56cd6045ab64413c8b003002" alt="img"></p><h2 id="504"><a href="#504" class="headerlink" title="504"></a>504</h2><p>当出现504的时候也伴随着一段英文，<code>504 Gateway Time-out</code>，顾名思义，就是超时了，复现这个错误码也很简单。让你的php程序模拟耗时请求，比如把php脚本里添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpsleep(70);//模拟耗时，睡70秒echo &quot;睡醒了&quot;;</span><br></pre></td></tr></table></figure><p>然后通过域名访问这个脚本文件，就会出现超时的界面<br><img src="http://leanote.com/api/file/getImage?fileId=56c9c05eab64413b37001afc" alt="img"></p><h1 id="重定向和缓存"><a href="#重定向和缓存" class="headerlink" title="重定向和缓存"></a>重定向和缓存</h1><h2 id="301和302"><a href="#301和302" class="headerlink" title="301和302"></a>301和302</h2><p>之所以将这两个状态码放到一起，因为他们都是重定向，其中，<code>301永久重定向</code>，<code>302暂时重定向</code>。不管是暂时还是临时，对用户而言，这两者没什么区别，都是在访问A网站的时候跳转到了B网站，并看到浏览器上的地址栏变成了B网站的地址。有区别的是搜索引擎，搜索引擎是要建立索引规则和权重的，如果网站A被设定为永久重定向到B，那搜索引擎可以确定A的地址永久改变了，就会把B当做唯一有效的目标地址，这是搜索引擎会把老地址的PageRank等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。所以，所以只要网站不是临时性迁移，都会做301重定向。<br>在nginx的rewrite语法中有两个关键字<br><code>permanent——永久重定向 redirect——临时重定向</code><br>如果我们想要将.asp文件永久重定向到index页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.asp$ &#123;    rewrite ^(.*)$ /index.html permanent;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://leanote.com/api/file/getImage?fileId=56c9bd30ab64413b37001aee" alt="img"><br>如果只想临时重定向到index页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.asp$ &#123;    rewrite ^(.*)$ /index.html redirect;&#125;</span><br></pre></td></tr></table></figure><p>再次访问页面是可以看到302冲重定向了,同样，浏览器地址栏上的地址变成了重定向后的地址<br><img src="http://leanote.com/api/file/getImage?fileId=56c9bdb0ab64413b37001af0" alt="img"></p><h2 id="304"><a href="#304" class="headerlink" title="304"></a>304</h2><p><code>304 Not Modified</code>,默认情况下，nginx会对静态文件进行缓存。为了节省网络宽带，nginx和浏览器会产生如下交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器客户端想请求一个文档，如果浏览器本地已经有缓存了，发送If-Modified-Since给Web服务器2. 服务器将文件最后修改时间将服务器的文档修改时间Last-Modified和浏览器发送过来的If-Modified-Since比较，如果两者一致，返回304给浏览器，告诉浏览器用本地缓存就好了，如果两者不一致，返回200给浏览器，告诉浏览器使用最新的文档</span><br></pre></td></tr></table></figure><p>在默认情况下，在浏览器中输入<code>http://localhost:8000/test.css</code>请求css文件<strong>两次</strong>就会出现304<br><img src="http://leanote.com/api/file/getImage?fileId=56cad79dab64413b37002183" alt="img"></p><p>如果在服务器端编辑<code>test.css</code>文件，由于这个时间文件最后修改时间发生了变更，这时服务器不会返回304状态码了。这时返回200状态码,两个的时间不一样了，浏览器采用最新的。</p><p><img src="http://leanote.com/api/file/getImage?fileId=56cadf78ab64413b370021b4" alt="img"></p><p>有关于各种缓存策略这里不做讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK总结</title>
      <link href="/2017/12/09/%E7%BD%91%E7%BB%9C/AWK%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/09/%E7%BD%91%E7%BB%9C/AWK%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>awk的总结文字，转载之</p></blockquote><hr><h3 id="Awk是什么"><a href="#Awk是什么" class="headerlink" title="Awk是什么"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#whatisawk">Awk是什么</a></h3><p>Awk、sed与grep，俗称Linux下的三剑客，它们之前有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交互式且面向字符流的编辑器（a “non-interactive” stream-oriented editor），而awk则是一门模式匹配的编程语言，因为它的主要功能是用于匹配文本并处理，同时它有一些编程语言才有的语法，例如函数、分支循环语句、变量等等，当然比起我们常见的编程语言，Awk相对比较简单。</p><p>使用Awk，我们可以做以下事情：</p><ul><li>将文本文件视为由字段和记录组成的文本数据库；</li><li>在操作文本数据库的过程中能够使用变量；</li><li>能够使用数学运算和字符串操作；</li><li>能够使用常见的编程结构，例如条件分支与循环；</li><li>能够格式化输出；</li><li>能够自定义函数；</li><li>能够在awk脚本中执行UNIX命令；</li><li>能够处理UNIX命令的输出结果；</li></ul><p>装备以上功能，awk能够做得事情非常多。但千里之行，始于足下，我们首先从最基本的命令行语法开始，一步一步得走入awk的编程世界。</p><hr><h3 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#commandusing">命令行语法</a></h3><p>同sed一样，awk的命令行语法也有两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [-F ERE] [-v assignment] ... program [argument ...]</span><br><span class="line">awk [-F ERE] -f progfile ...  [-v assignment] ...[argument ...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的program类似sed中的script，因为我们一直强调awk是一门编程语言，所以将awk的脚本视为一段代码。而awk的脚本同样可以写到一个文件中，并通过-f参数指定，这一点和sed是一样的。program一般多个pattern和action序列组成，当读入的记录匹配pattern时，才会执行相应的action命令。这里有一点要注意，在第一种形式中，除去命令行选项外，program参数一定要位于第一个位置。</p><p>Awk的输入被解析成多个记录（Record），默认情况下，记录的分隔符是\n，因此可以认为一行就是一个记录，记录的分隔符可以通过内置变量RS更改。当记录匹配某个pattern时，才会执行后续的action命令。</p><p>而每个记录由进一步地被分隔成多个字段（Field），默认情况下字段的分隔符是空白符，例如空格、制表符等等，也可以通过-F ERE选项或者内置变量FS更改。在awk中，可以通过$1，$2…来访问对应位置的字段，同时$0存放整个记录，这一点有点类似shell下的命令行位置参数。关于这些内容，我们会在下面详细介绍，这里你只要知道有这些东西就好。</p><p>标准的awk命令行参数主要由以下三个：</p><ul><li>-F ERE：定义字段分隔符，该选项的值可以是扩展的正则表达式（ERE）；</li><li>-f progfile：指定awk脚本，可以同时指定多个脚本，它们会按照在命令行中出现的顺序连接在一起；</li><li>-v assignment：定义awk变量，形式同awk中的变量赋值，即name&#x3D;value，赋值发生在awk处理文本之前；</li></ul><p>为了便于理解，这里举几个简单的例子。通过-F参数设置冒号:为分隔符，并打印各个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1:2:3&quot; | awk -F: &#x27;&#123;print $1 &quot; and &quot; $2 &quot; and &quot; $3&#125;&#x27;</span><br><span class="line">1 and 2 and 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在awk的脚本中访问通过-v选项设置的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo | awk -v a=1 &#x27;BEGIN &#123;print a&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看到，通过-v选项设置的变量在BEGIN的位置就可以访问了。BEGIN是一个特殊的pattern，它在awk处理输入之前就会执行，可以认为是一个初始化语句，与此对应的还有END。</p><p>好像还没介绍如何指定处理的文件，是不是最后的argument就是指定的文件？在看我这本书之前，我也是这样认为的，但是实际上arguemnt有两种形式，它们分别是输入文件（file）和变量赋值（assignment）。</p><p>awk可以同时指定多个输入文件，如果输入文件的文件名为’-‘，表示从标准输入读取内容。</p><p>变量赋值类似-v选项，它的形式为name&#x3D;value。awk中的变量名同一般的编程语言无太多区别，但是不能同awk的保留关键字重名，可以查看awk的man手册查询哪些是保留关键字。而变量值只有两种形式：字符串和数值。变量赋值必须位于脚本参数的后面，与文件名参数无先后顺序的要求，但是位于不同位置的赋值它的执行时机是不同的。</p><p>我们用实际的例子来解释这个区别，假设有两个文件：a和b，它们的内容分别如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat a</span><br><span class="line">file a</span><br><span class="line">cat b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了说明赋值操作发生的时机，我们在BEGIN，正常处理，END三个地方都打印变量的值。</p><p>第一种情况： 变量赋值位于所有文件名参数之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; var=1 a</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：赋值操作发生在正常处理之前，BEGIN动作之后。</p><p>第二种情况：变量赋值位于所有文件名之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1  </span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：赋值操作发生在正常处理之后，END动作之前。</p><p>第三种情况：变量赋值位于文件名之间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1 b</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>结果：赋值操作发生在处理前面的文件之后，并且位于处理后面的文件之前；</em></p><h5 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h5><ul><li>如果变量赋值在第一个文件参数之前，在BEGIN动作之后执行，影响到正常处理和END动作；</li><li>如果变量赋值在最后一个文件参数之后，在END动作之前执行，仅影响END动作；</li><li>如果文件参数不存在，情况同1所述；</li><li>如果变量赋值位于多个文件参数之间，在变量赋值前面的文件被处理后执行，影响到后续文件的处理和END动作；</li></ul><p>所以变量赋值一定要考虑清楚用途，否则比较容易出错，不过一般情况下也不会用到变量赋值。</p><p>自然地大家会将变量赋值与-v assignment选项进行比较，赋值的形式是一致的，但是-v选项的执行时机比变量赋值要早：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v var=a &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125;&#x27;</span><br><span class="line">BEGIN: a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，-v选项的赋值操作在BEGIN动作之前就执行了。</p><p>变量赋值一定要小心不要与保留关键字重名，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v BEGIN=1 &#x27;BEGIN &#123;print &quot;BEGIN: &quot; BEGIN&#125;&#x27;</span><br><span class="line">awk: fatal: cannot use gawk builtin `BEGIN&#x27; as variable name</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="记录（Record）与字段（Field"><a href="#记录（Record）与字段（Field" class="headerlink" title="记录（Record）与字段（Field)"></a><a href="http://xiaoh.me/2016/03/23/awk-more/recordandfield">记录（Record）与字段（Field)</a></h3><p>对于数据库来说，一个数据库表是由多条记录组成的，每一行表示一条记录（Record）。每条记录由多列组成，每一列表示一个字段（Field)。Awk将一个文本文件视为一个文本数据库，因此它也有记录和字段的概念。默认情况下，记录的分隔符是回车，字段的分隔符是空白符，所以文本文件的每一行表示一个记录，而每一行中的内容被空白分隔成多个字段。利用字段和记录，awk就可以非常灵活地处理文件的内容。</p><p>可以通过-F选项来修改默认的字段分隔符，例如&#x2F;etc&#x2F;passwd的每一行都是由冒号分隔成多个字段的，所以这里就需要将分隔符设置成冒号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过$1引用第一人字段，类似地$2表示第二个字段，$3表示第三个字段…. $0则表示整个记录。内置变量NF记录着字段的个数，所以$NF表示最后一个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/false</span><br><span class="line">/bin/false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，$(NF-1)表示倒数第二个。</p><p>内置变量FS也可以用于更改字段分隔符，它记录着当前的字段分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print FS&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">:</span><br><span class="line">awk -v FS=: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记录的分隔符可以通过内置变量RS更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -v RS=: &#x27;&#123;print $0&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果将RS设置成空，行为有就一点怪异了，它会将连续不为空行的所有行（一个段落）当作一个记录，而且强制回车为字段分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat awk_man.txt </span><br><span class="line">The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">which is specialized for textual data manipulation. An awk program is a sequence</span><br><span class="line">of patterns and corresponding actions.  When  input  is  read  that matches a </span><br><span class="line">pattern, the action associated with that pattern is carried out.</span><br><span class="line"></span><br><span class="line">Input shall be interpreted as a sequence of records. By default, a record is a line, </span><br><span class="line">less its terminating &lt;newline&gt;, but this can be changed by using the RS built-in </span><br><span class="line">variable. Each record of input shall be matched in turn against each pattern in the </span><br><span class="line">program. For each pattern matched, the associated action shall be executed.</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN &#123;RS=&quot;&quot;;FS=&quot;:&quot;&#125; &#123;print &quot;First line: &quot; $1&#125;&#x27; awk_man.txt </span><br><span class="line">First line: The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">First line: Input shall be interpreted as a sequence of records. By default, a record is a line,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，我们将变量赋值放到BEGIN动作中执行，因为BEGIN动作是在文件处理之前执行的，专门用于放初始化的语句。FS的赋值在这里是无效的，awk依然使用回车符来分隔字段。</p><hr><h3 id="脚本（Script）组成"><a href="#脚本（Script）组成" class="headerlink" title="脚本（Script）组成"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#script">脚本（Script）组成</a></h3><p>命令行中的program部分，可以称为awk代码,也可以称为awk脚本。一段awk脚本是由多个’pattern { action }‘序列组成的。action是一个或者多个语句，它在输入行匹配pattern的时候被执行。如果pattern为空，表明这个action会在每一行处理时都会被执行。下面的例子简单地打印文件的每一行，这里不带任何参数的print语句打印的是整个记录，类似’print $0‘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;line1\nline2&#x27; | awk &#x27;&#123;print&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了pattern { action }，还可以在脚本中定义自定义的函数，函数定义格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function name(parameter list) &#123; statements &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的参数列表用逗号分隔，参数默认是局部变量，无法在函数之外访问，而在函数中定义的变量为全局变量，可以在函数之外访问，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo line1 | awk &#x27;</span><br><span class="line">function t(a) &#123;</span><br><span class="line">    b=a;</span><br><span class="line">    print a;</span><br><span class="line">&#125; </span><br><span class="line">&#123;</span><br><span class="line">    print b;</span><br><span class="line">    t(&quot;kodango.me&quot;); </span><br><span class="line">    print b;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Awk脚本中的语句使用空行或者分号分隔，使用分号可以放在同一行，不过有时候会影响可读性，尤其是分支或循环结构中，很容易出错。</p><p>如果Awk中的一个语句太长，要分成多行，可以在行为使用反斜杠’’：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat test.awk</span><br><span class="line">function t(a)</span><br><span class="line">&#123;</span><br><span class="line">        b=a</span><br><span class="line">        print &quot;This is a very long line, so use backslash to escape the newline then we will print the variable a: a=&quot; a</span><br><span class="line">&#125; </span><br><span class="line">&#123; print b; t(&quot;kodango.me&quot;); print b;&#125;</span><br><span class="line">echo 1 | awk -f test.awk</span><br><span class="line"></span><br><span class="line">This is a very long line, so use backslash to escape the newline then we will print the variable a: a=kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>这里我们将脚本写到文件中，并通过-f参数来指定。但是，在一些特殊符号之后，是可以直接换行的，例如”, { &amp;&amp;</th><th></th><th>”。</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="模式（Pattern）"><a href="#模式（Pattern）" class="headerlink" title="模式（Pattern）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#pattern">模式（Pattern）</a></h3><p>模式是awk中比较重要的一部分，它有以下几种情况：</p><ul><li>&#x2F;regular expression&#x2F;： 扩展的正则表达式（Extended Regular Expression）， 关于ERE可以参考 <a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">这篇文章</a>；</li><li>relational expression： 关系表达式，例如大于、小于、等于，关系表达式结果为true表示匹配；</li><li>BEGIN： 特殊的模式，在第一个记录处理之前被执行，常用于初始化语句的执行；</li><li>END： 特殊的模式，在最后一个记录处理之前被执行，常用于输出汇总信息；</li><li>pattern, pattern：模式对，匹配两者之间的所有记录，类似sed的地址对；</li></ul><p>例如查找匹配数字3的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 20 | awk &#x27;/3/ &#123;print&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相反地，可以在在正则表达式之前加上’!’表示不匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;!/3/ &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>除了BEGIN和END这两个特殊的模式外，其余的模式都可以使用’&amp;&amp;’或者’</th><th></th><th>’运算符组合，前者表示逻辑与，后者表示逻辑或：</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 50 | awk &#x27;/3/ &amp;&amp; /1/ &#123;print&#125;&#x27;</span><br><span class="line">13</span><br><span class="line">31</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面的正则都是整行匹配，有时候仅仅需要匹配某个字符，这样我们可以用表达式$n ~ &#x2F;ere&#x2F;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;$1 ~ /xi/ &#123;print&#125;&#x27; /etc/passwd</span><br><span class="line">xingming:x:1000:1000::/home/xingming:/bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时候我们只想显示特定和行，例如显示第一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;NR==1 &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="正则表达式（Regular-Expression）"><a href="#正则表达式（Regular-Expression）" class="headerlink" title="正则表达式（Regular Expression）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#regex">正则表达式（Regular Expression）</a></h3><p>正则表达式的内容介绍起来太麻烦，还是推荐同学阅读现有的文章（如 <a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux&#x2F;Unix工具与正则表达式的POSIX规范</a>），里面对各个流派的正则表达式归纳地很清楚了。</p><hr><h3 id="表达式（Expressions）"><a href="#表达式（Expressions）" class="headerlink" title="表达式（Expressions）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#expressions">表达式（Expressions）</a></h3><p>表达式可以由常量、变量、运算符和函数组成，常数和变量的值可以为字符串和数值。</p><p>Awk中的变量有三种类型：用户定义的变量，内置变量和字段变量。其中，内置变量名都是大写的。变量并不非一定要被声明或者被初始化，未初始化的字符串变量的值为””，未初始化的数值变量的值为0。字段变量可以用$n来引用，n的取值范围为[0,NF]。n可以为一个变量，例如$NF代码最后一个字段，而$(NF-1)表示倒数第二个字段。</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#array">数组</a></h3><p>数组是一种特殊的变量，在awk中，比较特殊地是，数组的下标可以为数字或者字符串。数组的赋值很简单，下面将value赋值给数组下标为index的元素：<code>array[index]=value</code></p><p>可以用for..in..语法遍历数组元素，其中item是数组元素对应的下标：<code>for (item in array)</code></p><p>当然也可以在if分支判断中使用in操作符：<code>if (item in array)</code></p><p>一个完整的例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2 3&quot; | awk &#x27;&#123;</span><br><span class="line">    for (i=0;i&lt;NF;i++)</span><br><span class="line">          a[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">END &#123;</span><br><span class="line">    print 3 in a</span><br><span class="line">        for (i in a)</span><br><span class="line">               printf &quot;%s: %s\n&quot;, i, a[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">0</span><br><span class="line">0: 0</span><br><span class="line">1: 1</span><br><span class="line">2: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#innervalue">内置变量</a></h3><p>Awk在内部维护了许多内置变量，或者称为系统变量，例如之前提到的FS、RS等等。常见的内置变量如下表所示</p><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>ARGC</td><td>命令行参数的各个，即ARGV数组的长度</td></tr><tr><td>ARGV</td><td>存放命令行参数</td></tr><tr><td>CONVFMT</td><td>定义awk内部数值转换成字符串的格式，默认值为”%.6g”</td></tr><tr><td>OFMT</td><td>定义输出时数值转换成字符串的格式，默认值为”%.6g”</td></tr><tr><td>ENVIRON</td><td>存放系统环境变量的关联数组</td></tr><tr><td>FILENAME</td><td>当前被处理的文件名</td></tr><tr><td>NR</td><td>记录的总个数</td></tr><tr><td>FNR</td><td>当前文件中的记录的总个数</td></tr><tr><td>FS</td><td>字段分隔符，默认为空白</td></tr><tr><td>NF</td><td>每个记录中字段的个数</td></tr><tr><td>RS</td><td>记录的分隔符，默认为回车</td></tr><tr><td>OFS</td><td>输出时字段的分隔符，默认为空白</td></tr><tr><td>ORS</td><td>输出时记录的分隔符，默认为回车</td></tr><tr><td>RLENGTH</td><td>被match函数匹配的子串长度</td></tr><tr><td>RSTART</td><td>被match函数匹配的子串位于目标字符串的起始下标</td></tr></tbody></table><p>下面主要介绍几个比较难理解的内置变量：</p><h5 id="ARGV与ARGC"><a href="#ARGV与ARGC" class="headerlink" title="ARGV与ARGC"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#argvargc">ARGV与ARGC</a></h5><p>ARGV与ARGC的意思比较好理解，就像C语言 <code>main(int argc, char **argv)</code>。ARGV数组的下标从0开始到ARGC-1，它存放的是命令行参数，并且排除命令行选项（例如-v&#x2F;-f）以及program部分。因此事实上ARGV只是存储argument的部分，即文件名（file）以及命令行变量赋值两部分的内容。</p><p>通过下面的例子可以大概了解ARGC与ARGV的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    for (i = 0; i &lt; ARGC; i++)</span><br><span class="line">        print ARGV[i]</span><br><span class="line">&#125;&#x27; inventory-shipped BBS-list</span><br><span class="line">awk</span><br><span class="line">inventory-shipped</span><br><span class="line">BBS-list</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ARGV的用法不仅限于此，它是可以修改的，可以更改数组元素的值，可以增加数组元素或者删除数组元素。</p><h6 id="更改ARGV元素的值"><a href="#更改ARGV元素的值" class="headerlink" title="更改ARGV元素的值"></a>更改ARGV元素的值</h6><p>假设我们有a, b两个文件，它们各有一行内容：file a和file b。现在利用ARGV，我们可以做到偷梁换柱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;b&quot;&#125; &#123;print&#125;&#x27; a</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里要注意ARGV[1]&#x3D;”b”的引号不能缺少，否则ARGV[1]&#x3D;b会将变量b的值赋值给ARGV[1]。</p><p>当awk处理完一个文件之后，它会从ARGV的下一个元素获取参数，如果是一个文件则继续处理，如果是一个变量赋值则执行赋值操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;var=1&quot;&#125; &#123;print var&#125;&#x27; a b</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当下一个元素为空时，则跳过不处理，这样可以避开处理某个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中a这个文件就被跳过了。</p><p>而当下一个元素的值为”-”时，表明从标准输入读取内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;-&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">a</span><br><span class="line">a    # --&gt; 这里按下CTRL+D停止输入</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="删除ARGV元素"><a href="#删除ARGV元素" class="headerlink" title="删除ARGV元素"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#deleteargv">删除ARGV元素</a></h6><p>删除ARGV元素和将元素的值赋值为空的效果是一样的，它们都会跳转对某个参数的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;delete ARGV[1]&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除数组元素可以用delete语句。</p><h6 id="增加ARGV元素"><a href="#增加ARGV元素" class="headerlink" title="增加ARGV元素"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#addingargv">增加ARGV元素</a></h6><p>我第一次看到ARGV变量的时候就在想，能不能利用ARGV变量避免提供命令行参数，就像这样: <code>awk &#39;BEGIN&#123;ARGV[1]=&quot;a&quot;;&#125; &#123;print&#125;&#39;</code></p><p>但是事实上这样不行，awk会依然从标准输入中获取内容。下面的方法倒是可以，首先增加ARGC的值，再增加ARGV元素，我到现在也没搞懂这两者的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGC+=1;ARGV[1]=&quot;a&quot;&#125; &#123;print&#125;&#x27;</span><br><span class="line">file a</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CONVFMT与OFMT"><a href="#CONVFMT与OFMT" class="headerlink" title="CONVFMT与OFMT"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#convfmtofmt">CONVFMT与OFMT</a></h5><p>Awk中允许数值到字符串相互转换，其中内置变量CONVFMT定义了awk内部数值到字符串转换的格式，它的默认值为”%.6g”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11</span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%.6g, num=12.110000, str=12.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过更改CONVFMT，我们可以定义自己的转换格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    CONVFMT=&quot;%d&quot;;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11 </span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%d, num=12.110000, str=12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与此对应地还有一个内置变量 <em>OFMT</em>，它与CONVFMT的作用是类似的，只不过是影响输出的时候数字转换成字符串的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; OFMT=&quot;%d&quot;;print 12.11 &#125;&#x27; </span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ENVIRON"><a href="#ENVIRON" class="headerlink" title="ENVIRON"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#environ">ENVIRON</a></h5><p>ENVIRON是一个存放系统环境变量的关联数组，它的下标是环境变量名称，值是相应环境变量的值。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print ENVIRON[&quot;USER&quot;] &#125;&#x27; </span><br><span class="line">xingming</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用环境变量也可以将值传递给awk：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">U=hello awk &#x27;BEGIN &#123; print ENVIRON[&quot;U&quot;] &#125;&#x27; </span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以利用for..in循环遍历ENVIRON数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    for (env in ENVIRON) </span><br><span class="line">        printf &quot;%s=%s\n&quot;, env, ENVIRON[env]; </span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="RLENGTH与RSTART"><a href="#RLENGTH与RSTART" class="headerlink" title="RLENGTH与RSTART"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#rlengthrstart">RLENGTH与RSTART</a></h5><p>RLENGTH与RSTART都是与match函数相关的，前者表示匹配的子串长度，后者表示匹配的子串位于目标字符串的起始下标。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;match(&quot;hello,world&quot;, /llo/); print RSTART,RLENGTH&#125;&#x27;</span><br><span class="line">3 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#yunsuanfu">运算符</a></h3><p>表达式中必然少不了运算符，awk支持的运算符可以参见man手册中的“Expressions in awk”一小节内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man awk | grep &quot;^ *Table: Expressions in&quot; -A 42 | sed &#x27;s/^ *//&#x27;</span><br><span class="line">Table: Expressions in Decreasing Precedence in awk</span><br><span class="line"> </span><br><span class="line">Syntax                Name                      Type of Result   Associativity</span><br><span class="line">( expr )              Grouping                  Type of expr     N/A</span><br><span class="line">$expr                 Field reference           String           N/A</span><br><span class="line">++ lvalue             Pre-increment             Numeric          N/A</span><br><span class="line">-- lvalue             Pre-decrement             Numeric          N/A</span><br><span class="line">lvalue ++             Post-increment            Numeric          N/A</span><br><span class="line">lvalue --             Post-decrement            Numeric          N/A</span><br><span class="line">expr ^ expr           Exponentiation            Numeric          Right</span><br><span class="line">! expr                Logical not               Numeric          N/A</span><br><span class="line"> </span><br><span class="line">+ expr                Unary plus                Numeric          N/A</span><br><span class="line">- expr                Unary minus               Numeric          N/A</span><br><span class="line">expr * expr           Multiplication            Numeric          Left</span><br><span class="line"> </span><br><span class="line">...以下省略...</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="语句（Statement）"><a href="#语句（Statement）" class="headerlink" title="语句（Statement）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#statement">语句（Statement）</a></h3><p>到目前为止，用得比较多的语句就是print，其它的还有printf、delete、break、continue、exit、next等等。这些语句与函数不同的是，它们不会使用带括号的参数，并且没有返回值。不过也有意外，比如printf就可以像函数一样的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk &#x27;&#123;printf(&quot;%s\n&quot;, &quot;abc&quot;)&#125;&#x27;</span><br><span class="line">abc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>break和continue语句，大家应该比较了解，分别用于跳出循环和跳到下一个循环。</p><p>delete用于删除数组中的某个元素，这个我们在上面介绍ARGV的时候也使用过。</p><p>exit的用法顾名思义，就是退出awk的处理，然后会执行END部分的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;print;exit&#125; END &#123;print &quot;exit..&quot;&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">exit..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>next语句类似sed的n命令，它会读取下一条记录，并重新回到脚本的最开始处执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;</span><br><span class="line">    print &quot;Before next..&quot;</span><br><span class="line">    print $0 </span><br><span class="line">    next</span><br><span class="line">    print &quot;After next..&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">Before next..</span><br><span class="line">line1</span><br><span class="line">Before next..</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看出next后面的print语句不会执行。</p><p>print与printf语句是使用最多的，它们将内容输出到标准输出。注意在print语句中，输出的变量之间带不带逗号是有区别的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1, $2&#125;&#x27;</span><br><span class="line">1 2</span><br><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1 $2&#125;&#x27;</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>print输出时，字段之间的分隔符可以由OFS重新定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1 2&quot; | awk &#x27;&#123;OFS=&quot;;&quot;;print $1,$2&#125;&#x27;</span><br><span class="line">1;2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，print的输出还可以重定向到某个文件中或者某个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print items &gt; output-file</span><br><span class="line">print items &gt;&gt; output-file</span><br><span class="line">print items | command</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设有这一样一个文件，第一列是语句名称，第二列是对应的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat column.txt </span><br><span class="line">statement|description</span><br><span class="line">delete|delete item from an array</span><br><span class="line">exit|exit from the awk process</span><br><span class="line">next|read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们要将两列的内容分别输出到statement.txt和description.txt两个文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&#x27;|&#x27; &#x27;&#123;</span><br><span class="line">    print $1 &gt; &quot;statement.txt&quot;;</span><br><span class="line">    print $2 &gt; &quot;description.txt&quot;</span><br><span class="line">&#125;&#x27; column.txt </span><br><span class="line">[kodango@devops awk_temp]$ cat statement.txt </span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line">[kodango@devops awk_temp]$ cat description.txt </span><br><span class="line">description</span><br><span class="line">delete item from an array</span><br><span class="line">exit from the awk process</span><br><span class="line">read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个重定向到命令的例子，假设我们要对下面的文件进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat num.list </span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以通过将print的内容重定向到”sort -n”命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;print | &quot;sort -n&quot;&#125;&#x27; num.list </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>printf命令的用法与print类似，也可以重定向到文件或者输出，只不过printf比print多了格式化字符串的功能。printf的语法也大多数语言包括bash的printf命令类似，这里就不多介绍了。</p><hr><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#mathfunction">数学函数</a></h3><p>awk中支持以下数学函数：</p><ul><li>atan2(y,x)：反正切函数；</li><li>cos(x)：余弦函数；</li><li>sin(x)：正弦函数；</li><li>exp(x)：以自然对数e为底指数函数；</li><li>log(x)：计算以e 为底的对数值；</li><li>sqrt(x)：开平方函数；</li><li>int(x)：将数值转换成整数（绝对值）；</li><li>rand()：返回0到1的一个随机数值，不包含1；</li><li>srand([expr])：设置随机种子，一般与rand函数配合使用，如果参数为空，默认使用当前时间为种子；</li></ul><p>例如，我们使用rand()函数生成一个随机数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是你会发现，每次awk执行都会生成同样的随机数，但是在一次执行过程中产生的随机数又是不同的。因为每次awk执行都使用了同样的种子，所以我们可以用srand()函数来设置种子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.171625 0.00692412</span><br><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.43269 0.782984</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样每次生成的随机数就不一样了。</p><p>利用rand()函数我们也可以生成1到n的整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;</span><br><span class="line">    function randint(n) &#123; return int(n*rand()); &#125;</span><br><span class="line">    BEGIN &#123; srand(); print randint(10);</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#string">字符串函数</a></h3><p>awk中包含大多数常见的字符串操作函数。</p><h5 id="sub"><a href="#sub" class="headerlink" title="sub"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#sub">sub</a></h5><p><em>sub(ere, repl[, in])</em></p><p>描述：简单地说，就是将in中匹配ere的部分替换成repl，返回值是替换的次数。如果in参数省略，默认使用$0。替换的动作会直接修改变量的值。</p><p>下面是一个简单的替换的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello, world&quot; | awk &#x27;&#123;print sub(/ello/, &quot;i&quot;); print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">hi, world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在repl参数中&amp;是一个元字符，它表示匹配的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;var=&quot;kodango&quot;; sub(/kodango/, &quot;hello, &amp;&quot;, var); print var&#125;&#x27;</span><br><span class="line">hello, kodango</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="gsub"><a href="#gsub" class="headerlink" title="gsub"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#gsub">gsub</a></h5><p><em>gsub(ere, repl[, in])</em></p><p>描述：同sub()函数功能类似，只不过是gsub()是全局替换，即替换所有匹配的内容。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#index">index</a></h5><p><em>index(s, t)</em></p><p>描述：返回字符串t在s中出现的位置，注意这里位置是从1开始计算的，如果没有找到则返回0。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;n&quot;)&#125;&#x27;</span><br><span class="line">2</span><br><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;w&quot;)&#125;&#x27;</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="length"><a href="#length" class="headerlink" title="length"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#length">length</a></h5><p><em>length[([s])]</em></p><p>描述：返回字符串的长度，如果参数s没有指定，则默认使用$0作为参数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print length(&#x27;xingming&#x27;);&#125;&#x27;</span><br><span class="line">8</span><br><span class="line">$ echo &quot;first line&quot; | awk &#x27;&#123;print length();&#125;&#x27;</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="match"><a href="#match" class="headerlink" title="match"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#match">match</a></h5><p><em>match(s, ere)</em></p><p>描述： 返回字符串s匹配ere的起始位置，如果不匹配则返回0。该函数会定义RSTART和RLENGTH两个内置变量。RSTART与返回值相同，RLENGTH记录匹配子串的长度，如果不匹配则为-1。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">print match(&quot;xingming&quot;, /ngmin/);</span><br><span class="line">printf &quot;Matched at: %d, Matched substr length: %d\n&quot;, RSTART, RLENGTH;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">Matched at: 3, Matched substr length: 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="split"><a href="#split" class="headerlink" title="split"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#split">split</a></h5><p><em>split(s, a[, fs])</em></p><p>描述：将字符串按照分隔符fs，分隔成多个部分，并存到数组a中。注意，存放的位置是从第1个数组元素开始的。如果fs为空，则默认使用FS分隔。函数返回值分隔的个数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i in arr)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有一个奇怪的地方是for..in..输出的数组不是按顺序输出的，如果要按顺序输出可以用常规的for循环:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    n=split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i=1; i&lt;=n; i++)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#sprintf">sprintf</a></h5><p><em>sprintf(fmt, expr, expr, …)</em></p><p>描述：类似printf，只不过不会将格式化后的内容输出到标准输出，而是当作返回值返回。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    var=sprintf(&quot;%s=%s&quot;, &quot;name&quot;, &quot;value&quot;)</span><br><span class="line">    print var</span><br><span class="line">&#125;&#x27;</span><br><span class="line">name=value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="substr"><a href="#substr" class="headerlink" title="substr"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#substr">substr</a></h5><p><em>substr(s, m[, n])</em></p><p>描述：返回从位置m开始的，长度为n的子串，其中位置从1开始计算，如果未指定n或者n值大于剩余的字符个数，则子串一直到字符串末尾为止。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2, 3); &#125;&#x27;</span><br><span class="line">iao</span><br><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2); &#125;&#x27;</span><br><span class="line">iaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#tolower">tolower</a></h5><p><em>tolower(s)</em></p><p>描述：将字符串转换成小写字符。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print tolower(&quot;XIAOH.ME&quot;);&#125;&#x27;</span><br><span class="line">xiaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="toupper"><a href="#toupper" class="headerlink" title="toupper"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#toupper">toupper</a></h5><p><em>toupper(s)</em></p><p>描述：将字符串转换成大写字符。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print toupper(&#x27;xiaoh.me&#x27;)&#125;&#x27;</span><br><span class="line">XIAOH.ME</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="I-x2F-O处理函数"><a href="#I-x2F-O处理函数" class="headerlink" title="I&#x2F;O处理函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#io">I&#x2F;O处理函数</a></h3><h5 id="getline"><a href="#getline" class="headerlink" title="getline"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#getline">getline</a></h5><p>getline的用法相对比较复杂，它有几种不同的形式。不过它的主要作用就是从输入中每次获取一行输入。</p><h6 id="expression-getline-var"><a href="#expression-getline-var" class="headerlink" title="expression | getline [var]"></a><code>expression | getline [var]</code></h6><p>这种形式将前面管道前命令输出的结果作为getline的输入，每次读取一行。如果后面跟有var，则将读取的内容保存到var变量中，否则会重新设置$0和NF。</p><p>例如，我们将上面的statement.txt文件的内容显示作为getline的输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline var) print var&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中命令要用双引号，<code>cat statement.txt</code>，这一点同print&#x2F;printf是一样的。</p><p>如果不加var，则直接写到$0中，注意NF值也会被更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline) print $0,NF&#125;&#x27;</span><br><span class="line">statement 1</span><br><span class="line">delete 1</span><br><span class="line">exit 1</span><br><span class="line">next 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getline-var"><a href="#getline-var" class="headerlink" title="getline [var]"></a><code>getline [var]</code></h6><p>第二种形式是直接使用getline，它会从处理的文件中读取输入。同样地，如果var没有，则会设置$0，并且这时候会更新NF, NR和FNR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;</span><br><span class="line">    while (getline) </span><br><span class="line">       print NF, NR, FNR, $0;</span><br><span class="line">&#125;&#x27; statement.txt</span><br><span class="line">1 2 2 delete</span><br><span class="line">1 3 3 exit</span><br><span class="line">1 4 4 next</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getline-var-lt-expression"><a href="#getline-var-lt-expression" class="headerlink" title="getline [var] &lt; expression"></a><code>getline [var] &lt; expression</code></h6><p>第三种形式从expression中重定向输入，与第一种方法类似，这里就不加赘述了。</p><h5 id="close"><a href="#close" class="headerlink" title="close"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#close">close</a></h5><p>close函数可以用于关闭已经打开的文件或者管道，例如getline函数的第一种形式用到管道，我们可以用close函数把这个管道关闭，close函数的参数与管道的命令一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    while(&quot;cat statement.txt&quot; | getline) &#123;</span><br><span class="line">        print $0;</span><br><span class="line">        close(&quot;cat statement.txt&quot;);</span><br><span class="line">&#125;&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是每次读了一行后，关闭管道，然后重新打开又重新读取第一行就死循环了。所以要慎用，一般情况下也很少会用到close函数。</p><h5 id="system"><a href="#system" class="headerlink" title="system"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#system">system</a></h5><p>这个函数很简单，就是用于执行外部命令，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;system(&quot;uname -r&quot;);&#125;&#x27;</span><br><span class="line">3.6.2-1-ARCH</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>快速了解Awk系列的几篇文章相对比较粗糙，我是参考Awk的man手册以及《Sed &amp; Awk》附录B总结而成的，但是应该可以让大家对awk有一个大致的了解，欢迎大家一起交流。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用函数总结</title>
      <link href="/2017/12/06/%E5%89%8D%E7%AB%AF/%20js%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/06/%E5%89%8D%E7%AB%AF/%20js%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>发现一篇整理的不错的，常用JS函数，支持下作者。</p></blockquote><ul><li><a href="https://github.com/proYang/outils">作者github，start</a></li></ul><h1 id="常用函数汇总"><a href="#常用函数汇总" class="headerlink" title="常用函数汇总"></a>常用函数汇总</h1><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h3 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断两个数组是否相等</span><br><span class="line"> * @param &#123;Array&#125; arr1 </span><br><span class="line"> * @param &#123;Array&#125; arr2 </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function arrayEqual(arr1, arr2) &#123;</span><br><span class="line">    if (arr1 === arr2) return true;</span><br><span class="line">    if (arr1.length != arr2.length) return false;</span><br><span class="line">    for (var i = 0; i &lt; arr1.length; ++i) &#123;</span><br><span class="line">        if (arr1[i] !== arr2[i]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h3 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   为元素添加class</span><br><span class="line"> * @param  &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param  &#123;String&#125; cls </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var hasClass = require(&#x27;./hasClass&#x27;);</span><br><span class="line"></span><br><span class="line">function addClass(ele, cls) &#123;</span><br><span class="line">    if (!hasClass(ele, cls)) &#123;</span><br><span class="line">        ele.className += &#x27; &#x27; + cls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-hasClass"><a href="#2-2-hasClass" class="headerlink" title="2.2 hasClass"></a>2.2 hasClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断元素是否有某个class</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param &#123;String&#125; cls </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function hasClass(ele, cls) &#123;</span><br><span class="line">    return (new RegExp(&#x27;(\\s|^)&#x27; + cls + &#x27;(\\s|$)&#x27;)).test(ele.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-removeClass"><a href="#2-3-removeClass" class="headerlink" title="2.3 removeClass"></a>2.3 removeClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 为元素移除class</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param &#123;String&#125; cls </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var hasClass = require(&#x27;./hasClass&#x27;);</span><br><span class="line"></span><br><span class="line">function removeClass(ele, cls) &#123;</span><br><span class="line">    if (hasClass(ele, cls)) &#123;</span><br><span class="line">        var reg = new RegExp(&#x27;(\\s|^)&#x27; + cls + &#x27;(\\s|$)&#x27;);</span><br><span class="line">        ele.className = ele.className.replace(reg, &#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h3 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 根据name读取cookie</span><br><span class="line"> * @param  &#123;String&#125; name </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function getCookie(name) &#123;</span><br><span class="line">    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&#x27;;&#x27;);</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var tempArr = arr[i].split(&#x27;=&#x27;);</span><br><span class="line">        if (tempArr[0] == name) &#123;</span><br><span class="line">            return decodeURIComponent(tempArr[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-removeCookie"><a href="#3-2-removeCookie" class="headerlink" title="3.2 removeCookie"></a>3.2 removeCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var setCookie = require(&#x27;./setCookie&#x27;);</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 根据name删除cookie</span><br><span class="line"> * @param  &#123;String&#125; name </span><br><span class="line"> */</span><br><span class="line">function removeCookie(name) &#123;</span><br><span class="line">    // 设置已过期，系统会立刻删除cookie</span><br><span class="line">    setCookie(name, &#x27;1&#x27;, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-setCookie"><a href="#3-3-setCookie" class="headerlink" title="3.3 setCookie"></a>3.3 setCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  设置Cookie</span><br><span class="line"> * @param &#123;String&#125; name </span><br><span class="line"> * @param &#123;String&#125; value </span><br><span class="line"> * @param &#123;Number&#125; days </span><br><span class="line"> */</span><br><span class="line">function setCookie(name, value, days) &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setDate(date.getDate() + days);</span><br><span class="line">    document.cookie = name + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h3 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取浏览器类型和版本</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function getExplore() &#123;</span><br><span class="line">    var sys = &#123;&#125;,</span><br><span class="line">        ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">        s;</span><br><span class="line">    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:</span><br><span class="line">        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :</span><br><span class="line">        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :</span><br><span class="line">        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :</span><br><span class="line">        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :</span><br><span class="line">        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :</span><br><span class="line">        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;</span><br><span class="line">    // 根据关系进行判断</span><br><span class="line">    if (sys.ie) return (&#x27;IE: &#x27; + sys.ie)</span><br><span class="line">    if (sys.edge) return (&#x27;EDGE: &#x27; + sys.edge)</span><br><span class="line">    if (sys.firefox) return (&#x27;Firefox: &#x27; + sys.firefox)</span><br><span class="line">    if (sys.chrome) return (&#x27;Chrome: &#x27; + sys.chrome)</span><br><span class="line">    if (sys.opera) return (&#x27;Opera: &#x27; + sys.opera)</span><br><span class="line">    if (sys.safari) return (&#x27;Safari: &#x27; + sys.safari)</span><br><span class="line">    return &#x27;Unkonwn&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-getOS"><a href="#4-2-getOS" class="headerlink" title="4.2 getOS"></a>4.2 getOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取操作系统类型</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function getOS() &#123;</span><br><span class="line">    var userAgent = &#x27;navigator&#x27; in window &amp;&amp; &#x27;userAgent&#x27; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &#x27;&#x27;;</span><br><span class="line">    var vendor = &#x27;navigator&#x27; in window &amp;&amp; &#x27;vendor&#x27; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &#x27;&#x27;;</span><br><span class="line">    var appVersion = &#x27;navigator&#x27; in window &amp;&amp; &#x27;appVersion&#x27; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    if (/mac/i.test(appVersion)) return &#x27;MacOSX&#x27;</span><br><span class="line">    if (/win/i.test(appVersion)) return &#x27;windows&#x27;</span><br><span class="line">    if (/linux/i.test(appVersion)) return &#x27;linux&#x27;</span><br><span class="line">    if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &#x27;ios&#x27;</span><br><span class="line">    if (/android/i.test(userAgent)) return &#x27;android&#x27;</span><br><span class="line">    if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &#x27;windowsPhone&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h3 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取滚动条距顶部的距离</span><br><span class="line"> */</span><br><span class="line">function getScrollTop() &#123;</span><br><span class="line">    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-offset"><a href="#5-2-offset" class="headerlink" title="5.2 offset"></a>5.2 offset</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @returns &#123; &#123;left: number, top: number&#125; &#125;</span><br><span class="line"> */</span><br><span class="line">function offset(ele) &#123;</span><br><span class="line">    var pos = &#123;</span><br><span class="line">        left: 0,</span><br><span class="line">        top: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    while (ele) &#123;</span><br><span class="line">        pos.left += ele.offsetLeft;</span><br><span class="line">        pos.top += ele.offsetTop;</span><br><span class="line">        ele = ele.offsetParent;</span><br><span class="line">    &#125;;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var getScrollTop = require(&#x27;./getScrollTop&#x27;);</span><br><span class="line">var setScrollTop = require(&#x27;./setScrollTop&#x27;);</span><br><span class="line">var requestAnimFrame = (function () &#123;</span><br><span class="line">    return window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        window.mozRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  在$&#123;duration&#125;时间内，滚动条平滑滚动到$&#123;to&#125;指定位置</span><br><span class="line"> * @param &#123;Number&#125; to </span><br><span class="line"> * @param &#123;Number&#125; duration </span><br><span class="line"> */</span><br><span class="line">function scrollTo(to, duration) &#123;</span><br><span class="line">    if (duration &lt; 0) &#123;</span><br><span class="line">        setScrollTop(to);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var diff = to - getScrollTop();</span><br><span class="line">    if (diff === 0) return</span><br><span class="line">    var step = diff / duration * 10;</span><br><span class="line">    requestAnimationFrame(</span><br><span class="line">        function () &#123;</span><br><span class="line">            if (Math.abs(step) &gt; Math.abs(diff)) &#123;</span><br><span class="line">                setScrollTop(getScrollTop() + diff);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            setScrollTop(getScrollTop() + step);</span><br><span class="line">            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            scrollTo(to, duration - 16);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 设置滚动条距顶部的距离</span><br><span class="line"> */</span><br><span class="line">function setScrollTop(value) &#123;</span><br><span class="line">    window.scrollTo(0, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h3 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">var keyCodeMap = &#123;</span><br><span class="line">    8: &#x27;Backspace&#x27;,</span><br><span class="line">    9: &#x27;Tab&#x27;,</span><br><span class="line">    13: &#x27;Enter&#x27;,</span><br><span class="line">    16: &#x27;Shift&#x27;,</span><br><span class="line">    17: &#x27;Ctrl&#x27;,</span><br><span class="line">    18: &#x27;Alt&#x27;,</span><br><span class="line">    19: &#x27;Pause&#x27;,</span><br><span class="line">    20: &#x27;Caps Lock&#x27;,</span><br><span class="line">    27: &#x27;Escape&#x27;,</span><br><span class="line">    32: &#x27;Space&#x27;,</span><br><span class="line">    33: &#x27;Page Up&#x27;,</span><br><span class="line">    34: &#x27;Page Down&#x27;,</span><br><span class="line">    35: &#x27;End&#x27;,</span><br><span class="line">    36: &#x27;Home&#x27;,</span><br><span class="line">    37: &#x27;Left&#x27;,</span><br><span class="line">    38: &#x27;Up&#x27;,</span><br><span class="line">    39: &#x27;Right&#x27;,</span><br><span class="line">    40: &#x27;Down&#x27;,</span><br><span class="line">    42: &#x27;Print Screen&#x27;,</span><br><span class="line">    45: &#x27;Insert&#x27;,</span><br><span class="line">    46: &#x27;Delete&#x27;,</span><br><span class="line"></span><br><span class="line">    48: &#x27;0&#x27;,</span><br><span class="line">    49: &#x27;1&#x27;,</span><br><span class="line">    50: &#x27;2&#x27;,</span><br><span class="line">    51: &#x27;3&#x27;,</span><br><span class="line">    52: &#x27;4&#x27;,</span><br><span class="line">    53: &#x27;5&#x27;,</span><br><span class="line">    54: &#x27;6&#x27;,</span><br><span class="line">    55: &#x27;7&#x27;,</span><br><span class="line">    56: &#x27;8&#x27;,</span><br><span class="line">    57: &#x27;9&#x27;,</span><br><span class="line"></span><br><span class="line">    65: &#x27;A&#x27;,</span><br><span class="line">    66: &#x27;B&#x27;,</span><br><span class="line">    67: &#x27;C&#x27;,</span><br><span class="line">    68: &#x27;D&#x27;,</span><br><span class="line">    69: &#x27;E&#x27;,</span><br><span class="line">    70: &#x27;F&#x27;,</span><br><span class="line">    71: &#x27;G&#x27;,</span><br><span class="line">    72: &#x27;H&#x27;,</span><br><span class="line">    73: &#x27;I&#x27;,</span><br><span class="line">    74: &#x27;J&#x27;,</span><br><span class="line">    75: &#x27;K&#x27;,</span><br><span class="line">    76: &#x27;L&#x27;,</span><br><span class="line">    77: &#x27;M&#x27;,</span><br><span class="line">    78: &#x27;N&#x27;,</span><br><span class="line">    79: &#x27;O&#x27;,</span><br><span class="line">    80: &#x27;P&#x27;,</span><br><span class="line">    81: &#x27;Q&#x27;,</span><br><span class="line">    82: &#x27;R&#x27;,</span><br><span class="line">    83: &#x27;S&#x27;,</span><br><span class="line">    84: &#x27;T&#x27;,</span><br><span class="line">    85: &#x27;U&#x27;,</span><br><span class="line">    86: &#x27;V&#x27;,</span><br><span class="line">    87: &#x27;W&#x27;,</span><br><span class="line">    88: &#x27;X&#x27;,</span><br><span class="line">    89: &#x27;Y&#x27;,</span><br><span class="line">    90: &#x27;Z&#x27;,</span><br><span class="line"></span><br><span class="line">    91: &#x27;Windows&#x27;,</span><br><span class="line">    93: &#x27;Right Click&#x27;,</span><br><span class="line"></span><br><span class="line">    96: &#x27;Numpad 0&#x27;,</span><br><span class="line">    97: &#x27;Numpad 1&#x27;,</span><br><span class="line">    98: &#x27;Numpad 2&#x27;,</span><br><span class="line">    99: &#x27;Numpad 3&#x27;,</span><br><span class="line">    100: &#x27;Numpad 4&#x27;,</span><br><span class="line">    101: &#x27;Numpad 5&#x27;,</span><br><span class="line">    102: &#x27;Numpad 6&#x27;,</span><br><span class="line">    103: &#x27;Numpad 7&#x27;,</span><br><span class="line">    104: &#x27;Numpad 8&#x27;,</span><br><span class="line">    105: &#x27;Numpad 9&#x27;,</span><br><span class="line">    106: &#x27;Numpad *&#x27;,</span><br><span class="line">    107: &#x27;Numpad +&#x27;,</span><br><span class="line">    109: &#x27;Numpad -&#x27;,</span><br><span class="line">    110: &#x27;Numpad .&#x27;,</span><br><span class="line">    111: &#x27;Numpad /&#x27;,</span><br><span class="line"></span><br><span class="line">    112: &#x27;F1&#x27;,</span><br><span class="line">    113: &#x27;F2&#x27;,</span><br><span class="line">    114: &#x27;F3&#x27;,</span><br><span class="line">    115: &#x27;F4&#x27;,</span><br><span class="line">    116: &#x27;F5&#x27;,</span><br><span class="line">    117: &#x27;F6&#x27;,</span><br><span class="line">    118: &#x27;F7&#x27;,</span><br><span class="line">    119: &#x27;F8&#x27;,</span><br><span class="line">    120: &#x27;F9&#x27;,</span><br><span class="line">    121: &#x27;F10&#x27;,</span><br><span class="line">    122: &#x27;F11&#x27;,</span><br><span class="line">    123: &#x27;F12&#x27;,</span><br><span class="line"></span><br><span class="line">    144: &#x27;Num Lock&#x27;,</span><br><span class="line">    145: &#x27;Scroll Lock&#x27;,</span><br><span class="line">    182: &#x27;My Computer&#x27;,</span><br><span class="line">    183: &#x27;My Calculator&#x27;,</span><br><span class="line">    186: &#x27;;&#x27;,</span><br><span class="line">    187: &#x27;=&#x27;,</span><br><span class="line">    188: &#x27;,&#x27;,</span><br><span class="line">    189: &#x27;-&#x27;,</span><br><span class="line">    190: &#x27;.&#x27;,</span><br><span class="line">    191: &#x27;/&#x27;,</span><br><span class="line">    192: &#x27;`&#x27;,</span><br><span class="line">    219: &#x27;[&#x27;,</span><br><span class="line">    220: &#x27;\\&#x27;,</span><br><span class="line">    221: &#x27;]&#x27;,</span><br><span class="line">    222: &#x27;\&#x27;&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * @desc 根据keycode获得键名</span><br><span class="line"> * @param  &#123;Number&#125; keycode </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function getKeyName(keycode) &#123;</span><br><span class="line">    if (keyCodeMap[keycode]) &#123;</span><br><span class="line">        return keyCodeMap[keycode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;Unknow Key(Key Code:&#x27; + keycode + &#x27;)&#x27;);</span><br><span class="line">        return &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h3 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 深拷贝，支持常见类型</span><br><span class="line"> * @param &#123;Any&#125; values</span><br><span class="line"> */</span><br><span class="line">function deepClone(values) &#123;</span><br><span class="line">    var copy;</span><br><span class="line"></span><br><span class="line">    // Handle the 3 simple types, and null or undefined</span><br><span class="line">    if (null == values || &quot;object&quot; != typeof values) return values;</span><br><span class="line"></span><br><span class="line">    // Handle Date</span><br><span class="line">    if (values instanceof Date) &#123;</span><br><span class="line">        copy = new Date();</span><br><span class="line">        copy.setTime(values.getTime());</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle Array</span><br><span class="line">    if (values instanceof Array) &#123;</span><br><span class="line">        copy = [];</span><br><span class="line">        for (var i = 0, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = deepClone(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle Object</span><br><span class="line">    if (values instanceof Object) &#123;</span><br><span class="line">        copy = &#123;&#125;;</span><br><span class="line">        for (var attr in values) &#123;</span><br><span class="line">            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new Error(&quot;Unable to copy values! Its type isn&#x27;t supported.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断`obj`是否为空</span><br><span class="line"> * @param  &#123;Object&#125; obj</span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isEmptyObject(obj) &#123;</span><br><span class="line">    if (!obj || typeof obj !== &#x27;object&#x27; || Array.isArray(obj))</span><br><span class="line">        return false</span><br><span class="line">    return !Object.keys(obj).length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h3 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 随机生成颜色</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function randomColor() &#123;</span><br><span class="line">    return &#x27;#&#x27; + (&#x27;00000&#x27; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 生成指定范围随机数</span><br><span class="line"> * @param  &#123;Number&#125; min </span><br><span class="line"> * @param  &#123;Number&#125; max </span><br><span class="line"> * @return &#123;Number&#125; </span><br><span class="line"> */</span><br><span class="line">function randomNum(min, max) &#123;</span><br><span class="line">    return Math.floor(min + Math.random() * (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h3 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为邮箱地址</span><br><span class="line"> * @param  &#123;String&#125;  str</span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isEmail(str) &#123;</span><br><span class="line">    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  判断是否为身份证号</span><br><span class="line"> * @param  &#123;String|Number&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isIdCard(str) &#123;</span><br><span class="line">    return /^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/.test(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为手机号</span><br><span class="line"> * @param  &#123;String|Number&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isPhoneNum(str) &#123;</span><br><span class="line">    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/.test(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为URL地址</span><br><span class="line"> * @param  &#123;String&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isUrl(str) &#123;</span><br><span class="line">    return /[-a-zA-Z0-9@:%._\+~#=]&#123;2,256&#125;\.[a-z]&#123;2,6&#125;\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h3 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   现金额转大写</span><br><span class="line"> * @param  &#123;Number&#125; n </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function digitUppercase(n) &#123;</span><br><span class="line">    var fraction = [&#x27;角&#x27;, &#x27;分&#x27;];</span><br><span class="line">    var digit = [</span><br><span class="line">        &#x27;零&#x27;, &#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;, &#x27;肆&#x27;,</span><br><span class="line">        &#x27;伍&#x27;, &#x27;陆&#x27;, &#x27;柒&#x27;, &#x27;捌&#x27;, &#x27;玖&#x27;</span><br><span class="line">    ];</span><br><span class="line">    var unit = [</span><br><span class="line">        [&#x27;元&#x27;, &#x27;万&#x27;, &#x27;亿&#x27;],</span><br><span class="line">        [&#x27;&#x27;, &#x27;拾&#x27;, &#x27;佰&#x27;, &#x27;仟&#x27;]</span><br><span class="line">    ];</span><br><span class="line">    var head = n &lt; 0 ? &#x27;欠&#x27; : &#x27;&#x27;;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    var s = &#x27;&#x27;;</span><br><span class="line">    for (var i = 0; i &lt; fraction.length; i++) &#123;</span><br><span class="line">        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || &#x27;整&#x27;;</span><br><span class="line">    n = Math.floor(n);</span><br><span class="line">    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123;</span><br><span class="line">        var p = &#x27;&#x27;;</span><br><span class="line">        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123;</span><br><span class="line">            p = digit[n % 10] + unit[1][j] + p;</span><br><span class="line">            n = Math.floor(n / 10);</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replace(/(零.)*零$/, &#x27;&#x27;).replace(/^$/, &#x27;零&#x27;) + unit[0][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    return head + s.replace(/(零.)*零元/, &#x27;元&#x27;)</span><br><span class="line">        .replace(/(零.)+/g, &#x27;零&#x27;)</span><br><span class="line">        .replace(/^整$/, &#x27;零元整&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h3 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断浏览器是否支持webP格式图片</span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isSupportWebP() &#123;</span><br><span class="line">    return !![].map &amp;&amp; document.createElement(&#x27;canvas&#x27;).toDataURL(&#x27;image/webp&#x27;).indexOf(&#x27;data:image/webp&#x27;) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h3 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc   格式化$&#123;startTime&#125;距现在的已过时间</span><br><span class="line"> * @param  &#123;Date&#125; startTime </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function formatPassTime(startTime) &#123;</span><br><span class="line">    var currentTime = Date.parse(new Date()),</span><br><span class="line">        time = currentTime - startTime,</span><br><span class="line">        day = parseInt(time / (1000 * 60 * 60 * 24)),</span><br><span class="line">        hour = parseInt(time / (1000 * 60 * 60)),</span><br><span class="line">        min = parseInt(time / (1000 * 60)),</span><br><span class="line">        month = parseInt(day / 30),</span><br><span class="line">        year = parseInt(month / 12);</span><br><span class="line">    if (year) return year + &quot;年前&quot;</span><br><span class="line">    if (month) return month + &quot;个月前&quot;</span><br><span class="line">    if (day) return day + &quot;天前&quot;</span><br><span class="line">    if (hour) return hour + &quot;小时前&quot;</span><br><span class="line">    if (min) return min + &quot;分钟前&quot;</span><br><span class="line">    else return &#x27;刚刚&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   格式化现在距$&#123;endTime&#125;的剩余时间</span><br><span class="line"> * @param  &#123;Date&#125; endTime  </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function formatRemainTime(endTime) &#123;</span><br><span class="line">    var startDate = new Date(); //开始时间</span><br><span class="line">    var endDate = new Date(endTime); //结束时间</span><br><span class="line">    var t = endDate.getTime() - startDate.getTime(); //时间差</span><br><span class="line">    var d = 0,</span><br><span class="line">        h = 0,</span><br><span class="line">        m = 0,</span><br><span class="line">        s = 0;</span><br><span class="line">    if (t &gt;= 0) &#123;</span><br><span class="line">        d = Math.floor(t / 1000 / 3600 / 24);</span><br><span class="line">        h = Math.floor(t / 1000 / 60 / 60 % 24);</span><br><span class="line">        m = Math.floor(t / 1000 / 60 % 60);</span><br><span class="line">        s = Math.floor(t / 1000 % 60);</span><br><span class="line">    &#125;</span><br><span class="line">    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h3 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   url参数转对象</span><br><span class="line"> * @param  &#123;String&#125; url  default: window.location.href</span><br><span class="line"> * @return &#123;Object&#125; </span><br><span class="line"> */</span><br><span class="line">function parseQueryString(url) &#123;</span><br><span class="line">    url = url == null ? window.location.href : url</span><br><span class="line">    var search = url.substring(url.lastIndexOf(&#x27;?&#x27;) + 1)</span><br><span class="line">    if (!search) &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.parse(&#x27;&#123;&quot;&#x27; + decodeURIComponent(search).replace(/&quot;/g, &#x27;\\&quot;&#x27;).replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;).replace(/=/g, &#x27;&quot;:&quot;&#x27;) + &#x27;&quot;&#125;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   对象序列化</span><br><span class="line"> * @param  &#123;Object&#125; obj </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function stringfyQueryString(obj) &#123;</span><br><span class="line">    if (!obj) return &#x27;&#x27;;</span><br><span class="line">    var pairs = [];</span><br><span class="line"></span><br><span class="line">    for (var key in obj) &#123;</span><br><span class="line">        var value = obj[key];</span><br><span class="line"></span><br><span class="line">        if (value instanceof Array) &#123;</span><br><span class="line">            for (var i = 0; i &lt; value.length; ++i) &#123;</span><br><span class="line">                pairs.push(encodeURIComponent(key + &#x27;[&#x27; + i + &#x27;]&#x27;) + &#x27;=&#x27; + encodeURIComponent(value[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pairs.push(encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(obj[key]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pairs.join(&#x27;&amp;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h3 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc   函数节流。</span><br><span class="line"> * 适用于限制`resize`和`scroll`等函数的调用频率</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;Number&#125;    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。</span><br><span class="line"> * @param  &#123;Boolean&#125;   noTrailing     可选，默认为false。</span><br><span class="line"> *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。</span><br><span class="line"> *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.</span><br><span class="line"> *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）</span><br><span class="line"> * @param  &#123;Function&#125;  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，</span><br><span class="line"> *                                    执行去节流功能时，调用`callback`。</span><br><span class="line"> * @param  &#123;Boolean&#125;   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。</span><br><span class="line"> *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;Function&#125;  新的节流函数</span><br><span class="line"> */</span><br><span class="line">function throttle(delay, noTrailing, callback, debounceMode) &#123;</span><br><span class="line"></span><br><span class="line">    // After wrapper has stopped being called, this timeout ensures that</span><br><span class="line">    // `callback` is executed at the proper times in `throttle` and `end`</span><br><span class="line">    // debounce modes.</span><br><span class="line">    var timeoutID;</span><br><span class="line"></span><br><span class="line">    // Keep track of the last time `callback` was executed.</span><br><span class="line">    var lastExec = 0;</span><br><span class="line"></span><br><span class="line">    // `noTrailing` defaults to falsy.</span><br><span class="line">    if (typeof noTrailing !== &#x27;boolean&#x27;) &#123;</span><br><span class="line">        debounceMode = callback;</span><br><span class="line">        callback = noTrailing;</span><br><span class="line">        noTrailing = undefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The `wrapper` function encapsulates all of the throttling / debouncing</span><br><span class="line">    // functionality and when executed will limit the rate at which `callback`</span><br><span class="line">    // is executed.</span><br><span class="line">    function wrapper() &#123;</span><br><span class="line"></span><br><span class="line">        var self = this;</span><br><span class="line">        var elapsed = Number(new Date()) - lastExec;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        // Execute `callback` and update the `lastExec` timestamp.</span><br><span class="line">        function exec() &#123;</span><br><span class="line">            lastExec = Number(new Date());</span><br><span class="line">            callback.apply(self, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If `debounceMode` is true (at begin) this is used to clear the flag</span><br><span class="line">        // to allow future `callback` executions.</span><br><span class="line">        function clear() &#123;</span><br><span class="line">            timeoutID = undefined;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (debounceMode &amp;&amp; !timeoutID) &#123;</span><br><span class="line">            // Since `wrapper` is being called for the first time and</span><br><span class="line">            // `debounceMode` is true (at begin), execute `callback`.</span><br><span class="line">            exec();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Clear any existing timeout.</span><br><span class="line">        if (timeoutID) &#123;</span><br><span class="line">            clearTimeout(timeoutID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) &#123;</span><br><span class="line">            // In throttle mode, if `delay` time has been exceeded, execute</span><br><span class="line">            // `callback`.</span><br><span class="line">            exec();</span><br><span class="line"></span><br><span class="line">        &#125; else if (noTrailing !== true) &#123;</span><br><span class="line">            // In trailing throttle mode, since `delay` time has not been</span><br><span class="line">            // exceeded, schedule `callback` to execute `delay` ms after most</span><br><span class="line">            // recent execution.</span><br><span class="line">            //</span><br><span class="line">            // If `debounceMode` is true (at begin), schedule `clear` to execute</span><br><span class="line">            // after `delay` ms.</span><br><span class="line">            //</span><br><span class="line">            // If `debounceMode` is false (at end), schedule `callback` to</span><br><span class="line">            // execute after `delay` ms.</span><br><span class="line">            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return the wrapper function.</span><br><span class="line">    return wrapper;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 函数防抖 </span><br><span class="line"> * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，</span><br><span class="line"> * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。</span><br><span class="line"> * @example 适用场景：如在线编辑的自动存储防抖。</span><br><span class="line"> * @param  &#123;Number&#125;   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。</span><br><span class="line"> * @param  &#123;Boolean&#125;  atBegin       可选，默认为false。</span><br><span class="line"> *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。</span><br><span class="line">                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行</span><br><span class="line"> * @param  &#123;Function&#125; callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，</span><br><span class="line"> *                                  执行去抖动功能时，，调用`callback`。</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;Function&#125; 新的防抖函数。</span><br><span class="line"> */</span><br><span class="line">var throttle = require(&#x27;./throttle&#x27;);</span><br><span class="line">function debounce(delay, atBegin, callback) &#123;</span><br><span class="line">    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p><p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持<strong>按需引入</strong>吧</p><h2 id="1-目录结构说明"><a href="#1-目录结构说明" class="headerlink" title="1.目录结构说明"></a>1.目录结构说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">│  .babelrc</span><br><span class="line">│  .gitignore</span><br><span class="line">│  .travis.yml</span><br><span class="line">│  LICENSE</span><br><span class="line">│  package.json</span><br><span class="line">│  README.md</span><br><span class="line">│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载</span><br><span class="line">│  setScrollTop.js</span><br><span class="line">│  stringfyQueryString.js</span><br><span class="line">│   ...</span><br><span class="line">│   ...</span><br><span class="line">│  </span><br><span class="line">├─min</span><br><span class="line">│      outils.min.js  // 所有函数统一打包生成的全量压缩包</span><br><span class="line">│      </span><br><span class="line">├─script  // 本项目开发脚本目录</span><br><span class="line">│      build.js  // 打包构建脚本</span><br><span class="line">│      test.js  // 测试脚本</span><br><span class="line">│      webpack.conf.js  // webpack打包配置文件</span><br><span class="line">│      </span><br><span class="line">├─src // 源码目录</span><br><span class="line">│  │  index.js  // webpack入口文件</span><br><span class="line">│  │  </span><br><span class="line">│  ├─array</span><br><span class="line">│  │      </span><br><span class="line">│  ├─class</span><br><span class="line">│  │      </span><br><span class="line">│  ├─cookie</span><br><span class="line">│  │      </span><br><span class="line">│  ├─device</span><br><span class="line">│  │      </span><br><span class="line">│  ├─dom</span><br><span class="line">│  │      </span><br><span class="line">│  ├─keycode</span><br><span class="line">│  │      </span><br><span class="line">│  ├─object</span><br><span class="line">│  │      </span><br><span class="line">│  ├─random</span><br><span class="line">│  │      </span><br><span class="line">│  ├─regexp</span><br><span class="line">│  │      </span><br><span class="line">│  ├─string</span><br><span class="line">│  │      </span><br><span class="line">│  ├─support</span><br><span class="line">│  │      </span><br><span class="line">│  ├─time</span><br><span class="line">│  │      </span><br><span class="line">│  └─url</span><br><span class="line">│          </span><br><span class="line">└─test // 测试用例目录</span><br><span class="line">    │  array.test.js</span><br><span class="line">    │  class.test.js</span><br><span class="line">    │  cookie.test.js</span><br><span class="line">    │  device.test.js</span><br><span class="line">    │  dom.test.js</span><br><span class="line">    │  index.html</span><br><span class="line">    │  keycode.test.js</span><br><span class="line">    │  object.test.js</span><br><span class="line">    │  random.test.js</span><br><span class="line">    │  regexp.test.js</span><br><span class="line">    │  string.test.js</span><br><span class="line">    │  support.test.js</span><br><span class="line">    │  time.test.js</span><br><span class="line">    │  url.test.js</span><br><span class="line">    │  </span><br><span class="line">    └─_lib // 测试所用到的第三方库</span><br><span class="line">            mocha.css</span><br><span class="line">            mocha.js</span><br><span class="line">            power-assert.js </span><br></pre></td></tr></table></figure><h2 id="2-构建脚本"><a href="#2-构建脚本" class="headerlink" title="2.构建脚本"></a>2.构建脚本</h2><p>这里主要说明一下项目中<a href="https://github.com/proYang/outils/blob/master/script/build.js"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">// 删除旧的全量压缩包</span><br><span class="line">rm(path.resolve(rootPath, &#x27;min&#x27;, `$&#123;pkg.name&#125;.min.js`), err =&gt; &#123;</span><br><span class="line">    if (err) throw (err)</span><br><span class="line">    webpack(config, function (err, stats) &#123;</span><br><span class="line">        if (err) throw (err)</span><br><span class="line">        building.stop()</span><br><span class="line">        process.stdout.write(stats.toString(&#123;</span><br><span class="line">            colors: true,</span><br><span class="line">            modules: false,</span><br><span class="line">            children: false,</span><br><span class="line">            chunks: false,</span><br><span class="line">            chunkModules: false</span><br><span class="line">        &#125;) + &#x27;\n\n&#x27;)</span><br><span class="line">        resolve()</span><br><span class="line">        console.log(chalk.cyan(&#x27;  Build complete.\n&#x27;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 替换模块文件</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    // 先删除根目录中之前的函数模块</span><br><span class="line">    rm(&#x27;*.js&#x27;, err =&gt; &#123;</span><br><span class="line">        if (err) throw (err)</span><br><span class="line">        let folderList = fs.readdirSync(path.resolve(rootPath, &#x27;src&#x27;))</span><br><span class="line">        folderList.forEach((item, index) =&gt; &#123;</span><br><span class="line">            // 拷贝`src`下面一层目录的所有`js`文件至根目录</span><br><span class="line">            copy(`src/$&#123;item&#125;/*.js`, rootPath, function (err, files) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                if (index === folderList.length - 1) &#123;</span><br><span class="line">                    console.log(chalk.cyan(&#x27;  Copy complete.\n&#x27;))</span><br><span class="line">                    copying.stop()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="3-书写测试用例"><a href="#3-书写测试用例" class="headerlink" title="3.书写测试用例"></a>3.书写测试用例</h2><p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p><p>但是因为时间关系，本项目暂时通过项目中的<a href="https://github.com/proYang/outils/blob/master/script/test.js"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p><p>这里给大家推荐一个好用的断言库<a href="https://www.npmjs.com/package/power-assert"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p><p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p><blockquote><p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://travis-ci.org/"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://github.com/proYang/outils/blob/master/.travis.yml"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://github.com/proYang/outils/blob/master/script/karma.conf.js"> karma.conf.js </a>。</p></blockquote><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://github.com/proYang/outils/">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p><h3 id="1-添加自己的函数"><a href="#1-添加自己的函数" class="headerlink" title="1.添加自己的函数"></a>1.添加自己的函数</h3><p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否NaN</span><br><span class="line"> * @param  &#123;Any&#125; value </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isNaN(value) &#123;    </span><br><span class="line">    return value !== value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">modules.export = isNaN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后记得在<code>src/index.js</code>文件中暴露<code>isNaN</code>函数</p><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><p>在<code>test</code>文件新建测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;#isNaN()&#x27;, function () &#123;</span><br><span class="line">    it(`outils.isNaN(NaN) should return true`, function () &#123;</span><br><span class="line">        assert(outils.isNaN(NaN))</span><br><span class="line">    &#125;)</span><br><span class="line">    it(`outils.isNaN(&#x27;value&#x27;) should return false`, function () &#123;</span><br><span class="line">        assert.notEqual(outils.isNaN(NaN))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><del>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</del></p><h3 id="3-测试并打包"><a href="#3-测试并打包" class="headerlink" title="3.测试并打包"></a>3.测试并打包</h3><p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p><h3 id="4-发布到npm"><a href="#4-发布到npm" class="headerlink" title="4.发布到npm"></a>4.发布到<code>npm</code></h3><p>在<a href="https://www.npmjs.com/"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://www.npmjs.com/"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1.浏览器"></a>1.浏览器</h3><p>直接下载<code>min</code>目录下的<a href="https://github.com/proYang/outils/blob/master/min/outils.min.js"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var OS = outils.getOS()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://github.com/proYang/outils/releases"> github Release </a>页面下载对应版本号的代码。</p><h3 id="2-Webpack、RequireJS、SeaJS等模块加载器"><a href="#2-Webpack、RequireJS、SeaJS等模块加载器" class="headerlink" title="2.Webpack、RequireJS、SeaJS等模块加载器"></a>2.Webpack、RequireJS、SeaJS等模块加载器</h3><p>先使用<code>npm</code>安装<code>outils</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev outils</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 完整引入</span><br><span class="line">const outils = require(&#x27;outils&#x27;)</span><br><span class="line">const OS = outils.getOS()</span><br></pre></td></tr></table></figure><p><strong>推荐使用方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 按需引入require(&#x27;outils/&lt;方法名&gt;&#x27;)</span><br><span class="line">const getOS = require(&#x27;outils/getOS&#x27;)</span><br><span class="line">const OS = getOS()</span><br></pre></td></tr></table></figure><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import getOS from &#x27;outils/getOS&#x27;</span><br><span class="line">// 或</span><br><span class="line">import &#123; getOS &#125; from &quot;outils&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工欲善其事必先利其器。有了属于自己的这把利器，希望加班也会变成奢望。O(∩_∩)O哈哈~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器技巧总结</title>
      <link href="/2017/12/03/%E5%B7%A5%E5%85%B7/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/03/%E5%B7%A5%E5%85%B7/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单介绍一些chrome浏览器的小技巧</p></blockquote><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>快捷键比较多，这里挑出几个常用的说一下<br>最后会给出一张比较完整的快捷键的表</p><p>下列快捷键可以在所有 开发者工具 面板中可以使用</p><table><thead><tr><th>全局快捷键</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>打开 开发者工具</td><td>F12、Ctrl+Shift+I</td><td>Cmd+Opt+I</td></tr><tr><td>打开 开发者工具 并聚焦到控制台</td><td>Ctrl+Shift+J</td><td>Cmd+Shift+C</td></tr><tr><td>刷新页面</td><td>F5、Ctrl+R</td><td>Cmd+R</td></tr><tr><td>刷新忽略缓存内容的页面</td><td>Ctrl+F5、Ctrl+Shift+R</td><td>Cmd+Shift+R</td></tr></tbody></table><hr><p><strong>在Elements 面板中使用的快捷键</strong></p><table><thead><tr><th>Elements 面板</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>编辑属性</td><td>Enter、双击属性</td><td>Enter、双击属性</td></tr><tr><td>隐藏元素</td><td>H</td><td>H</td></tr><tr><td>切换为以HTML形式编辑</td><td>F2</td><td></td></tr></tbody></table><hr><p><strong>在Styles 边栏中使用的快捷键</strong></p><table><thead><tr><th>Styles 边栏</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>转到源中属性值声明行</td><td>Ctrl+点击属性值</td><td>CMd+点击属性值</td></tr><tr><td>在颜色定义值之间循环</td><td>Shift+点击颜色选取器框</td><td>Shift+点击颜色选取器框</td></tr><tr><td>编辑下一个&#x2F;上一个属性</td><td>Tab、Tab+Shift</td><td>Tab、Tab+Shift</td></tr></tbody></table><hr><p><strong>在控制台中使用的快捷键</strong></p><table><thead><tr><th>控制台</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>聚焦到控制台</td><td>Ctrl+&#96;</td><td>Ctrl+&#96;</td></tr><tr><td>清除控制台</td><td>Ctrl+L</td><td>Cmd+K、Opt+L</td></tr><tr><td>多行输入</td><td>Shift+Enter</td><td>Ctrl+Return</td></tr></tbody></table><h3 id="区域截屏"><a href="#区域截屏" class="headerlink" title="区域截屏"></a>区域截屏</h3><p>选取页面中的一部分，保存为图片<br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4uq956h4j20lv0bxt9p.jpg"></p><p>2、选择左上角的元素选择按钮，图标颜色变为蓝色即表示选中了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vhn5xepj207h04l3yi.jpg"></p><p>3、Windows 下按住 Ctrl，Mac 就按住 Command，然后点击鼠标左键在页面选择区域即可，松开鼠标后，截图自动下载。</p><p>4、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示 </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4viypbwuj20bl094mxp.jpg"></p><h3 id="节点截图"><a href="#节点截图" class="headerlink" title="节点截图"></a>节点截图</h3><p>选中页面中某一元素，保存为图片<br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、选中任意元素节点<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vl692wlj20fb04vmxc.jpg"></p><p>3、打开命令工具<br>使用快捷键 Ctrl + Shift + p (Windows) 或 Cmd + Shift + p (Mac)<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vmbp1t0j20fs093q3a.jpg"></p><p>4、点击Capture node screenshot，或者输入这行中任意的关键字，比如输入node，也会出来这个选项，然后点击这个选项，图片会自动下载。<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vmwcwm6j20er04fjrd.jpg"></p><p>5、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示</p><h3 id="截全屏"><a href="#截全屏" class="headerlink" title="截全屏"></a>截全屏</h3><p>保存完整网页为图片<br><strong>第一种方式</strong><br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、打开命令工具<br>使用快捷键 Ctrl + Shift + p (Windows) 或 Cmd + Shift + p (Mac) </p><p>3、点击Capture full size screenshot，或者输入这行中任意的关键字，比如输入full，也会出来这个选项<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vnpqtg4j20ej032q2t.jpg"></p><p>4、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示 </p><p><strong>第二种方式</strong><br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、选中 切换开发模式按钮，图标颜色变为蓝色即表示选中了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4votroz4j206j03wweg.jpg"></p><p>3、点右上方的三个 小点，点击Capture full size screenshot，图片会自动下载<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vp9m0pmj20kz08rt9o.jpg"></p><h3 id="拾色器"><a href="#拾色器" class="headerlink" title="拾色器"></a>拾色器</h3><p>在Styles边栏 点击任意颜色的小色块，就可以弹出颜色选择器<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vppvghkj207s079jri.jpg"><br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vq9x3fbj20m80f679a.jpg"><br>1、颜色选择区域。<br>2、吸管。<br>3、复制到剪贴板。将显示值复制到剪贴板。<br>4、显示值。颜色的RGBA，HSLA或十六进制表示。<br>5、调色板。单击其中一个方块将颜色更改为该方块。<br>6、色相。<br>7、透明度。<br>8、显示值切换器。在当前颜色的RGBA，HSLA和Hex表示之间切换。<br>9、调色板切换器。</p><h3 id="快速添加样式规则"><a href="#快速添加样式规则" class="headerlink" title="快速添加样式规则"></a>快速添加样式规则</h3><p>1、在Styles 边栏，鼠标放在每一小块样式规则上，右下方都会有三个小点<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vqjn4ulj20d3087aad.jpg"></p><p>2、鼠标放在这三个小点上，会出现5个小图标，每个小图标都有作用<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vt1zf7wj20cc03vglm.jpg"></p><p>3、他们从左到右分别代表</p><ul><li>添加 text-shadow</li><li>添加 box-shadow</li><li>添加 color</li><li>添加 background-color</li><li>插入样式规则</li></ul><h3 id="增加移动设备"><a href="#增加移动设备" class="headerlink" title="增加移动设备"></a>增加移动设备</h3><p>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、点击右上方的三个小点，然后选择Settings<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vqx6nwoj20m8075gn3.jpg"></p><p>3、选择Devices，然后在需要添加的设备前面打上勾就可以了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vthr10cj20e109jglu.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些小技巧，很简单，希望对大家有所帮助，不过对于有办法，有时间的朋友还是建议去官网看看吧，毕竟那里才更加全面。<br><a href="http://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">Chrome 开发者工具</a></p><p><a href="http://img.blog.csdn.net/20171122155304242">点击查看具体图片</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome 效率插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡相关总结</title>
      <link href="/2017/11/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>先理解一下所谓的“均衡”</p><p>不能狭义地理解为分配给所有实际服务器一样多的工作量，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程序地发挥作用。</p><h1 id="一、http重定向"><a href="#一、http重定向" class="headerlink" title="一、http重定向"></a>一、http重定向</h1><p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p><p>性能缺陷：</p><p>1、吞吐率限制</p><p>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs&#x2F;s，那么主服务器的吞吐率要达到3000reqs&#x2F;s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs&#x2F;s，那么平均分配到子服务器的吞吐率为2000reqs&#x2F;s，而现子服务器的最大吞吐率为1000reqs&#x2F;s，因此就得增加子服务器的数量，增加到6个才能满足。</p><p>2、重定向访问深度不同</p><p>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</p><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><h1 id="二、DNS负载均衡"><a href="#二、DNS负载均衡" class="headerlink" title="二、DNS负载均衡"></a>二、DNS负载均衡</h1><p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p><p>使用dig命令来看下”baidu”的DNS设置</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/205913_PgDS_3341316.jpg" alt="img"></p><p>可见baidu拥有三个A记录</p><p>相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。</p><p>特性:</p><p>1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</p><p>2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</p><p>不足：</p><p>1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</p><p>2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</p><p>3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</p><p>4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</p><p>5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</p><h1 id="三、反向代理负载均衡"><a href="#三、反向代理负载均衡" class="headerlink" title="三、反向代理负载均衡"></a>三、反向代理负载均衡</h1><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。</p><p>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p><p>1、任何对于实际服务器的HTTP请求都必须经过调度器</p><p>2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</p><p>特性：</p><p>1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</p><p>2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</p><p>3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</p><p>4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</p><p>5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</p><h1 id="四、IP负载均衡-LVS-NAT"><a href="#四、IP负载均衡-LVS-NAT" class="headerlink" title="四、IP负载均衡(LVS-NAT)"></a>四、IP负载均衡(LVS-NAT)</h1><p>因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？</p><p>NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。</p><p>从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，<a href="http://lib.csdn.net/base/linux">Linux</a>提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。</p><p>想知道你的服务器内核是否已经安装了IPVS模块，可以</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/211529_WLOE_3341316.jpg" alt="img"></p><p>有输出意味着IPVS已经安装了。IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。</p><p>1、打开调度器的数据包转发选项</p><p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</p><p>2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加</p><p>route add default gw xx.xx.xx.xx</p><p>3、使用ipvsadm配置</p><p>ipvsadm -A -t 111.11.11.11:80 -s rr  </p><p>添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等）</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m  </p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m  </p><p>添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包</p><p>运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。</p><p>实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一睦开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然如果你不差钱，可以去花钱去购买千兆交换机或万兆交换机，甚至负载均衡硬件设备，但如果你是个屌丝，咋办？</p><p>一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><h1 id="五、直接路由-LVS-DR"><a href="#五、直接路由-LVS-DR" class="headerlink" title="五、直接路由(LVS-DR)"></a>五、直接路由(LVS-DR)</h1><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>1、网络设置</p><p>这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。</p><p>2、将ip别名添加到回环接口lo上</p><p>这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行：</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/211643_3QOL_3341316.jpg" alt="img"></p><p>另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行：</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore</p><p>echo “2” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce</p><p>配置完了就可以使用ipvsadm配置LVS-DR集群了</p><p>ipvsadm -A -t 10.10.120.193:80 -s rr  </p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g  </p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g  </p><p>-g 就意味着使用直接路由的方式转发数据包</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><h1 id="六、IP隧道-LVS-TUN"><a href="#六、IP隧道-LVS-TUN" class="headerlink" title="六、IP隧道(LVS-TUN)"></a>六、IP隧道(LVS-TUN)</h1><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的ip命令总结</title>
      <link href="/2017/11/22/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20linux%E7%9A%84ip%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/22/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20linux%E7%9A%84ip%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://linux.cn/">Linux中国</a> <a href="https://linux.cn/article-3144-1.html">https://linux.cn/article-3144-1.html</a><br>地址：<a href="https://linux.cn/article-3144-1.html">https://linux.cn/article-3144-1.html</a></p><p>linux的<strong>ip</strong>命令和<strong>ifconfig</strong>类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003404uy9l1t5zayzllylm.png" alt="Net tools vs Iproute2"></p><p><em>Net tools vs Iproute2</em></p><p>要安装ip，请<a href="http://www.linuxgrill.com/anonymous/iproute2/NEW-OSDL/">点击这里</a>下载<strong>iproute2套装工具</strong> 。不过，大多数Linux发行版已经预装了iproute2工具。</p><p>你也可以使用git命令来下载最新源代码来编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://kernel.googlesource.com/pub/scm/linux/kernel/git/shemminger/iproute2.git</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003410tpix2804k660lwu4.png" alt="iproute2 git clone"></p><p><em>iproute2 git clone</em></p><h3 id="设置和删除Ip地址"><a href="#设置和删除Ip地址" class="headerlink" title="设置和删除Ip地址"></a>设置和删除Ip地址</h3><p>要给你的机器设置一个IP地址，可以使用下列ip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip addr add 192.168.0.193/24 dev wlan0</span><br></pre></td></tr></table></figure><p>请注意IP地址要有一个后缀，比如&#x2F;24。这种用法用于在无类域内路由选择（CIDR）中来显示所用的子网掩码。在这个例子中，子网掩码是255.255.255.0。</p><p>在你按照上述方式设置好IP地址后，需要查看是否已经生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show wlan0</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003411qp4xsem5491ee49t.png" alt="set ip address"></p><p><em>set ip address</em></p><p>你也可以使用相同的方式来删除IP地址，只需用del代替add。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip addr del 192.168.0.193/24 dev wlan0</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003412dottfn0jnidyykd2.png" alt="delete ip address"></p><p><em>delete ip address</em></p><h3 id="列出路由表条目"><a href="#列出路由表条目" class="headerlink" title="列出路由表条目"></a>列出路由表条目</h3><p>ip命令的路由对象的参数还可以帮助你查看网络中的路由数据，并设置你的路由表。第一个条目是默认的路由条目，你可以随意改动它。</p><p>在这个例子中，有几个路由条目。这个结果显示有几个设备通过不同的网络接口连接起来。它们包括WIFI、以太网和一个点对点连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003413mnehm4uinhziu287.png" alt="ip route show"></p><p><em>ip route show</em></p><p>假设现在你有一个IP地址，你需要知道路由包从哪里来。可以使用下面的路由选项（译注：列出了路由所使用的接口等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route get 10.42.0.47</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003414h53e34qwjfo34emm.png" alt="ip route get"></p><p><em>ip route get</em></p><h3 id="更改默认路由"><a href="#更改默认路由" class="headerlink" title="更改默认路由"></a>更改默认路由</h3><p>要更改默认路由，使用下面ip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip route add default via 192.168.0.196</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003415i8d82ulsa4c4jcd4.png" alt="default route"></p><p><em>default route</em></p><h3 id="显示网络统计数据"><a href="#显示网络统计数据" class="headerlink" title="显示网络统计数据"></a>显示网络统计数据</h3><p>使用ip命令还可以显示不同网络接口的统计数据。</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003417l1jc4h5537m050wy.png" alt="ip statistics all interfaces"></p><p><em>ip statistics all interfaces</em></p><p>当你需要获取一个特定网络接口的信息时，在网络接口名字后面添加选项<strong>ls</strong>即可。使用多个选项**-s**会给你这个特定接口更详细的信息。特别是在排除网络连接故障时，这会非常有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip -s -s link ls p2p1</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003418acoo0krhjellollu.png" alt="ip link statistics"></p><p><em>ip link statistics</em></p><h3 id="ARP条目"><a href="#ARP条目" class="headerlink" title="ARP条目"></a>ARP条目</h3><p>地址解析协议（ARP）用于将一个IP地址转换成它对应的物理地址，也就是通常所说的MAC地址。使用ip命令的neigh或者neighbour选项，你可以查看接入你所在的局域网的设备的MAC地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip neighbour</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003419uzm96tbvujb5bvqe.png" alt="ip neighbour"></p><p><em>ip neighbour</em></p><h3 id="监控netlink消息"><a href="#监控netlink消息" class="headerlink" title="监控netlink消息"></a>监控netlink消息</h3><p>也可以使用ip命令查看netlink消息。monitor选项允许你查看网络设备的状态。比如，所在局域网的一台电脑根据它的状态可以被分类成REACHABLE或者STALE。使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip monitor all</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003420ap2j3jjvjk3jvvoo.png" alt="ip monitor all"></p><p><em>ip monitor all</em></p><h3 id="激活和停止网络接口"><a href="#激活和停止网络接口" class="headerlink" title="激活和停止网络接口"></a>激活和停止网络接口</h3><p>你可以使用ip命令的up和down选项来激某个特定的接口，就像ifconfig的用法一样。</p><p>在这个例子中，当ppp0接口被激活和在它被停止和再次激活之后，你可以看到相应的路由表条目。这个接口可能是wlan0或者eth0。将ppp0更改为你可用的任意接口即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip link set ppp0 down $ sudo ip link set ppp0 up</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003421mdudvkazcgkl6g8d.png" alt="ip link set up and down"></p><p><em>ip link set up and down</em></p><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>当你陷入困境，不知道某一个特定的选项怎么用的时候，你可以使用help选项。man页面并不会提供许多关于如何使用ip选项的信息，因此这里就是获取帮助的地方。</p><p>比如，想知道关于route选项更多的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route help</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003422xh9xm2wihecdjhif.png" alt="ip route help"></p><p><em>ip route help</em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于网络管理员们和所有的Linux使用者们，ip命令是必备工具。是时候抛弃ifconfig命令了，特别是当你写脚本时。</p><hr><p>via: <a href="http://linoxide.com/linux-command/use-ip-command-linux/">http://linoxide.com/linux-command/use-ip-command-linux/</a></p><h2 id="译者：KayGuoWhu-校对：wxy"><a href="#译者：KayGuoWhu-校对：wxy" class="headerlink" title="译者：KayGuoWhu 校对：wxy"></a>译者：<a href="https://github.com/KayGuoWhu">KayGuoWhu</a> 校对：<a href="https://github.com/wxy">wxy</a></h2><p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a href="https://linux.cn/article-3144-1.html">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中list的排序</title>
      <link href="/2017/11/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E4%B8%ADlist%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/11/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E4%B8%ADlist%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里先简单总结下python中排序的用法</p></blockquote><p>python内置的排序函数主要有两个： <code>sort</code> 和 <code>sorted</code></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>sort只能对list排序，sorted可以对list, tuple, dist 以及自定义的类型进行排序</li><li>sort是在原有list上作操作，sorted 不会修改原来的数据结构，而是返回新的list （注意：对tuple排序只能用sorted）</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>1.sort</p><p>参数：reverse，key，cmp</p><pre><code>&gt;&gt;&gt; a = [5,4,6,7,9,1,2]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; print(a)[1, 2, 4, 5, 6, 7, 9]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; print(a)[9, 7, 6, 5, 4, 2, 1]&gt;&gt;&gt;  </code></pre><p>2.sorted</p><ul><li>sorted(data, cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)</li></ul><p>reverse True 从大到小，False 从小到大</p><p>从网上收集到demo，这里直接用下～</p><pre><code>&gt;&gt;&gt; b = [&#39;aa&#39;,&#39;BB&#39;,&#39;bb&#39;,&#39;zz&#39;,&#39;CC&#39;] &gt;&gt;&gt; sorted(b) [&#39;BB&#39;, &#39;CC&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;zz&#39;]    #按列表中元素每个字母的ascii码从小到大排序,如果要从大到小,请用sorted(b,reverse=True)下同  &gt;&gt;&gt; c =[&#39;CCC&#39;, &#39;bb&#39;, &#39;ffff&#39;, &#39;z&#39;]  &gt;&gt;&gt; sorted(c,key=len)             #按列表的元素的长度排序 [&#39;z&#39;, &#39;bb&#39;, &#39;CCC&#39;, &#39;ffff&#39;]  &gt;&gt;&gt; d =[&#39;CCC&#39;, &#39;bb&#39;, &#39;ffff&#39;, &#39;z&#39;] &gt;&gt;&gt; sorted(d,key = str.lower )    #将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 [&#39;bb&#39;, &#39;CCC&#39;, &#39;ffff&#39;, &#39;z&#39;]  &gt;&gt;&gt; def lastchar(s):        return s[-1] &gt;&gt;&gt; e = [&#39;abc&#39;,&#39;b&#39;,&#39;AAz&#39;,&#39;ef&#39;] &gt;&gt;&gt; sorted(e,key = lastchar)      #自定义函数排序,lastchar为函数名，这个函数返回列表e中每个元素的最后一个字母 [&#39;b&#39;, &#39;abc&#39;, &#39;ef&#39;, &#39;AAz&#39;]         #sorted(e,key=lastchar)作用就是 按列表e中每个元素的最后一个字母的ascii码从小到大排序  &gt;&gt;&gt; f = [&#123;&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:20&#125;,&#123;&#39;name&#39;:&#39;def&#39;,&#39;age&#39;:30&#125;,&#123;&#39;name&#39;:&#39;ghi&#39;,&#39;age&#39;:25&#125;]     #列表中的元素为字典 &gt;&gt;&gt; def age(s):        return s[&#39;age&#39;] &gt;&gt;&gt; ff = sorted(f,key = age)      #自定义函数按列表f中字典的age从小到大排序   [&#123;&#39;age&#39;: 20, &#39;name&#39;: &#39;abc&#39;&#125;, &#123;&#39;age&#39;: 25, &#39;name&#39;: &#39;ghi&#39;&#125;, &#123;&#39;age&#39;: 30, &#39;name&#39;: &#39;def&#39;&#125;]  &gt;&gt;&gt; f2 = sorted(f,key = lambda x:x[&#39;age&#39;])    #如果觉得上面定义一个函数代码不美观，可以用lambda的形式来定义函数,效果同上 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS安装docker启动失败</title>
      <link href="/2017/11/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%AE%89%E8%A3%85docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"/>
      <url>/2017/11/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%AE%89%E8%A3%85docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在自己的测试服务器装起了docker，安装成功，but，启动失败了，解决后，在此记录下～</p></blockquote><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><pre><code> [root@fantasykai ~]# uname -r 3.10.0-514.26.2.el7.x86_64 [root@fantasykai ~]# lsb_release -a LSB Version::core-4.1-amd64:core-4.1-noarch Distributor ID:CentOS Description:CentOS Linux release 7.3.1611 (Core) Release:7.3.1611 Codename:Core</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code>yum -y install docker</code></pre><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><blockquote><p>启动报错：</p></blockquote><pre><code>[root@fantasykai ~]# service docder startRedirecting to /bin/systemctl start  docder.serviceFailed to start docder.service: Unit not found.</code></pre><h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><p>新建一个docker.socket 文件</p><p>vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket</p><pre><code>[Unit]Description=Docker Socket for the APIPartOf=docker.service[Socket]ListenStream=/var/run/docker.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.target</code></pre><p>然后运行</p><pre><code>systemctl daemon-reloadsystemctl start docker.socketsystemctl start docker</code></pre><p> OK，启动好了，可以在愉快的玩耍了～</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步github上fork的分支</title>
      <link href="/2017/10/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%90%8C%E6%AD%A5github%E4%B8%8Afork%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2017/10/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%90%8C%E6%AD%A5github%E4%B8%8Afork%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>github 上fork 大牛的持续更新的项目，一段时间后，想把大牛提交的部分，更新到自己fork出来的项目上，为此google一把，了然于心，在此记录下~</p></blockquote><p>实现这个需求，发现有2种玩法：</p><ul><li>Github 上点点就行</li><li>使用命令行的方式同步</li></ul><h3 id="在Github-页面上点击完成"><a href="#在Github-页面上点击完成" class="headerlink" title="在Github 页面上点击完成"></a>在Github 页面上点击完成</h3><p> 看图有真相！</p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lm22286j21ly0q6jz3.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1ln40g4nj21li0l4tdm.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lncoxarj21r40smtfg.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lnkj5wrj21cm0yqagu.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lnqrersj21a20a2gnp.jpg"></p><h3 id="使用命令行方式同步"><a href="#使用命令行方式同步" class="headerlink" title="使用命令行方式同步"></a>使用命令行方式同步</h3><blockquote><p>怎么不了解命令行到方式呢～</p></blockquote><h4 id="1-配置源项目的地址"><a href="#1-配置源项目的地址" class="headerlink" title="1.配置源项目的地址"></a>1.配置源项目的地址</h4><blockquote><p>讲fork源的项目地址配置到自己的项目上。</p></blockquote><p>举个栗子</p><p>我fork了一个项目：pyeve&#x2F;eve，我的项目地址就是 fantasykai&#x2F;eve</p><p>项目名称上会显示 <code>forked from pyeve/eve</code></p><p>git clone 自己fork的项目后，添加一个远程仓库，即 源项目地址</p><pre><code>git remote add upstream https://github.com/pyeve/eve.git</code></pre><p>执行命令行后，查看下是否配置进来    </p><pre><code>git remote -vorigingit@github.com:fantasykai/eve.git (fetch)origingit@github.com:fantasykai/eve.git (push)upstreamhttps://github.com/pyeve/eve.git (fetch)upstreamhttps://github.com/pyeve/eve.git (push)</code></pre><h4 id="2-获取源项目更新内容。"><a href="#2-获取源项目更新内容。" class="headerlink" title="2.获取源项目更新内容。"></a>2.获取源项目更新内容。</h4><blockquote><p>使用 <code>fetch</code> 命令更新，fetch 后会更新到本地分支 <code>upstream/master</code></p></blockquote><pre><code>git fetch upstream</code></pre><h4 id="3-合并本地分支。"><a href="#3-合并本地分支。" class="headerlink" title="3.合并本地分支。"></a>3.合并本地分支。</h4><blockquote><p>切换到 <code>master</code> 分支，合并<code>upstream/master</code> 分支</p></blockquote><pre><code>git merge upstream/master</code></pre><h4 id="4-提交推送"><a href="#4-提交推送" class="headerlink" title="4.提交推送"></a>4.提交推送</h4><blockquote><p>解决本地冲突的代码，然后推送之</p></blockquote><pre><code>git push origin master</code></pre><blockquote><p>这样以来，之后想同步源项目的commits，就执行2，3，4 步骤</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS内核参数优化参考</title>
      <link href="/2017/10/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/"/>
      <url>/2017/10/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS内核参数优化参考"><a href="#CentOS内核参数优化参考" class="headerlink" title="CentOS内核参数优化参考"></a>CentOS内核参数优化参考</h1><blockquote><p>最近在做性能调优，把centos相关的配置也调整了下，找到一份不错的总结，这里记录下~</p></blockquote><p>所谓Linux服务器内核参数优化，主要是指在Linux系统中针对业务服务应用而进行的系统内核参数调整，优化并无一定的标准。下面以生产环境下Linux常见的内核优化为例进行讲解，仅供参考。</p><p>参考文章：</p><p>linux内核TCP相关参数解释</p><p><a href="http://os.chinaunix.net/a2008/0918/985/000000985483.shtml">http://os.chinaunix.net/a2008/0918/985/000000985483.shtml</a></p><p>linux内核参数优化</p><p><a href="http://blog.chinaunix.net/uid-29081804-id-3830203.html">http://blog.chinaunix.net/uid-29081804-id-3830203.html</a></p><p>linux内核调整和内核参数详解</p><p><a href="http://blog.csdn.net/cnbird2008/article/details/4419354">http://blog.csdn.net/cnbird2008/article/details/4419354</a></p><p>1、linux内核参数注释</p><p><strong>说明：以下表格中红色字体为常用优化参数，根据参数文件所处目录不同而进行分表整理</strong></p><p>（1）下列文件所在目录：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;</p><table><thead><tr><th>参数名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>tcp_syn_retries</td><td>5</td><td>1</td><td>对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,由tcp_retries1决定的)</td></tr><tr><td>tcp_synack_retries</td><td>5</td><td>1</td><td>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。</td></tr><tr><td>tcp_keepalive_time</td><td>7200</td><td>600</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。防止两边建立连接但不发送数据的攻击。</td></tr><tr><td>tcp_keepalive_probes</td><td>9</td><td>3</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td></tr><tr><td>tcp_keepalive_intvl</td><td>75</td><td>15</td><td>探测消息未获得响应时，重发该消息的间隔时间（秒）。默认值为75秒。 (对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</td></tr><tr><td>tcp_retries1</td><td>3</td><td>3</td><td>是3</td></tr><tr><td>tcp_retries2</td><td>15</td><td>5</td><td>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</td></tr><tr><td>tcp_orphan_retries</td><td>7</td><td>3</td><td>在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</td></tr><tr><td>tcp_fin_timeout</td><td>60</td><td>2</td><td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。</td></tr><tr><td>tcp_max_tw_buckets</td><td>180000</td><td>36000</td><td>系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</td></tr><tr><td>tcp_tw_recycle</td><td>0</td><td>1</td><td>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</td></tr><tr><td>tcp_tw_reuse</td><td>0</td><td>1</td><td>表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</td></tr><tr><td>tcp_max_orphans</td><td>8192</td><td>32768</td><td>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</td></tr><tr><td>tcp_abort_on_overflow</td><td>0</td><td>0</td><td>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</td></tr><tr><td>tcp_syncookies</td><td>0</td><td>1</td><td>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</td></tr><tr><td>tcp_stdurg</td><td>0</td><td>0</td><td>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在Linux 打开它﹐或会导致不能和它们正确沟通。</td></tr><tr><td>tcp_max_syn_backlog</td><td>1024</td><td>16384</td><td>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include&#x2F;net&#x2F;tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE*16(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies&#x2F;Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明)</td></tr><tr><td>tcp_window_scaling</td><td>1</td><td>1</td><td>该文件表示设置tcp&#x2F;ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp&#x2F;ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp&#x2F;ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）</td></tr><tr><td>tcp_timestamps</td><td>1</td><td>1</td><td>Timestamps 用在其它一些东西中﹐可以防范那些伪造的sequence 号码。一条1G的宽带线路或许会重遇到带out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</td></tr><tr><td>tcp_sack</td><td>1</td><td>1</td><td>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</td></tr><tr><td>tcp_fack</td><td>1</td><td>1</td><td>打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)[这个是TCP连接靠谱的核心功能]</td></tr><tr><td>tcp_dsack</td><td>1</td><td>1</td><td>允许TCP发送”两个完全相同”的SACK。</td></tr><tr><td>tcp_ecn</td><td>0</td><td>0</td><td>TCP的直接拥塞通告功能。</td></tr><tr><td>tcp_reordering</td><td>3</td><td>6</td><td>TCP流中重排序的数据报最大数量。 (一般有看到推荐把这个数值略微调整大一些,比如5)</td></tr><tr><td>tcp_retrans_collapse</td><td>1</td><td>0</td><td>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)</td></tr><tr><td>：</td><td>4096</td><td>8192</td><td>发送缓存设置</td></tr><tr><td>：</td><td>87380</td><td>32768</td><td>接收缓存设置</td></tr><tr><td>：</td><td>根据内存计算</td><td>786432</td><td>：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 &#x2F; 4096)。 )</td></tr><tr><td>tcp_app_win</td><td>31</td><td>31</td><td>时表示不需要缓冲。</td></tr><tr><td>tcp_adv_win_scale</td><td>2</td><td>2</td><td>计算缓冲开销</td></tr><tr><td>tcp_low_latency</td><td>0</td><td>0</td><td>集群的时候</td></tr><tr><td>tcp_westwood</td><td>0</td><td>0</td><td>通信来说应该启用这个选项。</td></tr><tr><td>tcp_bic</td><td>0</td><td>0</td><td>；这样可以更好地利用以</td></tr><tr><td>ip_forward</td><td>0</td><td>-</td><td>转发支持，把该值写</td></tr><tr><td>ip_local_port_range</td><td>61000</td><td>65000</td><td>，默认比较小，这个范围同样会间接用于</td></tr><tr><td>ip_conntrack_max</td><td>65535</td><td>65535</td><td>，这个值最大</td></tr></tbody></table><p><strong>（2）所处目录&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;netfilter&#x2F;，文件需要打开防火墙才会存在</strong></p><table><thead><tr><th>名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>ip_conntrack_max</td><td>65536</td><td>65536</td><td>，这个值最大</td></tr><tr><td>ip_conntrack_tcp_timeout_established</td><td>432000</td><td>180</td><td>，也就是</td></tr><tr><td>ip_conntrack_tcp_timeout_time_wait</td><td>120</td><td>120</td><td>状态超时时间，超过该时间就清除该连接</td></tr><tr><td>ip_conntrack_tcp_timeout_close_wait</td><td>60</td><td>60</td><td>状态超时时间，超过该时间就清除该连接</td></tr><tr><td>ip_conntrack_tcp_timeout_fin_wait</td><td>120</td><td>120</td><td>状态超时时间，超过该时间就清除该连接</td></tr></tbody></table><p><strong>（3）文件所处目录&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;</strong></p><table><thead><tr><th>参数名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>netdev_max_backlog</td><td>1024</td><td>16384</td><td>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，对重负载服务器而言，该值需要调高一点。</td></tr><tr><td>somaxconn</td><td>128</td><td>16384</td><td>用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制。</td></tr><tr><td>wmem_default</td><td>129024</td><td>129024</td><td>（以字节为单位）</td></tr><tr><td>rmem_default</td><td>129024</td><td>129024</td><td>（以字节为单位）</td></tr><tr><td>rmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据接收缓冲</td></tr><tr><td>wmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据发送缓冲</td></tr></tbody></table><h1 id="2、两种修改内核参数方法"><a href="#2、两种修改内核参数方法" class="headerlink" title="2、两种修改内核参数方法"></a>2、两种修改内核参数方法</h1><p>（1）、使用echo value方式直接追加到文件里如echo “1” &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries，但这种方法设备重启后又会恢复为默认值。</p><p>（2）、把参数添加到&#x2F;etc&#x2F;sysctl.conf中，然后执行sysctl -p使参数生效，永久生效。</p><h1 id="3、内核生产环境优化参数"><a href="#3、内核生产环境优化参数" class="headerlink" title="3、内核生产环境优化参数"></a>3、内核生产环境优化参数</h1><p>net.ipv4.tcp_syn_retries &#x3D; 1</p><p>net.ipv4.tcp_synack_retries &#x3D; 1</p><p>net.ipv4.tcp_keepalive_time &#x3D; 600</p><p>net.ipv4.tcp_keepalive_probes &#x3D; 3</p><p>net.ipv4.tcp_keepalive_intvl &#x3D;15</p><p>net.ipv4.tcp_retries2 &#x3D; 5</p><p>net.ipv4.tcp_fin_timeout &#x3D; 2</p><p>net.ipv4.tcp_max_tw_buckets &#x3D; 36000</p><p>net.ipv4.tcp_tw_recycle &#x3D; 1</p><p>net.ipv4.tcp_tw_reuse &#x3D; 1</p><p>net.ipv4.tcp_max_orphans &#x3D; 32768</p><p>net.ipv4.tcp_syncookies &#x3D; 1</p><p>net.ipv4.tcp_max_syn_backlog &#x3D; 16384</p><p>net.ipv4.tcp_wmem &#x3D; 8192 131072 16777216</p><p>net.ipv4.tcp_rmem &#x3D; 32768 131072 16777216</p><p>net.ipv4.tcp_mem &#x3D; 786432 1048576 1572864</p><p>net.ipv4.ip_local_port_range &#x3D; 1024 65000</p><p>net.ipv4.ip_conntrack_max &#x3D; 65536</p><p>net.ipv4.netfilter.ip_conntrack_max&#x3D;65536</p><p>net.ipv4.netfilter.ip_conntrack_tcp_timeout_established&#x3D;180</p><p>net.core.somaxconn &#x3D; 16384</p><p>net.core.netdev_max_backlog &#x3D; 16384</p><p>对比网上其他人的生产环境优化参数，需要优化的参数基本差不多，只是值有相应的变化。具体优化值要参考应用场景，这里所列只是常用优化参数，是否适合，可在上面查看该参数描述，理解后，再根据自己生产环境而设。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存溢出(OOM)异常总结</title>
      <link href="/2017/10/22/java/%20Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA(OOM)%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/22/java/%20Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA(OOM)%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看到一篇不错的 Java OOM的总结文章，收藏之，需要反复拜读～</p></blockquote><blockquote><p>我的职业生涯中见过数以千计的内存溢出异常均与下文中的8种情况相关。本文分析什么情况会导致这些异常出现，提供示例代码的同时为您提供解决指南。<strong>Nikita Salnikov-Tarnovski</strong><br>Plumbr Co-Founder and VP of Engineering<br>本文内容来源于Plumbr，对原文内容有删减和补充</p></blockquote><p>这也许是目前最为完整的Java OOM异常的解决指南。</p><h3 id="1、java-lang-OutOfMemoryError-Java-heap-space"><a href="#1、java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1、java.lang.OutOfMemoryError:Java heap space"></a>1、<code>java.lang.OutOfMemoryError:Java heap space</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：<code>Heap space（堆空间）</code>和<code>Permgen（永久代）</code>：</p><p>JVM内存模型示意图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><p>当应用程序试图向堆空间添加更多的数据，但堆却没有足够的空间来容纳这些数据时，将会触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。需要注意的是：即使有足够的物理内存可用，只要达到堆空间设置的大小限制，此异常仍然会被触发。</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>触发<code>java.lang.OutOfMemoryError: Java heap space</code>最常见的原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单，提供更大的堆空间即可。除了前面的因素还有更复杂的成因：</p><ul><li>流量&#x2F;数据量峰值：应用程序在设计之初均有用户量和数据量的限制，某一时刻，当用户数量或数据量突然达到一个峰值，并且这个峰值已经超过了设计之初预期的阈值，那么以前正常的功能将会停止，并触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。</li><li>内存泄漏：特定的编程错误会导致你的应用程序不停的消耗更多的内存，每次使用有内存泄漏风险的功能就会留下一些不能被回收的对象到堆空间中，随着时间的推移，泄漏的对象会消耗所有的堆空间，最终触发<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="①、简单示例"><a href="#①、简单示例" class="headerlink" title="①、简单示例"></a>①、简单示例</h5><p>首先看一个非常简单的示例，下面的代码试图创建2 x 1024 x 1024个元素的整型数组，当你尝试编译并指定12M堆空间运行时（java -Xmx12m OOM）将会失败并抛出<code>java.lang.OutOfMemoryError: Java heap space</code>错误，而当你指定13M堆空间时，将正常的运行。</p><blockquote><p>计算数组占用内存大小，不再本文的范围内，读者有兴趣，可以自行计算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class OOM &#123;</span><br><span class="line">    static final int SIZE=2*1024*1024;</span><br><span class="line">    public static void main(String[] a) &#123;</span><br><span class="line">        int[] i = new int[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;javac OOM.java</span><br><span class="line">D:\&gt;java -Xmx12m OOM</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at OOM.main(OOM.java:4)</span><br><span class="line">D:\&gt;java -Xmx13m OOM</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="②、内存泄漏示例"><a href="#②、内存泄漏示例" class="headerlink" title="②、内存泄漏示例"></a>②、内存泄漏示例</h5><p>在Java中，当开发者创建一个新对象（比如：<code>new Integer(5)</code>）时，不需要自己开辟内存空间，而是把它交给JVM。在应用程序整个生命周期类，JVM负责检查哪些对象可用，哪些对象未被使用。未使用对象将被丢弃，其占用的内存也将被回收，这一过程被称为垃圾回收。JVM负责垃圾回收的模块集合被称为垃圾回收器（<code>GC</code>）。</p><p>Java的内存自动管理机制依赖于GC定期查找未使用对象并删除它们。Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</p><p>我们可以非常容易的写出导致内存泄漏的Java代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class KeylessEntry &#123;</span><br><span class="line">    </span><br><span class="line">    static class Key &#123;</span><br><span class="line">        Integer id;</span><br><span class="line">        </span><br><span class="line">        Key(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            return id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Key,String&gt; m = new HashMap&lt;Key,String&gt;();</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            for(int i=0;i&lt;10000;i++) &#123;</span><br><span class="line">                if(!m.containsKey(new Key(i))) &#123;</span><br><span class="line">                    m.put(new Key(i), &quot;Number:&quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中<code>HashMap</code>为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于<code>Key</code>实体没有实现<code>equals()</code>方法，导致for循环中每次执行<code>m.containsKey(new Key(i))</code>结果均为<code>false</code>，其结果就是<code>HashMap</code>中的元素将一直增加。</p><p>随着时间的推移，越来越多的<code>Key</code>对象进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出<code>java.lang.OutOfMemoryError:Java heap space</code>。</p><blockquote><p>上面的代码直接运行可能很久也不会抛出异常，可以在启动时使用-Xmx参数，设置堆内存大小，或者在for循环后打印HashMap的大小，执行后会发现HashMap的size一直再增长。</p></blockquote><p>解决方法也非常简单，只要<code>Key</code>实现自己的<code>equals</code>方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    boolean response = false;</span><br><span class="line">    if (o instanceof Key) &#123;</span><br><span class="line">        response = (((Key)o).id).equals(this.id);</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，你应该确保有足够的堆空间来正常运行你的应用程序，在JVM的启动配置中增加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的配置分配1024M堆空间给你的应用程序，当然你也可以使用其他单位，比如用G表示GB，K表示KB。下面的示例都表示最大堆空间为1GB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1073741824 com.mycompany.MyClass</span><br><span class="line">java -Xmx1048576k com.mycompany.MyClass</span><br><span class="line">java -Xmx1024m com.mycompany.MyClass</span><br><span class="line">java -Xmx1g com.mycompany.MyClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，更多的时候，单纯地增加堆空间不能解决所有的问题。如果你的程序存在内存泄漏，一味的增加堆空间也只是推迟<code>java.lang.OutOfMemoryError: Java heap space</code>错误出现的时间而已，并未解决这个隐患。除此之外，垃圾收集器在GC时，应用程序会停止运行直到GC完成，而增加堆空间也会导致GC时间延长，进而影响程序的吞吐量。</p><p>如果你想完全解决这个问题，那就好好提升自己的编程技能吧，当然运用好<code>Debuggers, profilers, heap dump analyzers</code>等工具，可以让你的程序最大程度的避免内存泄漏问题。</p><h3 id="2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded"><a href="#2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded" class="headerlink" title="2、java.lang.OutOfMemoryError:GC overhead limit exceeded"></a>2、<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code></h3><p>Java运行时环境（<code>JRE</code>）包含一个内置的垃圾回收进程，而在许多其他的编程语言中，开发者需要手动分配和释放内存。</p><p>Java应用程序只需要开发者分配内存，每当在内存中特定的空间不再使用时，一个单独的垃圾收集进程会清空这些内存空间。垃圾收集器怎样检测内存中的某些空间不再使用已经超出本文的范围，但你只需要相信GC可以做好这些工作即可。</p><p>默认情况下，当应用程序花费超过98%的时间用来做GC并且回收了不到2%的堆内存时，会抛出<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误。具体的表现就是你的应用几乎耗尽所有可用内存，并且GC多次均未能清理干净。</p><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><p><code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。那如果没有此限制会发生什么呢？GC进程将被重启，100%的CPU将用于GC，而没有CPU资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。</p><p>所以<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>也可以看做是一个<code>fail-fast（快速失败）</code>实战的实例。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的代码初始化一个<code>map</code>并在无限循环中不停的添加键值对，运行后将会抛出<code>GC overhead limit exceeded</code>错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        Map map = System.getProperties();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            map.put(r.nextInt(), &quot;value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如你所预料的那样，程序不能正常的结束，事实上，当我们使用如下参数启动程序时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseParallelGC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们很快就可以看到程序抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误。但如果在启动时设置不同的堆空间大小或者使用不同的GC算法，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx10m -XX:+UseParallelGC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们将看到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at java.util.Hashtable.rehash(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.addEntry(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.put(Unknown Source)</span><br><span class="line">    at cn.moondev.Wrapper.main(Wrapper.java:12)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用以下GC算法：<code>-XX:+UseConcMarkSweepGC</code> 或者<code>-XX:+UseG1GC</code>，启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseConcMarkSweepGC Wrapper</span><br><span class="line">java -Xmx100m -XX:+UseG1GC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception: java.lang.OutOfMemoryError thrown from </span><br><span class="line">the UncaughtExceptionHandler in thread &quot;main&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。</p><p>以上这些变化可以说明，在资源有限的情况下，你根本无法无法预测你的应用是怎样挂掉的，什么时候会挂掉，所以在开发时，你不能仅仅保证自己的应用程序在特定的环境下正常运行。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先是一个毫无诚意的解决方案，如果你仅仅是不想看到<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>的错误信息，可以在应用程序启动时添加如下JVM参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseGCOverheadLimit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是强烈建议不要使用这个选项，因为这样并没有解决任何问题，只是推迟了错误出现的时间，错误信息也变成了我们更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>而已。</p><p>另一个解决方案，如果你的应用程序确实内存不足，增加堆内存会解决<code>GC overhead limit</code>问题，就如下面这样，给你的应用程序1G的堆内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m com.yourcompany.YourClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但如果你想确保你已经解决了潜在的问题，而不是掩盖<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误，那么你不应该仅止步于此。你要记得还有<code>profilers</code>和<code>memory dump analyzers</code>这些工具，你需要花费更多的时间和精力来查找问题。还有一点需要注意，这些工具在Java运行时有显著的开销，因此不建议在生产环境中使用。</p><h3 id="3、java-lang-OutOfMemoryError-Permgen-space"><a href="#3、java-lang-OutOfMemoryError-Permgen-space" class="headerlink" title="3、java.lang.OutOfMemoryError:Permgen space"></a>3、<code>java.lang.OutOfMemoryError:Permgen space</code></h3><p>Java中堆空间是JVM管理的最大一块内存空间，可以在JVM启动时指定堆空间的大小，其中堆被划分成两个不同的区域：新生代（Young）和老年代（Tenured），新生代又被划分为3个区域：<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>，如下图所示。</p><p>图片来源：并发编程网</p><p><code>java.lang.OutOfMemoryError: PermGen space</code>错误就表明持久代所在区域的内存已被耗尽。</p><h4 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h4><p>要理解<code>java.lang.OutOfMemoryError: PermGen space</code>出现的原因，首先需要理解<code>Permanent Generation Space</code>的用处是什么。持久代主要存储的是每个类的信息，比如：<strong>类加载器引用</strong>、<strong>运行时常量池（所有常量、字段引用、方法引用、属性）</strong>、<strong>字段(Field)数据</strong>、<strong>方法(Method)数据</strong>、<strong>方法代码</strong>、<strong>方法字节码</strong>等等。我们可以推断出，<code>PermGen</code>的大小取决于被加载类的数量以及类的大小。</p><p>因此，我们可以得出出现<code>java.lang.OutOfMemoryError: PermGen space</code>错误的原因是：太多的类或者太大的类被加载到<code>permanent generation</code>（持久代）。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><h5 id="①、最简单的示例"><a href="#①、最简单的示例" class="headerlink" title="①、最简单的示例"></a>①、最简单的示例</h5><p>正如前面所描述的，<code>PermGen</code>的使用与加载到JVM类的数量有密切关系，下面是一个最简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;</span><br><span class="line">public class MicroGenerator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100_000_000; i++) &#123;</span><br><span class="line">            generate(&quot;cn.moondev.User&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Class generate(String name) throws Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        return pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行时请设置JVM参数：<code>-XX:MaxPermSize=5m</code>，值越小越好。需要注意的是JDK8已经完全移除持久代空间，取而代之的是元空间（<code>Metaspace</code>），所以示例最好的JDK1.7或者1.6下运行。</p><p>代码在运行时不停的生成类并加载到持久代中，直到撑满持久代内存空间，最后抛出<code>java.lang.OutOfMemoryError:Permgen space</code>。代码中类的生成使用了<code>javassist</code>库。</p><h5 id="②、Redeploy-time"><a href="#②、Redeploy-time" class="headerlink" title="②、Redeploy-time"></a>②、Redeploy-time</h5><p>更复杂和实际的一个例子就是Redeploy（重新部署，你可以想象一下你开发时，点击eclipse的reploy按钮或者使用idea时按ctrl + F5时的过程）。在从服务器卸载应用程序时，当前的<code>classloader</code>以及加载的<code>class</code>在没有实例引用的情况下，持久代的内存空间会被GC清理并回收。如果应用中有类的实例对当前的<code>classloader</code>的引用，那么<code>Permgen</code>区的<code>class</code>将无法被卸载，导致<code>Permgen</code>区的内存一直增加直到出现<code>Permgen space</code>错误。</p><p>不幸的是，许多第三方库以及糟糕的资源处理方式（比如：线程、JDBC驱动程序、文件系统句柄）使得卸载以前使用的类加载器变成了一件不可能的事。反过来就意味着在每次重新部署过程中，应用程序所有的类的先前版本将仍然驻留在<code>Permgen</code>区中，你的每次部署都将生成几十甚至几百M的垃圾。</p><p>就以线程和JDBC驱动来说说。很多人都会使用线程来处理一下周期性或者耗时较长的任务，这个时候一定要注意线程的生命周期问题，你需要确保线程不能比你的应用程序活得还长。否则，如果应用程序已经被卸载，线程还在继续运行，这个线程通常会维持对应用程序的<code>classloader</code>的引用，造成的结果就不再多说。多说一句，<strong>开发者有责任处理好这个问题，特别是如果你是第三方库的提供者的话，一定要提供线程关闭接口来处理清理工作</strong>。</p><p>让我们想象一个使用JDBC驱动程序连接到关系数据库的示例应用程序。当应用程序部署到服务器上的时：服务器创建一个<code>classloader</code>实例来加载应用所有的类（包含相应的JDBC驱动）。根据JDBC规范，JDBC驱动程序（比如：<code>com.mysql.jdbc.Driver</code>）会在初始化时将自己注册到<code>java.sql.DriverManager</code>中。该注册过程中会将驱动程序的一个实例存储在DriverManager的静态字段内，代码可以参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// com.mysql.jdbc.Driver源码</span><br><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can\&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// // // // // // // // // //</span><br><span class="line">// 再看下DriverManager对应代码</span><br><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,DriverAction da) throws SQLException &#123;</span><br><span class="line">    if(driver != null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，当从服务器上卸载应用程序的时候，<code>java.sql.DriverManager</code>仍将持有那个驱动程序的引用，进而持有用于加载应用程序的<code>classloader</code>的一个实例的引用。这个<code>classloader</code>现在仍然引用着应用程序的所有类。如果此程序启动时需要加载2000个类，占用约10MB永久代（PermGen）内存，那么只需要5~10次重新部署，就会将默认大小的永久代（PermGen）塞满，然后就会触发<code>java.lang.OutOfMemoryError: PermGen space</code>错误并崩溃。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="①-解决初始化时的OutOfMemoryError"><a href="#①-解决初始化时的OutOfMemoryError" class="headerlink" title="① 解决初始化时的OutOfMemoryError"></a>① 解决初始化时的<code>OutOfMemoryError</code></h5><p>当在应用程序启动期间触发由于<code>PermGen</code>耗尽引起的<code>OutOfMemoryError</code>时，解决方案很简单。 应用程序需要更多的空间来加载所有的类到<code>PermGen</code>区域，所以我们只需要增加它的大小。 为此，请更改应用程序启动配置，并添加（或增加，如果存在）-XX：MaxPermSize参数，类似于以下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxPermSize=512m com.yourcompany.YourClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="②-解决Redeploy时的OutOfMemoryError"><a href="#②-解决Redeploy时的OutOfMemoryError" class="headerlink" title="② 解决Redeploy时的OutOfMemoryError"></a>② 解决<code>Redeploy</code>时的<code>OutOfMemoryError</code></h5><p>分析dump文件：首先，找出引用在哪里被持有；其次，给你的web应用程序添加一个关闭的hook，或者在应用程序卸载后移除引用。你可以使用如下命令导出dump文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump.hprof &lt;process-id&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是你自己代码的问题请及时修改，如果是第三方库，请试着搜索一下是否存在”关闭”接口，如果没有给开发者提交一个bug或者issue吧。</p><h5 id="③-解决运行时OutOfMemoryError"><a href="#③-解决运行时OutOfMemoryError" class="headerlink" title="③ 解决运行时OutOfMemoryError"></a>③ 解决运行时<code>OutOfMemoryError</code></h5><p>首先你需要检查是否允许GC从<code>PermGen</code>卸载类，JVM的标准配置相当保守，只要类一创建，即使已经没有实例引用它们，其仍将保留在内存中，特别是当应用程序需要动态创建大量的类但其生命周期并不长时，允许JVM卸载类对应用大有助益，你可以通过在启动脚本中添加以下配置参数来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，这个配置是未启用的，如果你启用它，GC将扫描<code>PermGen</code>区并清理已经不再使用的类。但请注意，这个配置只在<code>UseConcMarkSweepGC</code>的情况下生效，如果你使用其他GC算法，比如：<code>ParallelGC</code>或者<code>Serial GC</code>时，这个配置无效。所以使用以上配置时，请配合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你已经确保JVM可以卸载类，但是仍然出现内存溢出问题，那么你应该继续分析dump文件，使用以下命令生成dump文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=dump.hprof,format=b &lt;process-id&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你拿到生成的堆转储文件，并利用像Eclipse Memory Analyzer Toolkit这样的工具来寻找应该卸载却没被卸载的类加载器，然后对该类加载器加载的类进行排查，找到可疑对象，分析使用或者生成这些类的代码，查找产生问题的根源并解决它。</p><h3 id="4、java-lang-OutOfMemoryError-Metaspace"><a href="#4、java-lang-OutOfMemoryError-Metaspace" class="headerlink" title="4、java.lang.OutOfMemoryError:Metaspace"></a>4、<code>java.lang.OutOfMemoryError:Metaspace</code></h3><p>前文已经提过，<code>PermGen</code>区域用于存储类的名称和字段，类的方法，方法的字节码，常量池，JIT优化等，但从Java8开始，Java中的内存模型发生了重大变化：引入了称为<code>Metaspace</code>的新内存区域，而删除了<code>PermGen</code>区域。请注意：不是简单的将<code>PermGen</code>区所存储的内容直接移到<code>Metaspace</code>区，<code>PermGen</code>区中的某些部分，已经移动到了普通堆里面。</p><p>OOM-example-metaspace，图片来源：Plumbr</p><h4 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h4><p>Java8做出如此改变的原因包括但不限于：</p><ul><li>应用程序所需要的<code>PermGen</code>区大小很难预测，设置太小会触发<code>PermGen OutOfMemoryError</code>错误，过度设置导致资源浪费。</li><li>提升GC性能，在HotSpot中的每个垃圾收集器需要专门的代码来处理存储在<code>PermGen</code>中的类的元数据信息。从<code>PermGen</code>分离类的元数据信息到<code>Metaspace</code>，由于<code>Metaspace</code>的分配具有和<code>Java Heap</code>相同的地址空间，因此<code>Metaspace</code>和<code>Java Heap</code>可以无缝的管理，而且简化了<code>FullGC</code>的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有GC暂停。</li><li>支持进一步优化，比如：G1并发类的卸载，也算为将来做准备吧</li></ul><p>正如你所看到的，元空间大小的要求取决于加载的类的数量以及这种类声明的大小。 所以很容易看到<code>java.lang.OutOfMemoryError: Metaspace</code>主要原因：太多的类或太大的类加载到元空间。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>正如上文中所解释的，元空间的使用与加载到JVM中的类的数量密切相关。 下面的代码是最简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Metaspace &#123;</span><br><span class="line">    static javassist.ClassPool cp = javassist.ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123; </span><br><span class="line">            Class c = cp.makeClass(&quot;eu.plumbr.demo.Generated&quot; + i).toClass();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序运行中不停的生成新类，所有的这些类的定义将被加载到<code>Metaspace</code>区，直到空间被完全占用并且抛出<code>java.lang.OutOfMemoryError:Metaspace</code>。当使用<code>-XX：MaxMetaspaceSize = 32m</code>启动时，大约加载30000多个类时就会死机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">31023</span><br><span class="line">31024</span><br><span class="line">Exception in thread &quot;main&quot; javassist.CannotCompileException: by java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1170)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1113)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1071)</span><br><span class="line">    at javassist.CtClass.toClass(CtClass.java:1275)</span><br><span class="line">    at cn.moondev.book.Metaspace.main(Metaspace.java:12)</span><br><span class="line">    .....</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，既然应用程序会耗尽内存中的<code>Metaspace</code>区空间，那么应该增加其大小，更改启动配置增加如下参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 告诉JVM：Metaspace允许增长到512，然后才能抛出异常</span><br><span class="line">-XX：MaxMetaspaceSize = 512m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一个方法就是删除此参数来完全解除对<code>Metaspace</code>大小的限制（默认是没有限制的）。默认情况下，对于64位服务器端JVM，MetaspaceSize默认大小是21M（初始限制值），一旦达到这个限制值，FullGC将被触发进行类卸载，并且这个限制值将会被重置，新的限制值依赖于<code>Metaspace</code>的剩余容量。如果没有足够空间被释放，这个限制值将会上升，反之亦然。在技术上<code>Metaspace</code>的尺寸可以增长到交换空间，而这个时候本地内存分配将会失败（更具体的分析，可以参考：<a href="http://ifeve.com/java-permgen-removed/">Java PermGen 去哪里了?</a>）。</p><p>你可以通过修改各种启动参数来“快速修复”这些内存溢出错误，但你需要正确区分你是否只是推迟或者隐藏了<code>java.lang.OutOfMemoryError</code>的症状。如果你的应用程序确实存在内存泄漏或者本来就加载了一些不合理的类，那么所有这些配置都只是推迟问题出现的时间而已，实际也不会改善任何东西。</p><h3 id="5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread"><a href="#5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread" class="headerlink" title="5、java.lang.OutOfMemoryError:Unable to create new native thread"></a>5、<code>java.lang.OutOfMemoryError:Unable to create new native thread</code></h3><p>一个思考线程的方法是将线程看着是执行任务的工人，如果你只有一个工人，那么他同时只能执行一项任务，但如果你有十几个工人，就可以同时完成你几个任务。就像这些工人都在物理世界，JVM中的线程完成自己的工作也是需要一些空间的，当有足够多的线程却没有那么多的空间时就会像这样：</p><p>图片来源：Plumbr</p><p>出现<code>java.lang.OutOfMemoryError:Unable to create new native thread</code>就意味着Java应用程序已达到其可以启动线程数量的极限了。</p><h4 id="原因分析-4"><a href="#原因分析-4" class="headerlink" title="原因分析"></a>原因分析</h4><p>当JVM向OS请求创建一个新线程时，而OS却无法创建新的native线程时就会抛出<code>Unable to create new native thread</code>错误。一台服务器可以创建的线程数依赖于物理配置和平台，建议运行下文中的示例代码来测试找出这些限制。总体上来说，抛出此错误会经过以下几个阶段：</p><ul><li>运行在JVM内的应用程序请求创建一个新的线程</li><li>JVM向OS请求创建一个新的native线程</li><li>OS尝试创建一个新的native线程，这时需要分配内存给新的线程</li><li>OS拒绝分配内存给线程，因为32位Java进程已经耗尽内存地址空间（2-4GB内存地址已被命中）或者OS的虚拟内存已经完全耗尽</li><li><code>Unable to create new native thread</code>错误将被抛出</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例不能的创建并启动新的线程。当代码运行时，很快达到OS的线程数限制，并抛出<code>Unable to create new native thread</code>错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(10000000);</span><br><span class="line">            &#125; catch(InterruptedException e) &#123; &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>有时，你可以通过在OS级别增加线程数限制来绕过这个错误。如果你限制了JVM可在用户空间创建的线程数，那么你可以检查并增加这个限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// macOS 10.12上执行</span><br><span class="line">$ ulimit -u</span><br><span class="line">709</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你的应用程序产生成千上万的线程，并抛出此异常，表示你的程序已经出现了很严重的编程错误，我不觉得应该通过修改参数来解决这个问题，不管是OS级别的参数还是JVM启动参数。更可取的办法是分析你的应用是否真的需要创建如此多的线程来完成任务？是否可以使用线程池或者说线程池的数量是否合适？是否可以更合理的拆分业务来实现…..</p><h3 id="6、java-lang-OutOfMemoryError-Out-of-swap-space"><a href="#6、java-lang-OutOfMemoryError-Out-of-swap-space" class="headerlink" title="6、java.lang.OutOfMemoryError:Out of swap space?"></a>6、<code>java.lang.OutOfMemoryError:Out of swap space?</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，可以通过<code>-Xmx</code>和其他类似的启动参数来指定。在JVM请求的总内存大于可用物理内存的情况下，操作系统会将内存中的数据交换到磁盘上去。</p><p>图片来源：plumbr</p><p><code>Out of swap space?</code>表示交换空间也将耗尽，并且由于缺少物理内存和交换空间，再次尝试分配内存也将失败。</p><h4 id="原因分析-5"><a href="#原因分析-5" class="headerlink" title="原因分析"></a>原因分析</h4><p>当应用程序向JVM native heap请求分配内存失败并且native heap也即将耗尽时，JVM会抛出<code>Out of swap space</code>错误。该错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。</p><blockquote><p>Native Heap Memory是JVM内部使用的Memory，这部分的Memory可以通过JDK提供的JNI的方式去访问，这部分Memory效率很高，但是管理需要自己去做，如果没有把握最好不要使用，以防出现内存泄露问题。JVM 使用Native Heap Memory用来优化代码载入（JTI代码生成），临时对象空间申请，以及JVM内部的一些操作。</p></blockquote><p>这个问题往往发生在Java进程已经开始交换的情况下，现代的GC算法已经做得足够好了，当时当面临由于交换引起的延迟问题时，GC暂停的时间往往会让大多数应用程序不能容忍。</p><p><code>java.lang.OutOfMemoryError:Out of swap space?</code>往往是由操作系统级别的问题引起的，例如：</p><ul><li>操作系统配置的交换空间不足。</li><li>系统上的另一个进程消耗所有内存资源。</li></ul><p>还有可能是本地内存泄漏导致应用程序失败，比如：应用程序调用了native code连续分配内存，但却没有被释放。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题有几个办法，通常最简单的方法就是增加交换空间，不同平台实现的方式会有所不同，比如在Linux下可以通过如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line"># 创建并附加一个大小为640MB的新交换文件</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java GC会扫描内存中的数据，如果是对交换空间运行垃圾回收算法会使GC暂停的时间增加几个数量级，因此你应该慎重考虑使用上文增加交换空间的方法。</p><p>如果你的应用程序部署在JVM需要同其他进程激烈竞争获取资源的物理机上，建议将服务隔离到单独的虚拟机中</p><p>但在许多情况下，您唯一真正可行的替代方案是：</p><ul><li>升级机器以包含更多内存</li><li>优化应用程序以减少其内存占用</li></ul><p>当您转向优化路径时，使用内存转储分析程序来检测内存中的大分配是一个好的开始。</p><h3 id="7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit"><a href="#7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit" class="headerlink" title="7、java.lang.OutOfMemoryError:Requested array size exceeds VM limit"></a>7、<code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code></h3><p>Java对应用程序可以分配的最大数组大小有限制。不同平台限制有所不同，但通常在1到21亿个元素之间。</p><p>图片来源：plumbr</p><p>当你遇到<code>Requested array size exceeds VM limit</code>错误时，意味着你的应用程序试图分配大于Java虚拟机可以支持的数组。</p><h4 id="原因分析-6"><a href="#原因分析-6" class="headerlink" title="原因分析"></a>原因分析</h4><p>该错误由JVM中的<code>native code</code>抛出。 JVM在为数组分配内存之前，会执行特定于平台的检查：分配的数据结构是否在此平台中是可寻址的。</p><p>你很少见到这个错误是因为Java数组的索引是int类型。 Java中的最大正整数为2 ^ 31 - 1 &#x3D; 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：我的环境上(64位macOS，运行Jdk1.8)可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。如果再将数组的长度增加1到Integer.MAX_VALUE-1会导致熟悉的OutOfMemoryError：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，在使用OpenJDK 6的32位Linux上，在分配具有大约11亿个元素的数组时，您将遇到<code>Requested array size exceeded VM limit</code>的错误。 要理解你的特定环境的限制，运行下文中描述的小测试程序。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 3; i &gt;= 0; i--) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int[] arr = new int[Integer.MAX_VALUE-i];</span><br><span class="line">        System.out.format(&quot;Successfully initialized an array with %,d elements.\n&quot;, Integer.MAX_VALUE-i);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该示例重复四次，并在每个回合中初始化一个长原语数组。 该程序尝试初始化的数组的大小在每次迭代时增加1，最终达到Integer.MAX_VALUE。 现在，当使用Hotspot 7在64位Mac OS X上启动代码片段时，应该得到类似于以下内容的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，在出现<code>Requested array size exceeded VM limit</code>之前，出现了更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>。 这是因为初始化2 ^ 31-1个元素的数组需要腾出8G的内存空间，大于JVM使用的默认值。</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code>可能会在以下任一情况下出现：</p><ul><li>数组增长太大，最终大小在平台限制和<code>Integer.MAX_INT</code>之间</li><li>你有意分配大于<code>2 ^ 31-1</code>个元素的数组</li></ul><p>在第一种情况下，检查你的代码库，看看你是否真的需要这么大的数组。也许你可以减少数组的大小，或者将数组分成更小的数据块，然后分批处理数据。</p><p>在第二种情况下，记住Java数组是由int索引的。因此，当在平台中使用标准数据结构时，数组不能超过2 ^ 31-1个元素。事实上，在编译时就会出错：<code>error：integer number too large</code>。</p><h3 id="8、Out-of-memory-Kill-process-or-sacrifice-child"><a href="#8、Out-of-memory-Kill-process-or-sacrifice-child" class="headerlink" title="8、Out of memory:Kill process or sacrifice child"></a>8、<code>Out of memory:Kill process or sacrifice child</code></h3><p>为了理解这个错误，我们需要补充一点操作系统的基础知识。操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，名叫“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，然后选择一个进程杀掉。哪一个进程这么倒霉呢？选择的算法和想法都很朴实：谁占用内存最多，谁就被干掉。如果你对OOM Killer感兴趣的话，建议你阅读参考资料2中的文章。</p><p>OOM Killer，图片来源：plumbr</p><p>当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，就会产生<code>Out of memory:Kill process or sacrifice child</code>错误。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。</p><h4 id="原因分析-7"><a href="#原因分析-7" class="headerlink" title="原因分析"></a>原因分析</h4><p>默认情况下，Linux内核允许进程请求比系统中可用内存更多的内存，但大多数进程实际上并没有使用完他们所分配的内存。这就跟现实生活中的宽带运营商类似，他们向所有消费者出售一个100M的带宽，远远超过用户实际使用的带宽，一个10G的链路可以非常轻松的服务100个(10G&#x2F;100M)用户，但实际上宽带运行商往往会把10G链路用于服务150人或者更多，以便让链路的利用率更高，毕竟空闲在那儿也没什么意义。</p><p>Linux内核采用的机制跟宽带运营商差不多，一般情况下都没有问题，但当大多数应用程序都消耗完自己的内存时，麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。就如同上面的例子中，如果150人都占用100M的带宽，那么总的带宽肯定超过了10G这条链路能承受的范围。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>当你在Linux上运行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    List&lt;int[]&gt; l = new java.util.ArrayList();</span><br><span class="line">    for (int i = 10000; i &lt; 100000; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            l.add(new int[100000000]);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Linux的系统日志中<code>/var/log/kern.log</code>会出现以下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice child</span><br><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：你可能需要调整交换文件和堆大小，否则你将很快见到熟悉的<code>Java heap space</code>异常。在原作者的测试用例中，使用<code>-Xmx2g</code>指定的2g堆，并具有以下交换配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意：原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题最有效也是最直接的方法就是升级内存，其他方法诸如：调整OOM Killer配置、水平扩展应用，将内存的负载分摊到若干小实例上….. 我们不建议的做法是增加交换空间，具体原因已经在前文说过。参考资料②中详细的介绍了怎样微调OOM Killer配置以及OOM Killer选择进程算法的实现，建议你参考阅读。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>① 想要了解更多PermGen与Metaspace的内容推荐你阅读：</p><ul><li><a href="http://www.infoq.com/cn/news/2013/03/java-8-permgen-metaspace">Java 8会解决PermGen OutOfMemoryError问题吗?</a></li><li><a href="http://ifeve.com/java-permgen-removed/">Java PermGen 去哪里了?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里Java开发规约idea插件</title>
      <link href="/2017/10/16/java/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6idea%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/10/16/java/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6idea%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>周六日看了阿里云的云栖大会，周日场（10月15日）研发效能峰会上，阿里正式发布了《阿里巴巴Java开发手册》，并提供了代码规范插件，目前主要使用idea开发，这里简单记录下使用方法</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>编码规约扫描</li></ul><p>扫描结果将以 <code>Blocker</code>&#x2F; <code>Critical</code>&#x2F; <code>Major</code> 三种级别显示</p><ul><li>实时检测</li></ul><p>基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><blockquote><p>安装很简单，在idea的Plugins，–&gt; Browse repositories 里直接搜索alibaba 就可以找到</p></blockquote><p>   <img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/install_2.png" alt="Switch language"></p><p>   <a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/install_2.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/install_2.png</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用也很简单 idea —&gt; tools —&gt; 阿里编码规约</p><ol><li><p>Switch language</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/switch_language.png" alt="Switch language"></p></li><li><p>Inspections</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection.png" alt="Real time"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection.png</a></p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection_setting.png" alt="Settings"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_setting.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_setting.png</a></p></li><li><p>Code Analyze</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/analyze.png" alt="Settings"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze.png</a></p><p>We use the idea standard Inspection Results to show our violations.</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection_result.png" alt="Result"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_result.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_result.png</a></p><p>We can also analyze file which is modified before vcs checkin.</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/analyze_before_checkin.png" alt="Before Checkin"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze_before_checkin.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze_before_checkin.png</a></p></li></ol><blockquote><p>《阿里巴巴Java开发手册（终极版）.pdf》已发 安排时间仔细阅读再~</p></blockquote><ul><li><a href="https://github.com/alibaba/p3c">github 地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏高效的小工具</title>
      <link href="/2017/10/14/%E5%B7%A5%E5%85%B7/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/10/14/%E5%B7%A5%E5%85%B7/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>此篇讲持续更新，把用着不错的工具整理出来～，提高效率的同时，也方便学习和分享～</p><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><p><a href="https://brew.sh/">Homebrew — The missing package manager for macOS</a>，Mac上非常好用的包管理工具，很多常见的安装都可以通过<code>brew install app</code>或者<code>brew cask install app</code>直接安装，类似apt-get，yum等，之前已经有篇幅记载。</p><h4 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p><a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> mac上的命令行（bash–&gt;zsh）替代方案，各种强大</p><blockquote><p>Oh My Zsh will not make you a 10x developer…</p></blockquote><p>不管是自动纠错、目录切换、命令补全、参数补全、强大的alias，用起来都很顺手。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/oh-my-zsh.png" alt="oh-my-zsh.png"></p><h4 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h4><p>当简单查询某条命令如何使用时，用man查看简直是噩梦，实在太长了，Too Long Don’t Read!</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/man.png" alt="man"></p><p>而<a href="https://github.com/tldr-pages/tldr">tldr: Simplified and community-driven man pages</a>可以快速get到、回忆起命令的常见用法。对比一下：</p><pre><code>![tldr](http://oioeypcz0.bkt.clouddn.com/tldr-tar.png)</code></pre><h4 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h4><p>有时候cd到某个目录要好几层，用<a href="https://github.com/wting/autojump">Autojump: A cd command that learns</a>可以一步到位，安装之后，第一次需要手动cd，以后就可以<code>j longdir</code>即可。</p><pre><code>![autojump](http://oioeypcz0.bkt.clouddn.com/autojump.png)</code></pre><h4 id="Copy-as-Markdown"><a href="#Copy-as-Markdown" class="headerlink" title="Copy as Markdown"></a>Copy as Markdown</h4><p>对于经常用Markdown写文档的人来说，复制网页链接之后还要插入到<code>[]()</code>里，实在麻烦。<a href="https://github.com/chitsaou/copy-as-markdown">Copying Link, Image and Tab(s) as Markdown</a>解决这个头疼的问题。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/copy-as-markdown.png" alt="copy-as-markdown"></p><h4 id="Github-Hovercard"><a href="#Github-Hovercard" class="headerlink" title="Github Hovercard"></a>Github Hovercard</h4><p>经常混迹于Github人士会浏览无数的Repo，有时候只想大致看看Repo的信息，又懒惰打开那个网页。此时<a href="https://github.com/Justineo/github-hovercard">Github Hovercard</a>是你的不二之选。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/github-hovercard.png" alt="github-hovercard"></p><p>只需要把鼠标悬停在仓库链接即可。</p><h4 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h4><p>想看看Github上开源的代码，又不想一层层目录点下去，此时<a href="https://github.com/buunguyen/octotree">Octotree: Code tree for GitHub</a>正好解决这个难题。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/octotree.png" alt="Octotree"></p><h4 id="OctoLinker"><a href="#OctoLinker" class="headerlink" title="OctoLinker"></a>OctoLinker</h4><p>在Github上的代码，经常会看到<code>import ...</code>，习惯了IDE的你，是不是忍不住跳到那个类？<a href="https://github.com/OctoLinker/browser-extension">OctoLinker</a>满足你的这个需求。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/octo-linker.png" alt="octo-linker"></p><p>也支持Python。</p><h4 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h4><p>Mac下，想直接在某个文件夹下打开Terminal，咋办？去Terminal里打开实在是太麻烦了，试试<a href="http://zipzapmac.com/Go2Shell">Go2Shell</a>。集成在Finder里之后，一点即可。</p><h4 id="Web-Clipper"><a href="#Web-Clipper" class="headerlink" title="Web Clipper"></a>Web Clipper</h4><p>看到一篇好文章，保存链接不放心，怕链接失效；复制粘贴太麻烦。用<a href="https://evernote.com/products/webclipper/">Evernote Web Clipper</a>，直接保存富文本格式的文章，还只能去除广告，好用。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/web-clipper.png" alt="web-clipper"></p><h4 id="Json-Viewer"><a href="#Json-Viewer" class="headerlink" title="Json Viewer"></a>Json Viewer</h4><p>在浏览器上返回的Json文件，如果没有格式化太难看清其结构，利用<a href="https://github.com/tulios/json-viewer">Json Viewer</a>插件，就明了多了。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/json-viewer.png" alt="json-viewer"></p><h4 id="csvkit"><a href="#csvkit" class="headerlink" title="csvkit"></a>csvkit</h4><p>如果你做数据分析，这个命令行工具<a href="https://github.com/wireservice/csvkit/tree/1.0.2">csvkit</a>你一定喜欢。《Data Science at Command Line》一书推荐，很好用。</p><h4 id="Quicklook"><a href="#Quicklook" class="headerlink" title="Quicklook"></a>Quicklook</h4><p>工作中会遇到各种各样格式的文件，比如代码、Json、csv、Excel、markdown文档等。很多时候只想看大概信息，就是quicklook一下，不想打开编辑，这时候<a href="https://github.com/sindresorhus/quick-look-plugins">Quicklook Plugins: List of useful Quick Look plugins for developers</a>特别好用，官网上有很丰富的例子。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/quicklook-markdown.png" alt="quicklook-markdown"></p><h4 id="stedolan-x2F-jq"><a href="#stedolan-x2F-jq" class="headerlink" title="stedolan&#x2F;jq"></a>stedolan&#x2F;jq</h4><p>jq是一个轻量级和灵活的命令行JSON处理器,jq 像<code>sed</code> 一样处理json数据，使用起来非常友好，<a href="https://github.com/stedolan/jq">github 地址</a></p><p>常用的场景：配合curl，命令行，格式化json输出</p><p>curl <a href="http://127.0.0.1:5000/people">http://127.0.0.1:5000/people</a> | jq</p><pre><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                Dload  Upload   Total   Spent    Left  Speed100   168  100   168    0     0  21804      0 --:--:-- --:--:-- --:--:-- 24000&#123;&quot;_items&quot;: [],&quot;_links&quot;: &#123;    &quot;parent&quot;: &#123;    &quot;title&quot;: &quot;home&quot;,    &quot;href&quot;: &quot;/&quot;    &#125;,    &quot;self&quot;: &#123;    &quot;title&quot;: &quot;people&quot;,    &quot;href&quot;: &quot;people&quot;    &#125;&#125;,&quot;_meta&quot;: &#123;    &quot;page&quot;: 1,    &quot;max_results&quot;: 25,    &quot;total&quot;: 0&#125;&#125;</code></pre><h4 id="dict-cli"><a href="#dict-cli" class="headerlink" title="dict-cli"></a>dict-cli</h4><p>python的翻译工具，使用pip 安装即可</p><pre><code>sudo pip install dict-cli     </code></pre><p>直接使用 dict 单词</p><pre><code>dict desktop####################################  desktop 桌面#  (U: &#39;dɛsk&#39;tɑp E: &#39;desktɒp)##  n. 桌面；台式机##  desktop : 桌面#             台式机#             桌上型的#  Google Desktop : Google桌面#                    Google桌面#                    桌面搜索#  Desktop search : 桌面搜索#                    桌面搜索#                    桌面搜寻###################################</code></pre><h4 id="终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd"><a href="#终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd" class="headerlink" title="终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd"></a>终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd</h4><blockquote><p>zsh的z插件可以随意跳转最近经常打开的文件夹<br>zsh的wd插件可以任意跳转你标记过的文件夹</p></blockquote><h5 id="安装-z-和-wd-插件"><a href="#安装-z-和-wd-插件" class="headerlink" title="安装 z 和 wd 插件"></a>安装 <code>z</code> 和 <code>wd</code> 插件</h5><p>打开.zshrc 文件添加插件即可</p><pre><code>subl ~/.zshrc plugins=(git z wd)</code></pre><h5 id="使用-z-可查看最近访问最频繁的目录"><a href="#使用-z-可查看最近访问最频繁的目录" class="headerlink" title="使用 z 可查看最近访问最频繁的目录"></a>使用 <code>z</code> 可查看最近访问最频繁的目录</h5><p>z + 目录名部分内容即可跳转到目录</p><h5 id="使用wd插件"><a href="#使用wd插件" class="headerlink" title="使用wd插件"></a>使用wd插件</h5><pre><code>wd                  //查看所有可用命令wd add (label_name) //标记目录wd rm (label_name)  //去除目录标记wd list             //查看所有标记 </code></pre><p>在需要添加快捷方式的目录，直接执行 wd add 标签名称即可</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep命令的实践例子</title>
      <link href="/2017/10/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20grep%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90/"/>
      <url>/2017/10/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20grep%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p><strong>grep</strong> 应该是必备到命令了，看到一篇不错到总结，记录之</p><p><strong>grep</strong>是每个<strong>Linux</strong>发行版都预装的一个强有力的文件模式搜索工具。无论何种原因，如果你的系统没有预装它的话，你可以很容易的通过系统的包管理器来安装它（<strong>Debian&#x2F;Ubuntu</strong>系中的<strong>apt-get</strong>和<strong>RHEl&#x2F;CentOS&#x2F;Fedora</strong>系中的<strong>yum</strong>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install grep #Debian/Ubuntu $ sudo yum install grep #RHEL/CentOS/Fedora </span><br></pre></td></tr></table></figure><p>我发现使用现实世界中的真实例子让你投身其中是让你接触<strong>grep</strong>命令的最容易方式。</p><h3 id="1-搜索和寻找文件"><a href="#1-搜索和寻找文件" class="headerlink" title="1.搜索和寻找文件"></a>1.搜索和寻找文件</h3><p>假设你已经在你的电脑上安装了一个全新的<strong>Ubuntu</strong>，然后你打算卸载<strong>Python</strong>。你浏览网页寻找教程，但是你发现存在两个不同版本的<strong>Python</strong>在使用，而你不知道你的<strong>Ubuntu</strong>安装器到底在你的系统中安装了哪个版本的Python，也不知道它安装了哪些模块。解决这个烦恼只需简单的运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -l | grep -i python </span><br></pre></td></tr></table></figure><h4 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii  python2.7         2.7.3-0ubuntu3.4 Interactive high-level object-oriented language (version 2.7)</span><br><span class="line">ii  python2.7-minimal 2.7.3-0ubuntu3.4 Minimal subset of the Python language (version 2.7)</span><br><span class="line">ii  python-openssl    0.12-1ubuntu2.1  Python wrapper around the OpenSSL library</span><br><span class="line">ii  python-pam        0.4.2-12.2ubuntu4 A Python interface to the PAM library</span><br></pre></td></tr></table></figure><p>首先，我们运行<strong>dpkg -l</strong>列出你系统上安装的**.deb<strong>包。接着，我们使用管道将输出结果传输给命令</strong>grep -i<strong>python，这一步可以简单解释为把结果传输给grep然后过滤出所有含有python的项，并返回结果。–i选项用于忽略大小写,因为 grep 是大小写敏感的。使用选项</strong>-i**是个好习惯，除非你打算进行更细节的搜索。</p><h3 id="2-搜索和过滤文件"><a href="#2-搜索和过滤文件" class="headerlink" title="2.搜索和过滤文件"></a>2.搜索和过滤文件</h3><p>grep还可以在一个或多个文件里用于搜索和过滤。让我们来看一个这样的情景：</p><p>你的<strong>Apache网页服务器</strong>出现了问题，你不得不从许多专业网站里找一个发帖询问。好心回复你的人让你粘贴上来你的**&#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;default-ssl**文件内容。假如你能移除掉所有的注释行，那么对你，对帮你的人，以及所有阅读该文件的人，不是更容易发现问题吗？你当然可以很容易的做到！只需这样做就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep -v &quot;#&quot; /etc/apache2/sites-available/default-ssl </span><br></pre></td></tr></table></figure><p>选项**-v<strong>是告诉</strong>grep<strong>命令反转它的输出结果，意思就是不输出匹配的项，做相反的事，打印出所有不匹配的项。这个例子中，有</strong>#**的是注释行（译注：其实这个命令并不准确，包含“#”的行不全是注释行。关于如何精确匹配注释行，可以了解更多的关于正则表达式的内容。）。</p><h3 id="3-找出所有的mp3文件"><a href="#3-找出所有的mp3文件" class="headerlink" title="3.找出所有的mp3文件"></a>3.找出所有的mp3文件</h3><p><strong>grep</strong>命令对于过滤来自于<strong>标准输出</strong>的结果非常有用。例如，假设你的一个文件夹里面全是各种格式的音乐文件。你要找出艺术家<strong>jayZ</strong>的所有<strong>mp3</strong>格式的音乐文件，里面也不要有任何混合音轨。使用<strong>find命令</strong>再结合管道使用<strong>grep</strong>就可以完成这个魔法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find . -name &quot;.mp3&quot; | grep -i JayZ | grep -vi &quot;remix&quot;&quot; </span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用find命令打印出所有以**.mp3<strong>为后缀名的文件，接着将其使用管道传递给</strong>grep -i<strong>过滤和打印出名字为“</strong>JayZ<strong>”的文件,再使用管道传送给</strong>grep -vi<strong>以便过滤掉含有“</strong>remix**”的项。</p><ul><li><a href="http://www.tecmint.com/35-practical-examples-of-linux-find-command/">35个Linux中find命令的实践例子</a></li></ul><h3 id="4-在搜索字符串前面或者后面显示行号"><a href="#4-在搜索字符串前面或者后面显示行号" class="headerlink" title="4.在搜索字符串前面或者后面显示行号"></a>4.在搜索字符串前面或者后面显示行号</h3><p>另外两个选项是-A和-B之间的切换，是用以显示匹配的行以及行号，分别控制在字符串前或字符串后显示的行数。Man页给出了更加详细的解释，我发现一个记忆的小窍门：-A&#x3D;after、-B&#x3D;before。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -A 4 etho $ sudo ifconfig | grep -B 2 UP </span><br></pre></td></tr></table></figure><h3 id="5-在匹配字符串周围打印出行号"><a href="#5-在匹配字符串周围打印出行号" class="headerlink" title="5.在匹配字符串周围打印出行号"></a>5.在匹配字符串周围打印出行号</h3><p>grep命令的**-C**选项和例4中的很相似，不过打印的并不是在匹配字符串的前面或后面的行，而是打印出两个方向都匹配的行（译注：同上面的记忆窍门一样：-C&#x3D;center，以此为中心）： $ sudo ifconfig | grep -C 2 lo</p><h3 id="6-计算匹配项的数目"><a href="#6-计算匹配项的数目" class="headerlink" title="6.计算匹配项的数目"></a>6.计算匹配项的数目</h3><p>这个功能类似于将<strong>grep</strong>输出的结果用管道传送给计数器（<strong>wc</strong>程序），grep内建的选项可以达到同样的目的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -c inet6 </span><br></pre></td></tr></table></figure><h3 id="7-按给定字符串搜索文件中匹配的行号"><a href="#7-按给定字符串搜索文件中匹配的行号" class="headerlink" title="7.按给定字符串搜索文件中匹配的行号"></a>7.按给定字符串搜索文件中匹配的行号</h3><p>当你在编译出错时需要调试时，<strong>grep</strong>命令的**-n**选项是个非常有用的功能。它能告诉你所搜索的内容在文件的哪一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep -n &quot;main&quot; setup.py </span><br></pre></td></tr></table></figure><h3 id="8-在所有目录里递归的搜索"><a href="#8-在所有目录里递归的搜索" class="headerlink" title="8.在所有目录里递归的搜索"></a>8.在所有目录里递归的搜索</h3><p>假若你要在当前文件夹里搜索一个字符串，而当前文件夹里又有很多子目录，你可以指定一个**-r**选项以便于递归的搜索： $ sudo grep -r “function” *</p><h3 id="9-进行精确匹配搜索"><a href="#9-进行精确匹配搜索" class="headerlink" title="9.进行精确匹配搜索"></a>9.进行精确匹配搜索</h3><p>传递**-w**选项给grep命令可以在字符串中进行精确匹配搜索（译注：包含要搜索的单词，而不是通配）。例如，像下面这样输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -w “RUNNING” </span><br></pre></td></tr></table></figure><p>将打印出含有引号内匹配项的行。另外，你还可以试一下这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -w “RUN” </span><br></pre></td></tr></table></figure><p>搜索这个匹配项时，若搜索的东西里面没有这样的一个单独的单词，将什么也不会返回。</p><h3 id="10-在Gzip压缩文件中搜索"><a href="#10-在Gzip压缩文件中搜索" class="headerlink" title="10.在Gzip压缩文件中搜索"></a>10.在Gzip压缩文件中搜索</h3><p>我们还要关注一下grep的衍生应用。第一个是<strong>zgrep</strong>，这个与<strong>zcat</strong>很相似，可以用于<strong>gzip</strong>压缩过的文件。它有与<strong>grep</strong>相似的命令选项，使用方式也一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo zgrep -i error /var/log/syslog.2.gz </span><br></pre></td></tr></table></figure><h3 id="11-在文件中匹配正则表达式"><a href="#11-在文件中匹配正则表达式" class="headerlink" title="11.在文件中匹配正则表达式"></a>11.在文件中匹配正则表达式</h3><p><strong>egrep</strong>是另一个衍生应用，代表着“<strong>扩展全局正则表达式</strong>”。它可以识别更多的正则表达式元字符，例如<strong>at + ?</strong> | 和<strong>（）</strong>。在搜索源代码文件时，egrep是一个非常有用的工具，还有其他的一些零碎代码文件的搜索需要，使得这样的搜索能力成为必需。可以在grep命令中使用选项**-E**来启用它。</p><p>$ sudo grep -E</p><h3 id="12-搜索一个固定匹配字符串"><a href="#12-搜索一个固定匹配字符串" class="headerlink" title="12.搜索一个固定匹配字符串"></a>12.搜索一个固定匹配字符串</h3><p><strong>fgrep</strong>用于在一个文件或文件列表中搜索固定样式的字符串。功能与<strong>grep -F</strong>同。<strong>fgrep</strong>的一个通常用法为传递一个含有样式的文件给它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fgrep -f file_full_of_patterns.txt file_to_search.txt </span><br></pre></td></tr></table></figure><p>这仅仅是<strong>grep</strong>命令的开始，你可能已经注意到，它对于实现各种各样的需求简直是太有用了。除了这种我们运行的这种只有一行的命令，<strong>grep</strong>还可以写成<strong>cron</strong>任务或者自动的<strong>shell脚本</strong>去执行。保持好奇心，试验一下<strong>man页</strong>的各个选项，为实现你的目的写出一些<strong>grep表达式</strong>吧。</p><hr><p>via: <a href="http://www.tecmint.com/12-practical-examples-of-linux-grep-command/">http://www.tecmint.com/12-practical-examples-of-linux-grep-command/</a></p><p>译者：<a href="https://github.com/Linux-pdz">Linux-pdz</a> 校对：<a href="https://github.com/jasminepeng">jasminepeng</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-zsh的环境变量配置</title>
      <link href="/2017/10/08/%E5%B7%A5%E5%85%B7/%20oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/08/%E5%B7%A5%E5%85%B7/%20oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="配置环境变量的常用文件"><a href="#配置环境变量的常用文件" class="headerlink" title="配置环境变量的常用文件"></a>配置环境变量的常用文件</h2><h3 id="全局公用配置-profile-一般不建议直接配置该文件"><a href="#全局公用配置-profile-一般不建议直接配置该文件" class="headerlink" title="全局公用配置 profile 一般不建议直接配置该文件"></a>全局公用配置 profile 一般不建议直接配置该文件</h3><pre><code>            /etc/profile</code></pre><h3 id="全局公用配置-bashrc-bash-shell-系统级别的环境配置"><a href="#全局公用配置-bashrc-bash-shell-系统级别的环境配置" class="headerlink" title="全局公用配置 bashrc  bash shell 系统级别的环境配置"></a>全局公用配置 bashrc  bash shell 系统级别的环境配置</h3><pre><code>            /etc/bashrc</code></pre><h3 id="用户级别的的配置"><a href="#用户级别的的配置" class="headerlink" title="用户级别的的配置"></a>用户级别的的配置</h3><pre><code>            ~/.bash_profile</code></pre><h2 id="zsh-现在mac一般都会安装zsh，oh-my-zsh"><a href="#zsh-现在mac一般都会安装zsh，oh-my-zsh" class="headerlink" title="zsh 现在mac一般都会安装zsh，oh-my-zsh"></a>zsh 现在mac一般都会安装zsh，oh-my-zsh</h2><h3 id="oh-my-zsh-目录：-它是zsh的安装文件夹"><a href="#oh-my-zsh-目录：-它是zsh的安装文件夹" class="headerlink" title=".oh-my-zsh 目录： 它是zsh的安装文件夹"></a><code>.oh-my-zsh</code> 目录： 它是zsh的安装文件夹</h3><h3 id="zshrc-：-zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等"><a href="#zshrc-：-zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等" class="headerlink" title=".zshrc ： zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等"></a><code>.zshrc</code> ： zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等</h3><h3 id="x2F-oh-my-zsh-x2F-custom-x2F-my-custom-zsh-用户设置自定义系统变量、自定义命令等等"><a href="#x2F-oh-my-zsh-x2F-custom-x2F-my-custom-zsh-用户设置自定义系统变量、自定义命令等等" class="headerlink" title=".&#x2F;oh-my-zsh&#x2F;custom&#x2F;my_custom.zsh:用户设置自定义系统变量、自定义命令等等"></a>.&#x2F;oh-my-zsh&#x2F;custom&#x2F;my_custom.zsh:用户设置自定义系统变量、自定义命令等等</h3><blockquote><p>zsh不建议直接操作这个默认配置，如果用户需要自定义配置，推荐.&#x2F;oh-my-zsh&#x2F;custom&#x2F;custom.zsh修改。注意：custom文件夹里的所有配置都会被zsh自动读取并配置。</p></blockquote><ul><li><p>小贴士：可以配置一个快捷方式用于编辑<code>my_custom.zsh</code></p><pre><code>          alias zshconfig=&quot;subl ~/.oh-my-zsh/custom/my_custom.zsh&quot;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆节闲记二</title>
      <link href="/2017/10/03/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%BA%8C/"/>
      <url>/2017/10/03/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前各种环境都装在阿里云上，乘着国庆假期，各种环境安装到mac上，记录一笔先，后续有坑，填坑</p></blockquote><p>之前安装好的</p><ul><li><p><input checked="" disabled="" type="checkbox"> mongo</p></li><li><p><input checked="" disabled="" type="checkbox"> nginx</p></li><li><p><input checked="" disabled="" type="checkbox"> mysql</p></li><li><p>tomcat</p></li></ul><p>查看帮助</p><pre><code>    catalina -h </code></pre><p>启动tomcat</p><pre><code>    catalina run / start</code></pre><p>关闭tomcat</p><pre><code>    catalina stop</code></pre><ul><li>ActiveMQ</li></ul><p>启动</p><pre><code>    acivemq start</code></pre><p>关闭</p><pre><code>    activemq stop        </code></pre><ul><li>zookeeper</li></ul><p>启动</p><pre><code>    zkServer start</code></pre><p>停止</p><pre><code>    zkServer stop</code></pre><p>查询状态</p><pre><code>    zkServer status</code></pre><ul><li>kafka</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆节闲记一</title>
      <link href="/2017/10/02/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%B8%80/"/>
      <url>/2017/10/02/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>国庆节了，也感觉有忙不完的事情，拿了本书回来，还没有怎么读，虽然是很早计划读完的书，到今天第一章还未读完。200多页，希望国庆内读完吧。</p></blockquote><p>晓说这个节目应该是洗澡节目吧，洗澡时，必听。。。今天在笔记本上看到三季的最新一期，于是书单里又要新增2本书了：</p><ul><li>《三体》 好吧，虽然是很早就想看的书，比重排名更往前了；</li></ul><blockquote><p><a href="https://www.amazon.cn/%E4%B8%89%E4%BD%93-%E5%88%98%E6%85%88%E6%AC%A3/dp/B00OB3SNMY/ref=sr_1_1?ie=UTF8&qid=1506958531&sr=8-1&keywords=%E4%B8%89%E4%BD%93">三体</a></p></blockquote><ul><li>《Story》</li></ul><blockquote><p><a href="https://www.amazon.cn/Story-Style-Structure-Substance-and-the-Principles-of-Screenwriting-Mckee-Robert/dp/0060391685/ref=sr_1_2?ie=UTF8&qid=1506958398&sr=8-2&keywords=robert+mckee">Story: Substance, Structure, Style and the Principles of Screenwriting</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes概览</title>
      <link href="/2017/09/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Kubernetes%E6%A6%82%E8%A7%88/"/>
      <url>/2017/09/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Kubernetes%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>这是一篇 Kubernetes 的概览。</p><p>Kubernetes 是一个<a href="http://www.slideshare.net/BrianGrant11/wso2con-us-2015-kubernetes-a-platform-for-automating-deployment-scaling-and-operations">自动化部署、伸缩和操作应用程序容器的开源平台</a>。</p><p>使用 Kubernetes，你可以快速、高效地满足用户以下的需求：</p><ul><li>快速精准地部署应用程序</li><li>即时伸缩你的应用程序</li><li>无缝展现新特征</li><li>限制硬件用量仅为所需资源</li></ul><p>我们的目标是培育一个工具和组件的生态系统，以减缓在公有云或私有云中运行的程序的压力。</p><h4 id="Kubernetes-的优势"><a href="#Kubernetes-的优势" class="headerlink" title="Kubernetes 的优势"></a>Kubernetes 的优势</h4><ul><li><strong>可移动</strong>: 公有云、私有云、混合云、多态云</li><li><strong>可扩展</strong>: 模块化、插件化、可挂载、可组合</li><li><strong>自修复</strong>: 自动部署、自动重启、自动复制、自动伸缩</li></ul><p>Google 公司于 2014 年启动了 Kubernetes 项目。Kubernetes 是在 <a href="https://research.google.com/pubs/pub43438.html">Google 的长达 15 年的成规模的产品级任务的经验下</a>构建的，结合了来自社区的最佳创意和实践经验。</p><h3 id="为什么选择容器"><a href="#为什么选择容器" class="headerlink" title="为什么选择容器?"></a>为什么选择容器?</h3><p>想要知道你为什么要选择使用 <a href="https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/">容器</a>?</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201708/22/115217h7sbftbcbb8fby6u.jpg" alt="img"></p><p>程序部署的<em>传统方法</em>是指通过操作系统包管理器在主机上安装程序。这样做的缺点是，容易混淆程序之间以及程序和主机系统之间的可执行文件、配置文件、库、生命周期。为了达到精准展现和精准回撤，你可以搭建一台不可变的虚拟机镜像。但是虚拟机体量往往过于庞大而且不可转移。</p><p>容器部署的<em>新的方式</em>是基于操作系统级别的虚拟化，而非硬件虚拟化。容器彼此是隔离的，与宿主机也是隔离的：它们有自己的文件系统，彼此之间不能看到对方的进程，分配到的计算资源都是有限制的。它们比虚拟机更容易搭建。并且由于和基础架构、宿主机文件系统是解耦的，它们可以在不同类型的云上或操作系统上转移。</p><p>正因为容器又小又快，每一个容器镜像都可以打包装载一个程序。这种一对一的“程序 - 镜像”联系带给了容器诸多便捷。有了容器，静态容器镜像可以在编译&#x2F;发布时期创建，而非部署时期。因此，每个应用不必再等待和整个应用栈其它部分进行整合，也不必和产品基础架构环境之间进行妥协。在编译&#x2F;发布时期生成容器镜像建立了一个持续地把开发转化为产品的环境。相似地，容器远比虚拟机更加透明，尤其在设备监控和管理上。这一点，在容器的进程生命周期被基础架构管理而非被容器内的进程监督器隐藏掉时，尤为显著。最终，随着每个容器内都装载了单一的程序，管理容器就等于管理或部署整个应用。</p><p>容器优势总结：</p><ul><li><strong>敏捷的应用创建与部署</strong>：相比虚拟机镜像，容器镜像的创建更简便、更高效。</li><li><strong>持续的开发、集成，以及部署</strong>：在快速回滚下提供可靠、高频的容器镜像编译和部署（基于镜像的不可变性）。</li><li><strong>开发与运营的关注点分离</strong>：由于容器镜像是在编译&#x2F;发布期创建的，因此整个过程与基础架构解耦。</li><li><strong>跨开发、测试、产品阶段的环境稳定性</strong>：在笔记本电脑上的运行结果和在云上完全一致。</li><li><strong>在云平台与 OS 上分发的可转移性</strong>：可以在 Ubuntu、RHEL、CoreOS、预置系统、Google 容器引擎，乃至其它各类平台上运行。</li><li><strong>以应用为核心的管理</strong>: 从在虚拟硬件上运行系统，到在利用逻辑资源的系统上运行程序，从而提升了系统的抽象层级。</li><li><strong>松散耦联、分布式、弹性、无拘束的微服务</strong>：整个应用被分散为更小、更独立的模块，并且这些模块可以被动态地部署和管理，而不再是存储在大型的单用途机器上的臃肿的单一应用栈。</li><li><strong>资源隔离</strong>：增加程序表现的可预见性。</li><li><strong>资源利用率</strong>：高效且密集。</li></ul><h4 id="为什么我需要-Kubernetes，它能做什么"><a href="#为什么我需要-Kubernetes，它能做什么" class="headerlink" title="为什么我需要 Kubernetes，它能做什么?"></a>为什么我需要 Kubernetes，它能做什么?</h4><p>至少，Kubernetes 能在实体机或虚拟机集群上调度和运行程序容器。而且，Kubernetes 也能让开发者斩断联系着实体机或虚拟机的“锁链”，从<strong>以主机为中心</strong>的架构跃至<strong>以容器为中心</strong>的架构。该架构最终提供给开发者诸多内在的优势和便利。Kubernetes 提供给基础架构以真正的<strong>以容器为中心</strong>的开发环境。</p><p>Kubernetes 满足了一系列产品内运行程序的普通需求，诸如：</p><ul><li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">协调辅助进程</a>，协助应用程序整合，维护一对一“程序 - 镜像”模型。</li><li><a href="https://kubernetes.io/docs/concepts/storage/volumes/">挂载存储系统</a></li><li><a href="https://kubernetes.io/docs/concepts/configuration/secret/">分布式机密信息</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">检查程序状态</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">复制应用实例</a></li><li><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">使用横向荚式自动缩放</a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/">命名与发现</a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">负载均衡</a></li><li><a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/">滚动更新</a></li><li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/">资源监控</a></li><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">访问并读取日志</a></li><li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/">程序调试</a></li><li><a href="https://kubernetes.io/docs/admin/authorization/">提供验证与授权</a></li></ul><p>以上兼具平台即服务（PaaS）的简化和基础架构即服务（IaaS）的灵活，并促进了在平台服务提供商之间的迁移。</p><h4 id="Kubernetes-是一个什么样的平台"><a href="#Kubernetes-是一个什么样的平台" class="headerlink" title="Kubernetes 是一个什么样的平台?"></a>Kubernetes 是一个什么样的平台?</h4><p>虽然 Kubernetes 提供了非常多的功能，总会有更多受益于新特性的新场景出现。针对特定应用的工作流程，能被流水线化以加速开发速度。特别的编排起初是可接受的，这往往需要拥有健壮的大规模自动化机制。这也是为什么 Kubernetes 也被设计为一个构建组件和工具的生态系统的平台，使其更容易地部署、缩放、管理应用程序。</p><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标签</a>label可以让用户按照自己的喜好组织资源。 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>annotation让用户在资源里添加客户信息，以优化工作流程，为管理工具提供一个标示调试状态的简单方法。</p><p>此外，<a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes 控制面板</a>是由开发者和用户均可使用的同样的 <a href="https://kubernetes.io/docs/reference/api-overview/">API</a> 构建的。用户可以编写自己的控制器，比如 <a href="https://git.k8s.io/community/contributors/devel/scheduler.md">调度器</a>scheduler，使用可以被通用的<a href="https://kubernetes.io/docs/user-guide/kubectl-overview/">命令行工具</a>识别的<a href="https://git.k8s.io/community/contributors/design-proposals/extending-api.md">他们自己的 API</a>。</p><p>这种<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/principles.md">设计</a>让大量的其它系统也能构建于 Kubernetes 之上。</p><h4 id="Kubernetes-不是什么？"><a href="#Kubernetes-不是什么？" class="headerlink" title="Kubernetes 不是什么？"></a>Kubernetes 不是什么？</h4><p>Kubernetes 不是传统的、全包容的平台即服务（Paas）系统。它尊重用户的选择，这很重要。</p><p>Kubernetes：</p><ul><li>并不限制支持的程序类型。它并不检测程序的框架 (例如，<a href="http://wildfly.org/">Wildfly</a>)，也不限制运行时支持的语言集合 (比如， Java、Python、Ruby)，也不仅仅迎合 <a href="https://12factor.net/">12 因子应用程序</a>，也不区分 <em>应用</em> 与 <em>服务</em> 。Kubernetes 旨在支持尽可能多种类的工作负载，包括无状态的、有状态的和处理数据的工作负载。如果某程序在容器内运行良好，它在 Kubernetes 上只可能运行地更好。</li><li>不提供中间件（例如消息总线）、数据处理框架（例如 Spark）、数据库（例如 mysql），也不把集群存储系统（例如 Ceph）作为内置服务。但是以上程序都可以在 Kubernetes 上运行。</li><li>没有“点击即部署”这类的服务市场存在。</li><li>不部署源代码，也不编译程序。持续集成 (CI) 工作流程是不同的用户和项目拥有其各自不同的需求和表现的地方。所以，Kubernetes 支持分层 CI 工作流程，却并不监听每层的工作状态。</li><li>允许用户自行选择日志、监控、预警系统。（ Kubernetes 提供一些集成工具以保证这一概念得到执行）</li><li>不提供也不管理一套完整的应用程序配置语言&#x2F;系统（例如 <a href="https://github.com/google/jsonnet">jsonnet</a>）。</li><li>不提供也不配合任何完整的机器配置、维护、管理、自我修复系统。</li></ul><p>另一方面，大量的 PaaS 系统运行<em>在</em> Kubernetes 上，诸如 <a href="https://www.openshift.org/">Openshift</a>、<a href="http://deis.io/">Deis</a>，以及 <a href="http://eldarion.cloud/">Eldarion</a>。你也可以开发你的自定义 PaaS，整合上你自选的 CI 系统，或者只在 Kubernetes 上部署容器镜像。</p><p>因为 Kubernetes 运营在应用程序层面而不是在硬件层面，它提供了一些 PaaS 所通常提供的常见的适用功能，比如部署、伸缩、负载平衡、日志和监控。然而，Kubernetes 并非铁板一块，这些默认的解决方案是可供选择，可自行增加或删除的。</p><p>而且， Kubernetes 不只是一个<em>编排系统</em> 。事实上，它满足了编排的需求。 <em>编排</em> 的技术定义是，一个定义好的工作流程的执行：先做 A，再做 B，最后做 C。相反地， Kubernetes 囊括了一系列独立、可组合的控制流程，它们持续驱动当前状态向需求的状态发展。从 A 到 C 的具体过程并不唯一。集中化控制也并不是必须的；这种方式更像是<em>编舞</em>。这将使系统更易用、更高效、更健壮、复用性、扩展性更强。</p><h4 id="Kubernetes-这个单词的含义？k8s？"><a href="#Kubernetes-这个单词的含义？k8s？" class="headerlink" title="Kubernetes 这个单词的含义？k8s？"></a>Kubernetes 这个单词的含义？k8s？</h4><p><strong>Kubernetes</strong> 这个单词来自于希腊语，含义是 <em>舵手</em> 或 <em>领航员</em> 。其词根是 <em>governor</em> 和 <a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>。 <em>K8s</em> 是它的缩写，用 8 字替代了“ubernete”。</p><hr><p>via: <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></p><p>作者：<a href="https://kubernetes.io/">kubernetes.io</a> 译者：<a href="https://github.com/songsuhang00">songshuang00</a> 校对：<a href="https://github.com/wxy">wxy</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9新特性解读</title>
      <link href="/2017/09/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/>
      <url>/2017/09/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<em>杨晓峰</em> <a href="http://mp.weixin.qq.com/s/Onj9ZJYbV5pLTAPcYBJREA##">InfoQ</a></p></blockquote><p>在历经多次跳票之后，Java 9 终于在千呼万唤中正式发布。从这个版本开始，Java 将每半年发布一个版本。作为霸占编程语言排行榜鳌头多年的老牌语言，Java 9 中有哪些不得不说的新特性？Java 语言的未来又将如何？</p><blockquote><p>针对 Java 9 新特性的介绍已经非常多了，我这里不想再做一个百科全书一样的列表，希望从不同角度简要点评部分特性。</p></blockquote><p>Jigsaw</p><p>首先，谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目，这是一个雄心勃勃的项目。</p><p>大家知道，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越来越暴露出一些问题，比如 Java 运行环境的膨胀和臃肿，各种类库和工具在提供强大功能的同时，也越来越复杂，不同版本的类库交叉依赖导致 Jar Hell 等让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</p><p>但是由于兼容性等各方面的掣肘，对 Java 进行大刀阔斧的革新越来越困难，Jigsaw 从 Java 7 阶段就开始筹备，Java 8 阶段进行了大量工作，终于在 Java 9 里落地，有种千呼万唤始出来的意味。</p><p>Jigsaw 项目的目标是改进 Java SE 平台，使其可以适应不同大小的计算设备；改进其安全性，可维护性，提高性能；简化各种类库和大型应用的开发和维护。</p><p>这个项目的工作量和难度大大超出了初始规划。JSR 376 Java 平台模块化系统（JPMS, Java Platform Module System）作为 Jigsaw 项目的核心, 其主体部分被分解成 6 个 JEP(JDK Enhancement Proposals)</p><ul><li>200: The Modular JDK</li><li>201: Modular Source Code</li><li>220: Modular Run-Time Images</li><li>260: Encapsulate Most Internal APIs</li><li>261: Module System</li><li>282: jlink: The Java Linker</li></ul><p>可以看到这是一个庞大的系统工程，Java 的方方面面，包括 JDK 编译工具，运行时，Java 公共 API 和私有代码等等，完全是一个整体性的改变。</p><p>随着 Java 平台模块化系统的落地，开发人员无需再为不断膨胀的 Java 平台苦恼，例如，您可以使用 jlink 工具，根据需要定制运行时环境。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。</p><p>从软件开发实践的角度，Java 语言层面提供对模块的支持，可以鼓励（当然在某种程度上也可以看作强制）更加规范的开发实践，利用业界在开发领域几十年的经验、教训总结出的最佳实践，促进 Java 生态的健康发展。比如，更加完善的隐藏实现细节，这不仅可以促进面向接口、约定的编程，也可以避免可能的安全风险等。</p><p>不过，换个角度来说，天下没有免费的午餐，由于 JPMS 是语言平台层面的支持，它并不是完全透明的，也就是说不管用户是否真的需要或从中收益，都会或多或少的受其影响。</p><p>对此，我们可以从 JPMS 评审中针对类似深度反射限制之类的激烈争吵中，深刻体会到。比如，针对反射访问控制，最终 Java 9 开发团队，采取了相对折中的办法，在反射领域默认保持 Java 8 的默认行为。Java 9 在兼容性方面，相比于过往的版本，采取了更大的容忍度。</p><p>不过，Java 9 的相当一部分特性仍然是对用户透明的。只要升级到 Java 9，不需要或者很少需要用户参与动作就能获益。比如，更加紧凑的字符串实现；改进的竞争锁机制；改进安全应用性能 ；利用特定 CPU 指令优化 GHASH 和 RSA 等等，这些都是开箱即用、触手可得的改进。</p><p>Java 9 值得关注的新特性</p><p>对于部分开发者来说，探究 Java 内部 API 或者平台底层能力是一件非常酷的事情，但这往往并不是非常容易，比如部分能力可能并没有在历史版本的公共 API 中暴露出来（比如 Unsafe 相关），或者需要特定领域的知识。在 Java 9 中，不要错过 JEP 193: Variable Handles 和 JEP 274: Enhanced Method Handles，JEP 259: Stack-Walking API，JEP 285: Spin-Wait Hints 等特性。</p><p>另外，Java 9 中还有很多承上启下的特性，为未来创新打下基础或者整合、规范现有碎片化的功能，我会介绍一些有代表性的新特性。</p><p>在 Java 虚拟机领域，JEP 271: Unified GC Logging 和 JEP 158：Unified JVM Logging，对各种 JVM 日志进行了统一，大家终于不用为各种碎片化的日志选项苦恼了。</p><p>Oracle 一直在努力提高 Java 启动和运行时性能，希望其能够在更广泛的场景达到或接近本地语言的性能。但是，直到今天，谈到 Java，很多 C&#x2F;C++ 开发者还是会不屑地评价为启动慢，吃内存。</p><p>简单说，这主要是因为 Java 编译产生的类文件是 Java 虚拟机可以理解的二进制代码，而不是真正的可执行的本地代码，需要 Java 虚拟机进行解释和编译，这带来了额外的开销。</p><p>JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，但是实际应用可能非常庞大，大型 Java 应用的预热往往非常耗时，而且非热点代码可能根本没有机会被 JIT 编译。</p><p>在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件，这样会大大降低启动开销。</p><p>另外 JVMCI （JEP 243: Java-Level JVM Compiler Interface）等特性，对于整个编程语言的发展，可能都具有非常重要的意义，虽然未必引起了广泛关注。目前 Graal Core API 已经被集成进入 Java 9，虽然还只是初始一小步，但是完全用 Java 语言来实现的可靠的、高性能的动态编译器，似乎不再是遥不可及，这是 Java 虚拟机开发工程师的福音。</p><p>与此同时，随着 Truffle 框架和 Substrate VM 的发展，已经让个别信心满满的工程师高呼“One VM to Rule Them All!”， 也许就在不远的将来 Ploygot 以一种另类的方式成为现实。</p><p>谈谈 Java 的未来</p><p>前面简短地谈了谈 Java 9 中的一些令人激动的特性，Java 9 在取得这些进步的同时，那么在其的研发过程中有哪些教训，当前和未来遇到了那些挑战呢？</p><p>首先，就是如何更加快速、敏捷地进行创新。在 Java 9 的开发过程中, 非常突出的一点就是，由于 Jigsaw 项目的延期，导致 Java 9 的发布一再推迟，这带来了很多负面影响。大批特性已经完成多时，却无法及时被实际应用采纳，开发者无法及时地从中获益，也很难尽早发现和反馈可能存在的问题或改进。这不禁让人反思 Java 传统的研发模式的局限性。</p><p>针对这些情况，Java 首席架构师 Mark Reinhold 已经发出倡议，建议从传统的以特性驱动的发布周期，转变为以时间驱动的（6 个月为周期）发布模式，并逐步的将 Oracle JDK 原有商业特性进行开源，Java Flight Recorder 等杀手级工具和特性，一定会大受开发者的欢迎。针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term support）。</p><p>第二，随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。传统的大型企业或互联网应用，正在被云端，容器化应用、模块化的微服务甚至是函数（FaaS， Function-as-a-Service）所替代。</p><p>Java 需要在新的计算场景下，改进开发效率。这话说的有点笼统，我谈一些自己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向，例如，JEP 286: Local-Variable Type Inference；持续改进并发计算框架，Java 的并发特性非常强大和系统，但某种程度上过于复杂，在今年的 JVMLS 上，阿里巴巴 AJDK 组介绍了利用协程改进并发的实践，这是一个令人眼前一亮的创新；Java 非常需要更加友好的本地代码支持，相关的特性有很多好的想法和尝试，比如 Panama 项目；Value Types 和改进的泛型，有兴趣可以参考 Valhalla 项目。</p><p>最后，进一步改进启动和运行性能、优化计算资源使用。目前，相当一部分的 Java 类库和虚拟机特性都是针对长时间、大数据量、高并发等复杂任务进行的优化，但是在部分云计算场景中，比如越来越引起大家关注的 FaaS 应用，短时间、无状态的函数正在成为常见的计算单元。那么在这种场景下，Java 必须进行相应的改进和创新，才能保持和强化目前在软件开发领域的竞争力。比如，提高 Java 运行时启动速度，尤其是在容器环境的初始化表现；保证 CPU 等计算资源调度能力能够适应容器环境的新情况，最直接的就是 Java 平台需要支持基于 cgroup 等技术的资源管理；针对新场景下的 GC 优化；如何提高数据密度和计算效率等等。</p><p>以上很多方面往往不是孤立的，也不是非常简单就可以完成的，很多改进都是依赖于相关语言基础技术的进步和突破，Java 的进步需要持之以恒的耐心和持续的努力与投入。</p><blockquote><p>我们再来看看java成立到现在的所有版本。</p></blockquote><p>    1990年初，最初被命名为Oak；</p><p>    1995年5月23日，Java语言诞生；</p><p>    1996年1月，第一个JDK-JDK1.0诞生；</p><p>    1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术；</p><p>    1996年9月，约8.3万个网页应用了Java技术来制作；</p><p>    1997年2月18日，JDK1.1发布；</p><p>    1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议纪录；</p><p>    1997年9月，JavaDeveloperConnection社区成员超过十万；</p><p>    1998年2月，JDK1.1被下载超过2,000,000次；</p><p>    1998年12月8日，Java 2企业平台J2EE发布；</p><p>    1999年6月，SUN公司发布Java三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）；</p><p>    2000年5月8日，JDK1.3发布；</p><p>    2000年5月29日，JDK1.4发布；</p><p>    2001年6月5日，Nokia宣布到2003年将出售1亿部支持Java的手机；</p><p>    2001年9月24日，J2EE1.3发布；</p><p>    2002年2月26日，J2SE1.4发布，此后Java的计算能力有了大幅提升；</p><p>    2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0；</p><p>    2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME；</p><p>    2006年12月，SUN公司发布JRE6.0；</p><p>    2009年4月20日，甲骨文以74亿美元的价格收购SUN公司，取得java的版权，业界传闻说这对Java程序员是个坏消息（其实恰恰相反）；</p><p>    2010年11月，由于甲骨文对Java社区的不友善，因此Apache扬言将退出JCP；</p><p>    2011年7月28日，甲骨文发布Java SE 7；</p><p>    2014年3月18日，甲骨文发表Java SE 8；</p><p>    2017年7月，甲骨文发表Java SE 9。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc总结</title>
      <link href="/2017/09/16/java/%20springmvc%E6%80%BB%E7%BB%93/"/>
      <url>/2017/09/16/java/%20springmvc%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>温故而知新，今天一起来复习一下spring mvc的内容吧。</p><blockquote><p>spring mvc简介与运行原理</p></blockquote><p>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-9409cf62de5e6d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理.png"></p><ul><li>(1) Http请求：客户端请求提交到DispatcherServlet。</li><li>(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</li><li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。</li><li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。</li><li>(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。</li><li>(8) Http响应：视图负责将结果显示到客户端。</li></ul><blockquote><p>主要注解</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4120002-59a5ee861a98c9e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spring mvc注解.png"></p><blockquote><p>ContextLoaderListener</p></blockquote><p><em>在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。</em></p><ul><li>一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。</li><li>当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param &gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet。（同类多个节点以出现顺序依次加载）</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-746980d0ad376d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web.xml加载过程.png"></p><p><em>而spring mvc启动过程大致分为两个过程：</em></p><ul><li>ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。</li><li>DispatcherServlet初始化。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-110e7ed9ccd22461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web.xml配置.png"></p><p>其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。</p><ul><li><em>ContextLoaderListener在web.xml中的配置</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置contextConfigLocation初始化参数 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置ContextLoaderListerner --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ServletContextListener 接口有两个方法:contextInitialized,contextDestroyed</p><blockquote><p>DispatcherServlet</p></blockquote><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。</p><p>下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。</p><ul><li><em>流程图</em></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-635b0216e6e74921.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spring mvc处理请求的流程.jpg"></p><ul><li><em>在web.xml中的配置</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中</p><ul><li>load-on-startup：表示启动容器时初始化该Servlet；</li><li>url-pattern：表示哪些请求交给Spring Web MVC处理， “&#x2F;” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。</li></ul><p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。</p><p>WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）</p><p><img src="https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/publish/21-2/figures/figure-21-2-typical-context-hierarchy-in-spring-web-mvc.png" alt="DispatcherServlet继承结构"></p><p>spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-d2cafcce5381cd66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特殊bean.png"></p><p>其中，常用的ViewResolver的配置。以jsp作为视图为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对模型视图名称的解析,即在模型视图名称添加前后缀 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置上传文件限制MultipartResolver</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 上传限制 --&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">     &lt;!-- 上传文件大小限制为31M，31*1024*1024 --&gt;</span><br><span class="line">     &lt;property name=&quot;maxUploadSize&quot; value=&quot;32505856&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>applicationContext.xml中的标签</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4120002-7022162217045a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="applicationContext.xml配置文件标签.png"></p><blockquote><p>文件上传</p></blockquote><p>前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。</p><ul><li><em>表单</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;</span><br><span class="line">     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">     &lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><em>控制器</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path = &quot;/form&quot;, method = RequestMethod.POST)</span><br><span class="line"> public String handleFormUpload(@RequestParam(&quot;name&quot;) String name, </span><br><span class="line">            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line"></span><br><span class="line">   if (!file.isEmpty()) &#123;</span><br><span class="line">          byte[] bytes = file.getBytes();</span><br><span class="line">          // store the bytes somewhere</span><br><span class="line">          return &quot;redirect:uploadSuccess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;redirect:uploadFailure&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>异常处理</p></blockquote><p>先来说下常见的异常处理有几种方式，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-e9a87d75a1e94c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常处理方式.png"></p><p>Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。</p><p>某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。</p><ul><li><em>HandlerExceptionResolver 提供resolveException接口</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerExceptionResolver &#123;  </span><br><span class="line">    ModelAndView resolveException(  </span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><em>在BaseController中使用 @ExceptionHandler注解处理异常</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(Exception.class)</span><br><span class="line">public Object exceptionHandler(Exception ex, HttpServletResponse response, </span><br><span class="line">             HttpServletRequest request) throws IOException &#123;</span><br><span class="line">String url = &quot;&quot;;</span><br><span class="line">String msg = ex.getMessage();</span><br><span class="line">Object resultModel = null;</span><br><span class="line">try &#123;</span><br><span class="line">if (ex.getClass() == HttpRequestMethodNotSupportedException.class) &#123;</span><br><span class="line">url = &quot;admin/common/500&quot;;</span><br><span class="line">System.out.println(&quot;--------毛有找到对应方法---------&quot;);</span><br><span class="line">&#125; else if (ex.getClass() == ParameterException.class) &#123;//自定义的异常</span><br><span class="line">                               </span><br><span class="line">&#125; else if (ex.getClass() == UnauthorizedException.class) &#123;</span><br><span class="line">url = &quot;admin/common/unauth&quot;;</span><br><span class="line">System.out.println(&quot;--------毛有权限---------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String header = req.getHeader(&quot;X-Requested-With&quot;);</span><br><span class="line">boolean isAjax = &quot;XMLHttpRequest&quot;.equalsIgnoreCase(header);</span><br><span class="line">String method = req.getMethod();</span><br><span class="line">boolean isPost = &quot;POST&quot;.equalsIgnoreCase(method);</span><br><span class="line"></span><br><span class="line">if (isAjax || isPost) &#123;</span><br><span class="line">return Message.error(msg);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ModelAndView view = new ModelAndView(url);</span><br><span class="line">view.addObject(&quot;error&quot;, msg);</span><br><span class="line">view.addObject(&quot;class&quot;, ex.getClass());</span><br><span class="line">view.addObject(&quot;method&quot;, request.getRequestURI());</span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception exception) &#123;</span><br><span class="line">logger.error(exception.getMessage(), exception);</span><br><span class="line">return resultModel;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">logger.error(msg, ex);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>*在web.xml中处理异常 *</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 默认的错误处理页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">&lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">&lt;location&gt;/403.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">&lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">&lt;location&gt;/404.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&gt;</span><br><span class="line">&lt;!-- 这样配置也是可以的，表示发生500错误的时候，转到500.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;error-code&gt;500&lt;/error-code&gt; </span><br><span class="line">&lt;location&gt;/500.html&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; </span><br><span class="line">&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"></span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; </span><br><span class="line">&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 当error-code和exception-type都配置时，exception-type配置的页面优先级高及出现500错误，发生异常Exception时会跳转到500.jsp--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>来一个问题：HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？</li></ul><p><em>解答</em>：如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： ** return a corresponding ModelAndView to forward to, or null for default processing.**</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh 设置别名的方式访问服务器</title>
      <link href="/2017/09/07/%E5%B7%A5%E5%85%B7/%20ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/09/07/%E5%B7%A5%E5%85%B7/%20ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Windows上时，一般通过各种客户端(putty、SecureCRT等)连接到远程服务器，而切换到了Mac上，有了强大的终端，自然要好好用起来了。<span id="more"></span> 一般在终端上通过 ssh 命令进行远程服务器登录。</p></blockquote><h3 id="远程登录服务器命令-ssh"><a href="#远程登录服务器命令-ssh" class="headerlink" title="远程登录服务器命令 ssh"></a>远程登录服务器命令 ssh</h3><ul><li>ssh username@ip地址</li></ul><p>例如： ssh <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#49;&#57;&#50;&#46;&#49;&#54;&#56;&#x2e;&#49;&#49;&#46;&#x32;">&#x72;&#111;&#111;&#116;&#x40;&#49;&#57;&#50;&#46;&#49;&#54;&#56;&#x2e;&#49;&#49;&#46;&#x32;</a></p><p>but 服务端一般多台服务器，好几个ip地址，记住这么多ip地址好难，但是根据不同服务器的用途给他们起个别名，就方便多了，能想到自然能实现，这里简述下具体玩法~</p><h3 id="给服务器起个别名"><a href="#给服务器起个别名" class="headerlink" title="给服务器起个别名"></a>给服务器起个别名</h3><ol><li><p>在 <code>~/.ssh/</code> 目录下，新建一个config（有的话，就不用建了噻）</p></li><li><p>vim config 文件，进行编辑</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host dev</span><br><span class="line">HostName xxx.xx.xx.xx</span><br><span class="line">User root</span><br><span class="line">IdentitiesOnly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ul><li>Host 别名 起一个自己记得住的，比如开发环境 dev 测试环境 test  ..</li><li>HostName 服务器的ip address    </li><li>User 远程登录的用户名</li><li>IdentitiesOnly yes 反正这个就配置yes</li></ul><h3 id="ssh-别名-走起"><a href="#ssh-别名-走起" class="headerlink" title="ssh 别名 走起"></a>ssh 别名 走起</h3><p>配置好文件后，直接 键入 ssh dev 就玩起来了</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 开发常用的终端命令</title>
      <link href="/2017/09/06/%E5%89%8D%E7%AB%AF/%20web%20%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/09/06/%E5%89%8D%E7%AB%AF/%20web%20%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-开发常用的终端命令"><a href="#Web-开发常用的终端命令" class="headerlink" title="Web 开发常用的终端命令"></a>Web 开发常用的终端命令</h2><p>终端是开发人员的军火库中最重要的生产力工具之一。把它掌握好了可以对你的工作产生非常积极的影响。</p><p>这里记录一些常用到的命令</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><a href="https://curl.haxx.se/">curl</a></h2><p>curl 是一个命令行工具，用来通过 HTTP（s），FTP 等其它几十种你可能尚未听说过的协议来发起网络请求。它可以下载文件，检查响应消息头以及方便地访问远程数据。</p><p>在 Web 开发中， curl 经常被用来测试连接，还有调用 REST 风格的 API。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fetch the headers of a URL.</span></span><br><span class="line">curl -I http://google.com</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Referrer-Policy: no-referrer</span><br><span class="line">Location: http://www.google.com/?gfe_rd=cr&amp;ei=0fCKWe6HCZTd8AfCoIWYBQ</span><br><span class="line">Content-Length: 258</span><br><span class="line">Date: Wed, 09 Aug 2017 11:24:01 GMT</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request to a remote API.</span></span><br><span class="line">curl http://numbersapi.com/random/trivia</span><br><span class="line">29 is the number of days it takes Saturn to orbit the Sun.</span><br></pre></td></tr></table></figure><p>curl 的用法还可以比这更复杂。它有许多选项可以用来控制消息头，Cookie，身份验证等等这些要素。你可以通过 <a href="https://ec.haxx.se/">Everything curl</a> 这本优秀的电子书来了解更多。</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a><a href="https://www.computerhope.com/unix/tree.htm">tree</a></h2><p>tree 是一个小巧的命令行工具程序，它可以用可视化的效果向你展示一个目录下的文件。它的运行是递归的，会以树的形式遍历每个级别的嵌套关系，并显示出每一级目录。 如此你就可以快速地进行浏览并找到自己想要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">├── fonts</span><br><span class="line">│   ├── glyphicons-halflings-regular.eot</span><br><span class="line">│   ├── glyphicons-halflings-regular.svg</span><br><span class="line">│   ├── glyphicons-halflings-regular.ttf</span><br><span class="line">│   ├── glyphicons-halflings-regular.woff</span><br><span class="line">│   └── glyphicons-halflings-regular.woff2</span><br><span class="line">└── js</span><br><span class="line">    ├── bootstrap.js</span><br><span class="line">    └── bootstrap.min.js</span><br></pre></td></tr></table></figure><p>它还拥有使用一种类正则表达式的模式来对结果集进行过滤的选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree -P <span class="string">&#x27;*.min.*&#x27;</span></span><br><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">├── fonts</span><br><span class="line">└── js</span><br><span class="line">    └── bootstrap.min.js</span><br></pre></td></tr></table></figure><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><a href="https://tmux.github.io/">tmux</a></h2><p>根据维基的描述，tmux 是一个终端复用器，说人话就是，它是一个可以将多个终端连接到单个终端会话的工具。</p><p><img src="https://static.oschina.net/uploads/space/2017/0906/104206_TcXC_2903254.jpg" alt="img"></p><p>一个 tmux 终端带有三个分屏的效果</p><p>它让你可以在一个终端中进行程序之间的切换，添加分屏窗格，还有就是将多个终端连接到同一个会话，使它们保持同步。 当你在远程服务器上工作时，tmux 特别有用，因为它可以让你创建新的选项卡，然后在选项卡之间切换，而无需反反复复的退出然后登录。</p><h2 id="disk-usage-du"><a href="#disk-usage-du" class="headerlink" title="disk usage - du"></a><a href="https://www.computerhope.com/unix/udu.htm">disk usage - du</a></h2><p>运行 du 命令会生成相关文件和有关目录的空间使用情况的报告。它很容易使用，也可以递归地运行，会遍历每个子目录并且返回每个文件的单个大小。<br>du 通常在你发现某个驱动器的空间不足，但不知道是因为什么造成的时候使用。使用此命令可以快速查看每个文件夹所占用的存储空间，从而把耗费存储的大户给找出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running this will show the space usage of each folder in the current directory.</span></span><br><span class="line"><span class="comment"># The -h option makes the report easier to read.</span></span><br><span class="line"><span class="comment"># -s prevents recursiveness and shows the total size of a folder.</span></span><br><span class="line"><span class="comment"># The star wildcard (*) will run du on each file/folder in current directory.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> -sh *</span><br><span class="line"></span><br><span class="line">1.2G    Desktop</span><br><span class="line">4.0K    Documents</span><br><span class="line">40G     Downloads</span><br><span class="line">4.0K    Music</span><br><span class="line">4.9M    Pictures</span><br><span class="line">844K    Public</span><br><span class="line">4.0K    Templates</span><br><span class="line">6.9M    Videos</span><br></pre></td></tr></table></figure><p>还有一个用途类似的命令 <a href="https://www.computerhope.com/unix/udf.htm">df</a>（Disk Free），它会返回关于可用磁盘空间的各种信息（与 du 正好相反）。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a><a href="https://git-scm.com/">git</a></h2><p>git 是迄今为止最流行的版本控制系统。它是现代 Web 开发的指定工具之一，我们根本没办法把它从列表中给删掉。</p><p>尽管有很多的第三方应用和工具可用，但是大多数人还是喜欢通过终端对 git 来进行本地访问。git CLI 真的很强大，可以用来处理那些盘根错节的项目历史。</p><p>如果想了解更多的关于 git 的信息，建议你看看我们的教程“<a href="https://tutorialzine.com/2016/06/learn-git-in-30-minutes">30 分钟学会用 Git</a>”。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a><a href="https://www.computerhope.com/unix/utar.htm">tar</a></h2><p>tar 是用来处理文件压缩的默认 Unix 工具。它能让你快速的将多个文件打成一个包，这样在后续就更加容易存储和移动它们了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf archive.tar file1 file2 file3</span><br></pre></td></tr></table></figure><p>使用 -x 选项可以对现有的 .tar 压缩包进行解压缩操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf archive.tar</span><br></pre></td></tr></table></figure><p>注意大多数其它的格式，像 .zip 和 .rar 这些，都不能使用 tar 来打开，而是需要用其它的像 <a href="https://www.computerhope.com/unix/unzip.htm">unzip</a> 这样的工具来进行操作。</p><p>如今许多的 Unix 系统都运行着一个 tar 的扩展版本 (GNU tar) ，它也还可以执行限定文件大小的压缩操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create compressed gzip archive.</span></span><br><span class="line">tar -czf file.tar.gz inputfile1 inputfile2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract .gz archive.</span></span><br><span class="line">tar -xzf file.tar.gz</span><br></pre></td></tr></table></figure><p>如果你的操作系统并不支持该版本的 tar，还可以使用 <a href="http://www.gzip.org/">gzip</a>, <a href="https://linux.die.net/man/1/zcat">zcat</a> 或者 <a href="https://www.computerhope.com/unix/ucompres.htm">compress</a> 来限制文件压缩包的大小。</p><h2 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a><a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a></h2><p>Unix 内置了一些像 <a href="https://www.computerhope.com/unix/md5sum.htm">md5sum</a>、<a href="https://en.wikipedia.org/wiki/Sha1sum">sha1sum</a> 这样的命令行工具，它们在编程中有各自的作用，但最重要的是它们可以用来检查文件的完整性。</p><p>譬如，如果你从不受信的网络下载了一个 .iso 文件，这个文件中存在恶意脚本的风险。为了确认这个 .iso 是安全的，你可以生成它的 md5 或者其它摘要信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> ubuntu-16.04.3-desktop-amd64.iso </span><br><span class="line"></span><br><span class="line">0d9fe8e1ea408a5895cbbe3431989295  ubuntu-16.04.3-desktop-amd64.iso</span><br></pre></td></tr></table></figure><p>然后将生成的字符串与原作者提供的（比如 <a href="https://help.ubuntu.com/community/UbuntuHashes">UbuntuHashes</a>）进行比较。</p><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a><a href="http://hisham.hm/htop/">htop</a></h2><p>Htop 是个比内置的 top 任务管理更强大的工具。它提供了带有诸多选项的高级接口用于监控系统进程。</p><p><img src="https://static.oschina.net/uploads/space/2017/0906/104427_IuFg_2903254.jpg" alt="img"></p><p><em>运行中的 htop 任务管理器</em></p><p>虽然 htop 在终端中运行，但它对鼠标操作支持良好。所以使用 htop 的菜单导航、选择进程，以及通过排序和过滤来管理任务都很容易。</p><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a><a href="https://www.computerhope.com/unix/uln.htm">ln</a></h2><p>Unix 里面的链接同 Windows 中的快捷方式类似，允许你快速地访问到一个特定的文件。链接可以通过 ln 命令创建出来，而且可以有两种类型 : 硬的（hard） 或者符号的（symbolic）。每种类型都有不同的属性而且各有其用途 (<a href="https://www.computerhope.com/unix/uln.htm">了解更多</a>)。</p><p>这里有一个示例，展示了使用链接的最常见方式。假如说我们在桌面上有一个目录叫做 <em>Scripts</em>，里面整齐的摆放着我们最常用的 bash 脚本。每次我们想要调用其中的一个脚本的时候，我们会这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Desktop/Scripts/git-scripts/git-cleanup</span><br></pre></td></tr></table></figure><p>显然，这样做并不方便，每次我们都得写绝对路径。其实我们可以创建一个 symlink，将 <em>Scripts</em>  文件夹链接到 <em>&#x2F;usr&#x2F;local&#x2F;bin</em>，这样就能让脚本在所有的目录下面都可以执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s ~/Desktop/Scripts/git-scripts/git-cleanup /usr/local/bin/</span><br></pre></td></tr></table></figure><p>有了这个创建好的 symlink，我们现在就可以简单地通过其名称在任意一个打开的终端中执行脚本了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-cleanup</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a><a href="https://www.ssh.com/ssh/command/">ssh</a></h2><p>使用 ssh 命令，用户可以快速地连接到一个远程主机，然后登录进入其 Unix shell。这就使得通过自己本地机器的终端在服务器上提交指令成为了可能。</p><p>要定位一个连接，你只需要指定正确的 IP 地址或者 url 就行了。在你第一次连接到一台新的服务器的时候，会需要某种形式的认证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><p>如果你需要快速地在服务器上面执行一条命令，但又不想登录，在 url 之后加上一条命令就可以了。命令将会在服务器上执行，而执行结果也会从它那里返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host <span class="built_in">ls</span> /var/www</span><br><span class="line"></span><br><span class="line">some-website.com</span><br><span class="line">some-other-website.com</span><br></pre></td></tr></table></figure><p>你还可以用 SHH 做更多事情，像创建代理或者隧道，用私钥来保护你的连接，传输文件等。在<a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys">这里的一个指南</a>中你可以了解到更多信息。</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a><a href="https://www.computerhope.com/unix/ugrep.htm">grep</a></h2><p>grep 是一个用来在文本中查找字符串的标准 Unix 工具。它可以从一个文件或者直接就是流的形式获取到输入, 通过一个正则表达式来分析内容，然后返回匹配的行。</p><p>该命令在需要对大型文件进行内容过滤的时候非常趁手。下面我们利用 grep 结合 date 命令，来在一个大型的日志文件中进行查找，然后生成一个只包含当天错误日志的新文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Search <span class="keyword">for</span> today<span class="string">&#x27;s date (in format yyyy-mm-dd) and write the results to a new file. </span></span><br><span class="line"><span class="string">grep &quot;$(date +&quot;%Y-%m-%d&quot;)&quot; all-errors-ever.log &gt; today-errors.log</span></span><br></pre></td></tr></table></figure><p>另外一个用来操作字符串的强大工具就是 <a href="https://www.computerhope.com/unix/used.htm">sed</a>。它比起 grep 更加强大 (当然也更加复杂)，可以执行几乎所有的字符串相关的操作任务，包括添加、删除还有替换字符串的内容。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a><a href="https://www.computerhope.com/unix/ualias.htm">alias</a></h2><p>许多的 Unix 命令，包括本文中提到的一些，在你加上许多选项之后，看起来都相当的长了。为了能更加容易记忆，你可以使用 alias 这个 bash 内置的命令来为它们创建一个短别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create an alias for starting a local web server.</span></span><br><span class="line"><span class="built_in">alias</span> server=<span class="string">&quot;python -m SimpleHTTPServer 9000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instead of typing the whole command simply use the alias.</span></span><br><span class="line">server </span><br><span class="line"></span><br><span class="line">Serving HTTP on 0.0.0.0 port 9000 ...</span><br></pre></td></tr></table></figure><p>只要你保持终端一直是打开的状态， 别名就一直会是可用的。如果想永久使用的话，你可以将 alias  命令操作写到你的 .bashrc 文件中去。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2 快捷操作</title>
      <link href="/2017/08/26/%E5%B7%A5%E5%85%B7/%20iTerm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/26/%E5%B7%A5%E5%85%B7/%20iTerm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些 iTerm2 的常用快捷操作，方便提高效率</p></blockquote><h2 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h2><ul><li>ctrl + a: 到行首</li><li>ctrl + e: 行末</li><li>ctrl + f&#x2F;b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li><li>ctrl + p: 上一条命令，相当于方向键上</li><li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li><li>ctrl + d: 删除当前字符</li><li>ctrl + h: 删除之前的字符</li><li>ctrl + w: 删除光标前的单词</li><li>ctrl + k: 删除到文本末尾</li><li>ctrl + t: 交换光标处文本</li><li>ctrl + u: 删除一行</li><li>⌘ + —&#x2F;+&#x2F;0: 调整字体大小</li><li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li></ul><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul><li>新建窗口：shift + command + d（横向）command + d（竖向）</li><li>关闭窗口：shift + command + w</li><li>前一个窗口：command + &#96;</li><li>后一个窗口：command + ~</li><li>进入窗口 1,2,3：option + command + 编号</li></ul><h2 id="标签页操作"><a href="#标签页操作" class="headerlink" title="标签页操作"></a>标签页操作</h2><ul><li>新建标签页: Command + T</li><li>关闭标签页: Command + W</li><li>前一个标签页: Command + 左方向键，Shift + Command + [</li><li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li><li>进入标签页1，2，3…: Command + 标签页编号</li><li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li></ul><h2 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h2><ul><li>垂直分割: Command + D</li><li>水平分割: Shift + Command + D</li><li>前一个面板: Command + [</li><li>后一个面板: Command + ]</li><li>切换到上&#x2F;下&#x2F;左&#x2F;右面板: Option + Command + 上下左右方向键</li></ul><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ul><li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show&#x2F;hide iTerm2 with a system-wide hotkey 打上勾之后</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + &#x2F;</li><li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h2 id="文本选取"><a href="#文本选取" class="headerlink" title="文本选取"></a>文本选取</h2><p>文本选取有使用鼠标和不使用鼠标两种方式。</p><p>使用鼠标</p><p>默认情况下，选取的文字会自动复制到剪切板，可以使用以下方式进行文本选取：</p><ul><li>常见的点击并拖拽方式</li><li>双击选取整个单词</li><li>三击选取整行</li><li>选取某一部分，按住Shift，再点击某处，可以选取整个矩形内的文本（类似Windows下按住Shift可以批量选取图标）</li><li>按住Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住Command然后点击某个URL，会在浏览器中打开这个URL，点击某个文件夹，会在Finder里打开这个文件夹（再也不用open . 啦），点击某个文件名，会打开这个文件（文本文件支持MacVim，TextMate和BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回Linux的感觉了）</li></ul><p>不使用鼠标</p><p>(这种方式最多只能选取一行文本) 使用 Command + f，会呼出一个搜索框，可以在当前面板中进行搜索，输入想要选取的部分内容，输入过程中，按Tab可以将选取部分向右扩展，按Shift + Tab向左扩展，按回车转到下一个匹配位置。使用Tab或Shift+Tab扩展得到想要的内容之后，选取内容会自动复制到剪切板，再次按Command + f隐藏搜索框。</p><h2 id="位置书签"><a href="#位置书签" class="headerlink" title="位置书签"></a>位置书签</h2><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p><h2 id="粘贴历史"><a href="#粘贴历史" class="headerlink" title="粘贴历史"></a>粘贴历史</h2><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p><h2 id="即时回放"><a href="#即时回放" class="headerlink" title="即时回放"></a>即时回放</h2><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p><h2 id="窗口状态"><a href="#窗口状态" class="headerlink" title="窗口状态"></a>窗口状态</h2><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动iTerm2时自动恢复窗口状态</p><h2 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h2><ul><li>command+; 根据上下文呼出自动完成窗口，上下键选择</li><li>全屏 command+enter</li><li>光标去哪了？command+&#x2F;</li><li>用鼠标选中某个路径或者某个词汇就自动复制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 从Windows 迁移到Mac 上继续玩耍</title>
      <link href="/2017/08/25/%E6%9D%82%E8%AE%B0/%20hexo%20%E4%BB%8EWindows%20%E8%BF%81%E7%A7%BB%E5%88%B0Mac%20%E4%B8%8A%E7%BB%A7%E7%BB%AD%E7%8E%A9%E8%80%8D/"/>
      <url>/2017/08/25/%E6%9D%82%E8%AE%B0/%20hexo%20%E4%BB%8EWindows%20%E8%BF%81%E7%A7%BB%E5%88%B0Mac%20%E4%B8%8A%E7%BB%A7%E7%BB%AD%E7%8E%A9%E8%80%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近刚刚入手Mac，各种体验Mac的妙处，后面有时间把总结的各种坑记录下，这次先把基本的工具搬迁过来~</p><p>hexo 的搬家路： windows -&gt; mac </p></blockquote><h2 id="迁移思路"><a href="#迁移思路" class="headerlink" title="迁移思路"></a>迁移思路</h2><ul><li>在mac上安装好 <code>hexo</code>，初始化根目录；</li><li>然后生成新的 <code>SSH key</code>，并将其添加到 <code>github</code>；</li><li>将Windows上的资源、配置复制、直接粘贴覆盖Mac上对应的目录。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>安装 node&#x2F;git</strong></p><p>homebrew 安装：</p><p>​brew install node</p><p>​brew install git</p><p><strong>安装 hexo</strong></p><p>用 node 的 npm 安装 hexo：</p><pre><code>    npm install hexo-cli -g</code></pre><ul><li><p>每个版本安装方式可能不一样，这一步需要异步到 官网 </p></li><li><p><a href="https://hexo.io/">hexo 官网</a></p></li></ul><p><strong>初始化 hexo</strong></p><p>hexo init blog<br>cd blog<br>npm install<br>hexo server</p><p>启动成功</p><pre><code>    INFO  Start processing    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p><strong>生成 SSH key</strong><br>先检查一下本机的 SSH key：<code>cd ~/.ssh</code>；<br>生成 SSH key：<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>，<a href="mailto:&#x78;&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#120;&#x78;&#x78;&#64;&#x78;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#x6d;</a> 为自己注册 github 的邮箱；</p><p><strong>添加 SSH key 至 github</strong><br>进入.ssh文件夹： <code>cd ~/.ssh</code>，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：<em>Settings -&gt; SSH and GPG keys</em>，点击绿色的按钮 <em>New SSH key</em>，然后在输入框中输入刚才复制的内容；</p><p>使用coding的，同理</p><p>测试一下是否成功：<code>ssh git@github.com</code>，<br>看到以下即成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi gjincai! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure><p><strong>文件配置转移</strong><br>windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes；<br>把这几个文件复制到mac的目录下，直接覆盖替换相同的文件文件夹。</p><p>哦了！在mac上愉快的玩耍 <code>hexo</code> 吧！</p><ul><li>注意： 如果在 <code>hexo d</code> 部署不成功，有可能是缺少了模块，</li></ul><p>安装以下再尝试：<code>npm install hexo-deployer-git --save</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行使用技巧</title>
      <link href="/2017/08/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/08/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="最实用的-Linux-命令行使用技巧-【已翻译100-】"><a href="#最实用的-Linux-命令行使用技巧-【已翻译100-】" class="headerlink" title="最实用的 Linux 命令行使用技巧 【已翻译100%】"></a>最实用的 Linux 命令行使用技巧 【已翻译100%】</h1><p>英文原文：<a href="https://dzone.com/articles/most-useful-linux-command-line-tricks">Most Useful Linux Command Line Tricks</a></p><hr><p>我们可能每天都会要使用到很多的 <a href="https://likegeeks.com/main-linux-commands-easy-guide/">Linux 命令行</a>。 我们也会网络上知晓一些使用它们的小技巧，但是如果我们没有时常来进行练习，就有可能会忘掉怎么去使用它们。 所以我就决定把那些你可能会忘记的小提示和小技巧，或者对你而言可能是全新的东西都列表来。</p><h2 id="将输出内容以表格的形式显示出来"><a href="#将输出内容以表格的形式显示出来" class="headerlink" title="将输出内容以表格的形式显示出来"></a>将输出内容以表格的形式显示出来</h2><p>有时，在你看到命令行执行的输出时，因为字符串过度拥挤（比如说 mount 命令的输出）导致输出内容难以识别。如果我们看到的内容是一张表格会如何呢？其实这是很容易做到的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column –t:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091303_TBUa_2903254.png" alt="img"></p><p>在此例中，由于内容中留了空格，所以输出的形式就美观了起来。 那如果想要的分隔符是别的什么符号，比如说冒号，又该怎么去做呢？ （例如，在 cat&#x2F;etc&#x2F;passwd 的输出内容中使用）</p><p>这时候只需要使用 -s 参数指定分隔符就行了，像下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | column -t -s:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091553_PTLs_2903254.png" alt="img"></p><h2 id="重复执行一个命令，直到它运行成功"><a href="#重复执行一个命令，直到它运行成功" class="headerlink" title="重复执行一个命令，直到它运行成功"></a>重复执行一个命令，直到它运行成功</h2><p>如果在 Google 上搜索这个功能，你会发现很多人都问到了如何重复执行命令，直到这个命令成功返回并且运行正常。 Google上的建议里就包括 ping 服务器，直到它变得空闲为止，还有就是检查是否有向特定的目录上传了具有特定扩展名的文件，还有就是检查特定的URL是否已经存在，诸如此类的办法。</p><p>其实你还可以使用 while true 的循环来实现来实现这个功能：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/091607_Z6PD_2903254.png" alt="img"></p><p>在上面这个示例中，&gt;&#x2F;dev&#x2F;null 2&gt;＆1 会让程序的输出重定向到 &#x2F;dev&#x2F; null。标准错误和标准输出都会被包含进去。</p><p>这是我认为最酷的Linux命令行技巧之一。</p><h2 id="按内存资源的使用量对进程进行排序"><a href="#按内存资源的使用量对进程进行排序" class="headerlink" title="按内存资源的使用量对进程进行排序"></a>按内存资源的使用量对进程进行排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | sort -rnk 4:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091735_Hqk6_2903254.png" alt="img"></p><h2 id="按-CPU-资源的使用量对进程进行排序"><a href="#按-CPU-资源的使用量对进程进行排序" class="headerlink" title="按 CPU 资源的使用量对进程进行排序"></a>按 CPU 资源的使用量对进程进行排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | sort -nk 3:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091900_QTKd_2903254.png" alt="img"></p><p>如果想要检查你的机器架构，那就执行 getconf LONG_BIT。</p><h2 id="可以同时查看多个日志文件"><a href="#可以同时查看多个日志文件" class="headerlink" title="可以同时查看多个日志文件"></a>可以同时查看多个日志文件</h2><p>毫无疑问，你可能已经会使用 tail  命令来查看日志文件了，但可能有时候你还想着能同时查看多个日志文件。 使用 multi-tail 命令就支持支持文本的高亮显示，内容过滤以及更多你可能需要的功能：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/091924_12e3_2903254.png" alt="img"><img src="https://static.oschina.net/uploads/space/2017/0823/091937_H48w_2903254.png" alt="img"></p><p>如果系统里还没有这个命令，运行 apt-get install multitail 命令就可以把它给装上。</p><h2 id="回到你操作过的上一个目录去"><a href="#回到你操作过的上一个目录去" class="headerlink" title="回到你操作过的上一个目录去"></a>回到你操作过的上一个目录去</h2><p>只需敲入 cd - 就会返回到你操作过的上一个目录中去。</p><h2 id="让非交互式-Shell-会话可进行交互"><a href="#让非交互式-Shell-会话可进行交互" class="headerlink" title="让非交互式 Shell 会话可进行交互"></a>让非交互式 Shell 会话可进行交互</h2><p>想要这样做，那就把设置从 ~&#x2F;.bashrc 改成 ~&#x2F;.bash_profile 吧。</p><h2 id="定时的监视性命令输出"><a href="#定时的监视性命令输出" class="headerlink" title="定时的监视性命令输出"></a>定时的监视性命令输出</h2><p>使用 watch 命令（watch df -h），你就可以查看到任何命令的任何输出。例如，你可以查看可用空间以及它的使用量增长情况。</p><p>通过利用 watch 命令来操作会变化的数据，你可以尽情想象自己能拿这个来做些什么哦。</p><h2 id="在会话关掉以后继续运行程序"><a href="#在会话关掉以后继续运行程序" class="headerlink" title="在会话关掉以后继续运行程序"></a>在会话关掉以后继续运行程序</h2><p>如果你在后台运行了什么程序，然后你关掉了的 shell 会话，那么这个后台运行的程序就会被你的 shell 杀掉。关闭 shell 以后怎么让程序继续运行下去呢？</p><p>这个可以用 nohup 命令做到 - 该指令表示不做挂断操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup wget site.com/file.zip</span><br></pre></td></tr></table></figure><p>此命令是最容易被遗忘的 Linux 命令行技巧之一，因为我们许多人都会使用另外一个类命令的 screen 环境：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092000_PnE3_2903254.png" alt="img"></p><p>这样会在同一个目录下生成一个名称为 nohup.out 的文件，其中包含了正在运行的程序的输出内容：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092013_Bvae_2903254.png" alt="img"></p><p>命令很酷，对吧？</p><h2 id="自动对任何命令回答-Yes-或者-No"><a href="#自动对任何命令回答-Yes-或者-No" class="headerlink" title="自动对任何命令回答 Yes 或者 No"></a>自动对任何命令回答 Yes 或者 No</h2><p>如果你想自动化需要向用户说的 Yes 的过程，可以使用 yes 命令来实现：yes | apt-get update。</p><p>也许你想做的是自动地说“No”。这个可以使用 yes no | 命令来实现。</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092025_pFb6_2903254.png" alt="img"></p><h2 id="创建具有指定大小的文件"><a href="#创建具有指定大小的文件" class="headerlink" title="创建具有指定大小的文件"></a>创建具有指定大小的文件</h2><p>可以使用 dd 命令来创建出具有指定大小的文件：dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;out.txt bs&#x3D;1M count&#x3D;10。</p><p>这样就会创建出一个 10 MB 的文件，填充零作为内容：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092151_LtpJ_2903254.png" alt="img"></p><h2 id="以根目录用户来运行最后一个命令"><a href="#以根目录用户来运行最后一个命令" class="headerlink" title="以根目录用户来运行最后一个命令"></a>以根目录用户来运行最后一个命令</h2><p>有时，你会忘记在需要 root 权限的命令之前敲入 sudo。这时候你没必要去重写命令; 只要输入 sudo 就行了！</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092206_tCmM_2903254.png" alt="img"></p><h2 id="对命令行会话进行记录"><a href="#对命令行会话进行记录" class="headerlink" title="对命令行会话进行记录"></a>对命令行会话进行记录</h2><p>如果想要把自己在 shell 屏幕上敲的内容记录下来，可以使用 script 命令将所有敲写的内容保存到一个名为 typescriptscript 的文件中去。</p><p>等你敲入 exit 命令以后，所有命令就都会被写入该文件，以便你事后再回过头去查看。</p><h2 id="用标签符号替换空格符"><a href="#用标签符号替换空格符" class="headerlink" title="用标签符号替换空格符"></a>用标签符号替换空格符</h2><p>可以使用 tr 命令替换任何字符，这个用起来非常方便：cat geeks.txt | tr ‘:[space]:’ ‘\t’ &gt; out.txt.</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092230_Phyw_2903254.png" alt="img"></p><h2 id="将文件内容转换为大写或者小写"><a href="#将文件内容转换为大写或者小写" class="headerlink" title="将文件内容转换为大写或者小写"></a>将文件内容转换为大写或者小写</h2><p>可以这样实现：cat myfile | tr a-z A-Z&gt; output.txt。</p><h2 id="强大的-Xargs-命令"><a href="#强大的-Xargs-命令" class="headerlink" title="强大的 Xargs 命令"></a>强大的 Xargs 命令</h2><p>xargs 命令是最重要的 Linux 命令行技巧之一。你可以使用这个命令将命令的输出作为参数传递给另一个命令。例如，搜索 png 文件然后对其进行压缩或者其它操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find. -name *.png -type f -print | xargs tar -cvzf images.tar.gz</span><br></pre></td></tr></table></figure><p>又或者你的文件中有一个 URL 的列表，而你想要做的是以不同的方式下载或者处理这些 URL，可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat urls.txt | xargs wget</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/092303_cq15_2903254.png" alt="img"></p><p><img src="https://static.oschina.net/uploads/img/201708/23092445_75a4.png" alt="xargs command"></p><p>请你要记得，第一个命令的输出会在 xargs 命令结尾处传递。</p><p>那如果命令需要中间过程的输出，该怎么办呢？这个简单！</p><p>只需要使用 {} 并结合 -i 参数就行了。如下所示，替换在第一个命令的输出应该去的地方的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/*.conf | xargs -i cp &#123;&#125; /home/likegeeks/Desktop/out</span><br></pre></td></tr></table></figure><p>这只是 Linux 命令行技巧其中的几个而已。你可以使用其他命令来做一些更 HAPPY 的事情，比如 awk 命令和 sed 命令！</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OX上安装MongoDb</title>
      <link href="/2017/08/24/%E6%9D%82%E8%AE%B0/%20Mac%20OX%E4%B8%8A%E5%AE%89%E8%A3%85MongoDb/"/>
      <url>/2017/08/24/%E6%9D%82%E8%AE%B0/%20Mac%20OX%E4%B8%8A%E5%AE%89%E8%A3%85MongoDb/</url>
      
        <content type="html"><![CDATA[<p>在mac上安装mongodb有很多方式，HomeBrew 安装 MongoDB是最快速简洁的，也方便后面的维护，这次主要记录使用brew安装的方式</p><ul><li><a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/">官方安装文档</a></li></ul><p>更新Homebrew的package源，在Mac的终端中输入：</p><pre><code>$ brew update</code></pre><h2 id="开始安装MongoDB"><a href="#开始安装MongoDB" class="headerlink" title="开始安装MongoDB"></a>开始安装MongoDB</h2><pre><code>$ brew install mongodb</code></pre><p>然后等待MongoDB下载完成。</p><pre><code>==&gt; Downloading https://homebrew.bintray.com/bottles/mongodb-3.4.7.sierra.bottle.1.tar.gz######################################################################## 100.0%==&gt; Pouring mongodb-3.4.7.sierra.bottle.1.tar.gz==&gt; CaveatsTo have launchd start mongodb now and restart at login:  brew services start mongodbOr, if you don&#39;t want/need a background service you can just run:  mongod --config /usr/local/etc/mongod.conf==&gt; Summary🍺  /usr/local/Cellar/mongodb/3.4.7: 19 files, 281.9MB</code></pre><h2 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h2><p>上面最后提示的直接启动MongoDb的方法.</p><pre><code>mongod —config /usr/local/etc/mongod.conf</code></pre><p>后台方式启动</p><p>   nohup mongod —config &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mongod.conf &amp;</p><h2 id="关闭MongoDB服务"><a href="#关闭MongoDB服务" class="headerlink" title="关闭MongoDB服务"></a>关闭MongoDB服务</h2><p>在 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongo.html#bin.mongo"><code>mongo</code></a> shell中使用 <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> 方法来关闭 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> ，如下所示：</p><pre><code>use admindb.shutdownServer()</code></pre><p>对于启用 <a href="http://docs.mongoing.com/manual-zh/reference/configuration-options.html#security.authorization"><code>authorization</code></a> 的系统，通过验证登陆到 <code>admin</code> 数据库，或者在为开启验证的情况下经由本地主机的系统接口登陆到 <code>admin</code> 数据库时，用户可以仅仅通过发送 <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> 来关闭实例。</p><p>For systems with <a href="http://docs.mongoing.com/manual-zh/reference/configuration-options.html#security.authorization"><code>authorization</code></a> enabled, users may only issue <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> when authenticated to the <code>admin</code> database or via the localhost interface on systems without authentication enabled.</p><h3 id="使用-shutdown"><a href="#使用-shutdown" class="headerlink" title="使用 --shutdown"></a>使用 <code>--shutdown</code></h3><p>从Linux命令行关闭 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> ，可以使用 <em>–shutdown</em> 选项 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongod --shutdown</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-CTRL-C"><a href="#使用-CTRL-C" class="headerlink" title="使用 CTRL-C"></a>使用 <code>CTRL-C</code></h3><p>当正在运行一个交互模式 (i.e. without <em>–fork</em>) 的 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> 实例时，发送 <code>Control-C</code> 来进行正常关闭。</p><h3 id="使用-kill"><a href="#使用-kill" class="headerlink" title="使用 kill"></a>使用 <code>kill</code></h3><p>From the Linux command line, shut down a specific <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> instance using one of the following commands:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill &lt;mongod process ID&gt;</span><br><span class="line">kill -2 &lt;mongod process ID&gt;</span><br></pre></td></tr></table></figure><h2 id="连接到MongoDb-直接在命令行使用mongo连接："><a href="#连接到MongoDb-直接在命令行使用mongo连接：" class="headerlink" title="连接到MongoDb,直接在命令行使用mongo连接："></a>连接到MongoDb,直接在命令行使用mongo连接：</h2><p>$ mongo</p><pre><code>MongoDB shell version v3.4.7connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.7Server has startup warnings:2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten]2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten]&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 键盘快捷键</title>
      <link href="/2017/08/12/%E6%9D%82%E8%AE%B0/%20Mac%20%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/08/12/%E6%9D%82%E8%AE%B0/%20Mac%20%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-键盘快捷键"><a href="#Mac-键盘快捷键" class="headerlink" title="Mac 键盘快捷键"></a>Mac 键盘快捷键</h1><p>把<a href="https://support.apple.com/zh-cn/HT201236">官方</a>这个文档，搬过来学习系统快捷键，熟悉使用快捷键将会提升自己的工作效率。</p><p>您可以按下组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。</p><p>要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如，要使用快捷键 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常<a href="https://support.apple.com/kb/PH18802?locale=zh_CN">对某些按键使用符号</a>，其中包括以下修饰键：</p><ul><li><p>Command ⌘</p></li><li><p>Shift ⇧</p></li><li><p>Option ⌥</p></li><li><p>Control ⌃</p></li><li><p>Caps Lock ⇪</p></li><li><p>Fn</p></li></ul><p>如果您使用的是 Windows PC 专用键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。有些 Mac 键盘在顶行中设有特殊按键，快捷键中也会用到它们；这些按键上有音量图标、显示屏亮度图标和其他功能图标。按下图标键可执行相应功能，将其与 Fn 键组合可用作 F1、F2、F3 或其他标准功能键。 </p><p>要了解更多快捷键，请查看您所用应用的菜单。每个应用都有自己的快捷键，在一个应用中有用的快捷键可能不能用于另一个应用。</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="剪切、拷贝、粘贴和其他常用快捷键"><a href="#剪切、拷贝、粘贴和其他常用快捷键" class="headerlink" title="剪切、拷贝、粘贴和其他常用快捷键"></a>剪切、拷贝、粘贴和其他常用快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-X</td><td><strong>剪切</strong>所选项并拷贝到剪贴板。</td></tr><tr><td>Command-C</td><td>将所选项<strong>拷贝</strong>到剪贴板。这同样适用于“访达”中的文件。</td></tr><tr><td>Command-V</td><td>将剪贴板的内容<strong>粘贴</strong>到当前文稿或应用中。这同样适用于“访达”中的文件。</td></tr><tr><td>Command-Z</td><td><strong>撤销</strong>前一个命令。随后您可以按 Command-Shift-Z 来<strong>重做</strong>，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。</td></tr><tr><td>Command-A</td><td><strong>全选</strong>各项。</td></tr><tr><td>Command-F</td><td><strong>查找</strong>文稿中的项目或打开“查找”窗口。</td></tr><tr><td>Command-G</td><td><strong>再次查找</strong>：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command-Shift-G。</td></tr><tr><td>Command-H</td><td><strong>隐藏</strong>最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Command-Option-H。</td></tr><tr><td>Command-M</td><td>将最前面的窗口<strong>最小化</strong>至“程序坞”。要最小化最前面的应用的所有窗口，请按 Command-Option-M。</td></tr><tr><td>Command-N</td><td><strong>新建：</strong>打开一个新文稿或窗口。</td></tr><tr><td>Command-O</td><td><strong>打开</strong>所选项，或打开一个对话框以选择要打开的文件。</td></tr><tr><td>Command-P</td><td><strong>打印</strong>当前文稿。</td></tr><tr><td>Command-S</td><td><strong>存储</strong>当前文稿。</td></tr><tr><td>Command-W</td><td><strong>关闭</strong>最前面的窗口。要关闭应用的所有窗口，请按下 Command-Option-W。</td></tr><tr><td>Command-Q</td><td><strong>退出</strong>应用。</td></tr><tr><td>Option-Command-Esc</td><td><strong>强制退出</strong>：选择要<a href="https://support.apple.com/zh-cn/HT201276">强制退出</a>的应用。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的应用退出。</td></tr><tr><td>Command–空格键</td><td><strong>“聚焦”</strong>：显示或隐藏 <a href="https://support.apple.com/zh-cn/HT201744">“聚焦”</a> 搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。如果您<a href="https://support.apple.com/kb/PH21564?locale=zh_CN">使用多个输入源</a>以便用不同的语言键入内容，这些快捷键会<a href="https://support.apple.com/kb/PH21554?locale=zh_CN">更改输入源而非显示“聚焦”</a>。</td></tr><tr><td>空格键</td><td><strong>快速查看</strong>：使用<a href="https://support.apple.com/zh-cn/HT201067">快速查看</a>来预览所选项。</td></tr><tr><td>Command-Tab</td><td><strong>切换应用</strong>：在打开的应用中切换到下一个最近使用的应用。</td></tr><tr><td>Shift-Command-波浪号 (~)</td><td><strong>切换窗口</strong>：切换到最前端应用中下一个最近使用的窗口。</td></tr><tr><td>Shift-Command-3</td><td><strong>屏幕快照</strong>：拍摄整个屏幕的屏幕快照。<a href="https://support.apple.com/zh-cn/HT201361">了解更多屏幕快照快捷键</a>。</td></tr><tr><td>Command-逗号 (,)</td><td><strong>偏好设置</strong>：打开最前面的应用的偏好设置。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="睡眠、退出登录和关机快捷键"><a href="#睡眠、退出登录和关机快捷键" class="headerlink" title="睡眠、退出登录和关机快捷键"></a>睡眠、退出登录和关机快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>电源按钮</td><td>按下可打开 Mac 电源或将 Mac 从睡眠状态唤醒。当 Mac 处于唤醒状态时，按住这个按钮 1.5 秒钟会显示一个对话框，询问您是要睡眠、重新启动还是关机。如果您不想等待 1.5 秒钟，请按下 Control–电源按钮或 Control–介质推出键 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">。*按住这个按钮 5 秒钟会强制 Mac 关机。</td></tr><tr><td>Control–Command–电源按钮</td><td>强制 Mac 重新启动。*</td></tr><tr><td>Control–Shift–电源按钮或Control–Shift–介质推出键<img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>将显示器置于睡眠状态。*</td></tr><tr><td>Control–Command–介质推出键 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>退出所有应用，然后重新启动 Mac。如果任何打开的文稿有未存储的更改，系统就会询问您要不要存储这些更改。*</td></tr><tr><td>Control–Option–Command–电源按钮或Control–Option–Command–介质推出键<img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>退出所有应用，然后关闭 Mac。如果任何打开的文稿有未存储的更改，系统就会询问您要不要存储这些更改。*</td></tr><tr><td>Shift-Command-Q</td><td>退出登录您的 macOS 用户帐户。系统将提示您确认。</td></tr><tr><td>Option-Shift-Command-Q</td><td>立即退出登录您的 macOS 用户帐户，且系统不提示您确认。</td></tr></tbody></table><p>*不适用于带有<a href="https://support.apple.com/zh-cn/HT207055">触控栏</a>的键盘。</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="文稿快捷键"><a href="#文稿快捷键" class="headerlink" title="文稿快捷键"></a>文稿快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-B</td><td>以粗体显示所选文本，或者打开或关闭粗体显示功能。</td></tr><tr><td>Command-I</td><td>以斜体显示所选文本，或者打开或关闭斜体显示功能。</td></tr><tr><td>Command-U</td><td>对所选文本加下划线，或者打开或关闭加下划线功能。</td></tr><tr><td>Command-T</td><td>显示或隐藏“字体”窗口。</td></tr><tr><td>Command-D</td><td>从“打开”对话框或“存储”对话框中选择“桌面”文件夹。</td></tr><tr><td>Control-Command-D</td><td>显示或隐藏所选字词的定义。</td></tr><tr><td>Shift-Command-冒号 (:)</td><td>显示“拼写和语法”窗口。</td></tr><tr><td>Command-分号 (;)</td><td>查找文稿中拼写错误的字词。</td></tr><tr><td>Option-Delete</td><td>删除插入点左边的字词。</td></tr><tr><td>Control-H</td><td>删除插入点左边的字符。也可以使用 Delete 键。</td></tr><tr><td>Control-D</td><td>删除插入点右边的字符。也可以使用 Fn-Delete。</td></tr><tr><td>Fn-Delete</td><td>在没有向前删除 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/osx/modfdl.png" alt=" "> 键的键盘上向前删除。也可以使用 Control-D。</td></tr><tr><td>Control-K</td><td>删除插入点与行或段落末尾处之间的文本。</td></tr><tr><td>Command-Delete</td><td>在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。</td></tr><tr><td>Fn–上箭头</td><td>Page Up：向上滚动一页。</td></tr><tr><td>Fn–下箭头</td><td>Page Down：向下滚动一页。</td></tr><tr><td>Fn–左箭头</td><td>Home：滚动到文稿开头。</td></tr><tr><td>Fn–右箭头</td><td>End：滚动到文稿末尾。</td></tr><tr><td>Command–上箭头</td><td>将插入点移至文稿开头。</td></tr><tr><td>Command–下箭头</td><td>将插入点移至文稿末尾。</td></tr><tr><td>Command–左箭头</td><td>将插入点移至当前行的行首。</td></tr><tr><td>Command–右箭头</td><td>将插入点移至当前行的行尾。</td></tr><tr><td>Option–左箭头</td><td>将插入点移至上一字词的词首。</td></tr><tr><td>Option–右箭头</td><td>将插入点移至下一字词的词尾。</td></tr><tr><td>Shift–Command–上箭头</td><td>选中插入点与文稿开头之间的文本。</td></tr><tr><td>Shift–Command–下箭头</td><td>选中插入点与文稿末尾之间的文本。</td></tr><tr><td>Shift–Command–左箭头</td><td>选中插入点与当前行行首之间的文本。</td></tr><tr><td>Shift–Command–右箭头</td><td>选中插入点与当前行行尾之间的文本。</td></tr><tr><td>Shift–上箭头</td><td>将文本选择范围扩展到上一行相同水平位置的最近字符处。</td></tr><tr><td>Shift–下箭头</td><td>将文本选择范围扩展到下一行相同水平位置的最近字符处。</td></tr><tr><td>Shift–左箭头</td><td>将文本选择范围向左扩展一个字符。</td></tr><tr><td>Shift–右箭头</td><td>将文本选择范围向右扩展一个字符。</td></tr><tr><td>Option–Shift–上箭头</td><td>将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。</td></tr><tr><td>Option–Shift–下箭头</td><td>将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。</td></tr><tr><td>Option–Shift–左箭头</td><td>将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。</td></tr><tr><td>Option–Shift–右箭头</td><td>将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。</td></tr><tr><td>Control-A</td><td>移至行或段落的开头。</td></tr><tr><td>Control-E</td><td>移至行或段落的末尾。</td></tr><tr><td>Control-F</td><td>向前移动一个字符。</td></tr><tr><td>Control-B</td><td>向后移动一个字符。</td></tr><tr><td>Control-L</td><td>将光标或所选内容置于可见区域中央。</td></tr><tr><td>Control-P</td><td>上移一行。</td></tr><tr><td>Control-N</td><td>下移一行。</td></tr><tr><td>Control-O</td><td>在插入点后插入一行。</td></tr><tr><td>Control-T</td><td>将插入点后面的字符与插入点前面的字符交换。</td></tr><tr><td>Command–左花括号 ({)</td><td>左对齐。</td></tr><tr><td>Command–右花括号 (})</td><td>右对齐。</td></tr><tr><td>Shift–Command–竖线 (|)</td><td>居中对齐。</td></tr><tr><td>Option-Command-F</td><td>前往搜索栏。</td></tr><tr><td>Option-Command-T</td><td>显示或隐藏应用中的工具栏。</td></tr><tr><td>Option-Command-C</td><td>拷贝样式：将所选项的格式设置拷贝到剪贴板。</td></tr><tr><td>Option-Command-V</td><td>粘贴样式：将拷贝的样式应用到所选项。</td></tr><tr><td>Option-Shift-Command-V</td><td>粘贴并匹配样式：将周围内容的样式应用到粘贴在这个内容中的项目。</td></tr><tr><td>Option-Command-I</td><td>显示或隐藏检查器窗口。</td></tr><tr><td>Shift-Command-P</td><td>页面设置：显示用于选择文稿设置的窗口。</td></tr><tr><td>Shift-Command-S</td><td>显示“存储为”对话框或复制当前文稿。</td></tr><tr><td>Shift–Command–减号 (-)</td><td>缩小所选项。</td></tr><tr><td>Shift–Command–加号 (+)</td><td>放大所选项。Command–等号 (&#x3D;) 可执行相同的功能。</td></tr><tr><td>Shift–Command–问号 (?)</td><td>打开“帮助”菜单。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="“访达”快捷键"><a href="#“访达”快捷键" class="headerlink" title="“访达”快捷键"></a>“访达”快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-D</td><td>复制所选文件。</td></tr><tr><td>Command-E</td><td>推出所选磁盘或宗卷。</td></tr><tr><td>Command-F</td><td>在“访达”窗口中开始“聚焦”搜索。</td></tr><tr><td>Command-I</td><td>显示所选文件的“显示简介”窗口。</td></tr><tr><td>Shift-Command-C</td><td>打开“电脑”窗口。</td></tr><tr><td>Shift-Command-D</td><td>打开“桌面”文件夹。</td></tr><tr><td>Shift-Command-F</td><td>打开“我的所有文件”窗口。</td></tr><tr><td>Shift-Command-G</td><td>打开“前往文件夹”窗口。</td></tr><tr><td>Shift-Command-H</td><td>打开当前 macOS 用户帐户的个人文件夹。</td></tr><tr><td>Shift-Command-I</td><td>打开 <a href="https://support.apple.com/zh-cn/HT201104">iCloud 云盘</a>。</td></tr><tr><td>Shift-Command-K</td><td>打开“网络”窗口。</td></tr><tr><td>Option-Command-L</td><td>打开“下载”文件夹。</td></tr><tr><td>Shift-Command-O</td><td>打开“文稿”文件夹。</td></tr><tr><td>Shift-Command-R</td><td>打开“隔空投送”窗口。</td></tr><tr><td>Shift-Command-T</td><td>将所选的“访达”项目添加到“程序坞”（OS X Mountain Lion 或更低版本）</td></tr><tr><td>Control-Shift-Command-T</td><td>将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）</td></tr><tr><td>Shift-Command-U</td><td>打开“实用工具”文件夹。</td></tr><tr><td>Option-Command-D</td><td>显示或隐藏 <a href="https://support.apple.com/zh-cn/HT201730">“程序坞”</a>。即使您未在“访达”窗口中，这个快捷键通常也有效。</td></tr><tr><td>Control-Command-T</td><td>将所选项添加到边栏（OS X Mavericks 或更高版本）。</td></tr><tr><td>Option-Command-P</td><td>隐藏或显示“访达”窗口中的路径栏。</td></tr><tr><td>Option-Command-S</td><td>隐藏或显示“访达”窗口中的边栏。</td></tr><tr><td>Command–斜线 (&#x2F;)</td><td>隐藏或显示“访达”窗口中的状态栏。</td></tr><tr><td>Command-J</td><td>显示“显示”选项。</td></tr><tr><td>Command-K</td><td>打开“连接服务器”窗口。</td></tr><tr><td>Command-L</td><td>为所选项制作替身。</td></tr><tr><td>Command-N</td><td>打开一个新的“访达”窗口。</td></tr><tr><td>Shift-Command-N</td><td>新建文件夹。</td></tr><tr><td>Option-Command-N</td><td>新建智能文件夹。</td></tr><tr><td>Command-R</td><td>显示所选替身的原始文件。</td></tr><tr><td>Command-T</td><td>在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。</td></tr><tr><td>Shift-Command-T</td><td>显示或隐藏“访达”标签页。</td></tr><tr><td>Option-Command-T</td><td>在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。</td></tr><tr><td>Option-Command-V</td><td>移动：将剪贴板中的文件从原始位置移动到当前位置。</td></tr><tr><td>Option-Command-Y</td><td>显示所选文件的<a href="https://support.apple.com/zh-cn/HT201067">快速查看</a>幻灯片显示。</td></tr><tr><td>Command-Y</td><td>使用“快速查看”预览所选文件。</td></tr><tr><td>Command-1</td><td>以图标方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-2</td><td>以列表方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-3</td><td>以分栏方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-4</td><td>以封面流方式显示“访达”窗口中的项目。</td></tr><tr><td>Command–左中括号 ([)</td><td>前往上一文件夹。</td></tr><tr><td>Command–右中括号 (])</td><td>前往下一文件夹。</td></tr><tr><td>Command–上箭头</td><td>打开包含当前文件夹的文件夹。</td></tr><tr><td>Command–Control–上箭头</td><td>在新窗口中打开包含当前文件夹的文件夹。</td></tr><tr><td>Command–下箭头</td><td>打开所选项。</td></tr><tr><td>Command–“调度中心”</td><td>显示桌面。即使您未在“访达”窗口中，这个快捷键也有效。</td></tr><tr><td>Command–调高亮度</td><td>开启或关闭<a href="https://support.apple.com/zh-cn/HT204592">目标显示器模式</a>。</td></tr><tr><td>Command–调低亮度</td><td>当 Mac 连接到多个显示器时打开或关闭显示器镜像功能。</td></tr><tr><td>右箭头</td><td>打开所选文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td>左箭头</td><td>关闭所选文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td>Option-连按</td><td>在单独的窗口中打开文件夹，并关闭当前窗口。</td></tr><tr><td>Command-连按</td><td>在单独的标签页或窗口中打开文件夹。</td></tr><tr><td>Command-Delete</td><td>将所选项移到废纸篓。</td></tr><tr><td>Shift-Command-Delete</td><td>清倒废纸篓。</td></tr><tr><td>Option-Shift-Command-Delete</td><td>清倒废纸篓而不显示确认对话框。</td></tr><tr><td>Command-Y</td><td>使用“快速查看”预览文件。</td></tr><tr><td>Option–调高亮度</td><td>打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。</td></tr><tr><td>Option–“调度中心”</td><td>打开“调度中心”偏好设置。</td></tr><tr><td>Option–调高音量</td><td>打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。</td></tr><tr><td><em>按住 Command 键拖移</em></td><td>将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option 键拖移</em></td><td>拷贝拖移的项目。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option-Command 键拖移</em></td><td>为拖移的项目制作替身。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option 键点按开合三角</em></td><td>打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td><em>按住 Command 键点按窗口标题</em></td><td>查看包含当前文件夹的文件夹。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><ul><li><a href="https://support.apple.com/zh-cn/HT201255">Mac 启动时可以使用的快捷键</a></li><li><a href="https://support.apple.com/zh-cn/HT204434">辅助功能的快捷键</a></li><li><a href="https://support.apple.com/kb/PH19282?locale=zh_CN">“Safari 浏览器”8 (Yosemite) 的快捷键</a></li><li><a href="https://support.apple.com/kb/PH21483?locale=zh_CN">“Safari 浏览器”9 (El Capitan) 的快捷键</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用指令详解</title>
      <link href="/2017/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx运维常用指令详解"><a href="#Nginx运维常用指令详解" class="headerlink" title="Nginx运维常用指令详解"></a>Nginx运维常用指令详解</h2><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ul><li><p>一、主配置文件框架解析</p></li><li><ul><li><a href="#main_cfg_para">1、Main配置段常用参数</a></li><li><a href="#event_cfg_para">2、event配置段常用参数</a></li><li><a href="#http_cfg_para">3、http配置段常用参数</a></li><li><a href="#clinet_cfg_para">4、面向客户端请求相关的配置</a></li><li><a href="#client_limit">5、对客户端请求进行限制</a></li><li><a href="#file_cfg_para">6、文件操作优化相关的配置</a></li></ul></li><li><p><a href="#ngx_http_access_module">二、ngx_http_access_module模块</a></p></li><li><p><a href="#ngx_http_auth_basic_module">三、ngx_http_auth_basic_module模块</a></p></li><li><p><a href="#ngx_http_log_module">四、ngx_http_log_module模块</a></p></li><li><p><a href="#ngx_http_stub_status_module">五、ngx_http_stub_status_module模块</a></p></li><li><p><a href="#ngx_http_referer_module">六、ngx_http_referer_module模块</a></p></li><li><p><a href="#ngx_http_ssl_module">七、ngx_http_ssl_module模块</a></p></li><li><p><a href="#ngx_http_rewrite_module">八、ngx_http_rewrite_module模块</a></p></li><li><p><a href="#ngx_http_gzip_module">九、ngx_http_gzip_module模块</a></p></li><li><p><a href="#ngx_http_fastcgi_module">十、ngx_http_fastcgi_module模块</a></p></li><li><p><a href="#ngx_http_proxy_module">十一、ngx_http_proxy_module模块</a></p></li><li><p><a href="#ngx_http_headers_module">十二、ngx_http_headers_module模块</a></p></li><li><p><a href="#ngx_http_upstream_module">十三、ngx_http_upstream_module模块</a></p></li></ul><hr><h1 id="nginx常用配置详解"><a href="#nginx常用配置详解" class="headerlink" title="nginx常用配置详解"></a>nginx常用配置详解</h1><h2 id="一、主配置文件框架解析"><a href="#一、主配置文件框架解析" class="headerlink" title="一、主配置文件框架解析"></a>一、主配置文件框架解析</h2><h4 id="1、Main配置段常用参数"><a href="#1、Main配置段常用参数" class="headerlink" title="1、Main配置段常用参数"></a><span id="main_cfg_para">1、Main配置段常用参数</span></h4><h6 id="1-正常运行必备的配置指令"><a href="#1-正常运行必备的配置指令" class="headerlink" title="(1) 正常运行必备的配置指令"></a>(1) 正常运行必备的配置指令</h6><ul><li><p><code>uesr USERNAME [GROUPNAME];</code></p></li><li><ul><li>指定用于运行worker进程的用户和组,默认是nginx用户,nginx组</li></ul></li><li><p><code>pid /path/to/pid_file;</code></p></li><li><ul><li>指定nginx进程的PID文件路径, 默认为:pid &#x2F;var&#x2F;runl&#x2F;nginx&#x2F;nginx.pid</li></ul></li><li><p><code>worker_rlimit_nofile #;</code></p></li><li><ul><li>指定每个worker进程能打开的最大文件描述符数量(nofile: number of file)</li></ul></li><li><p><code>worker_rlimit_sigpending #;</code></p></li><li><ul><li>指定每个用户能够发往worker进程的信号的最大数量</li></ul></li></ul><h6 id="2-性能优化相关的配置"><a href="#2-性能优化相关的配置" class="headerlink" title="(2) 性能优化相关的配置"></a>(2) 性能优化相关的配置</h6><ul><li><p><code>woker_processes #;</code></p></li><li><ul><li>worker进程的个数,通常应该为物理CPU核心数量减1或者减2,worker_processes auto;可以根据物理CPU自动设定. worker不使用进程或线程处理请求, 而是直接将worker绑定到CPU上, 这样就没有进程切换的说法了.</li></ul></li><li><p><code>worker_cpu_affinity CPUMASK CPUMASK...;</code></p></li><li><ul><li>将worker进程与指定的CPU进行绑定,这种绑定不能隔离CPU,CPU还可能会响应其它进程请求.</li></ul></li><li><p><code>worker_priority NICE;</code></p></li><li><ul><li>[-20,19],worker进程的优先级, 默认为0</li></ul></li></ul><h6 id="3-调试定位问题的配置"><a href="#3-调试定位问题的配置" class="headerlink" title="(3)调试定位问题的配置"></a>(3)调试定位问题的配置</h6><ul><li><p><code>daemon [off|on];</code></p></li><li><ul><li>是否以守护进程方式启动nginx</li></ul></li><li><p><code>master_process [on | off];</code></p></li><li><ul><li>是否以master&#x2F;worker模型运行nginx,off后,只单个进程启动Nignx.</li></ul></li><li><p><code>error_log /path/to/error_log Level;</code></p></li><li><ul><li>错误日志文件及级别, 出于调试的需要,可以设定为debug,但在debug级别在编译时使用—with-debug选项时才有效</li></ul></li></ul><h4 id="2、event配置段常用参数"><a href="#2、event配置段常用参数" class="headerlink" title="2、event配置段常用参数"></a><span id="event_cfg_para">2、event配置段常用参数</span></h4><ul><li><p><code>worker_connections #;</code></p></li><li><ul><li>每个worker进程所能够响应的最大并发请求数量, 请求的最大上限为:worker_processes * worker_connections</li></ul></li><li><p><code>use [epoll | rgsig | select | poll]]</code></p></li><li><ul><li>定义使用的事件模型, 建议让nginx自动选择</li></ul></li><li><p><code>accept_mutex [on | off];</code></p></li><li><ul><li>定义内部调用请求至worker时请求的互斥锁文件(各worker接收用户的请求的负载均衡锁),on:能够让多个worker轮流地,序列化的响应新请求</li></ul></li><li><p><code>lockfile /path/to/lockfile</code></p></li><li><ul><li>锁文件定义位置</li></ul></li></ul><h4 id="3、http配置段常用参数"><a href="#3、http配置段常用参数" class="headerlink" title="3、http配置段常用参数"></a><span id="http_cfg_para">3、http配置段常用参数</span></h4><ul><li><p><code>server &#123;&#125;</code></p></li><li><ul><li>定义一个虚拟主机,server可以出现一次或多次</li></ul></li><li><p><code>listen address [:port] [default_server] [[ssl] [http2 | spdy]]</code></p></li><li><p><code>listen port [default_server] [ssl] [http2 | spdy]</code></p></li><li><ul><li>default_server:设置默认虚拟主机, 当用户使用IP地址访问时,就返回default_server的虚拟主机, 如果未定义default_server时,第一个虚拟主机将做为默认的主机</li><li>ssl : 用于限制只能通过SSL连接提供服务,不是以端口确认其协议的, 故需要启用ssl,需要在监听的端口后面, 添加ssl选项</li><li>spdy : spdy protocol(google研发的http协议,比http&#x2F;1.1性能要好, 全称为speedy),在编译时编译了spdy模块的情况下,用于支持spdy协议</li><li>http2 : http version2,在编译时需要开启http2协议支持</li></ul></li><li><p><code>server_name NAME [....];</code> : 指明主机名称</p></li><li><ul><li><p>(1) 先做精确匹配,例如:<a href="http://www.zhenping.me/">www.zhenping.me</a></p></li><li><p>(2) 左侧通配符,例如:*.zhenping.me</p></li><li><p>(3) 右侧通配符,例如:<a href="http://www.zhenping/">www.zhenping</a>.*</p></li><li><p>(4) 正则表达式匹配,例如:~^.*.zhenping.me$</p></li><li><p>default_server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx默认工作法则: 先将域的匹配规则,先做hash计算,把计算的结果放置进内存,下次访问请求过来时, 直接做对比</span><br></pre></td></tr></table></figure></li><li><p>servername后可跟一个或多个主机名, 名称还可以使用通配符和正则表达式(~),域名匹配顺序</p></li></ul></li><li><p><code>tcp_nodelay [on | off];</code></p></li><li><ul><li>对keepalive模式下的连接是否使用tcp_nodelay选项,默认关闭.其功能为:把多个小报文合并为一个报文,一起发送. 此机制可以提高带宽利用率,将发往同一个主机很小的TCP报文合并成一个,实际生产对于用户请求即使浪费带宽也不能合并请求</li></ul></li><li><p><code>tcp_nopush [on | off];</code></p></li><li><ul><li>是否启用tcp_nopush(FreeBSD)或tcp_cork(linux)选项,仅在sendfile为on时有用, 其功能:尝试将多个报文首部压缩成一个发送, 默认为off,不启用该功能</li></ul></li><li><p><code>sendfile [on | off];</code></p></li><li><ul><li>是否启用sendfile功能,静态文件直接在内核中封装响应,而不是从内核空间到用户空间封装后,再发往内核空间.</li></ul></li><li><p><code>roo /PATH/TO/Directory;</code></p></li><li><ul><li>设置web资源的路径映射,用于指明请求的URL所对应的文件的目录路径,可用于server或location中.</li></ul></li><li><p><code>location [ = | ~ | ~* | ^~ ] url &#123; ...&#125;</code></p></li><li><p><code>location @name &#123;...&#125;</code></p></li><li><ul><li><code>=</code> : URI的精确匹配</li><li><code>~</code> : 做正则表达式匹配,区分字符大小写</li><li><code>~*</code> : 做正则表达式匹配,不区分字符大小写</li><li><code>^~</code> : URI的左半部分匹配,不区分字符大小写</li><li>允许根据用户请求的URI来匹配定义的各location,匹配到时, 此请求将被相应的location块中的配置所处理, 简言之:用于为需要用到专用配置的uri提供特定配置.</li><li>当匹配多次时,其匹配优先级为:精确匹配&#x3D;,^<del>,</del>或~*,不带符号的URL, 如果优先级都一样, 就匹配最精确的规则</li></ul></li><li><p><code>alias</code></p></li><li><ul><li>只能用于location配置段,用于定义路径别名</li></ul></li><li><p><code>index</code></p></li><li><ul><li>设置默认主页(nginx_http_index_module模块引入), 可以带上变量,如$geo根据不同IP地址来设置不同的语言主页,应用上下文为:http,server,location</li></ul></li><li><p><code>error_page code ...[=[response]] uri;</code></p></li><li><ul><li>自定义错误页面,根据http状态码重写向错误页面</li></ul></li><li><p><code>try_files file... uri;</code></p></li><li><p><code>try_files file... =code;</code></p></li><li><ul><li>可用于server,location中, 以指定的顺序检查文件的存在性响应</li><li>尝试查找第1至第N-1个文件,第一个即为返回给请求者的资源,若1至N-1文件都不存在, 则跳转至最后一个uri(必须 不能匹配至当前location,而应该匹配至其它location,否则会导致死循环)</li></ul></li></ul><h4 id="4、面向客户端请求相关的配置"><a href="#4、面向客户端请求相关的配置" class="headerlink" title="4、面向客户端请求相关的配置"></a><span id="clinet_cfg_para">4、面向客户端请求相关的配置</span></h4><ul><li><p><code>keepalive_disable none | browser;</code></p></li><li><ul><li>禁止那些浏览器使用keepalive功能,如: keepalive_disable msie6</li></ul></li><li><p><code>keepalive_timeout #s;</code></p></li><li><ul><li>设定keepalive连接的超时时长,0表示禁止长连接,默认启用为75s</li></ul></li><li><p><code>keepalive_requests #;</code></p></li><li><ul><li>在keepalive连接上所允许请求的最大资源数量,默认为100;</li></ul></li><li><p><code>send_timout #;</code></p></li><li><ul><li>发送响应报文的超时时长,默认为60s;</li></ul></li><li><p><code>client_body_buffer_size SIZE(8k | 16k);</code></p></li><li><ul><li>接收客户请求报文body的缓冲区大小, 默认为16k(64位系统,32位系统为8K),超出指定大小时将被移存于磁盘上.</li></ul></li><li><p><code>client_body_temp_path [Level1 [level2 [level3]]]</code></p></li><li><ul><li>设定用于存储客户端请求body的临时存储路径及子目录结构和数量</li></ul></li></ul><h4 id="5、对客户端请求进行限制"><a href="#5、对客户端请求进行限制" class="headerlink" title="5、对客户端请求进行限制"></a><span id="client_limit">5、对客户端请求进行限制</span></h4><ul><li><p><code>limit_except METHOD &#123;...&#125;;</code></p></li><li><ul><li>对指定范围之外的其它方法进行访问控制,应用于location上下文</li></ul></li><li><p><code>limit_rate SPEED;</code></p></li><li><ul><li>限制客户端每秒种所能够传输的字节数, 默认为0,表示不限制,应用于http,server,location,if in location上下文中</li></ul></li><li><p><code>limit_rate_after SIZE;</code></p></li><li><ul><li>超出SIZE的值, 就限制速度,应用于http,server,location,if in locataion上下文中</li></ul></li></ul><h4 id="6、文件操作优化相关的配置"><a href="#6、文件操作优化相关的配置" class="headerlink" title="6、文件操作优化相关的配置"></a><span id="file_cfg_para">6、文件操作优化相关的配置</span></h4><ul><li><p><code>aio on | off;</code></p></li><li><ul><li>是否启用异步IO模式, 应用于http, server,location上下文中</li></ul></li><li><p><code>directio size | off;</code></p></li><li><ul><li>是否启用直接IO操作, 不在内存中缓冲, 直接从硬盘加载使用(当大于指定的size),应用于http,server,location</li></ul></li><li><p><code>open_file_cache off | max=N [inactive=time];</code></p></li><li><ul><li>(1) 文件描述符</li><li>(2) 文件大小</li><li>(3) 最近一次的修改时间</li><li>(4) 打开的目录的结构</li><li>(5) 没有找到或者没有权限操作的文件的相关信息</li><li>对打开的文件进行缓存 ,nginx可以缓存以下三种信息</li><li>max&#x3D;N : 可缓存的最大条目上限,一旦达到上限, 则会使用LRU算法从缓存中删除最近最少使用的缓存项</li><li>inactive&#x3D;time : 在此处指定的时长内没有被访问过的缓存项识别为非活动缓存项, 因此直接删除</li></ul></li><li><p><code>open_file_cache errors on|off;</code></p></li><li><ul><li>是否缓存找不到其路径的文件,或没有权限访问的文件相关信息</li></ul></li><li><p><code>open_file_cache_valid time;</code>    </p></li><li><ul><li>每隔多久检查一次缓存中缓存项的有效性,默认为60秒</li></ul></li><li><p><code>open_file_cache_min_uses number;</code></p></li><li><ul><li>缓存项在非活动其限内最少应该被访问的次数</li></ul></li></ul><h2 id="二、ngx-http-access-module模块"><a href="#二、ngx-http-access-module模块" class="headerlink" title="二、ngx_http_access_module模块"></a><span id="ngx_http_access_module">二、ngx_http_access_module模块</span></h2><h4 id="1、基于用户IP的权限控制"><a href="#1、基于用户IP的权限控制" class="headerlink" title="1、基于用户IP的权限控制"></a>1、基于用户IP的权限控制</h4><ul><li><p><code>allow address | CIDR | unix: | all;</code> 允许</p></li><li><p><code>deny address | CIDR | unix: | all;</code> 拒绝</p></li><li><ul><li><p>应用上下文件:http,server,location,limit_except</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">  location / &#123;</span><br><span class="line">      deny 192.168.1.1;</span><br><span class="line">      allow 192.16.1.0/24;</span><br><span class="line">      allow 10.1.1.0/16;</span><br><span class="line">      allow 2001:0db8::32;</span><br><span class="line">      deny all;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、ngx-http-auth-basic-module模块"><a href="#三、ngx-http-auth-basic-module模块" class="headerlink" title="三、ngx_http_auth_basic_module模块"></a><span id="ngx_http_auth_basic_module">三、ngx_http_auth_basic_module模块</span></h2><h4 id="1、基于Basic认证的权限控制"><a href="#1、基于Basic认证的权限控制" class="headerlink" title="1、基于Basic认证的权限控制"></a>1、基于Basic认证的权限控制</h4><ul><li><p><code>auth_basic string | off;</code></p></li><li><ul><li>用户定义认证的名称,string为所给定字符,其作用在于认证时显示的提示信息</li></ul></li><li><p><code>auth_basic_user_file FILE;</code></p></li><li><ul><li>实现用户认证的用户及帐号文件,文件格式如下(需手动创建):</li><li>密码可以使用httpd程序自带的工具htpasswd创建</li></ul></li></ul><h2 id="四、ngx-http-log-module模块的配置-访问日志"><a href="#四、ngx-http-log-module模块的配置-访问日志" class="headerlink" title="四、ngx_http_log_module模块的配置(访问日志)"></a><span id="ngx_http_log_module">四、ngx_http_log_module模块的配置(访问日志)</span></h2><h4 id="1、访问日志控制"><a href="#1、访问日志控制" class="headerlink" title="1、访问日志控制"></a>1、访问日志控制</h4><ul><li><p><code>log_format name string....;</code></p></li><li><ul><li>定义日志格式及其名称,日志格式一般通过调用内置变量来定义,默认格式为combined</li></ul></li><li><p><code>access_log path [format[buffer=size [flush=time]]];</code></p></li><li><p><code>access_log off</code></p></li><li><ul><li>定义日志文件路径,格式名称以及缓存大小和刷写时间间隔,建议定义缓冲以提升性能</li></ul></li><li><p><code>open_log_file_cache max=N [inactive=time] [min_uses] [valid=time];</code></p></li><li><p><code>open_log_file_cache off;</code></p></li></ul><h2 id="五、ngx-http-stub-status-module模块"><a href="#五、ngx-http-stub-status-module模块" class="headerlink" title="五、ngx_http_stub_status_module模块"></a><span id="ngx_http_stub_status_module">五、ngx_http_stub_status_module模块</span></h2><h4 id="1、nginx自身status的信息配置"><a href="#1、nginx自身status的信息配置" class="headerlink" title="1、nginx自身status的信息配置"></a>1、nginx自身status的信息配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 1 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 2 2 18 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br></pre></td></tr></table></figure><h6 id="各参数说明"><a href="#各参数说明" class="headerlink" title="各参数说明"></a>各参数说明</h6><ul><li>active connections : 当前活动的客户端连接数,包括等待的.</li><li>accepts : 已接受的客户端的连接总数量</li><li>handled : 已处理完成的客户端连接请求总数量</li><li>requests : 客户端总的请求数</li><li>reading : 当前正在读取的客户端请求报文首部信息的数量</li><li>writing : 当前正在向客户端发送响应报文的连接数量</li><li>wating : 等待其发出请求的空闲连接数量</li></ul><h2 id="六、ngx-http-referer-module模块"><a href="#六、ngx-http-referer-module模块" class="headerlink" title="六、ngx_http_referer_module模块"></a><span id="ngx_http_referer_module">六、ngx_http_referer_module模块</span></h2><blockquote><p>基于请求报文中的referer首部的值, 做访问控制 ,可以防止盗链,其只应用于server,location上下文</p></blockquote><ul><li><p><code>referer_hash_bucket_size SIZE;</code></p></li><li><ul><li>可以放多个缓存我要上,默认是64</li></ul></li><li><p><code>referer_hash_max_size SIZE;</code></p></li><li><ul><li>默认2048</li></ul></li><li><p><code>valid_referers none|blocked|server_names|string...;</code></p></li><li><ul><li>none : 请求的报文不存在referer首部</li><li>blocked : 请求报文中存在referer首部,但其没有有效值,或其值非以<a href="">http:&#x2F;&#x2F;或https开头</a></li><li>server_names :其值为一个主机名</li><li>arbitrary string : 直接字符串,可以使用*号匹配</li><li>rugular expression : 以~起始的正则表达式</li></ul></li></ul><h2 id="七、ngx-http-ssl-module模块"><a href="#七、ngx-http-ssl-module模块" class="headerlink" title="七、ngx_http_ssl_module模块"></a><span id="ngx_http_ssl_module">七、ngx_http_ssl_module模块</span></h2><ul><li><p><code>listen 443 ssl;</code></p></li><li><ul><li>在指定端口上启用必须ssl连接</li></ul></li><li><p><code>server_name www.zhenping.me;</code></p></li><li><ul><li>ssl主机的FQDN名称</li></ul></li><li><p><code>ssl_certificate cert.pem;</code></p></li><li><ul><li>ssl的公钥</li></ul></li><li><p><code>ssl_certificate_key cert.key;</code></p></li><li><ul><li>ssl的私钥</li></ul></li><li><p><code>ssl_session_cache off | none | [builtin[:size]] [shard:name:size];</code></p></li><li><ul><li>默认使用shared模式</li><li>off : 禁止缓存 ,关闭缓存,不支持缓存功能</li><li>none :禁止缓存 ,不响应缓存</li><li>builtin : 使用openssl内置的ssl会话缓存 ,此机制为各worker私有</li><li>shared: 在各worker之间使用一个共享的缓存,name:独有名称,size:缓存空间大小, 默认为1M,可以调到10M</li></ul></li><li><p><code>ssl_session_timeout 5m;</code></p></li><li><ul><li>ssl会议超时时长,即ssl session cache中的缓存有效时长,默认为5m</li></ul></li><li><p><code>ssl_prefer_server_ciphers on;</code></p></li><li><ul><li>优先使用服务端选择的加密算法</li></ul></li><li><p><code>ssl on | off;</code></p></li><li><ul><li>启用或关闭ssl,若不在listen处定义，也可以在server{ }中定义ssl on; 来启用https服务</li></ul></li><li><p><code>ssl_buffer_size SIZE;</code></p></li><li><ul><li>ssl缓冲大小</li></ul></li><li><p><code>ssl_ciphers CIPHERS;</code></p></li><li><ul><li>指明由nginx使用的加密算法,可以是openssl库所支持各加密套件</li></ul></li><li><p><code>ssl_client_certificate file;</code></p></li><li><ul><li>需要验证客户端证书</li></ul></li><li><p><code>ssl_crl FILE;</code></p></li><li><ul><li>证书吊销列表</li></ul></li><li><p><code>ssl_protocols [sslv2][sslv3][tlsv1][tlsv1.1][tlsv1.2];</code></p></li><li><ul><li>使用哪些协议版本, 默认为TLSv1,TLSv1.1,TLSv1.2</li></ul></li><li><p><code>ssl_trusted_certificate FILE;</code></p></li><li><ul><li>信任的根证书</li></ul></li><li><p><code>ssl_session_ticket_key FILE;</code></p></li></ul><h2 id="八、ngx-http-rewrite-module模块"><a href="#八、ngx-http-rewrite-module模块" class="headerlink" title="八、ngx_http_rewrite_module模块"></a><span id="ngx_http_rewrite_module">八、ngx_http_rewrite_module模块</span></h2><blockquote><p>将请求的url基于正则表达式进行重写(URL重定向),在如下情况下可以使用:http转换成httpd服务(http→https),域名转换domain.tld →domain2.tld, URL转换uri → uri2,实现SEO搜索引擎优化效果…. 将用户请求的URL基于正则表达式进行重写</p></blockquote><ul><li><p><code>rewrite regex replacement [flag];</code></p></li><li><ul><li>last : 重写完成之后停止对当前uri的进一步处理,改为对新uri的新一轮处理(对URI的重写规则进行匹配,当检查到第一条匹配到的时候,进行重写.然后返回到重写规则的第一条位置进行重新匹配,如果有匹配到的再进行重写,默认只能10次匹配). 此过程用户端感受不到.</li><li>break : 对URI的重写规则进行匹配,只要匹配到就重写,不再进行再次匹配,此过程用户端感受不到.</li><li>redirect : 重写完成之后返回客户端一个临时重定向,由客户端对新的URI重新发起请求, 即302的状态码</li><li>permanent : 重写完成之后,会返回客户端一个永久的重写向,由客户端对新的URI重新发起请求,即301的状态码</li><li>PCRE正则表达式元字符</li><li>字符: .,[],[^]</li><li>次数: *,+,?,{m},{m,}{m,n}</li><li>位置锚定: ^,$</li><li>或者: |</li><li>分组: (), 后向引用: 2,…..</li><li>应用于server,location,if上下文</li><li>regex : 基于perl的正则表达式,用于匹配用户请求的URL;</li><li>replacement : 重写为的结果</li><li>flag:标志位</li></ul></li><li><p><code>if(condition) &#123;...&#125;</code> :条件判断,引用新的配置上下文</p></li><li><ul><li>-f,!-f : 是否存在且为普通文件</li><li>-d,!-d : 是否存在且为目录</li><li>-e,!-e : 是否存在</li><li>-x,!-x : 是否存在且可执行</li><li>&#x3D;&#x3D;, !&#x3D;</li><li>~ : 模式匹配,区分字符大小写</li><li>~* : 模式匹配,不区分字符大小写</li><li>!~ : 模式不匹配, 区分字符大小写</li><li>!~* : 模式不匹配,不区分字符大小写</li><li>condition比较表达式:</li><li>文件及目录判断:</li></ul></li><li><p><code>return</code> : 立即停止对请求的URI的处理,并返回指定的状态码</p></li><li><ul><li>returncode [text];</li><li>returncode URL</li><li>return URL;</li></ul></li><li><p><code>set</code> : 设定变量值,或者自定义变量</p></li><li><ul><li>set $variable value;</li></ul></li><li><p><code>rewrite_log on | off;</code></p></li><li><ul><li>是否将重写日志记录errorlog中,默认为关闭(调试方法:错误日志debug,并开启rewrite_log)</li></ul></li></ul><h2 id="九、ngx-http-gzip-module模块"><a href="#九、ngx-http-gzip-module模块" class="headerlink" title="九、ngx_http_gzip_module模块"></a><span id="ngx_http_gzip_module">九、ngx_http_gzip_module模块</span></h2><ul><li><p><code>gzip on | off;</code></p></li><li><ul><li>启用或禁用gzip压缩响应报文</li></ul></li><li><p><code>gzip_buffers number size;</code></p></li><li><ul><li>default 32位系统4k,64位系统8k</li></ul></li><li><p><code>gzip_comp_level LEVEL;</code></p></li><li><ul><li>压缩比,1-9,默认为1</li></ul></li><li><p><code>gzip_disable regex ...;</code></p></li><li><ul><li>regex是为用于匹配客户端响应器类型的正则表达式,表示对何种浏览器禁止使用压缩功能</li></ul></li><li><p><code>gzip_min_length LENGTH;</code></p></li><li><ul><li>触发压缩功能的响应报文的最小长度</li></ul></li><li><p><code>gzip_http_version 1.0 | 1.1;</code></p></li><li><ul><li>设定启用压缩功能的最小版本</li></ul></li><li><p><code>gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etg | auth | any ...;</code></p></li><li><ul><li>定义对客户端请求的具有何种请求属性的资源启用压缩功能,如expired表示:对由于使用expire首部而无法缓存的对象启用压缩功能</li></ul></li><li><p><code>gzip_types mime.type;</code></p></li><li><ul><li>指明对那些类型的资源进行压缩</li></ul></li></ul><h2 id="十、ngx-http-fastcgi-module模块"><a href="#十、ngx-http-fastcgi-module模块" class="headerlink" title="十、ngx_http_fastcgi_module模块"></a><span id="ngx_http_fastcgi_module">十、ngx_http_fastcgi_module模块</span></h2><blockquote><p>fastcgi_module只能对后端的一台应用服务器进行反代,如果需要给多台应用服务器进行反代实现负载,需借助upstream模块定义一组服务器,由fastcgi功能引用来完成, lnmp的架构中, ningx只支持fastcgi的模式连接后端php服务器,不能将应用服务运行为一个子模块的方式.nginx不支持动态加载模块机制(DSO),所以需要编译php工作为fpm机制时,将ngnx_http_fastcgi_module编译到nginx程序中,在php编译时需使用 —enable-fpm,将Php设置为fpm模式.</p></blockquote><p>LNMP架构仅支持一种nginx+php的结合方式,实现方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location ~* \.php$ &#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、fastcgi模块指令"><a href="#1、fastcgi模块指令" class="headerlink" title="1、fastcgi模块指令"></a>1、fastcgi模块指令</h4><ul><li><p><code>fastcgi_pass address;</code></p></li><li><ul><li>address为fastcgi server监听的地址,如: fastcgi_pass localhost:9000;</li></ul></li><li><p><code>fastcgi_index NAME;</code></p></li><li><ul><li>定义fastcgi应用的默认主机,如: fastcgi_index index.php;</li></ul></li><li><p><code>fastcgi_param PARAMETER VALUE[if_not_empty];</code></p></li><li><ul><li>用户定义客户端请求的哪些属性传递给后端fastcti_server</li></ul></li><li><p><code>fastcgi_pass_header field;</code></p></li><li><ul><li>允许把fastcgi的响应首部直接发送给客户端</li></ul></li><li><p><code>fastcgi_cache_path path [levels=levels][use_temp_path=on|off] keys_zone=name:size [inactive=time][max_szie=size];</code></p></li><li><ul><li>缓存对象名字都以16进制进行编码,故一级目录一般为16个或者256个</li><li>元数据存在内存中,即为keys_zone</li><li>数据存在硬盘,即为path</li><li>用于定义缓存,缓存 空间等,可应用于http上下文,需要运行php的用户对path有写权限.</li><li>缓存机制:</li><li>levels&#x3D;#[:#[:#]] : 表示可以使用三级目录进行保存</li><li>keys_zone&#x3D;name:size : name名称要全局唯一,cache的标识符</li><li>inactive&#x3D;time : 缓存的非活动时间,缓存的访问次数在指定的time内比较少,就需要清理出去</li><li>max-size : 缓存空间上限,指磁盘的缓存空间上限</li></ul></li><li><p><code>fastcgi_cache zone | off;</code></p></li><li><ul><li>调用定义过的缓存,zone即为通过fastcgi_cache_path定义缓存时其keys_zone参数中的name</li></ul></li><li><p><code>fastcgi_cache_key string;</code></p></li><li><ul><li>定义那些键需要进行缓存,如用户访问的URI,如:fastcgi_cache_key $request_uri;</li></ul></li><li><p><code>fastcgi_cache_methods GET|HEAD|POST...;</code></p></li><li><ul><li>为何种请求方法对应的请求进行缓存,默认为get和head</li></ul></li><li><p><code>fastcgi_cache_min_uses number;</code></p></li><li><ul><li>缓存项的最少使用次数,默认为1次</li></ul></li><li><p><code>fastcgi_cache_revalidate on |off;</code></p></li><li><p><code>fastcgi_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | off;</code></p></li><li><ul><li>是否可使用stale缓存项(不新鲜)响应用户请求,默认是off</li></ul></li><li><p><code>fastcgi_cache_valid [code...] time;</code></p></li><li><ul><li>对不同响应码的响应设定可缓时长</li><li>缓存的设定及调用</li></ul></li></ul><h2 id="十一、ngx-http-proxy-module模块"><a href="#十一、ngx-http-proxy-module模块" class="headerlink" title="十一、ngx_http_proxy_module模块"></a><span id="ngx_http_proxy_module">十一、ngx_http_proxy_module模块</span></h2><p>反向代理(reverse proxy)方式是指以代理服务器来接受internet上的连接请求,然后将请求转发给内部网络上的服务器, 并将从服务器上得到的结果返回给internet上请求连接的客户端,此时站在服务器角度来看,代理服务器对外就表现为一个反向代理服务器,对反向代理服务器的攻击并不会使得后端内网web服务器上网页信息破坏,增强了web服务器的安全性</p><ul><li><p><code>proxy_pass URL;</code></p></li><li><ul><li>应用上下文:Location,if in location, limit_except</li><li>如果location URI时使用正则表达模式匹配时, 其proxy_pass后面的路径一定不能带URI地址</li><li>如果location 中有rewrite重写,在proxy_pass后面的连接地址一定不能带URI地址, 那怕有&#x2F;也不可以</li></ul></li><li><p><code>proxy_pass_header field;</code></p></li><li><ul><li>传递首部给客户端</li></ul></li><li><p><code>proxy_hide_header field;</code></p></li><li><ul><li>有意隐藏首部</li></ul></li><li><p><code>proxy_set_header field value;</code></p></li><li><ul><li>proxy_set_header HOST $http_host</li><li>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</li><li>request_host传递给host变量,再由代理服务器发起请求的时候,加入host首部(有的情况下代理服务器与backend服务器连接使用的IP地址, 这种传递host参数的情况下,代理发起的访问,都会转为默认的虚拟主机)</li><li>将客户端的真实IP地址赋值给X-Forwarded-For变量,代理请求的时候,将发送给后端的backend server.如果中间有多层代理 , 每经过一层代理时,代理服务器都会将在后面增加自己的IP地址,并以分号分隔开来</li><li>用于proxy_server向backend_server发请求报文时,将某请求首部重新赋值,或在原有值后面添加一个新的值</li></ul></li><li><p><code>proxy_cache_path path [levels=levels][use_temp_path=on|off] keys_zone=name:size [inactive=time][max_size=size];</code></p></li><li><ul><li>定义缓存,可用于http上下文</li></ul></li><li><p><code>proxy_cache zone | off;</code></p></li><li><ul><li>调用缓存,可用于http,server,location上下文</li></ul></li><li><p><code>proxy_cache_key string;</code></p></li><li><ul><li>$scheme : 所使用的协议</li><li>$proxy_host : 请求的那个代理服务器地址</li><li>$request_uri : 向那个URI发出的请求,带参数的: <a href="http://www.zhenping.me/?username=1&amp;userid=1">www.zhenping.me?username=1&amp;userid=1</a></li><li>$uri : 向那个URI发出的请求,不带参数</li><li>定义缓存键,默认为:proxy_cache_key proxy_host$request_uri;</li></ul></li><li><p>&#96;proxy_cache_valid [code…] time;</p></li><li><ul><li>对不同响应码设定其可缓存时长</li></ul></li><li><p><code>proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 |http_503 | http_504 | http_403 | http_404 | off...;</code></p></li><li><ul><li>定义如果后端服务器连接不成功,是否可以使用缓存数据进行响应</li></ul></li><li><p><code>proxy_connect_timeout time;</code></p></li><li><ul><li>定义后端服务器建立连接的超时时长,默认为60s,此值不应该超过75s</li></ul></li><li><p><code>proxy_send_timeout time;</code></p></li><li><ul><li>把请求发送给后端服务器的超时时长,默认为60s</li></ul></li><li><p><code>proxy_read_timeout time;</code></p></li><li><ul><li>等待后端服务器发送响应报文的超时时长,如果有大量的502,就需要考虑这个时长是否过短</li></ul></li></ul><h2 id="十二、ngx-http-headers-module模块"><a href="#十二、ngx-http-headers-module模块" class="headerlink" title="十二、ngx_http_headers_module模块"></a><span id="ngx_http_headers_module">十二、ngx_http_headers_module模块</span></h2><ul><li><p><code>add_header_name value [always];</code> : (其可操作响应报文首部)</p></li><li><ul><li><p>向响应报文添加自定义首部,并为其赋值,应用上下文为:http,server,location, if in location</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Via $server_addr;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expires [modified] time;</code></p></li><li><p><code>expires epoch | max | off;</code></p></li><li><ul><li>默认expires off, 允许或禁止向响应报文的cache-control或expires首部添加新值或修改其值</li></ul></li></ul><h2 id="十三、ngx-http-upstream-module模块"><a href="#十三、ngx-http-upstream-module模块" class="headerlink" title="十三、ngx_http_upstream_module模块"></a><span id="ngx_http_upstream_module">十三、ngx_http_upstream_module模块</span></h2><blockquote><p>用于将多个服务器定义成服务器组,而由proxy_pass fastcgi_pass等指令引用,应用于http上下文</p></blockquote><ul><li><p><code>upstream name &#123;...&#125;;</code></p></li><li><ul><li>定义一个后端服务器组,name为组名称,仅用于http上下文</li></ul></li><li><p><code>server address [parameters];</code></p></li><li><ul><li>weight&#x3D;number : 定义服务器权重,默认为1</li><li>max_fails&#x3D;number : 最大失败连接尝试次数(做健康状态检测),失败连接超时时长由fail_timeout参数指定</li><li>fail_timeout&#x3D;number : 等待目标服务器发送响应的时长,总的超时时长</li><li>backup : 备用服务器,所有主服务器均故障时,才启用此服务器(即sorry server)</li><li>down : 手动标记其不再处理任何用户请求</li><li>在upstream中定义一个服务器及相关参数,仅能用于upstream上下文</li><li>常用参数:</li></ul></li><li><p><code>ip hash</code></p></li><li><ul><li>源地址hash,把来自同一个IP地址的请求始终发往同一个backend server,除非backend server不可用</li></ul></li><li><p><code>least_conn;</code></p></li><li><ul><li>最少连接,当各server权重不同时,即为加权最少连接</li></ul></li><li><p><code>match name &#123;...&#125;</code></p></li><li><ul><li>status code[code…]; : 期望的响应状态码</li><li>header HEADER[oprator value] : 期望存在响应首部,也可对期望的响应首部值基于比较操作符和值进行比较</li><li>body : 期望响应报文的主体部分应该有的内容</li><li>对backend server做健康状态检测时,定义其结果判断机制,只能用于http上下文</li><li>常用参数</li></ul></li><li><p><code>health_check [parameters];</code> (较新版本中的nginx支持)</p></li><li><ul><li>interval&#x3D;time :检测的时间频率,默认为5秒钟</li><li>fails&#x3D;number : 判定服务器不可用的失败检测次数,默认为1次</li><li>passes&#x3D;number : 判定服务器可用的检测次数,默认为1次</li><li>uri&#x3D;URI; : 应用层的检测,做健康状态检测测试的目标URI,默认为”&#x2F;“</li><li>match&#x3D;name : 健康状态检测的结果评估调用(match name {…}参数)指定的match配置块</li><li>健康状态检测机制,应用上下文:location</li><li>常用参数</li></ul></li><li><p><code>hash key[consistent];</code></p></li><li><ul><li>$cookie_name : 将一个用户的请求始终发往同一个backend server,能实现会话绑定的功能,此处的name为cookie中某些参数的名称,此处常用的有:cookie_username.</li><li>$request_method</li><li>$request_uri : 将对同一个uri的请求始终发往同一个backend server,后端为cache server时特别有用</li><li>$uri</li><li>应用于upstream中,指明基于hash方式进行调度时,其hash键, hash $remote_addr 相当于ip_hash;</li><li>常用的hash key:</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradle 环境安装配置</title>
      <link href="/2017/07/19/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20gradle%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/07/19/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20gradle%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。[2]<br>当前其支持的语言限于Java、Groovy和Scala[3]，计划未来将支持更多的语言。</p></blockquote><h3 id="特性（优势）"><a href="#特性（优势）" class="headerlink" title="特性（优势）"></a>特性（优势）</h3><ul><li>自动处理包相依关系 - 取自 Maven Repos 的概念</li><li>自动处理布署问题 - 取自 Ant 的概念</li><li>条件判断写法直觉 - 使用 Groovy 语言</li></ul><p> Java 开发者常用 Maven 和 Ant 等工具进行封装布署的自动化，或是两者兼用，不过这两个包彼此有优缺点，如果频繁改变相依包版本，使用 Ant 相当麻烦，如果琐碎工作很多，Maven 功能不足，而且两者都使用 XML 描述，相当不利于设计 if、switch 等判段式，即使写了可读性也不佳，而 Gradle 改良了过去 Maven、Ant 带给开发者的问题，至今也成为 Android Studio 内置的封装布署工具。</p><p> Springboot 也在积极拥抱gradle</p><ul><li><a href="https://gradle.org/">gradle官网</a></li></ul><h3 id="环境部署（Windows）"><a href="#环境部署（Windows）" class="headerlink" title="环境部署（Windows）"></a>环境部署（Windows）</h3><ol><li><p>下载gradle安装文件 <a href="https://gradle.org/install/">官网下载</a> 下载后，解压</p></li><li><p>安装jdk （要求jdk1.7以上）</p></li><li><p>“计算机”–&gt;“属性”–&gt;“高级系统设置” –&gt;“环境变量”。</p></li><li><p>将解压目录\gradle-4.0.1\bin的配置到path中。（或者先配置GRADLE_HOME，再配置%GRADLE_HOME%\bin到path中）</p></li><li><p>检查是否安装成功</p><pre><code> &gt; gradle -v  ------------------------------------------------------------ Gradle 4.0.1 ------------------------------------------------------------</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令整理</title>
      <link href="/2017/07/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2017/07/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git常用命令整理，逐步完善自己经常使用的命令，方便查找，总结</p></blockquote><h2 id="先贴一张网上搜集到的git图"><a href="#先贴一张网上搜集到的git图" class="headerlink" title="先贴一张网上搜集到的git图"></a>先贴一张网上搜集到的git图</h2><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fho6hly27sj20uu0k5qkv.jpg"></p><h2 id="git命令速查"><a href="#git命令速查" class="headerlink" title="git命令速查"></a>git命令速查</h2><pre><code>git init                                                  # 初始化本地git仓库（创建新仓库）git config --global user.name &quot;xxx&quot;                       # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件git config --global color.ui true                         # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m &#39;xxx&#39;                                       # 提交git commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）git commit -am &#39;xxx&#39;                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log --stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff --cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch                                                # 显示本地分支git branch --contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch --merged                                       # 显示所有已合并到当前分支的分支git branch --no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features/performance                         # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin/master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支git push --tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch --all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态git log --pretty=format:&#39;%h %s&#39; --graph                   # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”git grep -e &#39;#define&#39; --and -e SORT_DIRENTgit gcgit fsck</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半年总结(2017)</title>
      <link href="/2017/07/05/%E6%9D%82%E8%AE%B0/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93(2017)/"/>
      <url>/2017/07/05/%E6%9D%82%E8%AE%B0/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93(2017)/</url>
      
        <content type="html"><![CDATA[<h1 id="半年总结"><a href="#半年总结" class="headerlink" title="半年总结"></a>半年总结</h1><blockquote><p>2017半年过去了，利用思维导图的方式稍微总结了一下，以便回顾总结，发现不足之处，逐步提高。<br>知识技能上，本是后端上半年却有点”不务正业”，APP上半年还在酝酿中，还没有涉及运维，运营时，自己感觉应该提前梳理出来，趁着后端上不忙碌，自己去熟悉总结了系统监控相关内容，集中式日志监控相关，主要熟悉了一下ELK体系，和阿里云的日志监控等，前端web，对angular,vue,react进行调研，现阶段，Vue应该是最容易入门及开展工作的。于是就了解熟悉了一些前端架构及Vue，并搭建了后台及运营管理的WEB平台。</p></blockquote><p>心得及收获:</p><p>1.拥抱开源，真正关注开源</p><p>2.贡献了第一个npm包</p><p>3.技术变更速度真快…,必须不断学习。</p><p>…</p><p>–不足:<br>1.知识深度不够，需要深层次理解一些底层原理</p><p>2.还是有些粗心大意，通过备忘录，checklist，多自我检查。</p><p>3.自我表达能力亟待提高。</p><p>4.生活上，自己的忙碌，让爸妈操心太多，不够关心家人。</p><p>想要总结的还太多，还是要点点滴滴积累，</p><p>希望下半年家人都能健健康康，自己工作，生活上能有更大的突破。</p><hr><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fhelozhx5dj21gs1qktkl.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-oss-upload 上传到阿里云的oss组件包（npm）</title>
      <link href="/2017/06/18/%E5%89%8D%E7%AB%AF/%20vue-oss-upload%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84oss%E7%BB%84%E4%BB%B6%E5%8C%85%EF%BC%88npm%EF%BC%89/"/>
      <url>/2017/06/18/%E5%89%8D%E7%AB%AF/%20vue-oss-upload%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84oss%E7%BB%84%E4%BB%B6%E5%8C%85%EF%BC%88npm%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近使用vue比较多，项目过程中遇到了，上传图片、视频到阿里云的OSS存储服务，<span id="more"></span>发现目前现成的上传组件，都不太支持，于是自己各种查看阿里云的文档及google，百度，自己写了一套符合自己的业务的上传组件，想到其他小伙伴肯定也会遇到类似的问题，就花了些时间，把组件提取出来，上传到了npm。</p></blockquote><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>服务端提供接口，获取阿里云STS临时访问OSS的权限，初始化ossClient，调用oss的sdk进行上传。通过vue2.3重新引入的sync特性返回上传结果</p><p>使用组件时，需要导入Css样式。自己不擅长写样式，写的比较挫，希望可以被改进，哈哈</p><ul><li>TODO: 上传的进度，等尚未实现，只有最终上传结果</li></ul><p><a href="https://cn.vuejs.org/"><img src="https://img.shields.io/badge/Vue-2.x-brightgreen.svg" alt="Vue 2.3.0+"></a></p><p><a href="https://nodei.co/npm/vue-oss-upload/"><img src="https://nodei.co/npm/vue-oss-upload.png?downloads=true&downloadRank=true&stars=true" alt="NPM"></a></p><ul><li><a href="https://github.com/fantasykai/vue-ossUpload">github 地址</a></li></ul><h1 id="vue-oss-upload"><a href="#vue-oss-upload" class="headerlink" title="vue-oss-upload"></a>vue-oss-upload</h1><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="需要依赖阿里云的oss的SDK-可以在index-html中引入"><a href="#需要依赖阿里云的oss的SDK-可以在index-html中引入" class="headerlink" title="需要依赖阿里云的oss的SDK,可以在index.html中引入"></a>需要依赖阿里云的oss的SDK,可以在index.html中引入</h3><p>  <code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://gosspublic.alicdn.com/aliyun-oss-sdk.min.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="组件依赖vue2-3以上的版本"><a href="#组件依赖vue2-3以上的版本" class="headerlink" title="组件依赖vue2.3以上的版本"></a>组件依赖vue2.3以上的版本</h3><p>vue2.3 重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。</p><p><a href="https://cn.vuejs.org/v2/guide/components.html#counter-event-example">.sync 修饰符</a></p><h2 id="Use-Setup"><a href="#Use-Setup" class="headerlink" title="Use Setup"></a>Use Setup</h2><h3 id="Install-vue-oss-upload"><a href="#Install-vue-oss-upload" class="headerlink" title="Install vue-oss-upload"></a>Install vue-oss-upload</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-oss-upload --save</span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code> props: &#123;      // 需要引入阿里云OSS的SDK，并初始化ossClient      ossClient: &#123;        type: Object,        toWay: false      &#125;,      // 是非支持多文件上传      multiple: &#123;        type: Boolean,        twoWay: false      &#125;,      // 上传组件id，区别页面中多次使用上传组件      id: &#123;        type: String,        twoWay: false      &#125;,      // 上传成功后的uri      url: &#123;        type: String,        twoWay: true      &#125;,       // 上传结果      uploadRes: &#123;        type: Boolean,        twoWay: true      &#125;,      // 上传按钮的名称      inputName: &#123;        type: String,      &#125;,      // 上传文件的名称      uploadFileName: &#123;        type: String,      &#125;,      // 上传到OSS的路径      path: &#123;        type: String,      &#125;,    &#125;,</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;upload-ali-oss :url.sync=&quot;uploadForm.content.path&quot; :multiple=&quot;true&quot;                        :id=&quot;uploadForm.id&quot;                        :ossClient=&quot;this.ossClient&quot;                        :inputName=&quot;uploadForm.inputName&quot;                        :uploadFileName=&quot;uploadForm.uploadFileName&quot;                        :path=&quot;uploadForm.upload.path&quot;                        :uploadRes.sync=&quot;uploadForm.uploadRes&quot;        &gt;&lt;/upload-ali-oss&gt;        &lt;div v-show=&quot;uploadForm.uploadRes&quot;             v-text=&quot;uploadForm.content.path&quot;&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;img v-if=&quot;uploadForm.uploadRes&quot;                 :src=&quot;this.imgSrc&quot;&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import VueUploadAliOSS from &#39;vue-oss-upload&#39;;    import Css from &#39;vue-oss-upload/dist/vue-alioss-upload.min.css&#39;    export default &#123;        name: &#39;app&#39;,        components: &#123;            &#39;upload-ali-oss&#39;: VueUploadAliOSS        &#125;,        data() &#123;            return &#123;                ossClient: Object,                uploadForm: &#123;                    id: &#39;imgFile&#39;,                    inputName: &#39;上传图片&#39;,// 自定义                    uploadFileName: &#39;2017063010192023&#39;,// 上传文件的名称                    content: &#123;                        path: &#39;&#39;,                    &#125;,                    upload: &#123;                        path: &#39;img/test/&#39;,// 自定义路径                    &#125;,                    uploadRes: false,                &#125;,                imgSrc: &#39;&#39;            &#125;        &#125;,        methods: &#123;            // 需要引入阿里云的ossSDK            //初始化OSS 权限, 建议后台提供获取oss临时权限的接口            initOSSAuth() &#123;                let Oss = OSS.Wrapper;                this.ossClient = new Oss(&#123;                    region: &#39;&#39;,                    accessKeyId: &#39;&#39;,                    accessKeySecret: &#39;&#39;,                    stsToken: &#39;&#39;,                    bucket: &#39;&#39;,                    endpoint: &#39;&#39;,                &#125;);            &#125;,            // 展示上传的内容（图片）            showUploadContent() &#123;                if (this.uploadForm.content.path) &#123;                    let path = this.uploadForm.content.path;                    var result = this.ossClient.signatureUrl(path, &#123;                        response: &#123;                            // &#39;content-disposition&#39;: &#39;attachment; filename=&quot;&#39; + filename + &#39;&quot;&#39;                            &#39;Content-Type&#39;: &#39;image/jpeg&#39;                        &#125;                    &#125;);                    this.imgSrc = result;                &#125;            &#125;        &#125;,        watch: &#123;            &#39;uploadForm.content.path&#39; (val, oldVal) &#123;//                console.log(&#39;new: %s, old: %s&#39;, val, oldVal)                if (&#39;&#39; !== val) &#123;                    this.showUploadContent();                &#125;            &#125;        &#125;,        mounted() &#123;            this.initOSSAuth();        &#125;    &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h3 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h3><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fgqi3miznuj20kj0l4k4f.jpg"></p><h1 id="Author-Blog"><a href="#Author-Blog" class="headerlink" title="Author Blog"></a>Author Blog</h1><p><a href="https://fantasykai.cc/">kai.fantasy</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解WebAssembly</title>
      <link href="/2017/06/17/%E5%89%8D%E7%AB%AF/%E7%90%86%E8%A7%A3WebAssembly/"/>
      <url>/2017/06/17/%E5%89%8D%E7%AB%AF/%E7%90%86%E8%A7%A3WebAssembly/</url>
      
        <content type="html"><![CDATA[<h1 id="几张图让你看懂WebAssembly"><a href="#几张图让你看懂WebAssembly" class="headerlink" title="几张图让你看懂WebAssembly"></a>几张图让你看懂WebAssembly</h1><p>最近，WebAssembly 在 Java 圈非常的火！人们都在谈论它多么多么快，怎样怎样改变 Web 开发领域。但是没有人讲他到底为什么那么快。在这篇文章里，我将会帮你了解 WebAssembly 到底为什么那么快。</p><p>第一，我们需要知道它到底是什么！WebAssembly 是一种可以使用非 Java 编程语言编写代码并且能在浏览器上运行的技术方案。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c397f83106e5460091a5d65fbf8c3060_th.png" alt="img"></p><p>当大家谈论起 WebAssembly 时，首先想到的就是 Java。现在，我没有必须在 WebAssembly 和 Java 中选一个的意思。实际上，我们期待开发者在一个项目中把 WebAssembly 和 Java 结合使用。但是，比较这两者是有用的，这对你了解 WebAssembly 有一定帮助。</p><p>\1. 一点点性能历史</p><p>1995 年 Java 诞生。它的设计时间非常短，前十年发展迅速。</p><p>紧接着浏览器厂商们就开始了更多的竞争。</p><p>2008年，人们称之为浏览器性能大战的时期开始了。很多浏览器加入了即时编译器，又称之为JITs。在这种模式下，Java在运行的时候，JIT 选择模式然后基于这些模式使代码运行更快。</p><p>这些 JITs 的引入是浏览器运行代码机制的一个转折点。所有的突然之间，Java 的运行速度快了10倍。</p><p><img src="http://img.mp.sohu.com/upload/20170518/199869a47f53403db81c516d1d382028_th.png" alt="img"></p><p>随着这种改进的性能，Java 开始被用于意想不到的事情，比如使用Node.js和Electron构建应用程序。</p><p>现在 WebAssembly 可能是的另一个转折点。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d50035df838b41e7a880d1e853c8d76d_th.png" alt="img"></p><p>在我们没有搞清楚 Java 和 WebAssembly 之间的性能差前，我们需要理解 JS 引擎所做的工作。</p><p>\2. Java 是如何在浏览器中运行的呢？</p><p>作为一个开发人员，您将Java添加到页面时，您有一个目标并遇到一个问题。</p><ul><li>目标：你想要告诉计算机做什么</li><li>问题：你和计算机使用不通的语言。</li></ul><p>您说的是人类的语言，计算机说的是机器语言。尽管你不认为 Java 或者其他高级语言是人类语言，但事实就是这样的。它们的设计是为了让人们认知，不是为机器设计的。</p><p>所以Java引擎的工作就是把你的人类语言转化成机器所理解的语言。</p><p>我想到电影《Arrival》，这就像人类和外星人进行交谈。</p><p><img src="http://img.mp.sohu.com/upload/20170518/67ceb7bfa4294effa890d6d8a7406eec_th.png" alt="img"></p><p>在这部电影中，人类语言不能从逐字翻译成外星语言。他们的语言反映出两种对世界不同的认知。人类和机器也是这样。</p><p>所以，怎么进行翻译呢？</p><p>在编程中，通常有两种翻译方法将代码翻译成机器语言。你可以使用解释器或者编译器。</p><p>使用解释器，翻译的过程基本上是一行一行及时生效的。</p><p><img src="http://img.mp.sohu.com/upload/20170518/98882314037d4f4d90ae8e7537fa3c94_th.png" alt="img"></p><p>编译器是另外一种工作方式，它在执行前翻译。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c4fcbfd4e975496c9c09ddb31f3cf672_th.png" alt="img"></p><p>每种翻译方法都有利弊。</p><p>2.1 解释器的利弊</p><p>解释器很快的获取代码并且执行。您不需要在您可以执行代码的时候知道全部的编译步骤。因此，解释器感觉与 Java 有着自然的契合。web 开发者能够立即得到反馈很重要。</p><p>这也是浏览器最开始使用 Java 解释器的原因之一。</p><p>但是实用解释器的弊端是当你运行相同的代码的时候。比如，你执行了一个循环。然后你就会一遍又一遍的做同样的事情。</p><p>2.2 编译器的利弊</p><p>编译器则有相反的效果。在程序开始的时候，它可能需要稍微多一点的时间来了解整个编译的步骤。但是当运行一个循环的时候他会更快，因为他不需要重复的去翻译每一次循环里的代码。</p><p>因为解释器必须在每次循环访问时不断重新转换代码，作为一个可以摆脱解释器低效率的方法，浏览器开始将编译器引入。</p><p>不同的浏览器实现起来稍有不同，但是基本目的是相同的。他们给 Java 引擎添加了一个新的部分，称为监视器（也称为分析器）。该监视器在 Java 运行时监控代码，并记录代码片段运行的次数以及使用了那些数据类型。</p><p>如果相同的代码行运行了几次，这段代码被标记为 “warm”。如果运行次数比较多，就被标记为 “hot”。</p><p>被标记为 “warm” 的代码被扔给基础编译器，只能提升一点点的速度。被标记为 “hot” 的代码被扔给优化编译器，速度提升的更多。</p><p><img src="http://img.mp.sohu.com/upload/20170518/3963d47dc81a4832918a8e65e107dade_th.png" alt="img"></p><p>了解更多，可以读 <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a></p><p>\3. 耗时比较：Java Vs. WebAssembly</p><p>这张图大致给出了现在一个程序的启动性能，目前 JIT 编译器在浏览器中很常见。</p><blockquote><p>该图显示了 JS 引擎运行程序花费的时间。显示的时间并不是平均的。这个图片表明，JS 引擎做的这些任务花费的时间取决于页面中 Java 做了什么事情。但是我们可以用这个图来构建一个心理模型。</p></blockquote><p><img src="http://img.mp.sohu.com/upload/20170518/0e7c178a93764f739671e7a82bc42120.png" alt="img"></p><p>每栏显示花费在特定任务上的时间。</p><ul><li>Parsing - 讲源码转换成解释器可以运行的东西所用的事情。</li><li>Compiling + optimizing - 花费在基础编译和优化编译上的时间。有一些优化编译的工作不在主线程，所以这里并不包括这些时间。</li><li>Re-optimizing - 当预先编译优化的代码不能被优化的情况下，JIT 将这些代码重新优化，如果不能重新优化那么久丢给基础编译去做。这个过程叫做重新优化。</li><li>Execution - 执行代码的过程</li><li>Garbage collection - 清理内存的时间</li></ul><p>一个重要的事情要注意：这些任务不会发生在离散块或特定的序列中。相反，它们将被交叉执行。比如正在做一些代码解析时，还执行者一些其他的逻辑，有些代码编译完成后，引擎又做了一些解析，然后又执行了一些逻辑，等等。</p><p>这种交叉执行对早期 Java 的性能有很大的帮助，早期的 Java 的执行就像下图一样：</p><p><img src="http://img.mp.sohu.com/upload/20170518/416ed043b72f44e9a4c059ab13bd89a8.png" alt="img"></p><p>一开始，当只有一个解释器运行 Java 时，执行速度相当缓慢。JITs 的引入，大大提升了执行效率。</p><p>监视和编译代码的开销是需要权衡的事情。如果 Java 开发人员按照相同的方式编写Java，解析和编译时间将会很小。但是，性能的提升使开发人员能够创建更大的Java应用程序。</p><p>这意味着还有改进的余地。</p><p>下面是 WebAssembly 如何比较典型 web 应用。</p><p><img src="http://img.mp.sohu.com/upload/20170518/e88618ea7fb0477e9155d0143b6575e1_th.png" alt="img"></p><p>浏览器的 JS 引擎有轻微的不同。我是基于 SpiderMonkey 来讲。</p><p>3.1 请求</p><p>这没有展示在图上，但是从服务器获取文件是会消耗时间的</p><p>下载执行与 Java 等效的 WebAssembly 文件需要更少的时间，因为它的体积更小。WebAssembly 设计的体积更小，可以以二进制形式表示。</p><p>即使使用 gzip 压缩的 Java文件很小，但 WebAssembly 中的等效代码可能更小。</p><p>所以说，下载资源的时间会更少。在网速慢的情况下更能显示出效果来。</p><p>3.2 解析</p><p>Java 源码一旦被下载到浏览器，源将被解析为抽象语法树（AST）。</p><p>通常浏览器解析源码是懒惰的，浏览器首先会解析他们真正需要的东西，没有及时被调用的函数只会被创建成存根。</p><p>在这个过程中，AST被转换为该 JS 引擎的中间表示（称为字节码）。</p><p>相反，WebAssembly 不需要被转换，因为它已经是字节码了。它仅仅需要被解码并确定没有任何错误。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c174c765cffc48aea914270ab46c0fc0_th.png" alt="img"></p><p>3.3 编译 + 优化</p><p>如前所述，Java 是在执行代码期间编译的。因为 Java 是动态类型语言，相同的代码在多次执行中都有可能都因为代码里含有不同的类型数据被重新编译。这样会消耗时间。</p><p>相反，WebAssembly 与机器代码更接近。例如，类型是程序的一部分。这是速度更快的一个原因：</p><ul><li>编译器不需要在运行代码时花费时间去观察代码中的数据类型，在开始编译时做优化。</li><li>编译器不需要去每次执行相同代码中数据类型是否一样。</li><li>更多的优化在 LLVM 最前面就已经完成了。所以编译和优化的工作很少。</li></ul><p><img src="http://img.mp.sohu.com/upload/20170518/dc75aae14a4743cda8b07788bfc8ccf4_th.png" alt="img"></p><p>3.4 重新优化</p><p>有时 JIT 抛出一个优化版本的代码，然后重新优化。</p><p>JIT 基于运行代码的假设不正确时，会发生这种情况。例如，当进入循环的变量与先前的迭代不同时，或者在原型链中插入新函数时，会发生重新优化。</p><p>在 WebAssembly 中，类型是明确的，因此 JIT 不需要根据运行时收集的数据对类型进行假设。这意味着它不必经过重新优化的周期。</p><p><img src="http://img.mp.sohu.com/upload/20170518/0c03cc06b07a4007bc522131579d59e0_th.png" alt="img"></p><p>3.5 执行</p><p>尽可能编写执行性能好的 Java。所以，你可能需要知道 JIT 是如何做优化的。</p><p>然而，大多数开发者并不知道 JIT 的内部原理。即使是那些了解 JIT 内部原理的开发人员，也很难实现最佳的方案。有很多时候，人们为了使他们的代码更易于阅读（例如：将常见任务抽象为跨类型工作的函数）会阻碍编译器优化代码。</p><p>正因如此，执行 WebAssembly 代码通常更快。有些必须对 Java 做的优化不需要用在 WebAssembly 上</p><p>另外，WebAssembly 是为编译器设计的。意思是，它是专门给编译器来阅读，并不是当做编程语言让程序员去写的。</p><p>由于程序员不需要直接编程，WebAssembly 提供了一组更适合机器的指令。根据您的代码所做的工作，这些指令的运行速度可以在10％到800％之间。</p><p><img src="http://img.mp.sohu.com/upload/20170518/cbbf6cb36a9147bbb4609277212b743e_th.png" alt="img"></p><p>3.6 垃圾回收</p><p>在 Java 中，开发者不需要担心内存中无用变量的回收。JS 引擎使用一个叫垃圾回收器的东西来自动进行垃圾回收处理。</p><p>这对于控制性能可能并不是一件好事。你并不能控制垃圾回收时机，所以它可能在非常重要的时间去工作，从而影响性能。</p><p>现在，WebAssembly 根本不支持垃圾回收。内存是手动管理的（就像 C&#x2F;C++）。虽然这些可能让开发者编程更困难，但它的确提升了性能。</p><p><img src="http://img.mp.sohu.com/upload/20170518/5e0ef2344f5b4b5382e3345fbb1a4900_th.png" alt="img"></p><p>总而言之，这些都是在许多情况下，在执行相同任务时WebAssembly 将胜过 Java 的原因。</p><p>在某些情况下，WebAssembly 不能像预期的那样执行，还有一些更改使其更快。我在另一篇文章中更深入地介绍了这些未来的功能。</p><p>\4. WebAssembly 是如何工作的？</p><p>现在，您了解开发人员为什么对 WebAssembly 感到兴奋，让我们来看看它是如何工作的。</p><p>当我谈到上面的 JIT 时，我谈到了与机器的沟通像与外星人沟通。</p><p><img src="http://img.mp.sohu.com/upload/20170518/b4e48c1abb9d4c24a4faa9ba8bbcf804_th.png" alt="img"></p><p>我现在想看看这个外星人的大脑如何工作 - 机器的大脑如何解析和理解交流内容。</p><p>这个大脑的一部分是专注于思考，例如算术和逻辑。有一部分脑部提供短期记忆，另一部分提供长期记忆。</p><p>这些不同的部分都有名字。</p><ul><li>负责思考的部分是算术逻辑单元（ALU）。</li><li>短期储存由寄存器（Registers）提供。</li><li>随机存储器（或RAM）来提供长期储存能力。</li></ul><p><img src="http://img.mp.sohu.com/upload/20170518/83ee9677b2a949a985b63b52ccb8389f_th.png" alt="img"></p><p>机器码中的语句被称为指令。</p><p>当一条指令进入大脑时会发生什么？它被拆分成了多个的部分并有特殊的含义。</p><p>被拆分成的多个部分分别进入不同的大脑单元进行处理，这也是拆分指令所依赖的方式。</p><p>例如，这个大脑从机器码中取出4-10位，并将它们发送到 ALU。ALU进行计算，它根据 0 和 1 的位置来确定是否需要将两个数相加。</p><p>这个块被称为“操作码”，因为它告诉 ALU 执行什么操作。</p><p><img src="http://img.mp.sohu.com/upload/20170518/88a3f256982748938fa8c707f8fa4a12_th.png" alt="img"></p><p>那么这个大脑会拿后面的两个块来确定他们所要操作的数。这两个块对应的是寄存器的地址。</p><p><img src="http://img.mp.sohu.com/upload/20170518/b9480bcd570b485097798d1b460c6a20_th.png" alt="img"></p><p>请注意添加在机器码上面的标注（ADD R1 R2），这使我们更容易了解发生了什么。这就是汇编。它被称为符号机器码。这样人类也能看懂机器码的含义。</p><p>您可以看到，这个机器的汇编和机器码之间有非常直接的关系。每种机器内部有不同的结构，所以每种机器都有自己独有的汇编语言。</p><p>所以我们并不只有一个翻译的目标。</p><p>相反，我们的目标是不同类型的机器码。就像人类说不同的语言一样，机器也有不同的语言。</p><p>您希望能够将这些任何一种高级编程语言转换为任何一种汇编语言。这样做的一个方法是创建一大堆不同的翻译器，可以从任意一种语言转换成任意一种汇编语言。</p><p><img src="http://img.mp.sohu.com/upload/20170518/043aeb5c166145ae9f39f42441031ab1_th.png" alt="img"></p><p>这样做的效率非常低。为了解决这个问题，大多数编译器会在高级语言和汇编语言之间多加一层。编译器将把高级语言翻译成一种更低级的语言，但比机器码的等级高。这就是中间代码（IR）。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d074ef3889144ab0a5ca04646d4b229e_th.png" alt="img"></p><p>意思就是编译器可以将任何一种高级语言转换成一种中间语言。然后，编译器的另外的部分将中间语言编译成目标机器的汇编代码。</p><p>编译器的“前端”将高级编程语言转换为IR。编译器的“后端”将 IR 转换成目标机器的汇编代码。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c36feccdd6554799ba4da393083b2603_th.png" alt="img"></p><p>4.1 WebAssembly 适合在哪里使用？</p><p>您可能会将 WebAssembly 当做是另外一种目标汇编语言。这是真的，这些机器语言（x86，ARM等）中的每一种都对应于特定的机器架构。</p><p>当你的代码运行在用户的机器的 web 平台上的时候，你不知道你的代码将会运行在那种机器结构上。</p><p>所以 WebAssembly 和别的汇编语言是有一些不同的。所以他是一个概念机上的机器语言，不是在一个真正存在的物理机上运行的机器语言。</p><p>正因如此，WebAssembly 指令有时候被称为虚拟指令。它比 Java 代码更快更直接的转换成机器代码，但它们不直接和特定硬件的特定机器代码对应。</p><p>在浏览器下载 WebAssembly后，使 WebAssembly 的迅速转换成目标机器的汇编代码。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d84a8a4c7ca14077b034a8cee345330c_th.png" alt="img"></p><p>如果想在您的页面里上添加 WebAssembly，您需要将您的代码编译成 .wasm 文件。</p><p>\5. 编译到 .wasm 文件</p><p>当前对 WebAssembly 支持最多的编译器工具链称是 LLVM。有许多不同的“前端”和“后端”可以插入到 LLVM 中。</p><p>注意：大多数 WebAssembly 模块开发者使用 C 和 Rust 编写代码，然后编译成 WebAssembly，但是这里有其他创建 WebAssembly 模块的途径。比如，这里有一个实验性工具，他可以帮你使用 Type 创建一个 WebAssembly 模块，你可以在这里直接编辑WebAssembly。</p><p>架设我们想通过 C 来创建 WebAssembly。我们可以使用 clang “前端” 从 C 编译成 LLVM 中间代码。当它变成 LLVM 的中间代码（IR）以后，LLVM 可以理解他，所以 LLVM 可以对代码做一些优化。</p><p>如果想让 LLVM 的 IR 变成 WebAssembly，我们需要一个 “后端”。目前 LLVM 项目中有一个正在开发中的。这个“后端”对做这件事情很重要，应该很快就会完成。可惜，它现在还不能用。</p><p>另外有一个工具叫做 Emen，它用起来比较简单。它还可以有比较有用的可以选择，比如说由 IndexDB 支持的文件系统。</p><p><img src="http://img.mp.sohu.com/upload/20170518/9fb176cae37a45289c06d50b8d4d9d9c_th.png" alt="img"></p><p>不管你使用的什么工具链，最终的结果都应该是以 .wasm 结尾的文件。来让我们看一下如何将它用在你的 web 页面。</p><p>\6. 在 Java 中加载一个 .wasm 组件</p><p>.wasm 文件是 WebAssembly 组件，它可以被 Java 加载。到目前为止，加载过程有点复杂。</p><blockquote><p>functionfetchAndInstantiate(url,importObject){</p><p>returnfetch(url).then(response &#x3D;&gt;</p><p>response.arrayBuffer()</p><p>).then(bytes &#x3D;&gt;</p><p>WebAssembly.instantiate(bytes,importObject)</p><p>).then(results &#x3D;&gt;</p><p>results.instance</p><p>);</p><p>}</p></blockquote><p>您可以在文档中更深入地了解这些。</p><p>我们正在努力使这个过程更容易。我们期望对工具链进行改进，并与现有的模块管理工具（如Webpack）或加载器（如SystemJS）相结合。我相信，加载 WebAssembly 模块越来越简单，就像加载 Java 一样。</p><p>但是，WebAssembly模块和JS模块之间存在重大差异。目前，WebAssembly 中的函数只能使用 WebAssembly 类型（整数或浮点数）作为参数或返回值。</p><p><img src="http://img.mp.sohu.com/upload/20170518/76579804e91847d0a4aab50f4e6a0626.png" alt="img"></p><p>对于任何更复杂的数据类型（如字符串），必须使用 WebAssembly 模块的内存。</p><p>如果你之前主要使用 Java，可能对于直接访问内存是不熟悉的。C，C ++和Rust等性能更高的语言往往具有手动内存管理功能。WebAssembly 模块的内存模拟这些语言中的堆。</p><p>为此，它使用 Java 中称为 ArrayBuffer。ArrayBuffer 是一个字节数组。因此，数组的索引作为内存地址。</p><p>如果要在 Java 和 WebAssembly 之间传递一个字符串，需要将字符转换为等效的字符码。然后你需要将它写入内存数组。由于索引是整数，所以可以将索引传递给 WebAssembly 函数。因此，字符串的第一个字符的索引可以当作指针。</p><p><img src="http://img.mp.sohu.com/upload/20170518/98e2fbd269ad4543b7fa485abc93e42d_th.png" alt="img"></p><p>任何人开发的 WebAssembly 模块很可能被 Web 开发人员使用并为该模块创建一个的装饰器。这样，您当做用户来使用这个模块就不需要考虑内存管理的事情了。</p><p>我已经在另一篇文章中解释了更多关于使用WebAssembly模块的内容。</p><p>\7. WebAssembly 现在是什么状态？</p><p>二月二十八日，四大浏览器宣布达成共识，即 WebAssembly 的 MVP （最小化可行产品）已经完成。大约一周后，Firefox会默认打开 WebAssembly 支持，而Chrome则在第二周开始。它也可用于预览版本的Edge和Safari。</p><p>这提供了一个稳定的初始版本，浏览器开始支持。</p><p><img src="http://img.mp.sohu.com/upload/20170518/f463c848d531411798ab6eb0461a8041_th.png" alt="img"></p><p>该核心不包含社区组织计划的所有功能。即使在初始版本中，WebAssembly 也会很快。但是，通过修复和新功能的组合，将来应该能够更快。我在另一篇文章中详细介绍了这些功能。</p><p>\8. 总结</p><p>使用WebAssembly，可以更快地在 web 应用上运行代码。这里有 几个 WebAssembly 代码运行速度比 Java 高效的原因。</p><ul><li>文件加载 - WebAssembly 文件体积更小，所以下载速度更快。</li><li>解析 - 解码 WebAssembly 比解析 Java 要快</li><li>编译和优化 - 编译和优化所需的时间较少，因为在将文件推送到服务器之前已经进行了更多优化，Java 需要为动态类型多次编译代码</li><li>重新优化 - WebAssembly 代码不需要重新优化，因为编译器有足够的信息可以在第一次运行时获得正确的代码</li><li>执行 - 执行可以更快，WebAssembly 指令更接近机器码</li><li>垃圾回收 - 目前 WebAssembly 不直接支持垃圾回收，垃圾回收都是手动控制的，所以比自动垃圾回收效率更高。</li></ul><p>目前浏览器中的 MVP（最小化可行产品） 已经很快了。在接下来的几年里，随着浏览器的发展和新功能的增加，它将在未来几年内变得更快。没有人可以肯定地说，这些性能改进可以实现什么样的应用。但是，如果过去有任何迹象，我们可以期待惊奇。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios 总结</title>
      <link href="/2017/06/10/%E5%89%8D%E7%AB%AF/axios%20%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/10/%E5%89%8D%E7%AB%AF/axios%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-总结"><a href="#axios-总结" class="headerlink" title="axios 总结"></a>axios 总结</h2><blockquote><p>公司目前没有web端开发，逐步需要做运维，运营的页面，想要快速开展工作，<br>就去了解了下目前比较火的前端框架，前端框架层出不穷技术栈也是日新月异，react vue angular，在做过一段时间了解和对比之后，认为目前vue是最合适的。</p></blockquote><blockquote><p>去官网熟悉了一下基本文档，写了几个demo，就开始设计运营业务的前端架构，借鉴很多github上的优秀作品，今天主要是总结下接口调用的http框架：axios</p></blockquote><blockquote><p>之前使用JQuery时，接口调用是通过$.ajax， 在熟悉vue的过程中，去了解到这块的解决方案，虽然vue全家桶中，提供了vue-resource，但是vue2.0版本以后，尤大宣布不再继续维护vue-resource，并推荐使用 axios，通过实践后，发现axios确实好用~</p></blockquote><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul><li>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端</li></ul><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF&#x2F;XSRF</li></ul><h3 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h3><p>Using npm:</p><pre><code>$ npm install axios</code></pre><p>Using bower:</p><pre><code>$ bower install axios</code></pre><p>Using cdn:</p><pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>我的项目使用的是vue-cli脚手架构建，使用的npm的安装方式进行引入</p><pre><code>npm install --save axios</code></pre><h3 id="使用举例："><a href="#使用举例：" class="headerlink" title="使用举例："></a>使用举例：</h3><ul><li><p>GET 请求</p><pre><code>  // Make a request for a user with a given ID  axios.get(&#39;/user?ID=12345&#39;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);    // Optionally the request above could also be done as  axios.get(&#39;/user&#39;, &#123;      params: &#123;        ID: 12345      &#125;    &#125;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);</code></pre></li><li><p>POST 请求</p><pre><code>  axios.post(&#39;/user&#39;, &#123;      firstName: &#39;Fred&#39;,      lastName: &#39;Flintstone&#39;    &#125;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);</code></pre></li><li><p>并发请求</p><pre><code>  function getUserAccount() &#123;    return axios.get(&#39;/user/12345&#39;);  &#125;  function getUserPermissions() &#123;    return axios.get(&#39;/user/12345/permissions&#39;);  &#125;  axios.all([getUserAccount(), getUserPermissions()])    .then(axios.spread(function (acct, perms) &#123;      //两个请求现已完成    &#125;));</code></pre></li></ul><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过向 axios 传递相关配置来创建请求</p><p>axios(config)</p><pre><code>// 发送 POST 请求axios(&#123;  method: &#39;post&#39;,  url: &#39;/user/12345&#39;,  data: &#123;    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;  &#125;&#125;);</code></pre><p>axios(url[, config])</p><pre><code>// 发送 GET 请求（默认的方法）axios(&#39;/user/12345&#39;);</code></pre><h4 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h4><p>为方便起见，为所有支持的请求方法提供了别名</p><pre><code>axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])</code></pre><ul><li>注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</li></ul><p>并发</p><p>处理并发请求的助手函数</p><pre><code>axios.all(iterable)axios.spread(callback)</code></pre><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>可以使用自定义配置新建一个 axios 实例</p><p>axios.create([config])</p><pre><code>var instance = axios.create(&#123;  baseURL: &#39;https://some-domain.com/api/&#39;,  timeout: 1000,  headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;&#125;);</code></pre><h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p><pre><code>axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])</code></pre><h4 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h4><p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</p><pre><code>&#123;  // `url` 是用于请求的服务器 URL  url: &#39;/user&#39;,  // `method` 是创建请求时使用的方法  method: &#39;get&#39;, // 默认是 get  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL  baseURL: &#39;https://some-domain.com/api/&#39;,  // `transformRequest` 允许在向服务器发送前，修改请求数据  // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream  transformRequest: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据  transformResponse: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `headers` 是即将被发送的自定义请求头  headers: &#123;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;,  // `params` 是即将与请求一起发送的 URL 参数  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象  params: &#123;    ID: 12345  &#125;,  // `paramsSerializer` 是一个负责 `params` 序列化的函数  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)  paramsSerializer: function(params) &#123;    return Qs.stringify(params, &#123;arrayFormat: &#39;brackets&#39;&#125;)  &#125;,  // `data` 是作为请求主体被发送的数据  // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;  // 在没有设置 `transformRequest` 时，必须是以下类型之一：  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams  // - 浏览器专属：FormData, File, Blob  // - Node 专属： Stream  data: &#123;    firstName: &#39;Fred&#39;  &#125;,  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)  // 如果请求话费了超过 `timeout` 的时间，请求将被中断  timeout: 1000,  // `withCredentials` 表示跨域请求时是否需要使用凭证  withCredentials: false, // 默认的  // `adapter` 允许自定义处理请求，以使测试更轻松  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).  adapter: function (config) &#123;    /* ... */  &#125;,  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头  auth: &#123;    username: &#39;janedoe&#39;,    password: &#39;s00pers3cret&#39;  &#125;,  // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;  responseType: &#39;json&#39;, // 默认的  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称  xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认的  // `onUploadProgress` 允许为上传处理进度事件  onUploadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `onDownloadProgress` 允许为下载处理进度事件  onDownloadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `maxContentLength` 定义允许的响应内容的最大尺寸  maxContentLength: 2000,  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的  &#125;,  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  // 如果设置为0，将不会 follow 任何重定向  maxRedirects: 5, // 默认的  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：  // `keepAlive` 默认没有启用  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),  // &#39;proxy&#39; 定义代理服务器的主机名称和端口  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。  proxy: &#123;    host: &#39;127.0.0.1&#39;,    port: 9000,    auth: : &#123;      username: &#39;mikeymike&#39;,      password: &#39;rapunz3l&#39;    &#125;  &#125;,  // `cancelToken` 指定用于取消请求的 cancel token  // （查看后面的 Cancellation 这节了解更多）  cancelToken: new CancelToken(function (cancel) &#123;  &#125;)&#125;</code></pre><h4 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h4><p>某个请求的响应包含以下信息</p><pre><code>&#123;  // `data` 由服务器提供的响应  data: &#123;&#125;,  // `status` 来自服务器响应的 HTTP 状态码  status: 200,  // `statusText` 来自服务器响应的 HTTP 状态信息  statusText: &#39;OK&#39;,  // `headers` 服务器响应的头  headers: &#123;&#125;,  // `config` 是为请求提供的配置信息  config: &#123;&#125;&#125;</code></pre><p>使用 then 时，你将接收下面这样的响应：</p><pre><code>axios.get(&#39;/user/12345&#39;)  .then(function(response) &#123;    console.log(response.data);    console.log(response.status);    console.log(response.statusText);    console.log(response.headers);    console.log(response.config);  &#125;);</code></pre><ul><li>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。</li></ul><h3 id="配置的默认值-x2F-defaults"><a href="#配置的默认值-x2F-defaults" class="headerlink" title="配置的默认值&#x2F;defaults"></a>配置的默认值&#x2F;defaults</h3><p>你可以指定将被用在各个请求的配置默认值</p><h4 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h4><pre><code>axios.defaults.baseURL = &#39;https://api.example.com&#39;;axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></pre><h4 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h4><pre><code>// 创建实例时设置配置的默认值var instance = axios.create(&#123;  baseURL: &#39;https://api.example.com&#39;&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;</code></pre><h4 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h4><p>配置会以一个优先顺序进行合并。这个顺序是：在 lib&#x2F;defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：</p><pre><code>// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get(&#39;/longRequest&#39;, &#123;  timeout: 5000&#125;);</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) &#123;    // 在发送请求之前做些什么    return config;  &#125;, function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error);  &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123;    // 对响应数据做点什么    return response;  &#125;, function (error) &#123;    // 对响应错误做点什么    return Promise.reject(error);  &#125;);</code></pre><p>如果你想在稍后移除拦截器，可以这样：</p><pre><code>var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor);</code></pre><p>可以为自定义 axios 实例添加拦截器</p><pre><code>var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;);</code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><pre><code>axios.get(&#39;/user/12345&#39;)  .catch(function (error) &#123;    if (error.response) &#123;      // 请求已发出，但服务器响应的状态码不在 2xx 范围内      console.log(error.response.data);      console.log(error.response.status);      console.log(error.response.headers);    &#125; else &#123;      // Something happened in setting up the request that triggered an Error      console.log(&#39;Error&#39;, error.message);    &#125;    console.log(error.config);  &#125;);</code></pre><p>可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。</p><pre><code>axios.get(&#39;/user/12345&#39;, &#123;  validateStatus: function (status) &#123;    return status &lt; 500; // 状态码在大于或等于500时才会 reject  &#125;&#125;)</code></pre><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>使用 cancel token 取消请求</p><blockquote><p>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。</p></blockquote><p>可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：</p><pre><code>var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&#39;/user/12345&#39;, &#123;  cancelToken: source.token&#125;).catch(function(thrown) &#123;  if (axios.isCancel(thrown)) &#123;    console.log(&#39;Request canceled&#39;, thrown.message);  &#125; else &#123;    // 处理错误  &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&#39;Operation canceled by the user.&#39;);</code></pre><p>还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：</p><pre><code>var CancelToken = axios.CancelToken;var cancel;axios.get(&#39;/user/12345&#39;, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    // executor 函数接收一个 cancel 函数作为参数    cancel = c;  &#125;)&#125;);// 取消请求cancel();</code></pre><ul><li>注意 : 可以使用同一个 cancel token 取消多个请求</li></ul><h3 id="使用application-x2F-x-www-form-urlencoded格式"><a href="#使用application-x2F-x-www-form-urlencoded格式" class="headerlink" title="使用application &#x2F; x-www-form-urlencoded格式"></a>使用application &#x2F; x-www-form-urlencoded格式</h3><pre><code> 默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</code></pre><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>在浏览器中，您可以使用URLSearchParams API，如下所示：</p><pre><code>var params = new URLSearchParams();params.append(&#39;param1&#39;, &#39;value1&#39;);params.append(&#39;param2&#39;, &#39;value2&#39;);axios.post(&#39;/foo&#39;, params);</code></pre><ul><li>请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。</li></ul><p>或者，您可以使用qs库对数据进行编码：</p><pre><code>var qs = require(&#39;qs&#39;);axios.post(&#39;/foo&#39;, qs.stringify(&#123; &#39;bar&#39;: 123 &#125;);</code></pre><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>在node.js中，可以使用querystring模块，如下所示：</p><pre><code>var querystring = require(&#39;querystring&#39;);axios.post(&#39;http://something.com/&#39;, querystring.stringify(&#123; foo: &#39;bar&#39; &#125;);</code></pre><p>当然也可以使用qs库。</p><h3 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h3><p>在vue项目中，新建api&#x2F;index.js</p><pre><code>import axios from &#39;axios&#39;</code></pre><p>将所有的api集中到该文件中，方便管理</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 指纹信息相关</title>
      <link href="/2017/05/19/%E5%89%8D%E7%AB%AF/%20js%20%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/"/>
      <url>/2017/05/19/%E5%89%8D%E7%AB%AF/%20js%20%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="js-浏览器指纹信息相关"><a href="#js-浏览器指纹信息相关" class="headerlink" title="js 浏览器指纹信息相关"></a>js 浏览器指纹信息相关</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>近期的一个需求，app做第三方分享时，用微信，或QQ邀请好友，下载app，<span id="more"></span>在被邀请方从分享页面获取app信息及下载app，安装，注册后，希望<br>可以关联到邀请方信息，可用于在后端统计，及被邀请方注册登录后，直接提示用户是否 添加 邀请方为好友。一般做法为生成邀请码，在注册时，用户填写邀请码，但这种方式，大多数用户不用在注册时，填写难记的邀请码信息。</p></blockquote><blockquote><p>与同事们讨论后，讨论了一种方案，第三方分享是H5页面，用户在点开分享页面时，记录用户的信息（网络，手机设备等），生成一个唯一标识与分享者uid关联。新用户在注册时，关联用户的机型，网络，关联到分享者信息。</p></blockquote><blockquote><p>js一般只能获取到浏览器的信息，浏览器的userAgent中可以获取部分设备信息（手机型号，品牌之类），虽然碰撞率很高，但目前也基本可以满足需求，最终浏览器指纹起到了一些辅助作用，也借此机会了解下相关概念，熟悉下js可以获取哪些用户信息，这里做个简单的记录</p></blockquote><h3 id="js指纹的概念理解"><a href="#js指纹的概念理解" class="headerlink" title="js指纹的概念理解"></a>js指纹的概念理解</h3><blockquote><p>JS浏览器指纹的相关内容。浏览器指纹指的是通过JS采集用户的各种浏览器和设备信息，借此希望能生成相对唯一的uuid，用于区分用户</p></blockquote><h3 id="fingerprintjs2"><a href="#fingerprintjs2" class="headerlink" title="fingerprintjs2"></a>fingerprintjs2</h3><ul><li><a href="https://github.com/Valve/fingerprintjs2">fingerprintjs2 github地址</a></li></ul><blockquote><p>Fingerprintjs2是github上开源的设备指纹采集器。最初的fingerprintjs库创建于2012年，但是由于新版本的开发很难保持向后兼容，因此Fingerprintjs2项目中增加了很多的新内容。</p></blockquote><blockquote><p>该项目将更多、更有效的来源用于指纹识别，并且可配置，也就是说用户可以选择性地开启其中的选项。该项目还将重点关注IE插件，尤其是在中国流行的QQ、Baidu等。另外，该项目使用了semver（语义化的版本控制系统）。</p></blockquote><blockquote><p>Fingerprintjs2的原理是根据所能获取到的设备相关信息：比如系统字体、ua、帆布指纹等数据，筛选计算出一个（94%情况下）近似唯一的24位哈希值，可以作为设备的唯一性标识。它的特点是不依赖cookie，用户无法通过清除缓存来删除。设备指纹现在被很多互联网反欺诈公司拿来作为用户特征识别的方法，也被一些广告公司用来跟踪用户数据。</p></blockquote><h4 id="Fingerprintjs2-源码列出目前可以采集到的信息"><a href="#Fingerprintjs2-源码列出目前可以采集到的信息" class="headerlink" title="Fingerprintjs2 源码列出目前可以采集到的信息"></a>Fingerprintjs2 源码列出目前可以采集到的信息</h4><pre><code>    keys = this.userAgentKey(keys);    keys = this.languageKey(keys);    keys = this.colorDepthKey(keys);    keys = this.pixelRatioKey(keys);    keys = this.hardwareConcurrencyKey(keys);    keys = this.screenResolutionKey(keys);    keys = this.availableScreenResolutionKey(keys);    keys = this.timezoneOffsetKey(keys);    keys = this.sessionStorageKey(keys);    keys = this.localStorageKey(keys);    keys = this.indexedDbKey(keys);    keys = this.addBehaviorKey(keys);    keys = this.openDatabaseKey(keys);    keys = this.cpuClassKey(keys);    keys = this.platformKey(keys);    keys = this.doNotTrackKey(keys);    keys = this.pluginsKey(keys);    keys = this.canvasKey(keys);    keys = this.webglKey(keys);    keys = this.adBlockKey(keys);    keys = this.hasLiedLanguagesKey(keys);    keys = this.hasLiedResolutionKey(keys);    keys = this.hasLiedOsKey(keys);    keys = this.hasLiedBrowserKey(keys);    keys = this.touchSupportKey(keys);    keys = this.customEntropyFunction(keys);    var that = this;</code></pre><p>fingerprintjs的源码已经列出了目前能够收集到的几乎所有API，其中浏览器UA，语言，浏览器所在CPU等级（cpuclass，仅支持IE，chrome和firefox反回undefined），浏览器版本，等都是通过<code>navigator</code>对象获得，还有 <code>window.indexedDB</code> ， <code>window.sessionStorage</code> 和 <code>window.localStorage</code> 这一类h5新增的特性是否存在也被用作区分值</p><p>Fingerprintjs2还考虑到了一些比较特殊的自定义区分值，比如时区，或者是否在浏览器层做了一些UA欺骗，比如 hasLiedLanguagesKey ， HasLiedBrowser ， HasLiedOs 。以 hasliedLanguageKey 为例，通过判断navigator.language和navigator.languages中第一个方法是否相同来实现：</p><pre><code>try &#123;      var firstLanguages = navigator.languages[0].substr(0, 2);      if(firstLanguages !== navigator.language.substr(0, 2))&#123;        return true;      &#125;    &#125; catch(err)&#123;      return true;    &#125;</code></pre><p>其中区分度最高的应该就是浏览器插件检测了，因为它还涉及到了一个插件安装顺序的唯独，也是通过navigator对象获得，需要对IE单独处理，关键代码：</p><pre><code>var plugins = [];      for(var i = 0, l = navigator.plugins.length; i &lt; l; i++) &#123;        plugins.push(navigator.plugins[i]);      &#125;      // sorting plugins only for those user agents, that we know randomize the plugins      // every time we try to enumerate them      if(this.pluginsShouldBeSorted()) &#123;        plugins = plugins.sort(function(a, b) &#123;          if(a.name &gt; b.name)&#123; return 1; &#125;          if(a.name &lt; b.name)&#123; return -1; &#125;          return 0;        &#125;);      &#125;      return this.map(plugins, function (p) &#123;        var mimeTypes = this.map(p, function(mt)&#123;          return [mt.type, mt.suffixes].join(&quot;~&quot;);        &#125;).join(&quot;,&quot;);        return [p.name, p.description, mimeTypes].join(&quot;::&quot;);      &#125;, this);</code></pre><h3 id="其他一些资源获取"><a href="#其他一些资源获取" class="headerlink" title="其他一些资源获取"></a>其他一些资源获取</h3><h4 id="检测字体"><a href="#检测字体" class="headerlink" title="检测字体"></a>检测字体</h4><p>传统的方式是flash读取系统安装的字体，这里面还增加了一个通过css和js检测字体的方法，实现原理非常有趣。<br>以var text &#x3D; ‘mmmmmmmmmmlli’；举例，不同的字体在同一大小的fontsize情况下，这段字体的长度和宽度是不同的，通过比较css的width和height，既可以判断用户是否有安装了相应的字体。实现的时候，可以在页面中动态插入一个span，讲fontsize设置为较大的值便于比较。这个手段也可以用在平常前端开发中，用以判断某种特定字体用户是否安装</p><h4 id="Canvas-画布指纹"><a href="#Canvas-画布指纹" class="headerlink" title="Canvas 画布指纹"></a>Canvas 画布指纹</h4><p>canvas是Html5中非常重要的一个特性，它同时也可以用语js指纹的一个重要熵值。其中的原因是因为同一个canvas图像在不同的设备上（不同的GPU），由于不同的渲染引擎、压缩比例，输出格式，以及同一系统字体安装不同，导致最后输出也不相同。通过在canvas画布上画字体，最后由toDataURL()方法专为64位格式。这一方法实现成本低，无法被禁用，立刻收到了广泛关注，目前这一方法被认为是浏览器指纹中十分重要的一种方法。不过在我的测试中，我发现还是很容易产生碰撞的，最简单的例子是在移动端上，比如高度统一的iPhone上面，同一代机型由于硬件相同，且ios在不越狱的情况下无法自定义字体，这就导致了的任意两台iphone6s通过safari判断画笔指纹会百分之百的获得同样的64位编码….</p><p>相关：</p><p><a href="https://github.com/Valve/fingerprintjs2/wiki/List-of-options">List of options</a></p><p><a href="http://jcarlosnorte.com/security/2016/03/06/advanced-tor-browser-fingerprinting.html">Advanced Tor Browser Fingerprinting</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留意开源项目的变更记录</title>
      <link href="/2017/05/19/%E6%9D%82%E8%AE%B0/%E7%95%99%E6%84%8F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/05/19/%E6%9D%82%E8%AE%B0/%E7%95%99%E6%84%8F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用开源的东东，其版本更新后一定得多看更新记录</p></blockquote><p>今天下午打算把vue的一个项目从私有coding上提交到github上（提取一些组件，毕竟来源于开源，也要回馈开源）。以为只是简单的复制粘贴。提交下<br>提交前，验证下。发现所有引用echarts的地方都显示不了了<br>直接报 Can’t get dom width or height<br>仔细对比代码，一毛一样，一个没问题，一个有问题，又各种google了半天。还是看不出问题。后来想新环境我更新了依赖。echarts3只是有小小版本0.3-升级到0.4 感觉应该没啥，查了下github上的记录，引用方式变了。</p><pre><code>import IEcharts from &#39;vue-echarts-v3&#39;;更新为import IEcharts from &#39;vue-echarts-v3/src/full.vue&#39;;</code></pre><p>经常总结工作的方式，方法，经验，不断提高自己</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 依赖管理(升级)工具 npm-check-updates</title>
      <link href="/2017/05/01/%E5%89%8D%E7%AB%AF/%20npm%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86(%E5%8D%87%E7%BA%A7)%E5%B7%A5%E5%85%B7%20npm-check-updates/"/>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%20npm%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86(%E5%8D%87%E7%BA%A7)%E5%B7%A5%E5%85%B7%20npm-check-updates/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习vue以来，发现更新版本真快，不愧是版本帝。。项目使用的vue及其他一些依赖版本更新后，想验证下最新的稳定版本，就要对<code>dependencies</code> 中各种包进行升级</p></blockquote><p>node 升级的依赖包的传统方法</p><pre><code>npm update 名称</code></pre><p>项目依赖的三方包多了咋办，一个个update不显示，于是继续google，找到了2个工具：</p><ul><li><a href="https://github.com/dylang/npm-check">npm-check</a></li></ul><blockquote><p>检查过时的，不正确的和未使用的依赖项</p></blockquote><ul><li><a href="https://github.com/tjunnone/npm-check-updates">npm-check-updates</a></li></ul><blockquote><p>npm-check-updates是一个命令行工具，允许您将package.json或bower.json依赖关系升级到最新版本，而不管现有的版本约束。</p></blockquote><h3 id="npm-check-updates-安装"><a href="#npm-check-updates-安装" class="headerlink" title="npm-check-updates 安装"></a>npm-check-updates 安装</h3><pre><code>npm install -g npm-check-updates</code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>npm-check-updates （或者直接使用别名(alias) ncu）All dependencies match the latest package versions :)</code></pre><p>出现上面这句话就是表示目前的包都是最新的</p><pre><code> express           4.12.x  →   4.13.x multer            ^0.1.8  →   ^1.0.1 react-bootstrap  ^0.22.6  →  ^0.24.0 react-a11y        ^0.1.1  →   ^0.2.6 webpack          ~1.9.10  →  ~1.10.5Run with -u to upgrade your package.json</code></pre><p>以上是目前的版本，及最新的版本差异</p><p>更新dependencies到新版本：</p><pre><code>    ncu -u</code></pre><p>更新全部dependencies到最新版本(包括当前指定版本范围满足最新版本号的,比如^4.2.0 -&gt; ^4.3.0)：</p><pre><code>     ncu -a</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Encrypt certbot 自动申请https证书</title>
      <link href="/2017/04/20/%E7%BD%91%E7%BB%9C/%20Let&#39;s%20Encrypt%20certbot%20%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7https%E8%AF%81%E4%B9%A6/"/>
      <url>/2017/04/20/%E7%BD%91%E7%BB%9C/%20Let&#39;s%20Encrypt%20certbot%20%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7https%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>服务器之前从Let’s Encrypt申请的https证书到期了，没有自动更新证书，上个月有一台web服务是使用了certbot自动申请，更新证书的，没有记录，这次再操作有点生疏了，还是趁这次，把操作过程记下来，加深印象，理解吧</p></blockquote><h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><blockquote><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL&#x2F;TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性</p></blockquote><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。</p></blockquote><h2 id="SSL-x2F-TLS-是什么？"><a href="#SSL-x2F-TLS-是什么？" class="headerlink" title="SSL&#x2F;TLS 是什么？"></a>SSL&#x2F;TLS 是什么？</h2><blockquote><p>“ HTTP over SSL&#x2F;TLS ”字面意思就是带“安全套接层”的 http 协议，内心纯洁的同学也可以理解为“带安全套的 http ”，因为带了安全套，所以当然会比较安全（&#x2F;(ㄒoㄒ)&#x2F;~~）。其中 SSL 是“ Secure Sockets Layer ” 的缩写，是“安全套接层”的意思。 TLS 是 “Transport Layer Security” 的缩写，是 ” 传输层安全协议 ” 的意思。 SSL 和 TLS 是同一个东西的不同阶段，理解为同一个东西也行，都是安全协议就对了。</p></blockquote><h2 id="为什么要部署-https"><a href="#为什么要部署-https" class="headerlink" title="为什么要部署 https"></a>为什么要部署 https</h2><blockquote><p>说到底，就是 https 更安全。甚至为了安全，一个专业可靠的网站， https 是必须的。 Firefox 和 Chrome 都计划将没有配置 SSL 加密的 http 网站标记为不安全（貌似 Firefox 50 已经这么干了），目前它们也正在联合其他相关的基金会与公司推动整个互联网 https 化，现在大家访问的一些主要的网站。如 Google 多年前就已经全部启用 https ，国内的淘宝、搜狗、知乎、百度等等也全面 https 了。甚至 Google 的搜索结果也正在给予 https 的网站更高的排名和优先收录权。</p></blockquote><h2 id="Let’s-Encrypt-简介"><a href="#Let’s-Encrypt-简介" class="headerlink" title="Let’s Encrypt 简介"></a>Let’s Encrypt 简介</h2><blockquote><p>Let’s Encrypt 是 ISRG （Internet Security Research Group） 提供的一个免费、开放、自动化的证书签发服务。ISRG 是一个美国公益组织，总部在加州。由于得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅速，甚至连老牌的免费 SSL 服务商 StartSSL 也坐不住，推出了类似 Let’s Encrypt 的自动签发和续期工具。</p></blockquote><h2 id="Certbot-简介"><a href="#Certbot-简介" class="headerlink" title="Certbot 简介"></a>Certbot 简介</h2><blockquote><p>Certbot 的官方网站是 <a href="https://certbot.eff.org/">https://certbot.eff.org/</a> ，打开这个链接选择自己使用的 web server 和操作系统，EFF 官方会给出详细的使用方法</p></blockquote><h2 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h2><pre><code>#sudo yum install epel-release#sudo yum install certbot</code></pre><blockquote><p>安装过程中可能会报错，建议安装前，更新下pip</p></blockquote><pre><code>pip install --upgrade pip</code></pre><p>至少这些包要更新下</p><pre><code>pip install requests urllib3 pyOpenSSL --force --upgrade</code></pre><p>还有个错误，需要安装下pyOpenSSL 0.14及以上的版本，我是下载了pyOpenSSL-0.15.1-1.el7.noarch.rpm解决的</p><pre><code>sudo rpm -Uvh pyOpenSSL-0.15.1-1.el7.noarch.rpm</code></pre><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><pre><code>certbot certonly --email ff@mail.com --agree-tos --no-eff-email --webroot -w /var/www/html/home -d xx.xx.com</code></pre><p>证书信息会生成在 <code>/etc/letsencrypt/live</code> 目录</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><pre><code>ssl_certificate /etc/letsencrypt/live/xx.xx.com/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/xx.xx.com/privkey.pem;</code></pre><p>下面是一些本地不想在修改配置到新地址时，做个软连接就好</p><h2 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h2><p>ln -sfn &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xx.xx.com&#x2F;fullchain.pem fullchain.pem<br>ln -sfn &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xx.xx.com&#x2F;privkey.pem privkey.pem</p><h2 id="配置定时任务-没有装crontab的话，安装下"><a href="#配置定时任务-没有装crontab的话，安装下" class="headerlink" title="配置定时任务 (没有装crontab的话，安装下)"></a>配置定时任务 (没有装crontab的话，安装下)</h2><pre><code>yum -y install yum-cron</code></pre><h2 id="crontab-l"><a href="#crontab-l" class="headerlink" title="crontab -l"></a>crontab -l</h2><pre><code>30 2 15 * * /usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log35 2 15 * * /usr/local/openresty/nginx/sbin/nginx -s reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 import的路径问题</title>
      <link href="/2017/04/10/%E5%89%8D%E7%AB%AF/%20es6%20import%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/10/%E5%89%8D%E7%AB%AF/%20es6%20import%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="es6-import的路径问题"><a href="#es6-import的路径问题" class="headerlink" title="es6 import的路径问题"></a>es6 import的路径问题</h2><blockquote><p>在导入</p></blockquote><pre><code>This dependency was not found:* /src/store/function in ./src/store/modules/checklist/index.js, ./src/store/modules/checklist/mutations.js</code></pre><p>问题原因：</p><blockquote><p>export default 的用法</p></blockquote><p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，相反其它的export 输出 可以有多个，且import时必须加大括号，示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> xxx &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import xxx from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句，而export需要跟变量声明或者大括号作为输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;　　<span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;　　<span class="comment">// 写法2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>import 时候的路径问题(作为新手，遇到一些坑，刚好记录下)</p><p>开始玩的时候，总是出现 cannot find module 问题，原来 在 import 的时候 如果不使用相对路径或者绝对路径，node默认会去node_modules&#x2F;文件夹下去找，例如：</p><pre><code>import * as obj from &#39;exports&#39;// node 会试着去寻找 node_modules/exports.js 模块 // 正确写法 import * as obj from &#39;./exports&#39;</code></pre><p>关于 import * as obj from ‘xx’  这种写法是把所有的输出包裹到obj对象里</p><p>对了，还有模块的继承写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circleplus.js 当前模块继承了 circle 模块的所有输出</span></span><br><span class="line"><span class="comment">// 此处只是继承了输出，并不能直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;circle&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">exp</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承之后，circleplus.js 相当于下面代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">exp</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2简单总结</title>
      <link href="/2017/04/05/%E5%89%8D%E7%AB%AF/%20vue2%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2017/04/05/%E5%89%8D%E7%AB%AF/%20vue2%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="vue2-简单总结"><a href="#vue2-简单总结" class="headerlink" title="vue2 简单总结"></a>vue2 简单总结</h2><blockquote><p>一些自己的简单总结</p></blockquote><h3 id="一、渐进式："><a href="#一、渐进式：" class="headerlink" title="一、渐进式："></a>一、渐进式：</h3><p>从简单的引入js使用指令到构建大型web应用，都可以应付<br>简易的引入过程：<br>1.html中引入js的方式<br>2.构建自定义组件<br>3.使用组件组成网页<br>4.vue-cli(构建项目),vue,vuex（统一管理状态）,vue-route（页面路由）,webpack（自动构建，打包，发布）等 构建大型SPA(单网页应用)</p><h3 id="二、适合我们现在前端发展"><a href="#二、适合我们现在前端发展" class="headerlink" title="二、适合我们现在前端发展"></a>二、适合我们现在前端发展</h3><p>vue更关注视图层，我们现在页面还比较少，随着业务发展，页面的需求会持续增多，vue本身比较小，又支持渐进式发展，后面页面逐步增多，可以抽取做成vue组件，逐步可以通过插拔组件的方式完成页面开发，提高规范及效率</p><h3 id="三、MVVM"><a href="#三、MVVM" class="headerlink" title="三、MVVM"></a>三、MVVM</h3><p>数据模型&#x2F;页面 双向绑定<br>根据restful的接口，数据上的变动会直接渲染到页面，页面上的文案变化，也会影响到数据模型<br>比较适合我们现在的后端风格，可以考虑客户端mvvm的解决方案。</p><p>假期时，抽空简单总结了下vue常用的指令，就拿之前排行榜的例子重写了下。</p><p><a href="https://github.com/fantasykai/vue2-learn-leaderboard">https://github.com/fantasykai/vue2-learn-leaderboard</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集中式日志监控系统</title>
      <link href="/2017/03/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/03/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="集中式日志监控系统"><a href="#集中式日志监控系统" class="headerlink" title="集中式日志监控系统"></a>集中式日志监控系统</h1><h2 id="为什么需要日志管理系统"><a href="#为什么需要日志管理系统" class="headerlink" title="为什么需要日志管理系统"></a>为什么需要日志管理系统</h2><p>日志，对于任何系统都是重要的组成，作为程序猿，定位问题，查看系统的健康运载情况，都需要通过查询日志进行分析。</p><p>合理的软件架构往往都不会是单点的，即使在同一台应用服务器上，日志有不同的种类，nginx访问日志，操作系统，应用服务，业务逻辑等等。</p><p>没有日志管理系统时，我们如何分析日志：</p><p>tail，cat，grep，sed ，awk ，wc… 显然不可能登录到每一台应用服务器上敲命令。</p><p>于是建立一套集中式的方法，把不同来源的数据集中整合到一起，方便归纳分析，就成为解决以上痛点的方式方法。</p><h2 id="ELK-简介"><a href="#ELK-简介" class="headerlink" title="ELK 简介"></a>ELK 简介</h2><p>ELK 是 Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack,目前ELK Stack 已经成为最流行的集中式日志解决方案。</p><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写</p><p>主要特点</p><ul><li>实时分析</li><li>分布式实时文件存储，并将每一个字段都编入索引</li><li>文档导向，所有的对象全部是文档</li><li>高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。</li><li>支持 JSON</li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写</p><p>主要特点</p><ul><li>几乎可以访问任何数据</li><li>可以和多种外部应用结合</li><li>支持弹性扩展</li></ul><p>它由三个主要部分组成</p><ul><li>Shipper－发送日志数据</li><li>Broker－收集数据，缺省内置 Redis</li><li>Indexer－数据写入</li></ul><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 是一款基于 Apache 开源协议，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。</p><p>Elastic.co 在2016-10-27 发布了 Elastic Stack 5.0 以后目前更新的步伐还是很快的，并且Elastic.co 对部分好用插件开始收费。</p><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p>我在对ELK有了一定了解探索后，决定先使用 ELK 5 之前比较成熟的方案做一次搭建，尝试及进一步熟悉了解集中式日志监控系统，也方便应用到我们的测试及生成环境中。</p><p>各模块版本</p><ul><li>elasticsearch-2.4.4</li><li>logstash-2.3.4</li><li>kibana-4.6.3</li></ul><p>另外还引入消息队列</p><ul><li>zookeeper-3.4.9</li><li>kafka_2.11-0.10.2.0</li></ul><p>Logstash 作为日志收集端，比较消耗 CPU 和内存资源,从Elastic.co的官网找到了更好的替代方案：Beats组件</p><p>Beats 作为日志shipper</p><ul><li>Packetbeat（网络数据）；</li><li>Metricbeat（从系统和服务收集指标。从CPU到内存，Redis到Nginx等等，Metricbeat是一种轻量级的方式来发送系统和服务统计信息）；</li><li>Filebeat（日志文件）；</li><li>Winlogbeat（搜集 Windows 事件日志数据）。</li><li>Heartbeat （使用主动探测监视服务的可用性。给出一个URL列表，Heartbeat询问一个简单的问题：你活着吗？Heartbeat将此信息和响应时间发送到弹性堆栈的其余部分进行进一步分析）</li></ul><p>Beats 将搜集到的数据发送到 Logstash，经 Logstash 解析、过滤后，将其发送到 Elasticsearch 存储</p><p>相比 Logstash，Beats 所占系统的 CPU 和内存几乎可以忽略不计，这样解决了Logstash 在各服务器节点上占用系统资源高的问题。另外，Beats 和 Logstash 之间支持 SSL&#x2F;TLS 加密传输，客户端和服务器双向认证，保证了通信安全。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdj6dwfug4j20mo0jswft"></p><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdfbfjchczj214g10iwpx"></p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><p>简单把部署过程及配置文件进行记录，方便后续回顾及优化</p><h3 id="相关环境："><a href="#相关环境：" class="headerlink" title="相关环境："></a>相关环境：</h3><p>部署平台&#x2F;环境：</p><ul><li>linux centos7.2</li><li>jdk1.8.0_74</li></ul><h3 id="1-部署Elasticsearch集群"><a href="#1-部署Elasticsearch集群" class="headerlink" title="1.部署Elasticsearch集群"></a>1.部署Elasticsearch集群</h3><ul><li><a href="https://www.elastic.co/">elastic 官网</a></li></ul><p>我从官网下载了 <code>elasticsearch-2.4.4.tar.gz</code></p><h4 id="解压缩tar-tz"><a href="#解压缩tar-tz" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h4><pre><code>    cd /usr/local/elasticsearch    tar -zxvf elasticsearch-2.4.4.tar.gz</code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><pre><code>    cd /usr/local/elasticsearch/elasticsearch-2.4.4/config    vim elasticsearch.yml</code></pre><p>配置文件关键配置说明：</p><p>部分配置已经在部署图中有所说明，这里再补充一些字段说明：</p><pre><code> #配置es的集群名称，不同的集群用名字来区分，es会自动发现在同一网段下的es，配置成相同集群名字的各个节点形成一个集群。如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。    cluster.name: blu-es       #节点名称，es启动时会自动创建节点名称，自己配置下更方便维护吧    node.name: es01         #是否作为主节点    node.master: true        #是否存储数据     node.data: false    # 默认情况下，ElasticSearch使用0.0.0.0地址，并为http传输开启9200-9300端口，为节点到节点的通信开启9300-9400端口，可以自行设置IP地址    network.host: 我设置为内网的IP了    # 输监听定制端口    http.port: 9200    # 数据文件存储路径 此路径要创建出来    path.data: /home/elk/data    # 日志文件存储路径，此路径要创建出来    path.logs: /var/log/elasticsearch</code></pre><h4 id="ES环境启动"><a href="#ES环境启动" class="headerlink" title="ES环境启动"></a>ES环境启动</h4><ul><li><strong>elasticsearch默认是不支持用root用户来启动的。</strong></li></ul><p>解决方案：</p><ul><li><p>1.新建专门的用户用来管理elasticsearch，线上环境确实也不建议使用root用户</p></li><li><p>2.启动时，追加 <code>Des.insecure.allow.root=true</code></p><pre><code>  在 `/usr/local/elasticsearch/elasticsearch-2.4.4/bin/elasticsearch` 中增加 ES_JAVA_OPTS=&quot;-Des.insecure.allow.root=true&quot;</code></pre></li></ul><p>启动ES环境</p><pre><code>    cd /usr/local/elasticsearch/elasticsearch-2.4.4/bin    sh ./elasticsearch -d</code></pre><ul><li>-d表示后台启动</li></ul><h4 id="Elasticsearch插件安装"><a href="#Elasticsearch插件安装" class="headerlink" title="Elasticsearch插件安装"></a>Elasticsearch插件安装</h4><p>在熟悉Elasticsearch过程中，了解到有许多不错的插件，这里把简单记录下插件的安装方法</p><ul><li><p>通过plugin 命令进行安装</p><pre><code>  #head 方便对es进行各种操作的客户端，可以查看各个索引的数据量以及分片的状态，  /usr/share/elasticsearch/bin/plugin install mobz/elasticsearch-head  #kopf es的管理工具，也提供了对ES集群操作的API。  /usr/share/elasticsearch/bin/plugin install lmenezes/elasticsearch-kopf  #bigdesk 监控es状态的插  /usr/share/elasticsearch/bin/plugin install hlstudio/bigdesk</code></pre></li><li><p>还可以到github上查找插件的源码进行手动安装，安装细节不再赘述。</p></li><li><p>访问插件： <code>/_plugin/插件名称</code></p><pre><code>  如访问head  http://ip:9200/_plugin/head/</code></pre></li></ul><h4 id="Elasticsearch集群配置"><a href="#Elasticsearch集群配置" class="headerlink" title="Elasticsearch集群配置"></a>Elasticsearch集群配置</h4><p>主要是针对 <code>elasticsearch.yml</code>的配置，上述步骤已经对该文件部分关键字段说明，我在测试环境使用了3台做集群配置，通过head插件可以查看集群的状态：</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdl4okw4u7j20o60hrdks"></p><p>ES 集群搭建OK~</p><h3 id="2-部署kafka集群"><a href="#2-部署kafka集群" class="headerlink" title="2.部署kafka集群"></a>2.部署kafka集群</h3><p>Kafka集群是把状态保存在Zookeeper中的，首先要搭建Zookeeper集群。</p><ul><li>Zookeeper通过复制来实现高可用性，只要集群中半数以上的节点处于可用状态，它就能够保证服务继续。所以搭建集群的服务器台数应该为（2*n+1）台。</li></ul><h4 id="1-Zookeeper的安装配置"><a href="#1-Zookeeper的安装配置" class="headerlink" title="1) Zookeeper的安装配置"></a>1) Zookeeper的安装配置</h4><ul><li><a href="https://zookeeper.apache.org/">zookeeper官网</a></li></ul><p>上述说明zookeeper集群必须保证3台以上的服务器，我这里搭建3台zookeeper服务器</p><h5 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h5><ul><li>myid 为服务器编号，用于标识服务器，这个值必须和dataDir目录下myid文件中的值保证一致</li></ul><table><thead><tr><th>服务IP</th><th>myid</th></tr></thead><tbody><tr><td>10.11.1.11</td><td>11</td></tr><tr><td>10.11.1.12</td><td>12</td></tr><tr><td>10.11.1.13</td><td>13</td></tr></tbody></table><pre><code>为每台机器创建myid文件# 10.11.1.11echo 11 &gt;/home/zookeeper/data/myid# 10.11.1.12echo 12 &gt;/home/zookeeper/data/myid# 10.11.1.13echo 13 &gt;/home/zookeeper/data/myid</code></pre><h5 id="我从官网下载了-zookeeper-3-4-9-tar-gz"><a href="#我从官网下载了-zookeeper-3-4-9-tar-gz" class="headerlink" title="我从官网下载了 zookeeper-3.4.9.tar.gz"></a>我从官网下载了 <code>zookeeper-3.4.9.tar.gz</code></h5><h5 id="解压缩tar-tz-1"><a href="#解压缩tar-tz-1" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h5><pre><code>    cd /usr/local/zookeeper    tar -zxvf zookeeper-3.4.9.tar.gz</code></pre><h5 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><pre><code>    cd /usr/local/zookeeper/zookeeper-3.4.9/conf    cp zoo_sample.cfg zoo.cfg    vim zoo.cfg    # 这个时间是作为Zk服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime     tickTime=2000    # 此配置表示，允许follower(相对于Leaderer言的“客户端”)连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。    initLimit=10    # 此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。    syncLimit=5    # 数据的存放路径    dataDir=/home/zookeeper/data    # the port at which the clients will connect    clientPort=2181    # the maximum number of client connections.    # 最大的并发连接数限制，设置为0或者不设置该参数，表示不进行连接数的限制。    #maxClientCnxns=60        # 集群模式的配置参数    # 第一个端口是master和slave之间的通信端口，默认是2888，第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888    server.11=10.11.1.11:2888:3888    server.12=10.11.1.12:2888:3888    server.13=10.11.1.13:2888:3888        #    # Be sure to read the maintenance section of the     # administrator guide before turning on autopurge.    #    # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance    #    # The number of snapshots to retain in dataDir    #autopurge.snapRetainCount=3    # Purge task interval in hours    # Set to &quot;0&quot; to disable auto purge feature    #autopurge.purgeInterval=1</code></pre><p>每台的zoo.cfg的配置相同，复制到每一台即可</p><h5 id="启动zookeeper环境"><a href="#启动zookeeper环境" class="headerlink" title="启动zookeeper环境"></a>启动zookeeper环境</h5><pre><code>在bin目录下执行nohup ./zkServer.sh start &amp;</code></pre><h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><pre><code>./zkServer.sh statusUsing config: /usr/local/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfgMode: follower 或者 Mode: leader </code></pre><h4 id="2-kafka的安装配置"><a href="#2-kafka的安装配置" class="headerlink" title="2) kafka的安装配置"></a>2) kafka的安装配置</h4><ul><li><a href="https://kafka.apache.org/">kafka官网</a></li></ul><h5 id="我从kafka的官网下载了-kafka-2-11-0-10-2-0-tgz"><a href="#我从kafka的官网下载了-kafka-2-11-0-10-2-0-tgz" class="headerlink" title="我从kafka的官网下载了 kafka_2.11-0.10.2.0.tgz"></a>我从kafka的官网下载了 <code>kafka_2.11-0.10.2.0.tgz</code></h5><h5 id="解压缩tar-tz-2"><a href="#解压缩tar-tz-2" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h5><pre><code>    cd /usr/local/kafka    tar -zxvf kafka_2.11-0.10.2.0.tgz</code></pre><h5 id="修改配置文件-2"><a href="#修改配置文件-2" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><pre><code>    vim /usr/local/kafka/kafka_2.11-0.10.2.0/config/server.properties</code></pre><p>配置文件主要参数说明</p><pre><code>    #当前机器在集群中的唯一标识，和zookeeper的myid性质一样    broker.id=1          #当前kafka对外提供服务的端口默认是9092    port=9092 #不配置的话，默认为9092        #这个是borker进行网络处理的线程数    num.network.threads=3         #这个是borker进行I/O处理的线程数    num.io.threads=8         #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个    log.dirs=/usr/local/kafka/kafka_2.11-0.10.2.0/logs             #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能    socket.send.buffer.bytes=102400             #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘    socket.receive.buffer.bytes=102400         #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小    socket.request.max.bytes=104857600         #默认的分区数，一个topic默认1个分区数    num.partitions=6        #默认消息的最大持久化时间（小时）    log.retention.hours=60         #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件    log.segment.bytes=1073741824        #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除    log.retention.check.interval.ms=300000         #设置zookeeper的连接端口    zookeeper.connect=10.11.1.11:2181,10.11.1.12:2181,10.11.1.13:2181        指定客户端连接zookeeper的最大超时时间    zookeeper.connection.timeout.ms=6000</code></pre><ul><li>另外2台的配置只是需要修改broker.id即可，3台服务器保证broker.id不相同。</li></ul><h5 id="配置主机名对应IP的解析"><a href="#配置主机名对应IP的解析" class="headerlink" title="配置主机名对应IP的解析"></a>配置主机名对应IP的解析</h5><p><strong>3台配置相同</strong></p><pre><code>    vim /etc/hosts         10.11.1.11 server1    10.11.1.12 server2    10.11.1.13 server3</code></pre><h5 id="启动kafka环境"><a href="#启动kafka环境" class="headerlink" title="启动kafka环境"></a>启动kafka环境</h5><pre><code>    nohup ./kafka-server-start.sh ../config/server.properties &amp;</code></pre><p>kafka集群搭建OK</p><h3 id="3-部署logstash服务"><a href="#3-部署logstash服务" class="headerlink" title="3.部署logstash服务"></a>3.部署logstash服务</h3><p>在此架构中，logstash担任两种角色，也处于不同的层次</p><ul><li>对日志进行格式化等处理，对接转存到kafka集群中。</li><li>作为（消费者）从kafka集群中拉取日志消息。同步到ES集群。</li></ul><h4 id="部署日志处理层的logstash"><a href="#部署日志处理层的logstash" class="headerlink" title="部署日志处理层的logstash"></a>部署日志处理层的logstash</h4><p>这里用到了 <code>GeoLite</code>, 可用于转换IP，变成地理位置信息。</p><ul><li><a href="https://dev.maxmind.com/">GeoLite官网</a></li></ul><h5 id="从GeoLite官网下载-GeoLiteCity-dat-gz"><a href="#从GeoLite官网下载-GeoLiteCity-dat-gz" class="headerlink" title="从GeoLite官网下载 GeoLiteCity.dat.gz"></a>从GeoLite官网下载 <code>GeoLiteCity.dat.gz</code></h5><h5 id="从elastic官网下载-logstash-2-3-4-tar-gz"><a href="#从elastic官网下载-logstash-2-3-4-tar-gz" class="headerlink" title="从elastic官网下载 logstash-2.3.4.tar.gz"></a>从elastic官网下载 <code>logstash-2.3.4.tar.gz</code></h5><h5 id="解压logstash-2-3-4-tar-gz"><a href="#解压logstash-2-3-4-tar-gz" class="headerlink" title="解压logstash-2.3.4.tar.gz"></a>解压logstash-2.3.4.tar.gz</h5><pre><code>    cd /usr/local/logstash    tar -zxvf logstash-2.3.4.tar.gz</code></pre><h5 id="解压GeoLiteCity-dat-gz"><a href="#解压GeoLiteCity-dat-gz" class="headerlink" title="解压GeoLiteCity.dat.gz"></a>解压GeoLiteCity.dat.gz</h5><pre><code>    cd /usr/local/logstash    tar -zxvf GeoLiteCity.dat.gz</code></pre><h5 id="编辑获取日志并输出到kafka的配置文件"><a href="#编辑获取日志并输出到kafka的配置文件" class="headerlink" title="编辑获取日志并输出到kafka的配置文件"></a>编辑获取日志并输出到kafka的配置文件</h5><p><code>vim logstash_in_kafka.conf</code></p><pre><code>    # 用于接收Beats组件传送的日志信息    input &#123;        beats &#123;        port =&gt; 5044        codec =&gt; &quot;json&quot;    &#125;    &#125;        # 过滤日志内容，这里判断nginx日志时，增加ip转换的内容      filter &#123;        if [type] == &quot;nginxacclog&quot; &#123;             geoip &#123;            source =&gt; &quot;clientip&quot;            target =&gt; &quot;geoip&quot;            database =&gt; &quot;/usr/local/logstash/GeoLiteCity.dat&quot;            add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][longitude]&#125;&quot; ]            add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][latitude]&#125;&quot; ]    &#125;            mutate &#123;            convert =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;float&quot; ]         &#125;    &#125;    &#125;    # 输出到kafka中    output &#123;      kafka &#123;        workers =&gt; 2        bootstrap_servers =&gt; &quot;10.11.1.11:9092,10.11.1.12:9092,10.11.1.13:9092&quot;        topic_id =&gt; &quot;peiyinlog&quot;    &#125;    &#125;</code></pre><ul><li>workers：用于写入时的工作线程</li><li>bootstrap_servers：指定可用的kafka broker实例列表</li><li>topic_id：指定topic名称，可以在写入前手动在broker创建定义好分片数和副本数，也可以不提前创建，那么在logstash写入时会自动创建</li><li>topic，分片数和副本数则默认为broker配置文件中设置的。</li></ul><h5 id="启动logstash"><a href="#启动logstash" class="headerlink" title="启动logstash"></a>启动logstash</h5><pre><code>    nohup ./logstash agent -f logstash_in_kafka.conf &amp;</code></pre><h4 id="部署作为consumer的logstash"><a href="#部署作为consumer的logstash" class="headerlink" title="部署作为consumer的logstash"></a>部署作为consumer的logstash</h4><p>同样解压logstash-2.3.4.tar.gz，只是这里的配置文件不同</p><h5 id="编辑从kafka获取日志内容，传输到ES集群的配置文件"><a href="#编辑从kafka获取日志内容，传输到ES集群的配置文件" class="headerlink" title="编辑从kafka获取日志内容，传输到ES集群的配置文件"></a>编辑从kafka获取日志内容，传输到ES集群的配置文件</h5><p><code>vim kafka_to_es.conf</code></p><pre><code>    # 从kafka获取日志内容    input&#123;        kafka &#123;            zk_connect =&gt; &quot;10.11.1.11:2181,10.11.1.12:2181,10.11.1.13:2181&quot;            group_id =&gt; &quot;logstash&quot;            topic_id =&gt; &quot;peiyinlog&quot;            reset_beginning =&gt; false            consumer_threads =&gt; 50            decorate_events =&gt; true         &#125;         &#125;         # 删除一些不需要的字段      filter &#123;      if [type] == &quot;nginxacclog&quot; &#123;              mutate &#123;         remove_field =&gt; [&quot;slbip&quot;,&quot;kafka&quot;,&quot;domain&quot;,&quot;serverip&quot;,&quot;url&quot;,&quot;@version&quot;,&quot;offset&quot;,&quot;input_type&quot;,&quot;count&quot;,&quot;source&quot;,&quot;fields&quot;,&quot;beat.hostname&quot;,&quot;host&quot;,&quot;tags&quot;]        &#125;    &#125;         &#125;         # 输出日志到ES集群    output &#123;        if [type] == &quot;nginxacclog&quot; &#123;           # stdout &#123;codec =&gt; rubydebug &#125;            elasticsearch &#123;                hosts =&gt; [&quot;x.x.x.x:9200&quot;,&quot;x.x.x.x:9200&quot;]                index =&gt; &quot;logstash-nginxacclog-%&#123;+YYYY.MM.dd&#125;&quot;                manage_template =&gt; true                flush_size =&gt; 50000                idle_flush_time =&gt; 10                workers =&gt; 2    &#125;         &#125;        if [type] == &quot;messages&quot; &#123;            elasticsearch &#123;                hosts =&gt; [&quot;x.x.x.x:9200&quot;,&quot;x.x.x.x:9200&quot;]                index =&gt; &quot;logstash-messages-%&#123;+YYYY.MM.dd&#125;&quot;                manage_template =&gt; true                flush_size =&gt; 50000                idle_flush_time =&gt; 30                workers =&gt; 1    &#125;         &#125;         &#125;</code></pre><h5 id="启动logstash-1"><a href="#启动logstash-1" class="headerlink" title="启动logstash"></a>启动logstash</h5><pre><code>    nohup ./logstash agent -f kafka_to_es.conf &amp;</code></pre><h3 id="4-部署日志采集程序Filebeat"><a href="#4-部署日志采集程序Filebeat" class="headerlink" title="4.部署日志采集程序Filebeat"></a>4.部署日志采集程序Filebeat</h3><p>上述已说明使用beats组件作为日志采集程序，这里只使用了<code>filebeat</code>组件收集我们测试环境上的nginx日志centos操作系统日志，并传输到logstash中。</p><h4 id="从elastic官网下载-filebeat-1-2-3-x86-64-tar-gz"><a href="#从elastic官网下载-filebeat-1-2-3-x86-64-tar-gz" class="headerlink" title="从elastic官网下载 filebeat-1.2.3-x86_64.tar.gz"></a>从elastic官网下载 <code>filebeat-1.2.3-x86_64.tar.gz</code></h4><h4 id="解压logstash-2-3-4-tar-gz-1"><a href="#解压logstash-2-3-4-tar-gz-1" class="headerlink" title="解压logstash-2.3.4.tar.gz"></a>解压logstash-2.3.4.tar.gz</h4><pre><code>    cd /usr/local/filebeat    tar -zxvf ogstash-2.3.4.tar.gz</code></pre><h4 id="配置filebeat-yml-文件"><a href="#配置filebeat-yml-文件" class="headerlink" title="配置filebeat.yml 文件"></a>配置filebeat.yml 文件</h4><pre><code>    ################### Filebeat Configuration Example #########################         ############################# Filebeat ######################################         filebeat:      prospectors:        -          paths:            - /var/log/messages               input_type: log                     document_type: messages             -          paths:            - /var/log/nginx/access.log                     input_type: log               document_type: nginxacclog                        multiline:               pattern: &#39;^[[:space:]]&#39;              negate: true              match: after           registry_file: /var/lib/filebeat/registry                ############################# Output ##########################################           output:      logstash:         hosts: [&quot;x.x.x.x:5044&quot;,&quot;x.x.x.x:5044&quot;]                ############################# Shipper #########################################           shipper:       name: &quot;blu_test&quot;                  ############################# Logging #########################################            logging:        files:        rotateeverybytes: 10485760 # = 10MB</code></pre><h4 id="这里把nginx的access日志源改为json格式，方便后续处理"><a href="#这里把nginx的access日志源改为json格式，方便后续处理" class="headerlink" title="这里把nginx的access日志源改为json格式，方便后续处理"></a>这里把nginx的access日志源改为json格式，方便后续处理</h4><pre><code>    log_format json &#39;&#123; &quot;@timestamp&quot;:&quot;$time_local&quot;,&#39;             &#39;&quot;clientip&quot;:&quot;$remote_addr&quot;,&#39;             &#39;&quot;remote_user&quot;: &quot;$remote_user&quot;, &#39;             &#39;&quot;http_x_forwarded_for&quot;:&quot;$http_x_forwarded_for&quot;,&#39;             &#39;&quot;serverip&quot;:&quot;$server_addr&quot;,&#39;             &#39;&quot;size&quot;:$body_bytes_sent,&#39;             &#39;&quot;request_time&quot;:$request_time,&#39;             &#39;&quot;domain&quot;:&quot;$host&quot;,&#39;             &#39;&quot;request&quot;: &quot;$request&quot;, &#39;             &#39;&quot;method&quot;:&quot;$request_method&quot;,&#39;             &#39;&quot;requesturi&quot;:&quot;$request_uri&quot;,&#39;             &#39;&quot;url&quot;:&quot;$uri&quot;,&#39;             &#39;&quot;appversion&quot;:&quot;$HTTP_APP_VERSION&quot;,&#39;             &#39;&quot;referer&quot;:&quot;$http_referer&quot;,&#39;             &#39;&quot;agent&quot;:&quot;$http_user_agent&quot;,&#39;             &#39;&quot;status&quot;:&quot;$status&quot;&#125;&#39;;</code></pre><h4 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h4><pre><code>    nginx -s reload</code></pre><h4 id="启动-filebeat"><a href="#启动-filebeat" class="headerlink" title="启动 filebeat"></a>启动 filebeat</h4><pre><code>    cd /usr/local/filebeat/filebeat-1.2.3-x86_64    nohup ./filebeat start &amp;</code></pre><h3 id="5-安装配置kibana"><a href="#5-安装配置kibana" class="headerlink" title="5.安装配置kibana"></a>5.安装配置kibana</h3><h4 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h4><p>kibana最早是为了代替logstash-web 用来查看 ES 中的数据，用PHP编写的web</p><p>k2 是k1作者使用ruby重写</p><p>K3 是纯前端框架搭建，使用angularjs 编写</p><p>K4 是使用node.js编写</p><p>目前最新的版本已经是K5 </p><p>本次部署依然选用了比较成熟的k4,安装也相对比较简单</p><h5 id="从elastic官网下载-kibana-4-6-3-linux-x86-64-tar-gz"><a href="#从elastic官网下载-kibana-4-6-3-linux-x86-64-tar-gz" class="headerlink" title="从elastic官网下载 kibana-4.6.3-linux-x86_64.tar.gz"></a>从elastic官网下载 <code>kibana-4.6.3-linux-x86_64.tar.gz</code></h5><h5 id="解压kibana-4-6-3-linux-x86-64-tar-gz"><a href="#解压kibana-4-6-3-linux-x86-64-tar-gz" class="headerlink" title="解压kibana-4.6.3-linux-x86_64.tar.gz"></a>解压kibana-4.6.3-linux-x86_64.tar.gz</h5><pre><code>    cd /usr/local/kibana    tar -zxvf kibana-4.6.3-linux-x86_64.tar.gz</code></pre><h5 id="配置kibana-yml-文件"><a href="#配置kibana-yml-文件" class="headerlink" title="配置kibana.yml 文件"></a>配置kibana.yml 文件</h5><pre><code>    cd /usr/local/kibana/kibana-4.6.3-linux-x86_64/config    vim kibana.yml</code></pre><p>一堆参数，只需修改这3个，即可启动</p><pre><code>    # Kibana is served by a back end server. This controls which port to use.    server.port: 5601        # The host to bind the server to.    server.host: &quot;0.0.0.0&quot;        # The Elasticsearch instance to use for all your queries.    elasticsearch.url: &quot;http://IP:9200&quot;</code></pre><h5 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h5><pre><code>    nohup ./kibana &amp;</code></pre><h4 id="访问kibana，配置日志索引"><a href="#访问kibana，配置日志索引" class="headerlink" title="访问kibana，配置日志索引"></a>访问kibana，配置日志索引</h4><ul><li>访问地址： <code>http://IP:5601</code></li></ul><p>默认情况下，Kibana 认为你要访问的是通过 Logstash 导入 Elasticsearch 的数据。这时候你可以用默认的 logstash-* 作为你的 index pattern。通配符(*) 匹配索引名中零到多个字符。如果你的 Elasticsearch 索引有其他命名约定，输入合适的 pattern。pattern 也开始是最简单的单个索引的名字。</p><p><img src="https://ws1.sinaimg.cn/mw690/7108d6c2ly1fdlec8xlpfj210z0hbtae"></p><p>如果一个新索引是定期生成，而且索引名中带有时间戳，选择 <code>Use event times to create index names</code> 选项，然后再选择 <code>Index pattern interval</code>。这可以提高搜索性能，Kibana 会至搜索你指定的时间范围内的索引。在你用 Logstash 输出数据给 Elasticsearch 的情况下尤其有效。</p><p>点击 <code>Create</code> 添加 <code>index pattern</code>。第一个被添加的 pattern 会自动被设置为默认值。如果你有多个 index pattern 的时候，你可以在 Settings &gt; Indices 里设置具体哪个是默认值。</p><p><img src="https://ws1.sinaimg.cn/mw690/7108d6c2ly1fdleezdoyrj21070pgq78"></p><h4 id="kibana简单介绍"><a href="#kibana简单介绍" class="headerlink" title="kibana简单介绍"></a>kibana简单介绍</h4><p>简单介绍下kibana的三个模块</p><h5 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h5><p>可以从 <strong><code>Discover</code></strong> 页面以交互方式探索日志数据，可以过滤搜索结果以及查看文档数据。 还可以查看与搜索查询匹配的文档数，并获取字段值统计信息，可以配置时间字段，则日志随时间的分布将显示在页面顶部的直方图中。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlh5o8arrj218m0ekwgf"></p><h5 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h5><p><strong><code>Visualize</code></strong> 用来构建显示相关可视化的仪表板.Kibana可视化基于Elasticsearch查询。 通过使用一系列Elasticsearch聚合来提取和处理数据</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlh5z4x7ej210p0k6tb6"></p><h5 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h5><p>Kibana仪表板显示已保存的可视化对象的集合。 可以根据需要安排和调整可视化对象，并保存仪表板，以便重新加载和共享。</p><p>我在Visualize中制作了一些简单的统计，绘制了一个Dashboard</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlhexd03kj21f30qzqfa"></p><p>目前对Kibana及ES尚未深入了解，后续有一定掌握之后再做总结分享。</p><h3 id="后续优化："><a href="#后续优化：" class="headerlink" title="后续优化："></a>后续优化：</h3><ul><li>部署的的相关应用统一管理等</li><li>ES 调优</li><li>kafka集群调优</li><li>kibana扩展</li><li>kibana接入到nginx中</li><li>等等</li></ul><p>参考资料：</p><ul><li><p><a href="https://www.gitbook.com/book/chenryn/elk-stack-guide-cn/details">elk-stack-guide-cn</a></p></li><li><p><a href="https://www.elastic.co/">elastic.co</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多说评论一篇文章被评论后，其他文章都添加了相同的评论</title>
      <link href="/2017/03/10/%E6%9D%82%E8%AE%B0/%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2017/03/10/%E6%9D%82%E8%AE%B0/%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端时间开博客开通了评论功能，使用的是<code>多说评论</code>duoshuo.com，今天在查找一些资料时，发现每一篇博客都有相同的评论，<span id="more"></span><br>自己当时没有测试该功能，居然有出现这种问题，看来还是凡事都得马虎不得，不能轻易想当然！</p></blockquote><p>简单梳理了下解决的思路，希望对遇到相同问题的朋友有所帮助</p><h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ul><li>查找原因</li></ul><p>每一篇文章都是相同的回复，测试了一下，回复一篇文章，其他文章都出现了自己的回复，<strong>认为是同一篇文章？</strong></p><p>先登录多说的管理后台，看到评论的文章名称都是乱码。</p><p>再查看自己的配置，检查哪里是否配置错，</p><p>评论模块的配置：comment.ejs</p><p>这里是copy的多说提供的通用配置</p><pre><code>    &lt;!-- 多说评论框 start --&gt;        &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;请将此处替换成文章在你的站点中的ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt;    &lt;!-- 多说评论框 end --&gt;    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;     。。。    &lt;!-- 多说公共JS代码 end --&gt;</code></pre><p>这里可以看出<code>data-thread-key</code> 是个关键字段，是用来区分文章的唯一ID，这里居然居然没改，问题肯定在这里，马上检查生成的html，果然<code>&lt;section id=&quot;comments&quot; class=&quot;comment&quot;&gt;</code>模块部分生成的代码data-thread-key&#x3D;内容都是乱码了，打开几篇文章查看，果然都是相同的乱码。因为comment.ejs默认的编码不是UTF-8。所以嵌入到文章里只有这部分是乱码</p><ul><li>问题解决</li></ul><p> 把comment.ejs中的中文注释全部删除，COPY 最新的 多说通用代码，修改data-thread-key， data-title，data-url的配置</p><pre><code>    &lt;section id=&quot;comments&quot; class=&quot;comment&quot;&gt;        &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%- page.path %&gt;&quot; data-title=&quot;&lt;%- page.title %&gt;&quot; data-url=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;/div&gt;      &lt;script type=&quot;text/javascript&quot;&gt;       var duoshuoQuery = &#123;short_name:&quot;zijide&quot;&#125;;        (function() &#123;            var ds = document.createElement(&#39;script&#39;);            ds.type = &#39;text/javascript&#39;;ds.async = true;            ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;            ds.charset = &#39;UTF-8&#39;;            (document.getElementsByTagName(&#39;head&#39;)[0]              || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);        &#125;)();        &lt;/script&gt;    &lt;/section&gt;</code></pre><p>再次发布，测试评论模块及回评，OK了。</p><ul><li><a href="https://dev.duoshuo.com/docs/5003ecd94cab3e7250000008">评论框调用代码参数说明</a></li></ul><blockquote><p>凡事须再细心，认真</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 15 Tomcat JRebel 6.4 实现热部署</title>
      <link href="/2017/03/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20IDEA%2015%20Tomcat%20JRebel%206.4%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/03/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20IDEA%2015%20Tomcat%20JRebel%206.4%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="idea-是个好东东"><a href="#idea-是个好东东" class="headerlink" title="idea 是个好东东"></a><strong>idea 是个好东东</strong></h3><blockquote><p>使用Intellij IDEA 一个月了，期间了解及感受到了其许多美妙之处，使用过程中遇到许多问题，既然博客已经搭建起来了，后面多记录，<span id="more"></span>多总结吧~</p></blockquote><h3 id="关于热部署"><a href="#关于热部署" class="headerlink" title="关于热部署"></a><strong>关于热部署</strong></h3><blockquote><p>刚开始玩idea，项目从eclipse导过来的，使用的maven构建，tomcat作为容器，每次修改类，文件等都需要使用maven重新编译，打包，重启tomcat，刚开始使用idea，不太熟络，而且编译打包速度也挺快，就当是熟悉过程，这样编译，重启，编译重启一段时间后，果然还是觉得影响效率，于是尝开始思考，尝试如何热部署环境。</p></blockquote><h3 id="关于JRebel"><a href="#关于JRebel" class="headerlink" title="关于JRebel"></a><strong>关于JRebel</strong></h3><blockquote><p>Jrebel 可快速实现热部署，节省了大量重启时间，提高了个人开发效率,JRebel是收费软件 ! 好东西果然收费</p></blockquote><blockquote><p>JRebel是一款JAVA虚拟机插件，它使得JAVA程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。JRebel使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个<br>变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程，每年可以省去部署用的时间花费高达5.25个星期。<br>-百度百科</p></blockquote><p> <strong>下载JRebel for Intellij插件</strong><br><img src="http://i.imgur.com/7RwOoRE.png"></p><h4 id="破解JRebel"><a href="#破解JRebel" class="headerlink" title="破解JRebel"></a><strong>破解JRebel</strong></h4><blockquote><p>好东西都收费，我只是本地使用，非商业用途，就不打算破费了，请大家支持正版，呼呼，我下载的JRebel版本是6.4.8 百度到了6.4左右的破解文件，可以通用，这里大概记录下破解过程，比较简单也</p></blockquote><ul><li><a href="http://pan.baidu.com/s/1qYJ7Kfy">破解文件下载地址</a></li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><blockquote><p>时间原因，这次没有描述部署tomcat的方法，后面有空的话再补上吧，今天只记录下jrebel的破解，及配置部署的，其实也很简单，有个重点的提示就是在部署工程的war时，要选 <strong>exploded</strong> 这样在<strong>Server页</strong>的”On Update action “才可以选择 <strong>update classes and resources</strong></p></blockquote><h5 id="1-关闭idea"><a href="#1-关闭idea" class="headerlink" title="1. 关闭idea"></a>1. 关闭idea</h5><h5 id="2-破解补丁"><a href="#2-破解补丁" class="headerlink" title="2. 破解补丁"></a>2. 破解补丁</h5><pre><code>     解压缩破解补丁，替换对应idea的JRebel插件的俩个jar包及放置jrebel.lic文件    ~\用户名\.IntelliJIdea15\config\plugins\jr-ide-idea\lib\jrebel6\jrebel.jar    ~\用户名\.IntelliJIdea15\config\plugins\jr-ide-idea\lib\jrebel\jrebel.jar    ~\用户名\.jrebel\jrebel.lic</code></pre><h5 id="3-替换后好，重启idea"><a href="#3-替换后好，重启idea" class="headerlink" title="3. 替换后好，重启idea"></a>3. 替换后好，重启idea</h5><h5 id="4-选择热部署的项目"><a href="#4-选择热部署的项目" class="headerlink" title="4. 选择热部署的项目"></a>4. 选择热部署的项目</h5><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdfle6iltzj208c0edglr"></p><h5 id="5-TOMCAT-配置-这里有重点"><a href="#5-TOMCAT-配置-这里有重点" class="headerlink" title="5. TOMCAT 配置 这里有重点"></a>5. <strong>TOMCAT 配置</strong> 这里有重点</h5><p><img src="http://i.imgur.com/WgyWr8U.png"></p><p><img src="http://i.imgur.com/VSrk60c.png"></p><p><img src="http://i.imgur.com/wGFqdjS.png"></p><blockquote><p>本地试玩后，果然酸爽，后续使用过程遇到问题，或使用一段时间后，再做记录，及总结感受~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ngxtop-nginx监控</title>
      <link href="/2017/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ngxtop-nginx%E7%9B%91%E6%8E%A7/"/>
      <url>/2017/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ngxtop-nginx%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nginx的接入日志，是一份巨大的宝库，通过监控，分析日志，可以掌握系统的运载情况，甚至可以分析用户行为。</p></blockquote><p>想到日志的监控，分析，最容易想到tail，awk这样的命令，但实际操作中，刷刷流过的日志信息，似乎也不会让你有什么头绪。</p><h2 id="ngxtop-简介"><a href="#ngxtop-简介" class="headerlink" title="ngxtop 简介"></a>ngxtop 简介</h2><p>ngxtop 类似于linux的 top 命令，设计为在短时间内运行，作为服务器的故障排除和监控使用</p><p>ngxtop 使用python2编写和测试，但也可以支持python3，使用sqlite 数据库</p><h2 id="ngxtop-安装"><a href="#ngxtop-安装" class="headerlink" title="ngxtop 安装"></a>ngxtop 安装</h2><p>ngxtop使用python编写， 所以可以使用pip命令进行安装，确保机器上已经安装好了python环境和pip</p><pre><code>    sudo pip install ngxtop</code></pre><ul><li>注意：</li></ul><p>安装成功，但执行<code>ngxtop</code>时，报这种错误：</p><pre><code>ImportError: No module named _curses</code></pre><p>是因为 <code>ngxtop</code> 可执行命令未安装到 &#x2F;usr&#x2F;bin&#x2F;下，而是&#x2F;usr&#x2F;local&#x2F;bin&#x2F;，所以建议安装时，加上 sudo</p><h2 id="ngxtop-命令简介"><a href="#ngxtop-命令简介" class="headerlink" title="ngxtop 命令简介"></a>ngxtop 命令简介</h2><pre><code>用法:    ngxtop [options]    ngxtop [options] (print|top|avg|sum) &lt;var&gt; ...    ngxtop info    ngxtop [options] query &lt;query&gt; ...</code></pre><h3 id="参数选项说明"><a href="#参数选项说明" class="headerlink" title="参数选项说明"></a>参数选项说明</h3><ul><li>-l <file>或–access-log <file> 日志的路径</li><li>-f <format>或–log-format <format> 设置日志格式，默认格式combined，另外一种较常用格式为common</li><li>–no-follow 处理历史的日志</li><li>-t <seconds> 或 –interval <seconds> 刷新频率，默认2秒</li><li>-g <var>或 –group-by <var> 按变量分组，默认显示 request_path</li><li>-w <var>或 –having <expr> 筛选 [default: 1]</li><li>-o <var>或 –order-by <var> 输出的排序方式，默认: 访问数</li><li>-n <number>或 –limit <number> 显示top多条，默认前top 10条</li><li>-a <exp> …或 –a <exp> … 对输出字段做处理，可选 sum, avg, min, max</li><li>-v或 –verbose 详细输出</li><li>-d或 –debug debug模式，输出每行及记录</li><li>-h或 –help 显示帮助详细</li><li>–version 显示版本信息</li></ul><p><strong>高级选项</strong></p><ul><li>-c <file>或 –config <file> 指定nginx配置文件，自动分析日志格式</li><li>-i <filter-expression>或 –filter <filter-expression> 只处理符合规则的记录</li><li>-p <filter-expression>或 –pre-filter <filter-expression> in-filter expression to check in pre-parsing phase.<br>另外一些变量可以在分析时用到，名字含义同日志格式里的设置：remote_addr、remote_user、time_local、request、request_path、status、body_bytes_sent、http_referer、http_user_agent。</li></ul><p>使用示例：</p><ul><li><p>列出10个nginx服务器，按请求数量排序</p><pre><code>  ngxtop</code></pre></li><li><p>显示前20个最频繁的请求</p><pre><code>  ngxtop -n 20 </code></pre></li><li><p>获取nginx基本信息</p><pre><code>  ngxtop info  </code></pre></li><li><p>以自定义显示的变量，简单列出需要显示的变量。使用 “print” 命令显示自定义请求。</p><pre><code>  ngxtop print request http_user_agent remote_addr  </code></pre></li><li><p>显示请求最多的客户端IP地址</p><pre><code>  ngxtop top remote_addr  </code></pre></li><li><p>显示状态码是404的请求</p><pre><code>  ngxtop -i &#39;status == 404&#39; print request status</code></pre></li><li><p>统计访问次数最多的请求</p><pre><code>  ngxtop -l access.log --no-follow</code></pre></li><li><p>自定义排序的字段</p><pre><code>  ngxtop -l access.log --no-follow -o avg_bytes_sent</code></pre></li><li><p>自定义过滤条件</p><pre><code>  只统计成功  ngxtop -l access.log --no-follow -i &#39;status!=200&#39;</code></pre></li><li><p>输出400以上状态吗的请求以及请求来源</p><p>  ngxtop -i ‘status &gt;&#x3D; 400’ print request status http_referer</p></li><li><p>搜索客户端为 iPhone 的 log</p><pre><code>   ngxtop -l access.log --no-follow -i &#39;http_user_agent.find(&#39;iPhone&#39;)&#39;   条件里是可以嵌 python 语句的，这些语句被 eval() 动态翻译并执行。需要注意的是这些语句如果抛出异常会导致 ngxtop 异常退出。</code></pre></li><li><p>分组过滤</p><pre><code>   -g 相当于 group by,   -a 相当于 having。   ngxtop 已经默认提供了 avg_bytes_sent, 2xx, 3xx, 4xx, 5xx 这些聚合字段，一般这些字段已经足够了。   如果业务复杂了，想做出更多的查询，可以利用这两个参数自己组合条件。   访问量前十的ip地址      ngxtop --group-by remote_addr</code></pre></li><li><p>除了Nginx，ngtop 还可以处理其他的日志文件，比如还可以监控apache日志，如：</p></li></ul><p>使用普通格式从远程服务器解析apache日志</p><pre><code>ssh user@remote_server tail -f /var/log/apache2/access.log | ngxtop -f common</code></pre><p>更多内容请参见 ： </p><ul><li><a href="https://github.com/lebinh/ngxtop">ngxtop</a></li></ul><p>另外再推荐一个可以生成统计报表，输出为html，cvs等文件的分析统计 : </p><ul><li><a href="https://github.com/allinurl/goaccess/">goaccess</a></li></ul><blockquote><p>让人过于舒服的路，都是下坡路；最不费力气的行走，都是顺风走。然而，动物园里养不出千里马，水井里也生不出腾飞的巨龙。你最终变成什么样，很大程度上取决于你在人生道路上，是选择迎风奔跑，还是就坡下驴。努力这个词太平凡，但努力将使你的人生不平庸。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wrk 安装与使用</title>
      <link href="/2017/02/25/%E5%B7%A5%E5%85%B7/%20wrk%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/02/25/%E5%B7%A5%E5%85%B7/%20wrk%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>wrk 和 apache benchmark（ab）同属于性能测试工具，<!---more---> 但是比 ab 功能更加强大，还可以支持lua脚本来创建复杂的测试场景。</p></blockquote><blockquote><p>wrk 的一个很好的特性就是能用很少的线程压出很大的并发量， 原因是它使用了一些操作系统特定的高性能 I&#x2F;O 机制, 比如 select, epoll, kqueue 等。 其实它是复用了 redis 的 ae 异步事件驱动框架. 确切的说 ae 事件驱动框架并不是 redis 发明的, 而是来自于 Tcl的解释器 jim, 这个小巧高效的框架, 因为被 redis 采用而更多的被大家所熟知.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>准备条件</p></blockquote><ol><li>确保linux上已经安装了 make工具 (sudo apt-get install make)</li><li>GCC 编译环境（sudo apt-get install build-essential）</li></ol><ul><li><a href="https://github.com/wg/wrk.git">wrk Git 地址</a></li></ul><blockquote><p>安装</p></blockquote><ul><li><p>安装 luajit</p><pre><code>  sudo apt-get install build-essential libssl-dev git  git clone http://luajit.org/git/luajit-2.0.git  cd luajit  make &amp;&amp; sudo make install</code></pre></li><li><p>然后下载wrk的源码</p><pre><code>  git clone https://github.com/wg/wrk.git  cd wrk</code></pre></li><li><p>在上一步下载的 luajit 代码中，有一个 jit 文件夹，需要复制到 wrk 目录下</p></li><li><p>执行<code>make</code></p></li></ul><p>执行编译后，生成wrk文件</p><pre><code>    make    # move the executable to somewhere in your PATH    sudo cp wrk /usr/local/bin</code></pre><p><img src="http://i.imgur.com/9eJoM7q.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>执行简单的命令</p><pre><code>    ./wrk -t4 -c1000 -d10s -T30s --latency http://www.baidu.com</code></pre><p>执行结果：</p><p><img src="http://i.imgur.com/HM57lBt.png"></p><blockquote><p>简要说明下wrk的参数的含义</p></blockquote><ul><li>-t 线程数</li><li>-c 连接数</li><li>-d 测试持续时间</li><li>-T 超时时间</li><li>–latency 响应的分布时间</li></ul><blockquote><p>响应结果的参数含义:</p></blockquote><ul><li><p>Latency：响应时间</p></li><li><p>Req&#x2F;Sec：每秒请求数量，也就是并发能力</p></li><li><p>Avg：平均</p></li><li><p>Max：最大</p></li><li><p>Stdev：标准差</p></li><li><p>+&#x2F;- Stdev： 正负一个标准差占比</p></li><li><p>Latency: 响应的分布时间</p></li><li><p>注意：模拟测试的时候，一般线程数不宜过多，核数的2到4倍足够了。 多了反而因为线程切换过多造成效率降低， 因为 wrk 不是使用每个连接一个线程的模型， 而是通过异步网络 I&#x2F;O 提升并发量。 所以网络通信不会阻塞线程执行，这也是 wrk 可以用很少的线程模拟大量网路连接的原因。</p></li></ul><h2 id="支持lua脚本"><a href="#支持lua脚本" class="headerlink" title="支持lua脚本"></a>支持lua脚本</h2><blockquote><p>这块内容只是简单了解了下，还是很强大，等用到后，在做笔记吧~</p></blockquote><blockquote><ul><li>用人不在于如何减少人的短处, 而在于如何发挥人的长处。   –彼得.德鲁克 (管理学之父)</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置访问日志</title>
      <link href="/2017/02/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/"/>
      <url>/2017/02/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 对接调式排查问题时，查询日志是非常关键的，nginx作为负载&#x2F;反向代理，冲在第一线可以收集到很多访问&#x2F;接入信息。熟悉和了解nginx的日志模块，对排查，分析，统计都有帮助。</p></blockquote><h3 id="nginx的日志相关指令"><a href="#nginx的日志相关指令" class="headerlink" title="nginx的日志相关指令"></a>nginx的日志相关指令</h3><hr><h4 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h4><ul><li>用于设置日志的格式</li></ul><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><ul><li><p>log_format name string</p></li><li><p><code>name</code>:格式名称</p></li><li><p><code>string</code>:定义的格式</p></li></ul><p>举例：</p><pre><code>    log_format access  &#39;$http_x_forwarded_for $remote_addr [$time_local] &quot;$request&quot; &#39;               &#39;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$request_body&quot; &quot;$sent_http_last_modified&quot; &quot;$remote_user&quot; &#39;;</code></pre><ul><li><p>当日志文件中记录的值为”-“时，表示为空</p></li><li><p>access为自定义的日志格式的名称，使用时引用即可：</p><pre><code>access_log /var/log/nginx/access.log  access;</code></pre></li></ul><h5 id="具体设置的参数说明："><a href="#具体设置的参数说明：" class="headerlink" title="具体设置的参数说明："></a>具体设置的参数说明：</h5><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$args</td><td>#请求中的参数值</td><td></td></tr><tr><td>$query_string</td><td>#同 $args</td><td></td></tr><tr><td>$arg_NAME</td><td>#GET请求中NAME的值</td><td></td></tr><tr><td>$is_args</td><td>#如果请求中有参数，值为”?”，否则为空字符串</td><td></td></tr><tr><td>$uri</td><td>#请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”&#x2F;foo&#x2F;bar.html”。</td><td></td></tr><tr><td>$document_uri</td><td>#同 $uri</td><td></td></tr><tr><td>$document_root</td><td>#当前请求的文档根目录或别名</td><td></td></tr><tr><td>$host</td><td>#优先级：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名.请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称</td><td></td></tr><tr><td>$hostname</td><td>#主机名</td><td></td></tr><tr><td>$https</td><td>#如果开启了SSL安全模式，值为”on”，否则为空字符串。</td><td></td></tr><tr><td>$binary_remote_addr</td><td>#客户端地址的二进制形式，固定长度为4个字节</td><td></td></tr><tr><td>$body_bytes_sent</td><td>#传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的”%B”参数保持兼容</td><td></td></tr><tr><td>$bytes_sent</td><td>#传输给客户端的字节数</td><td></td></tr><tr><td>$connection</td><td>#TCP连接的序列号</td><td></td></tr><tr><td>$connection_requests</td><td>#TCP连接当前的请求数量</td><td></td></tr><tr><td>$content_length</td><td>#”Content-Length” 请求头字段</td><td></td></tr><tr><td>$content_type</td><td>#”Content-Type” 请求头字段</td><td></td></tr><tr><td>$cookie_name</td><td>#cookie名称</td><td></td></tr><tr><td>$limit_rate</td><td>#用于设置响应的速度限制</td><td></td></tr><tr><td>$msec</td><td>#当前的Unix时间戳</td><td></td></tr><tr><td>$nginx_version</td><td>#nginx版本</td><td></td></tr><tr><td>$pid</td><td>#工作进程的PID</td><td></td></tr><tr><td>$pipe</td><td>#如果请求来自管道通信，值为”p”，否则为”.”</td><td></td></tr><tr><td>$proxy_protocol_addr</td><td>#获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串</td><td></td></tr><tr><td>$realpath_root</td><td>#当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径</td><td></td></tr><tr><td>$remote_addr</td><td>#客户端地址</td><td></td></tr><tr><td>$remote_port</td><td>#客户端端口</td><td></td></tr><tr><td>$remote_user</td><td>#用于HTTP基础认证服务的用户名</td><td></td></tr><tr><td>$request</td><td>#代表客户端的请求地址</td><td></td></tr><tr><td>$request_body</td><td>#客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器</td><td></td></tr><tr><td>$request_body_file</td><td>#将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传 递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off</td><td></td></tr><tr><td>$request_completion</td><td>#如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空</td><td></td></tr><tr><td>$request_filename</td><td>#当前连接请求的文件路径，由root或alias指令与URI请求生成</td><td></td></tr><tr><td>$request_length</td><td>#请求的长度 (包括请求的地址，http请求头和请求主体)</td><td></td></tr><tr><td>$request_method</td><td>#HTTP请求方法，通常为”GET”或”POST”</td><td></td></tr><tr><td>$request_time</td><td>#处理客户端请求使用的时间,单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</td><td></td></tr><tr><td>$request_uri</td><td>#这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”&#x2F;cnphp&#x2F;test.php?arg&#x3D;freemouse”</td><td></td></tr><tr><td>$scheme</td><td>#请求使用的Web协议，”http” 或 “https”</td><td></td></tr><tr><td>$server_addr</td><td>#服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中</td><td></td></tr><tr><td>$server_name</td><td>#服务器名</td><td></td></tr><tr><td>$server_port</td><td>#服务器端口</td><td></td></tr><tr><td>$server_protocol</td><td>#服务器的HTTP版本，通常为 “HTTP&#x2F;1.0” 或 “HTTP&#x2F;1.1”</td><td></td></tr><tr><td>$status</td><td>#HTTP响应代码</td><td></td></tr><tr><td>$time_iso8601</td><td>#服务器时间的ISO 8610格式</td><td></td></tr><tr><td>$time_local</td><td>#服务器时间（LOG Format 格式）</td><td></td></tr><tr><td>$cookie_NAME</td><td>#客户端请求Header头中的cookie变量，前缀”$cookie_”加上cookie名称的变量，该变量的值即为cookie名称的值</td><td></td></tr><tr><td>$http_NAME</td><td>#匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：”Accept-Language”，$http_accept_language即可</td><td></td></tr><tr><td>$http_cookie</td><td></td><td></td></tr><tr><td>$http_host</td><td>#请求地址，即浏览器中你输入的地址（IP或域名）</td><td></td></tr><tr><td>$http_referer</td><td>#url跳转来源,用来记录从那个页面链接访问过来的</td><td></td></tr><tr><td>$http_user_agent</td><td>#用户终端浏览器等信息</td><td></td></tr><tr><td>$http_x_forwarded_for</td><td></td><td></td></tr><tr><td>$sent_http_NAME</td><td>#可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可</td><td></td></tr><tr><td>$sent_http_cache_control</td><td></td><td></td></tr><tr><td>$sent_http_connection</td><td></td><td></td></tr><tr><td>$sent_http_content_type</td><td></td><td></td></tr><tr><td>$sent_http_keep_alive</td><td></td><td></td></tr><tr><td>$sent_http_last_modified</td><td></td><td></td></tr><tr><td>$sent_http_location</td><td></td><td></td></tr><tr><td>$sent_http_transfer_encoding</td><td></td><td></td></tr></tbody></table><ul><li><p>常用的配置：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>211.28.65.253</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>—</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET &#x2F;article-10000.html HTTP&#x2F;1.1”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.it300.com/">www.it300.com</a> 192.168.100.100</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>1547</td></tr><tr><td>$http_referer</td><td>url跳转来源</td><td><a href="https://www.baidu.com/">https://www.baidu.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户终端浏览器等信息</td><td>Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本TLSv1</td><td></td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.10.10.100:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.002</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr><tr><td>$request_body</td><td>post请求的参数</td><td>—</td></tr></tbody></table></li></ul><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ul><li>如何设置nginx中remote_addr和x_forwarded_for参数</li></ul><p><code>remote_addr</code> : remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP</p><p><code>x_forwarded_for</code>:通常web服务器放在反向代理的后面，当使用了代理时，web服务器就不知道你的真实IP了，为了避免这个情况，代理服务器通常会增加一个<code>x_forwarded_for</code>的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP.</p><ul><li><p>在server中设置x_forwarded_for</p><pre><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre></li></ul><h4 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h4><ul><li>用来指定日志文件的存放路径、格式</li></ul><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><ul><li>access_log path [format [buffer&#x3D;size [flush&#x3D;time]]];</li><li>access_log path format gzip[&#x3D;level] [buffer&#x3D;size] [flush&#x3D;time];</li><li>access_log syslog:server&#x3D;address[,parameter&#x3D;value] [format];</li><li>access_log off;</li></ul><p>默认值: access_log logs&#x2F;access.log combined;</p><p>配置段: http, server, location, if in location, limit_except</p><p>gzip压缩等级。</p><p>buffer设置内存缓存区大小。</p><p>flush保存在缓存区中的最长时间。</p><p>不记录日志：access_log off;</p><p>使用默认combined格式记录日志：access_log logs&#x2F;access.log 或 access_log logs&#x2F;access.log combined;</p><h4 id="open-log-file-cache"><a href="#open-log-file-cache" class="headerlink" title="open_log_file_cache"></a>open_log_file_cache</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h5><ul><li>open_log_file_cache max&#x3D;N [inactive&#x3D;time] [min_uses&#x3D;N] [valid&#x3D;time];</li><li>open_log_file_cache off;</li></ul><p>默认值: open_log_file_cache off;</p><p>配置段: http, server, location</p><p>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)，格式如下：</p><p>参数注释如下：</p><ul><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>off：禁用缓存</li></ul><p>实例：</p><pre><code>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</code></pre><h4 id="log-not-found"><a href="#log-not-found" class="headerlink" title="log_not_found"></a>log_not_found</h4><ul><li>是否在error_log中记录不存在的错误。默认是。</li></ul><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h5><ul><li>log_not_found on | off;</li></ul><p>默认值: log_not_found on;</p><p>配置段: http, server, location</p><h4 id="log-subrequest"><a href="#log-subrequest" class="headerlink" title="log_subrequest"></a>log_subrequest</h4><ul><li>是否在access_log中记录子请求的访问日志。默认不记录。</li></ul><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法:"></a>语法:</h5><ul><li>log_subrequest on | off;<br>默认值: log_subrequest off;<br>配置段: http, server, location</li></ul><h4 id="rewrite-log"><a href="#rewrite-log" class="headerlink" title="rewrite_log"></a>rewrite_log</h4><ul><li>启用时将在error log中记录notice级别的重写日志。</li></ul><p>由ngx_http_rewrite_module模块提供的。用来记录重写日志的。对于调试重写规则建议开启。 Nginx重写规则指南</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法:"></a>语法:</h5><p>rewrite_log on | off;</p><p>默认值: rewrite_log off;</p><p>配置段: http, server, location, if</p><h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h4><ul><li>配置错误日志。</li></ul><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法:"></a>语法:</h5><ul><li>error_log file | stderr | syslog:server&#x3D;address[,parameter&#x3D;value] [debug | info | notice | warn | error | crit | alert | emerg];</li></ul><p>默认值: error_log logs&#x2F;error.log error;</p><p>配置段: main, http, server, location</p><h3 id="日志统计分析"><a href="#日志统计分析" class="headerlink" title="日志统计分析"></a>日志统计分析</h3><p>＞　看到某大师分享的关于手动分析的日志的方式，方法不错，简单记录下</p><p><strong>Nginx 日志能够记录的变量还有很多没出现在默认配置中：</strong></p><p>比如：</p><p>请求数据大小：$request_length</p><p>返回数据大小：$bytes_sent</p><p>请求耗时：$request_time</p><p>所用连接序号：$connection</p><p>当前连接发生请求数：$connection_requests</p><p>Nginx 的默认格式不可计算统计，需要想办法转换成可统计计算的格式，比如用控制字符 ^A (Mac 下 ctrl+v ctrl+a 打出)分割每个字段。</p><p>log_format 的格式可以变成这样：</p><pre><code>    log_format new &#39;$remote_addr^A$http_x_forwarded_for^A$host^A$time_local^A$status^A&#39;    &#39;$request_time^A$request_length^A$bytes_sent^A$http_referer^A$request^A$http_user_agent&#39;;</code></pre><p>这样之后就通过常见的 Linux 命令行工具进行分析了：</p><ul><li><p>查找访问频率最高的 URL 和次数：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;print $10&#125;’ | sort | uniq -c</code></pre></li><li><p>查找当前日志文件 500 错误的访问：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5 == 500) print $0&#125;’</code></pre></li><li><p>查找当前日志文件 500 错误的数量：<br>cat access.log | awk -F ‘^A’ ‘{if($5 &#x3D;&#x3D; 500) print $0}’ | wc -l</p></li><li><p>查找某一分钟内 500 错误访问的数量:</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5 == 500) print $0&#125;’ | grep ’09:00’ | wc-l</code></pre></li><li><p>查找耗时超过 1s 的慢请求：</p><pre><code>tail -f access.log | awk -F ‘^A’ ‘&#123;if($6&gt;1) print $0&#125;’</code></pre></li><li><p>假如只想查看某些位：</p><pre><code>tail -f access.log | awk -F ‘^A’ ‘&#123;if($6&gt;1) print $3″|”$4&#125;’</code></pre></li><li><p>查找 502 错误最多的 URL：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5==502) print $11&#125;’ | sort | uniq -c</code></pre></li><li><p>查找 200 空白页</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5==200 &amp;&amp; $8 &lt; 100) print $3″|”$4″|”$11″|”$6&#125;’</code></pre></li><li><p>查看实时日志数据流</p><pre><code>tail -f access.log | cat -e</code></pre></li><li><p>或者</p><pre><code>tail -f access.log | tr ‘^A’ ‘|’</code></pre></li></ul><p>按这个思路可以做很多其他分析，比如 UA 最多的访问；访问频率最高的 IP；请求耗时分析；请求返回包大小分析；等等。</p><h3 id="切割日志"><a href="#切割日志" class="headerlink" title="切割日志"></a>切割日志</h3><p>Nginx 的日志都是写在一个文件当中的，不会自动地进行切割，如果访问量很大的话，将导致日志文件容量非常大，不便于管理和造成Nginx 日志写入效率低下等问题。所以，往往需要要对access_log、error_log日志进行切割。</p><p>切割日志一般利用USR1信号让nginx产生新的日志。</p><ul><li>实例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">logdir=&quot;/data/logs/nginx&quot;</span><br><span class="line">pid=`cat $logdir/nginx.pid`</span><br><span class="line">DATE=`date -d &quot;1 hours ago&quot; +%Y%m%d%H`</span><br><span class="line">DATE_OLD=`date -d &quot;7 days ago&quot; +%Y%m%d`</span><br><span class="line">for i in `ls $logdir/*access.log`; do</span><br><span class="line">        mv $i $i.$DATE</span><br><span class="line">done</span><br><span class="line">for i in `ls $logdir/*error.log`; do</span><br><span class="line">        mv $i $i.$DATE</span><br><span class="line">done</span><br><span class="line">kill -s USR1 $pid</span><br><span class="line">rm -v $logdir&quot;/access.log.&quot;$DATE_OLD*</span><br><span class="line"></span><br><span class="line">rm -v $logdir&quot;/error.log.&quot;$DATE_OLD*</span><br></pre></td></tr></table></figure><p>1、分析：</p><p>将上面的脚本放到crontab中，每小时执行一次（0 ），这样每小时会把当前日志重命名成一个新文件；然后发送USR1这个信号让Nginx 重新生成一个新的日志。（相当于备份日志）<br>将前7天的日志删除；</p><p>2、说明：</p><p>在没有执行kill -USR1 $pid之前，即便已经对文件执行了mv命令而改变了文件名称，nginx还是会向新命名的文件”*access.log.2016032623”照常写入日志数据的。原因在于：linux系统中，内核是根据文件描述符来找文件的。</p><p>3、logrotates：</p><p>使用系统自带的logrotates，也可以实现nginx的日志分割，查看其bash源码，发现也是发送USR1这个信号。</p><p>nginx的日志相关总结先到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用图床及自建图床方法汇总</title>
      <link href="/2017/02/20/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%BA%8A%E5%8F%8A%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2017/02/20/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%BA%8A%E5%8F%8A%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客里的图片一直使用的是MarkdownPad 2提供图库，但是博客支持https后，之前图片都是引用的http，域名就失去小绿锁。</p></blockquote><p>是时候寻找新的图床啦。</p><p>于是乎，在网上这到这个哥们的博文，收藏之</p><ul><li>支持https了</li></ul><p><a href="https://eason-yang.com/2016/10/09/collection-of-image-hosting/">常用图床及自建图床方法汇总(转载)</a></p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fcx6wfeyjuj20i406ugmo"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven 执行错误 Failed to clean project Failed to delete</title>
      <link href="/2017/02/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20maven%20%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%20Failed%20to%20clean%20project%20Failed%20to%20delete/"/>
      <url>/2017/02/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20maven%20%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%20Failed%20to%20clean%20project%20Failed%20to%20delete/</url>
      
        <content type="html"><![CDATA[<h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><blockquote><p>idea启动通过maven，启动tomcat时，执行clean命令也报错</p></blockquote><ul><li><p>报错信息：</p><pre><code>  Failed to clean project Failed to delete ... tomcat / log</code></pre></li></ul><blockquote><p>无法删除，想到tomcat可能没有关闭。想到昨天idea被我强杀的进程。tomcat没杀掉，查看进程，果然tomcat进程还在，杀掉进程后，重新执行<br>maven 命令，正常了~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级win10后，无法使用 MarkdownPad2的问题</title>
      <link href="/2017/02/08/%E5%B7%A5%E5%85%B7/%E5%8D%87%E7%BA%A7win10%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20MarkdownPad2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/02/08/%E5%B7%A5%E5%85%B7/%E5%8D%87%E7%BA%A7win10%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20MarkdownPad2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>最新的win10系统，自带了ubuntu子系统，诱惑很大，于是把win7换成了win10，<span id="more"></span><br>But 升级win10后，部分软件不兼容，安装好经常使用MarkdownPad2后，直接打开一个.md文件，就开始报错</p></blockquote><p><img src="http://i.imgur.com/6ADsHjh.png"></p><p>对文档进行编辑时，同样报错</p><p><img src="http://i.imgur.com/WGG07vD.png"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>不甘心好用的工具无法使用， 百度之，并顺利解决，这里做个记录：</p><p>下载该程序 <a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe"><code>awesomium_v1.6.6_sdk_win.exe</code></a>，安装后，即可正常使用</p><ul><li>注意： 低版本的win10，可能无法安装awesomium_v1.6.6_sdk_win，win10还是升级吧。希望win10能逐步稳定下来</li></ul><blockquote><p>我们活在各自的的心灵世界，我们有什么样的心，就决定我们看到什么样的世界</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo执行失败的2个问题解决方法</title>
      <link href="/2017/02/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20sudo%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%842%E4%B8%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2017/02/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20sudo%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%842%E4%B8%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题一：sudo-unable-to-resolve-host-dev"><a href="#问题一：sudo-unable-to-resolve-host-dev" class="headerlink" title="问题一：sudo: unable to resolve host dev"></a>问题一：sudo: unable to resolve host dev</h2><ul><li><p>处理方式：</p><pre><code>  编辑 /etc/hosts  127.0.0.1       localhost 设备的hostname  # 或改成下面这两行   #127.0.0.1       localhost   #127.0.0.1       设备的hostname</code></pre></li></ul><h2 id="问题二：-sudo-no-tty-present-and-no-askpass-program-specified"><a href="#问题二：-sudo-no-tty-present-and-no-askpass-program-specified" class="headerlink" title="问题二： sudo: no tty present and no askpass program specified"></a>问题二： sudo: no tty present and no askpass program specified</h2><ul><li><p>处理方式：</p><pre><code>  这是由于帐号并没有开启免密码导致的  切换到root用户  1.vi /etc/sudoers  2.添加 用户名 ALL = NOPASSWD: ALL</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装 centOS 报错 No Caching mode page found</title>
      <link href="/2017/01/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AE%89%E8%A3%85%20centOS%20%E6%8A%A5%E9%94%99%20No%20Caching%20mode%20page%20found/"/>
      <url>/2017/01/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AE%89%E8%A3%85%20centOS%20%E6%8A%A5%E9%94%99%20No%20Caching%20mode%20page%20found/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>在阿里的<a href="http://mirrors.aliyun.com/centos/">镜像库</a>上下载了centos7.2的iso文件，制作好U盘引导盘，在PC上安装时，<!---more---> 报错</p></blockquote><pre><code>    No Caching mode page found Assuming drive cache:write through    省略一大堆。。。    /dev/root does not exist</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>重启后，在进入安装界面时，按 <code>e</code> 键</p><pre><code>  修改  vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</code></pre></li><li><p>将hd:后面的内容替换为挂在的U盘路径即可</p><pre><code>  如：  vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb1:/ quiet</code></pre></li><li><p>注意： sdb1 即为U盘的挂在名称。硬盘一般是sda</p></li><li><p>可以通过 <code>ls /dev/sd*</code> 查看</p></li></ul><p>修改好后，按下 <code>CTRL + X </code> 就OK了</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatais 总结</title>
      <link href="/2017/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatais%20%E6%80%BB%E7%BB%93/"/>
      <url>/2017/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatais%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>Mapper 配置：</strong> Mapper 配置可以使用基于 XML 的 Mapper 配置文件来实现，也可以使用基于 Java 注解的 MyBatis 注解来实现，甚至可以直接使用 MyBatis 提供的 API 来实现。</p><p><strong>Mapper 接口：</strong> Mapper 接口是指自行定义的一个数据操做接口，类似于通常所说的 DAO 接口。早期的 Mapper 接口需要自定义去实现，现在 MyBatis 会自动为 Mapper 接口创建动态代理对象。Mapper 接口的方法通常与 Mapper 配置文件中的 select、insert、update、delete 等 XML 结点存在一一对应关系。</p><p><strong>Executor：</strong> MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 进行的，Executor 是 MyBatis 的一个核心接口。</p><p><strong>SqlSession：</strong> SqlSession 是 MyBatis 的关键对象，是执行持久化操作的独享，类似于 JDBC 中的 Connection，SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法，它的底层封装了 JDBC 连接，可以用 SqlSession 实例来直接执行被映射的 SQL 语句。</p><p><strong>SqlSessionFactory：</strong> SqlSessionFactory 是 MyBatis 的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory 对象的实例可以通过 SqlSessionFactoryBuilder 对象类获得，而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出。</p><p>MyBatis 的工作流程如下：</p><p><img src="http://www.ityouknow.com/assets/images/2017/chat/mybat.png" alt="img"></p><ul><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话。根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession）。会话对象是一个接口，该接口中包含了对数据库操作的增删改查方法。</li><li>创建执行器。因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象。在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库。拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ul><p>在具体的使用过程中，按照上述的流程来执行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>collections 数据复制</title>
      <link href="/2017/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/collections%20%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/collections%20%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="collections-数据复制"><a href="#collections-数据复制" class="headerlink" title="collections 数据复制"></a>collections 数据复制</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><blockquote><p>起名真心好难，做了一个collection 用了一段时间后，想换个名字。。。之前测试的数据。想导入过去，搜罗了下，执行成功后，做个笔记</p></blockquote><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul><li><p>命令行执行</p><pre><code>  db.material.find().forEach(function(x)&#123;  db.unityassets.insert(x);  &#125;)</code></pre></li></ul><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ul><li>Mongo Express 中直接改名</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对一致性Hash算法，java实现的研究</title>
      <link href="/2016/12/17/java/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%EF%BC%8Cjava%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2016/12/17/java/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%EF%BC%8Cjava%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="http://www.cnblogs.com/xrq730/p/5186728.html">http://www.cnblogs.com/xrq730/p/5186728.html</a></p></blockquote><p><strong>一致性Hash算法</strong></p><p>关于一致性Hash算法，在我之前的博文中已经有多次提到了，<a href="http://www.cnblogs.com/xrq730/p/4948707.html">MemCache超详细解读</a>一文中”一致性Hash算法”部分，对于为什么要使用一致性Hash算法、一致性Hash算法的算法原理做了详细的解读。</p><p>算法的具体原理这里再次贴上：</p><p><strong>先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</strong></p><p>这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。</p><p>当然，万事不可能十全十美，一致性Hash算法比普通的余数Hash算法更具有伸缩性，但是同时其算法实现也更为复杂，本文就来研究一下，如何利用Java代码实现一致性Hash算法。在开始之前，先对一致性Hash算法中的几个核心问题进行一些探究。</p><p><strong>数据结构的选取</strong></p><p>一致性Hash算法最先要考虑的一个问题是：构造出一个长度为232的整数环，根据节点名称的Hash值将服务器节点放置在这个Hash环上。</p><p>那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：</p><p><strong>O(1) &lt; O(log2N) &lt; O(N) &lt; O(N * log2N) &lt; O(N2) &lt; O(N3)  &lt; O(N!)</strong></p><p>一般来说，前四个效率比较高，中间两个差强人意，最后一个后比较差（只要N比较大，这个算法就动不了了）。OK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。</p><p><strong>1、解决方案一：排序+List</strong></p><p>我想到的第一种思路是：算出所有待加入数据结构的节点名称的Hash值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，最后将排序后的数据放入List中，采用List而不是数组是为了结点的扩展考虑。</p><p><strong>之后，待路由的结点，只需要在List中找到第一个Hash值比它大的服务器节点就可以了</strong>，比如服务器节点的Hash值是[0,2,4,6,8,10]，带路由的结点是7，只需要找到第一个比7大的整数，也就是8，就是我们最终需要路由过去的服务器节点。</p><p>如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：</p><p>（1）最好的情况是第一次就找到，时间复杂度为O(1)</p><p>（2）最坏的情况是最后一次才找到，时间复杂度为O(N)</p><p>平均下来时间复杂度为O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为O(N)。</p><p>但是如果考虑到之前的排序，我在网上找了张图，提供了各种排序算法的时间复杂度：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212222344573-933837136.jpg" alt="img"></p><p>看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，看起来最好的归并排序法的时间复杂度仍然有O(N * logN)，稍微耗费性能了一些。</p><p><strong>2、解决方案二：遍历+List</strong></p><p>既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。</p><p>解决方案使用List不变，不过可以采用遍历的方式：</p><p>（1）服务器节点不排序，其Hash值全部直接放入一个List中</p><p>（2）带路由的节点，算出其Hash值，由于指明了”顺时针”，因此遍历List，比待路由的节点Hash值大的算出差值并记录，比待路由节点Hash值小的忽略</p><p>（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点</p><p>在这个算法中，看一下时间复杂度：</p><p>1、最好情况是只有一个服务器节点的Hash值大于带路由结点的Hash值，其时间复杂度是O(N)+O(1)&#x3D;O(N+1)，忽略常数项，即O(N)</p><p>2、最坏情况是所有服务器节点的Hash值都大于带路由结点的Hash值，其时间复杂度是O(N)+O(N)&#x3D;O(2N)，忽略首项系数，即O(N)</p><p>所以，总的时间复杂度就是O(N)。其实算法还能更改进一些：给一个位置变量X，如果新的差值比原差值小，X替换为新的位置，否则X不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为O(N)。</p><p>总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。</p><p><strong>3、解决方案三：二叉查找树</strong></p><p>抛开List这种数据结构，另一种数据结构则是使用<strong>二叉查找树</strong>。对于树不是很清楚的朋友可以简单看一下这篇文章<a href="http://www.cnblogs.com/xrq730/p/5187032.html">树形结构</a>。</p><p>当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有AVL树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：</p><p>1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高</p><p>2、JDK里面提供了红黑树的代码实现TreeMap和TreeSet</p><p>另外，以TreeMap为例，TreeMap本身提供了一个tailMap(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构。</p><p>使用红黑树，可以使得查找的时间复杂度降低为O(logN)，比上面两种解决方案，效率大大提升。</p><p>为了验证这个说法，我做了一次测试，从大量数据中查找第一个大于其中间值的那个数据，比如10000数据就找第一个大于5000的数据（模拟平均的情况）。看一下O(N)时间复杂度和O(logN)时间复杂度运行效率的对比：</p><table><thead><tr><th></th><th><strong>50000</strong></th><th><strong>100000</strong></th><th><strong>500000</strong></th><th><strong>1000000</strong></th><th><strong>4000000</strong></th></tr></thead><tbody><tr><td><strong>ArrayList</strong></td><td><strong>1ms</strong></td><td><strong>1ms</strong></td><td><strong>4ms</strong></td><td><strong>4ms</strong></td><td><strong>5ms</strong></td></tr><tr><td><strong>LinkedList</strong></td><td><strong>4ms</strong></td><td><strong>7ms</strong></td><td><strong>11ms</strong></td><td><strong>13ms</strong></td><td><strong>17ms</strong></td></tr><tr><td><strong>TreeMap</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td></tr></tbody></table><p>因为再大就内存溢出了，所以只测试到4000000数据。可以看到，数据查找的效率，TreeMap是完胜的，其实再增大数据测试也是一样的，红黑树的数据结构决定了任何一个大于N的最小数据，它都只需要几次至几十次查找就可以查到。</p><p>当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，<strong>为了维护红黑树，数据插入效率TreeMap在三种数据结构里面是最差的，且插入要慢上5~10倍</strong>。</p><p><strong>Hash值重新计算</strong></p><p>服务器节点我们肯定用字符串来表示，比如”192.168.1.1”、”192.168.1.2”，根据字符串得到其Hash值，那么另外一个重要的问题就是Hash值要重新计算，这个问题是我在测试String的hashCode()方法的时候发现的，不妨来看一下为什么要重新计算Hash值：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * String的hashCode()方法运算结果查看</span><br><span class="line"> * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StringHashCodeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;192.168.0.0:111的哈希值：&quot; + &quot;192.168.0.0:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.1:111的哈希值：&quot; + &quot;192.168.0.1:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.2:111的哈希值：&quot; + &quot;192.168.0.2:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.3:111的哈希值：&quot; + &quot;192.168.0.3:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.4:111的哈希值：&quot; + &quot;192.168.0.4:1111&quot;.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>我们在做集群的时候，集群点的IP以这种连续的形式存在是很正常的。看一下运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.0:111的哈希值：1845870087</span><br><span class="line">192.168.0.1:111的哈希值：1874499238</span><br><span class="line">192.168.0.2:111的哈希值：1903128389</span><br><span class="line">192.168.0.3:111的哈希值：1931757540</span><br><span class="line">192.168.0.4:111的哈希值：1960386691</span><br></pre></td></tr></table></figure><p>这个就问题大了，[0,232-1]的区间之中，5个HashCode值却只分布在这么小小的一个区间，什么概念？[0,232-1]中有4294967296个数字，而我们的区间只有114516604，从概率学上讲这将导致97%待路由的服务器都被路由到”192.168.0.0”这个集群点上，简直是糟糕透了！</p><p>另外还有一个不好的地方：规定的区间是非负数，String的hashCode()方法却会产生负数（不信用”192.168.1.0:1111”试试看就知道了）。不过这个问题好解决，取绝对值就是一种解决的办法。</p><p>综上，String重写的hashCode()方法在一致性Hash算法中没有任何实用价值，得找个算法重新计算HashCode。这种重新计算Hash值的算法有很多，比如CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等，其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法，用别的Hash算法也可以，比如FNV1_32_HASH算法的计算效率就会高一些。</p><p><strong>一致性Hash算法实现版本1：不带虚拟节点</strong></p><p>使用一致性Hash算法，尽管增强了系统的伸缩性，但是也有可能导致负载分布不均匀，解决办法就是使用<strong>虚拟节点代替真实节点</strong>，第一个代码版本，先来个简单的，不带虚拟节点。</p><p>下面来看一下不带虚拟节点的一致性Hash算法的Java代码实现：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 不带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  *</span><br><span class="line"> 5  */</span><br><span class="line"> 6 public class ConsistentHashingWithoutVirtualNode</span><br><span class="line"> 7 &#123;</span><br><span class="line"> 8     /**</span><br><span class="line"> 9      * 待添加入Hash环的服务器列表</span><br><span class="line">10      */</span><br><span class="line">11     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">12             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">13     </span><br><span class="line">14     /**</span><br><span class="line">15      * key表示服务器的hash值，value表示服务器的名称</span><br><span class="line">16      */</span><br><span class="line">17     private static SortedMap&lt;Integer, String&gt; sortedMap = </span><br><span class="line">18             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">19     </span><br><span class="line">20     /**</span><br><span class="line">21      * 程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">22      */</span><br><span class="line">23     static</span><br><span class="line">24     &#123;</span><br><span class="line">25         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">26         &#123;</span><br><span class="line">27             int hash = getHash(servers[i]);</span><br><span class="line">28             System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">29             sortedMap.put(hash, servers[i]);</span><br><span class="line">30         &#125;</span><br><span class="line">31         System.out.println();</span><br><span class="line">32     &#125;</span><br><span class="line">33     </span><br><span class="line">34     /**</span><br><span class="line">35      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">36      */</span><br><span class="line">37     private static int getHash(String str)</span><br><span class="line">38     &#123;</span><br><span class="line">39         final int p = 16777619;</span><br><span class="line">40         int hash = (int)2166136261L;</span><br><span class="line">41         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">42             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">43         hash += hash &lt;&lt; 13;</span><br><span class="line">44         hash ^= hash &gt;&gt; 7;</span><br><span class="line">45         hash += hash &lt;&lt; 3;</span><br><span class="line">46         hash ^= hash &gt;&gt; 17;</span><br><span class="line">47         hash += hash &lt;&lt; 5;</span><br><span class="line">48         </span><br><span class="line">49         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">50         if (hash &lt; 0)</span><br><span class="line">51             hash = Math.abs(hash);</span><br><span class="line">52         return hash;</span><br><span class="line">53     &#125;</span><br><span class="line">54     </span><br><span class="line">55     /**</span><br><span class="line">56      * 得到应当路由到的结点</span><br><span class="line">57      */</span><br><span class="line">58     private static String getServer(String node)</span><br><span class="line">59     &#123;</span><br><span class="line">60         // 得到带路由的结点的Hash值</span><br><span class="line">61         int hash = getHash(node);</span><br><span class="line">62         // 得到大于该Hash值的所有Map</span><br><span class="line">63         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">64                 sortedMap.tailMap(hash);</span><br><span class="line">65         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">66         Integer i = subMap.firstKey();</span><br><span class="line">67         // 返回对应的服务器名称</span><br><span class="line">68         return subMap.get(i);</span><br><span class="line">69     &#125;</span><br><span class="line">70     </span><br><span class="line">71     public static void main(String[] args)</span><br><span class="line">72     &#123;</span><br><span class="line">73         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">74         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">75             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">76                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">77     &#125;</span><br><span class="line">78 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>可以运行一下看一下结果：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.0:111]加入集合中, 其Hash值为575774686</span><br><span class="line">[192.168.0.1:111]加入集合中, 其Hash值为8518713</span><br><span class="line">[192.168.0.2:111]加入集合中, 其Hash值为1361847097</span><br><span class="line">[192.168.0.3:111]加入集合中, 其Hash值为1171828661</span><br><span class="line">[192.168.0.4:111]加入集合中, 其Hash值为1764547046</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.4:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.4:111]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>看到经过FNV1_32_HASH算法重新计算过后的Hash值，就比原来String的hashCode()方法好多了。从运行结果来看，也没有问题，三个点路由到的都是顺时针离他们Hash值最近的那台服务器上。</p><p><strong>使用虚拟节点来改善一致性Hash算法</strong></p><p>上面的一致性Hash算法实现，可以在很大程度上解决很多分布式环境下不好的路由算法导致系统伸缩性差的问题，但是会带来另外一个问题：负载不均。</p><p>比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。<strong>某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求</strong>。</p><p>解决这个问题的办法是引入虚拟节点，其工作原理是：<strong>将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上</strong>。采取这样的方式，就可以有效地解决增加或减少节点时候的负载不均衡的问题。</p><p>至于一个物理节点应该拆分为多少虚拟节点，下面可以先看一张图：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212234143027-642938706.png" alt="img"></p><p>横轴表示需要为每台福利服务器扩展的虚拟节点倍数，纵轴表示的是实际物理服务器数。可以看出，物理服务器很少，需要更大的虚拟节点；反之物理服务器比较多，虚拟节点就可以少一些。比如有10台物理服务器，那么差不多需要为每台服务器增加100~200个虚拟节点才可以达到真正的负载均衡。</p><p><strong>一致性Hash算法实现版本2：带虚拟节点</strong></p><p>在理解了使用虚拟节点来改善一致性Hash算法的理论基础之后，就可以尝试开发代码了。编程方面需要考虑的问题是：</p><p>1、一个真实结点如何对应成为多个虚拟节点？</p><p>2、虚拟节点找到后如何还原为真实结点？</p><p>这两个问题其实有很多解决办法，我这里使用了一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如”192.168.0.0:111”就把它变成”192.168.0.0:111&amp;&amp;VN0”到”192.168.0.0:111&amp;&amp;VN4”，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到”&amp;&amp;”的位置就可以了。</p><p>下面来看一下带虚拟节点的一致性Hash算法的Java代码实现：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  */</span><br><span class="line"> 5 public class ConsistentHashingWithVirtualNode</span><br><span class="line"> 6 &#123;</span><br><span class="line"> 7     /**</span><br><span class="line"> 8      * 待添加入Hash环的服务器列表</span><br><span class="line"> 9      */</span><br><span class="line">10     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">11             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">12     </span><br><span class="line">13     /**</span><br><span class="line">14      * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span><br><span class="line">15      */</span><br><span class="line">16     private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;();</span><br><span class="line">17     </span><br><span class="line">18     /**</span><br><span class="line">19      * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</span><br><span class="line">20      */</span><br><span class="line">21     private static SortedMap&lt;Integer, String&gt; virtualNodes = </span><br><span class="line">22             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">23     </span><br><span class="line">24     /**</span><br><span class="line">25      * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span><br><span class="line">26      */</span><br><span class="line">27     private static final int VIRTUAL_NODES = 5;</span><br><span class="line">28     </span><br><span class="line">29     static</span><br><span class="line">30     &#123;</span><br><span class="line">31         // 先把原始的服务器添加到真实结点列表中</span><br><span class="line">32         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">33             realNodes.add(servers[i]);</span><br><span class="line">34         </span><br><span class="line">35         // 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span><br><span class="line">36         for (String str : realNodes)</span><br><span class="line">37         &#123;</span><br><span class="line">38             for (int i = 0; i &lt; VIRTUAL_NODES; i++)</span><br><span class="line">39             &#123;</span><br><span class="line">40                 String virtualNodeName = str + &quot;&amp;&amp;VN&quot; + String.valueOf(i);</span><br><span class="line">41                 int hash = getHash(virtualNodeName);</span><br><span class="line">42                 System.out.println(&quot;虚拟节点[&quot; + virtualNodeName + &quot;]被添加, hash值为&quot; + hash);</span><br><span class="line">43                 virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">44             &#125;</span><br><span class="line">45         &#125;</span><br><span class="line">46         System.out.println();</span><br><span class="line">47     &#125;</span><br><span class="line">48     </span><br><span class="line">49     /**</span><br><span class="line">50      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">51      */</span><br><span class="line">52     private static int getHash(String str)</span><br><span class="line">53     &#123;</span><br><span class="line">54         final int p = 16777619;</span><br><span class="line">55         int hash = (int)2166136261L;</span><br><span class="line">56         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">57             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">58         hash += hash &lt;&lt; 13;</span><br><span class="line">59         hash ^= hash &gt;&gt; 7;</span><br><span class="line">60         hash += hash &lt;&lt; 3;</span><br><span class="line">61         hash ^= hash &gt;&gt; 17;</span><br><span class="line">62         hash += hash &lt;&lt; 5;</span><br><span class="line">63         </span><br><span class="line">64         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">65         if (hash &lt; 0)</span><br><span class="line">66             hash = Math.abs(hash);</span><br><span class="line">67         return hash;</span><br><span class="line">68     &#125;</span><br><span class="line">69     </span><br><span class="line">70     /**</span><br><span class="line">71      * 得到应当路由到的结点</span><br><span class="line">72      */</span><br><span class="line">73     private static String getServer(String node)</span><br><span class="line">74     &#123;</span><br><span class="line">75         // 得到带路由的结点的Hash值</span><br><span class="line">76         int hash = getHash(node);</span><br><span class="line">77         // 得到大于该Hash值的所有Map</span><br><span class="line">78         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">79                 virtualNodes.tailMap(hash);</span><br><span class="line">80         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">81         Integer i = subMap.firstKey();</span><br><span class="line">82         // 返回对应的虚拟节点名称，这里字符串稍微截取一下</span><br><span class="line">83         String virtualNode = subMap.get(i);</span><br><span class="line">84         return virtualNode.substring(0, virtualNode.indexOf(&quot;&amp;&amp;&quot;));</span><br><span class="line">85     &#125;</span><br><span class="line">86     </span><br><span class="line">87     public static void main(String[] args)</span><br><span class="line">88     &#123;</span><br><span class="line">89         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">90         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">91             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">92                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">93     &#125;</span><br><span class="line">94 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>关注一下运行结果：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN0]被添加, hash值为1686427075</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN1]被添加, hash值为354859081</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN2]被添加, hash值为1306497370</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN3]被添加, hash值为817889914</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN4]被添加, hash值为396663629</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN0]被添加, hash值为1032739288</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN1]被添加, hash值为707592309</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN2]被添加, hash值为302114528</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN3]被添加, hash值为36526861</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN4]被添加, hash值为848442551</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN0]被添加, hash值为1452694222</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN1]被添加, hash值为2023612840</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN2]被添加, hash值为697907480</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN3]被添加, hash值为790847074</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN4]被添加, hash值为2010506136</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN0]被添加, hash值为891084251</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN1]被添加, hash值为1725031739</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN2]被添加, hash值为1127720370</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN3]被添加, hash值为676720500</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN4]被添加, hash值为2050578780</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN0]被添加, hash值为586921010</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN1]被添加, hash值为184078390</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN2]被添加, hash值为1331645117</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN3]被添加, hash值为918790803</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN4]被添加, hash值为1232193678</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.2:111]</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>从代码运行结果看，每个点路由到的服务器都是Hash值顺时针离它最近的那个服务器节点，没有任何问题。</p><p>通过采取虚拟节点的方法，一个真实结点不再固定在Hash换上的某个点，而是大量地分布在整个Hash环上，这样即使上线、下线服务器，也不会造成整体的负载不均衡。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置反向代理</title>
      <link href="/2016/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2016/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前项目中的前端页面还不是很多，打算进行前后端解耦，把页面拆出来放到nginx中，页面上通过异步请求接口获取数据，再进行页面渲染，使用nginx的反向代理机制可以解决跨域问题</p></blockquote><h3 id="WHAT-跨域问题"><a href="#WHAT-跨域问题" class="headerlink" title="WHAT ?跨域问题"></a>WHAT ?跨域问题</h3><blockquote><p>页面资源与API接口不在同一个IP,或域名，端口时，所进行的访问都是跨域的，而浏览器为了安全问题都是限制了跨域访问，不允许跨域请求资源</p></blockquote><h3 id="常见的跨域解决方案"><a href="#常见的跨域解决方案" class="headerlink" title="常见的跨域解决方案"></a>常见的跨域解决方案</h3><blockquote><p>目前来讲没有不依靠服务器端来跨域请求资源的技术</p></blockquote><ul><li><p>jsonp 需要目标服务器配合一个callback函数。</p></li><li><p>window.name+iframe 需要目标服务器响应window.name。</p></li><li><p>window.location.hash+iframe 同样需要目标服务器作处理。</p></li><li><p>html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。</p></li><li><p>CORS  需要服务器设置header ：Access-Control-Allow-Origin。</p></li><li><p>nginx反向代理，不需要目标服务器配合，只需要搭建一个nginx服务器，用于转发请求。</p></li></ul><h3 id="nginx反向代理解决跨域问题"><a href="#nginx反向代理解决跨域问题" class="headerlink" title="nginx反向代理解决跨域问题"></a>nginx反向代理解决跨域问题</h3><blockquote><p>nginx.conf</p></blockquote><pre><code>server &#123;    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / &#123; #所有以/开头的地址,实际上是所有请求        root   html; ＃去请求../html文件夹里的文件,其中..的路径在nginx里面有定义        index  index.html index.htm;  ＃首页响应地址    &#125;</code></pre><blockquote><p>server代表启动的一个服务，location 是一个定位规则。</p></blockquote><p>　location是nginx用来路由的入口，其实就是要在location里面实现反向代理。</p><blockquote><p>ajax 部分的代码片段:</p></blockquote><pre><code>    // 获取接口数据，并渲染    qrCode.shuffle = function () &#123;       var uid = getUrlParam(&quot;uid&quot;);    //var url = &quot;http://api.xxx/qr/profile?uid=&quot;;    var proxyurl = &quot;/proxy/html/qr/profile&quot;;    var allType = $(&quot;#allType&quot;).val();$.ajax(&#123;    url: proxyurl,    async: true,    type: &quot;GET&quot;,    data: &#123;        &quot;uid&quot;: uid,    &#125;,    dataType: &quot;json&quot;,    timeout: 1000,    success: function (data) &#123;        var userInfo = data;        // 用户昵称        $(&quot;#name&quot;).append(userInfo.nickName);        // 用户性别图片        $(&quot;#sex&quot;).attr(&quot;src&quot;, &quot;img/&quot; + userInfo.sex);        // BluId        $(&quot;#idnumber&quot;).append(userInfo.userNum);    &#125;,&#125;)&#125;;</code></pre><blockquote><p>如果通过 url &#x3D; “<a href="http://api.xxx/qr/profile?uid=XX&quot;">http://api.xxx/qr/profile?uid=XX&quot;</a> 访问接口，必然会        </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew常用命令</title>
      <link href="/2016/12/09/%E5%B7%A5%E5%85%B7/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/12/09/%E5%B7%A5%E5%85%B7/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>mac上安装应用的命令，同apt-get，yum一样好使</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>Homebrew安装命令，mac下自带ruby，在终端输入以下命令，按提示安装即可  </p><pre><code>  ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;  </code></pre></li><li><p>参考 <a href="http://brew.sh/index_zh-cn.html">Homebrew</a></p></li></ul><h3 id="brew常用命令："><a href="#brew常用命令：" class="headerlink" title="brew常用命令："></a>brew常用命令：</h3><pre><code>    安装软件:  brew install  ＊（软件名 eg. brew install nginx）    卸载软件:  brew uninstall ＊    搜索软件:  brew search *    显示已经安装软件列表:  brew list    更新软件:  brew update    更新某具体软件: brew upgrade git</code></pre><h3 id="install-brew-cask-管理安装非终端的软件"><a href="#install-brew-cask-管理安装非终端的软件" class="headerlink" title="install brew cask 管理安装非终端的软件"></a>install brew cask 管理安装非终端的软件</h3><pre><code>brew install brew-cask-completion➜  ~ brew cask search qq==&gt; Exact Matchqq==&gt; Partial Matchesqqbrowser           qqinput             qqmacmgr            qqmusic</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌开发者大会笔记</title>
      <link href="/2016/12/09/%E6%9D%82%E8%AE%B0/%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/12/09/%E6%9D%82%E8%AE%B0/%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="谷歌开发者大会笔记"><a href="#谷歌开发者大会笔记" class="headerlink" title="谷歌开发者大会笔记"></a>谷歌开发者大会笔记</h1><blockquote><p>很高兴参加了今年的google开发者大会，感觉收获颇丰，与会上做了一些笔记和拍照，简单整理记录下~ 做一次分享也是帮自己回顾及梳理下思路</p></blockquote><blockquote><p>google力推的创新和技术</p></blockquote><ul><li>Android</li><li>PWA、AMP</li><li>Angular</li><li>人工智能,深度学习</li><li>VR</li></ul><p>课题很多，自己主要参与了移动web相关的讲座:</p><blockquote><p>总结关键词:</p></blockquote><ul><li>渐进式，沉浸式，通知，用户体验，便捷</li><li>即时加载<blockquote><p>Service Worker（对离线和弱网络的情况下的支持）</p></blockquote></li><li>桌面icon（应用免安装）</li><li>快速</li><li>安全</li><li>灵活（适配各种分辨率，尺寸的）</li><li>未来无限可能(通过web控制一切)</li></ul><h2 id="大会主题："><a href="#大会主题：" class="headerlink" title="大会主题："></a>大会主题：</h2><hr><ul><li><p>android</p></li><li><p>firebase</p></li><li><p>angular</p></li><li><p>移动web</p></li><li><p>google play</p></li><li><p>ads</p></li><li><p>what’s Next</p></li></ul><hr><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><blockquote><p>在主会场听了简介，具体内容期待官方分享演讲PPT，或视频回放</p></blockquote><ul><li><p>Android新特性   </p><pre><code>  Doze省电模式“增强版”</code></pre></li><li><p>Android studio 新版本特性  </p><pre><code>  快速（版块设计）、智能（APK 分析 APK Analyzer 版块测试项Layout Inspector）、支持（多窗口、快速设置、通知、仿真模拟器）</code></pre></li><li><p>Android Support Library 新特性</p></li><li><p>Android Wear2.0</p></li><li><p>Android 兼容性（让应用更好的适应平台变化，设备类型差异和弱网络环境）</p></li><li><p>Android 开发中的电量和内存优化</p></li></ul><hr><h3 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h3><ul><li>Firebase 介绍（何时，何地使用）</li><li>Firebase 测试、崩溃报告</li><li>Firebase Analytics</li><li>Firebase 跨平台推送（Cloud Messaging）</li><li>Code Lab（TODO 待了解）</li></ul><hr><h3 id="Augular"><a href="#Augular" class="headerlink" title="Augular"></a>Augular</h3><ul><li>已经推出了2.0版本。</li><li>使用Angular可以开发PWA.<blockquote><p>Angular core</p></blockquote></li><li>申明式模板</li><li>变更检测</li><li>依赖注入</li><li>组件式架构</li><li>AOT静态编译</li><li>平台无关</li></ul><blockquote><p>Angular 无处不在</p></blockquote><pre><code>    PWA 移动duan端 桌面端    </code></pre><blockquote><p>服务端渲染<br>开发效率</p></blockquote><ul><li>javaScript 的超集</li><li>增强型</li><li>可读性</li><li>相似性</li><li>工具链</li></ul><hr><h3 id="移动web"><a href="#移动web" class="headerlink" title="移动web"></a>移动web</h3><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><blockquote><p>Progessive Web Apps(PWA)</p></blockquote><h5 id="渐进式网页应用程序特点"><a href="#渐进式网页应用程序特点" class="headerlink" title="渐进式网页应用程序特点"></a>渐进式网页应用程序特点</h5><ul><li>可靠的</li><li>快速的</li><li>引人入胜</li></ul><blockquote><p>引人入胜:</p></blockquote><ul><li>添加到主屏幕</li><li>沉浸式</li><li>通知</li><li>Web 通知</li></ul><blockquote><p>PWD 化的三种途径</p></blockquote><ul><li>自下而上</li><li>简单版本</li><li>单一功能</li></ul><blockquote><p>使用PWA达到的效果</p></blockquote><ul><li>交互缓存</li><li>后台通知</li><li>快速流畅，60fps交互体验</li><li>UI尺寸，动态调节</li><li>桌面图标，方便添加</li></ul><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><blockquote><p>原生App拥有Web应用通常所不具备的富离线体验，定时的静默更新，消息通知推送等功能。而新的Service workers标准让在Web App上拥有这些功能。</p></blockquote><ul><li><p>Service Worker 必须配置HTTPS</p></li><li><p>Service Worker 生命周期</p></li><li><p>缓存策略</p><pre><code>  网络优先，失败则读取缓存  先读取缓存，再从网络上更新内容  一般回退流程  同时读取网络与缓存内容，接受其中最快的返回结果</code></pre></li></ul><blockquote><p>测试过程可以通过 Chrome Dev Tools 观察和处理缓存     </p></blockquote><ul><li>github 源码分享：<br><a href="https://github.com/GoogleChrome/sw-toolbox">sw-toolbox</a></li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><blockquote><p>介绍为何如何使用HTTPS(推荐了 开源证书及价格优惠的证书网址 &#x2F; 搜索排行指南)</p></blockquote><blockquote><p>为什么选择 HTTPS</p></blockquote><ul><li>身份验证（你在与谁通信）</li><li>加密（谁能读取数据）</li><li>整合 （谁能修改数据）</li></ul><blockquote><p>HTTPS的成本</p></blockquote><ul><li>证书</li><li>搜索排行</li></ul><blockquote><p>推荐SSL 证书提供</p></blockquote><ul><li><p><a href="https://ssmate.com/pricing">sslmate</a> (Standard SSL $15.95 &#x2F; Multi-Host SSL $24.95)</p></li><li><p>开源 Let’s Encrypt</p></li><li><p><a href="https://developers.google.cn/web/fundamentals/security/encrpt-transit/migration-concerns">搜索排行指南</a></p></li></ul><blockquote><p>HTTPS Chrome 开发者工具中的安全面板</p></blockquote><ul><li>Chrome DevTools Security Panel</li></ul><blockquote><p>HTTP&#x2F;2 释放HTTPS的潜能</p></blockquote><blockquote><p>更多价值的参考信息</p></blockquote><ul><li><a href="https://developers.google.cn/web/fundamentals/security/encrypt-in-transit/">传输过程中的数据加密</a></li></ul><blockquote><p>待整理</p></blockquote><ul><li>使用内容安全策略 </li><li>避免出现混合内容</li></ul><h4 id="可安装应用与通知推送机制"><a href="#可安装应用与通知推送机制" class="headerlink" title="可安装应用与通知推送机制"></a>可安装应用与通知推送机制</h4><blockquote><p>通知剖析</p></blockquote><ul><li><p>时效性、要合时</p></li><li><p>通知内容：要精确</p></li><li><p>通知中的内容和人物：要切实相关</p></li><li><p>为用户提供<code>丰富的选项</code>（用户无需打开应用，即可轻松完成任务）</p><pre><code>  以信用卡还款通知为例，通知只显示本次需要还款的金额，还需要用户去跳转连接进行还款操作，不如直接在通知中增加是否马上还款的确认按钮，即通过通知服务增加与用户的互动性。</code></pre></li><li><p><a href="https://github.com/web-push-libs/web-push">WEB推送源码分享</a></p></li></ul><blockquote><p>更多分享待整理：</p></blockquote><ul><li><a href="g.cn/WebPushNotifications">网络推送通知入门指南</a></li><li><a href="">对数据有效负载进行加密</a></li><li><a href="">Chrome 中的VAPID</a></li></ul><h4 id="PWA-工具："><a href="#PWA-工具：" class="headerlink" title="PWA 工具："></a>PWA 工具：</h4><blockquote><p>使用 App Shell 和 动态内容模型</p></blockquote><ul><li>Lighthouse</li><li>the dev tools application panel</li></ul><p><strong>相关链接：</strong> </p><ul><li><a href="http://goo.gl/4EhFAC">客户代码样例</a></li><li><a href="http://goo.gl/A6pBhj">项目主页</a></li><li><a href="https://youtu.be/jCKZDTtUA2A">使用Service Workder 实现即时加载</a></li><li><a href="http://goo.gl/Bxdx99">PWA 代码实验室</a></li></ul><h4 id="使用Angular构建-PWA"><a href="#使用Angular构建-PWA" class="headerlink" title="使用Angular构建 PWA"></a>使用Angular构建 PWA</h4><blockquote><p>App Shell 生成<br>Service Worker<br>Push 推送<br>演讲者现场编程演示</p></blockquote><ul><li><a href="https://github.com/StephenFluin/2016-pwa-beijing">现场写的代码分享</a></li><li><a href="https://github.com/alxhub/ng2-weather-pwa">Full Angular PWA Sample</a></li></ul><h4 id="web-Apps-的未来"><a href="#web-Apps-的未来" class="headerlink" title="web Apps 的未来"></a>web Apps 的未来</h4><blockquote><p>今天的WEB &#x3D;&gt; 渐进式网页应用程序（PWA）</p></blockquote><ul><li>即时加载 （对离线和弱网络差的情况均适用）</li><li>把应用添加到主屏幕快捷方式</li><li>推送增加用户互动</li><li>快速 流畅的动画，滚屏和导航</li><li>安全（HTTPS）</li><li>灵敏（适应任意屏幕尺寸）</li></ul><blockquote><p>未来的WEB的讨论</p></blockquote><ul><li>了解用户是谁</li><li>凭证管理</li><li>支付WEB上的东西 （google主导支付协议规范（W3C PaymentRequest））</li></ul><blockquote><p>目前支付流程： <strong>手动  冗长 缓慢 N个按键</strong>  </p></blockquote><blockquote><p>PaymentRequest : <strong>跨浏览器  跨平台  开源生态</strong></p></blockquote><ul><li>硬件连接<blockquote><p>基础BLE术语 : </p></blockquote></li><li>“Central” device(my phone)</li><li>“Peripheral”device(candle)</li><li>GATT(Generic ATTribute profile)</li></ul><hr><ul><li><p>物理网</p><blockquote><p><a href="http://www.physical–web.org/">http://www.physical–web.org</a></p></blockquote></li><li><p>WebVR<br>明年就可以看到webVR的相关产品</p></li></ul><hr><h3 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h3><blockquote><p>主要介绍如何 通过Google Play，面向全球市场</p></blockquote><ul><li>google本次大会主题之一，也包含希望开发者看到国外的市场</li></ul><hr><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><blockquote><p>主要介绍google向企业用户提供的各种服务</p></blockquote><hr><h3 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next"></a>What’s Next</h3><h4 id="Blokly"><a href="#Blokly" class="headerlink" title="Blokly"></a>Blokly</h4><blockquote><p>Google的开源产品，用于构建图形化编程的网页和移动应用</p></blockquote><h4 id="使用Material-Design-走向成功"><a href="#使用Material-Design-走向成功" class="headerlink" title="使用Material Design 走向成功"></a>使用Material Design 走向成功</h4><blockquote><p>TODO 待了解</p></blockquote><h4 id="TensorFlow-简介"><a href="#TensorFlow-简介" class="headerlink" title="TensorFlow 简介"></a>TensorFlow 简介</h4><ul><li>Google开源的人工智能项目,机器学习库<blockquote><p>DeepMind也计划开源</p></blockquote></li></ul><h4 id="深度学习与艺术"><a href="#深度学习与艺术" class="headerlink" title="深度学习与艺术"></a>深度学习与艺术</h4><blockquote><p>主要介绍图像识别，归类技术（TODO 待了解）</p></blockquote><h4 id="DayDream-简介"><a href="#DayDream-简介" class="headerlink" title="DayDream 简介"></a>DayDream 简介</h4><blockquote><p>Google VR平台，明年会有很多DayDream Ready的设备出来。</p></blockquote><h4 id="Tango-简介"><a href="#Tango-简介" class="headerlink" title="Tango 简介"></a>Tango 简介</h4><blockquote><p>Google VR平台,新款的nexus手机上会看到相关应用功能</p></blockquote><hr><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><h2 id="Google-技术的中文网站"><a href="#Google-技术的中文网站" class="headerlink" title="Google 技术的中文网站"></a>Google 技术的中文网站</h2><ul><li><p><a href="https://developers.google.cn/">developers.google.cn</a>  整合的Google技术学习资源，包括分门别类的技术产品和开发指南。</p></li><li><p><a href="https://developer.android.google.cn/index.html">developer.android.google.cn</a> 特别为Android开发者推出的官网，有中文界面，不过目前官方文档还是英文的。</p></li><li><p><a href="https://developers.googleblog.cn/">Google开发者博客</a></p></li><li><p><a href="https://firebase.google.cn/">firebase.google.cn</a> Firebase中文官网，包括英文的官方文档，不过想要使用的话还是需要链接到国外主站。</p></li><li><p><a href="https://angular.cn/">angular</a></p></li></ul><hr><p> 马凯 2016&#x2F;12&#x2F;9</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置MySQL-Python报错问题</title>
      <link href="/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%85%8D%E7%BD%AEMySQL-Python%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
      <url>/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%85%8D%E7%BD%AEMySQL-Python%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习python时，配置MySQL-Python的时候系统报错，提示：</p></blockquote><pre><code>EnvironmentError: mysql_config not foundGoogle后得知mysql_config是属于MySQL开发用的文件，而使用apt-get安装的MySQL是没有这个文件的，于是在包安装器里面寻找</code></pre><ul><li><p>libmysqld-dev</p></li><li><p>libmysqlclient-dev</p></li></ul><p>这两个包安装后问题即可解决</p><pre><code>sudo apt-get -y install mysql-server mysql-client libmysqlclient-dev mytop</code></pre><ul><li>注意:import MySQLdb “y” 是小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios-apple-review被拒-app-server-完全适配-ipv6（转载）</title>
      <link href="/2016/11/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2016/11/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>原文出处 <a href="https://devthinking.com/ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6/">ios-apple-review被拒-app-server-完全适配-ipv6</a></li></ul><p>感谢作者分享</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv6相关总结</title>
      <link href="/2016/11/16/%E7%BD%91%E7%BB%9C/%20IPv6%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2016/11/16/%E7%BD%91%E7%BB%9C/%20IPv6%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>ios上架AppStore时，被驳回，要求必须支持IPv6,在此总结一些IPv6相关的知识点</p></blockquote><h2 id="IPv6格式"><a href="#IPv6格式" class="headerlink" title="IPv6格式"></a>IPv6格式</h2><blockquote><p>IPv6是128bit</p></blockquote><h2 id="IPv6-DNS"><a href="#IPv6-DNS" class="headerlink" title="IPv6 DNS:"></a>IPv6 DNS:</h2><p>未知国家<br>2001:470:20::2</p><p>加拿大<br>2001:478:6:0:230:48ff:fe22:6a29</p><p>英国<br>2001:7fd::1</p><p>日本<br>2001:dc4::1</p><h2 id="Linux命令-ping-IPv6："><a href="#Linux命令-ping-IPv6：" class="headerlink" title="Linux命令 ping IPv6："></a>Linux命令 ping IPv6：</h2><p>Linux下ping IPv6需要使用ping6，如果使用ping，则会提示ping: unknown host。</p><p>ping6 ipv6.google.com</p><p>ping6 2001:470:20::2</p><p>PING 2001:470:20::2(2001:470:20::2) 56 data bytes</p><p>64 bytes from 2001:470:20::2: icmp_seq&#x3D;11 ttl&#x3D;60 time&#x3D;714 ms</p><p>64 bytes from 2001:470:20::2: icmp_seq&#x3D;12 ttl&#x3D;60 time&#x3D;4.65 ms</p><p>ping 2001:470:20::2</p><p>ping: unknown host 2001:470:20::2</p><h2 id="Windows命令-ping-IPv6："><a href="#Windows命令-ping-IPv6：" class="headerlink" title="Windows命令 ping IPv6："></a>Windows命令 ping IPv6：</h2><p>ping -6 ipv6.google.com</p><h2 id="Linux命令-wget-IPv6："><a href="#Linux命令-wget-IPv6：" class="headerlink" title="Linux命令 wget IPv6："></a>Linux命令 wget IPv6：</h2><p>wget -6 <a href="http://ipv6.google.com/">http://ipv6.google.com</a></p><h2 id="Linux和Windows命令查询域名AAAA记录，是否支持IPv6："><a href="#Linux和Windows命令查询域名AAAA记录，是否支持IPv6：" class="headerlink" title="Linux和Windows命令查询域名AAAA记录，是否支持IPv6："></a>Linux和Windows命令查询域名AAAA记录，是否支持IPv6：</h2><p>Linux和Windows都是使用nslookup程序查询dns。</p><pre><code>$ nslookup&gt;set querytype=aaaa&gt;ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.ipv6.l.google.comhas AAAA address 2404:6800:8005::6a</code></pre><p>由此可知，IPv4的DNS也能返回域名的IPv6记录，即AAAA记录。</p><pre><code>$ nslookup&gt; set querytype=aaaa&gt; google.comServer:2001:470:20::2Address:2001:470:20::2#53Non-authoritative answer:google.comhas AAAA address 2001:4860:800b::69</code></pre><p>配置域名同时支持IPv6和IPv4：</p><p>领先的域名注册商同时支持IPv6和IPv4，比如godaddy、namesilo，在注册商这里购买了域名之后，登录到域名管理界面，可以设置A记录和AAAA记录。</p><p>假设购买了example.com，希望example.com同时支持IPv6和IPv4，则添加一条A记录指向192.0.32.10，添加一条AAAA记录，指向2620:0:2d0:200::10，等待一段时间即可生效（等待时间与TTL有关）。结果如下：</p><pre><code>$ nslookup&gt; example.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:Name:example.comAddress: 192.0.32.10&gt; set querytype=aaaa&gt; example.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:example.comhas AAAA address 2620:0:2d0:200::10</code></pre><p>配置域名只支持IPv6：</p><p>假设购买了google.com，希望ipv6.google.com只支持IPv6，不支持IPv4，则不添加A记录，只添加一条AAAA记录，指向2404:6800:8005::68。结果如下：</p><pre><code>$ nslookup&gt; ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.&gt; ipv6.l.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:*** Can&#39;t find ipv6.l.google.com: No answer&gt; set querytype=aaaa&gt; ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.ipv6.l.google.comhas AAAA address 2404:6800:8005::68</code></pre><h2 id="Apache-httpd配置IPv6："><a href="#Apache-httpd配置IPv6：" class="headerlink" title="Apache httpd配置IPv6："></a>Apache httpd配置IPv6：</h2><p>Apache httpd配置支持IPv6，需要给IP带上方括号，参考：<a href="http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/core.html#virtualhost">http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/core.html#virtualhost</a></p><pre><code>&lt;VirtualHost [2404:6800:8005::68]:80&gt;ServerAdmin webmaster@ipv6.google.comDocumentRoot /var/www/html/ipv6.google.com/ServerName ipv6.google.com&lt;/VirtualHost&gt;IPv4内网用户如何使用IPv6：</code></pre><p>安装Teredo隧道即可。访问IPv6网站通过Teredo服务器转发，速度受影响。</p><ul><li>注意：</li></ul><p>Teredo隧道与PPPOE冲突，解决方法：使用路由拨号，本机只有一个本地连接即可。</p><p>Teredo隧道与多网卡冲突，比如virtualbox的虚拟网卡，解决办法：禁用别的网卡，只留一个本地连接。</p><ul><li><p>参考：</p></li><li><p>在IPv4网络下接入IPv6网络的方法：<a href="http://www.ipv6bbs.cn/thread-151-1-1.html">http://www.ipv6bbs.cn/thread-151-1-1.html</a></p></li><li><p>资料：<a href="http://felixcat.net/2010/04/install-teredo-ipv6/">http://felixcat.net/2010/04/install-teredo-ipv6/</a></p></li><li><p><a href="http://www.ipv6home.cn/html/63/t-17563.html">http://www.ipv6home.cn/html/63/t-17563.html</a></p></li><li><p>Win 7下用Teredo隧道接入IPv6后，操作系统默认还是直接走IPv4：<a href="http://social.technet.microsoft.com/Forums/zh-CN/window7betacn/thread/ae1f7d47-aa19-493d-a10d-f8032441a147/">http://social.technet.microsoft.com/Forums/zh-CN/window7betacn/thread/ae1f7d47-aa19-493d-a10d-f8032441a147/</a></p></li><li><p>teredo IPv6 配置hosts后无法使用gtalk客户端（解决办法：使用Pidgin）：<a href="http://www.google.com/support/forum/p/other/thread?tid=4f65f26a7da1785f&amp;hl=zh-CN">http://www.google.com/support/forum/p/other/thread?tid=4f65f26a7da1785f&amp;hl=zh-CN</a></p></li></ul><h2 id="IPv4外网用户如何使用IPv6："><a href="#IPv4外网用户如何使用IPv6：" class="headerlink" title="IPv4外网用户如何使用IPv6："></a>IPv4外网用户如何使用IPv6：</h2><p>安装isatap隧道即可。访问IPv6网站通过isatap网关转发，速度受影响。</p><p>如何设置浏览器默认使用IPv6：</p><p>1、真实IPv4 + 真实IPv6</p><p>操作系统会优先使用IPv6（未测试）。</p><p>2、真实IPv4内网+ IPv6 Teredo隧道</p><p>当域名同时有A和AAAA记录时，Windows 7、Ubuntu优先使用真实IPv4内网，所以需要修改hosts加入IPv6。</p><p>当域名只有AAAA记录时，Ubuntu可直接访问（比如ipv6.google.com），不用配hosts。</p><p>2、真实IPv4外网+ IPv6 isatap隧道</p><p>XP可以直接访问ipv6.google.com，不能直接访问docs.google.com，需要配hosts。</p><p>IPv6路由器：</p><p>D-Link一百元的家用路由器国外版本支持IPv6：<a href="http://www.dlink.com/ipv6%EF%BC%8C%E6%AF%94%E5%A6%82DIR-615%EF%BC%8C%E6%88%AA%E5%9B%BE%E5%9C%A8%E6%9C%80%E5%90%8E%E3%80%82%E4%BD%86%E5%9B%BD%E5%86%85%E7%89%88%E6%9C%AC%E4%B8%8D%E7%9F%A5%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81IPv6%EF%BC%8C%E4%BA%AC%E4%B8%9C%E5%AE%A2%E6%9C%8D%E8%AF%B4%E4%B8%8D%E6%94%AF%E6%8C%81%E3%80%82">http://www.dlink.com/ipv6，比如DIR-615，截图在最后。但国内版本不知是否支持IPv6，京东客服说不支持。</a></p><p>TP-Link家用路由器不支持IPv6。</p><p>是不是刷了dd-wrt完整版操作系统的路由器都支持IPv6，还待确认。</p><ul><li><p>参考资料：</p></li><li><p>google的工具 ： <a href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></p></li><li><p>IPv6 隧道 ： <a href="https://tunnelbroker.net/">https://tunnelbroker.net/</a></p></li><li><p>测试浏览器是否支持IPv6：<a href="http://test-ipv6.com/">http://test-ipv6.com/</a></p></li><li><p>测试浏览器是否默认使用IPv6：<a href="http://www.kame.net/">http://www.kame.net/</a></p></li><li><p>火狐扩展，显示正在访问的网站IP，可以看出是否是IPv6：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/worldip-flag-and-datacenter-pi/">https://addons.mozilla.org/zh-CN/firefox/addon/worldip-flag-and-datacenter-pi/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Data Rest Service</title>
      <link href="/2016/11/04/java/%20Spring%20Boot%20Data%20Rest%20Service/"/>
      <url>/2016/11/04/java/%20Spring%20Boot%20Data%20Rest%20Service/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Spring Boot 可以通过spring-boot-starter-data-rest来对外提供REST API，可以免于编写对应的Controller，且具备分页和排序的功能。</p></blockquote><h2 id="pom文件中增加相关的依赖项"><a href="#pom文件中增加相关的依赖项" class="headerlink" title="pom文件中增加相关的依赖项"></a>pom文件中增加相关的依赖项</h2><pre><code>    &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                  &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 文章收藏</title>
      <link href="/2016/11/01/java/%20JAVA%20%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/"/>
      <url>/2016/11/01/java/%20JAVA%20%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<p>整理了一些不错的java文章，感谢作者们的贡献</p><ul><li><a href="http://www.importnew.com/15605.html#impl_equals">Java习惯用法总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 效率插件</title>
      <link href="/2016/11/01/%E5%B7%A5%E5%85%B7/Chrome%20%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/"/>
      <url>/2016/11/01/%E5%B7%A5%E5%85%B7/Chrome%20%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>整理收集一些Chrome的好用的插件</p><h3 id="RESTFUL"><a href="#RESTFUL" class="headerlink" title="RESTFUL"></a>RESTFUL</h3><ul><li><p>Postman</p><pre><code>  RESTFUL的客户端调式工具，可以分类保存</code></pre></li></ul><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><ul><li><p>Octotree</p><pre><code>  在github上 树形展示</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome 效率插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 删除乱码的文件</title>
      <link href="/2016/10/21/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%88%A0%E9%99%A4%E4%B9%B1%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2016/10/21/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%88%A0%E9%99%A4%E4%B9%B1%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Linux 使用过程中，产生了一些乱码的文件，使用rm 命令无法正常删除<span id="more"></span>，这种情况下，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ehcache mybatis 分布式</title>
      <link href="/2016/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/ehcache%20mybatis%20%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2016/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/ehcache%20mybatis%20%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> 单机上，为mybatis加上缓存框架ehcache，非常简单。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postman 使用简介</title>
      <link href="/2016/10/16/%E6%B5%8B%E8%AF%95/%20postman%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2016/10/16/%E6%B5%8B%E8%AF%95/%20postman%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介下"><a href="#简介下" class="headerlink" title="简介下"></a>简介下</h2><blockquote><p>postman是个不错的测试工具，感觉应该是目前最方便快捷的API测试工具，建议更新到最新的版本，因为越来越强大～</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>特点一大堆吧，部分功能收费，But免费版本已经足够Happy的玩耍了，就简单说几个比较重要的特色吧</p><ul><li>Mac，Win，都能玩</li><li>脚本语言为javascript</li><li>已经自带了常用的代码模版</li><li>支持环境变量配置，并且支持导入</li><li>支持用例的导入，导出</li><li>可以批量跑用例</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略吧，chrome插件，官方下载客户端安装包（基于 Electron），推荐从官方下载安装客户端版</p><h2 id="使用玩法"><a href="#使用玩法" class="headerlink" title="使用玩法"></a>使用玩法</h2><blockquote><p>建议先花点时间（个把小时也就），看下官方文档</p></blockquote><ul><li><a href="https://www.getpostman.com/docs/">postman 官方文档</a></li></ul><p>简单几个截图总结说明下</p><p>整体结构</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk7thc6k9j219z0r2n3g.jpg"></p><p>请求前脚本举例，比如用于预先初始化一些参数</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk7z6f7w9j21af0qxn1r.jpg"></p><p>测试脚本编写模块，有很多现成的code模版</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk87g3herj219r0n0jwd.jpg"></p><p>批量跑用例  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8kftoxpj219j0qyq8c.jpg"></p><p>批量跑用例时的页面，展示每条的结果，及汇总  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8n17ge7j20wb0h4di9.jpg"></p><p>看下变量怎么玩滴  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8rjfmgfj20x80nan00.jpg"></p><h2 id="常用脚本解释说明"><a href="#常用脚本解释说明" class="headerlink" title="常用脚本解释说明"></a>常用脚本解释说明</h2><blockquote><p>新版本脚本有所更新，但是大差不差哈，具体可以去官网看下在</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">1. 清除一个全局变量</span><br><span class="line">     Clear a global variable</span><br><span class="line">    对应脚本：</span><br><span class="line">    postman.clearGlobalVariable(&quot;variable_key&quot;);</span><br><span class="line">    参数：需要清除的变量的key</span><br><span class="line"></span><br><span class="line">  2.清除一个环境变量</span><br><span class="line">    Clear an environment variable</span><br><span class="line">    对应脚本：</span><br><span class="line">    postman.clearEnvironmentVariable(&quot;variable_key&quot;);</span><br><span class="line">    参数：需要清除的环境变量的key</span><br><span class="line"></span><br><span class="line">  3.response包含内容</span><br><span class="line">    Response body:Contains string</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Body matches string&quot;] =responseBody.has(&quot;string_you_want_to_search&quot;);</span><br><span class="line">    参数：预期内容</span><br><span class="line"></span><br><span class="line">  4.将xml格式的response转换成son格式</span><br><span class="line">    Response body:Convert XML body to a JSON Object</span><br><span class="line">    对应脚本：</span><br><span class="line">    var jsonObject = xml2Json(responseBody);</span><br><span class="line">    参数：（默认不需要设置参数,为接口的response）需要转换的xml</span><br><span class="line"></span><br><span class="line">  5.response等于预期内容</span><br><span class="line">    Response body:Is equal to a string</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Body is correct&quot;] = responseBody === &quot;response_body_string&quot;;</span><br><span class="line">    参数：预期response</span><br><span class="line"></span><br><span class="line">  6.json解析key的值进行校验</span><br><span class="line">    Response body:JSON value check</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Args key contains argument passed as url parameter&quot;] = &#x27;test&#x27; in responseJSON.args</span><br><span class="line">    参数：test替换被测的值，args替换被测的key</span><br><span class="line"></span><br><span class="line">  7.检查response的header信息是否有被测字段</span><br><span class="line">    Response headers:Content-Type header check</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Content-Type is present&quot;] = postman.getResponseHeader(&quot;Content-Type&quot;);</span><br><span class="line">    参数：预期header</span><br><span class="line"></span><br><span class="line">  8.响应时间判断</span><br><span class="line">    Response time is less than 200ms</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Response time is less than 200ms&quot;] = responseTime &lt; 200;</span><br><span class="line">    参数：响应时间</span><br><span class="line"></span><br><span class="line">    9.设置全局变量</span><br><span class="line">      Set an global variable</span><br><span class="line">      对应脚本：</span><br><span class="line">      postman.setGlobalVariable(&quot;variable_key&quot;, &quot;variable_value&quot;);</span><br><span class="line">      参数：全局变量的键值</span><br><span class="line"></span><br><span class="line">    10.设置环境变量</span><br><span class="line">      Set an environment variable</span><br><span class="line">      对应脚本：</span><br><span class="line">      postman.setEnvironmentVariable(&quot;variable_key&quot;, &quot;variable_value&quot;);</span><br><span class="line">      参数：环境变量的键值</span><br><span class="line"></span><br><span class="line">    11.判断状态码</span><br><span class="line">      Status code:Code is 200</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Status code is 200&quot;] = responseCode.code != 400;</span><br><span class="line">      参数：状态码</span><br><span class="line"></span><br><span class="line">    12.检查code name 是否包含内容</span><br><span class="line">      Status code:Code name has string</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Status code name has string&quot;] = responseCode.name.has(&quot;Created&quot;);</span><br><span class="line">      参数：预期code name包含字符串</span><br><span class="line"></span><br><span class="line">    13.成功的post请求</span><br><span class="line">      Status code:Successful POST request</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Successful POST request&quot;] = responseCode.code === 201 || responseCode.code === 202;</span><br><span class="line"></span><br><span class="line">     14.微小验证器</span><br><span class="line">       Use Tiny Validator for JSON data            </span><br><span class="line">       对应脚本： </span><br><span class="line">        var schema = &#123;</span><br><span class="line">         &quot;items&quot;: &#123;</span><br><span class="line">         &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">        var data1 = [true, false];</span><br><span class="line">        var data2 = [true, 123];</span><br><span class="line">        console.log(tv4.error);</span><br><span class="line">        tests[&quot;Valid Data1&quot;] = tv4.validate(data1, schema);</span><br><span class="line">        tests[&quot;Valid Data2&quot;] = tv4.validate(data2, schema);</span><br><span class="line">        参数：可以修改items里面的键值对来对应验证json的参数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>简单总结了下postman 的基本玩法，更高级的等有了更深的体会，在补充之，希望能给您带来帮助～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派模型</title>
      <link href="/2016/10/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/10/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看过几篇文章后，这篇总结的不错，转载之，方便学习及回顾</p></blockquote><blockquote><p>原文出处： <a href="https://www.jianshu.com/p/acc7595f1b9d">huachao1001</a></p></blockquote><p>其实，双亲委派模型并不复杂。自定义类加载器也不难！随便从网上搜一下就能搜出一大把结果，然后<code>copy</code>一下就能用。但是，如果每次想自定义类加载器就必须搜一遍别人的文章，然后复制，这样显然不行。可是自定义类加载器又不经常用，时间久了容易忘记。相信你经常会记不太清<code>loadClass</code>、<code>findClass</code>、<code>defineClass</code>这些函数我到底应该重写哪一个？它们主要是做什么的？本文大致分析了各个函数的流程，目的就是让你看完之后，难以忘记！或者说，延长你对自定义类加载器的记忆时间！随时随地想自定义就自定义！</p><h1 id="1-双亲委派模型"><a href="#1-双亲委派模型" class="headerlink" title="1. 双亲委派模型"></a>1. 双亲委派模型</h1><p>关于双亲委派模型，网上的资料有很多。我这里只简单的描述一下，就当是复习。</p><h2 id="1-1-什么是双亲委派模型？"><a href="#1-1-什么是双亲委派模型？" class="headerlink" title="1.1 什么是双亲委派模型？"></a>1.1 什么是双亲委派模型？</h2><p>首先，先要知道什么是类加载器。简单说，类加载器就是根据指定全限定名称将<code>class</code>文件加载到<code>JVM</code>内存，转为<code>Class</code>对象。如果站在<code>JVM</code>的角度来看，只存在两种类加载器:</p><blockquote><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录或<code>-Xbootclasspath</code>参数指定的路径中的类库加载到内存中。</li><li>其他类加载器：由<code>Java</code>语言实现，继承自抽象类<code>ClassLoader</code>。如：</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>应用程序类加载器（<code>Application ClassLoader</code>）。负责加载用户类路径（<code>classpath</code>）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul></blockquote><p>双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即<code>ClassNotFoundException</code>），子加载器才会尝试自己去加载。</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-d2f7f6206935de2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>类加载器的双亲委派模型</p><h2 id="1-2-为什么需要双亲委派模型？"><a href="#1-2-为什么需要双亲委派模型？" class="headerlink" title="1.2 为什么需要双亲委派模型？"></a>1.2 为什么需要双亲委派模型？</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个<code>java.lang.String</code>类，该<code>String</code>类具有系统的<code>String</code>类一样的功能，只是在某个函数稍作修改。比如<code>equals</code>函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到<code>JVM</code>中。此时，如果没有双亲委派模型，那么<code>JVM</code>就可能误以为黑客自定义的<code>java.lang.String</code>类是系统的<code>String</code>类，导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在<code>JVM</code>中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。</p><p>举个简单例子：</p><blockquote><p><code>ClassLoader1</code>、<code>ClassLoader2</code>都加载<code>java.lang.String</code>类，对应Class1、Class2对象。那么<code>Class1</code>对象不属于<code>ClassLoad2</code>对象加载的<code>java.lang.String</code>类型。</p></blockquote><h2 id="1-3-如何实现双亲委派模型？"><a href="#1-3-如何实现双亲委派模型？" class="headerlink" title="1.3 如何实现双亲委派模型？"></a>1.3 如何实现双亲委派模型？</h2><p>双亲委派模型的原理很简单，实现也简单。每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。其实<code>ClassLoader</code>类默认的<code>loadClass</code>方法已经帮我们写好了，我们无需去写。</p><h1 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h1><h1 id="2-1几个重要函数"><a href="#2-1几个重要函数" class="headerlink" title="2. 1几个重要函数"></a>2. 1几个重要函数</h1><h3 id="2-1-1-loadClass"><a href="#2-1-1-loadClass" class="headerlink" title="2.1.1 loadClass"></a>2.1.1 loadClass</h3><p><code>loadClass</code>默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看看<code>loadClass(String name, boolean resolve)</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码可以明显看出，<code>loadClass(String, boolean)</code>函数即实现了双亲委派模型！整个大致过程如下：</p><blockquote><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name, false);</code>）.或者是调用<code>bootstrap</code>类加载器来加载。</li><li>如果父加载器及<code>bootstrap</code>类加载器都没有找到指定的类，那么调用当前类加载器的<code>findClass</code>方法来完成类加载。</li></ol></blockquote><p><strong>话句话说，如果自定义类加载器，就必须重写findClass方法！</strong></p><h3 id="2-1-1-find-Class"><a href="#2-1-1-find-Class" class="headerlink" title="2.1.1 find Class"></a>2.1.1 find Class</h3><p><code>findClass</code>的默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，抽象类<code>ClassLoader</code>的<code>findClass</code>函数默认是抛出异常的。而前面我们知道，<code>loadClass</code>在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的<code>findeClass</code>函数，因此我们必须要在<code>loadClass</code>这个函数里面实现将一个指定类名称转换为<code>Class</code>对象.</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为<code>Class</code>对象呢？很简单，<code>Java</code>提供了<code>defineClass</code>方法，通过这个方法，就可以把一个字节数组转为Class对象啦~</p><h3 id="2-1-1-defineClass"><a href="#2-1-1-defineClass" class="headerlink" title="2.1.1 defineClass"></a>2.1.1 defineClass</h3><p><code>defineClass</code>主要的功能是：</p><blockquote><p>将一个字节数组转为<code>Class</code>对象，这个字节数组是<code>class</code>文件读取后最终的字节数组。如，假设<code>class</code>文件是加密过的，则需要解密后作为形参传入<code>defineClass</code>函数。</p></blockquote><p><code>defineClass</code>默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError  &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-函数调用过程"><a href="#2-2-函数调用过程" class="headerlink" title="2.2 函数调用过程"></a>2.2 函数调用过程</h2><p>上一节所提的函数调用过程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-d5859f8e79069128?imageMogr2/auto-orient/strip%7CimageView2/2/w/598" alt="img"></p><p>自定义函数调用过程</p><h2 id="2-3-简单示例"><a href="#2-3-简单示例" class="headerlink" title="2.3 简单示例"></a>2.3 简单示例</h2><p>首先，我们定义一个待加载的普通<code>Java</code>类:<code>Test.java</code>。放在<code>com.huachao.cl</code>包下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.huachao.cl;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;恩，是的，我是由 &quot; + getClass().getClassLoader().getClass()</span><br><span class="line">                + &quot; 加载进来的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>如果你是直接在当前项目里面创建，待<code>Test.java</code>编译后，请把<code>Test.class</code>文件拷贝走，再将<code>Test.java</code>删除。因为如果<code>Test.class</code>存放在当前项目中，根据双亲委派模型可知，会通过<code>sun.misc.Launcher$AppClassLoader</code> 类加载器加载。为了让我们自定义的类加载器加载，我们把Test.class文件放入到其他目录。</p></blockquote><p>在本例中，我们Test.class文件存放的目录如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-fcf13f3f446a60f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/602" alt="img"></p><p>class文件目录</p><p>接下来就是自定义我们的类加载器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">        private String classPath;</span><br><span class="line"></span><br><span class="line">        public MyClassLoader(String classPath) &#123;</span><br><span class="line">            this.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] loadByte(String name) throws Exception &#123;</span><br><span class="line">            name = name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span><br><span class="line">            FileInputStream fis = new FileInputStream(classPath + &quot;/&quot; + name</span><br><span class="line">                    + &quot;.class&quot;);</span><br><span class="line">            int len = fis.available();</span><br><span class="line">            byte[] data = new byte[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            return data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] data = loadByte(name);</span><br><span class="line">                return defineClass(name, data, 0, data.length);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                throw new ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        MyClassLoader classLoader = new MyClassLoader(&quot;D:/test&quot;);</span><br><span class="line">        Class clazz = classLoader.loadClass(&quot;com.huachao.cl.Test&quot;);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method helloMethod = clazz.getDeclaredMethod(&quot;hello&quot;, null);</span><br><span class="line">        helloMethod.invoke(obj, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恩，是的，我是由 class Main$MyClassLoader 加载进来的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 启动时选择项目</title>
      <link href="/2016/09/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E5%90%AF%E5%8A%A8%E6%97%B6%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE/"/>
      <url>/2016/09/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E5%90%AF%E5%8A%A8%E6%97%B6%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="idea-启动时选择项目"><a href="#idea-启动时选择项目" class="headerlink" title="idea 启动时选择项目"></a>idea 启动时选择项目</h2><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>idea，（15.2）启动时，直接进入之前关闭的时的最后一个项目，在加载过程中点取消，才会出现选择项目的界面，想要启动时就进行选择，只要配置下即可，这里做下记录，以免后续忘记</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>File–&gt;Settings （Ctrl + Alt + S） –&gt; Appearance &amp; Behavior –&gt; System Setting</li></ul><p><img src="http://i.imgur.com/5X6FK1m.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful设计规范</title>
      <link href="/2016/09/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20RESTful%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2016/09/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20RESTful%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful设计规范"><a href="#RESTful设计规范" class="headerlink" title="RESTful设计规范"></a>RESTful设计规范</h2><h1 id="一、-摘要（Abstract）"><a href="#一、-摘要（Abstract）" class="headerlink" title="一、 摘要（Abstract）"></a>一、 摘要（Abstract）</h1><p>RESTful API 已经非常成熟，也得到了大家的认可。我们按照 <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> 对 REST 评价的模型，规范基于 level2 来设计</p><h1 id="二、版本（Versioning）"><a href="#二、版本（Versioning）" class="headerlink" title="二、版本（Versioning）"></a>二、版本（Versioning）</h1><p>API的版本号放入URL。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.jiuyescm.com/v1/</span><br><span class="line">https://api.jiuyescm.com/v1.2/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、资源、路径（Endpoint）"><a href="#三、资源、路径（Endpoint）" class="headerlink" title="三、资源、路径（Endpoint）"></a>三、资源、路径（Endpoint）</h1><p>路径，API的具体地址。在REST中，每个地址都代表一个具体的资源（<code>Resource</code>）约定如下：</p><ul><li><p>路径仅表示资源的路径（位置），尽量不要有actions操作（一些特殊的<code>actions</code>操作除外）</p></li><li><p>路径以 复数（名词） 进行命名资源，不管返回单个或者多个资源。</p></li><li><p>使用 小写字母、数字以及下划线（“_”） 。（下划线是为了区分多个单词，如user_name）</p></li><li><p>资源的路径从父到子依次如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&#123;resource&#125;/&#123;resource_id&#125;/&#123;sub_resource&#125;/&#123;sub_resource_id&#125;/&#123;sub_resource_property&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>?</code> 来进行资源的过滤、搜索以及分页等</p></li><li><p>使用版本号，且版本号在资源路径之前</p></li><li><p>优先使用内容协商来区分表述格式，而不是使用后缀来区分表述格式</p></li><li><p>应该放在一个专用的域名下，如：<code>http：//api.jiuyescm.com</code></p></li><li><p>使用SSL</p></li></ul><p>综上，一个API路径可能会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://api.domain.com/v1/&#123;resource&#125;/&#123;resource_id&#125;/&#123;sub_resource&#125;/&#123;sub_resource_id&#125;/&#123;sub_resource_property&#125;</span><br><span class="line">https://api.domain.com /v1/&#123;resource&#125;?page=1&amp;page_size=10</span><br><span class="line">https://api.domain.com /v1/&#123;resource&#125;?name=xx&amp;sortby=name&amp;order=asc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四、操作（HTTP-Actions）"><a href="#四、操作（HTTP-Actions）" class="headerlink" title="四、操作（HTTP Actions）"></a>四、操作（HTTP Actions）</h1><p>用<code>HTTP</code>动词（方法）表示对资源的具体操作。常用的<code>HTTP</code>动词有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）</span><br><span class="line">POST（CREATE）：在服务器新建一个资源</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）  </span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性） </span><br><span class="line">DELETE（DELETE）：从服务器删除资源</span><br><span class="line">还有两个不常用的HTTP动词</span><br><span class="line">HEAD：获取资源的元数据</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一些例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /users：列出所有用户  </span><br><span class="line">POST /users：新建一个用户  </span><br><span class="line">GET /users/&#123;user_id&#125;：获取某个指定用户的信息  </span><br><span class="line">PUT /users/&#123;user_id&#125;：更新某个指定用户的信息（提供该用户的全部信息）  </span><br><span class="line">PATCH /users/&#123;user_id&#125;：更新某个指定用户的信息（提供该用户的部分信息）  </span><br><span class="line">DELETE /users/&#123;user_id&#125;：删除某个用户  </span><br><span class="line">GET /users/&#123;user_id&#125;/resources：列出某个指定用户的所有权限资源  </span><br><span class="line">DELETE /users/&#123;user_id&#125;/resources/&#123;resources_id&#125;：删除某个指定用户的指定权限资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、数据（Data-Format）"><a href="#五、数据（Data-Format）" class="headerlink" title="五、数据（Data Format）"></a>五、数据（Data Format）</h1><p>数据是对资源的具体描述，分为请求数据和返回数据。约定如下：</p><ul><li>查询，过滤条件使用query string，例如user?name&#x3D;xxx</li><li>Content body 仅仅用来传输数据</li><li>通过Content-Type指定请求与返回的数据格式。其中请求数据还要指定Accept。（我们暂时只使用Json）</li><li>数据应该拿来就能用，不应该还要进行转换操作</li><li>使用字符串（YYYY-MM-dd hh:mm:ss）格式表达时间字段，例如: 2017-02-20 16:00:00</li><li>数据采用UTF-8编码</li><li>返回的数据应该尽量简单，响应状态应该包含在响应头中</li><li>使用 小写字母、数字以及下划线（“_”） 描述字段，不使用大写描述字段（这个由于使用了一些开源的jar所以这个不强求，比如说pageinfo我们无法修改属性名称）</li><li>建议资源中的唯一标识命名为id（这个不强求，有的唯一标识名称确实比较复杂）</li><li>属性和字符串值必须使用双引号””（这个json转换默认规则）</li><li>建议对每个字段设置默认值（数组型可设置为[],字符串型可设置为””，数值可设置为0，对象可设置为{}）,这一条是为了方便前端&#x2F;客户端进行判断字段存不存在操作（这样json转换会自动转成相应的字符）</li><li>POST操作应该返回新建的资源；PUT&#x2F;PATCH操作返回更新后的完整的资源；DELETE返回一个空文档；GET返回资源数组或当个资源</li><li>为了方便以后的扩展兼容，如果返回的是数组，强烈建议用一个包含如items属性的对象进行包裹，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;items&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.domain.com/v1/users</span><br><span class="line">Request</span><br><span class="line">    headers:</span><br><span class="line">        Accept: application/json</span><br><span class="line">        Content-Type: application/json;charset=UTF-8</span><br><span class="line">    body:</span><br><span class="line">     &#123;</span><br><span class="line">            &quot;user_name&quot;: &quot;ZhangSan&quot;,</span><br><span class="line">            &quot;address&quot;: &quot;ujfhysdfsdf&quot;,</span><br><span class="line">             &quot;nick&quot;: &quot;ZS&quot;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">Response</span><br><span class="line">    status: 201 Created</span><br><span class="line">    headers:</span><br><span class="line">        Content-Type: application/json;charset=UTF-8</span><br><span class="line">    body:</span><br><span class="line">        &#123;</span><br><span class="line">           &quot;requestId&quot;: sdfsdflkjoiusdf,</span><br><span class="line">           &quot;code&quot;: &quot;&quot;,</span><br><span class="line">            &quot;message&quot;: &quot;&quot;,</span><br><span class="line">            &quot;items&quot;:</span><br><span class="line">                  &#123;</span><br><span class="line">                       &quot;id&quot;:&quot;111&quot;,</span><br><span class="line">                       &quot;user_name&quot;: &quot;HingKwan&quot;,</span><br><span class="line">                       &quot;address&quot;: &quot;ujfhysdfsdf&quot;,</span><br><span class="line">                        &quot;nick&quot;: &quot;ZS&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="六、安全（Security）"><a href="#六、安全（Security）" class="headerlink" title="六、安全（Security）"></a>六、安全（Security）</h1><h2 id="调用限制"><a href="#调用限制" class="headerlink" title="调用限制"></a>调用限制</h2><p>为了避免请求泛滥，给API设置速度限制很重要。入速度设置之后，可以在HTTP返回头上对返回的信息进行说明，下面是几个必须的返回头（依照twitter的命名规则）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X-Rate-Limit-Limit :当前时间段允许的并发请求数</span><br><span class="line">X-Rate-Limit-Remaining:当前时间段保留的请求数</span><br><span class="line">X-Rate-Limit-Reset:当前时间段剩余秒数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个我们一般会在getway中实现</strong></p><h2 id="授权校验"><a href="#授权校验" class="headerlink" title="授权校验"></a>授权校验</h2><p>RESTful API是无状态的也就是说用户请求的鉴权和cookie以及session无关，每一次请求都应该包含鉴权证明。 可以使用http请求头Authorization设置授权码; 必须使用User-Agent设置客户端信息, 无User-Agent请求头的请求应该被拒绝访问。具体的授权可以采用OAuth2，或者自己定义并实现相关的授权验证机制（基于token）。 <strong>这个我们一般会在getway中实现</strong></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>当API返回非2XX的HTTP响应时，应该采用统一的响应信息，格式如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:&quot;INVALID_ARGUMENT&quot;,</span><br><span class="line">    &quot;message&quot;:&quot;&#123;error message&#125;&quot;,</span><br><span class="line">    &quot;request_id&quot;:&quot;sdfsdfo8lkjsdf&quot;,</span><br><span class="line">    &quot;items&quot;:[],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>HTTP Header Code：符合HTTP响应的状态码。详细见以下的“状态码”节</li><li>code：用来表示某类错误不是具体错误，比如缺少参数等。是对HTTP Header Code的补充，开发团队可以根据自己的需要自己定义</li><li>message：错误信息的摘要，应该是对用户处理错误有用的信息</li><li>request_id：请求的id，方便开发定位发生错误的请求（可选）</li><li>code的定义约定：<ul><li>采用 大写字母命名，字母与字母之间用下划线（”_”） 隔开</li><li>code应该用来定义错误类别，而非定义具体的某个错误。</li><li>缺少参数使用：MISSING_X</li><li>无效参数使用：INVALID_X</li><li>逻辑验证错误使用：VALIDATION_X</li><li>不存在使用：NO_FOUND_X</li></ul></li></ul><h1 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h1><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">200 OK - [GET/PUT/PATCH/DELETE]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。  </span><br><span class="line">201 Created - [POST/PUT/PATCH]：用户新建或修改数据成功。  </span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）  </span><br><span class="line">204 No Content - [DELETE]：用户删除数据成功。  </span><br><span class="line">304 Not Modified   - HTTP缓存有效。</span><br><span class="line">400 Invalid Request - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。  </span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。  </span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。  </span><br><span class="line">404 Not Found - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">405 Method Not Allowed - [*]：该http方法不被允许。  </span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。  </span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。  </span><br><span class="line">415 Unsupported Media Type - [*]：请求类型错误。</span><br><span class="line">422 Unprocesable Entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。  </span><br><span class="line">429 Too Many Request - [*]：请求过多。</span><br><span class="line">500 Internal Server Error - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。  </span><br><span class="line">503 Service Unavailable - [*]：服务当前无法处理请求。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="八、异常规范（Exceptions）"><a href="#八、异常规范（Exceptions）" class="headerlink" title="八、异常规范（Exceptions）"></a>八、异常规范（Exceptions）</h1><ul><li>Controller中try catch住service的异常，再转换为restful中需要抛出的异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Long id = userService.save(vo);</span><br><span class="line">    vo.setId(id);</span><br><span class="line">&#125; catch(BizException e) &#123;</span><br><span class="line">    throw new UnprocesableEntityException(ErrorCode.USER_NAME_EXIST.getCode(), ErrorCode.USER_NAME_EXIST.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Controller中抛出的异常必须使用spring-mvc-rest包中的异常类，不允许自定义异常，选择需要返回的httpStatus对应的异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#403 [*]：表示得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.ForbiddenException</span><br><span class="line"></span><br><span class="line">#410 [GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.GoneException</span><br><span class="line"></span><br><span class="line">#400 [POST/PUT/PATCH]：用户发出的请求有错误（常用在请求必要的参数错误上），服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.InvalidRequestException</span><br><span class="line"></span><br><span class="line">#406 [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）或（请求参数需要数字，用户传入字符串）</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.NotAcceptableException</span><br><span class="line"></span><br><span class="line">#404 [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.NotFoundException</span><br><span class="line"></span><br><span class="line">#401 [*]：表示没有权限（令牌、用户名、密码错误，或任何资源没有权限）</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.UnauthorizedException</span><br><span class="line"></span><br><span class="line">#422 [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.UnprocesableEntityException</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>抛出的异常中需要传入异常编码和异常信息，异常编码定义遵循上面 《安全中错误编码规范》</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;MESSING_ID&quot;, &quot;缺少参数：id&quot;</span><br><span class="line">&quot;MESSING_NAME&quot;, &quot;缺少参数：name&quot;</span><br><span class="line">&quot;MESSING_ADDRESS&quot;, &quot;缺少参数：address&quot;</span><br><span class="line">&quot;USER_NAME_EXIST&quot;, &quot;用户名已存在&quot;</span><br><span class="line">&quot;USER_NOT_FOUND&quot;, &quot;用户名不存在&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常用的错误编码、异常、httpStatus对应关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;MESSING_ID&quot;, &quot;缺少参数：id&quot;、InvalidRequestException、400</span><br><span class="line">&quot;MESSING_NAME&quot;, &quot;缺少参数：name&quot;、InvalidRequestException、400</span><br><span class="line">&quot;MESSING_ADDRESS&quot;, &quot;缺少参数：address&quot;、InvalidRequestException、400</span><br><span class="line">&quot;USER_NAME_EXIST&quot;, &quot;用户名已存在&quot;、UnprocesableEntityException、422</span><br><span class="line">&quot;USER_NOT_FOUND&quot;, &quot;用户名不存在&quot;、NotFoundException、404</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="九、示例（Example）"><a href="#九、示例（Example）" class="headerlink" title="九、示例（Example）"></a>九、示例（Example）</h1><p>采用user提供的示例代码</p><h2 id="POST-x2F-users"><a href="#POST-x2F-users" class="headerlink" title="POST &#x2F;users"></a>POST &#x2F;users</h2><p>Resource <code>POST /v1/users</code></p><p>POST Parameters Endpoint requires：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>用户住址</td></tr></tbody></table><p>and accepts a few other parameters listed below.</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;:&quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;:&quot;sdfoiu&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 201 Created</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 27,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Objec</td><td>t 返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 400 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;MESSING_NAME&quot;,</span><br><span class="line">  &quot;message&quot;: “缺少参数：name”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_NAME</td><td>缺少参数：name</td></tr><tr><td>400</td><td>MESSING_ADDRESS</td><td>缺少参数：address</td></tr><tr><td>422</td><td>USER_NAME_EXIST</td><td>用户名已存在</td></tr><tr><td>500</td><td>INTERNAL_SERVER_ERROR</td><td>未知的错误</td></tr></tbody></table><h2 id="DELETE-x2F-users-x2F-user-id"><a href="#DELETE-x2F-users-x2F-user-id" class="headerlink" title="DELETE &#x2F;users&#x2F;{user_id}"></a>DELETE &#x2F;users&#x2F;{user_id}</h2><p>Resource <code>DELETE /v1/users/&#123;user_id&#125;</code></p><p>Path Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr></tbody></table><p>Query Parameters None</p><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl –H ‘Content-Type: application/json’\</span><br><span class="line">-X DELETE \</span><br><span class="line">‘https://api.jiuyescm.com/v1/users/111’ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 204 No Content</p><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>404</td><td>USER_NOT_FOUND</td><td>用户不存在</td></tr></tbody></table><h2 id="PUT-x2F-users"><a href="#PUT-x2F-users" class="headerlink" title="PUT &#x2F;users"></a>PUT &#x2F;users</h2><p>Resource <code>PUT /v1/users</code></p><p>PUT Body Parameters Endpoint requires：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr><tr><td>user_name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>用户住址</td></tr></tbody></table><p>and accepts a few other parameters listed below..</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;user_id&quot;: 12,</span><br><span class="line">    &quot;name&quot;:&quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;:&quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;:&quot;sdfoiu&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 12,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 400 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;MESSING_NAME&quot;,</span><br><span class="line">  &quot;message&quot;: “缺少参数：name”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>400</td><td>MESSING_NAME</td><td>缺少参数：name</td></tr><tr><td>400</td><td>MESSING_ADDRESS</td><td>缺少参数：address</td></tr><tr><td>422</td><td>USER_NAME_EXIST</td><td>用户名已存在</td></tr><tr><td>500</td><td>INTERNAL_SERVER_ERROR</td><td>未知的错误</td></tr></tbody></table><h2 id="GET-x2F-users-x2F-user-id"><a href="#GET-x2F-users-x2F-user-id" class="headerlink" title="GET &#x2F;users&#x2F;{user_id}"></a>GET &#x2F;users&#x2F;{user_id}</h2><p>Resource <code>GET /v1/users/&#123;user_id&#125;</code></p><p>Path Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr></tbody></table><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Curl –H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">&#x27;https://api.jiuyescm.com/v1/users/12&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 12,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>String</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 404 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot; USER_NOT_FOUND&quot;,</span><br><span class="line">  &quot;message&quot;: “用户不存在”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>404</td><td>USER_NOT_FOUND</td><td>用户不存在</td></tr></tbody></table><h2 id="GET-x2F-users"><a href="#GET-x2F-users" class="headerlink" title="GET &#x2F;users"></a>GET &#x2F;users</h2><p>Resource <code>GET /v1/users</code></p><p>Query Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>根据用户名称进行查询</td></tr><tr><td>page</td><td>int</td><td>第几页，不传入默认1</td></tr><tr><td>page_size</td><td>int</td><td>每页返回多少条结果，不传入默认20</td></tr></tbody></table><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Curl –H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">&#x27;https://api.jiuyescm.com/v1/users?name=xxx&amp;page=1&amp;page_size=20&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 Success</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;&quot;,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;pageNum&quot;: 1,</span><br><span class="line">    &quot;pageSize&quot;: 20,</span><br><span class="line">    &quot;size&quot;: 17,</span><br><span class="line">    &quot;startRow&quot;: 1,</span><br><span class="line">    &quot;endRow&quot;: 17,</span><br><span class="line">    &quot;total&quot;: 17,</span><br><span class="line">    &quot;pages&quot;: 1,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 2,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu1&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 3,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu2&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 4,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu3&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 5,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu4&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 6,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu5&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 7,</span><br><span class="line">        &quot;name&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;8888&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 8,</span><br><span class="line">        &quot;name&quot;: &quot;444&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;444&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;444&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 9,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu7&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 12,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu9&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 13,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu10&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 17,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 20,</span><br><span class="line">        &quot;name&quot;: &quot;9999&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 23,</span><br><span class="line">        &quot;name&quot;: &quot;888&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 24,</span><br><span class="line">        &quot;name&quot;: &quot;222&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 25,</span><br><span class="line">        &quot;name&quot;: &quot;222444&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 26,</span><br><span class="line">        &quot;name&quot;: &quot;222444sdf&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 27,</span><br><span class="line">        &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;firstPage&quot;: 1,</span><br><span class="line">    &quot;prePage&quot;: 0,</span><br><span class="line">    &quot;nextPage&quot;: 0,</span><br><span class="line">    &quot;lastPage&quot;: 1,</span><br><span class="line">    &quot;isFirstPage&quot;: true,</span><br><span class="line">    &quot;isLastPage&quot;: true,</span><br><span class="line">    &quot;hasPreviousPage&quot;: false,</span><br><span class="line">    &quot;hasNextPage&quot;: false,</span><br><span class="line">    &quot;navigatePages&quot;: 8,</span><br><span class="line">    &quot;navigatepageNums&quot;: [</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 获得根目录</title>
      <link href="/2016/09/10/java/%20Spring%20%E8%8E%B7%E5%BE%97%E6%A0%B9%E7%9B%AE%E5%BD%95/"/>
      <url>/2016/09/10/java/%20Spring%20%E8%8E%B7%E5%BE%97%E6%A0%B9%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>项目过程中，有时需要在java中获取项目中静态资源，如图片资源的地址，可以通过System.getProperty(“webapp.root”)来动态获取项目的运行路径。</p></blockquote><ul><li><p>web.xml配置</p> <context-param>      <param-name>webAppRootKey</param-name>      <param-value>webapp.root</param-value>  </context-param><pre><code>&lt;!-- 根目录Listener  注意：此配置要配置在--&gt;</code></pre>  <listener>      <listener-class>org.springframework.web.util.WebAppRootListener</listener-class>  </listener>  <!-- Spring监听器 -->  <listener>      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  </listener></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins+Maven+Nexus+SVN+Tomcat+Sonar搭建持续集成环境</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins+Maven+Nexus+SVN+Tomcat+Sonar%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins+Maven+Nexus+SVN+Tomcat+Sonar%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daemon模式启动tomcat</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/daemon%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8tomcat/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/daemon%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="下载tomcat，过程略"><a href="#下载tomcat，过程略" class="headerlink" title="下载tomcat，过程略"></a>下载tomcat，过程略</h2><h2 id="安装Daemon-自启动"><a href="#安装Daemon-自启动" class="headerlink" title="安装Daemon 自启动"></a>安装Daemon 自启动</h2><pre><code>cd /usr/local/apache-tomcat-8.0.32/bintar -zxvf commons-daemon-native.tar.gzcd /usr/local/apache-tomcat-8.0.32/bin/commons-daemon-1.0.15-native-src/unix./configuremakecp jsvc ../..</code></pre><h2 id="新增tomcat用户并赋权限"><a href="#新增tomcat用户并赋权限" class="headerlink" title="新增tomcat用户并赋权限"></a>新增tomcat用户并赋权限</h2><pre><code>useradd -r tomcatchown -R tomcat: /usr/local/apache-tomcat-8.0.32</code></pre><h2 id="编写系统服务-关键"><a href="#编写系统服务-关键" class="headerlink" title="编写系统服务(关键)"></a>编写系统服务(关键)</h2><pre><code>vim /usr/lib/systemd/system/tomcatd.service</code></pre><h2 id="填入内容："><a href="#填入内容：" class="headerlink" title="填入内容："></a>填入内容：</h2><pre><code>Description=Apache Tomcat Web Application ContainerAfter=network.target syslog.target[Service]Type=forkingPIDFile=/var/run/tomcatd.pidEnvironment=CATALINA_PID=/var/run/tomcatd.pidEnvironment=JAVA_HOME=/usr/local/java/jdk1.8.0_74Environment=CATALINA_HOME=/usr/local/apache-tomcat-8.0.32ExecStart=/usr/local/apache-tomcat-8.0.32/bin/daemon.sh startExecStop=/usr/local/apache-tomcat-8.0.32/bin/daemon.sh stop[Install]WantedBy=multi-user.target</code></pre><h2 id="将tomcat加入系统自启动"><a href="#将tomcat加入系统自启动" class="headerlink" title="将tomcat加入系统自启动"></a>将tomcat加入系统自启动</h2><pre><code>systemctl enable tomcatd.service</code></pre><h2 id="测试是否能启动"><a href="#测试是否能启动" class="headerlink" title="测试是否能启动"></a>测试是否能启动</h2><pre><code>ps -aux| grep tomcat</code></pre><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><pre><code>systemctl stop tomcatd.servicesystemctl start tomcatd.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ideas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述nexus私服搭建及在idea中应用</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%AE%80%E8%BF%B0nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9C%A8idea%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%AE%80%E8%BF%B0nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9C%A8idea%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简述nexus私服搭建及在idea中应用"><a href="#简述nexus私服搭建及在idea中应用" class="headerlink" title="简述nexus私服搭建及在idea中应用"></a>简述nexus私服搭建及在idea中应用</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Nexus是一个强大的Maven仓库管理器，它极大地简化了自己内部仓库的维护和外部仓库的访问。利用Nexus你可以只在一个地方就能够完全控制访问 和部署在你所维护仓库中的每个Artifact。Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。Nexus 使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过m2eclipse与Eclipse集成使用。Nexus支持WebDAV与LDAP安全身份认证。</p></blockquote><h2 id="下载安装-Nexus"><a href="#下载安装-Nexus" class="headerlink" title="下载安装 Nexus"></a>下载安装 Nexus</h2><ul><li>下载地址 <a href="http://www.sonatype.org/nexus/">Nexus官网</a></li></ul><p><strong>注意：</strong> 选择NEXUS OSS（开源版本）</p><h2 id="简述配置（win版本）"><a href="#简述配置（win版本）" class="headerlink" title="简述配置（win版本）"></a>简述配置（win版本）</h2><ul><li>将下载好的ZIP包进行解压</li><li>配置环境变量</li><li>启动</li></ul><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p> 访问<a href="http://localhost:8081/nexus/">http://localhost:8081/nexus/</a> 在右上角有个Log in 点击登录</p><ul><li>默认的用户名是 admin 密码是 admin123</li></ul><p> <img src="http://i.imgur.com/J7tH3Sl.png"></p><h2 id="Nexus中的仓库"><a href="#Nexus中的仓库" class="headerlink" title="Nexus中的仓库"></a>Nexus中的仓库</h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h3><blockquote><p>　登陆Nexus，在左边菜单栏里选择Repositories，然后会出现右边的画面，右边上半部分是列出来的repository，黑体字是类型为group的repository。　　　　</p></blockquote><p>简单介绍下几种repository的类型：</p><ul><li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li><li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li><li>group，仓库组，用来合并多个hosted&#x2F;proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li></ul><p><img src="http://i.imgur.com/gKlcHk0.png"></p><h3 id="管理本地仓库"><a href="#管理本地仓库" class="headerlink" title="管理本地仓库"></a>管理本地仓库</h3><p>　　　　</p><blockquote><p>hosted的为本地仓库，Nexus预定义了3个本地仓库，分别是Releases, Snapshots, 3rd Party.</p></blockquote><ul><li><p>Releases:</p><pre><code>  这里存放我们自己项目中发布的构建, 通常是Release版本的, 比如我们自己做了一个FTP Server的项目, 生成的构件为ftpserver.war, 我们就可以把这个构建发布到Nexus的Releases本地仓库. 关于符合发布后面会有介绍.</code></pre></li><li><p>Snapshots:</p><pre><code>  这个仓库非常的有用, 它的目的是让我们可以发布那些非release版本, 非稳定版本, 比如我们在trunk下开发一个项目,在正式release之前你可能需要临时发布一个版本给你的同伴使用, 因为你的同伴正在依赖你的模块开发, 那么这个时候我们就可以发布Snapshot版本到这个仓库, 你的同伴就可以通过简单的命令来获取和使用这个临时版本.</code></pre></li><li><p>3rd Party:</p><pre><code>  顾名思义, 第三方库, 你可能会问不是有中央仓库来管理第三方库嘛,没错, 这里的是指可以让你添加自己的第三方库, 比如有些构件在中央仓库是不存在的. 比如你在中央仓库找不到Oracle 的JDBC驱动, 这个时候我们就需要自己添加到3rdparty仓库。</code></pre></li></ul><blockquote><p>后续再补充一下配置自己的项目</p></blockquote><h2 id="IDEA-在项目中的配置"><a href="#IDEA-在项目中的配置" class="headerlink" title="IDEA 在项目中的配置"></a>IDEA 在项目中的配置</h2><h3 id="配置settings-xml文件"><a href="#配置settings-xml文件" class="headerlink" title="配置settings.xml文件"></a>配置settings.xml文件</h3><p>在 settings.xml 中添加：</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP/域名:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP/域名:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="IDEA-的maven配置"><a href="#IDEA-的maven配置" class="headerlink" title="IDEA 的maven配置"></a>IDEA 的maven配置</h3><p>选择配置好的settings.xml文件</p><p><img src="http://i.imgur.com/4D8JvUR.png"></p><h3 id="发布jar包"><a href="#发布jar包" class="headerlink" title="发布jar包"></a>发布jar包</h3><blockquote><p>  执行deploy按钮就可以将 打好的 jar 包或者 war包上传到 私服中  （install  是将jar包 拷贝到本地仓库）</p></blockquote><blockquote><p>在后续使用过程中，多多总结提高吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CD 持续发布</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CD%20%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CD%20%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI 持续集成</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能测试相关</title>
      <link href="/2016/09/05/%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2016/09/05/%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>#简述</p><blockquote><p>…</p></blockquote><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><blockquote><p>一个系统的的吞吐量（承受压力）与请求对CPU的消耗、外部接口、IO等等紧密关联。<span id="more"></span>  单个请求对CPU消耗越高，外部系统接口、IO影响的速度越慢，系统吞吐能力越低，反之越高。  系统吞吐量几个重要参数： QPS(TPS),并发数，响应时间</p></blockquote><ul><li><p>QPS(TPS) : 每秒钟请求&#x2F;事务 数量</p></li><li><p>并发数： 系统同时处理的请求&#x2F;事务数</p></li><li><p>响应时间： 一般取的是平均响应时间</p></li></ul><p>他们之间的关系：</p><p>QPS(TPS) &#x3D; 并发数&#x2F;平均响应时间</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid 简述</title>
      <link href="/2016/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Druid%20%E7%AE%80%E8%BF%B0/"/>
      <url>/2016/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Druid%20%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h2><blockquote><p>Druid是什么? <span id="more"></span><br>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p></blockquote><ul><li>Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</li></ul><p>同时Druid不仅仅是一个数据库连接池</p><p><strong>它包括三部分：</strong> </p><ul><li>DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 </li><li>DruidDataSource 高效可管理的数据库连接池。 </li><li>SQLParser</li></ul><h2 id="Druid-的主要作用："><a href="#Druid-的主要作用：" class="headerlink" title="Druid 的主要作用："></a>Druid 的主要作用：</h2><ul><li><p>1.替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。</p></li><li><p>2.可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。</p></li><li><p>3.数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。</p></li><li><p>4.SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。</p></li><li><p>5.扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。</p></li></ul><h1 id="druid的项目路径及介绍"><a href="#druid的项目路径及介绍" class="headerlink" title="druid的项目路径及介绍"></a>druid的项目路径及介绍</h1><p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Druid github地址</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sz 与 rz 命令</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20sz%20%E4%B8%8E%20rz%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20sz%20%E4%B8%8E%20rz%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Linux 使用过程中，避免不了 上传，下载这样的操作，在没有FTP 工具时，通过 sz 、rz命令就可以实现上传，下载的需求。<span id="more"></span><br>但多数Linux系统默认未初始该命令，这里简单记录下sz、rz命令的安装与使用。</p></blockquote><h2 id="命令用途"><a href="#命令用途" class="headerlink" title="命令用途"></a>命令用途</h2><blockquote><p>已陈述sz 、rz可以完成上传，下载的这样的操作，具体对应为：</p></blockquote><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sz：（send） 将选定的文件发送（send）到本地机器</span><br><span class="line">rz：（receive）从本地选择文件上传到Linux服务器</span><br></pre></td></tr></table></figure></code></pre><h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><h3 id="1-编译安装"><a href="#1-编译安装" class="headerlink" title="1.编译安装"></a>1.编译安装</h3><p>root 账号登陆后，依次执行以下命令：</p><pre><code>cd /tmpwget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gztar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20./configure &amp;&amp; make &amp;&amp; make install</code></pre><ul><li><p>安装过程默认把lsz和lrz安装到了&#x2F;usr&#x2F;local&#x2F;bin&#x2F;目录下，现在我们并不能直接使用，下面创建软链接，并命名为rz&#x2F;sz：</p><p>  cd &#x2F;usr&#x2F;bin<br>  ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;lrz rz<br>  ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;lsz sz</p></li></ul><h3 id="2-yum安装"><a href="#2-yum安装" class="headerlink" title="2.yum安装"></a>2.yum安装</h3><p>root 账号登陆后执行以下命令：</p><pre><code>yum install -y lrzsz</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>sz将文件发送到本地：</p><pre><code>   # sz filename</code></pre></li><li><p>rz 将本地的文件上传至Linux环境上：</p><pre><code>  # rz</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 跳转到资源管理器的几种方式</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>开发过程有时候会需要跳转到文件所在文件夹（资源管理器）中，之前使用eclipse时，有Open Explorer这样的插件，<span id="more"></span>在文件上右键就可以使用,学习使用idea后，有时候也需要这样的功能，这里整理下我了解到的三种方式~</p></blockquote><h2 id="idea-跳转到资源管理器的方式"><a href="#idea-跳转到资源管理器的方式" class="headerlink" title="idea 跳转到资源管理器的方式"></a>idea 跳转到资源管理器的方式</h2><h3 id="方式一：右键-Show-in-Explorer"><a href="#方式一：右键-Show-in-Explorer" class="headerlink" title="方式一：右键 Show in Explorer"></a>方式一：右键 Show in Explorer</h3><blockquote><ul><li>在project页面右键需要跳转的文件，选择右键菜单中的 <strong>Show in Explorer</strong></li></ul></blockquote><p><img src="http://i.imgur.com/G0dFyNd.png"></p><h3 id="方式二：-在工具栏上添加-Show-in-Explorer-按钮"><a href="#方式二：-在工具栏上添加-Show-in-Explorer-按钮" class="headerlink" title="方式二： 在工具栏上添加  Show in Explorer 按钮"></a>方式二： 在工具栏上添加  Show in Explorer 按钮</h3><blockquote><ul><li>在工具栏的空白处，右键选择 <strong>Customize Menus and Toolbars…</strong></li></ul></blockquote><p><img src="http://i.imgur.com/2Xr2Zbw.png"></p><blockquote><ul><li>在对话框中，展开 <strong>Main Toolbar</strong>  -&gt; <strong>TasksToolbar</strong> -&gt; 右侧的 <strong>Add After</strong></li></ul></blockquote><p><img src="http://i.imgur.com/lJD7sWl.png"></p><blockquote><ul><li>在对话框中，展开 <strong>Other</strong>  -&gt; <strong>Show in Explorer</strong> -&gt; 为其设置一个图标</li></ul></blockquote><ul><li><strong>注意：图标大小（建议<code>18 * 18</code> &#x2F; <code>16 * 16</code>）</strong> 太大了，idea会提示icon太大</li></ul><p><img src="http://i.imgur.com/6FzWD9l.png"></p><blockquote><ul><li>更改图标：添加过后，可以在 <strong>Main Toolbar</strong> 最下面找到<strong>Show in Explorer</strong> 右边菜单选择 <strong>Edit Action Icon</strong> 进行更换图标</li></ul></blockquote><p><img src="http://i.imgur.com/itRWLor.png"></p><blockquote><ul><li>这样比在project里右键文件省事一些~</li></ul></blockquote><h3 id="方式三：-快捷键-，idea强大的快捷键（推荐）"><a href="#方式三：-快捷键-，idea强大的快捷键（推荐）" class="headerlink" title="方式三： 快捷键 ，idea强大的快捷键（推荐）"></a>方式三： 快捷键 ，idea强大的快捷键（推荐）</h3><blockquote><ul><li>直接在当前编辑的文件中，按下快捷键 <strong>Ctrl + Alt + F12</strong> 会列出文件的所在的文件夹及上层目录，回车，跳转吧</li></ul></blockquote><hr><blockquote><p>每一个优秀的人，都不是与生俱来带着光环的，也不一定是比别人幸运。他们只是在任何一件小事上，都对自己有所要求，不因舒适而散漫放纵，不因辛苦而放弃追求。雕塑自己的过程，必定伴随着疼痛与辛苦，可那一锤一凿的自我敲打，终究能让我们收获一个更好的自己。九月来了，新的一天,加油！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS上安装JDK</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E4%B8%8A%E5%AE%89%E8%A3%85JDK/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E4%B8%8A%E5%AE%89%E8%A3%85JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>简单记录下Linux下安装JDK的方法，实际有很多种安装方式，这里只记录下解压缩包的方式，<span id="more"></span>其他如，yum，rpm等方式不再陈述</p></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><blockquote></blockquote><ul><li>CentOS 7.0 64</li><li>jdk-8u74-linux-x64.tar.gz</li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="1-在-x2F-usr-x2F-local-x2F-目录下创建java目录"><a href="#1-在-x2F-usr-x2F-local-x2F-目录下创建java目录" class="headerlink" title="1.在&#x2F;usr&#x2F;local&#x2F;目录下创建java目录"></a>1.在&#x2F;usr&#x2F;local&#x2F;目录下创建java目录</h3><pre><code># mkdir /usr/local/java# cd /usr/local/java</code></pre><h3 id="2-解压tar-gz-文件"><a href="#2-解压tar-gz-文件" class="headerlink" title="2.解压tar.gz 文件"></a>2.解压tar.gz 文件</h3><pre><code># tar -zxvf jdk-8u74-linux-x64.tar.gz</code></pre><h3 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h3><pre><code>#  vi /etc/profile</code></pre><ul><li><p>设置JAVA_HOME环境</p><pre><code>  export JAVA_HOME=/usr/local/java/jdk1.8.0_74  export JRE_HOME=/usr/local/java/jdk1.8.0_74/jre  export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH  export PATH=$JAVA_HOME/bin:$PATH</code></pre></li></ul><h3 id="4-引用文件，生效"><a href="#4-引用文件，生效" class="headerlink" title="4.引用文件，生效"></a>4.引用文件，生效</h3><pre><code># source /etc/profile</code></pre><h3 id="5-验证配置"><a href="#5-验证配置" class="headerlink" title="5.验证配置"></a>5.验证配置</h3><pre><code># java -versionjava version &quot;1.8.0_74&quot;Java(TM) SE Runtime Environment (build 1.8.0_74-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 排序</title>
      <link href="/2016/08/30/java/%20JAVA%20%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/30/java/%20JAVA%20%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Date 函数</title>
      <link href="/2016/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20Date%20%E5%87%BD%E6%95%B0/"/>
      <url>/2016/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20Date%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-Date-函数"><a href="#Mysql-Date-函数" class="headerlink" title="Mysql Date 函数"></a>Mysql Date 函数</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>工作中，经常会遇到日期处理相关业务场景，这里整理下mysql常用的时间相关函数，加深记忆，也方便之后查找<span id="more"></span></p></blockquote><h2 id="MySQL-Date-函数"><a href="#MySQL-Date-函数" class="headerlink" title="MySQL Date 函数"></a>MySQL Date 函数</h2><ul><li>MySQL 中几个重要的日期函数：</li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="#now">NOW()</a></td><td>返回当前的日期和时间</td></tr><tr><td><a href="#CURDATE">CURDATE()</a></td><td>返回当前的日期</td></tr><tr><td><a href="#CURTIME">CURTIME()</a></td><td>返回当前的时间</td></tr><tr><td><a href="#DATE">DATE()</a></td><td>提取日期或日期&#x2F;时间表达式的日期部分</td></tr><tr><td><a href="#EXTRACT">EXTRACT()</a></td><td>返回日期&#x2F;时间按的单独部分</td></tr><tr><td><a href="#DATE_ADD">DATE_ADD()</a></td><td>给日期添加指定的时间间隔</td></tr><tr><td><a href="#DATE_SUB">DATE_SUB()</a></td><td>从日期减去指定的时间间隔</td></tr><tr><td><a href="#DATEDIFF">DATEDIFF()</a></td><td>返回两个日期之间的天数</td></tr><tr><td><a href="#DATE_FORMAT">DATE_FORMAT()</a></td><td>用不同的格式显示日期&#x2F;时间</td></tr></tbody></table><h3 id="SQL-Date-数据类型"><a href="#SQL-Date-数据类型" class="headerlink" title="SQL Date 数据类型"></a>SQL Date 数据类型</h3><p>MySQL 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值</p><ul><li>DATE - 格式 YYYY-MM-DD</li><li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li><li>YEAR - 格式 YYYY 或 YY</li></ul><h2 id="date-函数用法"><a href="#date-函数用法" class="headerlink" title="date 函数用法"></a>date 函数用法</h2><h3 id="MySQL-NOW-函数"><a href="#MySQL-NOW-函数" class="headerlink" title="MySQL NOW() 函数"></a><span id="now">MySQL NOW() 函数</span></h3><hr><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>NOW() 函数返回当前的日期和时间。</li></ul><p><strong>语法</strong></p><pre><code>NOW()</code></pre><p><strong>举例</strong></p><pre><code>SELECT NOW(),CURDATE(),CURTIME();</code></pre><p>结果</p><table><thead><tr><th>NOW()</th><th>CURDATE()</th><th>CURTIME()</th></tr></thead><tbody><tr><td>2016-08-25 12:29:23</td><td>2016-08-25</td><td>12:29:23</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使Guava的插件实现equals, hashCode 和 toString方法（idea）</title>
      <link href="/2016/08/23/java/%E4%BD%BFGuava%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0equals,%20hashCode%20%E5%92%8C%20toString%E6%96%B9%E6%B3%95%EF%BC%88idea%EF%BC%89/"/>
      <url>/2016/08/23/java/%E4%BD%BFGuava%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0equals,%20hashCode%20%E5%92%8C%20toString%E6%96%B9%E6%B3%95%EF%BC%88idea%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><blockquote><p>POJO 类需要编写equals, hashCode 和 toString方法，通常只需要一个模板就能完成，目前我们已经可以让IDE使用插件来帮我们完成这些工作。但是<span id="more"></span>通常由IDE自动生成的这些代码都非常难看：</p></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddrInfo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1900570942803605101L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户uid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 市</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细地址( 领地一 / 领地二 )</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String addrDetail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// getters, setters if needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="通常做法"><a href="#通常做法" class="headerlink" title="通常做法"></a>通常做法</h1><p>目前的主流IDE都能够生成符合需求的方法的代码，但是生成的equals、hashCode和toString方法代码通常看起来就像下面这样：</p><ol><li><p><strong>equals</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserAddrInfo</span> <span class="variable">that</span> <span class="operator">=</span> (UserAddrInfo) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="literal">null</span> ? !uid.equals(that.uid) : that.uid != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (province != <span class="literal">null</span> ? !province.equals(that.province) : that.province != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (city != <span class="literal">null</span> ? !city.equals(that.city) : that.city != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (area != <span class="literal">null</span> ? !area.equals(that.area) : that.area != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> addrDetail != <span class="literal">null</span> ? addrDetail.equals(that.addrDetail) : that.addrDetail == <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>hashCode</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> uid != <span class="literal">null</span> ? uid.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + (province != <span class="literal">null</span> ? province.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (city != <span class="literal">null</span> ? city.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (area != <span class="literal">null</span> ? area.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (addrDetail != <span class="literal">null</span> ? addrDetail.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>toString</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserAddrInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uid=&quot;</span> + uid +</span><br><span class="line">                <span class="string">&quot;, province=&#x27;&quot;</span> + province + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, city=&#x27;&quot;</span> + city + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, area=&#x27;&quot;</span> + area + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, addrDetail=&#x27;&quot;</span> + addrDetail + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="使用Guava库来解决"><a href="#使用Guava库来解决" class="headerlink" title="使用Guava库来解决"></a>使用Guava库来解决</h1><p>Google Guava是一个提供了很多非常使用Java工具的精巧的库。我们可以使用Google Guava来重写上面的三个方法来使得代码显得更好看：</p><ol><li><p><strong>equals</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">UserAddrInfo</span> <span class="variable">that</span> <span class="operator">=</span> (UserAddrInfo) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equal(uid, that.uid) &amp;&amp;</span><br><span class="line">            Objects.equal(province, that.province) &amp;&amp;</span><br><span class="line">            Objects.equal(city, that.city) &amp;&amp;</span><br><span class="line">            Objects.equal(area, that.area) &amp;&amp;</span><br><span class="line">            Objects.equal(addrDetail, that.addrDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>hashCode – 只需要一行</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(uid, province, city, area, addrDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>toString</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.toStringHelper(<span class="built_in">this</span>)</span><br><span class="line">            .add(<span class="string">&quot;uid&quot;</span>, uid)</span><br><span class="line">            .add(<span class="string">&quot;province&quot;</span>, province)</span><br><span class="line">            .add(<span class="string">&quot;city&quot;</span>, city)</span><br><span class="line">            .add(<span class="string">&quot;area&quot;</span>, area)</span><br><span class="line">            .add(<span class="string">&quot;addrDetail&quot;</span>, addrDetail)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="安装Intellij-IDEA插件"><a href="#安装Intellij-IDEA插件" class="headerlink" title="安装Intellij IDEA插件"></a>安装Intellij IDEA插件</h1><p>使用idea不久，边已经非常喜欢这款智能，友善的帮手了，下面总结下使用idea安装guava equals，hashCode，和 toString 自动生成代码的插件</p><ol><li><p><strong>可以插件搜索页面查询 equals 边可以找到该插件，下载安装即可</strong><br><img src="http://i.imgur.com/GXPBFOa.png"></p></li><li><p><strong>打开一个POJO ，键入 ALT + INS 就可以为POJO 生成equals 和 hashCode，toString</strong></p></li></ol><p><img src="http://i.imgur.com/cTrrw7z.png"></p><p>3.<strong>模板 选择guava</strong></p><p><img src="http://i.imgur.com/vlVfrAs.png"></p><p>设置完成，以后只要在POJO 类中，键入 <strong>ALT + INS</strong> 就可以自动生成guava风格的equals，hashCode，toString 方法了</p><p>guava 库优雅高效，要准备花时间掌握下了~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中按照in中的条件进行排序</title>
      <link href="/2016/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-1/"/>
      <url>/2016/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-1/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>实现一个排序的场景，需要按照list的id顺序进行排序，并管理到id对应的 用户信息<span id="more"></span></p></blockquote><blockquote><p>因为使用了sql 的in 方法，默认的排序是按照id的大小进行排序，经过百度，及尝试已经实现</p></blockquote><h3 id="order-by-field-u-uid-id1-id2-id3-指定的字段顺序排序"><a href="#order-by-field-u-uid-id1-id2-id3-指定的字段顺序排序" class="headerlink" title="order by field(u.uid,id1,id2,id3) 指定的字段顺序排序"></a>order by field(u.uid,id1,id2,id3) 指定的字段顺序排序</h3><ul><li><p>样例sql：</p><p>  SELECT</p><ul><li>  FROM<br>  tmp_a u<br>  LEFT JOIN tmp_b ui ON u.uid &#x3D; ui.uid<br>  WHERE<br>  u.id IN (<br>  1017117800,<br>  1081555602,<br>  1081360502<br>  )<br>  ORDER BY<br>  field(<br>  u.id,<br>  1017117800,<br>  1081555602,<br>  1081360502<br>  )</li></ul></li></ul><p>在此标记一下~ </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP相关总结</title>
      <link href="/2016/08/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2016/08/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="CAP理论概述"><a href="#CAP理论概述" class="headerlink" title="CAP理论概述"></a>CAP理论概述</h2><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/cap.jpg"><img src="http://www.hollischuang.com/wp-content/uploads/2015/12/cap.jpg" alt="cap"></a></p><h2 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h2><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>一致性指“<code>all nodes see the same data at the same time</code>”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<a href="http://www.hollischuang.com/archives/663">分布式的一致性</a></p><p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p><p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p><h3 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h3><p>可用性指“<code>Reads and writes always succeed</code>”，即服务一直可用，而且是正常响应时间。</p><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p><h3 id="Partition-Tolerance分区容错性"><a href="#Partition-Tolerance分区容错性" class="headerlink" title="Partition Tolerance分区容错性"></a>Partition Tolerance分区容错性</h3><p>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><h2 id="CAP的证明"><a href="#CAP的证明" class="headerlink" title="CAP的证明"></a>CAP的证明</h2><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/intro_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/intro_thumb.png" alt="intro_thumb"></a></p><p>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p>在满足一致性的时候，N1和N2中的数据是一样的，V0&#x3D;V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario1_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario1_thumb.png" alt="scenario1_thumb"></a></p><p>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p><p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario2_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario2_thumb.png" alt="scenario2_thumb"></a></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据V0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h2 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h2><p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><blockquote><p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p><p>CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p></blockquote><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p><p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p><h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p><p>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p><h2 id="基本可用（Basically-Available）"><a href="#基本可用（Basically-Available）" class="headerlink" title="基本可用（Basically Available）"></a>基本可用（Basically Available）</h2><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p><p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p><h2 id="软状态（-Soft-State）"><a href="#软状态（-Soft-State）" class="headerlink" title="软状态（ Soft State）"></a>软状态（ Soft State）</h2><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p><h2 id="最终一致性（-Eventual-Consistency）"><a href="#最终一致性（-Eventual-Consistency）" class="headerlink" title="最终一致性（ Eventual Consistency）"></a>最终一致性（ Eventual Consistency）</h2><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><h1 id="ACID和BASE的区别与联系"><a href="#ACID和BASE的区别与联系" class="headerlink" title="ACID和BASE的区别与联系"></a>ACID和BASE的区别与联系</h1><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p><p>ACID和BASE代表了两种截然相反的设计哲学</p><p>在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中按照in中的条件进行排序</title>
      <link href="/2016/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>今天在整合定时任务时，想要把所有的定时任务的执行时间放到配置文件properties文件中，方便管理及修改</p></blockquote><pre><code>    在spring mvc中，在配置文件中的东西，可以在java代码中通过注解进行读取了：</code></pre><ul><li>@PropertySource  在spring 3.1中开始引入</li></ul><h4 id="新建一个jobs-properties-文件"><a href="#新建一个jobs-properties-文件" class="headerlink" title="新建一个jobs.properties 文件"></a>新建一个jobs.properties 文件</h4><p><img src="http://i.imgur.com/tvc9ry9.png"> </p><h4 id="代码中添加-PropertySource"><a href="#代码中添加-PropertySource" class="headerlink" title="代码中添加 @PropertySource"></a>代码中添加 @PropertySource</h4><p><img src="http://i.imgur.com/XCMhVz1.png"></p><ul><li><p>要注意的是，要使用 </p><pre><code>  @Bean   public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() &#123;   return new PropertySourcesPlaceholderConfigurer();   &#125;</code></pre></li></ul><p>才能让spring正确解析出${} 中的值;</p><p>在spring 3.2中，允许支持多个properties了</p><pre><code>@Configuration      @PropertySource(&#123;          &quot;classpath:config.properties&quot;,          &quot;classpath:db.properties&quot; //如果是相同的key，则最后一个起作用      &#125;)      public class AppConfig &#123;          @Autowired          Environment env;      &#125;  </code></pre><p>spring 4.1中，支持@PropertySources</p><pre><code>@Configuration  @PropertySources(&#123;      @PropertySource(&quot;classpath:config.properties&quot;),      @PropertySource(&quot;classpath:db.properties&quot;)  &#125;)  public class AppConfig &#123;      //...  &#125; </code></pre><p>在spring 4.2中，</p><pre><code>&lt;/pre&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;@Configuration  @PropertySource(&quot;classpath:missing.properties&quot;)  public class AppConfig &#123;      //...  &#125;  </code></pre><p>如果发现missing.properties不存在，则抛出异常<br>，也可以使用ignoreResourceNotFound&#x3D;true去忽略 </p><pre><code>view plain copy 在CODE上查看代码片派生到我的代码片    @Configuration       @PropertySource(value=&quot;classpath:missing.properties&quot;, ignoreResourceNotFound=true)       public class AppConfig &#123;       //...       &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命名、设计及使用规范</title>
      <link href="/2016/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%E5%91%BD%E5%90%8D%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2016/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%E5%91%BD%E5%90%8D%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>最近对MySQL相关的规范，进行了整理<span id="more"></span></p></blockquote><h3 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h3><ul><li>dev：开发环境，开发可读写，可修改表结构。开发人员可以修改表结构，可以随意修改其中的数据但是需要保证不影响其他开发同事。</li><li>qa：测试环境，开发可读写，开发人员可以通过工具修改表结构。</li><li>sim：模拟环境，开发可读写，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用。</li><li>real：生产数据库从库（准实时同步），只读环境，不允许修改数据，不允许修改表结构，供线上问题查找，数据查询等使用。</li><li>online：线上环境，开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找DBA进行操作并进行相应记录，禁止进行压力测试。</li></ul><p>这些环境的机器，一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_account，r_ account 分别代表读、写账号，account是读写账号。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><h4 id="基本命名原则"><a href="#基本命名原则" class="headerlink" title="基本命名原则"></a>基本命名原则</h4><ul><li>使用有意义的英文词汇，词汇中间以下划线分隔。（不要用拼音）</li><li>只能使用英文字母，数字，下划线，并以英文字母开头。</li><li>库、表、字段全部采用小写，不要使用驼峰式命名。</li><li>避免用ORACLE、MySQL的保留字，如desc，关键字如index。</li><li>命名禁止超过32个字符，须见名之意，建议使用名词不是动词</li><li>数据库，数据表一律使用前缀:<ul><li>临时库、表名必须以tmp为前缀，并以日期为后缀</li><li>备份库、表必须以bak为前缀，并以日期为后缀</li></ul></li></ul><p>为什么库、表、字段全部采用小写？</p><p>在 MySQL 中，数据库和表对就于那些目录下的目录和文件。因而，操作系统的敏感性决定数据库和表命名的大小写敏感。</p><ul><li>Windows下是不区分大小写的。</li><li>Linux下大小写规则：<ul><li>数据库名与表名是严格区分大小写的；</li><li>表的别名是严格区分大小写的；</li><li>列名与列的别名在所有的情况下均是忽略大小写的；</li><li>变量名也是严格区分大小写的；</li></ul></li></ul><p>如果已经设置了驼峰式的命名如何解决？需要在MySQL的配置文件my.ini中增加 lower_case_table_names &#x3D; 1即可。</p><ul><li>表命名</li></ul><p>同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。所有日志表均以 log_ 开头</p><h4 id="字段命名"><a href="#字段命名" class="headerlink" title="字段命名"></a>字段命名</h4><ul><li>表达其实际含义的英文单词或简写。布尔意义的字段以“is_”作为前缀，后接动词过去分词。</li><li>各表之间相同意义的字段应同名。各表之间相同意义的字段，以去掉模块前缀的表名_字段名命名。</li><li>外键字段用表名_字段名表示其关联关系。</li><li>表的主键一般都约定成为id，自增类型，是别的表的外键均使用xxx_id的方式来表明。</li></ul><h4 id="索引命名"><a href="#索引命名" class="headerlink" title="索引命名"></a>索引命名</h4><ul><li>非唯一索引必须按照“idx_字段名称_字段名称[_字段名]”进行命名</li><li>唯一索引必须按照“uniq_字段名称_字段名称[_字段名]”进行命名</li></ul><h4 id="约束命名"><a href="#约束命名" class="headerlink" title="约束命名"></a>约束命名</h4><ul><li>主键约束：pk_表名称。</li><li>唯一约束：uk_表名称_字段名。（应用中需要同时有唯一性检查逻辑。）</li></ul><h4 id="触发器命名"><a href="#触发器命名" class="headerlink" title="触发器命名"></a>触发器命名</h4><ul><li>trg_表名_操作。</li></ul><h4 id="函数过程命名"><a href="#函数过程命名" class="headerlink" title="函数过程命名"></a>函数过程命名</h4><ul><li>采用动词+名词的形式表达其含义。</li></ul><h4 id="序列命名"><a href="#序列命名" class="headerlink" title="序列命名"></a>序列命名</h4><ul><li>seq_表名</li></ul><h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><p>1、表引擎取决于实际应用场景；日志及报表类表建议用myisam，与交易，审核，金额相关的表建议用innodb引擎。如无说明，建表时一律采用innodb引擎。myisam与innodb的区别</p><p>2、默认使用utf8mb4字符集，数据库排序规则使用utf8mb4_general_ci，（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上）。</p><p>为什么字符集不选择utf8，排序规则不使用utf8_general_ci？<br>采用utf8编码的MySQL无法保存占位是4个字节的Emoji表情。为了使后端的项目，全面支持客户端输入的Emoji表情，升级编码为utf8mb4是最佳解决方案。对于JDBC连接串设置了characterEncoding为utf8或者做了上述配置仍旧无法正常插入emoji数据的情况，需要在代码中指定连接的字符集为utf8mb4。</p><p>3、所有表、字段均应用 comment 列属性来描述此表、字段所代表的真正含义，如枚举值则建议将该字段中使用的内容都定义出来。</p><p>4、如无说明，表中的第一个id字段一定是主键且为自动增长，禁止在非事务内作为上下文作为条件进行数据传递。禁止使用varchar类型作为主键语句设计。</p><p>5、如无说明，表必须包含create_time和modify_time字段，即表必须包含记录创建时间和修改时间的字段</p><p>6、如无说明，表必须包含is_del，用来标示数据是否被删除，原则上数据库数据不允许物理删除。</p><p>7、用尽量少的存储空间来存数一个字段的数据</p><ul><li>能用int的就不用char或者varchar</li><li>能用tinyint的就不用int</li><li>使用UNSIGNED存储非负数值。</li><li>不建议使用ENUM、SET类型，使用TINYINT来代替</li><li>使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED</li><li>存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE</li><li>时间字段，除特殊情况一律采用int来记录unix_timestamp</li><li>存储年使用YEAR类型。</li><li>存储日期使用DATE类型。</li><li>存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。</li><li>建议使用INT UNSIGNED存储IPV4。</li><li>尽可能不使用TEXT、BLOB类型</li><li>禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。建议使用其他方式存储（TFS&#x2F;SFS），MySQL只保存指针信息。</li><li>单条记录大小禁止超过8k（列长度(中文)*3(UTF8)+列长度(英文)*1）</li></ul><h4 id="datetime与timestamp有什么不同？"><a href="#datetime与timestamp有什么不同？" class="headerlink" title="datetime与timestamp有什么不同？"></a>datetime与timestamp有什么不同？</h4><p>相同点：TIMESTAMP列的显示格式与DATETIME列相同。显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。<br>不同点：</p><ul><li><p>TIMESTAMP</p></li><li><p>4个字节储存，时间范围：1970-01-01 08:00:01 ~ 2038-01-19 11:14:07</p></li><li><p>值以UTC格式保存，涉及时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。</p></li><li><p>datetime  </p></li><li><p>8个字节储存，时间范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p></li><li><p>实际格式储存，与时区无关</p></li></ul><h4 id="如何使用TIMESTAMP的自动赋值属性？"><a href="#如何使用TIMESTAMP的自动赋值属性？" class="headerlink" title="如何使用TIMESTAMP的自动赋值属性？"></a>如何使用TIMESTAMP的自动赋值属性？</h4><ul><li>将当前时间作为ts的默认值：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP。</li><li>当行更新时，更新ts的值：ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP。</li><li>可以将1和2结合起来：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。</li></ul><h4 id="如何使用INT-UNSIGNED存储ip？"><a href="#如何使用INT-UNSIGNED存储ip？" class="headerlink" title="如何使用INT UNSIGNED存储ip？"></a>如何使用INT UNSIGNED存储ip？</h4><p>使用INT UNSIGNED而不是char(15)来存储ipv4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。</p><p>8、如无备注，所有字段都设置NOT NULL，并设置默认值；</p><p>9、禁止在数据库中存储明文密码</p><p>10、如无备注，所有的布尔值字段，如is_hot、is_deleted，都必须设置一个默<br>认值，并设为0；</p><p>11、如无备注，排序字段order_id在程序中默认使用降序排列；</p><p>12、整形定义中不添加长度，比如使用INT，而不是INT[4]</p><h4 id="INT-M-，M值代表什么含义？"><a href="#INT-M-，M值代表什么含义？" class="headerlink" title="INT[M]，M值代表什么含义？"></a>INT[M]，M值代表什么含义？</h4><p>注意数值类型括号后面的数字只是表示宽度而跟存储范围没有关系。很多人他们认为INT(4)和INT(10)其取值范围分别是 (-9999到9999)和(-9999999999到9999999999)，这种理解是错误的。其实对整型中的 M值与 ZEROFILL 属性结合使用时可以实现列值等宽。不管INT[M]中M值是多少，其取值范围还是 (-2147483648到2147483647 有符号时)，(0到4294967295无符号时)。<br>显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。当结合可选扩展属性ZEROFILL使用时默认补充的空格用零代替。例如：对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度，如果为一个数值列指定ZEROFILL, MySQL自动为该列添加UNSIGNED属性。</p><p>13、使用VARBINARY存储大小写敏感的变长字符串</p><h4 id="什么时候用CHAR，什么时候用VARCHAR？"><a href="#什么时候用CHAR，什么时候用VARCHAR？" class="headerlink" title="什么时候用CHAR，什么时候用VARCHAR？"></a>什么时候用CHAR，什么时候用VARCHAR？</h4><p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR- (30)可以占用30个字符。</p><ul><li>CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索<br>过程中不进行大小写转换。</li><li>VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。</li></ul><p>同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。</p><p>char适合存储用户密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar,因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。char(1)字符串对于单字节字符集只会占用一个字节，但是varchar(1)则会占用2个字节，因为1个字节用来存储长度信息。</p><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><p>MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。MySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。索引的用途：去重、加速定位、避免排序、覆盖索引。</p><h4 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h4><p>InnoDB存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。比如SELECT email,uid FROM user_email WHERE uid&#x3D;xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升。</p><h4 id="索引的基本规范"><a href="#索引的基本规范" class="headerlink" title="索引的基本规范"></a>索引的基本规范</h4><p>1、索引数量控制，单张表中索引数量不超过5个，单个索引中的字段数不超过5个。</p><ul><li>综合评估数据密度和分布</li><li>考虑查询和更新比例</li></ul><h4 id="为什么一张表中不能存在过多的索引？"><a href="#为什么一张表中不能存在过多的索引？" class="headerlink" title="为什么一张表中不能存在过多的索引？"></a>为什么一张表中不能存在过多的索引？</h4><p>InnoDB的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。</p><p>2、对字符串使用前缀索引，前缀索引长度不超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引。</p><ul><li>不要索引blob&#x2F;text等字段,不要索引大型字段,这样做会让索引占用太多的存储空间</li></ul><h4 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h4><p>前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。</p><p>建立前缀索引的语法：ALTER TABLE table_name ADD KEY(column_name(prefix_length));</p><p>3、主键准则</p><ul><li>表必须有主键</li><li>不使用更新频繁的列</li><li>尽量不选择字符串列</li><li>不使用UUID MD5 HASH</li><li>默认使用非空的唯一键</li><li>建议选择自增或发号器</li></ul><p>4、 重要的SQL必须被索引，核心SQL优先考虑覆盖索索引</p><ul><li>UPDATE、DELETE语句的WHERE条件列</li><li>ORDER BY、GROUP BY、DISTINCT的字段</li><li>多表JOIN的字段</li></ul><p>5、区分度最大的字段放在前面</p><ul><li>选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面</li><li>索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引,(a,c)作为条件的时候只能使用到a列索引,所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理,(b,c)则不能走索引</li><li>合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)</li></ul><p>6、索引禁忌</p><ul><li>不在低基数列上建立索引，例如“性别”</li><li>不在索引列进行数学运算和函数运算</li><li>不要索引常用的小型表</li></ul><p>7、 尽量不使用外键</p><ul><li>外键用来保护参照完整性，可在业务端实现</li><li>对父表和子表的操作会相互影响，降低可用性</li><li>INNODB本身对online DDL的限制</li></ul><h4 id="MYSQL-中索引的限制"><a href="#MYSQL-中索引的限制" class="headerlink" title="MYSQL 中索引的限制"></a>MYSQL 中索引的限制</h4><ul><li>MYISAM 存储引擎索引长度的总和不能超过 1000 字节</li><li>BLOB 和 TEXT 类型的列只能创建前缀索引</li><li>MYSQL 目前不支持函数索引</li><li>使用不等于 (!&#x3D; 或者 &lt;&gt;) 的时候, MYSQL 无法使用索引。</li><li>过滤字段使用函数运算 (如 abs (column)) 后, MYSQL无法使用索引。</li><li>join语句中join条件字段类型不一致的时候MYSQL无法使用索引</li><li>使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引。</li><li>使用非等值查询的时候, MYSQL 无法使用 Hash 索引。</li></ul><h4 id="语句设计规范"><a href="#语句设计规范" class="headerlink" title="语句设计规范"></a>语句设计规范</h4><p>1、使用预编译语句</p><ul><li>只传参数，比传递SQL语句更高效</li><li>一次解析，多次使用</li><li>降低SQL注入概率</li></ul><p>2、避免隐式转换</p><ul><li>会导致索引失效</li></ul><p>3、充分利用前缀索引</p><ul><li>必须是最左前缀</li><li>不可能同时用到两个范围条件</li><li>不使用%前导的查询，如like “%ab”</li></ul><p>4、不使用负向查询，如not in&#x2F;like</p><ul><li>无法使用索引，导致全表扫描</li><li>全表扫描导致buffer pool利用率降低</li></ul><p>5、避免使用存储过程、触发器、UDF、events等</p><ul><li>让数据库做最擅长的事</li><li>降低业务耦合度，为sacle out、sharding留有余地</li><li>避开BUG</li></ul><p>6、避免使用大表的JOIN</p><ul><li>MySQL最擅长的是单表的主键&#x2F;二级索引查询</li><li>JOIN消耗较多内存，产生临时表</li></ul><p>7、避免在数据库中进行数学运算</p><ul><li>MySQL不擅长数学运算和逻辑判断</li><li>无法使用索引</li></ul><p>8、减少与数据库的交互次数</p><ul><li>INSERT … ON DUPLICATE KEY UPDATE</li><li>REPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),()</li><li>UPDATE … WHERE ID IN(10,20,50,…)</li></ul><p>9、合理的使用分页</p><ul><li>限制分页展示的页数</li><li>只能点击上一页、下一页</li><li>采用延迟关联</li></ul><h4 id="如何正确的使用分页？"><a href="#如何正确的使用分页？" class="headerlink" title="如何正确的使用分页？"></a>如何正确的使用分页？</h4><p>假如有类似下面分页语句：SELECT * FROM table  ORDER BY id LIMIT 10000, 10<br>由于MySQL里对LIMIT OFFSET的处理方式是取出OFFSET+LIMIT的所有数据，然后去掉OFFSET，返回底部的LIMIT。所以，在OFFSET数值较大时，MySQL的查询性能会非常低。可以使用id &gt; n 的方式进行解决：<br>使用id &gt; n 的方式有局限性，对于id不连续的问题，可以通过翻页的时候同时传入最后一个id方式来解决。</p><pre><code>    //输出时，找出当前结果集中的最大最小id       //下一页       http://example.com/page.php?last=100       select * from table where id&lt;100 order by id desc limit 10       //上一页       http://example.com/page.php?first=110       select * from table where id&gt;110 order by id desc limit 10</code></pre><p>这种方式比较大的缺点是，如果在浏览中有插入&#x2F;删除操作，翻页不会更新，而总页数可能仍然是根据新的count(*) 来计算，最终可能会产生某些记录访问不到。为了修补这个问题，可以继续引入当前页码以及在上次翻页以后是否有插入&#x2F;删除等影响总记录数的操作并进行缓存</p><pre><code>    select * from table where id &gt;= (select id from table order by id limit #offset#, 1)</code></pre><p>9、拒绝大SQL，拆分成小SQL</p><ul><li>充分利用QUERY CACHE</li><li>充分利用多核CPU</li></ul><p>10、使用in代替or，in的值不超过1000个</p><p>11、禁止使用order by rand()</p><p>12、使用EXPLAIN诊断，避免生成临时表</p><p>EXPLAIN语句（在MySQL客户端中执行）可以获得MySQL如何执行SELECT语句的信息。通过对SELECT语句执行EXPLAIN，可以知晓MySQL执行该SELECT语句时是否使用了索引、全表扫描、临时表、排序等信息。尽量避免MySQL进行全表扫描、使用临时表、排序等。详见官方文档。</p><p>13、用union all而不是union</p><h4 id="union-all与-union有什么区别？"><a href="#union-all与-union有什么区别？" class="headerlink" title="union all与 union有什么区别？"></a>union all与 union有什么区别？</h4><p>union和union all关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。</p><p>union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。如：</p><pre><code>    select * from test_union1        union        select * from test_union2</code></pre><p>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而union all只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。<br>从效率上说，union all要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用union all，如下：</p><pre><code>    select * from test_union1        union all        select * from test_union2</code></pre><p>14、程序应有捕获SQL异常的处理机制</p><p>15、禁止单条SQL语句同时更新多个表</p><p>16、不使用select * ，SELECT语句只获取需要的字段</p><p>消耗CPU和IO、消耗网络带宽<br>无法使用覆盖索引<br>减少表结构变更带来的影响<br>因为大，select&#x2F;join 可能生成临时表</p><p>17、UPDATE、DELETE语句不使用LIMIT</p><p>18、INSERT语句必须显式的指明字段名称，不使用INSERT INTO table()</p><p>19、INSERT语句使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不超过500</p><p>20、统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1) 备注：仅针对Myisam</p><p>21、数据更新建议使用二级索引先查询出主键，再根据主键进行数据更新</p><p>22、禁止使用跨库查询</p><p>23、禁止使用子查询，建议将子查询转换成关联查询</p><p>24、针对varchar类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p><h3 id="分表规范"><a href="#分表规范" class="headerlink" title="分表规范"></a>分表规范</h3><p>单表一到两年内数据量超过500w或数据容量超过10G考虑分表，需提前考虑历史数据迁移或应用自行删除历史数据，采用等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略</p><p>用HASH进行散表，表名后缀使用十进制数，下标从0开始<br>按日期时间分表需符合YYYY[MM][DD][HH]格式<br>采用合适的分库分表策略。例如千库十表、十库百表等<br>禁止使用分区表，分区表对分区键有严格要，分区表在表变大后执行DDL、SHARDING、单表恢复等都变得更加困难。<br>拆分大字段和访问频率低的字段，分离冷热数据</p><h3 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h3><ul><li>批量导入、导出数据必须提前通知DBA协助观察</li><li>禁止在线上从库执行后台管理和统计类查询</li><li>禁止有super权限的应用程序账号存在</li><li>产品出现非数据库导致的故障时及时通知DBA协助排查</li><li>推广活动或上线新功能必须提前通知DBA进行流量评估</li><li>数据库数据丢失，及时联系DBA进行恢复</li><li>对单表的多次alter操作必须合并为一次操作</li><li>不在MySQL数据库中存放业务逻辑</li><li>重大项目的数据库方案选型和设计必须提前通知DBA参与</li><li>对特别重要的库表，提前与DBA沟通确定维护和备份优先级</li><li>不在业务高峰期批量更新、查询数据库其他规范</li><li>提交线上建表改表需求，必须详细注明所有相关SQL语句</li><li>其他规范</li></ul><p>日志类数据不建议存储在MySQL上，优先考虑Hbase或OceanBase，如需要存储请找DBA评估使用压缩表存储。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·常用命令记录</title>
      <link href="/2016/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2016/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-笔记"><a href="#MongoDB-笔记" class="headerlink" title="MongoDB 笔记"></a>MongoDB 笔记</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1 查询所有存在的数据库</p><pre><code>show dbs</code></pre><p>2 进入数据库</p><pre><code>use admin</code></pre><p>3 查看所有的collection集合</p><pre><code>show collections    </code></pre><p>4 增加或修改密码</p><pre><code>db.addUser(&#39;userTest&#39;,&#39;123456&#39;)db.addUser(&quot;userTest&quot;,&quot;123456&quot;,true) 参数分别为 用户名、密码、是否只读</code></pre><p>5 查看用户列表</p><pre><code>db.system.users.find()</code></pre><p>6 用户认证</p><pre><code>db.auth(&#39;userTest&#39;,&#39;123456&#39;)</code></pre><p>7 删除用户</p><pre><code>db.removeUser(&#39;userTest&#39;)</code></pre><p>8 查看所有用户</p><pre><code>show users</code></pre><p>9 查看各个collection的状态</p><pre><code>db.printCollectionStats()</code></pre><p>10 查看主从复制状态</p><pre><code>db.printReplicationInfo()</code></pre><p>11 修复数据库</p><pre><code>db.repairDatabase()</code></pre><p>12 设置profiling,0:off 1:slow 2 all</p><pre><code>db.setProfilingLevel(1)</code></pre><p>13 查看profiling</p><pre><code>show profiling</code></pre><p>14 拷贝数据库</p><pre><code>db.copyDatabase(&#39;userTest&#39;,&#39;userTest1&#39;)db.copyDatabase(&quot;userTest&quot;,&quot;temp&quot;,&quot;127.0.0.1&quot;)</code></pre><p>15 删除集合collection</p><pre><code>db.userTest.drop()</code></pre><p>16 删除当前数据库</p><pre><code>db.dropDatabase()</code></pre><hr><h2 id="MongoDB增删改命令"><a href="#MongoDB增删改命令" class="headerlink" title="MongoDB增删改命令"></a>MongoDB增删改命令</h2><p>1 存储数据</p><pre><code>    db.collection.insert(&#123;&#39;name&#39;:&#39;userTest&#39;&#125;)        db.collection.save(&#123;&#39;age&#39;:18&#125;)</code></pre><p>1 存储嵌套的对象</p><pre><code>    db.foo.save(&#123;&#39;name&#39;:&#39;userTest&#39;,&#39;age&#39;:25,&#39;address&#39;:&#123;&#39;city&#39;:&#39;changchun&#39;,&#39;Province&#39;:&#39;Jilin&#39;&#125;&#125;)</code></pre><p>2 存储数组对象</p><pre><code>    db.foo.save(&#123;&#39;name&#39;:userTest,&#39;age&#39;:25,&#39;address&#39;:[&#39;Jilin Province&#39;,&#39;Liaoning Province&#39;]&#125;)</code></pre><p>3 根据query条件修改，如果不存在则插入，允许修改多条记录</p><pre><code>    db.foo.update(&#123;&#39;age&#39;:&#39;25&#39;&#125;,&#123;&#39;$set&#39;:&#123;&#39;name&#39;:&#39;userTest&#39;&#125;&#125;,upsert=true,multi=true)</code></pre><p>4 删除yy&#x3D;5的记录</p><pre><code>    db.foo.remove(&#123;&#39;name&#39;:&#39;userTest&#39;&#125;)</code></pre><p>5 删除所有的记录</p><pre><code>    db.foo.remove()    </code></pre><p>6 去掉某个字段 <code>$unset</code></p><pre><code>  db.users.update(&#123;&#125;,&#123;&#39;$unset&#39;:&#123;&#39;age&#39;:1&#125;&#125;,false,true);    </code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>1 增加索引:1 asc -1 desc</p><pre><code>db.foo.ensureIndex(&#123;firstname:1,lastname:-1&#125;,&#123;unieap:true&#125;)</code></pre><p>2 索引子对象</p><pre><code>db.foo.ensureIndex(&#123;&#39;Al.Em&#39;:!&#125;)</code></pre><p>3 查看索引信息</p><pre><code>db.foo.getIndexes()db.foo.getIndexKeys()</code></pre><p>4 根据索引名删除索引</p><pre><code>db.foo.dropIndex(&#39;Al.Em_1&#39;)</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code>$gt ---- &gt;$lt ---- &lt;$gte ---- &gt;=$lte ---- &lt;=$ne ---- != 、&lt;&gt;$in ---- in$nin ---- not in$all ---- all$or ---- or$not ---- 反匹配</code></pre><p>1 查询所有记录</p><pre><code>db.foo.find() ---- select * from foo</code></pre><p>2 查询某列非重复的记录</p><pre><code>db.foo.distinct(&quot;userTest&quot;) ---- select distinct name from foo</code></pre><p>3 查询age &#x3D; 22 的记录</p><pre><code>db.foo.find(&#123;&quot;age&quot;:22&#125;) ---- select * from foo where age = 22</code></pre><p>4 查询age &gt; 22 的记录</p><pre><code>db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;) ---- select * from foo where age &gt; 22</code></pre><p>5 查询age &lt; 22 的记录</p><pre><code>db.foo.find(&#123;age:&#123;$lt:22&#125;&#125;) ---- select * from foo where age &lt; 22</code></pre><p>6 查询age &lt;&#x3D; 25的记录</p><pre><code>db.foo.find(&#123;age:&#123;$lte:25&#125;&#125;)</code></pre><p>7 查询age &gt;&#x3D; 23 并且 age &lt;&#x3D;26的记录</p><pre><code>db.foo.find(&#123;age:&#123;gte:23,lte:26&#125;&#125;)</code></pre><p>8 查询name中包含userTest的数据</p><pre><code>db.foo.find(&#123;name:/userTest/&#125;) ---- select * from foo where name like &#39;%userTest%&#39;</code></pre><p>9 查询name中以userTest开头的数据</p><pre><code>db.foo.find(&#123;name:/^userTest/&#125;) ---- select * from foo where name like &#39;userTest%&#39;</code></pre><p>10 查询指定列name、age的数据</p><pre><code>db.foo.find(&#123;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo</code></pre><p>11 查询制定列name、age数据，并且age &gt; 22</p><pre><code>db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo where age &gt;22</code></pre><p>12 按照年龄排序</p><ul><li>升序：db.foo.find().sort({age:1})  降序：db.foo.find().sort({age:-1})</li></ul><p>13 查询name&#x3D;userTest.age&#x3D;25的数据</p><pre><code>db.foo.find(&#123;name:&#39;userTest&#39;,age:22&#125;) ---- select * from foo where name=&#39;userTest&#39; and age =&#39;25&#39;</code></pre><p>14 查询前5条数据</p><pre><code>db.foo.find().limit(5) ---- select top 5 * from foo</code></pre><p>15 查询10条以后的数据</p><pre><code>db.foo.find().skip(10) ---- select * from foo where id not in (select top 10 * from foo);</code></pre><p>16 查询在5-10之间的数据</p><pre><code>db.foo.find().limit(10).skip(5) </code></pre><p>17 or与查询</p><pre><code>db.foo.find(&#123;$or:[&#123;age:22&#125;,&#123;age:25&#125;]&#125;) ---- select * from foo where age=22 or age =25</code></pre><p>18 查询第一条数据</p><pre><code>db.foo.findOne() 、db.foo.find().limit(1)---- select top 1 * from foo</code></pre><p>19 查询某个结果集的记录条数</p><pre><code>db.foo.find(&#123;age:&#123;$gte:25&#125;&#125;).count() ---- select count(*) from foo where age &gt;= 20</code></pre><p>20 按照某列进行排序</p><pre><code>db.foo.find(&#123;sex:&#123;$exists:true&#125;&#125;).count() ---- select count(sex) from foo</code></pre><p>21 查询age取模10等于0的数据</p><pre><code>db.foo.find(&#39;this.age % 10 == 0&#39;)、db.foo.find(&#123;age:&#123;$mod:[10,0]&#125;&#125;)</code></pre><p>22 匹配所有</p><pre><code>db.foo.find(&#123;age:&#123;$all:[22,25]&#125;&#125;)</code></pre><p>23 查询不匹配name&#x3D;X*带头的记录</p><pre><code>db.foo.find(&#123;name:&#123;$not:/^X.*/&#125;&#125;)</code></pre><p>24 排除返回age字段</p><pre><code>db.foo.find(&#123;name:&#39;userTest&#39;&#125;,&#123;age:0&#125;)</code></pre><p>25 判断字段是否存在</p><pre><code>db.foo.find(&#123;name:&#123;$exists:true&#125;&#125;)    </code></pre><p>26 查询两个字段值相同的记录</p><pre><code>db.foo.find(&#123;$where:&quot;this.bluid==this.seqid&quot;&#125;).count();</code></pre><h3 id="MongoDB下根据数组大小进行查询的方法"><a href="#MongoDB下根据数组大小进行查询的方法" class="headerlink" title="MongoDB下根据数组大小进行查询的方法"></a>MongoDB下根据数组大小进行查询的方法</h3><p>1.测试数据</p><pre><code>db.array_test.insert(&#123;name:&#39;a&#39;, num:[11,22,33,44,55]&#125;);db.array_test.insert(&#123;name:&#39;b&#39;, num:[111,222]&#125;);db.array_test.insert(&#123;name:&#39;c&#39;, num:[1111]&#125;);db.array_test.insert(&#123;name:&#39;d&#39;, num:[2222]&#125;);</code></pre><ol><li><p><code>$size</code> 查询指定大小的数据</p><p> db.array_test.find({num:{$size:2}})</p></li></ol><ul><li><p>注意：$size 无法查询某个范围的大小，例如下面的语句是无法按照预期运行的：</p><p>  db.array_test.find({num:{$size:{$gt:3}}}); &#x2F;&#x2F;错误</p></li></ul><p>官方文档中建议，如果需要查询的数组大小在某个范围，可以另外为每个文档添加一个键来保存当前数组的大小。</p><p>2.其他思路：</p><p>   使用$where，例如如果要求数组大小小于3：</p><pre><code>db.array_test.find(&#123; $where: &quot;this.num.length &lt; 3&quot; &#125;).pretty()这种方法具有很大的灵活性，但是速度会慢一些。</code></pre><p>另外一个比较高效的方法是判断数组中的某个指定索引的元素是否存在，例如如果要求数组大小小于3：</p><pre><code>db.array_test.find(&#123; &quot;num.2&quot;: &#123;$exists:0&#125; &#125;)数组大小小于3，也就是num[2]不存在。db.array_test.find(&#123; &quot;num.3&quot;: &#123;$exists:1&#125; &#125;)数据大于等于 3</code></pre><h3 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h3><p>1 分组查询</p><pre><code>    db.users.aggregate([    &#123;$match : &#123;&#39;_created&#39;:&#123;&#39;$gte&#39;: ISODate(&#39;2017-04-01 0:0:0&#39;)&#125;&#125;&#125;,    &#123;$group : &#123;_id : &quot;$channel&quot;, channel_count:&#123;$sum:1&#125;&#125;&#125;,    &#123;$sort:&#123;channel_count:-1&#125;&#125;    ]);    </code></pre><p>2 多次分组查询</p><pre><code>    db.logins.aggregate([    &#123;&#39;$match&#39;: &#123;&#39;operate&#39;: &#39;get_token&#39;&#125;&#125;,     &#123;&#39;$group&#39;: &#123;&#39;_id&#39;: &#123;&#39;userId&#39;: &#39;$user_id&#39;, &#39;brand&#39;: &#39;$brand&#39;, &#39;deviceType&#39;: &#39;$src&#39;&#125;&#125;&#125;,     &#123;&#39;$group&#39;: &#123;&#39;_id&#39;: &#123;&#39;brand&#39;: &#39;$_id.brand&#39;, &#39;deviceType&#39;: &#39;$_id.deviceType&#39;&#125;, &#39;num&#39;: &#123;&#39;$sum&#39;: 1&#125;&#125;&#125;,     &#123;&#39;$sort&#39;: &#123;&#39;_id.deviceType&#39;: -1, &#39;num&#39;: -1&#125;&#125;,     &#123;&#39;$limit&#39;: 20&#125;]);</code></pre><h3 id="各种更新操作"><a href="#各种更新操作" class="headerlink" title="各种更新操作"></a>各种更新操作</h3><ul><li><p>更新语法</p><pre><code>  db.collection.update(criteria, objNew, upsert, multi )</code></pre></li><li><p>criteria:update的查询条件，类似sql update查询内where后面的</p></li><li><p>objNew:update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。</p></li><li><p>upsert : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</p></li><li><p>multi : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</p></li></ul><p>1 修改字段数据类型语法</p><ul><li><p><a href="https://docs.mongodb.com/manual/reference/operator/query/type/">MongoDB 数据类型</a></p><pre><code>  db.users.find(&#123;&quot;recv&quot;:&#123;$type:2&#125;&#125;).forEach(             function(x)&#123;                 x.recv=new NumberLong(x.recv);                 db.users.save(x);             &#125;        );</code></pre></li></ul><p>2 mongodb 更新一个字段的值为另外一个字段的值</p><pre><code>    db.users.find(&#123;&#39;client.src&#39;:2&#125;).forEach(       function(item)&#123;                            db.users.update(&#123;&quot;_id&quot;:item._id&#125;,&#123;&quot;$set&quot;:&#123;&quot;client.deviceName&quot;:item.client.sysDesc&#125;&#125;,false,true)         &#125;    )</code></pre><p>3 mongoDB 同步collection从一个数据库到另一个数据库中</p><ul><li><p>new_database是目的数据库</p><pre><code>  db.&lt;collection_name&gt;.find().forEach(function(d)&#123; db.getSiblingDB(&#39;&lt;new_database&gt;&#39;)[&#39;&lt;collection_name&gt;&#39;].insert(d); &#125;);</code></pre></li></ul><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>1 查看collection数据大小</p><pre><code>db.userTest.dataSize()</code></pre><p>2 查看collection状态</p><pre><code>db.userTest.stats()</code></pre><p>3 查询所有索引的大小</p><pre><code>db.userTest.totalIndexSize()</code></pre><h3 id="mongoDB关于数据库的操作"><a href="#mongoDB关于数据库的操作" class="headerlink" title="mongoDB关于数据库的操作"></a>mongoDB关于数据库的操作</h3><h4 id="User相关的基本操作："><a href="#User相关的基本操作：" class="headerlink" title="User相关的基本操作："></a>User相关的基本操作：</h4><pre><code>    &gt; show users　　　　　　　　　　　　　　　　　       ------查看所有用户    &gt; db.system.users.find()　　　　　　　　　　　　　　------查看用户列表    &gt; db.addUser(&#39;name&#39;,&#39;pwd&#39;)　　　　　　                     ------增加或修改用户密码    &gt; db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true)　　　　　 ------添加用户、设置密码、是否只读    &gt; db.auth(&quot;userName&quot;, &quot;123123&quot;)　　　　　　            ------数据库认证、安全模式    &gt; db.removeUser(&#39;name&#39;)　　　　　　                         ------根据用户名删除用户</code></pre><h4 id="Database相关的基本操作："><a href="#Database相关的基本操作：" class="headerlink" title="Database相关的基本操作："></a>Database相关的基本操作：</h4><pre><code>    &gt; show dbs                                                                           ------查看所有数据库    &gt; use [db-name]                                                                  ------当创建一个集合(table)的时候会自动创建当前数据库，这个指令相当于mysql的use [database-name]    &gt; db.dropDatabase()                                                          ------删除当前的数据库    &gt; db.repairDatabase()                                                        ------修复数据库    &gt; db.copyDatabase(&#39;mail_addr&#39;,&#39;mail_addr_tmp&#39;)         -----拷贝数据库    &gt; db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;)          ------将本机的mydb的数据复制到temp数据库中    &gt; db.cloneDatabase(“127.0.0.1”)                                     ------将指定机器上的数据库的数据克隆到当前数据库    </code></pre><h4 id="Collection相关的基本操作："><a href="#Collection相关的基本操作：" class="headerlink" title="Collection相关的基本操作："></a>Collection相关的基本操作：</h4><pre><code>    &gt; show collections                                                             ------查看所有的集合     &gt; db.printReplicationInfo()　                                            ------查看主从复制状态    &gt; db.mail_addr.drop()　                                                    ------删除collection(mail_addr 是collections的名字)    &gt; db.createCollection(“collectionName”, &#123;size: 20, capped: 5, max: 100&#125;)            ------创建一个聚集集合    &gt; db.getCollection(&quot;account&quot;)                                        ------得到指定名称的聚集集合    &gt; db.getCollectionNames()                                             ------得到当前db的所有聚集集合    &gt; db.printCollectionStats()                                              ------查看各collection的状态    其它：    &gt; db.getPrevError()                                                          ------查询之前的错误信息    &gt; db.resetError()                                                               ------清除错误记录        </code></pre><h4 id="查看聚集集合的基本信息"><a href="#查看聚集集合的基本信息" class="headerlink" title="查看聚集集合的基本信息"></a>查看聚集集合的基本信息</h4><pre><code>    &gt; db.test.count();     　　　　　　　　　　　　　------查询当前集合的数据条数    &gt; db.test.dataSIze();                                                   ------查询数据空间大小    &gt; db.test.getDB();                                                       ------得到当前聚集集合所在的database    &gt; db.test.stats();                                                          ------得到当前聚集的状态    &gt; db.test.totalSize();　                                               ------得到聚集集合总大小    &gt; db.test.storageSize();                                             ------得到聚集集合储存空间大小    &gt; db.test.getShardVersion();                                    ------Shard版本信息    &gt; db.test.renameCollection(&quot;users&quot;);                     ------将集合test重名为users    &gt; db.test.drop();                                                          ------删除当前聚集集合</code></pre><h4 id="mongoDB数据的导入和导出"><a href="#mongoDB数据的导入和导出" class="headerlink" title="mongoDB数据的导入和导出"></a>mongoDB数据的导入和导出</h4><pre><code>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。    　　    　　</code></pre><ul><li><p>命令选项说明:　</p><pre><code>  　　  -h:指明数据库宿主机的IP  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字  -f:指明要导出那些列  -o:指明到要导出的文件名  -q:指明导出数据的过滤条件</code></pre></li></ul><p>demo </p><pre><code>本地        mongoexport -d bludb -c resources -o resources.json --type json        远程mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库名 -c collections名称 -o resources.json --type json</code></pre><p>远程<br>mongoexport -h IP –port 端口 -u 用户名 -p 密码 -d 数据库名 -c collections名称 -o resources.json –type json</p><h4 id="Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据"><a href="#Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据" class="headerlink" title="Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据"></a>Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据</h4><pre><code>　导入命令选项说明:　      -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导入那些列</code></pre><p>demo</p><pre><code>    mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库名 -c colelctions名称  resources.json --type json    </code></pre><h5 id="如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式-CSV-格式良好，主流数据库都支持导出为CSV-的格式，所以这种格式非常利于异构数据迁移"><a href="#如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式-CSV-格式良好，主流数据库都支持导出为CSV-的格式，所以这种格式非常利于异构数据迁移" class="headerlink" title="如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式(CSV 格式良好，主流数据库都支持导出为CSV 的格式，所以这种格式非常利于异构数据迁移)"></a>如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式(CSV 格式良好，主流数据库都支持导出为CSV 的格式，所以这种格式非常利于异构数据迁移)</h5><ul><li><p>参数说明：</p><pre><code>  -type:指明要导入的文件格式  -headerline:指明第一行是列名，不需要导入  -file：指明要导入的文件</code></pre></li></ul><h4 id="MongoDB的数据备份和恢复"><a href="#MongoDB的数据备份和恢复" class="headerlink" title="MongoDB的数据备份和恢复"></a>MongoDB的数据备份和恢复</h4><p>用mongodump 来做MongoDB 的库或表级别的备份</p><ul><li><p>备份选项说明(sudo .&#x2F;mongodump  –help)：</p><pre><code>  -h:指明数据库宿主机的IP  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字  -o:输出目录  -q:json query(json查询)</code></pre></li></ul><h5 id="用mongorestore-来做MongoDB-的库或表级别的数据恢复"><a href="#用mongorestore-来做MongoDB-的库或表级别的数据恢复" class="headerlink" title="用mongorestore 来做MongoDB 的库或表级别的数据恢复"></a>用mongorestore 来做MongoDB 的库或表级别的数据恢复</h5><ul><li><p>恢复选项说明(sudo .&#x2F;mongorestore  –help):</p><pre><code>  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字</code></pre></li></ul><p>　　　</p><h3 id="从阿里云备份的数据，导入本地"><a href="#从阿里云备份的数据，导入本地" class="headerlink" title="从阿里云备份的数据，导入本地"></a>从阿里云备份的数据，导入本地</h3><ul><li><p>阿里云建议的语法</p><pre><code>  cat xx.ar| mongorestore -h xxx --port xxx -u xxx -p xxx --drop --gzip --archive -vvvv --stopOnError</code></pre></li><li><p>我在windows上导入的语法</p><pre><code>  mongorestore -h 127.0.0.1 --port 27017  --drop --gzip --archive=hins1226667_data_2212.ar --stopOnError</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性详解</title>
      <link href="/2016/07/17/java/%20JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/07/17/java/%20JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK1-8新特性详解"><a href="#JDK1-8新特性详解" class="headerlink" title="JDK1.8新特性详解"></a>JDK1.8新特性详解</h2><p>Java 8 发行版2014年 3月 19日</p><p>将Java8的新特新逐一列出，并将使用简单的代码示例来指导你如何使用默认接口方法，lambda表达式，方法引用以及多重Annotation，之后你将会学到最新的API上的改进，比如流，函数式接口，Map以及全新的日期API</p><h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a>一、接口的默认方法</h2><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p>首先看看在老版本的Java中是如何排列字符串的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</span><br><span class="line">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b) &#123;</span><br><span class="line">        return b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a>四、方法与构造函数引用</h2><p>前一节中的代码还可以通过静态方法引用来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);   // 123</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(&quot;Java&quot;);</span><br><span class="line">System.out.println(converted);    // &quot;J&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p><h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a>五、Lambda 作用域</h2><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p><h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a>六、访问局部变量</h2><p>我们可以直接在lambda表达式中访问外层的局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在lambda表达式中试图修改num同样是不允许的。</p><h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">    static int outerStaticNum;</span><br><span class="line">    int outerNum;</span><br><span class="line">    void testScopes() &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = 23;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = 72;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * 100);</span><br><span class="line">Built-in Functional Interfaces</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line">predicate.test(&quot;foo&quot;);              // true</span><br><span class="line">predicate.negate().test(&quot;foo&quot;);     // false</span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br><span class="line">personSupplier.get();   // new Person</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p>Consumer 接口表示执行在单个参数上的操作。</p><p>Consumer greeter &#x3D; (p) -&gt; System.out.println(“Hello, ” + p.firstName); greeter.accept(new Person(“Luke”, “Skywalker”));</p><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</span><br><span class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a>Optional 接口</h3><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</span><br><span class="line">optional.isPresent();           // true</span><br><span class="line">optional.get();                 // &quot;bam&quot;</span><br><span class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(&quot;ddd2&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa2&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb1&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa1&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb3&quot;);</span><br><span class="line">stringCollection.add(&quot;ccc&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb2&quot;);</span><br><span class="line">stringCollection.add(&quot;ddd1&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h3><p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean anyStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line">System.out.println(anyStartsWithA);      // true</span><br><span class="line"></span><br><span class="line">boolean allStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      // false</span><br><span class="line"></span><br><span class="line">boolean noneStartsWithZ = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a>Count 计数</h3><p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long startsWithB = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</span><br><span class="line">        .count();</span><br><span class="line">System.out.println(startsWithB);    // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce 规约"></a>Reduce 规约</h3><p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="并行Streams"><a href="#并行Streams" class="headerlink" title="并行Streams"></a>并行Streams</h3><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int max = 1000000;</span><br><span class="line">List&lt;String&gt; values = new ArrayList&lt;&gt;(max);</span><br><span class="line">for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们计算一下排序这个Stream要耗时多久， 串行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line">long count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 串行耗时: 899 ms 并行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line">long count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p><p>下面的例子展示了map上的其他有用的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line">map.computeIfPresent(9, (num, val) -&gt; null);</span><br><span class="line">map.containsKey(9);     // false</span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</span><br><span class="line">map.containsKey(23);    // true</span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.remove(3, &quot;val3&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line">map.remove(3, &quot;val33&quot;);</span><br><span class="line">map.get(3);             // null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外一个有用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9</span><br><span class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9concat</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h2 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a>九、Date API</h2><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="Clock-时钟"><a href="#Clock-时钟" class="headerlink" title="Clock 时钟"></a>Clock 时钟</h3><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   // legacy java.util.Date</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</span><br><span class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime 本地时间"></a>LocalTime 本地时间</h3><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2));  // false</span><br><span class="line"></span><br><span class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       // -3</span><br><span class="line">System.out.println(minutesBetween);     // -239</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(23, 59, 59);</span><br><span class="line">System.out.println(late);       // 23:59:59</span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   // 13:37</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate 本地日期"></a>LocalDate 本地日期</h3><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天&#x2F;月&#x2F;年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(2);</span><br><span class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>System.out.println(dayOfWeek); &#x2F;&#x2F; FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</span><br><span class="line">System.out.println(xmas);   // 2014-12-24</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime-本地日期时间"><a href="#LocalDateTime-本地日期时间" class="headerlink" title="LocalDateTime 本地日期时间"></a>LocalDateTime 本地日期时间</h3><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      // WEDNESDAY</span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          // DECEMBER</span><br><span class="line"></span><br><span class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    // 1439</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p><h2 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a>十、Annotation 注解</h2><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line">@Repeatable(Hints.class)</span><br><span class="line">@interface Hint &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例 2：使用多重注解（新方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Hint(&quot;hint1&quot;)</span><br><span class="line">@Hint(&quot;hint2&quot;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.7新特性详解</title>
      <link href="/2016/07/16/java/%20JDK1.7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/07/16/java/%20JDK1.7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK1-7新特性详解"><a href="#JDK1-7新特性详解" class="headerlink" title="JDK1.7新特性详解"></a>JDK1.7新特性详解</h2><p>Java 7 发行版2011 年 7 月 28 日</p><p>JDK7对Java语法有少量更新，重点是在易用性和便捷性的改进。</p><h2 id="1-二进制字面量"><a href="#1-二进制字面量" class="headerlink" title="1.二进制字面量"></a>1.二进制字面量</h2><p>JDK7开始，终于可以用二进制来表示整数（byte,short,int和long）。使用二进制字面量的好处是，可以是代码更容易被理解。语法非常简单，只要在二进制数值前面加 0b或者0B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte nByte = (byte)0b0001;  </span><br><span class="line">short nShort = (short)0B0010;  </span><br><span class="line">int nInt = 0b0011;  </span><br><span class="line">long nLong = 0b0100L; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-数字字面量可以出现下划线"><a href="#2-数字字面量可以出现下划线" class="headerlink" title="2.数字字面量可以出现下划线"></a>2.数字字面量可以出现下划线</h2><p>对于一些比较大的数字，我们定义起来总是不方面，经常缺少或者增加位数。JDK7为我们提供了一种解决方案，下划线可以出现在数字字面量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10_0000_0000;  </span><br><span class="line">long b = 0xffff_ffff_ffff_ffffl;  </span><br><span class="line">byte c = 0b0001_1000;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：你只能将下划线置于数字之间，以下使用方法是错误的，</p><ol><li>数字的开头或者结尾</li><li>小数点的前后</li><li>‘F’或者‘f’的后缀</li><li>只能用数字的位置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nt err1 = _11,err2=11_;  </span><br><span class="line">float err3=3._4,err4=3_.4;  </span><br><span class="line">long err5=0x888_f;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-switch-语句可以用字符串了"><a href="#3-switch-语句可以用字符串了" class="headerlink" title="3.switch 语句可以用字符串了"></a>3.switch 语句可以用字符串了</h2><p>这个功能千呼万唤，终于出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void switchString(String str)&#123;  </span><br><span class="line">        switch(str)&#123;  </span><br><span class="line">            case &quot;one&quot;:  </span><br><span class="line">                System.err.println(&quot;1&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            case &quot;two&quot;:  </span><br><span class="line">                System.out.println(&quot;2&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            default :  </span><br><span class="line">                System.out.println(&quot;err&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-泛型实例的创建可以通过类型推断来简化"><a href="#4-泛型实例的创建可以通过类型推断来简化" class="headerlink" title="4.泛型实例的创建可以通过类型推断来简化"></a>4.泛型实例的创建可以通过类型推断来简化</h2><p>以后你创建一个泛型实例，不需要再详细说明类型，只需用&lt;&gt;,编译器会自动帮你匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//例如   </span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();  </span><br><span class="line">//可以简化为  </span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-在可变参数方法中传递非具体化参数（Non-Reifiable-Formal-Parameters）-改进编译警告和错误"><a href="#5-在可变参数方法中传递非具体化参数（Non-Reifiable-Formal-Parameters）-改进编译警告和错误" class="headerlink" title="5.在可变参数方法中传递非具体化参数（Non-Reifiable Formal Parameters）,改进编译警告和错误"></a>5.在可变参数方法中传递非具体化参数（Non-Reifiable Formal Parameters）,改进编译警告和错误</h2><p>有些参数类型，例如ArrayList 和 List,是非具体化的（non-reifiable）.在编译阶段，编译器会擦除该类型信息。</p><p>Heappollution 指一个变量被指向另外一个不是相同类型的变量。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List l = new ArrayList&lt;Number&gt;();  </span><br><span class="line">List&lt;String&gt; ls = l;       // unchecked warning  </span><br><span class="line">l.add(0, new Integer(42)); // another unchecked warning  </span><br><span class="line">String s = ls.get(0);      // ClassCastException is thrown  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到我们的主题，在jdk7中，当你定义下面的函数时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;  </span><br><span class="line">    for (T x : elements) &#123;  </span><br><span class="line">      listArg.add(x);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你会得到一个warning</p><p><code>warning: [varargs] Possible heap pollution from parameterized vararg type</code></p><p>在jdk7之前，当你调用一个含有非具体化参数的可变参数方法，你必须自行保证不会发生<code>heappollution</code>。这有一个问题，如果调用者对方法不熟悉，他根本无法判断。JDK7对此做了改进，在该方法被定义时久发出警告</p><p>要消除警告，可以有三种方式</p><ol><li>加 annotation @SafeVarargs</li><li>加 annotation @SuppressWarnings({“unchecked”, “varargs”})</li><li>使用编译器参数 –Xlint:varargs;</li></ol><h2 id="6-try-with-resources-语句"><a href="#6-try-with-resources-语句" class="headerlink" title="6.try-with-resources 语句"></a>6.try-with-resources 语句</h2><p>jdk7提供了try-with-resources,可以自动关闭相关的资源（只要该资源实现了AutoCloseable接口，jdk7为绝大部分资源对象都实现了这个接口）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFile(String path) throws IOException &#123;  </span><br><span class="line">  try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;  </span><br><span class="line">    return br.readLine();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try 语句块中还可以同时处理多个资源,可以跟普通的try语句一样catch异常，有finally语句块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (  </span><br><span class="line">      java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);  </span><br><span class="line">      java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)  </span><br><span class="line">    ) &#123;  </span><br><span class="line">&#125;catch(…)&#123;  </span><br><span class="line">&#125;finally&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-Catch多个Exception，rethrow-exception-改进了类型检测"><a href="#7-Catch多个Exception，rethrow-exception-改进了类型检测" class="headerlink" title="7.Catch多个Exception，rethrow exception 改进了类型检测"></a>7.Catch多个Exception，rethrow exception 改进了类型检测</h2><p>很多时候，我们捕获了多个异常，却做了相同的事情，比如记日志，包装成新的异常，然后rethrow。这时，代码就不那么优雅了，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException ex) &#123;  </span><br><span class="line">     logger.log(ex);  </span><br><span class="line">     throw ex;  </span><br><span class="line">catch (SQLException ex) &#123;  </span><br><span class="line">     logger.log(ex);  </span><br><span class="line">     throw ex;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Jdk7允许捕获多个异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException|SQLException ex) &#123;  </span><br><span class="line">    logger.log(ex);  </span><br><span class="line">    throw ex;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，catch后面的异常参数是final的，不能重新再复制</p><p><code>RethrowException</code>更具包容性的类型检测</p><p>当你重新抛出多个异常时，不再需要详细定义异常类型了，编译器已经知道你具体抛出的是哪个异常了。你只需在方法定义的时候声明需要抛出的异常即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void call() throws ReflectiveOperationException, IOException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">      callWithReflection(arg);  </span><br><span class="line">    &#125; catch (final Exception e) &#123;  </span><br><span class="line">      logger.trace(&quot;Exception in reflection&quot;, e);  </span><br><span class="line">      throw e;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考</p><ul><li>Jdk7官网 <a href="http://openjdk.java.net/projects/jdk7/">http://openjdk.java.net/projects/jdk7/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·安装与配置(win)</title>
      <link href="/2016/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE(win)/"/>
      <url>/2016/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE(win)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·入门</title>
      <link href="/2016/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%85%A5%E9%97%A8/"/>
      <url>/2016/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB·入门"><a href="#MongoDB·入门" class="headerlink" title="MongoDB·入门"></a>MongoDB·入门</h1><p>##何为 NoSql</p><blockquote><p>NoSQL(NoSQL &#x3D; Not Only SQL ) <span id="more"></span></p></blockquote><ul><li><p>为什么使用NoSQL 强项：</p><pre><code>  1.对数据库高并发读写。    2.对海量数据的高效率存储和访问。    3.对数据库的高可扩展性和高可用性。</code></pre></li><li><p>弱项：</p><pre><code>  1.数据库事务一致性需求    2.数据库的写实时性和读实时性需求    3.对复杂的SQL查询，特别是多表关联查询的需求</code></pre></li></ul><h2 id="NoSQL四大类"><a href="#NoSQL四大类" class="headerlink" title="NoSQL四大类"></a>NoSQL四大类</h2><h3 id="1-key-value存储"><a href="#1-key-value存储" class="headerlink" title="1.key-value存储"></a>1.key-value存储</h3><blockquote><table><thead><tr><th>Examples</th><th>Redis, Tokyo Cabinet&#x2F;Tyrant, Tair</th></tr></thead><tbody><tr><td>典型应用场景</td><td>内容缓存，主要用于处理大量数据的高访问负载。</td></tr><tr><td>数据模型</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td></tr><tr><td>强项</td><td>查找速度快</td></tr><tr><td>弱项</td><td>数据无结构化（或弱结构），通常只被当作字符串或者二进制数据</td></tr></tbody></table></blockquote><h3 id="2-列式数据库"><a href="#2-列式数据库" class="headerlink" title="2.列式数据库"></a>2.列式数据库</h3><blockquote><table><thead><tr><th>Examples</th><th align="left">Cassandra  HBase Riak  SybaseIQ</th></tr></thead><tbody><tr><td>典型应用场景</td><td align="left">分布式的文件系统、大数据分析。</td></tr><tr><td>数据模型</td><td align="left">以列簇式存储，将同一列数据存在一起</td></tr><tr><td>强项</td><td align="left">查找速度快，可扩展性强，更容易进行分布式扩展</td></tr><tr><td>弱项</td><td align="left">功能相对局限</td></tr></tbody></table></blockquote><h3 id="3-文档型数据库"><a href="#3-文档型数据库" class="headerlink" title="3.文档型数据库"></a>3.文档型数据库</h3><blockquote><table><thead><tr><th>Examples</th><th>MongoDb，CouchDB</th></tr></thead><tbody><tr><td>典型应用场景</td><td>Web应用(Value是结构化的，数据库能够了解Value的内容)</td></tr><tr><td>数据模型</td><td>Key-Value对应的键值对，Value为结构化文档数据</td></tr><tr><td>强项</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td></tr><tr><td>弱项</td><td>相比其他NoSql查询性能不高，而且缺乏统一的查询语法</td></tr></tbody></table></blockquote><h3 id="4-图结构数据库"><a href="#4-图结构数据库" class="headerlink" title="4.图结构数据库"></a>4.图结构数据库</h3><blockquote><table><thead><tr><th>Examples</th><th>Neo4J, InfoGrid, Infinite Graph</th></tr></thead><tbody><tr><td>典型应用场景</td><td>社交网络，推荐系统等。专注于构建关系图谱</td></tr><tr><td>数据模型</td><td>图结构</td></tr><tr><td>强项</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td></tr><tr><td>弱项</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td></tr></tbody></table></blockquote><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Mongo 是一个高性能，开源，无模式的文档型数据库，它在许多场景下可用于替代传统的关系型数据库或键&#x2F;值存储方式。MongoDB使用C++开发。不支持SQL，但有自己功能强大的查询语法。MongoDB使用BSON作为数据存储和传输的格式。BSON是一种类似JSON的二进制序列化文档。MongoDB很像MySQL，是最像关系型数据库的NoSql。</p></blockquote><ul><li>字段对应关系</li></ul><blockquote><table><thead><tr><th>MySQL term</th><th align="left">Mongo term&#x2F;conceptp</th></tr></thead><tbody><tr><td>database</td><td align="left">database</td></tr><tr><td>table</td><td align="left">collection</td></tr><tr><td>index</td><td align="left">index</td></tr><tr><td>row</td><td align="left">BSON document</td></tr><tr><td>column</td><td align="left">BSON field</td></tr><tr><td>join</td><td align="left">embedding and linking</td></tr><tr><td>primary key</td><td align="left">_id field</td></tr><tr><td>group by</td><td align="left">aggregation</td></tr></tbody></table></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><ul><li>高性能、易部署、易使用，存储数据非常方便。</li></ul></blockquote><ul><li>面向集合存储，易存储对象类型的数据</li><li>模式自由</li><li>支持动态查询</li><li>支持完全索引，包含内部对象。</li><li>支持复制和故障恢复。 </li><li>使用高效的二进制数据存储，包括大型对象（如视频等）</li><li>自动处理碎片，以支持云计算层次的扩展性</li><li>支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序</li><li>文件存储格式为BSON（一种JSON的扩展）</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><blockquote><ul><li>面向集合的存储：适合存储对象及JSON形式的数据。</li></ul></blockquote><ul><li>动态查询：MongoDB 支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>完整的索引支持：包括文档内嵌对象及数组。MongoDB的查询优化器会分析查询表达式，并生成一个高效的查询计划。</li><li>查询监视：MongoDB包含一系列监视工具用于分析数据库操作的性能。</li><li>复制及自动故障转移：MongoDB数据库支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。</li><li>高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）。</li><li>自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群。</li></ul><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><blockquote><ul><li>网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</li></ul></blockquote><ul><li>大数据量，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</li><li>高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。</li><li>用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Spring3 Schedule Task之注解实现 （两次起动Schedule Task 的解决方案）</title>
      <link href="/2016/06/30/java/%20Spring%20Spring3%20Schedule%20Task%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%A4%E6%AC%A1%E8%B5%B7%E5%8A%A8Schedule%20Task%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/"/>
      <url>/2016/06/30/java/%20Spring%20Spring3%20Schedule%20Task%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%A4%E6%AC%A1%E8%B5%B7%E5%8A%A8Schedule%20Task%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>目前项目中还未运用到 定时任务模块，考虑到好友生日提醒，后续的统计，日志收集等会需要做成定时任务执行，<br>   就目前情况，准备先使用Spring3的 Spring-Task 来实现，直接用注解即可，配置后，写了个测试方法，每隔一分钟 打印一句话。测试过程中发下每次会执行两遍~  解决后 mark 下，补充学习~。</p></blockquote><p><img src="http://i.imgur.com/OzJCeEx.png"></p><pre><code> Spring3 Schedule Task之注解实现 （两次启动Schedule Task 的解决方案）在spring3 中的新引入的task 命名空间。可以部分取代 quartz 功能，配置和API更加简单，并且支持注解方式。但是如果需要使用比较复杂的任务调度。还是建议使用quartz。</code></pre><h2 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h2><pre><code>在Spring的相关配置文件中（applicationContext.xml或者是&#123;project_name&#125;_servelt.xml或者是独立的配置文件如XXX_quartz.xml)中配置并开启Spring Schedule Task.注意其中高亮的部分是必须的。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;        xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd       http://www.springframework.org/schema/task       http://www.springframework.org/schema/task/spring-task-3.0.xsd       &quot;&gt;    &lt;mvc:annotation-driven /&gt;    &lt;context:component-scan base-package=&quot;com.mytools.validator.engine&quot; /&gt;        &lt;!-- 启动定时器 --&gt;    &lt;task:annotation-driven/&gt;     &lt;/beans&gt;</code></pre><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><pre><code>    可以在类中的需要定时执行的方法下指定如下Annotation@Scheduled(cron=&quot;0 33/3 * * * ?&quot;) //每小时的33分钟开始执行，每3分钟执行1次    public void start() throws ServletException &#123;                 validate();&#125;</code></pre><ul><li><p>备注：其实@Scheduled中可以指定如下3中时间表达式：</p></li><li><p>（1）fixedRate：每隔多少毫秒执行一次该方法。如：</p><pre><code>    @Scheduled(fixedRate=2000)  // 每隔2秒执行一次    public void scheduleMethod()&#123;                System.out.println(&quot;Hello world...&quot;);      &#125;  </code></pre><p>　 </p></li><li><p>（2）fixedDelay：当一次方法执行完毕之后，延迟多少毫秒再执行该方法。</p></li><li><p>（3）cron：详细配置了该方法在什么时候执行。cron值是一个cron表达式。如：</p><pre><code>          @Scheduled(cron=&quot;0 0 0 * * SAT&quot;)            public voidarchiveOldSpittles() &#123;             // ...            &#125;</code></pre></li></ul><p>到指定时间后，任务总是执行2次的解决方案：<br>这是因为我们很容易在一个基于Spring的Web工程中启动2个定时线程：</p><p> 第一次：web容器启动的时候，读取applicationContext.xml（或者别的Spring核心配置文件）文件时，会加载一次。</p><p> 第二次：Spring本身会加载applicationContext.xml（或者别的Spring核心配置文件）一次。</p><p>解决方案：将你的Task的相关配置独立出来并在web.xml中通过context-param加载。而不是通过spring加载。</p><p>1） 独立出Spring-Task，如新命名一个文件名叫cms_quartz.xml</p><ol start="2"><li>在web.xml中去加载该文件：</li></ol><pre><code>&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/cms-servlet.xml,classpath:cms-quartz.xml&lt;/param-value&gt;    &lt;/context-param&gt;</code></pre><hr><p>1.首先加入下载spring3.2 ，<a href="http://projects.spring.io/spring-framework/">http://projects.spring.io/spring-framework/</a></p><p>2.加入jar包，在applicationContext.xml加入声明</p><p>-xmlns加入</p><p>[java<br>xmlns:task&#x3D;”<a href="http://www.springframework.org/schema/task&quot;">http://www.springframework.org/schema/task&quot;</a><br>-xsi加入<br>[java]<br><a href="http://www.springframework.org/schema/task">http://www.springframework.org/schema/task</a>   </p><p>[java]<br><a href="http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;">http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;</a>  </p><p>[java]<br>            <!-- 使用Annotation自动注册Bean，解决事物失效问题：在主容器中不扫描@Controller注解，在SpringMvc中只扫描@Controller注解。  --><br>            &lt;context:component-scan base-package&#x3D;”com.zt49”&gt;<br>                &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller” &#x2F;&gt;<br>            </context:component-scan>  </p><ul><li>任务注解</li></ul><p>[java]<br>&lt;task:annotation-driven &#x2F;&gt;  </p><p>3.创建一个任务类（示例）<br>[java]<br>import org.springframework.context.annotation.Lazy;  </p><p>import org.springframework.scheduling.annotation.Scheduled;  </p><p>import org.springframework.stereotype.Component;  </p><pre><code>@Component  public class TestTask &#123;            @Scheduled(cron = &quot;0 0/1 * * * ?&quot;)      public void test()&#123;          System.out.println(&quot;test&quot;);      &#125;    &#125;  </code></pre><p>启动程序，定时任务就可以了。这个示例代表每分钟执行一次任务。</p><p>附：cron常用表示：</p><pre><code>CronTrigger配置格式:   格式: [秒] [分] [小时] [日] [月] [周] [年]序号 说明 是否必填 允许填写的值 允许的通配符1   秒    是      0-59 ,         - * /2    分    是      0-59 ,        - * /3    小时  是      0-23 ,       - * /4    日    是      1-31 ,      - * ? / L W5    月    是    1-12 or JAN-DEC , - * /6    周     是     1-7 or SUN-SAT , - * ? / L #7    年     否     empty 或 1970-2099 , - * /通配符说明:* 表示所有值. 例如:在分的字段上设置 &quot;*&quot;,表示每一分钟都会触发。? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为&quot;?&quot; 具体设置为 0 0 0 10 * ?- 表示区间。例如在小时上设置 &quot;10-12&quot;,表示 10,11,12点都会触发。, 表示指定多个值，例如在周字段上设置 &quot;MON,WED,FRI&quot; 表示周一，周三和周五触发/ 用于递增触发。如在秒上面设置&quot;5/15&quot; 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置&#39;1/3&#39;所示每月1号开始，每隔三天触发一次。L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于&quot;7&quot;或&quot;SAT&quot;。如果在&quot;L&quot;前加上数字，则表示该数据的最后一个。例如在周字段上设置&quot;6L&quot;这样的格式,则表示“本 月最后一个星期五&quot;W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置&quot;15W&quot;，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 &quot;1W&quot;,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，&quot;W&quot;前只能设置具体的数字,不允许区间&quot;-&quot;).小提示&#39;L&#39;和 &#39;W&#39;可以一组合使用。如果在日字段上设置&quot;LW&quot;,则表示在本月的最后一个工作日触发(一般指发工资 )# 序号(表示每月的第几个周几)，例如在周字段上设置&quot;6#3&quot;表示在每月的第三个周六.注意如果指定&quot;#5&quot;,正好第五周没有周六，则不会触发该配置(用 在母亲节和父亲节再合适不过了)小提示周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同.常用示例:0 0 12 * * ? 每天12点触发0 15 10 ? * * 每天10点15分触发0 15 10 * * ? 每天10点15分触发0 15 10 * * ? * 每天10点15分触发0 15 10 * * ? 2005 2005年每天10点15分触发0 * 14 * * ? 每天下午的 2点到2点59分每分触发0 0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)0 0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) 每天下午的 18点到18点59分(整点开始，每隔5分触发)0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发0 10,44 14 ? 3 WED 3月分每周三下午的 2点10分和2点44分触发0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发0 15 10 15 * ? 每月15号上午10点15分触发0 15 10 L * ? 每月最后一天的10点15分触发0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发0 15 10 ? * 6#3 每月的第三周的星期五开始触发0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次0 11 11 11 11 ? 每年的11月11号 11点11分触发</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh-keygen</title>
      <link href="/2016/06/16/%E5%B7%A5%E5%85%B7/%20ssh-keygen/"/>
      <url>/2016/06/16/%E5%B7%A5%E5%85%B7/%20ssh-keygen/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>ssh是一种安全的网络协议，主要用于登录linux<span id="more"></span>,可每次登录都需要输入密码，非常麻烦，ssh-keygen （公钥）认证是ssh认证方式的一种，通过公钥认证可实现免密码登录， 带来了不少便利。~ github也可以通过这种方式认证</p></blockquote><h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><blockquote><p>这里只简单记录下，如何通过ssh-keygen实现两台linux设备的相互登录</p></blockquote><ul><li>从本地免密码登录到目标机器</li></ul><ol><li><p>本地执行 <code>ssh-keygen -t rsa</code> 默认在 ~&#x2F;.ssh目录下生成将会生成密钥文件和私钥文件 id_rsa,id_rsa.pub</p><pre><code>    -t : [rsa|dsa] 加密方式    -f : 自定义文件的名字     -C : 注释（备注）</code></pre></li><li><p>把id_rsa.pub复制到目标机器的.ssh目录，并导入到<code>authorized_keys</code>中</p><pre><code>         cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre></li></ol><p>这样就可以通过SSH 目标IP，直接登录到目标机器了</p><ul><li>注意：.ssh的目录，及里面的文件权限请保持只能本地写的权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2016/06/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/06/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-学习笔记·入门"><a href="#Markdown-学习笔记·入门" class="headerlink" title="Markdown 学习笔记·入门"></a>Markdown 学习笔记·入门</h1><p>　　花一点点时间了解了下Markdown的语法，确实非常简单，这里做下总结，也算是对Markdown语法的熟悉，及模仿造轮子吧~ <span id="more"></span>  </p><h2 id="markdown-简介"><a href="#markdown-简介" class="headerlink" title="markdown 简介"></a>markdown 简介</h2><blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。–百度百科</p></blockquote><h2 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h2><blockquote></blockquote><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li><li>Markdown 的标记语法有极好的可读性。</li></ul><h2 id="Markdown-语法介绍"><a href="#Markdown-语法介绍" class="headerlink" title="Markdown 语法介绍"></a>Markdown 语法介绍</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ul><li>*,-,+ 3个符号 被称为Markdown符号</li><li>空白行表示另起一个段落</li><li>&#96;是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签</li></ul><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li><p><code>#</code> + 空格 后面的文字即表示为标题</p><pre><code>  # 表示一级标题，## 表示二级标题，依次表示 1-6 级标题</code></pre></li><li><p>注意： 符号后面要加一个 <strong>空格</strong> 和文本内容隔开</p></li><li><p>还可以在文字下行加&#x3D; 表示大标题 - 表示小标题 慎用吧</p><pre><code>  例如：  大标题  =  小标题  -</code></pre></li></ul><h3 id="字体：斜体-x2F-加粗"><a href="#字体：斜体-x2F-加粗" class="headerlink" title="字体：斜体 &#x2F; 加粗"></a>字体：斜体 &#x2F; 加粗</h3><pre><code>    *文本* 表示文本内容为斜体， **文本** 表示文本内容为加粗</code></pre><ul><li>效果： <em>斜体文本</em>  <strong>加粗文本</strong></li></ul><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>段落间加一个 <strong>空白行</strong> 分割 同html中的 <code>&lt;p&gt;</code></li><li>连续两个空格即为换行 同html中的 <code>&lt;br&gt;</code></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>使用*,+,-加上一个空格来表示</p></li><li><p>可以支持嵌套,如</p><pre><code>  *,+,-效果一样的  - 外层列表项目        + 内层列表项目       + 内层无序列表项目      + 内层列表项目  - 外层列表项目</code></pre></li><li><p>效果</p></li></ul><p> </p><hr><ul><li>外层列表项目<ul><li>内层列表项目</li><li>内层列表项目</li><li>内层列表项目</li></ul></li><li>外层列表项目</li></ul><hr><ul><li><p>有序列表用 数字+英文点+空格来表示</p><pre><code>  - 1. 这样会展示序号 </code></pre></li><li><p>效果：</p></li><li><ol><li>这样会展示序号</li></ol></li><li><p>注意：列表内容很长的，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><p>这其实是我第一个接触的markdown语法，第一篇资料收集时就用到了</p><pre><code>   直接使用 [文本](链接)</code></pre></li><li><p>效果：<a href="https://www.baidu.com/">百度</a></p><pre><code>   如果很多地方需要相同的url呢，可以预先定义url 这样玩：[ref_name]:URL     ref_name 一般使用数字表示，显得专业 然后在需要使用链接的地方 使用[文本][ref_name] 这种方式即可,酷炫</code></pre></li><li><p>效果<br>[1]:<a href="https://www.baidu.com/">https://www.baidu.com/</a></p><pre><code>    [ref_name]：url 如： [1]:https://www.baidu.com/ </code></pre></li><li><p>引用上面定义的url [百度][1]</p></li><li><p>如果想把URL展示出来，并可以作为链接使用  这样玩：<code>&lt;URL&gt;</code></p><pre><code>    &lt;url&gt; 如： &lt;https://www.baidu.com/&gt; </code></pre></li><li><p>效果：<a href="https://www.baidu.com/">https://www.baidu.com/</a></p></li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li><p>图片语法与链接类似</p><pre><code>  ![](图片地址) 如： ![](http://i.imgur.com/P7ACmyM.png)</code></pre></li></ul><p> <img src="http://i.imgur.com/P7ACmyM.png"></p><ul><li><p>同样可以使用引用的方式使用图片</p><pre><code>  这样定义：[id]:图片url  这样引用定义 ![][id]</code></pre></li><li><p>定义图片的大小或比例</p></li><li><p>方法一：嵌入HTML代码</p><pre><code>      &lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; 注意：要居中展示，外围加&lt;div&gt;即可</code></pre></li><li><p>方法二：使用支持图片大小更改操作的 Mou 编辑器 （mac可以玩）</p><pre><code>       ![](url =100x100) 注意: =前有个空格，可以只写宽度。         </code></pre></li><li><p>方法三： 阿里云的OSS，七牛云的图片服务器时，url上加上相关操字段即可实现图片大小，比例修改，具体见各自的产品文档~</p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>开篇关于Markdown的简介和特点就是引用的百度， 只要在第一行加上 “&gt;”和一个空格，表示代码引用，还可以嵌套</li></ul><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><ul><li><p>使用 \ 来转义，表示文本中的markdown符号</p><pre><code>  如： \[百度](https://www.baidu.com/)</code></pre></li><li><p>效果：[百度](<a href="https://www.baidu.com/">https://www.baidu.com/</a>)</p></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><p>表格代码</p><blockquote></blockquote><p>| Tables        | Are           | Cool  |<br>| ————- |:————-:| —–:|<br>| col 3 is      | right-aligned | $1600 |<br>| col 2 is      | centered      |   $12 |<br>| zebra stripes | are neat      |    $1 |  </p><p>   ————- 左对齐 :————-: 居中 —–:右对齐</p></li><li><p>效果：</p></li></ul><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li><p>按下Tab键 或4个空格即表示代码块</p></li><li><p>下面是一小段代码举例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里显示一些代码，使用```java```，进行代码染色，这是一段使用JAVA代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> Id </span><br><span class="line">  <span class="keyword">public</span> string Subject</span><br><span class="line">  省略 get() set() toString() ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样基本就可以玩起来了，还是需要多实践，多谢，多总结。</p><blockquote><p>我们活在各自的的心灵世界，我们有什么样的心，就决定我们看到什么样的世界</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习下Markdown</title>
      <link href="/2016/06/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AD%A6%E4%B9%A0%E4%B8%8BMarkdown/"/>
      <url>/2016/06/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AD%A6%E4%B9%A0%E4%B8%8BMarkdown/</url>
      
        <content type="html"><![CDATA[<p>   利用闲暇时间搭建了这个人博客，希望以督促自己坚持多总结， 多写作，不断提高自己，现在都流行使用Markdown来编写blog，我对<br>Markdown 尚未了解，百度之，还好比较简单<span id="more"></span>,下载了MarkDownPad,收集了一些资料,准备学习之</p><p><a href="http://lutaf.com/markdown-simple-usage.htm">鲁塔弗 一分钟学会Markdown语法</a></p><p><a href="http://www.ituring.com.cn/article/23">图灵社区 Markdown语法入门</a></p><p><a href="http://www.jianshu.com/p/q81RER">简书 适合新手的Markdown语法</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
