<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>知识图谱编辑器帮助文档</title>
      <link href="/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
      <url>/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八然</title>
      <link href="/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
      <url>/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</url>
      
        <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是追求极致</title>
      <link href="/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
      <url>/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</url>
      
        <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qs.stringify的使用</title>
      <link href="/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图看二十大报告</title>
      <link href="/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
      <url>/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> 语录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cherry键盘 win键无效</title>
      <link href="/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
      <url>/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十大手帐</title>
      <link href="/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
      <url>/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> 语录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是成长</title>
      <link href="/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
      <url>/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么让猫吃辣椒</title>
      <link href="/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
      <url>/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</url>
      
        <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac上用trash命令代替rm</title>
      <link href="/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平凡日子里的挣扎</title>
      <link href="/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
      <url>/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openflow总结</title>
      <link href="/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
      <link href="/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
      <url>/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八卦</title>
      <link href="/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
      <url>/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</url>
      
        <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 日志规范</title>
      <link href="/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10种常见的软件架构模式</title>
      <link href="/2020/10/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/10/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>有没有想过要设计多大的企业规模系统？在主要的软件开发开始之前，我们必须选择一个合适的体系结构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，我们应该了解不同的体系结构。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785157/1000" alt="img"></p><p>什么是架构模式？</p><p>根据维基百科中的定义：</p><p>架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。架构模式与软件设计模式类似，但具有更广泛的范围。</p><p>在本文中，将简要地解释以下10种常见的体系架构模式，以及它们的用法、优缺点。</p><p>分层模式</p><p>客户端-服务器模式</p><p>主从设备模式</p><p>管道-过滤器模式</p><p>代理模式</p><p>点对点模式</p><p>事件总线模式</p><p>模型-视图-控制器模式</p><p>黑板模式</p><p>解释器模式</p><p>一. 分层模式</p><p>这种模式也称为多层体系架构模式。它可以用来构造可以分解为子任务组的程序，每个子任务都处于一个特定的抽象级别。每个层都为下一个提供更高层次服务。</p><p>一般信息系统中最常见的是如下所列的4层。</p><p>表示层(也称为UI层)</p><p>应用层(也称为服务层)</p><p>业务逻辑层(也称为领域层)</p><p>数据访问层(也称为持久化层)</p><p>使用场景：</p><p>一般的桌面应用程序</p><p>电子商务Web应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785133/1000" alt="img"></p><p>二. 客户端-服务器模式</p><p>这种模式由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。</p><p>使用场景：</p><p>电子邮件，文件共享和银行等在线应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785144/1000" alt="img"></p><p>三. 主从设备模式</p><p>这种模式由两方组成;主设备和从设备。主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是由从设备返回的结果。</p><p>使用场景：</p><p>在数据库复制中，主数据库被认为是权威的来源，并且要与之同步</p><p>在计算机系统中与总线连接的外围设备(主和从驱动器)</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785136/1000" alt="img"></p><p>四. 管道-过滤器模式</p><p>此模式可用于构造生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。</p><p>使用场景：</p><p>编译器。连续的过滤器执行词法分析、解析、语义分析和代码生成</p><p>生物信息学的工作流</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785139/1000" alt="img"></p><p>五. 代理模式</p><p>此模式用于构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。</p><p>服务器将其功能(服务和特征)发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。</p><p>使用场景：</p><p>消息代理软件，如Apache ActiveMQ，Apache Kafka，RabbitMQ和JBoss Messaging</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785137/1000" alt="img"></p><p>六. 点对点模式</p><p>在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。</p><p>使用场景：</p><p>像Gnutella和G2这样的文件共享网络</p><p>多媒体协议，如P2PTV和PDTP</p><p>像Spotify这样的专有多媒体应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785140/1000" alt="img"></p><p>七. 事件总线模式</p><p>这种模式主要是处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。消息源将消息发布到事件总线上的特定通道上。侦听器订阅特定的通道。侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。</p><p>使用场景：</p><p>安卓开发</p><p>通知服务</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785148/1000" alt="img"></p><p>八. 模型-视图-控制器模式</p><p>这种模式，也称为MVC模式，把一个交互式应用程序划分为3个部分，</p><p>模型：包含核心功能和数据</p><p>视图：将信息显示给用户(可以定义多个视图)</p><p>控制器：处理用户输入的信息</p><p>这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</p><p>使用场景：</p><p>在主要编程语言中互联网应用程序的体系架构</p><p>像Django和Rails这样的Web框架</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785143/1000" alt="img"></p><p>九. 黑板模式</p><p>这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由3个主要组成部分组成。</p><p>黑板——包含来自解决方案空间的对象的结构化全局内存</p><p>知识源——专门的模块和它们自己的表示</p><p>控制组件——选择、配置和执行模块</p><p>所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。</p><p>使用场景：</p><p>语音识别</p><p>车辆识别和跟踪</p><p>蛋白质结构识别</p><p>声纳信号的解释</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785141/1000" alt="img"></p><p>十. 解释器模式</p><p>这个模式用于设计一个解释用专用语言编写的程序的组件。它主要指定如何评估程序的行数，即以特定的语言编写的句子或表达式。其基本思想是为每种语言的符号都有一个分类。</p><p>使用场景：</p><p>数据库查询语言，比如SQL</p><p>用于描述通信协议的语言</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785135/1000" alt="img"></p><p>下面给出的表格总结了每种体系架构模式的优缺点。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211787148/1000" alt="img"></p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211788404/1000" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用计划管理提升团队效率和产能</title>
      <link href="/2020/09/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD/"/>
      <url>/2020/09/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本文根据沈剑老师在〖deeplus直播第237期〗线上分享演讲内容整理而成。</p></blockquote><p>大家好，我是快狗打车的产品技术设计团队的负责人沈剑，可能很多人通过“架构师之路”认识了我。在这些年里我身上肩负着架构师和团队领导者的身份，完成了不少系统的产品设计，也从一线管理者晋升到现在整个产研团队的总负责人。</p><p>其实在这个过程中需要设定很多目标，包括团队的目标、业务项目的目标和技术项目的目标。今天分享主要集中在让大家了解，作为一个管理者或项目经理可以通过哪些方法和工具去达成既定的目标。</p><p>如果你是一个团队的负责人，或者未来也希望成为团队负责人，又或者你正在带领业务和技术项目、正在参与项目且未来希望能够带领项目，那么我希望通过今天的分享能够帮助大家解决以下三个问题：</p><ul><li>如何达成既定目标；</li><li>如何制定计划；</li><li>实现团队目标。</li></ul><p><strong>前言</strong></p><p>在开始分享前，我在这里先抛出两个问题：</p><ul><li><strong>管理者的职责是什么？</strong></li></ul><p>我的理念是，作为一个管理者在面对上级、同事和下属的时候职责都是不一样的。</p><p>面对老板，我们必须完成给定的业务目标或者项目目标；面对同事，我们就要为队友赋能；而面对下属，我们不仅要帮助他们解决问题，还有帮助他们成长和提升，也就是帮他们搭舞台唱戏。以上是我认为，作为一个管理者要尽到的核心职责。</p><p>然而究其根本，管理者的职责其实是实现自己承诺的目标。面对老板就是要实现承诺的业务目标，对同事是实现对合作的承诺，对下属则是对你实现承诺的方法和资源。管理者并没有拥有很大的权力，多大程度上实现了承诺过的目标才是岗位价值的体现。分层次说的话，CEO要实现自己对业务总体目标的承诺，CTO要实现对产研项目、产品系统交付的承诺，而总监经理要实现对交付质量、技术体系建设、组织能力建设的承诺，员工也要实现对自己在项目、在系统中负责的稳定性、迭代、效率和质量的承诺。</p><p><strong>我们对管理者基本的要求，就是实现自己承诺的目标</strong>。如果目标没有达成，那这个管理者就是不合格的。</p><ul><li><strong>管理者如何实现目标？</strong></li></ul><p>达成目标的要素有老板的支持、清晰的目标、下属的能力、到位的监督等等，可能每个管理者实现自己目标的关键要素都不一样。</p><p>回想一下，我们在做项目的过程，是不是先定下项目目标，然后是项目负责人，接着拆解、监督跟进、风险评估和改进、过程改进？这个流程可能大家没有一个系统的说法，但它就是使用计划管理去实现目标的。整个定目标、做计划、行动、复盘、调整行动、达成目标的过程其实就是计划管理。特别是在效率交付这个方面，对负责的相关研发部门来说，计划管理极其重要。</p><p><strong>一、什么是计划管理</strong></p><p>1、计划管理</p><p>要做计划管理，那就要先说说什么是计划。计划就是目标及一步步实现目标的步骤。想看一个企业做得好不好，带领一个团队带得好不好，我们要重点看其是否养成了做计划的习惯，因为做计划是一个主动规划的过程。</p><p>但是很多人会说：“很多时候我只是被动地被安排工作啊，老板让我做什么我就做什么。”</p><p>被动安排工作，很可能是你的老板在做计划而你只是执行他的计划。很多的时候，业务变复杂了，团队也扩张了，很多管理者就不会做计划了，或者做好的计划就乱套了，这样对项目推进有很大的影响，所以我们必须养成做计划的习惯。</p><p>计划管理是我们做一切管理的基础，是达成目标的一个工具。</p><p>2、流程管理</p><p>我们知道做产研项目的项目流程是提需求、接需求、需求设计和评审、研发设计和评审、研发链条测试上线部署。</p><p>那么流程管理能解决什么问题呢？重点解决的问题不是说哪个人在哪个环节进行审批，而是大家的分工问题。我们要知道整个流程需要哪些岗位来配合工作，借此设置产品、研发、测试和运维的岗位。流程管理是用来确保人人有事做，事事有人做，并且在整个项目、业务流程中，每一个岗位都是明确的。</p><p>3、组织管理</p><p>组织管理的内容是确定权责，它主要解决了负责人必须有权，有权的人必须负责的这个问题。</p><p>在实际落地的管理工作过程中，如果推进流程清晰、岗位分工明确，那么组织管理的工作就会比较少；反之如果推进流程模糊、岗位分工也含糊，那么管理者就需要投入大量精力去解决关于流程的问题，去解决组织上需要权责清晰分明的问题。</p><p>实际工作中，花费在流程管理和组织管理的时间还是比较少的，更多的时间用在计划管理上，需要做好设定和达成目标的工作。计划管理、流程管理、组织管理分别解决不同的问题：</p><ul><li><strong>计划管理，</strong> 解决设计计划、明确目标、合理分解任务和达成目标的问题；</li><li><strong>流程管理，</strong> 解决流程和岗位要清晰，人人有事做，事事有人做的问题；</li><li><strong>组织管理，</strong> 解决权责问题，确保组织合理，做事的人有权、有权的人承担责任。</li></ul><p>这是基础管理最重要的三项内容，如果你要做更高阶的管理，往总监、VP、CTO的方向走的话，那么在管理工作中你还需要思考高阶的管理，比如说战略管理，我们要建设怎样的能力，又比如说文化管理，我们如何能够持续地建设能力并且在各个方向上文化都拥有战斗力。</p><p><strong>计划管理是我们做好一切的基础，是达成目标的方法。</strong>做好计划管理，基本上你就是一个80分的一线或者二线管理者。</p><p><strong>二、计划管理最佳适用范围</strong></p><p>问题：销售的目标是一个需要达成的销售额，销售额按月度考核，有的时候目标达成了而有的时候没有，那么我这个月需要怎样制定怎样销售额度。以上算不算计划管理？</p><p>答案：不算，这个例子更偏向于绩效管理。</p><p>对于直接为业务结果负责的部门，会特别注重绩效管理。但是对于不直接背负绩效管理指标的部门，绩效管理就不是这个部门的管理者最关注的的事情。像是最典型的研发部，它们为交付服务而存在，是一个注重效率的部门，要求快速、高质、高效地交付产品和系统。</p><p><strong>计划管理适合关注效率而非绩效的部门。</strong> 对这样的部门来说，其核心管理方法论就是计划管理。</p><p>还是典型的例子，对技术部门来说，他们的主要职责不是技术驱动业务的部分（少数公司例外），更多的是为交付而负责，确保高质量、高效、安全、低成本地做系统交付，十分注重过程和效率。所以计划管理非常适合像研发这样的团队去做管理。</p><p><strong>三、计划管理也是一个过程管理</strong></p><p>有一些团队拍着胸脯说：“你就不用管啦，我季度末给你结果！”</p><p>这不算过程管理，它虽然有目标有结果，但是却没有关注过程，所以它其实就是绩效管理。像这样“不用管，到时候保证给出结果”的情况在很多公司和团队中都存在，这种管理方式极其容易出现管理失控。</p><p>结果团队，例如销售的KPI管理的review周期比较短，通常以周或者月为维度来review销售结果，这严重依赖个人能力而不是制度或者流程。过程管理运用到研发团队身上的话，绩效考核一般来说粒度更粗，以季或者年为维度review结果，也就不大会出现“拍胸脯”的现象，以避免管理失控。</p><p>既然计划管理是一种方法和工具，想要做好管理就需要去多学习、多练习。那么如何培养好好的管理习惯？大家回想一下自己的编码习惯是怎么培养出来的，应该就是通过不断写代码而训练出来的。所以类比一下，对于计划管理也是一样的，我们需要养成做计划的习惯，刻意训练自己运用这种管理方式的习惯。</p><p>举个例子，比如我负责58到家的技术部，而且在2020年有一个“提效、为效率负责、为项目交付吞吐量负责”目标。首先我会和技术团队解释我们有这样的目标是因为它与我们的职责相关，然后明确目标的内容是“本季度或者本年的交付吞吐量要提升到20%，线上线下bug要降低多少”等等。</p><p>其实这就是要向你带领的团队明确我们<strong>为什么做、做什么和怎么做</strong>，以及其他细节：</p><ul><li><strong>为什么做？</strong> 为了提高效率；</li><li><strong>做什么？</strong> 建设技术体系；</li><li><strong>怎么做？</strong> 讨论现在效率的瓶颈是什么，找出项目流程中的主要矛盾到底是需求评审阶段、项目设计阶段、研发阶段、链条阶段还是上线阶段。哪个过程最耗时间，如果是需求评审阶段很低效，产品没想清楚，那么我们这个季度就会主要抓这个部分来提高效率；如果是上线阶段，我们没有好的工具和平台，都是依赖于人肉，整个过程都是主要矛盾的话就重点抓这一块；</li><li><strong>时间节点？</strong> 季度；</li><li><strong>负责人？</strong> 我，沈剑。</li></ul><p><strong>四、计划管理五要素</strong></p><p>看完之后其实会发现，上面说的<strong>做什么、为什么、怎么做、时间节点、责任人</strong>这些要素，不管是带领团队做产品项目、业务项目还是技术项目，在计划管理中就是最重要的五要素。为了方便大家记忆，计划管理五要素可以记成“他问我为何”，也就是<strong>Target、Why、When、Who、How（TWWWH）</strong>。</p><p>1、 <strong>T（Target）：</strong></p><ul><li>首先设定好目标；</li><li>其次这个目标必须承接战略和部门职责，比如说部门职责是提高效率、高质量、低成本、安全地交付。目标必须和职责相关。为什么要建设技术体系，一定是更高效、更高质量的和交付相关的。</li></ul><p><strong>2、W（Why）：</strong></p><ul><li>项目成立原因，比如研发团队的职责相关，所以要提高效率、建设技术体系、改进上线流程、改进产品协作流程等等；</li><li>这个点是负责人和管理者在做计划、传达的过程中最容易忽略的一个点。很多时候我们只跟大家同步业务目标和结果、项目目标和结果，但是没有传达为什么要做这件事情，这就导致了很多员工执行不到位。是因为他们在做这件事情的时候，本身就不认同这件事情的目标，也不知道为什么要做；</li><li>比如目标是技术体系建设，有些运维人员会觉得自动化运维工具会取代自己的岗位，他不认可这个目标。但是这个工具在平台建设中和部门职责息息相关，是必须要完成的事情。所以，在传达的时候要解释清楚这个工具会帮助运维团队提高工作效率，让他们有时间专注在其他关于自动化的工作上，而不是不断重复上线操作。这样，一旦他们认可你的目标之后，执行计划和配合工作才会更加顺畅。</li></ul><p><strong>3、W（When）：</strong></p><ul><li><p>时间点很重要，比如本季度或者今年要提升多少；</p></li><li><p>如果你说今年要完成5、6个项目，员工听着就会觉得时间粒度非常粗且不可控，会导致他们完成的信心指数非常低。如果把这个时间节点进一步细化和拆解，今年要完成5、6个项目，其中容器化项目实现需要12个步骤，并且每个动作需要1个月来完成。这样将时间点做了细致的拆解，听着相对可控，员工对于完成这个指标的信心指数就会比较高。又比如说这个项目需要2个星期上线，时间粒度粗所以项目风险也高，如果你说项目需要研发几个接口、每个链条和自测需要多长时间，时间拆解越细，老板对你完成这个计划的信心指数就高；</p></li><li><p>对于时间这一块想要强调的是，在做计划时尽可能将时间粒度拆解得细、最大程度明确动作，这样老板看完你的计划之后信心指数比较高，会觉得项目交给你之后他就不需要实时和你同步项目，他可以把精力放在别的项目上。</p></li></ul><p><strong>4、W（Who）：</strong></p><ul><li><p>在计划和管理中，责任人要对整个项目负责；</p></li><li><p>项目成功，就要奖励；项目失败，责任人就需要对项目负责。</p></li></ul><p><strong>5、H（How）：</strong></p><ul><li><p>分解、实施、review、复盘、改进行动计划以达成目标；</p></li><li><p>需要完成计划、明确目标、上传下达、提高老板信心指数；</p></li><li><p>举一个很粗粒度的例子，2019年我负责58到家的技术中心，当时老板向我提了一个要求，就是要提升团队的效率。提升团队的效率是在明确职责的前提下，相同的事情能够让更少的人去做，或者是人数不变的情况下承担更多的职责。我会首先，按季度粗粒度地将计划进行拆解：</p></li><li><p><strong>Q1：</strong> 在架构侧、中台侧、基础服务侧和企业平台侧，可能要做效能的提升；而运维侧和IT侧可能需要成立虚拟的组织，让更少的人能去做更多的事情。Q1要成立一个创新的部门，去做一些创新的事情，Q1可能只完成了一部分，等我把这一块拆解之后，就把这个目标给相关的总监，由他做更细化的拆解；</p></li><li><p><strong>Q2：</strong> 可能有两个部门的人效比较低，有人员的汰换或者质量部、效能部的重组架构调整，那我Q2主要抓这一块的矛盾；</p></li><li><p><strong>Q3：</strong> 有些部门反馈到数据部，觉得效率比较低，那么就要对大数据进行调整。同时创新的方面，又孵化出了一个保险业务；</p></li><li><p><strong>Q4：</strong> 我做了一级的拆解之后递归给下面的总监和经理做二级的拆解，可能最终年效提升了10%，节省40%的人完成过去相同的工作，又或者在人数不变的情况下，我还孵化了两个创新的产品。</p></li><li><p>我必须确保在我的管理范围内，所有人都知道我们的年度总目标是什么、为什么要做、计划是什么、每一块的负责人是谁、初步的规划怎么做。</p></li></ul><p>大家可以想想，你们的团队是否明确了今年整个技术部的目标，或者你们部门是否明确了目标，又或者你们最近一个项目的目标是什么。你的团队人员究竟是清清楚楚，还是简单地被分配和执行工作。</p><p>如果他们对目标不清楚或者不认可这个目标，在执行的过程中就很有可能出现很大的阻力，也会有很多的问题。</p><p>还有就是，你们到底有没有和他们讨论怎么做。很多人会这样说，“人效要提升40%”，那你没有具体拆解过的行动计划，如果没有那最后就是靠天看这个目标能不能达成。</p><p>有没有负责人和明确的时间点，在怎样的时间节点要达成怎样的目标。</p><p>所以TWWWH（他问我为何），目标、为什么、时间节点、负责人、怎么做这五项因素在做计划管理中非常重要。</p><p><strong>五、计划管理核心讨论什么</strong></p><p>1、怎么做很重要</p><p><strong>计划管理最核心应该讨论：怎么做。</strong></p><p>举个具体的例子，比如我所负责的快狗的技术中心的部门，Q2的项目吞吐量中一个效率指标要提升30%。我们初步定的目标是30%，挑战点的目标是50%，其实我们并没有花多大的精力去讨论目标是30%还是50%。但是很多同学在做计划的时候会很精细地计算到，“我要提升15%，我算过了，做A可以提升5%，做B可以提升5%，做C和做D可以提升5%，所以总体可以提升15%。”</p><p>我不知道大家在定OKR的时候是不是这样细算出来的。我们知道，制定OKR的时候要制定有挑战的目标，而且最好50%概率能够完成，也就是跳一跳能够得到的目标。</p><p>所以你要把效能提升30%还是35%还是50%，其实没那么重要。甚至很多业务，你问他的业务增长目标是怎么做出来的，这很有可能就是老大拍板的。</p><p>怎么做非常重要，在做计划管理的过程中我们应该把时间放在讨论怎么做上面，重点应该讨论行动计划的制定。</p><p>我们重点需要花时间去想，执行中可能会有的潜在困难、这些困难的解决方案，再配合定期的执行、校验和行动计划的更新。</p><p>2、如何复盘</p><p>定期的执行和检查，我也不知道大家会不会定期复盘项目，你们的项目复盘会怎么开，重点说什么，但你们想一想是不是下面这个样子：</p><p>首先摆数据，我们订单增长了多少、效能提升了多少、体系化项目进度是多少；然后找原因，解释这个地方为什么没有达成预期，去做各种各样的解释。这是一种非常错误的复盘会。当然找原因是必须的，但是你会发现你找到原因解释，对后续的改进没有任何意义，所以复盘会上要重点讨论什么呢？</p><p><strong>要重点讨论后续的行动计划、潜在风险、解决方案和行动的变更。</strong> 制定计划的时候要讨论行动计划和怎么做，复盘的时候也要重点讨论行动计划。之前做对了的我们要继续做，什么行动要保持，之前做错了什么或者什么没有做对，我们也要纠偏回来。</p><p>但是我参加过很多复盘会，这些会可能都和追责有关。很多复盘会做这样的工作，通篇都在解释为什么这个项目没有达成预期，不是我的原因而是别人的原因。</p><p>我又举个例子，我对Q2产品效能的提升定了一个50%的目标，最终目标完成了80%。Q2过去之后，我们要怎样复盘？</p><p>我们做对了什么？可能是组织架构调整了，目标更清晰了。原来一开会大家都在扯皮，说测试是瓶颈所以要加测试，说前端是瓶颈所以要加前端。我将组织架构调整成相对闭环的部门，业务里有一个研发小组，包含了测试、研发、前端和后端，那么原来沟通的成本就降低了，大家都看齐同一个业务目标，背一个业务指标，扯皮就减少了，沟通就更高效了，这样对项目提升可能有帮助。</p><p>最简单的方法，比如说五、六月份是战略重心，有几个战略项目都要上线。有些老大会说，“这两个技术团队的同学辛苦辛苦，周六来冲个刺。”这样可能团队多工作一天就提升了20%的效能，但我特别反对长期通过这种方式来提升迭代速度。我们还是要通过优化流程和工具去优化、提升速度。</p><p>又像刚刚说到的流程这一块，在项目流程过程中，原来在需求阶段可能存在问题但我没有改进，所以最终只提升了5个点。</p><p>或者说，原来上线都是通过人工，而现在用自动化的上线工具；原来搭建测试环境需要很长时间，现在通过自动化的方式去搭建测试环境，这样对效能的提升是肯定有帮助的。这方面就需要管理者了解当前的主要矛盾，并去解决这些主要矛盾。</p><p>如果你觉得人员技能不到位，那你就能要去做培训；你觉得不靠谱，那你就要做汰换。反正到了季度末我们复盘的时候，做对了的事情在下个季度就继续做，做错了的事情就要停止做，能够继续迭代的空间，我们就要去优化。</p><p>在计划管理的过程中，大家要多花时间去讨论行动计划，在复盘中讨论做对了什么、行动计划要改变什么，而不是单纯的质量和数字，以及解释、推脱或者甩锅，这样对后续达成目标没有什么帮助。所以我想表达的是，花时间的重头戏应该是制定行动计划。</p><p><strong>六、计划管理的两大特点</strong></p><p>1、目标不合理性</p><p>前面提到了怎样的OKR是好的OKR，如果你达成的概率是50%，50%概率不能达成，这个目标跳一跳就可以够得到，那这样的目标是好目标。</p><p>再举一个例子，Q2有一个项目是IDC或者叫集群，快狗侧可能有几百个集群原来做了过度的设计，微服务化拆分出了太多细粒度的服务，导致维护起来成本很高。那我们说Q2可能要做一些集群的合并和架构的优化。</p><p>当时项目有一个负责人，我让他提一个目标，他纠结了很长的时间，说我不知道集群要减少10%，还是15%，还是8%。但其实你会发现，不管这个值是多少，后面重点要花时间去讨论的是行动计划、怎么样合并集群、架构怎样更合理、以什么样的节奏去执行。其实目标是10%还是30%，和后面讨论的行动计划是没有关系的。所以后来我就说，那我定下20%这个值，然后Q2就按照这个目标去走，看Q2能不能达成20%的OKR。</p><p>OKR和KPI不一样。KPI达成与否跟你的涨薪或者跟你的绩效有关，但是OKR指定的是有挑战的OKR，所以你的leader一定要综合实现难度系数去打分。虽然说我拍了一个目标，但是因为我是一个技术专家，所以我在拍的过程中是有所谓的专业手感的，我并不是瞎拍的。</p><p>我实际是想了一下，20%的目标去做工作有一定的挑战，但就是能够实现的。在这个拍目标的过程中，能够体现我的专业手感。在一个专业领域里浸淫久了，拍目标的时候其实能够体现专业手感，IDC减少多少、效能提升多少、订单增长多少更合理，这些都能够体现你的专业手感。</p><p>总之，计划管理有一项特点是目标不合理，因为目标本身是一个预测，目标要符合战略的要求，而且目标更重要的是体现你对某一部分的决心。很多时候项目目标定下来了，团队管理反而简单了。有些团队之所以不出成果，是因为花了大量时间放在目标讨论上，而且在制定目标的过程中往往也提出了很多困难，去强调达成目标非常有挑战，并持续降低自己的目标，直到目标降低到自己有把握的程度。这个不是OKR，也不是计划管理。OKR不是在制定目标的时候有大概率能完成的感觉，而是一个有挑战的目标。</p><p>未来也希望大家在做计划管理的过程中，能够制定一个有50%概率能够完成的目标，这就是一个好的OKR目标。目标在制定的过程中也能够体现你的专业手感，所以如果你让一线的同学来这个事情会更不靠谱，因为一线的同学更多思考自己怎么才能不出错，所以你让他去定目标，一定是自己能够实现的。他们关注的更多是自己，可能不是业务或者公司的压力。</p><p>我们作为leader，有一项非常重要的要求，你要同时具备内外部视角。外部怎么看问题，你的老板希望你能达成什么目标。而很多一线的员工可能缺乏外部视角，他们可能更多思考的是做什么能够不出错，所以我要制定一个我能够完成的目标，这样我就能拿到奖金。这就是典型的KPI或者自我的思维。</p><p>计划管理的第一个特点，也是不必花太多时间精准地制定目标。很多时候大家精准地讨论目标，就会强调这个事情有多难、多有挑战，会持续地降低目标，直到降到一个自己有把握的目标。你想想，这样对团队的发展和对业务的发展，都是非常不利的。</p><p>2、行动计划的合理性</p><p>行动计划必须合理，你要花最多的时间在讨论行动计划上。</p><p>资源匹配要合理，如果你没有给我那么多的预算，我拿不到那么多的市场费用和流量，你也没有足够的研发团队，那你让我在一个月之内干出那么多系统，我做不到。所以行动计划的拆解必须是合理的。</p><p>下面举一个例子，快狗打车在做Q2的容器化项目来提升的自动化程度时有一个负责人，负责人是我们这边运维的总监，目标是Q2整个测试环境容器化全覆盖。</p><p>他就解释给团队听：</p><ul><li>为什么要做这件事情，你要提高效率，跟我们的职责相关；</li><li>时间节点是一个季度，我们要达成测试环境的覆盖，他就进行拆解，总共有200个集群，第一个月要覆盖80个，第一个星期要覆盖哪10个集群完成容器化；</li><li>每一块工作继续拆细，研发和运维团队要负责哪部分；</li><li>在季度初，他就做了一个计划管理，然后在每个月执行的过程中，以月为单位进行review。上个月我计划完成三分之一，那我有没有80个集群测试环境的三分之一Docker容器化覆盖？如果项目delay了，我要发现为什么项目delay了；如果有一块技术方案我们想得简单了，那有什么解决方案？如果我们后续的行动计划可能要改变，我们就得加进人手，让大家更重视或者晚上加一个小时班，这样去不断地调整自己的行动计划，不断复盘之前哪一块工作做得好，做对的要继续做，做错的要停止做，迭代优化要继续改进。</li></ul><p><strong>总结</strong></p><p><strong>1、</strong> <strong>对管理者最基本的要求，是对目标的承诺</strong></p><p>你能够承诺多大的目标，你的岗位就有多大的价值。</p><p>大家想一想，你能跟你的老板举手说我愿意背什么样的指标。你这句话承诺的指标，项目、系统、团队或者业务的一个指标，你都会发现跟你的岗位有关。你的职位越高你承诺的指标和负责的范围会越大。</p><p><strong>2、</strong> <strong>计划管理是一切管理的基础，计划管理也是目标达成的一个工具</strong></p><p>基础管理非常重要的几项：</p><ul><li>计划管理解决的是目标及目标达成工具的问题；</li><li>流程管理要确定核心的业务流程。产研侧的话就是项目流程，确定实现过程中的岗位、解决事事有人做，人人有事做的问题。大家可以去看看，你们的团队是不是缺某些岗位，观察有没有PMO岗等等；</li><li>组织管理确定权责的关系，解决负责的人必须有权，有权的人必须为结果负责的问题。</li></ul><p>流程管理，一旦流程确定岗位确定之后，我们在日常管理的过程中，再改流程的概率就会变小，你花在这个上面的比重也会小。组织管理也是一样的，一旦权责明确，组织架构明确。其实你调整的频率也是很小的，</p><p>所以基本上作为一个管理者，不管你是做项目管理还是团队管理，无论你是做业务项目还是技术项目，绝大部分的工作都应该花在计划管理上。</p><p>设定目标、设定行动计划、追踪行动计划，做好了计划管理就能做一个80分的管理者。</p><p><strong>3、</strong> <strong>计划管理，非常适合关注过程和效能的“非绩效部门”</strong></p><p>研发团队是典型的为交付、产品负责的“非绩效部门”。部门的职责是高效、高质、低成本、安全性地进行交付，这样的部门非常适合计划管理。所以理论上，这种部门的管理者绝大部分做计划管理都是定目标、做行动计划、review和达成。</p><p><strong>4、</strong> <strong>计划管理是一个过程管理</strong></p><p>过程管理对销售部门来说更多的是KPI导向，要完成多少的销售业绩，每个大区有每个大区的玩法，每个城市经理有每个城市经理的玩法，每个团队的执行过程都是不一样的。如果通过拍胸脯的方式，这样的团队review的频率或者是绩效考核频率可能会比较高，会以周或者月为单位。</p><p><strong>5、</strong> <strong>计划管理五要素：他问我为何（TWWWH）</strong></p><ul><li><strong>目标（T）；</strong></li><li><strong>为什么（W）：</strong> 这是Leader在管理的过程中很容易忽略的和下属和团队成员进行沟通的问题。Leader的职责是上传下达，很多时候你只是告诉他们业务目标是这个，项目交付时间是这个，但你没有告诉他，他为什么要做这个业务和项目，这样可能会引发团队成员的归属感或者疑虑。当他不认同这件事情的时候，他可能就会成为达成目标的一个反推力，所以这个部分非常重要；</li><li><strong>时间节点（W）：</strong> SMART法则，要有时间概念；</li><li><strong>责任人（W）：</strong> 责任人很重要。负责的人要有权，有权的人要负责，你有没有授予他协调资源和完成目标的权力也很重要；</li><li><strong>怎么做（H）：</strong> 为什么很多团队的目标无法达成，可能是在制定目标的时候只提到这个季度要提升50%，但是没有提及怎么提升50%。如果就这样做了再说吧，那到了季度末的时候整个管理是会是失控的，整个项目和业务达成也是失控的。整个过程的初期中最核心要讨论的就是怎么达成，而不是你的目标到底是10%还是15%。</li></ul><p><strong>6、</strong> <strong>计划管理中，核心要讨论怎么做</strong></p><p><strong>7、</strong> <strong>计划管理两大特点：</strong></p><ul><li><strong>目标的不合理性：</strong> 不要花太多时间在讨论目标上，定一个50%概率能达成的、跳一跳就能够达成的目标是最合适的；</li><li><strong>行动计划的合理性：</strong> 行动计划和资源匹配必须是合理的，不能是不切实际的。</li></ul><p><strong>团队管得好不好，可以看大家有没有养成“计划管理”的习惯！</strong> 如果你做的不好，大概率是季度初制定了目标，但不做行动计划、不做review复盘，季度末达成还是不达成，就全靠天。所以我也要求我的团队在各块工作都需要做计划管理，初期讨论行动计划，review整个过程，而不是找借口和做推脱，并且季度末也会根据他工作的难度系数给予他应得的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 VLAN、三层交换机、网关、DNS、子网掩码、MAC地址</title>
      <link href="/2020/08/26/%E7%BD%91%E7%BB%9C/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%20VLAN%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/08/26/%E7%BD%91%E7%BB%9C/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%20VLAN%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p><strong>一、什么是vlan?</strong></p><p>VLAN中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p><p>听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分vlan？</p><p><strong>这里举个例：通俗的了解</strong></p><p>一所高中，新学期高一招了800个学生，这800个学生，如果放在一个班里，那肯定是管理不过来，面对800个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从800份信息中去找，极其麻烦，浪费时间；</p><p>而实际中，也是一样，电脑A要想要与电脑B通信，于是电脑A就需要发送arp请求，而网络中电脑众多，最终ARP请求会被转发到同一网络中的所有电脑，才能找到电脑B，如此一来，为了找到电脑B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。</p><p><strong>那么怎么办呢？</strong></p><p>学校就针对这800个学生，分成了10个班，每个班80人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。</p><p>1101表示一班01号学生。</p><p>1102表示一班02号学生。</p><p>1201表示2班01号学生。</p><p>同一个班的学生编号尾数不同，其它的都相同。</p><p>那么这样老师再管理起来就轻松多了，可以把一班这80人管理的妥妥的，隔壁2班与3班乱成一锅粥也不管一班的事，我就要这一班80人好好上课就行。</p><p>这就是vlan，每个班就相当于一个vlan，而每个班名称，就相当于vlan的名称，而每个学生的编号就是ip地址；同班同学（同一个vlan的ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。</p><p>所以同一个vlan间，可以相互通信；不同vlan，若不做配置，不能相互通信。</p><p>搜索公众号程序员小乐回复关键字“offer”获取算法面试题和答案。</p><p>那么不同vlan如何通通信呢？就需要单臂路由与三层交换机。</p><p><strong>二、单臂路由与三层交换机</strong></p><p>我们知道要实现不同vlan间通信，就必须需要有路由功能，不同VLAN之间相互通信的两种方式（单臂路由、三层交换机）。</p><p><strong>什么是单臂路由？</strong></p><p>单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同vlan间的可以互相通信。</p><p><img src="https://aimak.cn/blog_img/tools/network/danbituopu.jpeg"></p><p><strong>那什么是三层交换机呢？</strong></p><p>对于小型的网络，单臂路由可以应付，但随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。</p><p>为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。</p><p>关于三层交换机的内部结构，可以参照下面的简图。</p><p><img src="https://aimak.cn/blog_img/tools/network/sanceng.png"></p><p>在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。</p><p><strong>三、什么是网关</strong></p><p>在了解了vlan与三层交换机后，能不能通信，还需要看网关是否正确。</p><p><strong>一、什么是网关</strong></p><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p><strong>二、如何来理解网关</strong></p><p>大家都知道，从一个房间走到另一个房间，必然要经过<strong>一扇门</strong>。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“<strong>关口</strong>”。</p><p>按照不同的分类标准，网关也有很多种。TCP&#x2F;IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP&#x2F;IP协议下的网关。</p><p><strong>三、网关的ip地址</strong></p><p><strong>那么网关到底是什么呢？</strong></p><p>网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用<strong>ip中选一个</strong>，不过，一般用的是<strong>第1个和最后一个</strong>。</p><p><strong>例如</strong></p><p>比如有网络A和网络B，</p><p><strong>网络A：</strong>的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p><strong>网络B：</strong>的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p>  <img src="https://aimak.cn/blog_img/tools/network/ipaddr.jpeg"></p><p><strong>四、网关是如何实现通信？</strong></p><p>在没有<strong>路由器</strong>的情况下，不同的两个网络之间是<strong>不能</strong>进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则<strong>必须通过网关</strong>。</p><p>如果<strong>网络A</strong>中的主机发现<strong>数据包</strong>的目的主机<strong>不在</strong>本地网络中，就把数据包转发给它<strong>自己的网关</strong>，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。</p><p>所以说，只有设置好网关的<strong>IP地址</strong>，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。</p><p><strong>五、什么是默认网关？</strong></p><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。<strong>默认网关</strong>的意思是一台主机如果找不到可用的网关，就把数据包发给默认<strong>指定的网关</strong>，由这个网关来处理数据包。现在<strong>主机</strong>使用的网关，一般指的是默认网关。 </p><p><strong>四、什么是DNS</strong></p><p>DNS是域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>搜索公众号程序员小乐回复关键字“Java”获取Java面试题和答案。</p><p>DNS说白了是把域名翻译成IP地址用的，这里面<strong>举个例子</strong>，大家就很容易清楚了。</p><p>例如我们在浏览器里面输入<a href="http://www.baidu.com的时候,机器要跟百度这个网站进行**通信**,机器要往外面**发送**数据包,数据包里面要写百度这台服务器的**ip地址**,我们不知道ip地址是多少,那么就需要主机**问dns服务器**,dns服务器就自动帮我们把www.baidu.com这个域名**翻译成**了ip地址61.135.169.105.然后写到了数据包的目的ip地址里面就可以进行通信./">www.baidu.com的时候，机器要跟百度这个网站进行**通信**，机器要往外面**发送**数据包，数据包里面要写百度这台服务器的**IP地址**，我们不知道IP地址是多少，那么就需要主机**问DNS服务器**，DNS服务器就自动帮我们把www.baidu.com这个域名**翻译成**了IP地址61.135.169.105。然后写到了数据包的目的IP地址里面就可以进行通信。</a></p><p>就跟我们写信一样，你得写个收信人的<strong>地址</strong>邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是DNS的作用，所以你的在本地连接里面写DNS才可以正常浏览网页，如果不设置DNS，是无法正常访问网页的。</p><p><strong>五、MAC地址</strong></p><p>讲到MAC地址，就不得不提ip地址，这里顺便把ip地址也说下。</p><p><strong>IP与MAC</strong></p><p>虽然现在已经ipv6了，但我们基本用的大多数还是ipv4协议，所谓ip就是你电脑整个<strong>网络的编号</strong>。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在<strong>变化</strong>的。唯一不变的是你的MAC地址：<strong>物理地址</strong>。</p><p>MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>做个比喻，你经常搬家，你没搬一次家都有一个地址，XX小区XX单元XX号，这个就是IP。但是你的名字不变，这个就是MAC，不同的是我们的<strong>MAC不允许重名。</strong></p><p><strong><img src="https://aimak.cn/blog_img/tools/network/mac_info.jpeg"></strong></p><p><strong>我们的IP分为两个部分：</strong>如上图分为<strong>网络部分</strong>和<strong>主机部分</strong>。网络部分好比就是你在XX省XX市XX镇，这个是国家固定下来了的。但是XX小区XX单元XX号是开发商自己定的。两个编号<strong>加起来</strong>就是你的ip了。不同的是在现实中两个编号的长度是固定的，在网络上A、B、C、D的ip地址却是变化的，这个在前天有详细讲到。</p><p><strong>六、子网掩码</strong></p><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由<strong>网络部分</strong>和<strong>主机部分。</strong>正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><p><strong>举个例子</strong></p><blockquote><p> <strong>有一个网段</strong>是192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p></blockquote><blockquote><p> <strong>另外有一个网段，</strong>是192.168.0.0——192.168.255.254，我们叫它<strong>安村</strong>，村里有个同样有两个ip地址为92.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？</p></blockquote><blockquote><p> 这个时候就需要<strong>子网掩码</strong>了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是255.255.255.0，<strong>安村</strong>的网段是255.255.0.0。</p></blockquote><blockquote><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 工具包Hutool</title>
      <link href="/2020/08/13/java/Java%20%E5%B7%A5%E5%85%B7%E5%8C%85Hutool/"/>
      <url>/2020/08/13/java/Java%20%E5%B7%A5%E5%85%B7%E5%8C%85Hutool/</url>
      
        <content type="html"><![CDATA[<p>Hutool 谐音 “糊涂”，寓意追求 “万事都作糊涂观，无所谓失，无所谓得” 的境界。</p><p>Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以 “甜甜的”。Hutool 最初是我项目中 “util” 包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。（抄自作者简介）</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一个 Java 基础工具类，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类，同时提供以下组件：</p><ul><li>hutool-aop JDK 动态代理封装，提供非 IOC 下的切面支持</li><li>hutool-bloomFilter 布隆过滤，提供一些 Hash 算法的布隆过滤</li><li>hutool-cache 缓存</li><li>hutool-core 核心，包括 Bean 操作、日期、各种 Util 等</li><li>hutool-cron 定时任务模块，提供类 Crontab 表达式的定时任务</li><li>hutool-crypto 加密解密模块</li><li>hutool-db JDBC 封装后的数据操作，基于 ActiveRecord 思想</li><li>hutool-dfa 基于 DFA 模型的多关键字查找</li><li>hutool-extra 扩展模块，对第三方封装（模板引擎、邮件等）</li><li>hutool-http 基于 HttpUrlConnection 的 Http 客户端封装</li><li>hutool-log 自动识别日志实现的日志门面</li><li>hutool-script 脚本执行封装，例如 Javascript</li><li>hutool-setting 功能更强大的 Setting 配置文件和 Properties 封装</li><li>hutool-system 系统参数调用封装（JVM 信息等）</li><li>hutool-json JSON 实现</li><li>hutool-captcha 图片验证码实现</li></ul><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>这两天使用 Hutool 把 Halo 里面的一些代码给替换掉了，不得不说，用起来十分顺心，下面简单介绍一下我用到的一些 Hutool 的工具类。</p><h3 id="SecureUtil（加密解密工具）"><a href="#SecureUtil（加密解密工具）" class="headerlink" title="SecureUtil（加密解密工具）"></a>SecureUtil（加密解密工具）</h3><p>主要是在登录的时候还有修改密码的时候用到的，因为数据库里面的密码是 md5 加密处理的，所以登录的时候需要先加密之后再到数据库进行查询，使用 Hutool 的话，只需要调用 <code>SecureUtil</code> 中的 md5 方法就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = userService.userLoginByName(loginName,SecureUtil.md5(loginPwd));</span><br></pre></td></tr></table></figure><h3 id="HtmlUtil（HTML-工具类）"><a href="#HtmlUtil（HTML-工具类）" class="headerlink" title="HtmlUtil（HTML 工具类）"></a>HtmlUtil（HTML 工具类）</h3><p>这个工具类就比较厉害了，不过我在 Halo 当中用得最多的还是 <code>HtmlUtil.encode</code>，可以将一些字符转化为安全字符，防止 xss 注入和 SQL 注入，比如下面的评论提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comment.setCommentAuthor(HtmlUtil.encode(comment.getCommentAuthor()));</span><br></pre></td></tr></table></figure><p>这就是防止有小坏蛋故意写一些可执行的 js 代码，然后提交评论，在后台面板就会执行这一段代码，比较危险，使用 encode 方法就可以将 <code>标签给转化成</code>，这样转化之后，js 代码就不会执行了。</p><p>另外，HtmlUtil 还提供了以下方法，有兴趣的可以去试一下。</p><ul><li>HtmlUtil.restoreEscaped 还原被转义的 HTML 特殊字符</li><li>HtmlUtil.encode 转义文本中的 HTML 字符为安全的字符</li><li>HtmlUtil.cleanHtmlTag 清除所有 HTML 标签</li><li>HtmlUtil.removeHtmlTag 清除指定 HTML 标签和被标签包围的内容</li><li>HtmlUtil.unwrapHtmlTag 清除指定 HTML 标签，不包括内容</li><li>HtmlUtil.removeHtmlAttr 去除 HTML 标签中的属性</li><li>HtmlUtil.removeAllHtmlAttr 去除指定标签的所有属性</li><li>HtmlUtil.filter 过滤 HTML 文本，防止 XSS 攻击</li></ul><h3 id="CronUtil（定时任务）"><a href="#CronUtil（定时任务）" class="headerlink" title="CronUtil（定时任务）"></a>CronUtil（定时任务）</h3><p>这个工具就更厉害了，完全不需要类似 <code>quartz</code> 这样的框架来做定时任务，而且 CronUtil 也不需要任何其他依赖，只需要在 resources 下建一个配置文件，然后在程序启动的时候将定时任务开启就行了，如 Halo 的定时备份功能（每天凌晨 1 点备份一次）。</p><p>cron.setting:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupResources = 0 0 1 * * ?</span><br><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupDatabase = 0 0 1 * * ?</span><br><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupPosts = 0 0 1 * * ?</span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextRefreshedEvent event)&#123;</span><br><span class="line"> this.loadActiveTheme();</span><br><span class="line"> this.loadOptions();</span><br><span class="line"> this.loadFiles();</span><br><span class="line"> this.loadThemes();</span><br><span class="line"> //启动定时任务</span><br><span class="line"> CronUtil.start();</span><br><span class="line"> log.info(&quot;定时任务启动成功！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用方法请看文档 <a href="http://hutool.mydoc.io/?t=255673">http://hutool.mydoc.io/?t=255673</a></p><blockquote><p>好了，就介绍这三个工具类，有兴趣的可以去试试其他的工具，挺全的，这应该是我用过最好用的一个工具类库了，值得一试。</p></blockquote><p>官网地址：<a href="http://www.hutool.cn/">http://www.hutool.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术管理者管理模板总结</title>
      <link href="/2020/07/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E7%AE%A1%E7%90%86%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E7%AE%A1%E7%90%86%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="看方向"><a href="#看方向" class="headerlink" title="看方向"></a><strong>看方向</strong></h2><ul><li>向上级明确团队的职责</li><li>基于职责确定团队的使命、目标</li><li>把职责、使命向团队成员传达清楚</li><li>做好团队规划，包括：规模、分工、梯队、资源盘点等</li><li>建立团队的WIki，包括：职责、使命、目标、团队规划、人员分工、规章制度等</li></ul><h2 id="管事"><a href="#管事" class="headerlink" title="管事"></a><strong>管事</strong></h2><ul><li><p>OKR</p></li><li><ul><li>制定团队OKR，对齐公司和部门OKR</li><li>跟进团队成员的个人OKR制定和进度跟踪</li><li>跟踪OKR进展，识别高绩效人才</li></ul></li><li><p>技术管理</p></li><li><ul><li><p>参与技术方向决策，将研发规范、例会等信息明确传达给团队成员并推进</p></li><li><ul><li>技术评审规范</li><li>代码风格规范</li><li>代码开发规范</li><li>代码管理规范</li><li>CodeReview规范</li></ul></li><li><p>组织技术评审、CodeReview</p></li><li><p>制定学习分享机制并切实推行</p></li><li><p>团队所负责维护的系统的周期巡检</p></li><li><p>公司层面基础技术以及成熟开源项目的引入和推进</p></li></ul></li><li><p>项目管理</p></li><li><ul><li><p>创建并保持项目文档的更新</p></li><li><ul><li>需求文档</li><li>技术调研文档</li><li>方案选型文档</li><li>系统设计文档</li></ul></li><li><p>根据技术评审的结果预估开发工期并做好关键时间点的把控</p></li><li><ul><li>系统、模块、功能的设计以及简述</li><li>参与的研发人员以及分工</li><li>预估工时</li><li>预计完成时间</li><li>关键时间点、里程碑</li><li>确定会议机制：晨会、周会</li></ul></li><li><p>技术方案确定</p></li><li><ul><li>技术选型</li><li>技术架构</li><li>技术难点</li><li>性能瓶颈</li><li>上下游系统</li><li>功能模块</li></ul></li><li><p>项目风险管理</p></li><li><p>项目质量管理，包括代码质量把控和监控告警设施的接入</p></li><li><p>协调资源推进项目进展</p></li></ul></li><li><p>技术产品运营</p></li><li><ul><li>提炼团队项目的公共抽象部分，组件化和平台化</li><li>组件、技术平台的推广</li></ul></li><li><p>成本管理</p></li><li><ul><li>技术选型时把成本做为重要考量项</li><li>提升团队资源的利用率</li><li>关注团队的人力成本和技术成本</li><li>关注团队的产出价值</li></ul></li><li><p>流程改进</p></li><li><ul><li>定位阻碍研发的流程节点，寻找有效的解决方案</li><li>寻求有效工具或者方案提升关键流程效率</li></ul></li><li><p>制度建设</p></li><li><ul><li>明确公司和部门的规章制度并推进实行</li><li>根据团队需要，制定团队规章制度</li><li>制定SOP，保障下限水准</li><li>明确团队例会制度</li></ul></li></ul><h2 id="管人"><a href="#管人" class="headerlink" title="管人"></a><strong>管人</strong></h2><ul><li><p>定期的一对一沟通</p></li><li><ul><li>你所负责业务的完成情况到现在怎么样？目标完成情况怎么样？</li><li>这段时间自我评价绩效如何？什么原因？</li><li>你个人有没有什么你觉得我应该知道的？</li></ul></li><li><p>关注团队成员职业规划和能力成长，给与指导和建议</p></li><li><p>关注团队成员工作状态</p></li><li><p>组织团建，提高团队凝聚力</p></li></ul><h2 id="管理仪表盘"><a href="#管理仪表盘" class="headerlink" title="管理仪表盘"></a><strong>管理仪表盘</strong></h2><p>建立自己的管理仪表盘，关注关键数据</p><ul><li>系统监控数据（QPS、硬件资源使用率、错误数等）-&gt; 提前发现系统瓶颈，消除隐患；提高资源利用率，降低成本</li><li>项目构建报告（单元测试覆盖率报告、代码质量报告、构建失败与成功概况）-&gt; 关注项目研发质量，保障持续交付</li><li>项目&#x2F;任务进度 -&gt; 保证项目&#x2F;任务正常进行</li><li>业务关键数据指标 -&gt; 关注业务价值，提升团队成员成就感</li><li>OKR进度 -&gt; 关注OKR实现状况，识别高绩效人员</li><li>团队成员的每日&#x2F;周的工作状况 -&gt; 关注团队成员状况</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中设置了过期时间的Key，需要注意哪些问题</title>
      <link href="/2020/07/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Redis%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84Key%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Redis%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84Key%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>熟悉Redis的同学应该知道，Redis的每个Key都可以设置一个过期时间，当达到过期时间的时候，这个key就会被自动删除。</p><h2 id="在为key设置过期时间需要注意的事项"><a href="#在为key设置过期时间需要注意的事项" class="headerlink" title="在为key设置过期时间需要注意的事项"></a><strong>在为key设置过期时间需要注意的事项</strong></h2><p><strong>1、 DEL&#x2F;SET&#x2F;GETSET等命令会清除过期时间</strong></p><p>在使用DEL、SET、GETSET等会覆盖key对应value的命令操作一个设置了过期时间的key的时候，会导致对应的key的过期时间被清除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//设置mykey的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; set mykey hello ex 300</span><br><span class="line">OK</span><br><span class="line">//查看过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) 294</span><br><span class="line">//使用set命令覆盖mykey的内容</span><br><span class="line">127.0.0.1:6379&gt; set mykey olleh</span><br><span class="line">OK</span><br><span class="line">//过期时间被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><p><strong>2、INCR&#x2F;LPUSH&#x2F;HSET等命令则不会清除过期时间</strong></p><p>而在使用INCR&#x2F;LPUSH&#x2F;HSET这种只是修改一个key的value，而不是覆盖整个value的命令，则不会清除key的过期时间。</p><p>INCR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//设置incr_key的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; set incr_key 1 ex 300</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl incr_key</span><br><span class="line">(integer) 291</span><br><span class="line">//进行自增操作</span><br><span class="line">127.0.0.1:6379&gt; incr incr_key</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get incr_key</span><br><span class="line">&quot;2&quot;</span><br><span class="line">//查询过期时间，发现过期时间没有被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl incr_key</span><br><span class="line">(integer) 277</span><br></pre></td></tr></table></figure><p>LPUSH：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//新增一个list类型的key，并添加一个为1的值</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 1</span><br><span class="line">(integer) 1</span><br><span class="line">//为list设置300s的过期时间</span><br><span class="line">127.0.0.1:6379&gt; expire list 300</span><br><span class="line">(integer) 1</span><br><span class="line">//查看过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl list</span><br><span class="line">(integer) 292</span><br><span class="line">//往list里面添加值2</span><br><span class="line">127.0.0.1:6379&gt; lpush list 2</span><br><span class="line">(integer) 2</span><br><span class="line">//查看list的所有值</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">//能看到往list里面添加值并没有使过期时间清除</span><br><span class="line">127.0.0.1:6379&gt; ttl list</span><br><span class="line">(integer) 252</span><br></pre></td></tr></table></figure><p><strong>3、PERSIST命令会清除过期时间</strong></p><p>当使用PERSIST命令将一个设置了过期时间的key转变成一个持久化的key的时候，也会清除过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set persist_key haha ex 300</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl persist_key</span><br><span class="line">(integer) 296</span><br><span class="line">//将key变为持久化的</span><br><span class="line">127.0.0.1:6379&gt; persist persist_key</span><br><span class="line">(integer) 1</span><br><span class="line">//过期时间被清除</span><br><span class="line">127.0.0.1:6379&gt; ttl persist_key</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><p><strong>4、使用RENAME命令，老key的过期时间将会转到新key上</strong></p><p>在使用例如：RENAME KEY_A KEY_B命令将KEY_A重命名为KEY_B，不管KEY_B有没有设置过期时间，新的key KEY_B将会继承KEY_A的所有特性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//设置key_a的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; set key_a value_a ex 300</span><br><span class="line">OK</span><br><span class="line">//设置key_b的过期时间为600s</span><br><span class="line">127.0.0.1:6379&gt; set key_b value_b ex 600</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key_a</span><br><span class="line">(integer) 279</span><br><span class="line">127.0.0.1:6379&gt; ttl key_b</span><br><span class="line">(integer) 591</span><br><span class="line">//将key_a重命名为key_b</span><br><span class="line">127.0.0.1:6379&gt; rename key_a key_b</span><br><span class="line">OK</span><br><span class="line">//新的key_b继承了key_a的过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl key_b</span><br><span class="line">(integer) 248</span><br></pre></td></tr></table></figure><p>这里篇幅有限，我就不一一将key_a重命名到key_b的各个情况列出来，大家可以在自己电脑上试一下key_a设置了过期时间，key_b没设置过期时间这种情况。</p><p><strong>5、使用EXPIRE&#x2F;PEXPIRE设置的过期时间为负数或者使用EXPIREAT&#x2F;PEXPIREAT设置过期时间戳为过去的时间会导致key被删除</strong></p><p>EXPIRE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key_1 value_1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key_1</span><br><span class="line">&quot;value_1&quot;</span><br><span class="line">//设置过期时间为-1</span><br><span class="line">127.0.0.1:6379&gt; expire key_1 -1</span><br><span class="line">(integer) 1</span><br><span class="line">//发现key被删除</span><br><span class="line">127.0.0.1:6379&gt; get key_1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>EXPIREAT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key_2 value_2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key_2</span><br><span class="line">&quot;value_2&quot;</span><br><span class="line">//设置的时间戳为过去的时间</span><br><span class="line">127.0.0.1:6379&gt; expireat key_2 10000</span><br><span class="line">(integer) 1</span><br><span class="line">//key被删除</span><br><span class="line">127.0.0.1:6379&gt; get key_2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>6、EXPIRE命令可以更新过期时间</strong></p><p>对一个已经设置了过期时间的key使用expire命令，可以更新其过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//设置key_1的过期时间为100s</span><br><span class="line">127.0.0.1:6379&gt; set key_1 value_1 ex 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key_1</span><br><span class="line">(integer) 95</span><br><span class="line">//更新key_1的过期时间为300s</span><br><span class="line">127.0.0.1:6379&gt; expire key_1 300</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key_1</span><br><span class="line">(integer) 295</span><br></pre></td></tr></table></figure><p>在Redis2.1.3以下的版本中，使用expire命令更新一个已经设置了过期时间的key的过期时间会失败。并且对一个设置了过期时间的key使用LPUSH&#x2F;HSET等命令修改其value的时候，会导致Redis删除该key。</p><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h2><p>那你有没有想过一个问题，Redis里面如果有大量的key，怎样才能高效的找出过期的key并将其删除呢，难道是遍历每一个key吗？假如同一时期过期的key非常多，Redis会不会因为一直处理过期事件，而导致读写指令的卡顿。</p><p>这里说明一下，Redis是单线程的，所以一些耗时的操作会导致Redis卡顿，比如当Redis数据量特别大的时候，使用keys * 命令列出所有的key。</p><p>实际上Redis使用懒惰删除+定期删除相结合的方式处理过期的key。</p><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a><strong>懒惰删除</strong></h3><p>所谓懒惰删除就是在客户端访问该key的时候，redis会对key的过期时间进行检查，如果过期了就立即删除。</p><p>这种方式看似很完美，在访问的时候检查key的过期时间，不会占用太多的额外CPU资源。但是如果一个key已经过期了，如果长时间没有被访问，那么这个key就会一直存留在内存之中，严重消耗了内存资源。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h3><p>定期删除的原理是，Redis会将所有设置了过期时间的key放入一个字典中，然后每隔一段时间从字典中随机一些key检查过期时间并删除已过期的key。</p><p>Redis默认每秒进行10次过期扫描：</p><ol><li>从过期字典中随机20个key</li><li>删除这20个key中已过期的</li><li>如果超过25%的key过期，则重复第一步</li></ol><p>同时，为了保证不出现循环过度的情况，Redis还设置了扫描的时间上限，默认不会超过25ms。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://redis.io/commands/expire#expire-accuracy">https://redis.io/commands/expire#expire-accuracy</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云端研发新基建：Serverless 与持续架构服务落地实践</title>
      <link href="/2020/06/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%91%E7%AB%AF%E7%A0%94%E5%8F%91%E6%96%B0%E5%9F%BA%E5%BB%BA%EF%BC%9AServerless%20%E4%B8%8E%E6%8C%81%E7%BB%AD%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/06/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%91%E7%AB%AF%E7%A0%94%E5%8F%91%E6%96%B0%E5%9F%BA%E5%BB%BA%EF%BC%9AServerless%20%E4%B8%8E%E6%8C%81%E7%BB%AD%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>云时代创新核心要素</strong></p><p>首先，让我们快速将视野放大到社会商业爆炸式增长的云时代，无论是创业公司还是发展中的公司，都希望能有一个低成本、可持续支撑的架构服务，帮助自己的业务持续发展，用户流量从小到大，无需变更架构，更不用中断业务。</p><p>这种架构服务诉求背后的核心痛点体现在业务快速试错与流量快速增长之间的矛盾。如果从传统的架构方式去思考，这个问题很难调和：</p><ul><li>如果要快速奔跑，就没有时间好好思考设计架构。</li><li>如果架构设计不好，就无法支撑未来巨大的流量。</li><li>而如果花时间把架构设计好再动手，就没办法快速奔跑，很可能错过一个商业创新的时间窗口。</li><li>另外，还有一个未知的疑问，这个设计好的架构真的够好么？</li></ul><p>结合我们之前的探索实践，我们知道，借助云原生 Serverless 的能力：实时弹性、按量付费，正好可以帮助我们把上述问题提升到一个新的维度去解决：业务完全可以放飞自我快速奔跑，架构服务由云原生 Serverless 矩阵来提供，保证流量再大也不怕。</p><p><strong>中小研发生态现状</strong></p><p>基于上述的一个判断，我们认为，现代商业社会的启动过程：从一个 idea 的诞生，到快速试错，再到上线服务用户的过程，有了一个很好的方案去支撑。但是，就像布道师们经常讲的一句话，人人都在谈云原生 Serverless，实际上并不是人人都知道怎么落地 Serverless。我们不妨来看几个真实的创业公司案例。</p><p><strong>案例一 天猫精灵技能业务</strong></p><p>天猫精灵的技能应用开发本身与天猫精灵开发者平台之前的连接较为松散，技能应用的开发对于一个中小开发者而言，启动成本较高。开发技能应用过程中的技术栈和方案也因人而异，因团队而异，也由于广大的开发者对技能应用背后的大流量没有一个一致的高水位保障，使得天猫精灵平台在做推广的时候也经常遇到阻力，担心在推广之后，很多技能无法承载大量涌入的活动流量，反而影响活动效果。</p><p><strong>案例二 某直播互动健身创业公司</strong></p><p>Y 公司是一家面对面直播互动健身的创业公司，研发团队的构成有 2 个前端、2 个后端、1 个架构师、1 个 iOS、1 个产品经理、1 个设计师，产品的构成有微信小程序、iOS APP、Android APP、PC 端 WEB 应用。</p><p>当前的核心痛点及诉求：</p><ul><li><p>研发成本、架构人员的浪费（这已经算是幸福的烦恼了，很多公司是找不到合格的架构师的）。</p></li><li><p>新人落地的成本（每个新人都有 3 个月的熟悉环境、流程、业务的成本）。</p></li><li><p>自研自建业务架构的成本，要等业务架构确定后才能动手。</p></li><li><p>业务线切换的沉默成本比较高，如新业务启动到上线：技术架构的选型、服务的复用等等都是损耗。</p></li><li><p>运维成本，如：承接推活动来的高峰流量以及平时流量的平均成本。</p></li></ul><p><strong>案例三 某软件外包服务商</strong></p><p>O 公司是一家 base 杭州的软件外包服务商，他们的研发团队构成为：5 个 Java、4 个前端、1 个 iOS、1 个 Android、1 个产品经理、2 个测试、5 个商务、6 个品牌、2 个 UI 设计；</p><p>当前的核心痛点及诉求：</p><ul><li><p>10 人以下规模来什么做什么，没有沉淀，没有办法复用，没有高的盈利回报，人都铺在业务上，没时间学习架构，进入了一个恶性循环，需要一个很低的成本去采用一个先进的技术架构方案，确保不落伍，同时可以继续聚焦业务开发；有了可复用的空间（如架构、组件、服务）才有盈利的空间。10 人以下的外包公司，CTO 是不太可能去招的，40 万一年的话，公司一半的利润就没了。</p></li><li><p>想依托于云，不过每家云厂商都产品众多，围绕自己的业务怎么知道有哪些产品适合，要一个个去挑选、学习，整体成本太高。</p></li></ul><p><strong>核心要解决的问题以及产品化思考</strong></p><p>我们将上述调研的客户反馈诉求进行梳理，可以归纳出以下几点诉求：</p><ul><li><p>人员、业务尽可能做到快速启动，低成本启动。开发人员能够快速进入业务开发，架构师能省就省，业务能够基于行业现有解决方案、基本业务架构、业务模块尽快启动。</p></li><li><p>开发人员的时间尽可能投入到业务开发中，但同时要保证业务所用技术架构的先进性：一个人的时间是恒定的，如何帮助中小企业把人员投入业务的时间从 60% 提高到 99%，同时还能确保业务背后所用的技术栈及技术架构是行业内广受认可的。</p></li><li><p>线上业务能够做到按量付费：1、业务的流量高峰不会成为业务增长的瓶颈；2、类似于外包服务商&#x2F;ISV，可以为他们的客户灵活制定弹性的服务体系。</p></li></ul><p>基于以上三点，我们进一步抽象用户群体以及场景和服务策略：</p><p><strong>主要用户群体</strong></p><ol><li>中小体量研发团队及创业公司研发团队</li><li>要做开发生态的业务或平台</li><li>行业软件&#x2F;解决方案 ISV&#x2F;服务商</li></ol><p><strong>场景和服务策略</strong></p><p>在快速商业化试错的创新创业场景下，通过集成设计以阿里云 Serverless 产品线为矩阵的业务架构，帮助用户快速迭代业务，同时保证业务上线后无需变更架构就可以持续支撑不断增长的流量，确保业务不中断，提高试错效率，降低试错成本。</p><p>在研发人员需要支持多业务线切换调度的场景下，通过集成云效研发协同底座的能力构建在线研发团队，通过设计解决方案实例化的能力构建统一应用开发环境，降低开发者在业务切换中的沉默成本，让开发者可以快速且专注地进入业务逻辑的开发，提高研发效率。</p><p>在需要快速启动业务的场景下，通过构建三套业务环境，帮助用户实现环境在线，降低环境准备的时间成本与投入成本。</p><p>为研发团队提供一种将应用开发方法和结果抽象成标准的格式化的解决方案的能力，用该解决方案统一快速地教育开发者。</p><p>定义了用户群体、问题、场景以及服务策略之后，我们开始尝试去定义这个产品：我们要去打造一个全云端研发工作的平台，以业务、研发任务为用户界面，用户对云产品的感知尽量保持并限制在必要的情况之下，但是平台要在背后为他们提供一系列先进的云原生 Serverless 架构服务，同时，具备让用户的团队、环境、代码、协同等等实现在线的能力，帮助目标用户群体省钱、省时、可持续发展。</p><p><strong>核心技术方案</strong></p><p>作为一个面向用户业务视角而非云产品或任何单项研发能力视角的设计，背后就必不可少的要跟非常多的系统、产品、能力进行集成；并且，要达成与用户业务视角的关联，又需要额外设计一套核心应用模型去支撑。这里，我们通过两个架构设计，向大家阐述我们的实现思路与方式。</p><p>系统集成架构</p><p><img src="https://aimak.cn/blog_img/sys/system_jicheng.png"></p><p>认同在线协同是大趋势。我们把自己定义为大协同领域的一环，最好能够依托于一个更具全局性的团队在线协同底座去建设，我们与云效合作共建，基于一个共同的团队模型以及数据去设计实现不同的领域能力。</p><p>原子研发能力分布广泛，以代码为主线进行串联设计，在开发者用户路径中，我们与 Codeup、Flow 等产品进行集成，与经济体共建 IDE 集成，共同推出 CloudIDE，为开发者提供从云上代码托管到云上研发，再到云上 CICD 的一站式服务。</p><p>解决方案实例化架构</p><p>用技术语言来描述的话，可以把解决方案实例化架构核心要解决的问题理解成将一个行业应用的开发经验进行 “序列化” 与 “反序列化” 的过程。</p><p>我们与 OAM 团队合作，以 OAM 为规范，对构成一个行业应用的研发环境以及依赖资源进行格式化、规范化的描述，生成一个云开发平台所能理解和认识的解决方案，这是“序列化”的过程。</p><p>当云开发平台去解析一个解决方案，核心会做两件事情，一是分析和生成一个基于阿里云产品矩阵构成的云原生 Serverless 架构，另一件事情是将依赖的资源做打包上传等预处理；然后开始生成任务，逐一进行生产、创建、安装，直至一个行业应用被初始化完成，这是“反序列化”的过程。</p><p>通过这种设计，我们实现了云开发平台最为核心的能力：</p><ol><li>帮助行业开发生态格式化、规范化地沉淀经验。</li><li>帮助行业开发生态快速分发、复制行业应用开发经验。</li><li>帮助行业开发生态无缝升级至先进的云原生 Serverless 架构。</li></ol><p><strong>阿里云云开发平台正式上线服务</strong></p><p>2020 年 4 月 23 日，阿里云云开发平台联合天猫精灵智能应用平台共同发布，上线云开发服务功能；2020 年 4 月 28 日，阿里云云开发平台联合阿里前端委员会 Serverless 小组，共同发布基于 Ali Midway FaaS 框架的前后端一体通用 NodeJS 解决方案。2020年5月28日，与阿里巴巴云原生团队合作推出基于 SpringCloud、MSE 的微服务应用开发解决方案，轻松将微服务开发并部署在 Serverless 平台之上，帮助开发者以 0 启动成本、基于云原生 Serverless 架构服务，3 分钟极致效率，完成一个标准技能应用的创建和部署。</p><p>在 Roadmap 中，还有微服务、小程序、大数据等场景解决方案将陆续上线。</p><p>感受云开发平台的极致特性</p><p><strong>1 个开发界面</strong></p><ul><li>打开浏览器就能开发</li><li>不管你用什么设备，电脑、手机、平板</li><li>不管是什么操作系统，Windows、MacOS、Linux、Android、iOS</li></ul><p><strong>1 套统一的业务环境</strong></p><ul><li>统一的云上开发和业务环境（支持 NodeJS，Java，PhP，Python, C# 等主流语言）</li><li>登录即完成配置，无需等待，专注业务创新</li><li>远程协同开发、所测即所得、测完即上线</li></ul><p><strong>1 个领先的架构</strong></p><ul><li>基于业界领先的 Serverless 架构</li><li>最快 1 秒钟部署</li><li>按量付费不浪费，自动扩容不宕机</li></ul><p><strong>N 个行业应用场景</strong></p><ul><li>解决方案模版化</li><li>最快 3 分钟上线一个行业应用（通用 WEB 应用，AIoT 应用，微服务应用等等）</li><li>99% 时间聚焦在业务，开发更专注</li></ul><p>了解云开发平台的运作方式</p><p>云开发平台是一个可以满足开发者、研发团队完全基于「云+浏览器」就能完成日常开发工作的环境。它的设计理念是使自己成为团队大协同中的一环，它会跟阿里云诸多研发能力和工具进行集成，比如：云效企业协同底座、CloudIDE、Codeup、Flow 等等，籍由强大的阿里研发生态，为用户提供更大的协同研发可能，用户可以在使用云开发平台的时候，根据业务的需要，主动选择去开通使用更多类似于项目管理、需求管理、文档管理等其他服务。</p><p>同时，为了帮助用户提供一个无缝应用阿里云服务的环境，云开发平台会跟阿里云的诸多云产品进行集成，随时为用户的使用而准备；用户可以在云开发平台创建基于各种场景解决方案的应用，并为每个应用选用不同的云服务，这些云服务会开通在用户的阿里云主账号之下，用户主动开通的各种云资源会按照用户的使用，正常地计量计费。</p><p>云开发平台鼓励所有的场景解决方案尽可能多的基于阿里云的 Serverless 类型产品去提供服务。Serverless 类型的产品都具有实时弹性以及按量付费的特征，这可以帮助到商业化研发团队，以尽可能低的成本去实现自己的商业价值。</p><p><strong>云开发平台具体如何真实地帮到目标用户群体</strong></p><p>云开发平台如何帮助用户实现线上轻量化团队协同？</p><p>我们联合云效，共同构建了一个在线研发团队的能力，团队规模从 1-10 人 到 1000 人以上，全都免费提供，助力企业快速成长！</p><p>1 分钟完成研发团队的在线化：在云开发平台，团队管理者创建好自己的企业，然后创建一批子账号分配给每一个团队成员，团队即完成了在线化。</p><p>如果用户企业内已经有一套域账号系统，那么通过对接阿里云 SP 的 SAML 配置之后，能够方便实现用域账号的 SSO。</p><p>如果团队并非组织关系型怎么办呢？在云开发平台，团队管理者创建好自己的企业，然后复制邀请链接，发送给那些并非组织关系里的成员，收到邀请的成员确认加入团队即完成团队的在线化。</p><p>云开发平台如何帮助用户实现业务的快速启动呢？</p><p>团队在线之后就要开始启动业务。</p><p><strong>新业务秒级启动</strong></p><p>在云开发平台，团队管理员可以从应用场景中，选择一个成熟的行业应用解决方案，秒级完成应用的创建。</p><p><strong>业务开发人员直接进入业务开发，100% focus 在业务的开发交付</strong></p><p>在云工作台，我们优化了以往传统线下研发模式中人人需要配置开发环境的弊端，将人人要做的事情，交由应用管理员一人执行，业务开发者登录云开发平台即开始业务开发。</p><p>云开发平台如何帮助用户实现研发环境的升级呢？</p><p>团队在线了，应用在线了，还剩下的环节就是代码和研发过程。</p><p><strong>安全可靠且免费的代码托管服务</strong></p><p>云开发平台联合阿里云 Codeup，在云开发平台创建的每一个应用，都会自动分配一个免费的代码仓库，为用户提供安全可靠且免费的代码托管服务，帮助用户实现代码在线。</p><p><strong>功能强大的云端开发环境</strong></p><p>云开发平台联合阿里经济体共建团队推出自研 CloudIDE，为用户提供功能强大，兼容 VS Code 插件生态的云端开发环境，内置 NodeJS，Java，PhP，Python，C# 等主流语言开发环境，开箱即用，体验媲美本地；当然，开发者也可以选择将代码克隆到本地，继续以个人偏好的开发习惯进行开发，之后随时将代码同步到云端，做到云端与本地的实时同步。</p><p><strong>业界领先的 Serverless 架构</strong></p><p>在每一个应用的背后，都有强大的阿里云 Serverless 产品矩阵构成的架构服务在支撑，API Gateway+Function Compute 组合、VPC+ECI+EIP 组合等等，保障每一个应用上线，都能稳稳地支撑，轻松助力用户不断攀登新的业绩高峰。</p><p><strong>0 成本启动</strong></p><p>基于强大的云开发平台服务以及阿里云 Serverless 架构矩阵，我们帮用户把 Serverless 如丝般顺滑落地到他们的业务之中，大胆开发，放心试错，无需为云开发平台支付任何费用。</p><p><strong>回顾</strong></p><p>在这次突如其来的疫情期间，所有人都隔离在家，也许千人规模的企业能够有内部的强大 IT 系统做支撑，整个企业仍然可以进行远程异地运转，但是对于广大的初创及成长中的企业，这种能力无疑是稀缺的，而在线，可能是未来的一个趋势和常态。今天，随着阿里云云开发平台服务的上线，我们可以真正帮助到这些企业，通过用户业务视角、用户研发界面、提供云计算的开箱即用，去释放云上研发，Serverless 架构的技术红利，推动云计算的普惠价值！</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL 是真的香</title>
      <link href="/2020/06/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/GraphQL%20%E6%98%AF%E7%9C%9F%E7%9A%84%E9%A6%99/"/>
      <url>/2020/06/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/GraphQL%20%E6%98%AF%E7%9C%9F%E7%9A%84%E9%A6%99/</url>
      
        <content type="html"><![CDATA[<p>转自：toutiao.com&#x2F;i6833818331884028419</p><ul><li>GraphQL简介</li><li>GraphQL 对比 REST API 有什么好处？</li><li>GraphQL 思考模式</li><li>GraphQL执行逻辑</li><li>GraphQL应用的基本架构</li><li>GraphQL特点总结</li><li>GraphQL支持的数据操作</li><li>GraphQL的核心概念：图表模式（Schema）</li><li>标量类型（Scalar Type）</li><li>对象类型（Object Type）</li><li>类型修饰符（Type Modifier）</li><li>其他类型</li><li>Graphql 技术接入架构</li><li>服务端实现</li><li>客户端实现</li><li></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>REST作为一种现代网络应用非常流行的软件架构风格，自从Roy Fielding博士在2000年他的博士论文中提出来到现在已经有了20年的历史。它的简单易用性，可扩展性，伸缩性受到广大Web开发者的喜爱。</p><p>REST 的 API 配合JSON格式的数据交换，使得前后端分离、数据交互变得非常容易，而且也已经成为了目前Web领域最受欢迎的软件架构设计模式。</p><p>但随着REST API的流行和发展，它的缺点也暴露了出来：</p><ul><li><strong>滥用REST接口</strong>，导致大量相似度很高（具有重复性）的API越来越冗余。</li><li>对于前端而言：<strong>REST API粒度较粗</strong>，难以一次性符合前端的数据要求，前端需要分多次请求接口数据。增加了前端人员的工作量。</li><li>对于后端而言：<strong>前端需要的数据往往在不同的地方具有相似性，但却又不同</strong>，比如针对同样的用户信息，有的地方只需要用户简要信息（比如头像、昵称），有些地方需要详细的信息，这就需要开发不同的接口来满足这些需求。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。增加了后端开发人员的工作量和重复度。</li></ul><p>那我们来分析一下，<strong>当前端需求变化，涉及到改动旧需求时</strong>，会有以下这些情况：</p><p><strong>做加法</strong>：</p><p>产品需求增加，页面需要增加功能，数据也就相应的要增加显示，那么REST接口也需要做增加，这种无可厚非。</p><p><strong>做减法</strong>：</p><p>产品需求减少，页面需要减少功能，或者减少某些信息显示，那么数据就要做减法。</p><p><strong>一种通常懒惰的做法是，前端不与后端沟通，仅在前端对数据选择性显示。</strong></p><p>因为后端接口能够满足数据需要，仅仅是在做显示的时候对数据进行了选择性显示，但接口的数据是存在冗余的，这种情况一个是存在数据泄露风险，另外就是数据量过大时造成网络流量过大，页面加载缓慢，用户流量费白白消耗，用户体验就会下降。</p><p><strong>另外一种做法就是告知后端，要么开发新的接口，要么，修改旧接口，删掉冗余字段。</strong></p><p>但一般来说，开发新接口往往是后端开发人员会选择的方案，因为这个方案对现有系统的影响最低，不会有额外的风险。</p><p>修改旧接口删除冗余数据的方案往往开发人员不会选择，这是为什么呢？</p><p>这就涉及到了系统的稳定性问题了，旧接口往往不止是一个地方在用，很有可能很多页面、设置不同客户端、不同服务都调用了这个接口获取数据，不做详细的调查，是不可能知道到底旧接口被调用了多少次，一旦改动旧接口，涉及范围可能非常大，往往会引起其他地方出现崩溃。改动旧接口成本太高，所以往往不会被采取。</p><p><strong>同时做加减法：</strong></p><p>既有加法，又有减法，其实这种就跟新需求没啥区别，前端需要重做页面，后端需要新写接口满足前端需要，但是旧接口还是不能轻举妄动（除非确定只有这一处调用才可以删除）。</p><p>往往这个时候，其实用到的数据大多都是来自于同一个DO或者DTO，不过是在REST接口组装数据时，用不同的VO来封装不同字段，或者，使用同样的VO，组装数据时做删减。</p><p>看到这些问题是不是觉得令人头大？</p><p>所以<strong>需求频繁改动是万恶之源</strong>，当产品小哥哥改动需求时，程序员小哥哥可能正提着铁锹赶来……</p><p>那么有没有一种方案或者框架，可以使得在用到同一个领域模型（DO或者DTO）的数据时，前端对于这个模型的数据字段需求的改动，后端可以根据前端的改动和需要，自动适配，自动组装需要的字段，返回给前端呢？如果能这样做的话，那么后端程序猿小哥可能要开心死了，前端妹子也不用那么苦口婆心地劝说后端小哥哥了。</p><p>所以<strong>GraphQL</strong>隆重出世了！那么问题来了！</p><hr><p>Part 1 What is GraphQL</p><h1 id="GraphQL简介"><a href="#GraphQL简介" class="headerlink" title="GraphQL简介"></a>GraphQL简介</h1><ul><li>GraphQL是一种新的API标准，它提供了一种比REST更有效、更强大和更灵活的替代方案。</li><li>它是由Facebook开发并开源的，现在由来自世界各地的公司和个人组成的大型社区维护。</li><li>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</li><li>它是数据库无关的，而且可以在使用API的任何环境中有效使用，我们可以理解为GraphQL是基于API之上的一层封装，目的是为了更好，更灵活的适用于业务的需求变化。</li></ul><p>简单的来说，它</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235702/1000"></p><p>它的工作模式是这样子的：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235703/1000"></p><h1 id="GraphQL-对比-REST-API-有什么好处？"><a href="#GraphQL-对比-REST-API-有什么好处？" class="headerlink" title="GraphQL 对比 REST API 有什么好处？"></a>GraphQL 对比 REST API 有什么好处？</h1><p><strong>REST API 的接口灵活性差、接口操作流程繁琐，GraphQL 的声明式数据获取，使得接口数据精确返回，数据查询流程简洁，照顾了客户端的灵活性。</strong></p><p><strong>客户端拓展功能时要不断编写新接口（依赖于服务端），GraphQL 中一个服务仅暴露一个 GraphQL 层，消除了服务器对数据格式的硬性规定，客户端按需请求数据，可进行单独维护和改进。</strong></p><p><strong>REST API 基于HTTP协议，不能灵活选择网络协议，而传输层无关、数据库技术无关使得 GraphQL 有更加灵活的技术栈选择，能够实现在网络协议层面优化应用。</strong></p><p>举个经典的例子：前端向后端请求一个book对象的数据及其作者信息。</p><p>我用动图来分别演示下REST和GraphQL是怎么样的一个过程。</p><p>先看REST API的做法：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235704/0"></p><p>REST API获取数据</p><p>再来看GraphQL是怎么做的：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235705/0"></p><p>GraphQL获取数据</p><p>可以看出其中的区别：</p><ul><li>与REST多个endpoint不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235706/1000"></p><p>Endpoints对比</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235707/1000"></p><p>REST API’s Endpoints</p><ul><li>GraphQL 实际上将多个 HTTP 请求聚合成了一个请求，将多个 restful 请求的资源变成了一个从根资源 POST 访问其他资源的 Comment 和 Author 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，因此GraphQL又可以被看成是图数据库的形式。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235710/1000"></p><p>图数据库模式的数据查询</p><p>那我们已经能看到GraphQL的先进性，接下来看看它是怎么做的。</p><h1 id="GraphQL-思考模式"><a href="#GraphQL-思考模式" class="headerlink" title="GraphQL 思考模式"></a>GraphQL 思考模式</h1><p>使用GraphQL接口设计获取数据需要三步：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235711/0"></p><p>GraphQL获取数据三步骤</p><ol><li>首先要设计数据模型，用来描述数据对象，它的作用可以看做是VO，用于告知GraphQL如何来描述定义的数据，为下一步查询返回做准备；</li><li>前端使用模式查询语言（Schema）来描述需要请求的数据对象类型和具体需要的字段（称之为声明式数据获取）；</li><li>后端GraphQL通过前端传过来的请求，根据需要，自动组装数据字段，返回给前端。</li></ol><p>GraphQL的这种思考模式是不是完美解决了之前遇到的问题呢？！</p><p>总结它的好处：</p><p>在它的设计思想中，GraphQL 以图的形式将整个 Web 服务中的资源展示出来，客户端可以按照其需求自行调用，类似添加字段的需求其实就不再需要后端多次修改了。</p><p>创建GraphQL服务器的最终目标是：</p><p><strong>允许查询通过图和节点的形式去获取数据。</strong></p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235712/1000"></p><h1 id="GraphQL执行逻辑"><a href="#GraphQL执行逻辑" class="headerlink" title="GraphQL执行逻辑"></a>GraphQL执行逻辑</h1><p>有人会问：</p><ul><li>使用了GraphQL就要完全抛弃REST了吗？</li><li>GraphQL需要直接对接数据库吗？</li><li>使用GraphQL需要对现有的后端服务进行大刀阔斧的修改吗？</li></ul><p>答案是：NO！不需要！</p><p>它完全可以以一种不侵入的方式来部署，将它作为前后端的中间服务，也就是，现在开始逐渐流行的 <strong>前端 —— 中端 —— 后端</strong> 的三层结构模式来部署！</p><p>那就来看一下这样的部署模式图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235713/1000"></p><p>GraphQL执行逻辑</p><p>也就是说，完全可以搭建一个GraphQL服务器，专门来处理前端请求，并处理后端服务获取的数据，重新进行组装、筛选、过滤，将完美符合前端需要的数据返回。</p><p>新的开发需求可以直接就使用GraphQL服务来获取数据了，以前已经上线的功能无需改动，还是使用原有请求调用REST接口的方式，最低程度的降低更换GraphQL带来的技术成本问题！</p><p>如果没有那么多成本来支撑改造，那么就不需要改造！</p><p>只有当原有需求发生变化，需要对原功能进行修改时，就可以换成GraphQL了。</p><h1 id="GraphQL应用的基本架构"><a href="#GraphQL应用的基本架构" class="headerlink" title="GraphQL应用的基本架构"></a>GraphQL应用的基本架构</h1><p>下图是一个 GraphQL 应用的基本架构，其中客户端只和 GraphQL 层进行 API 交互，而 GraphQL 层再往后接入各种数据源。这样一来，只要是数据源有的数据， GraphQL 层都可以让客户端按需获取，不必专门再去定接口了。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235714/1000"></p><p>GraphQL应用基本架构</p><p><strong>一个GraphQL服务仅暴露一个 GraphQL Endpoint，可以按照业务来进行区分，部署多个GraphQL服务，分管不同的业务数据，这样就可以避免单服务器压力过大的问题了。</strong></p><h1 id="GraphQL特点总结"><a href="#GraphQL特点总结" class="headerlink" title="GraphQL特点总结"></a>GraphQL特点总结</h1><ul><li><strong>声明式数据获取（可以对API进行查询）:</strong> 声明式的数据查询带来了接口的精确返回，服务器会按数据查询的格式返回同样结构的 JSON 数据、真正照顾了客户端的灵活性。</li><li><strong>一个微服务仅暴露一个 GraphQL 层：</strong>一个微服务只需暴露一个GraphQL endpoint，客户端请求相应数据只通过该端点按需获取，不需要再额外定义其他接口。</li><li><strong>传输层无关、数据库技术无关：</strong>带来了更灵活的技术栈选择，比如我们可以选择对移动设备友好的协议，将网络传输数据量最小化，实现在网络协议层面优化应用。</li></ul><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235716/1000"></p><p>Part 2 Schema &amp; Type</p><h1 id="GraphQL支持的数据操作"><a href="#GraphQL支持的数据操作" class="headerlink" title="GraphQL支持的数据操作"></a>GraphQL支持的数据操作</h1><p>GraphQL对数据支持的操作有：</p><ul><li><strong>查询（Query）：</strong>获取数据的基本查询。</li><li><strong>变更（Mutation）：</strong>支持对数据的增删改等操作。</li><li><strong>订阅（Subscription）：</strong>用于监听数据变动、并靠websocket等协议推送变动的消息给对方。</li></ul><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235717/0"></p><p>GraphQL支持的操作</p><h1 id="GraphQL的核心概念：图表模式（Schema）"><a href="#GraphQL的核心概念：图表模式（Schema）" class="headerlink" title="GraphQL的核心概念：图表模式（Schema）"></a>GraphQL的核心概念：图表模式（Schema）</h1><p>要想要设计GraphQL的数据模型，用来描述你的业务数据，那么就必须要有一套Schema语法来做支撑。</p><p>想要描述数据，就必须离不开数据类型的定义。所以GraphQL设计了一套Schema模式（可以理解为语法），其中最重要的就是数据类型的定义和支持。</p><p>那么类型（Type）就是模式（Schema）最核心的东西了。</p><p><strong>什么是类型？</strong></p><ul><li>对于数据模型的抽象是通过类型（Type）来描述的，每一个类型有若干字段（Field）组成，每个字段又分别指向某个类型（Type）。这很像Java、C#中的类（Class）。</li><li>GraphQL的Type简单可以分为两种，一种叫做Scalar Type(标量类型)，另一种叫做Object Type(对象类型)。</li></ul><p>那么就分别来介绍下两种类型。</p><h1 id="标量类型（Scalar-Type）"><a href="#标量类型（Scalar-Type）" class="headerlink" title="标量类型（Scalar Type）"></a>标量类型（Scalar Type）</h1><p>标量是GraphQL类型系统中最小的颗粒。类似于Java、C#中的基本类型。</p><p>其中内建标量主要有：</p><ul><li><strong>String</strong></li><li><strong>Int</strong></li><li><strong>Float</strong></li><li><strong>Boolean</strong></li><li><strong>Enum</strong></li><li><strong>ID</strong></li></ul><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235718/0"></p><p>Scalar Type</p><p>上面的类型仅仅是GraphQL默认内置的类型，当然，为了保证最大的灵活性，GraphQL还可以很灵活的自行创建标量类型。</p><h1 id="对象类型（Object-Type）"><a href="#对象类型（Object-Type）" class="headerlink" title="对象类型（Object Type）"></a>对象类型（Object Type）</h1><p>仅有标量类型是不能满足复杂抽象数据模型的需要，这时候我们可以使用对象类型。</p><p>通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。</p><p>对象类型的定义可以参考下图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235720/1000"></p><p>对象模型引入关联关系</p><p>是不是很方便呢？我们可以像设计类图一样来设计GraphQL的对象模型。</p><h1 id="类型修饰符（Type-Modifier）"><a href="#类型修饰符（Type-Modifier）" class="headerlink" title="类型修饰符（Type Modifier）"></a>类型修饰符（Type Modifier）</h1><p>那么，类型系统仅仅只有类型定义是不够的，我们还需要对类型进行更广泛性的描述。</p><p>类型修饰符就是用来修饰类型，以达到额外的数据类型要求控制。</p><p>比如：</p><ul><li>列表：[Type]</li><li>非空：Type!</li><li>列表非空：[Type]!</li><li>非空列表，列表内容类型非空：[Type!]!</li></ul><p>在描述数据模型（模式Schema）时，就可以对字段施加限制条件。</p><p>例如定义了一个名为User的对象类型，并对其字段进行定义和施加限制条件：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235721/1000"></p><p>User字段控制</p><p>那么，返回数据时，像下面这种情况就是不允许的：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235722/1000"></p><p>错误的表示</p><p>Graphql会根据Schema Type来自动返回正确的数据：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235723/1000"></p><p>正确的表示</p><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>除了上面的，Graphql还有一些其他类型来更好的引入面向对象的设计思想：</p><ul><li><strong>接口类型（Interfaces）：</strong>其他对象类型实现接口必须包含接口所有的字段，并具有相同的类型修饰符，才算实现接口。</li></ul><p>比如定义了一个接口类型：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235724/1000"></p><p>那么就可以实现该接口：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235725/1000"></p><ul><li><strong>联合类型（Union Types）：</strong>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。几个对象类型共用一个联合类型。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237705/1000"></p><ul><li><strong>输入类型（Input Types）：</strong>更新数据时有用，与常规对象只有关键字修饰不一样，常规对象时 <strong>type</strong> 修饰，输入类型是 <strong>input</strong> 修饰。</li></ul><p>比如定义了一个输入类型：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237706/1000"></p><p>前端发送变更请求时就可以使用（通过参数来指定输入的类型）：</p><p><img src="/"></p><p>所以，这样面向对象的设计方式，真的对后端开发人员特别友好！而且前端MVVM框架流行以来，面向对象的设计思想也越来越流行，前端使用Graphql也会得心应手。</p><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237707/1000"></p><p>Part 3 GraphQL技术接入架构</p><h1 id="Graphql-技术接入架构"><a href="#Graphql-技术接入架构" class="headerlink" title="Graphql 技术接入架构"></a>Graphql 技术接入架构</h1><p>那么，该怎么设计来接入我们现有的系统中呢？</p><ul><li><strong>将Graphql服务直连数据库的方式：</strong>最简洁的配置，直接操作数据库能减少中间环节的性能消耗。</li></ul><p>直连数据库的接入</p><ul><li><strong>集成现有服务的GraphQL层：</strong>这种配置适合于旧服务的改造，尤其是在涉及第三方服务时、依然可以通过原有接口进行交互。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237708/1000"></p><p>集成现有服务的GraphQL层</p><ul><li><strong>直连数据库和集成服务的混合模式：</strong>前两种方式的混合。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237709/1000"></p><p>混合接入方式</p><p>可以说是非常灵活了！你都不用担心会给你带来任何的麻烦。</p><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237710/1000"></p><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>在服务端， GraphQL 服务器可用任何可构建 Web 服务器的语言实现。有以下语言的实现供参考：</p><p>C# &#x2F; .NET</p><p>Clojure</p><p>Elixir</p><p>Erlang</p><p>Go</p><p>Groovy</p><p>Java</p><p>JavaScript</p><p>Julia</p><p>Kotlin</p><p>Perl</p><p>PHP</p><p>Python</p><p>R</p><p>Ruby</p><p>Rust</p><p>Scala</p><p>Swift</p><p>种类繁多，几乎流行的语言都有支持。</p><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>在客户端，Graphql Client目前有下面的语言支持：</p><p>C# &#x2F; .NET</p><p>Clojurescript</p><p>Elm</p><p>Flutter</p><p>Go</p><p>Java &#x2F; Android</p><p>JavaScript</p><p>Julia</p><p>Swift &#x2F; Objective-C iOS</p><p>Python</p><p>R</p><p>覆盖了众多客户端设计语言，而其他语言的支持也在推进中。</p><h1 id="Graphql的一些服务"><a href="#Graphql的一些服务" class="headerlink" title="Graphql的一些服务"></a>Graphql的一些服务</h1><p>整理了下目前比较流行的服务框架：</p><ul><li>Apollo Engine:一个用于监视 GraphQL 后端的性能和使用的服务。</li><li>Graphcool (github): 一个 BaaS（后端即服务），它为你的应用程序提供了一个 GraphQL 后端，且具有用于管理数据库和存储数据的强大的 web ui。</li><li>Tipe (github): 一个 SaaS（软件即服务）内容管理系统，允许你使用强大的编辑工具创建你 的内容，并通过 GraphQL 或 REST API 从任何地方访问它。</li><li>AWS AppSync：完全托管的 GraphQL 服务，包含实时订阅、离线编程和同步、企业级安全特性以及细粒度的授权控制。</li><li>Hasura：一个 BaaS（后端即服务），允许你在 Postgres 上创建数据表、定义权限并使用 GraphQL 接口查询和操作。</li></ul><h1 id="Graphql的一些工具"><a href="#Graphql的一些工具" class="headerlink" title="Graphql的一些工具"></a>Graphql的一些工具</h1><ul><li>graphiql (npm): 一个交互式的运行于浏览器中的 GraphQL IDE。</li><li>Graphql Language Service: 一个用于构建 IDE 的 GraphQL 语言服务（诊断、自动完成等） 的接口。</li><li>quicktype (github): 在 TypeScript、Swift、golang、C#、C++ 等语言中为 GraphQL 查 询生成类型。</li></ul><p>想要获取更多关于Graphql的一些框架、工具，可以去awesome-graphql：一个神奇的社区，维护一系列库、资源等，地址是</p><p><a href="https://github.com/chentsulin/awesome-graphql%E3%80%82">https://github.com/chentsulin/awesome-graphql。</a></p><p>想要学习更多Graphql的知识，可以去<strong>GraphQL.cn。</strong></p><hr><p>好了，一个入门级的Graphql介绍篇就这样完结了（尽管篇幅也很大哈哈）。</p><ul><li>不知道你懂得它的原理和优点了吗？</li><li>你对它感兴趣吗？</li><li>看完这篇介绍，有没有想动手尝试一下呢？</li><li>你会在你下一个项目中引入Graphql并使用它吗？</li><li>你对Graphql还有什么疑惑的问题呢？</li></ul><p>或者你有其他问题，都可以在评论区留言或者私信我，大家一起共同探讨。</p><p>Graphql还有更多需要介绍的东西，没有写出来，这仅仅是一个入门介绍哈，后面我会再写一篇文章来详细介绍Graphql在具体的使用方面的总结和在项目中使用的实际感受，如果你也对Graphql感兴趣，可以关注我 @IT研究僧大师兄 下一次的文章介绍。关注我后可以私信我，发送关键字“Graphql PPT”，获取我自己制作的Graphql PPT。</p><p>当然，如果你也和我一样，热衷于技术，热衷于科技、互联网，不妨点个关注吧，我会持续分享干货知识、经验和观点总结。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择分布式事务解决方案</title>
      <link href="/2020/05/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/05/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong>概述</strong></p><p>事务是一组不可分组的操作集合，这些操作要么都成功执行，要么都取消执行。最典型的需要事务的场景是银行账户间的转账：假如 A 账户要给 B 账户转账 100 元，那么 A 账户要扣减 100 元，B 账户要增加 100 元，这两个账户的数据变更都成功才可算作转账成功。更严格来说，可以用 ACID 四个特性表述事务：</p><p>Atomicity：原子性，事务中的所有操作要么都成功执行，要么都取消执行，不能存在部分执行，部分不执行的状态。</p><p>Consistency：一致性，举个例子简单的理解就是，A、B 两个账户各有 100 元，无论两个账户并发相互转账多少次，两个账户的资金总额依然是 200 元。</p><p>Isolation：隔离性，并发事务之间的相互影响程度，隔离性也是分级别的：读未提交、读已提交、可重复读等。</p><p>Durability：持久性，事务完成后对数据的更改不会丢失。</p><p>单体数据库不涉及网络交互，所以在多表之间实现事务是比较简单的，这种事务我们称之为本地事务。</p><p>但是单体数据库的性能达到瓶颈的时候，就需要分库(分物理实例)，就会出现跨库(数据库实例)的事务需求；随着企业应用的规模越来越大，企业会进一步进行服务化改造，以满足业务增长的需求；当前微服务架构越来越流行，跨服务的事务场景也会越来越多。</p><p>这些都是分布式事务的需求。分布式事务是指是指事务的发起者、参与者、数据资源服务器以及事务管理器分别位于分布式系统的不同节点之上。</p><p>概括起来，分布式事务有三种场景：</p><p>跨数据库分布式事务跨服务分布式事务混合式分布式事务</p><p><img src="https://pics3.baidu.com/feed/2f738bd4b31c87018a7b2245af2325290608ff23.png@f_auto?token=904aaf97b1a13069a99c892c610fa9b2" alt="img"></p><p>分布式事务中涉及的参与者分布在异步网络中，参与者通过网络通信来达到分布式一致性，网络通信不可避免出现失败、超时的情况，因此分布式事务的实现比本地事务面临更多的困难。下面介绍几种常见的分布式事务解决方案。</p><p><strong>分布式事务模式</strong></p><p>XA Specification</p><p>最早的分布式事务产品可能是 AT&amp;T 在 20 世纪 80 年代推出的 Tuxedo (Transactions for Unix, Extended for Distributed Operations)，Tuxedo 最早是为了电信领域的 OLTP 系统研发的分布式事务中间件，后来标准化组织 X&#x2F;Open 吸收采纳了 Tuxedo 的设计思想和一些接口，推出了分布式事务规范：XA Specification。</p><p>XA 规范中定义了分布式事务处理模型，这个模型中包含四个核心角色：</p><p>RM (Resource Managers)：资源管理器，提供数据资源的操作、管理接口，保证数据的一致性和完整性。最有代表性的就是数据库管理系统，当然有的文件系统、MQ 系统也可以看作 RM。</p><p>TM (Transaction Managers)：事务管理器，是一个协调者的角色，协调跨库事务关联的所有 RM 的行为。</p><p>AP (Application Program)：应用程序，按照业务规则调用 RM 接口来完成对业务模型数据的变更，当数据的变更涉及多个 RM 且要保证事务时，AP 就会通过 TM 来定义事务的边界，TM 负责协调参与事务的各个 RM 一同完成一个全局事务。</p><p>CRMs (Communication Resource Managers)：主要用来进行跨服务的事务的传播。</p><p>下图是 XA 规范中定义的事务模型图，其中：发起分布式事务的 TM 实例称之为 root 节点，其他的 TM 实例可以统称为事务的参与者。事务发起者负责开启整个全局事务，事务参与者各自负责执行自己的事务分支。如果TM实例发起了对其他 TM 实例的服务调用，那么发起者就被成为 Superior，被调用这就被称之为 Subordinate 节点。</p><p><img src="https://pics5.baidu.com/feed/d833c895d143ad4bb21a35d70a5ee1a9a40f0657.png@f_auto?token=2673237f259be7f9fba5ab5fb2c8333b" alt="img"></p><p>图源：《Distributed Transaction Processing:Reference Model, Version 3》 Page 32,Figure 3-2</p><p>XA 规范中分布式事务是构建在 RM 本地事务（此时本地事务被看作分支事务）的基础上的，TM 负责协调这些分支事务要么都成功提交、要么都回滚。XA 规范把分布式事务处理过程划分为两个阶段，所以又叫两阶段提交协议（two phrase commit）：</p><p>1）预备阶段</p><p>TM 记录事务开始日志，并询问各个 RM 是否可以执行提交准备操作。</p><p>RM 收到指令后，评估自己的状态，尝试执行本地事务的预备操作：预留资源，为资源加锁、执行操作等，但是并不提交事务，并等待 TM 的后续指令。如果尝试失败则告知 TM 本阶段执行失败并且回滚自己的操作，然后不再参与本次事务（以 MySQL 为例，这个阶段会完成资源的加锁，redo log 和 undo log 的写入）。</p><p>TM 收集 RM 的响应，记录事务准备完成日志。</p><p>2）提交&#x2F;回滚阶段</p><p>这个阶段根据上个阶段的协调结果发起事务的提交或者回滚操作。</p><p>如果所有 RM 在上一个步骤都返回执行成功，那么：</p><p>TM 记录事务 commit 日志，并向所有 RM 发起事务提交指令。</p><p>RM 收到指令后，提交事务，释放资源，并向 TM 响应“提交完成”。</p><p>如果 TM 收到所有 RM 的响应，则记录事务结束日志。</p><p>如果有 RM 在上一个步骤中返回执行失败或者超时没有应答，则 TM 按照执行失败处理，那么：</p><p>记录事务 abort 日志，向所有 RM 发送事务回滚指令。</p><p>RM 收到指令后，回滚事务，释放资源，并向 TM 响应回滚完成。</p><p>如果 TM 收到所有 RM 的响应，则记录事务结束日志。</p><p><img src="https://pics1.baidu.com/feed/29381f30e924b89975a8b7ace45aa6930b7bf676.png@f_auto?token=cfa018d07898f65ba2fc2f8959899151" alt="img"></p><p>针对部分场景，XA 规范还定义了如下优化措施：</p><p>如果 TM 发现整个事务只涉及到一个 RM，那么就会将整个过程退化为一阶段提交。</p><p>如果 RM 收到的 AP 的数据操作是只读操作，那么它可以在阶段 1 就将事务完成并告知 TM 其不再参与阶段 2 的过程。会有脏读的风险。</p><p>如果 RM 在阶段1完成后，长时间等不到阶段 2 的指令，那么其可以自动提交或者回滚本地事务。这叫做 Heuristic Completion，注意这种场景有可能会破坏事务的一致性，产生异常。</p><p>XA 规范中详细定义了各个核心组件之间的交互接口，以 TM 和 RM 的交互接口为例，如下图，一次完整的全局事务，TM 和 RM 之间的交互还是比较频繁的：</p><p><img src="https://pics5.baidu.com/feed/35a85edf8db1cb13f3eda8c85408ed4890584bcc.png@f_auto?token=5c1ed2fed03a01c866feace204203996" alt="img"></p><p>事务的执行过程中，宕机和网络超时都有可能发生，针对这些异常场景，不同 XA 规范的实现，对异常处理做法可能不同，可参考如下：</p><p>TM 在阶段 1 中询问 RM 前宕机，恢复后无需做任何操作。</p><p>TM 在阶段 1 中询问 RM 后宕机，可能只有部分 RM 收到了阶段 1 的请求，因此此时需要向 RM 发起回滚请求。</p><p>TM 在阶段 1 中询问 RM 完毕，但是在就准备完成日志时宕机，因不清楚宕机前的事务协商的结果，因此恢复后需要向 RM 发起回滚请求。</p><p>TM 在阶段 1 中记录完毕事务准备完成日志后宕机，恢复后可以根据日志发起提交或者回滚的指令。</p><p>TM 在阶段 2 中记录 commit&#x2F;abort 日志前宕机，恢复后可以根据日志发起提交或者回滚指令。</p><p>TM 在阶段 2 中记录事务结束日志前宕机，恢复后可以根据日志发起提交或者回滚指令。</p><p>TM 在阶段 2 中记录事务结束日志后宕机，恢复后无需做任何操作。</p><p>阶段 1 中，RM 有超时情况时，TM 按失败处理，给所有 RM 发送回滚指令。</p><p>阶段 2 中，RM 有超时情况是，TM 需要对超时的 RM 持续重复发送指令。</p><p><strong>特点剖析</strong></p><p>XA 两阶段提交协议设计上是要像本地事务一样实现事务的 ACID 四个特性：</p><p>原子性：在 prepare 和 commit 阶段保证事务是原子性的。</p><p>一致性：XA 协议实现的是强一致性。</p><p>隔离性：XA 事务在完成之前一直持有资源的锁，所以可以做到写隔离。</p><p>持久性：基于本地事务实现，所以这一点没有问题。</p><p>XA 是出现最早的分布式事务规范，主流数据库 Oracle、MySQL、SQLServer 等都支持 XA 规范，J2EE 中的 JTA 规范也是参照 XA 规范编写的，与 XA 规范兼容。</p><p>XA 是在资源管理层面实现的分布式事务模型，对业务的入侵度较低。</p><p>XA 两阶段提交协议可以覆盖分布式事务的三种场景，但是全局事务的执行过程中，RM 一直持有资源的锁，如果参与的 RM 过多，尤其是跨服务的场景下，网络通信的次数和时间会急剧变多，所以阻塞的时间更长，系统的吞吐能力变得很差，事务死锁出现的概率也会变大，所以并不适合微服务架构场景中的跨服务的分布式事务模式。</p><p>每一个 TM 域来说，由于 TM 是单点，存在单点故障风险，如果 TM 在阶段1之后挂掉，会导致参与的 RM 长时间收不到阶段 2 的请求而长期持有资源的锁，影响业务的吞吐能力。同时一次完整的全局事务，TM 和 RM 之间的交互多达 8 次，太繁琐，非常影响系统的处理性能。</p><p>XA 两阶段协议可能会造成脑裂的异常，假如 TM 在阶段 2 通知 RM 提交事务时，如果指令发出后就宕机了，而只有部分 RM 收到了提交请求，那么当 TM 恢复的时候，就无法协调本次事务所有的 RM 本地事务的一致性了。</p><p>XA 要处理的异常场景非常多，对框架的实现有一定的挑战，开源的实现，可以参考：Atomikos，Bitronix。</p><p>针对 XA 两阶段提交中的问题，有人提出了三阶段提交的改进方案，三阶段提交方案主要解决了单点故障问题，并在 RM 侧也引入了超时机制，以避免资源的长时间锁定。但是三阶段提交方案依然无法避免脑裂的异常情况出现，实际应用案例很少，感兴趣的同学可以自行找相关资料了解。</p><p>TCC</p><p>TCC (Try、Commit、Cancel) 是一种补偿型事务，该模型要求应用的每个服务提供 try、confirm、cancel 三个接口，它的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。</p><p>TCC 也是一种两阶段提交协议，可以看作 2PC&#x2F;XA 的一种变种，但是不会长时间持有资源锁。</p><p>TCC 模型将事务的提交划分为两个阶段：</p><p>1）阶段 1</p><p>完成业务检查（一致性）、预留业务资源（准隔离性），即 TCC 中的 try。</p><p>2）阶段 2</p><p>如果 try 阶段所有业务资源都预留成功，则执行 confirm 操作，否则执行 cancel 操作：</p><p>confirm：不做任何业务检查，仅仅使用预留的资源执行业务操作，如果失败会一直重试。</p><p>cancel：取消执行业务操作，释放预留的资源，如果失败会一直重试。</p><p><img src="https://pics3.baidu.com/feed/91529822720e0cf31238492e841a4919bc09aaff.png@f_auto?token=f84c1f561dc9fce0c0c1a91266fcde68" alt="img"></p><p>TCC 模式中，事务的发起者和参与者都需要记录事务日志，事务的发起者需要记录全局事务和各个分支事务的状态和信息；事务的参与者需要记录分支事务的状态。</p><p>TCC 事务在执行过程中的任意环节，均可能发生宕机、重启、网络中断等异常情况，此时事务处于非原子状态和非最终一致状态，此时就需要根据主事务记录和分支事务记录的日志，去完成剩余分支事务的提交或者回滚，使整个分布式事务内所有参展达到最终一致的状态，实现事务的原子性。</p><p><strong>举例</strong></p><p>我们以一个简单的电商系统为例，小明在淘宝上花 100 元买了一本书，获赠 10 个积分，产品上有如下几个操作：</p><p>订单系统创建商品订单支付系统接受小明的支付库存系统扣减产品库存会员系统给小明账户增加会员积分</p><p>这几个动作需要作为一个事务执行，要同时成功或者同时撤销。</p><p>如果采用 TCC 事务模式，那么各个系统需要改造为如下状态：</p><p>1）订单系统</p><p>try：创建一个订单，状态显示为“待支付”confirm：更新订单的状态为“已完成”cancel：更新订单的状态为“已取消”</p><p>2）支付系统</p><p>try：假设小明账户中有 1000 元，冻结小明账户中的 100 元，此时小明看到的余额依然是 1000 元。confirm：将账户余额变为 900 元，并清除冻结记录。concel：清除冻结记录。</p><p>3）库存系统</p><p>try：假设库存中还生 10 本书，冻结其中的一本书，现实库存依然有 10 本书。confirm：将剩余库存更新为 9 本书，并清除冻结记录。cancel：清除冻结记录。</p><p>4）会员系统</p><p>try：假设小明原因积分 3000 分，给小明账户预增加 10 积分，账户显示的积分依然是 3000 分。confirm：将账户积分更新为 3010，并清除预增加记录。cancel：清除预增加记录。</p><p><strong>特点剖析</strong></p><p>TCC 事务具备事务的四个特性：</p><p>原子性：事务发起方协调各个分支事务全部提交或者全部回滚。一致性：TCC 事务提供最终一致性。隔离型：通过 try 预分配资源的方式来实现数据的隔离。持久性：交由各个分支事务来实现。</p><p>TCC 事务模型对业务方侵入较大，需要业务方把功能的实现上由一个接口拆分为三个，开发成本较高。</p><p>同时 TCC 事务为了解决异步网络中的通信失败或超时带来的异常情况，要求业务方在设计实现上要遵循三个策略：</p><p>允许空回滚：原因是异常发生在阶段 1 时，部分参与方没有收到 try 请求从而触发整个事务的 cancel 操作，try 失败或者没有执行 try 操作的参与方收到 cancel 请求时，要进行空回滚操作。</p><p>保持幂等性：原因是异常发生在阶段 2 时，比如网络超时，则会重复调用参与方的 confirm&#x2F;cancel 方法，因此需要这两个方法实现上保证幂等性。</p><p>防止资源悬挂：原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 try 请求比 cancel 请求更晚到达的情况，cancel 会执行空回滚而确保事务的正确性，但是此时 try 方法也不可以再被执行。</p><p>TCC 事务将分布式事务从资源层提到业务层来实现，可以让业务灵活选择资源的锁定粒度，并且全局事务执行过程中不会一直持有锁，所以系统的吞吐量比 2PC&#x2F;XA 模式要高很多。</p><p>支持 TCC 事务的开源框架有：ByteTCC、Himly、TCC-transaction。</p><p>Saga</p><p>Saga 并不是一个新概念，其相关论文在 1987 年就发布了，和 XA 两阶段提交规范出现的时间差不多。</p><p>Saga 和 TCC 一样，也是一种补偿事务，但是它没有 try 阶段，而是把分布式事务看作一组本地事务构成的事务链。</p><p>事务链中的每一个正向事务操作，都对应一个可逆的事务操作。Saga 事务协调器负责按照顺序执行事务链中的分支事务，分支事务执行完毕，即释放资源。如果某个分支事务失败了，则按照反方向执行事务补偿操作。</p><p>假如一个 Saga 的分布式事务链有 n 个分支事务构成，[T1,T2,…,Tn]，那么该分布式事务的执行情况有三种：</p><p>T1,T2,…,Tn：n 个事务全部执行成功了。</p><p>T1,T2,…,Ti,Ci,…,C2,C1：执行到第 i (i&lt;&#x3D;n) 个事务的时候失败了，则按照 i-&gt;1 的顺序依次调用补偿操作。如果补偿失败了，就一直重试。补偿操作可以优化为并行执行。</p><p>T1,T2,…,Ti (失败),Ti (重试),Ti (重试),…,Tn：适用于事务必须成功的场景，如果发生失败了就一直重试，不会执行补偿操作。</p><p><img src="https://pics7.baidu.com/feed/3bf33a87e950352ac93f1c4cda1f40f4b3118bfe.jpeg@f_auto?token=c55f6111c8fe54054b09acff243df47c" alt="img"></p><p><strong>举例</strong></p><p>假如国庆节小明要出去玩，从北京出发，先去伦敦，在伦敦游玩三天，再去巴黎，在巴黎游玩三天，然后再返回北京。整个行程中涉及不同航空公司的机票预订以及伦敦和巴黎当地的酒店预订，小明的计划是如果任何一张机票或酒店预订不上，就取消本次出行计划。假如综合旅游出行服务平台提供这种一键下单的功能，那么这就是一个长事务，用 Saga 模式编排服务的话，就如下图所示：任何一个环节失败的话，就通过补偿操作取消前面的行程预订。</p><p><img src="https://pics7.baidu.com/feed/8326cffc1e178a82ab09e1367c5fc88ba877e8d6.png@f_auto?token=8fd901e793f623020986ea6b01064abe" alt="img"></p><p><strong>特点剖析</strong></p><p>Saga 事务是可以保障事务的三个特性：</p><p>原子性：Saga 协调器可以协调事务链中的本地事务要么全部提交，要么全部回滚。</p><p>一致性：Saga 事务可以实现最终一致性。</p><p>持久性：基于本地事务，所以这个特性可以很好实现。</p><p>但是 Saga 不保证事务隔离性的，本地事务提交后变更就对其他事务可见了。其他事务如果更改了已经提交成功的数据，可能会导致补偿操作失败。比如扣款失败，但是钱已经花掉了，业务设计上需要考虑这种场景并从业务设计上规避这种问题。</p><p>Saga 事务和 TCC 事务一样，对业务实现要求高，要求业务设计实现上遵循三个策略：</p><p>允许空补偿：网络异常导致事务的参与方只收到了补偿操作指令，因为没有执行过正常操作，因此要进行空补偿。</p><p>保持幂等性：事务的正向操作和补偿操作都可能被重复触发，因此要保证操作的幂等性。</p><p>防止资源悬挂：网络异常导致事务的正向操作指令晚于补偿操作指令到达，则要丢弃本次正常操作，否则会出现资源悬挂问题。</p><p>虽然 Saga 和 TCC 都是补偿事务，但是由于提交阶段不同，所以两者也是有不同的：</p><p>Saga 是不完美补偿，补偿操作会留下之前原始事务操作的痕迹，需要考虑对业务上的影响。</p><p>TCC 是完美补偿，补偿操作会彻底清理之前的原始事务操作，用户是感知不到事务取消之前的状态信息的。</p><p>TCC 的事务可以更好的支持异步化，但是 Saga 模式一般在补偿阶段比较适合异步化。</p><p>Saga 模式非常适合于业务流程长的长事务的场景，实现上对业务侵入低，所以非常适合微服务架构的场景。同时 Saga 采用的是一阶段提交模式，不会对资源长时间加锁，不存在“木桶效应”，所以采用这种模式架构的系统性能高、吞吐高。</p><p>阿里巴巴的 Seata 开源项目和华为的 ServiceComb 开源项目都支持 Saga 模式。</p><p>基于消息的分布式事务</p><p>基于消息的分布式事务模式核心思想是通过消息系统来通知其他事务参与方自己事务的执行状态。</p><p>消息系统的引入更有效的将事务参与方解耦，各个参与方可以异步执行。</p><p>该种模式的难点在于解决本地事务执行和消息发送的一致性：两者要同时执行成功或者同时取消执行。</p><p>实现上主要有两种方式：</p><p>基于事务消息的方案基于本地消息的方案</p><p><strong>基于事务消息的分布式事务</strong></p><p>普通消息是无法解决本地事务执行和消息发送的一致性问题的。因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现。</p><p>解决这个问题，需要引入事务消息，事务消息和普通消息的区别在于事务消息发送成功后，处于 prepared 状态，不能被订阅者消费，等到事务消息的状态更改为可消费状态后，下游订阅者才可以监听到次消息。</p><p>本地事务和事务消息的发送的处理流程如下：</p><p>事务发起者预先发送一个事务消息。</p><p>MQ 系统收到事务消息后，将消息持久化，消息的状态是“待发送”，并给发送者一个 ACK 消息。</p><p>事务发起者如果没有收到 ACK 消息，则取消本地事务的执行；如果收到了 ACK 消息，则执行本地事务，并给 MQ 系统再发送一个消息，通知本地事务的执行情况。</p><p>MQ 系统收到消息通知后，根据本地事务的执行情况更改事务消息的状态，如果成功执行，则将消息更改为“可消费”并择机下发给订阅者；如果事务执行失败，则删除该事务消息。</p><p>本地事务执行完毕后，发给 MQ 的通知消息有可能丢失了。所以支持事务消息的 MQ 系统有一个定时扫描逻辑，扫描出状态仍然是“待发送”状态的消息，并向消息的发送方发起询问，询问这条事务消息的最终状态如何并根据结果更新事务消息的状态。因此事务的发起方需要给 MQ 系统提供一个事务消息状态查询接口。</p><p>如果事务消息的状态是“可发送”，则 MQ 系统向下游参与者推送消息，推送失败会不停重试。</p><p>下游参与者收到消息后，执行本地事务，本地事务如果执行成功，则给 MQ 系统发送 ACK 消息；如果执行失败，则不发送 ACK 消息，MQ 系统会持续推送给消息。</p><p><img src="https://pics1.baidu.com/feed/dc54564e9258d109f97984e6590477b96d814daa.png@f_auto?token=7e70a5f432da006c05678ecc2f8b191d" alt="img"></p><p><strong>基于本地消息的分布式事务</strong></p><p>基于事务消息的模式对 MQ 系统要求较高，并不是所有 MQ 系统都支持事务消息的，RocketMQ 是目前为数不多的支持事务小的 MQ 系统。如果所依赖的 MQ 系统不支持事务消息，那么可以采用本地消息的分布式模式。</p><p>该种模式的核心思想是事务的发起方维护一个本地消息表，业务执行和本地消息表的执行处在同一个本地事务中。业务执行成功，则同时记录一条“待发送”状态的消息到本地消息表中。系统中启动一个定时任务定时扫描本地消息表中状态为“待发送”的记录，并将其发送到 MQ 系统中，如果发送失败或者超时，则一直发送，知道发送成功后，从本地消息表中删除该记录。后续的消费订阅流程则与基于事务消息的模式雷同。</p><p><img src="https://pics0.baidu.com/feed/a50f4bfbfbedab64e165b6807e6a14c579311e3a.png@f_auto?token=5116c02293edada2fe357d8960adb6c6" alt="img"></p><p><strong>特点剖析</strong></p><p>基于消息的分布式事务模式对 ACID 特性的支持如下：</p><p>原子性：最终可以实现分支事务都执行或者都不执行。一致性：提供最终一致性。隔离性：不保障隔离性。持久性：由本地事务来保证。</p><p>基于消息的分布式事务可以将分布式系统之间更有效的解耦，各个事务参与方之间的调用不再是同步调用。</p><p>对 MQ 系统的要求较高，对业务实现也有一定的侵入性，要么提供事务消息状态查询接口，要么需要维护本地消息表。并且原则上只接受下游分支事务的成功，不接受事务的回滚，如果失败就要一直重试，适用于对最终一致性敏感度较低的业务场景，例如跨企业的系统间的调用，适用的场景有限。</p><p>最大努力通知型分布式事务</p><p>最大努力通知型的分布式事务解决方案，也是基于 MQ 系统的一种解决方案，但是不要求 MQ 消息可靠。</p><p><strong>举例</strong></p><p>假设小明通过联通的网上营业厅为手机充话费，充值方式选择支付宝支付。整个操作的流程如下：</p><p>小明选择充值金额“50 元”，支付方式“支付宝”。</p><p>联通网上营业厅创建一个充值订单，状态为“支付中”，并跳转到支付宝的支付页面（此时进入了支付宝的系统中）。</p><p>支付宝验明确认小明的支付后，从小明的账户中扣除 50 元，并向联通的账户中增加 50 元。执行完毕后向 MQ 系统发送一条消息，消息的内容标识支付是否成功，消息发送允许失败。</p><p>如果消息发送成功，那么支付宝的通知服务会订阅到该消息，并调用联通的接口通知本次支付的结果。如果此时联通的服务挂掉了，导致通知失败了，则会按照 5min、10min、30min、1h、…、24h 等递增的时间间隔，间隔性重复调用联通的接口，直到调用成功或者达到预订的时间窗口上限后，则不再通知。这就是尽最大努力通知的含义。</p><p>如果联通服务恢复正常，收到了支付宝的通知，如果支付成功，则给账户充值；如果支付失败，则取消充值。执行完毕后给支付宝通知服务确认响应，确认响应允许失败，支付宝系统会继续重试。所以联通的充值接口需要保持幂等性。</p><p>如果联通服务故障时间很久，恢复正常后，已超出支付宝通知服务的时间窗口，则联通扫描“支付中”的订单，主动向支付宝发起请求，核验订单的支付结果。</p><p><strong>特点剖析</strong></p><p>最大努力通知型方案本质是通过引入定期校验机制来对最终一致性做兜底，对业务侵入性较低、对 MQ 系统要求较低，实现比较简单，适合于对最终一致性敏感度比较低、业务链路较短的场景，比如跨平台、跨企业的系统间的业务交互。</p><p><strong>分布式事务中间件</strong></p><p>阿里巴巴有两个分布式事务中间件可选择：</p><p>蚂蚁金服团队开发的 XTS，金融云产品名称为 DTX。阿里巴巴中间件团队开发的 TXC。</p><p>XTS 和 TXC 的功能差不多，都支持 TCC 事务模式，也都提供了对业务入侵度较低的分布式事务方案，目前这两个团队应该是在共建开源版的分布式事务中间件 Seata。此处我们介绍一下 Seata。</p><p>Seata</p><p>简单说一下 Seata (Simple Extensible Autonomous Transaction Architecture) 的历史：</p><p>2014 年阿里巴巴就已经推出了分布式事务中间件产品 TXC (Taobao Transaction Constructor)。</p><p>2016 年，TXC 进行了云产品化改造，提供了阿里云的云版本，名字叫做 GTS (Global Transaction Service) 。</p><p>2019 年，GTS 宣布开源，开源项目的名字叫做 Seata。</p><p>Seata 支持 TCC 模式、Saga 模式。但是 Seata 对 TCC 模式的支持提供了一种对业务入侵度为0的解决方案，这种方案叫做 AT (Automatic Transaction) 模式。下面我们重点说一下 AT 模式的运行机制：</p><p>全局事务依然是基于各个分支事务来完成。Seata Server 协调各个分支事务要么一起提交，要么一起回滚。</p><p>各个分支事务在运行时，Seata Client 通过对 SQL 执行的代理和拦截，通过解析 SQL 定位到行记录，记录下 SQL 执行前后的行数据快照，beforeImage 和 afterImage 共同构成了回滚日志，回滚日志记录在独立的表中。回滚日志的写入和业务数据的更改在在同一个本地事务中提交。</p><p>分支事务完成后，立即释放对本地资源的锁，然后给 Seata 协调器上报事务执行的结果。</p><p>Seata 协调器汇总各个分支事务的完成情况，生成事务提交或者回滚的决议，将决议下发给 Seata Client。</p><p>如果决议是提交事务，则 Seata Client 异步清理回滚日志；如果决议是回滚事务，则 Seata Client 根据回滚日志进行补偿操作，补偿前会对比当前数据快照和 afterImage 是否一致，如果不一致则回滚失败，需要人工介入。</p><p><img src="https://pics1.baidu.com/feed/b2de9c82d158ccbf7f89cf1495840738b135414d.png@f_auto?token=360fae75e5fc68c31b60e6bb68f9051b" alt="img"></p><p>AT 模式通过自动生成回滚日志的方式，使得业务方接入成本低，对业务入侵度很低，但是应用 AT 模式也有一些限制：</p><p>AT 模式只支持基于 ACID 事务的关系数据库。</p><p>AT 模式是通过对 SQL 解析来完成的，对 SQL 语法的支持有限，使用复杂 SQL 时需要考虑兼容性。</p><p>目前不支持复合主键，业务表在设计时注意添加自增主键。</p><p>全局事务默认的隔离级别是读未提交，但是通过 SELECT…FOR UPDATE 等语句，可以实现读已提交的隔离级别。通过全局排它写锁，可以做到的隔离级别介于读未提交和读已提交之间。</p><p><strong>总结</strong></p><p>单体数据库事务很容易满足事务的 ACID 四个特性，提供强一致性保证，但是分布式事务要完全遵循 ACID 特性会比较困难。为了追求分布式系统的高可用和高吞吐，分布式事务的解决方案一般提供的是最终一致性。</p><p>我们把提供强一致性的事务称之为刚性事务，把提供最终一致性的事务称之为柔性事务。刚性事务可以完全满足 ACID 四个特性，柔性事务对事务的 ACID 特性的支持情况如下：</p><p>原子性：完全支持。一致性：只提供最终一致性支持。隔离性：不完全保证，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求。持久性：完全支持。</p><p>柔性事务一般遵循的是分布式领域中的 BASE 理论：</p><p>BA：Basic Availability，基本业务可用性。S：Soft state，柔性状态。E：Eventual consistency，最终一致性。</p><p>BASE 理论，是对 CAP 理论的延伸，是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p>CAP 理论告诉我们一个分布式系统无法同时满足一致性, 可用性, 分区容错性，所以在设计上对这三点做取舍。刚性事务追求强一致性，所以牺牲了高可用性；柔性事务通过牺牲一致性换来了系统的高可用性。</p><p>在系统选择分布式方案时，可以根据对一致性的要求进行选择，业务上有强一致性要求的场景时，优先考虑 XA 规范的两阶段提交；业务上只需要最终一致性的场景时，可以在根据具体场景在柔性事务方案中进行选择。</p><p>参考[1]分布式事务中间件TXC（<a href="http://mw.alibaba-inc.com/product-txc.html%EF%BC%89[2]%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1%EF%BC%88https://www.jianshu.com/p/8095001d79bb%EF%BC%89[3]%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6ServiceComb%EF%BC%88http://servicecomb.apache.org/cn/docs/distributed-transactions-saga-implementation/%EF%BC%89[4]%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%88https://sq.163yun.com/blog/article/165554812476866560%EF%BC%89[5]Seata%EF%BC%88https://seata.io/zh-cn/%EF%BC%89[6]TCC%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%EF%BC%88https://www.cnblogs.com/jajian/p/10014145.html%EF%BC%89[7]TCC%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF%EF%BC%88https://blog.csdn.net/dm_vincent/article/details/92432059[8]Compensating">http://mw.alibaba-inc.com/product-txc.html）[2]弹力设计之补偿事务（https://www.jianshu.com/p/8095001d79bb）[3]分布式事务中间件ServiceComb（http://servicecomb.apache.org/cn/docs/distributed-transactions-saga-implementation/）[4]深入理解两阶段提交（https://sq.163yun.com/blog/article/165554812476866560）[5]Seata（https://seata.io/zh-cn/）[6]TCC事务原理（https://www.cnblogs.com/jajian/p/10014145.html）[7]TCC事务异常场景（https://blog.csdn.net/dm_vincent/article/details/92432059[8]Compensating</a> Transaction Pattern（<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction%EF%BC%89[9]%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88https://www.jianshu.com/p/04bad986a4a2%EF%BC%89[10]%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0%EF%BC%88http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383%EF%BC%89[11]%E5%88%9D%E8%AF%86Open/X">https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction）[9]基于消息的分布式事务（https://www.jianshu.com/p/04bad986a4a2）[10]分布式事务概述（http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383）[11]初识Open/X</a> XA（<a href="https://www.jianshu.com/p/6c1fd2420274%EF%BC%89[12]DTP">https://www.jianshu.com/p/6c1fd2420274）[12]DTP</a>: XA Specification（<a href="https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf%EF%BC%89[13]DTP">https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf）[13]DTP</a> Model（<a href="https://pubs.opengroup.org/onlinepubs/009249599/toc.pdf">https://pubs.opengroup.org/onlinepubs/009249599/toc.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新人如何快速上手项目管理</title>
      <link href="/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>互联网公司除了业务迭代快，大型战役活动也不少，比如阿里巴巴的双11、阿里影业的春节档、优酷的世界杯等等。这些大型战役，不仅考验技术人的代码功底，更考验在超大型项目中团队协作能力、快速应变能力。</p><p>本文将从PMO的专业能力+技术人的实践视角，详解大型项目及战役的运作流程，将复杂项目做模块化拆解，教你站在项目全局看技术实践，同时例举团队高效沟通的技巧，希望为当下SOHO的互联网人带来启发。</p><h1 id="二、做好大型项目的五个关键"><a href="#二、做好大型项目的五个关键" class="headerlink" title="二、做好大型项目的五个关键"></a>二、做好大型项目的五个关键</h1><p>几百人、上千人组成的大型项目&#x2F;战役有很多挑战，乍一看让人望而却步，但仔细梳理下来好像也没有那么复杂，只需要厘清以下的关键：</p><p>拿什么结果 -&gt; 项目的目标<br>谁是我战友 -&gt; 项目的成员<br>啥时候吹号 -&gt; 项目的计划<br>怎么来协同 -&gt; 项目的机制<br>战后做点啥 -&gt; 复盘和沉淀</p><p>思路就是: 明确事-&gt;找对人-&gt;排计划-&gt;定机制-&gt;收好尾。不过，从项目特质上来说，信息是渐明渐细的，梳理和澄清是一件持续的工作。</p><h1 id="三、问题厘清"><a href="#三、问题厘清" class="headerlink" title="三、问题厘清"></a>三、问题厘清</h1><p>有了整体的思路,心里也就有了底气，但也不能眉毛胡子一把抓。不同的阶段重点不同，按照常见的项目阶段来看，可以分为启动期、规划期、执行期、监控期及收尾期。每个阶段需要明确关键目标，锁定核心问题。</p><p>启动期：明确方向，确认人员，厘清目标，明确机制，制定里程碑计划；</p><p>规划期：明确目标、确认方案，制定执行计划；</p><p>执行期：紧盯目标、管控计划、保障落地；</p><p>监控期：基于目标、运用机制、核查计划、发掘风险，制定预案，管控变更。理论上从规划期到收尾期都属于监控期，但项目的差异，着力点和力度有不同。常见的互联网项目，执行期监控力度最大，所以一些流程上把执行和监控揉和在一起了；</p><p>收尾期；有序收尾、深度复盘、有效沉淀。</p><p>这里已经明确了各节点的重点，那如何抓住这些节点值得探讨。作为项目PM或团队管理者，需要把控三点：</p><p>驱动管理节点，紧盯目标，这个目标是宏观的目标，包括业务目标、进度目标、人员的目标；</p><p>保障沟通通道，保障信息的上传下达，步调一致，协同各团队有效参与；</p><p>运用管理机制，包括目标负责制、沟通机制、需求管理机制等；</p><h1 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h1><p><strong>1. 驱动管理节点</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/27ff29481551406899e004d6fbca3eb0.jpeg"></p><p>管理节点一方面要拉齐信息，另一方面要发掘风险和问题，及时做出应对。关键点上核心信息的确认和决策以及同步，当面的会议沟通是非常有效的手段，但保障会议有效是其中的关键。</p><p>会议前；做好议题收集和准备，特别是会议的前置输入材料和关键信息提前准备好；</p><p>会议中；聚焦议题和发言顺序，控制会议时间，保障会议有效；</p><p>会议后；要有结论输出并同步参会人及关联方；</p><p>SOHO模式下，IM、音视频及共享屏幕工具尤为重要，尽量选择团队日常使用、通用性好、使用复杂度低的工具并分享使用TIPS。整体会议安排上做好协同，避免过度的会议影响正常工作；</p><p>方向对焦会: 基于项目价值、核心1号位及关键同学，通过会议确认并输出：方向、初步策略、里程碑及运行机制；</p><p>方案review会: 会议前基于方向对焦会结论，已产出核心方案草案，且在该草案基础上拉通关联团队输出联动业务方案；</p><p>需求评审会：基于业务方案和平台能力明确当前业务需求，通过需求评审会确认各负责人及落地计划；</p><p>复盘会：基于目标、方案结合当前完成情况进行复盘，重点是可复用能力的沉淀和发现问题的后续跟进。</p><p><strong>2. 保障沟通通道</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/54286eb66b854a88bf99f554b169678e.jpeg"></p><p>日会：通过项目例会对焦核心信息，同时进行关键工作进度同步、成果验收和快速决策。根据项目所处的阶段和工作的颗粒度，可以调整会议的频率，但不适宜频繁调整节奏和会议室；</p><p>日报：围绕核心目标、策略、进展、风险等核心信息有效记录和同步，重要信息需和对接人确认并反馈；</p><p>文档库：提升信息管理效率，降低PM和关键人员沟通瓶颈；促使团队自主联动，有效同步和纪录核心信息，持续沉淀关键信息给后续复盘和项目做好沉淀。</p><p><strong>3. 建立和运用机制</strong></p><p>持续和聚焦目标、策略（方案）、进度（计划）促成高效执行；发掘和同步风险，准备预案消除和降低风险危害。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/1faec555f23d4b7eb11b9a28a14d2e2f.jpeg"></p><h1 id="五、关键点"><a href="#五、关键点" class="headerlink" title="五、关键点"></a>五、关键点</h1><p><strong>1. K.O.（启动会）</strong>:</p><p>目的：启动会能够让各个业务部门的人员清楚知道项目的概况，目标、策略、落地计划，懂得如何配合，确保后续各部门人员配合到位，沟通协调效率高，有利于推动整个项目的推进。</p><p>操作：</p><p>1）会前准备</p><p>明确参会人员：确定他们的时间，并据此确定会议地点。SOHO模式下，选择好协同工具，比如视频会议、视频直播，提前试用告知参会者准备参会设备；</p><p>划分讲话内容：为发言者圈定讲话范围和时限，让参会者要求准备发言内容；线上沟通，需要比现场沟通更精炼；</p><p>准备相关资料：包括宣传资料、现场摆设、座位分布、相关配套服务等等。</p><p>2）会议通知</p><p>召开项目启动会通常提前3天发布通知，紧急情况下适当调整，同时要提前与参会的核心人员进行沟通，让参会人员事先了解自己在项目中需要负责的工作和担任的角色。项目团队的所有成员都要参加项目启动会议，即使有人当时不在办公室，也尽可能通过电话参与会议。</p><p>3）会议议程</p><ol><li>由项目负责人介绍项目背景、目标、范围，奠定整个项目的基础；</li><li>由各业务负责人介绍产品方案；</li><li>由项目经理介绍项目管理机制，包括安全机制、奖惩机制、沟通机制（日会、周会、日报、周报等）、变更管理等；</li><li>由项目负责人为各团队负责人颁发委任状或立军令状，并全团队大合影，在SOHO模式下可以选择工作照拼图。</li></ol><p>4）会议原则</p><p>高层的领导尽量邀请到，这样各负责人可以提高重视度，更积极的组织个参与工作。启动会一定要按时开始、按时结束。这代表着项目管理的基调和规则，有利于形成守时、高效的项目管理风格。<br>启动会必须要正式，会议的议程和时间可以缩短，但是会议的规格和对参会人员的重视程度一定要达到标准，要让参会人员觉得会议很重要，老大讲话投屏、横幅、座位牌、水等尽量要有保证。</p><p>5）会议总结</p><p>项目启动会是一种关键信息对焦和拉通形式，所以，需要总结会议的重点内容和后续计划，并把会上领导关键讲话作为项目过程中的指导方针，把团队的合影、军令状、项目的K.O.文件等在会后一并发给大家，推进项目展开。</p><p><strong>2. 风险管理</strong></p><p>风险在各个项目里长期存在，识别、反馈及处理风险是持续工作。在项目里一方面要建立全员风险管理的意识，鼓励风险的及时识别和上报。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/ae6b0977ab224917a766e454727e1762.jpeg"></p><p><strong>3. 相关方管理</strong></p><p>项目经理需要识别项目相关方，分析其对项目的要求或需求，并且管理好这些要求和需求，满足不同的相关方，从而以确保项目的成功。识别和管理相关方是项目中持续要做的工作，且需要明确反对项目的人或组织同样属于相关方。</p><p>1）识别相关方:</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/d89ddefefd304a9d93b84e35ac336fe5.jpeg"></p><p>2）管理相关方：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/7dfe083ddf55453a952cca8564f35a63.jpeg"></p><p><strong>4. 复盘</strong></p><p>目的：基于目标、方案结合当前完成情况进行复盘，沉淀可服用能力，发掘系统缺陷和无效策略，在结束后修复完善漏洞并记录为下一个项目提供支撑和规避；</p><p>时机：</p><p>不同的项目复盘契机存在差异，但复盘的目标需要明确，一定要杜绝无效的复盘；</p><ol><li>时限型项目达到预定时间；例如：3月底完成APP DAU提升XX的目标；</li><li>目标型项目达到预定目标；例如：Q3完成APP客诉量下降一半的目标；</li><li>项目出现严重问题；</li></ol><p>操作：</p><p>1）复盘原则：</p><p>多目标以目标纬度复盘，确保链条完整性；<br>子项目复盘在组内进行，保障复盘有效性；<br>鼓励畅所欲言，警惕自我吹捧、禁止互相攻击。</p><p>2）会前准备:</p><p>明确需要参与人、时间、地点；划分讲话内容，为发言者圈定讲话范围和时限，让发言者要求准备<br>准备相关资料，包括前期方案及过程数据。</p><h1 id="六、结束语"><a href="#六、结束语" class="headerlink" title="六、结束语"></a>六、结束语</h1><p>以上是组织一个项目的简要流程。从阿里文娱PMO团队的经验出发，项目过程中会有很多复杂的问题出现，但发挥项目的团队能力，最终都能顺利解决。此外，还可以寻求专业的项目管理团队作为教练赋能，最终实现：</p><ol><li>目标可预测；</li><li>资源可调度；</li><li>变化可控制；</li><li>问题可见和追溯，使得战役有序打响并取得预期的胜利。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servicemesh和API Gateway关系深度探讨</title>
      <link href="/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/"/>
      <url>/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://skyao.io/post/202004-servicemesh-and-api-gateway/">https://skyao.io/post/202004-servicemesh-and-api-gateway/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Service Mesh和API Gateway之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在Service Mesh和API Gateway融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。</p><blockquote><p>备注1：为了节约篇幅，我们将直奔主题，假定读者对Servicemesh和API Gateway已有基本的了解。</p><p>备注2: 这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。</p></blockquote><h2 id="原本清晰的界限：定位和职责"><a href="#原本清晰的界限：定位和职责" class="headerlink" title="原本清晰的界限：定位和职责"></a>原本清晰的界限：定位和职责</h2><p>首先，Service Mesh和API Gateway在功能定位和承担的职责上有非常清晰的界限：</p><ul><li>Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯</li><li>API Gateway： 负责将服务以API的形式暴露（给系统外部），以实现业务功能</li></ul><p>如上图所示：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>从功能和职责上说：</p><ul><li>位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力</li><li>在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务</li><li>原子微服务和组合服务部署于 <strong>系统内部</strong>，在采用servicemesh的情况下，由servicemesh提供服务间通讯的能力</li><li>API Gateway用于将系统内部的这些服务暴露给 <strong>系统外部</strong>，以API的形式接受外部请求。</li></ul><p>从部署上说：</p><ul><li>Servicemesh部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统</li><li>API Gateway部署在系统的边缘：一方面暴露在系统之外，对外提供API供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。</li></ul><p>在这里引入两个使用非常广泛的术语：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_407b3c3a252215b00281feebff74034e.png" alt="img"></p><ul><li><strong>东西向</strong>通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部</li><li><strong>南北向</strong>通讯：指服务对外部提供访问，通常是通过API Gateway提供的API对外部保罗，其通讯流量是从系统外部进入系统内部。</li></ul><blockquote><p>解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左西右东”的原则。</p></blockquote><p>总结：Service Mesh和API Gateway在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现Service Mesh和API Gateway关系的讨论了，自然也不会有本文。</p><p>问题的根源在哪里？</p><blockquote><p>强烈推荐阅读：附录中 Christian Posta 的文章 “Do I Need an API Gateway if I Use a Service Mesh?“对此有深度分析和讲解。</p></blockquote><h2 id="哲学问题：网关访问内部服务，算东西向还是南北向？"><a href="#哲学问题：网关访问内部服务，算东西向还是南北向？" class="headerlink" title="哲学问题：网关访问内部服务，算东西向还是南北向？"></a>哲学问题：网关访问内部服务，算东西向还是南北向？</h2><p>如下图所示，图中黄色的线条表示的是API Gateway访问内部服务：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看 API Gateway 访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_3639b8345d877d10b889d082af357bb8.png" alt="img"></p><p>所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway ，是作为一个整体，还是逻辑上分拆为对内对外两个部分。</p><p>这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现 “API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：</p><ol><li>泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway访问内部服务的通讯机制自行实现，独立于服务间通讯的机制</li><li>兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。</li></ol><p>而最终决策通常也和产品的定位有关：如果希望维持 API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如springcloud生态下的zuul和springcloud gateway。</p><p>但无论选择哪个流派，都改变不了一个事实，当 “API Gateway 作为一个客户端访问内部服务” 时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证…… 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。</p><p>这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。</p><p>这里又是一个类似的哲学问题：当 “API Gateway 作为一个客户端访问内部服务” 时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？</p><p>答案不重要。</p><h2 id="Sidecar：真正的重合点"><a href="#Sidecar：真正的重合点" class="headerlink" title="Sidecar：真正的重合点"></a>Sidecar：真正的重合点</h2><p>在进入servicemesh时代之后，Servicemesh和API gateway 的关系开始是这样：</p><ol><li>功能和职责清晰划分</li><li>客户端访问服务的功能高度重叠</li></ol><p>此时两者的关系很清晰，而且由于当时Servicemesh和API Gateway是不同的产品，两者的重合点只是在功能上。</p><p>而随着时间的推移，当 Servicemesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。</p><p>在Servicemesh出现之后，如何为基于Servicemesh的服务选择合适的API Gateway方案，就慢慢开始提上日程，而其中选择重用Servicemesh的能力也自然成为一个探索的方向，并逐步出现新式API Gateway产品，其想法很直接：</p><p><strong>如何融合东西向和南北向的通讯方案？</strong></p><p>其中的一个做法就是基于Servicemesh的Sidecar来实现API Gateway，从而在南北向通讯中引入Servicemesh这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片(鸣谢赵化冰同学)来解释这个方案的思路：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_b3dce2008e0a698c0a2c0b94fa11cd72.png" alt="img"></p><p>这个时候servicemesh和API Gateway的关系就变得有意思了，因为servicemesh中sidecar的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：</p><ol><li>API Gateway本体：实现API Gateway除了访问内部服务之外的功能</li><li>Sidecar：按照servicemesh的标准做法， 我们视API Gateway为一个部署于servicemesh中的普通服务，为这个服务1:1的部署sidecar</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_7f2933075826470040bdc993f499a41f.png" alt="img"></p><p>在这个方案中，原来用于servicemesh的sidecar，被用在了API Gateway中，替代了API Gateway中原有的客户端访问的各种功能。这个方案让API Gateway的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway可以更专注于 “API Management” 的核心功能。</p><p>此时 servicemesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。</p><p>而采用这个方案的公司，通常都是先有servicemesh产品，再基于servicemesh产品规划（或者重新规划）API Gateway方案，典型如蚂蚁金服的SOFA Gateway产品是基于MOSN，而社区开源产品Ambassador和Gloo都是基于Envoy。</p><p>上述方案的优势在于API Gateway和Sidecar独立部署，职责明确，架构清晰。但是，和servicemesh使用sidecar被质疑多一跳会造成性能开销影响效率一样，API Gateway使用Sidecar也被同样的质疑：多了一跳……</p><p>解决“多一跳”问题的方法简单而粗暴，基于sidecar，将API Gateway的功能加进来。这样API Gateway本体和Sidecar再次合二为一：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_9c29254ffd88f10a2d87f5207d0cd98f.png" alt="img"></p><p>至于走到这一步之后，Servicemesh和API Gateway是什么关系：这到底算是Servicemesh&#x2F;sidecar融合了API Gateway，还是API Gateway融合了Servicemesh&#x2F;Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。</p><h2 id="BFF：把融合进行到底"><a href="#BFF：把融合进行到底" class="headerlink" title="BFF：把融合进行到底"></a>BFF：把融合进行到底</h2><p>BFF(Backend For Frontend)的引入会让Servicemesh和API Gateway走到一个更加亲密的地步。</p><p>先来看看常规的BFF的玩法：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_e140284a158e9b4b6564033a00470096.png" alt="img"></p><p>在这里，多增加了一个 BFF 层，介于API Gateway和内部服务（包括组合服务和原子微服务）之间。注意BFF的工作模式和组合服务很类似，都是组合多个服务。但差别在于：</p><ol><li>组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务</li><li>BFF不同，BFF如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问</li><li>对我们今天的话题而言，最关键的一点：BFF完全收口了从外部进入的流量，而组合服务没有，API Gateway是可以直接访问原子微服务的</li></ol><p>“BFF完全收口外部流量”，这一点在API Gateway和Sidecar融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有BFF的情况下，API Gateway和Sidecar融合后的情景：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_651c59dccf7914428f283feed4dbd00c.png" alt="img"></p><p>放大一点，单独看API Gateway和BFF：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_f9c39a8b510c458355adaf5a268ca4e7.png" alt="img"></p><p>注意到，流量从被API Gateway接收，到进入BFF在这个流程中，这个请求路径中有两个sidecar：</p><ol><li>和BFF部署在一起的，是没有API Gateway功能的普通Sidecar</li><li>API Gateway和Sidecar融合之后，这就是一个“有API Gateway功能的大Sidecar”（或者是“有Sidecar功能的特殊API Gateway”）：虽然扮演了API Gateway的角色，但本质上依然包含一个完整功能的sidecar，和BFF自带的Sidecar是等同的</li></ol><p>所以，问题来了：为什么要放两个sidecar在流程中，缩减到一个会怎么样？我们尝试将两个Sidecar合二为一，去掉BFF自带的Sidecar，直接把扮演API Gateway的sidecar给BFF用：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_a41f2181acde4f58b132873302a99e57.png" alt="img"></p><p>此时的场景是这样：</p><ol><li>流量直接打到BFF上（BFF前面可能会挂其他的网络组件提供负载均衡等功能）</li><li>BFF的sidecar接收流量，完成API Gateway的功能，然后将流量转给BFF</li><li>BFF通过sidecar调用内部服务（和没有合并时一致）</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_65454a16542646a5a9751b76bd5d8927.png" alt="img"></p><p>注意这里有一个关键点，在前面时特意注明的：“<strong>BFF完全收口外部流量</strong>”。这是前提条件，因为原有的API Gateway集群已经不再存在，如果BFF没能收口全部流量，则这些未能收口的流量会找不到API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带API Gateway功能的Sidecar，也是可行的，只是管理上会比BFF模式要复杂一些。</p><p>另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的API Gateway的集群，常规的中心化的网关在这个方案中被融合到每一个BFF的实例中，从而实现另外一个重要特性：去中心化。</p><p>上述Servicemesh 和 API Gateway融合的方案，并未停留在纸面上。</p><p>在蚂蚁金服内部，我们基于Servicemesh 和 API Gateway融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化&#x2F;Sidecar化，最终演变成了这样一个方案：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_0d19f1a6e1e5aee915cd771adc2553b2.png" alt="img"></p><blockquote><p>强烈推荐阅读：附录中我的同事 贾岛 的文章 “蚂蚁金服 API Gateway Mesh 思考与实践” 对此有深入介绍和详细描述。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了 Servicemesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是API Gateway和Sidecar 合二为一。</p><p>后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。</p><p>补充介绍一下文中多次提到的“MOSN”：</p><p>MOSN 是 MOSN 是 Modular Open Smart Network 的简称， 是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。 MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。 MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。</p><ul><li>GitHub：<a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a></li><li>官网：<a href="https://mosn.io/">https://mosn.io</a></li></ul><h2 id="附录：参考资料和推荐阅读"><a href="#附录：参考资料和推荐阅读" class="headerlink" title="附录：参考资料和推荐阅读"></a>附录：参考资料和推荐阅读</h2><p>意犹未尽的同学，欢迎继续阅读以下内容。</p><p>按文章发表的时间排序：</p><ul><li><a href="https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/">The Difference Between API Gateways and Service Mesh</a>： 2020-02，指导架构师确定何时使用API网关以及何时使用服务网格，作者Marco Palladino，来自kong。</li><li><a href="https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">Do I Need an API Gateway if I Use a Service Mesh?</a>：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 <a href="https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">使用了 Service Mesh 后我还需要 API 网关吗</a>，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。</li><li><a href="https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN">蚂蚁金服 API Gateway Mesh 思考与实践</a>: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和API Gateway Mesh的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在Servicemesh和API Gateway融合方面的实践。</li><li><a href="https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/">API Gateway的身份认同危机</a>: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述API Gateway的基本理念如API的定义，API Management的含义，API Gateway模式，以及服务网格和API Gateway的关系。</li><li><a href="https://skyao.io/talk/201810-ant-finance-service-mesh-practice/">长路漫漫踏歌而行：蚂蚁金服Service Mesh实践探索</a>: 2018-10，我在QCon的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于Sidecar的SOFA Gateway产品刚开始开发。</li><li><a href="https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784">API Gateway vs Service Mesh</a>: 2018-09，作者Richard Li，Datawire的CEO ，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的API Gateway开源产品，文章阐述了对服务网格和API Gateway的看法，差异，以及对两者集成的看法。</li><li><a href="https://skyao.io/post/201803-dreammesh-brainstorm-gateway/">DreamMesh抛砖引玉(9)-API Gateway</a>: 2018-03，这个文章也是我写的，2018年初我和servicemesh社区的一些朋友深入探讨之后，在DreamMesh系列博客文章中记录下了当时构想的方案，尤其对 API gateway和sidecar是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！</li><li><a href="https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56">Service Mesh vs API Gateway</a>: 2017-10，原文作者 <a href="https://medium.com/@kasunindrasiri">Kasun Indrasiri</a>，以及 <a href="https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/">赵化冰同学翻译的中文版本</a>，文章不长，主要对比了服务网格和API Gateway的产品功能，提出了两者融合的方式——在API Gateway中通过服务网格来调用下游服务。</li><li><a href="https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/">Application Network Functions With ESBs, API Management, and Now.. Service Mesh?</a>：2017-08，作者 Christian Posta，讲述服务网格与ESB，消息代理和API管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始k8s</title>
      <link href="/2020/04/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bk8s/"/>
      <url>/2020/04/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bk8s/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始k8s"><a href="#从零开始k8s" class="headerlink" title="从零开始k8s"></a>从零开始k8s</h1><p>译者：王乐</p><p>这部文档是面对想要学习Kubernetes集群的读者。如果你对入门指南已经可以满足你对这个列表上所列的需求，我们建议你继续阅读这个，因为他是根据前人积累经验所写的新手指南。当然如果除了学习入门指南知识外还希望学习IaaS，网络，配置管理或对操作系统有特殊要求，这个指南将会提供给学习者一个指导性的概述及思路。</p><h2 id="设计和准备"><a href="#设计和准备" class="headerlink" title="设计和准备"></a>设计和准备</h2><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ol><li><p>你应该已经熟悉Kubernetes了。我们建议根据 其他入门指南架设一个临时的集群。这样可以帮助你先熟悉Kubernetes命令行(kubectl)和一些概念(pods, services, 等等)。</p></li><li><p>当你浏览完其他入门指南的时候，你应该已经安装好了 kubectl 。如果没有，你可以根据这个说明安装。</p></li></ol><h2 id="Cloud-Provider"><a href="#Cloud-Provider" class="headerlink" title="Cloud Provider"></a>Cloud Provider</h2><p>Kubernetes有一个概念叫Cloud Provider，是指一个提供管理TCP负载均衡，节点（实例）和路由器接口的模块。 pkg&#x2F;cloudprovider&#x2F;cloud.go 里具体定义了这个接口。 当然，你也可以不用实现这个Cloud Provider去新建一个自定义的聚群（例如，使用裸机集群）。取决于不同部件是如何设置的，并不是所有接口都需要实现的。</p><h3 id="node（节点）"><a href="#node（节点）" class="headerlink" title="node（节点）"></a>node（节点）</h3><ul><li>你可以使用虚拟机或物理机。</li><li>为了运行本指南给出的例子和测试用例，你最好有4个节点以上。</li><li>虽说很多入门指南讲主节点和普通节点做了区分，但严格意义上讲，这不是必要的。</li><li>节点需要运行在x86_64的Linux系统上。当然也可能运行在其他的系统和CPU架构上，但这个指南不会提供相关的帮助。</li><li>对于一个拥有10个以上节点的集群来说，Apiserver和etcd可以一起安装在一台1核和1GB内存的机子上。</li><li>你可以给其他节点可以分配合理的内存和CPU内核。不是所有节点需要同样的配置。</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Kubernetes有一个独特的网络模型.</p><p>Kubernetes给每一个pod分配IP地址。当你新建一个集群，为了保证Pod获得IP地址，你需要给Kubernetes分配一个IP地址池。最简单的做法是每当节点与节点之间的通信可以以一下两种方式实现：</p><p><strong>（1）配置网络完成Pod的IP地址路由</strong></p><ul><li>因为一切从头开始，所以难度会大一些。</li><li>Google Compute Engine (GCE) 和 AWS会指导如何使用这种方式</li><li>需要编程配置路由器和交换机去实现Pod的IP地址路由。</li><li>可在Kubernetes环境外配置或者通过在Cloud Provider模块的“路由”接口里实现。</li><li>通常情况下，提供最优网络性能。</li></ul><p><strong>（2）建立一个拓扑网络</strong></p><ul><li>较容易建立</li><li>因为数据流量被封装，所以每个Pod的IP地址是可以路由的。</li><li>例如：<br>Flannel<br>Weave<br>Open vSwitch (OVS)</li><li>不需要CLoud Provider模块里的“路由”部分</li><li>较为不太理想的性能（具体的性能弱化取决于你的实际情况）</li></ul><p>你需要为Pod所需要的IP地址选一个IP地址范围。</p><p>（3）一些可选择配置方式：</p><ul><li>GCE：每一个项目有一个自己的IP子网“10.0.0.0&#x2F;8”。项目中的每一个Kubernetes集群从中获得一个“&#x2F;16”的子网。每一个节点从’&#x2F;16’的子网里获IP地址。</li><li>AWS：在一个组织内使用一个VPC。从中分配地址给每一个聚群或者使用给不同的集群分配不同的VPC。</li><li>暂不支持支持IPv6</li></ul><p>（4）给每一的node的Pod地址分配一个CIDR子网或者一个</p><ul><li>你总共需要max-pods-per-node * max-number-of-nodes个IP地址。一个“&#x2F;24” 如果缺少IP地址，一个“&#x2F;26”（62个节点）或者“&#x2F;27”（30个节点）也能满足。</li><li>例如，使用“10.10.0.0&#x2F;16” “10.10.0.0&#x2F;24” “10.10.255.0&#x2F;24”</li><li>需要路由设置或连接到拓扑网络</li></ul><p>Kubernetes 会给每个service分配一个IP地址。 但是service的地址并不一定是可路由的。当数据离开节点时，kube-proxy需要将Service IP地址翻译成Pod IP地址。因此，你需要给Service也分配一个地址段。这个网段叫做“SERVICE_CLUSTER_IP_RANGE”。例如，你可以这样设置“SERVICE_CLUSTER_IP_RANGE&#x3D;”10.0.0.0&#x2F;16”，这样的话就会允许65534个不同的Service同时运行。请注意，你可以调整这个IP地址段。但不允许在Service和Pod运行的时候移除这个网段。</p><p>同样，你需要为主节点选一个静态IP地址。 －命名这个IP地址为“MASTER_IP”。 －配置防火墙，从而允许访问apiserver端口80和443。 －使用sysctl设置”net.ipv4.ip_forward &#x3D; 1“从而开启IPv4 forwarding。</p><h2 id="集群命名"><a href="#集群命名" class="headerlink" title="集群命名"></a>集群命名</h2><p>为你的集群选个名字。要选一个简短不会和其他服务重复的名字。</p><ul><li>用kubectl来访问不同的集群。比如当你想在其他的区域测试新的Kubernetes版本。</li><li>Kubernetes集群可以建立一个Cloud Provider资源（例如，AWS ELB）。所以不同的集群要能区分他们之间的相关资源，这个名字叫做“CLUSTERNAME”。</li></ul><h2 id="软件安装包"><a href="#软件安装包" class="headerlink" title="软件安装包"></a>软件安装包</h2><p>你需要以下安装包</p><ul><li>etcd</li><li>以下容器二选一:<br>docker<br>rkt</li><li>Kubernetes<br>kubelet<br>kube-proxy<br>kube-apiserver<br>kube-controller-manager<br>kube-scheduler</li></ul><h2 id="下载和解压缩Kubernetes安装"><a href="#下载和解压缩Kubernetes安装" class="headerlink" title="下载和解压缩Kubernetes安装"></a>下载和解压缩Kubernetes安装</h2><p>Kubernets安装版本包包含所有Kuberentes的二进制发行版本和所对应的etcd。你可使直接使用这个二进制发行版本（推荐）或者按照开发者文档说明编译这些Kubernetes的二进制文件。 本指南只讲述了如何直接使用二进制发行版本。 下载最新安装版本并解压缩。之后找到你下载“.&#x2F;kubernetes&#x2F;server&#x2F;kubernetes-server-linux-amd64.tar.gz”的路径， 并解压缩这个压缩包。然后在其中找到“.&#x2F;kubernetes&#x2F;server&#x2F;bin”文件夹。里面有所所需的可运行的二进制文件。</p><h2 id="选择安装镜像"><a href="#选择安装镜像" class="headerlink" title="选择安装镜像"></a>选择安装镜像</h2><p>在容器外运行docker，kuberlet和kube-proxy，就像你运行任何后台系统程序。所以你只需要这些基本的二进制运行文件。etcd， kube-apiserver， kube-controller-manager和kubescheduler，我们建议你在容器里运行etcd， kube-apiserver， kube-controller-manager和kube-scheduler。所以你需要他们的容器镜像。 你可以选择不同的Kubernetes镜像：</p><p><strong>你可以使用Google Container Registry (GCR)上的镜像文件：</strong></p><ul><li>例如“gcr.io&#x2F;google_containers&#x2F;hyperkube:$TAG”。这里的“TAG”是指最新的发行版本的标示。这个表示可以从最新发行说明找到。</li><li>确定$TAG和你使用的kubelet，kube-proxy的标签是一致的。</li><li>hyperkube是一个集成二进制运行文件</li><li>你可以使用“hyperkube kubelet …”来启动kubelet ，用“hyperkube apiserver …”运行apiserver， 等等。</li></ul><p><strong>生成你自己的镜像：</strong></p><ul><li>使用私有镜像服务器。</li><li>例如，可以使用“docker load -i kube-apiserver.tar”将“.&#x2F;kubernetes&#x2F;server&#x2F;bin&#x2F;kubeapiserver.tar”文件转化成dokcer镜像。</li><li>之后可使用“docker images”来验证镜像是否从制定的镜像服务器加载成功。</li></ul><p><strong>对于etcd，你可以：</strong></p><ul><li>使用上Google Container Registry (GCR)的镜像，例如“gcr.io&#x2F;google_containers&#x2F;etcd:2.0.12”</li><li>使用Docker Hub或着Quay.io上的镜像，例如“quay.io&#x2F;coreos&#x2F;etcd:v2.2.0”</li><li>使用你操作系统自带的etcd</li><li>自己编译<br>你可以使用这个命令行“cd kubernetes&#x2F;cluster&#x2F;images&#x2F;etcd; make”</li></ul><p>我们建议你使用Kubernetes发行版本里提供的etcd版本。Kubernetes发行版本里的二进制运行文件只是和这个版本的etcd测试过。你可以在“kubernetes&#x2F;cluster&#x2F;images&#x2F;etcd&#x2F;Makefile”里“ETCD_VERSION”所对应的值找到所推荐的版本号。 接下来本文档会假设你已经选好镜像标示并设置了对应的环境变量。 设置好了最新的标示和正确的镜像服务器：</p><ul><li>“HYPERKUBE_IMAGE&#x3D;&#x3D;gcr.io&#x2F;google_containers&#x2F;hyperkube:$TAG”</li><li>“ETCD_IMAGE&#x3D;gcr.io&#x2F;google_containers&#x2F;etcd:$ETCD_VERSION”</li></ul><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><p>这里有两种主要的安全选项：</p><p><strong>使用HTTP访问apiserver</strong></p><ul><li>配合使用防火墙。</li><li>这种方法比较易用。</li></ul><p><strong>使用HTTPS访问apiserver</strong></p><ul><li>配合电子证书和用户登录信息使用。</li><li>推荐使用</li><li>设置电子证书较为复杂。</li></ul><p>如果要用HTTPS这个方式，你需要准备电子证书和用户登录信息。</p><h3 id="准备安全证书"><a href="#准备安全证书" class="headerlink" title="准备安全证书"></a>准备安全证书</h3><p>你需要准备多个证书：</p><ul><li>主节点会是一个HTTPS服务器，所以需要一个证书。</li><li>如果Kuberlets需要通过HTTPS提供API服务时，这些kuberlets需要出示证书向主节点证明主从关系。</li></ul><p>除非你决定要一个真正CA来生成这些证书的话，你需要一个根证书，并用这个证书来给主节点，kuberlet和kubectl的证书签名。</p><ul><li>参见“cluster&#x2F;gce&#x2F;util.sh”脚本里的“create-certs”</li><li>并参见“cluster&#x2F;saltbase&#x2F;salt&#x2F;generate-cert&#x2F;make-ca-cert.sh”和cluster&#x2F;saltbase&#x2F;salt&#x2F;generate-cert&#x2F;make-cert.sh“</li></ul><p><strong>你需要修改以下部分(我们之后也会用到这些参数的)</strong></p><p>”CA_CERT“</p><ul><li>放置在apiserver所运行的节点上，比如“&#x2F;srv&#x2F;kubernetes&#x2F;ca.crt”。</li></ul><p>“MASTER_CERT”</p><ul><li>用CA_CERT来签名</li><li>放置在apiserver所运行的节点上，比如”&#x2F;srv&#x2F;kubernetes&#x2F;server.crt”。</li></ul><p>“MASTER_KEY“</p><ul><li>放置在apiserver所运行的节点上，比如”&#x2F;srv&#x2F;kubernetes&#x2F;server.key“。</li></ul><p>“KUBELET_CERT”</p><ul><li>可选配置</li></ul><p>”KUBELET_KEY“</p><ul><li>可选配置</li></ul><h2 id="准备登录信息"><a href="#准备登录信息" class="headerlink" title="准备登录信息"></a>准备登录信息</h2><p>管理员（及任何用户）需要：</p><ul><li>对应验证身份的令牌或密码。</li><li>令牌可以是长字符串，比如 32个字符<br>可参见”TOKEN&#x3D;$(dd if&#x3D;&#x2F;dev&#x2F;urandom bs&#x3D;128 count&#x3D;1 2&gt;&#x2F;dev&#x2F;null | base64 | tr -d”&#x3D;+&#x2F;” | dd bs&#x3D;32 count&#x3D;1 2&gt;&#x2F;dev&#x2F;null)““</li></ul><p>你的令牌和密码需要保存在apiserver上的一个文件里。本指南使用这个文件”&#x2F;var&#x2F;lib&#x2F;kubeapiserver&#x2F;known_tokens.csv“。文件的具体格式在认证文档里描述了。 至于如何把登录信息分发给用户，Kubernetes是将登录信息放入kubeconfig文件里。</p><p>管理员可以按如下步骤创建kubeconfig文件：</p><ul><li>如果你已经在非客制化的集群上运行过Kubernetes(例如，按照入门指南架设过Kubernetes)，那么你已经有“$HOME&#x2F;.kube&#x2F;config&#96;”文件了。</li><li>你需要在kuberconfig文件里添加证书，密钥和主节点IP：<br>1、如果你选择了“firewall-only”的安全设置，你需要按如下设置apiserver：<br>2、“kubectl config set-cluster $CLUSTER_NAME –server&#x3D;http:&#x2F;&#x2F;$MASTER_IP –insecure-skip-tls-verify&#x3D;true”<br>3、否则，按如下设置你的apiserver的IP，证书，用户登录信息：<br>4、“kubectl config set-cluster $CLUSTER_NAME –certificate-authority&#x3D;$CA_CERT –embed-certs&#x3D;true –server&#x3D;https:&#x2F;&#x2F;$MASTER_IP”<br>5、“kubectl config set-credentials $USER –client-certificate&#x3D;$CLI_CERT –clientkey&#x3D;$CLI_KEY –embed-certs&#x3D;true –token&#x3D;$TOKEN”<br>6、设置你的集群为缺省集群：<br>7、“kubectl config set-context $CONTEXT_NAME –cluster&#x3D;$CLUSTER_NAME –user&#x3D;$USER”<br>8、“kubectl config use-context $CONTEXT_NAME”</li></ul><p>接下来，为kubelets和kube-proxy准备kubeconfig文件。至于要准备多少不同的文件，这里有几个选项：</p><p>\1. 使用和管理员同样的登陆账号</p><ul><li>这是最简单的建设方法。</li></ul><p>\2. 所有的kubelet使用同一个令牌和kubeconfig文件，另外一套给所有的kube-proxy使用，在一套给管理员使用。</p><ul><li>这个设置和GCE的配置类似。</li></ul><p>\3. 为每一个kubelet，kube-proxy和管理员准备不同的登陆账号。</p><ul><li>这个配置在实现中，目前还不支持。</li></ul><p>为了生成这个文件，你可以参照“cluster&#x2F;gce&#x2F;configure-vm.sh”中的代码直接从“$HOME&#x2F;.kube&#x2F;config”拷贝过去或者参考以下模版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Config</span><br><span class="line">users:</span><br><span class="line">- name: kubelet</span><br><span class="line">user:</span><br><span class="line">token: $&#123;KUBELET_TOKEN&#125;</span><br><span class="line">clusters:</span><br><span class="line">- name: local</span><br><span class="line">cluster:</span><br><span class="line">certificate-authority-data: $&#123;CA_CERT_BASE64_ENCODED&#125;</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">cluster: local</span><br><span class="line">user: kubelet</span><br><span class="line">name: service-account-context</span><br><span class="line">current-context: service-account-context</span><br></pre></td></tr></table></figure><p>把kubeconfig文件放置到每一个节点上。本章节之后的事例会假设kubeconfig文件已经放置在“&#x2F;var&#x2F;lib&#x2F;kube-proxy&#x2F;kubeconfig”和“&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeconfig”里。</p><h2 id="在节点上配置和安装基础软件"><a href="#在节点上配置和安装基础软件" class="headerlink" title="在节点上配置和安装基础软件"></a>在节点上配置和安装基础软件</h2><p>这个章节讨论的是如歌配置Kubernetes节点。 你应该在每个节点运行三个后台进程：</p><ul><li>docker or rkt</li><li>kubelet *kube-proxy</li></ul><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>对最低Docker版本的要求是随着kubelet的版本变化的。最新的稳定版本通常是个好选择。如果版本太低，Kubelet记录下警报并拒绝运行pod，所以你可以选择个版本试一下。</p><p>如果你之前安装Docker的节点没有Kubernetes相关的配置，你可能已经有Docker新建的网桥和iptables的规则。所以你或许希望在为Kubernetes配置Docker前根据以下命令移除之前的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -F</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">brctl delbr docker0</span><br></pre></td></tr></table></figure><p>如何配置Docker取决于你网络是基于routable-vip还是overlay-network。 这里有一些建议的Docker选项：</p><ul><li>为每一个节点的CIDR网断建立你自己的网桥，命名为cbr0并为docker设置 –bridge&#x3D;cbr0 。</li><li>配置 –iptables&#x3D;false ，所以docker不会为host-port设置iptables(这个控制在docker旧版本不够细致，以后会在新版本里修复)</li></ul><p><strong>所以kube-proxy可以代替docker来设置iptables。</strong></p><ul><li>–ip-masq&#x3D;false<br>如果你将PodIP设置为可路由寻址，你会希望将这个选项设置为false。否则，docker会将NodeIP重写为PodIP的源地址。<br>一些环境(例如,GCE)下需要伪装(masquerade)离开这个云环境的流量。这个配置是取决于具体的云环境的。<br>如果你在使用overlay网络，请参考其他资料。</li><li>–mtu&#x3D;<br>但使用Flannel的时候，需要这个选项。 因为UDP包封装造成过大的数据包。</li><li>–insecure-registry $CLUSTER_SUBNET<br>为链接没有SSL安全链接的私有registry。</li></ul><p><strong>你或许希望为Docker提高可以打开文件的数目：</strong></p><ul><li>DOCKER_NOFILE&#x3D;1000000 这里的设置取决于你的节点的操作系统。比如，GCE上基于Debian的发行版本使用 &#x2F;etc&#x2F;default&#x2F;docker 这个配置文件。</li></ul><p>在进行下一步安装前，可以参考Docker文档里的实例来确保docker在你的系统上正常工作。</p><h2 id="rkt"><a href="#rkt" class="headerlink" title="rkt"></a>rkt</h2><p>rkt是类似Docker的技术。你只需要二选一安装Docker或者rkt。最低的版本是v0.5.6。</p><p>systemd是在节点上运行rkt必须的。与rkt v0.5.6所对应的最低版本是systemd 215。</p><p>rkt metadata service也是必须安装的，来支持rtk的网络部分。你可以用以下命令来运行rkt的metadata服务 sudo systemd-run rkt metadata-service</p><p>接下来你需要来设置kubelet的标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--container-runtime=rkt</span><br></pre></td></tr></table></figure><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>所有的节点都要运行kubelet。</p><p>可参考的参数：</p><ul><li>如果选择HTTPS的安全配置：<br>–api-servers&#x3D;https:&#x2F;&#x2F;$MASTER_IP<br>–kubeconfig&#x3D;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeconfig</li><li>否则，使用防火墙的安全配置：<br>–api-servers&#x3D;http:&#x2F;&#x2F;$MASTER_IP</li><li>–config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;manifests</li><li>–cluster-dns&#x3D; 是用来配置DNS服务器的地址(参考Starting Addons.)</li><li>–cluster-domain&#x3D; 是为DNS集群地址使用的DNS域名前缀。</li><li>–docker-root&#x3D;</li><li>–root-dir&#x3D;</li><li>–configure-cbr0&#x3D; (参考之前的介绍)</li><li>–register-node (参考章节<strong>节点</strong>.)</li></ul><h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>所有的节点都要运行kube-proxy。(并不一定要在主节点上运行kube-proxy，但最好还是与其它节点保持一致) 可参考如何获得kubelet二进制运行包来获得kube-proxy二进制运行包。</p><p>可参考的参数</p><ul><li>如果选择HTTPS的安全配置<br>–api-servers&#x3D;https:&#x2F;&#x2F;$MASTER_IP<br>–kubeconfig&#x3D;&#x2F;var&#x2F;lib&#x2F;kube-proxy&#x2F;kubeconfig</li><li>否则，使用防火墙的安全配置：<br>–api-servers&#x3D;http:&#x2F;&#x2F;$MASTER_IP</li></ul><h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h2><p>为了pod的网络通信，需要给每一个节点分配一个自己的CIDR网段。这个叫做 NODE_X_POD_CIDR 。</p><p>需要给每一个节点新建一个叫 cbr0 网桥。网桥会在networking documentation里做详细介绍。约定俗成，$NODE_X_POD_CIDR 里的第一个IP地址作为这个网桥的IP地址。这个地址叫做 NODE_X_BRIDGE_ADDR 。比如， NODE_X_POD_CIDR 是 10.0.0.0&#x2F;16 ，那么 NODE_X_BRIDGE_ADDR 是 10.0.0.1&#x2F;16 。注意：这里用 &#x2F;16 这个后缀是因为之后也会这么使用。</p><ul><li>推荐的自动化步骤:<br>\1. 在初始化的脚本里，设置kubelet的选项为 –configure-cbr0&#x3D;true ，并重启kubelet服务。Kubelet会自动设置cobr0. 它会一直等待，直到节点controller正确设置Node.Spec.PodCIDR。因为你目前还没有设置好apiserver和节点controller，所以网桥不会马上完成设置。</li><li>人工步骤:<br>\1. 设置kubelet的选项 –configure-cbr0&#x3D;false ，并重启kubelet。<br>\2. 新建网桥比如 brctl addbr cbr0 .<br>\3. 设定合适的MTU<br>比如 ip link set dev cbr0 mtu 1460 (注意: 真实的MTU值是由你的网络环境所决定的)<br>\4. 把集群网络加入网桥(docker会连接在这个网桥的另一端)。<br>比如 ip addr add $NODE_X_BRIDGE_ADDR dev cbr0<br>\5. 开启网桥<br>比如 ip link set dev cbr0 up</li></ul><p>在你关闭了Docker的IP伪装的情况下，为了让pod之间相互通信，你可能需要为去往集群网络外的流量做目的IP地址伪装，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING ! -d $&#123;CLUSTER_SUBNET&#125; -m addrtype ! --dst-type LOCAL -jMASQUERADE</span><br></pre></td></tr></table></figure><p>这样会重写从PodIP到节点IP的数据流量的原地址。内核connection tracking会确保发向节点的回复能够到达pod。</p><p>注意: 需不需要IP地址伪装是视环境而定的。在一些环境下是不需要IP伪装的。例如GCE这样的环境从pod发出的数据是不允许发向Interent的，但如果在同一个GCE项目里是不会有问题的。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>如果需要，为你的系统安装包管理器开启自动升级。</li><li>为所有的节点设置日志轮询(比如，使用logrotate)。</li><li>建立liveness-monitoring (比如，使用monit)。</li><li>建立存储插件的支持(可选)<br>为可选的存储类型安装所需的客户端程序，比如为GlusterFS安装 glusterfsclient。</li></ul><h3 id="使用配置管理工具"><a href="#使用配置管理工具" class="headerlink" title="使用配置管理工具"></a>使用配置管理工具</h3><p>之前架设服务器的步骤都是使用“传统”的系统管理方式。你可以尝试使用系统配置工具来自动化架设流程。你可以参考其他入门指南，比如使用Saltstack， Ansible， Juju和CoreOSCloud Config。</p><h2 id="引导安装集群"><a href="#引导安装集群" class="headerlink" title="引导安装集群"></a>引导安装集群</h2><p>通常情况下，基本的节点服务(kubelet， kube-proxy和docker)都是由传统的系统配置方式完成建立和管理的。其他的Kubernetes的相关部分都是由Kubernetes本身来完成配置和管理的：</p><ul><li>配置和管理的选项在Pod spec(yaml or json)而不是&#x2F;etc&#x2F;init.d文件或systemd unit里定义的。</li><li>他们都是由Kubernetes而不是init来负责运行的。</li></ul><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>你需要运行一个或多个etcd实例。</p><ul><li>推荐方式: 运行一个etcd实例，将日志保存在类似RAID，GCE PD的永久存储空间上。</li><li>或者: 运行3个或者5个etcd实例。<br>日志可以保存在 Log can be written to non-durable storage because storage isreplicated.<br>运行一个apiserver，这个apiserver连接到其中一个etc实例上。 参见clustertroubleshooting<br>获取更多的有关集群可用性的信息。</li></ul><p><strong>启动一个etcd实例:</strong></p><p>1.复制 cluster&#x2F;saltbase&#x2F;salt&#x2F;etcd&#x2F;etcd.manifest 2.做有必要的设置修改 3.将这个文件放到kubelet mainfest的文件夹中</p><h2 id="Apiserver，Controller-Manager和Scheduler"><a href="#Apiserver，Controller-Manager和Scheduler" class="headerlink" title="Apiserver，Controller Manager和Scheduler"></a>Apiserver，Controller Manager和Scheduler</h2><p>在主节点上，apiserver，controller manager，scheduler会运行在各自的pod里。</p><p>启动以上三个服务的步骤大同小异：</p><p>\1. 从为pod所提供的template开始。</p><p>\2. 设置 HYPERKUBE_IMAGE 的值为选择安装镜像中所设置的值。</p><p>\3. 可参考以下的template来决定你集群所需的选项。</p><p>\4. 在 commands 列表里设置所需的运行选项（例如，$ARGN）。</p><p>\5. 将完成的template放在kubelet manifest的文件夹内。</p><p>\6. 验证pod是否运行。</p><h2 id="Apiserver-pod模版"><a href="#Apiserver-pod模版" class="headerlink" title="Apiserver pod模版"></a>Apiserver pod模版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;kind&quot;: &quot;Pod&quot;,</span><br><span class="line">&quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-apiserver&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;spec&quot;: &#123;</span><br><span class="line">&quot;hostNetwork&quot;: true,</span><br><span class="line">&quot;containers&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-apiserver&quot;,</span><br><span class="line">&quot;image&quot;: &quot;$&#123;HYPERKUBE_IMAGE&#125;&quot;,</span><br><span class="line">&quot;command&quot;: [</span><br><span class="line">&quot;/hyperkube&quot;,</span><br><span class="line">&quot;apiserver&quot;,</span><br><span class="line">&quot;$ARG1&quot;,</span><br><span class="line">&quot;$ARG2&quot;,</span><br><span class="line">...</span><br><span class="line">&quot;$ARGN&quot;</span><br><span class="line">],</span><br><span class="line">&quot;ports&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;https&quot;,</span><br><span class="line">&quot;hostPort&quot;: 443,</span><br><span class="line">&quot;containerPort&quot;: 443</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;local&quot;,</span><br><span class="line">&quot;hostPort&quot;: 8080,</span><br><span class="line">&quot;containerPort&quot;: 8080</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;volumeMounts&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;srvkube&quot;,</span><br><span class="line">&quot;mountPath&quot;: &quot;/srv/kubernetes&quot;,</span><br><span class="line">&quot;readOnly&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;etcssl&quot;,</span><br><span class="line">&quot;mountPath&quot;: &quot;/etc/ssl&quot;,</span><br><span class="line">&quot;readOnly&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;livenessProbe&quot;: &#123;</span><br><span class="line">&quot;httpGet&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;/healthz&quot;,</span><br><span class="line">&quot;port&quot;: 8080</span><br><span class="line">&#125;,</span><br><span class="line">&quot;initialDelaySeconds&quot;: 15,</span><br><span class="line">&quot;timeoutSeconds&quot;: 15</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;volumes&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;srvkube&quot;,</span><br><span class="line">&quot;hostPath&quot;: &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;etcssl&quot;,</span><br><span class="line">&quot;hostPath&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;/etc/ssl&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选设置的apiserver的选项：</p><ul><li>–cloud-provider&#x3D; 参见 cloud providers<br>–</li><li>-cloud-config&#x3D; 参见 cloud providers</li><li>如果你想在主节点运行proxy，你需要设置 —address&#x3D;${MASTER_IP} 或者 –bindaddress&#x3D;127.0.0.1 和 –address&#x3D;127.0.0.1 。</li><li>–cluster-name&#x3D;$CLUSTER_NAME</li><li>–service-cluster-ip-range&#x3D;$SERVICE_CLUSTER_IP_RANGE</li><li>–etcd-servers&#x3D;<a href="http://127.0.0.1:4001/">http://127.0.0.1:4001</a></li><li>–tls-cert-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;server.cert</li><li>–tls-private-key-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;server.key</li><li>–admission-control&#x3D;$RECOMMENDED_LIST<br>参考 admission controllers.</li><li>只有当你相信你的集群用户可以使用root权限来运行pod时，开启这个选项 –allowprivileged&#x3D;true ,</li></ul><p>如果你是按照firewall-only的安全方式来配置的，你需要以下设置：</p><ul><li>–token-auth-file&#x3D;&#x2F;dev&#x2F;null</li><li>—insecure-bind-address&#x3D;$MASTER_IP</li><li>–advertise-address&#x3D;$MASTER_IP</li></ul><p>如果你是按照HTTPS的安全方式来配置的，你需要以下设置：</p><ul><li>–client-ca-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;ca.crt</li><li>–token-auth-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;known_tokens.csv</li><li>–basic-auth-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;basic_auth.csv</li></ul><p>这个pod使用 hostPath 加载多个节点文件系统目录。这些加载的目录的用途是：</p><ul><li>加载 &#x2F;etc&#x2F;ssl 目录可以允许apiserver找到SSL根证书，从而验证例如云服务提供商所提供的外部服务。<br>如果你不使用任何云服务提供商，你就不需要配置这里（比如，只使用物理裸机）。</li><li>加载 &#x2F;srv&#x2F;kubernetes 目录可以允许读取存储在节点磁盘上的证书和认证信息。</li><li>可选, 你也可以加在 &#x2F;var&#x2F;log 目录从而将日志记录在这个目录里(没有在template里举例标明)。<br>如果你想用类似journalctl的工具从根文件系统来访问日志的话，可以加载这个目录。 TODO 描述如何架设proxy-ssh。</li></ul><h3 id="Cloud-Providers"><a href="#Cloud-Providers" class="headerlink" title="Cloud Providers"></a>Cloud Providers</h3><p>Apiserver支持多个cloud providers。</p><ul><li>–cloud-provider 选项的值可以<br>是 aws ， gce ， mesos ， openshift ， ovirt ， rackspace ， vagrant 或者不´未设置。</li><li>未设置选项可以用来设置物理裸机。</li><li>在这里添加新的IaaS。</li></ul><p>一些cloud providers需要配置文件。这种情况下，你需要将配置文件放置在apiserver的镜像中或者通过 hostPath 来加载。</p><ul><li>如果cloud providers需要配置文件，设置 —cloud-config&#x3D; 这个选项。</li><li>aws ， gce ， mesos ， openshift ， ovirt 和 rackspace 会使用到这个选项。</li><li>你必须需要将配置文件放置在apiserver的镜像中或者通过 hostPath 来加载。</li><li>云配置文件的语法Gcfg。</li><li>AWS格式是用类型来定义的AWSCloudConfig。</li><li>其他的云服务提供商也有类似的对应文件。</li><li>比如在GCE里: 在这个文件找 gce.conf 字节。</li></ul><h2 id="Scheduler-pod-template"><a href="#Scheduler-pod-template" class="headerlink" title="Scheduler pod template"></a>Scheduler pod template</h2><p>完成scheduler pod的template：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;kind&quot;: &quot;Pod&quot;,</span><br><span class="line">&quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-scheduler&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;spec&quot;: &#123;</span><br><span class="line">&quot;hostNetwork&quot;: true,</span><br><span class="line">&quot;containers&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-scheduler&quot;,</span><br><span class="line">&quot;image&quot;: &quot;$HYBERKUBE_IMAGE&quot;,</span><br><span class="line">&quot;command&quot;: [</span><br><span class="line">&quot;/hyperkube&quot;,</span><br><span class="line">&quot;scheduler&quot;,</span><br><span class="line">&quot;--master=127.0.0.1:8080&quot;,</span><br><span class="line">&quot;$SCHEDULER_FLAG1&quot;,</span><br><span class="line">...</span><br><span class="line">&quot;$SCHEDULER_FLAGN&quot;</span><br><span class="line">],</span><br><span class="line">&quot;livenessProbe&quot;: &#123;</span><br><span class="line">&quot;httpGet&quot;: &#123;</span><br><span class="line">&quot;host&quot; : &quot;127.0.0.1&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/healthz&quot;,</span><br><span class="line">&quot;port&quot;: 10251</span><br><span class="line">&#125;,</span><br><span class="line">&quot;initialDelaySeconds&quot;: 15,</span><br><span class="line">&quot;timeoutSeconds&quot;: 15</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，不需要额外设置scheduler。</p><p>你或许想加载 &#x2F;var&#x2F;log 并将输出记录在这个日志目录里。</p><h2 id="Controller-Manager-Template"><a href="#Controller-Manager-Template" class="headerlink" title="Controller Manager Template"></a>Controller Manager Template</h2><p>完成controller manager pod的template：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;kind&quot;: &quot;Pod&quot;,</span><br><span class="line">&quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-controller-manager&quot;</span><br><span class="line">&#125;,&quot;spec&quot;: &#123;</span><br><span class="line">&quot;hostNetwork&quot;: true,</span><br><span class="line">&quot;containers&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;kube-controller-manager&quot;,</span><br><span class="line">&quot;image&quot;: &quot;$HYPERKUBE_IMAGE&quot;,</span><br><span class="line">&quot;command&quot;: [</span><br><span class="line">&quot;/hyperkube&quot;,</span><br><span class="line">&quot;controller-manager&quot;,</span><br><span class="line">&quot;$CNTRLMNGR_FLAG1&quot;,</span><br><span class="line">...</span><br><span class="line">&quot;$CNTRLMNGR_FLAGN&quot;</span><br><span class="line">],</span><br><span class="line">&quot;volumeMounts&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;srvkube&quot;,</span><br><span class="line">&quot;mountPath&quot;: &quot;/srv/kubernetes&quot;,</span><br><span class="line">&quot;readOnly&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;etcssl&quot;,</span><br><span class="line">&quot;mountPath&quot;: &quot;/etc/ssl&quot;,</span><br><span class="line">&quot;readOnly&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;livenessProbe&quot;: &#123;</span><br><span class="line">&quot;httpGet&quot;: &#123;</span><br><span class="line">&quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/healthz&quot;,</span><br><span class="line">&quot;port&quot;: 10252</span><br><span class="line">&#125;,</span><br><span class="line">&quot;initialDelaySeconds&quot;: 15,</span><br><span class="line">&quot;timeoutSeconds&quot;: 15</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;volumes&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;srvkube&quot;,</span><br><span class="line">&quot;hostPath&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;/srv/kubernetes&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;etcssl&quot;,</span><br><span class="line">&quot;hostPath&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;/etc/ssl&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合controller manager所使用的选项：</p><ul><li>–cluster-name&#x3D;$CLUSTER_NAME</li><li>—cluster-cidr&#x3D;<br>TODO: 解释这个选项</li><li>–allocate-node-cidrs&#x3D;<br>TODO: 解释这个选项</li><li>–cloud-provider&#x3D; 和 –cloud-config 在apiserver章节里解释过。</li><li>–service-account-private-key-file&#x3D;&#x2F;srv&#x2F;kubernetes&#x2F;server.key ，这个值是service<br>account功能所使用的。</li><li>–master&#x3D;127.0.0.1:8080</li></ul><h2 id="运行和验证Apiserver，Scheduler和Controller-Manager"><a href="#运行和验证Apiserver，Scheduler和Controller-Manager" class="headerlink" title="运行和验证Apiserver，Scheduler和Controller Manager"></a>运行和验证Apiserver，Scheduler和Controller Manager</h2><p>将每个完成的pod template放置在kubelet的配置文件夹中（文件夹地址是在kubelet的 –config&#x3D; 选项所指向的地址， 通常是 &#x2F;etc&#x2F;kubernetes&#x2F;manifests ）。没有放置顺序关系:scheduler和controller manager会一直尝试连接到apiserver，直到连接成功。</p><p>用 ps 或者 docker ps 来检测每一个进程是否正常运行。 比如，你可以这样看apiserver的容器是否被kubelet启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps | grep apiserver:</span><br><span class="line">5783290746d5 gcr.io/google_containers/kube-apiserver:e36bf367342b5a80d7467fd7611ad873........</span><br></pre></td></tr></table></figure><p>之后尝试连接apiserver:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ echo $(curl -s http://localhost:8080/healthz)</span><br><span class="line">ok</span><br><span class="line">$ curl -s http://localhost:8080/api</span><br><span class="line">&#123;</span><br><span class="line">&quot;versions&quot;: [</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果kubelets使用 –register-node&#x3D;true 这个选项，他们会开始自动注册到apiserver上。很快，你就可以使用 kubectl get nodes 命令看到所有的节点。否则，你需要手动注册这些节点。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>TODO 如何开启日志。</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>TODO 如何开启监控。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>TODO 如何运行DNS。</p><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><h3 id="运行validate-cluster"><a href="#运行validate-cluster" class="headerlink" title="运行validate-cluster"></a>运行validate-cluster</h3><p>TODO 解释如何运行“cluster&#x2F;validate-cluster.sh”。</p><h3 id="检查pods和services"><a href="#检查pods和services" class="headerlink" title="检查pods和services"></a>检查pods和services</h3><p>你可以尝试这阅读“检查的集群”这一节，例如GCE。你应该检查Service。通过“mirro pods”去检查apiserver，scehduler和controller-manager以及运行的插件。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>到这里你应该能够运行一些基本的实例了，例如nginx example。</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>你可以试着运行一致性测试. 测试失败的结果可能会给你些排除故障的线索。</p><h3 id="网络-2"><a href="#网络-2" class="headerlink" title="网络"></a>网络</h3><p>节点之间必须用私有IP链接。可以通过ping或者SSH来确定节点之间的联通。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 的 16 条实践解读</title>
      <link href="/2020/04/15/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/"/>
      <url>/2020/04/15/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我将重点介绍 Spring Boot 特有的实践（大多数时候，也适用于 Spring 项目）。以下依次列出了最佳实践，排名不分先后。</p><h3 id="1、使用自定义-BOM-来维护第三方依赖"><a href="#1、使用自定义-BOM-来维护第三方依赖" class="headerlink" title="1、使用自定义 BOM 来维护第三方依赖"></a>1、使用自定义 BOM 来维护第三方依赖</h3><p>这条实践是我根据实际项目中的经历总结出的。</p><p>Spring Boot 项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。</p><p>怎么办呢？事实上，Spring IO Platform 就是做的这个事情，它本身就是 Spring Boot 的子项目，同时维护了其他第三方开源库。我们可以借鉴 Spring IO Platform 来编写自己的基础项目 platform-bom，所有的业务模块项目应该以 BOM 的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.spring.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>platform-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Cairo-SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、使用自动配置"><a href="#2、使用自动配置" class="headerlink" title="2、使用自动配置"></a>2、使用自动配置</h3><p>Spring Boot 的一个主要特性是使用自动配置。这是 Spring Boot 的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的 jar 文件时，自动配置就会被激活。</p><p>使用它的最简单方法是依赖 Spring Boot Starters。因此，如果你想与 Redis 进行集成，你可以首先包括：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想与 MongoDB 进行集成，需要这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助于这些 starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的 Jar 地狱。</p><blockquote><p><a href="https://dzone.com/articles/what-is-jar-hell">https://dzone.com/articles/what-is-jar-hell</a></p></blockquote><p>通过使用以下注解属性，可以从自动配置中排除某些配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>（exclude = &#123;ClassNotToAutoconfigure.class&#125;）</span><br></pre></td></tr></table></figure><p>但只有在绝对必要时才应该这样做。</p><p>有关自动配置的官方文档可在此处找到：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html%E3%80%82">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。</a></p></blockquote><h3 id="3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目"><a href="#3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目" class="headerlink" title="3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目"></a>3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目</h3><blockquote><p>这一条最佳实践来自 Josh Long （Spring Advocate，@starbuxman）。</p></blockquote><p>Spring Initializr 提供了一个超级简单的方法来创建一个新的 Spring Boot 项目，并根据你的需要来加载可能使用到的依赖。</p><blockquote><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p>使用 Initializr 创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于 Spring 自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。</p><h3 id="4、考虑为常见的组织问题创建自己的自动配置"><a href="#4、考虑为常见的组织问题创建自己的自动配置" class="headerlink" title="4、考虑为常见的组织问题创建自己的自动配置"></a>4、考虑为常见的组织问题创建自己的自动配置</h3><p>这一条也来自 Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。</p><p>如果你在一个严重依赖 Spring Boot 的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。</p><p>这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。</p><p>如果将这个提供 Spring Boot 配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。</p><h3 id="5、正确设计代码目录结构"><a href="#5、正确设计代码目录结构" class="headerlink" title="5、正确设计代码目录结构"></a>5、正确设计代码目录结构</h3><p>尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。</p><p>避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；</p><p>将 Application.java（应用的入口类）保留在顶级源代码目录中；</p><p>我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！</p><h3 id="6、保持-Controller-的简洁和专注"><a href="#6、保持-Controller-的简洁和专注" class="headerlink" title="6、保持 @Controller 的简洁和专注"></a>6、保持 @Controller 的简洁和专注</h3><p>Controller 应该非常简单。你可以在此处阅读有关 GRASP 中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller">https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller</a></p></blockquote><ul><li>控制器应该是无状态的！默认情况下，控制器是单例，并且任何状态都可能导致大量问题；</li><li>控制器不应该执行业务逻辑，而是依赖委托；</li><li>控制器应该处理应用程序的 HTTP 层，这不应该传递给服务；</li><li>控制器应该围绕用例 &#x2F; 业务能力来设计。</li></ul><p>要深入这个内容，需要进一步地了解设计 REST API 的最佳实践。无论你是否想要使用 Spring Boot，都是值得学习的。</p><h3 id="7、围绕业务功能构建-Service"><a href="#7、围绕业务功能构建-Service" class="headerlink" title="7、围绕业务功能构建 @Service"></a>7、围绕业务功能构建 @Service</h3><p>Service 是 Spring Boot 的另一个核心概念。我发现最好围绕业务功能 &#x2F; 领域 &#x2F; 用例（无论你怎么称呼都行）来构建服务。</p><p>在应用中设计名称类似<code>AccountService</code>, <code>UserService</code>, <code>PaymentService</code>这样的服务，比起像<code>DatabaseService</code>、<code>ValidationService</code>、<code>CalculationService</code>这样的会更合适一些。</p><p>你可以决定使用 Controler 和 Service 之间的一对一映射，那将是理想的情况。但这并不意味着，Service 之间不能互相调用！</p><h3 id="8、使数据库独立于核心业务逻辑之外"><a href="#8、使数据库独立于核心业务逻辑之外" class="headerlink" title="8、使数据库独立于核心业务逻辑之外"></a>8、使数据库独立于核心业务逻辑之外</h3><p>我之前还不确定如何在 Spring Boot 中最好地处理数据库交互。在阅读了罗伯特 ·C· 马丁的 “Clear Architecture” 之后，对我来说就清晰多了。</p><p>你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。</p><blockquote><p>罗伯特 C. 马丁强烈地说明，你的数据库是一个 “细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用 Spring Boot 和现代微服务开发会让事情变得更快。</p></blockquote><h3 id="9、保持业务逻辑不受-Spring-Boot-代码的影响"><a href="#9、保持业务逻辑不受-Spring-Boot-代码的影响" class="headerlink" title="9、保持业务逻辑不受 Spring Boot 代码的影响"></a>9、保持业务逻辑不受 Spring Boot 代码的影响</h3><p>考虑到 “Clear Architecture” 的教训，你还应该保护你的业务逻辑。将各种 Spring Boot 代码混合在一起是非常诱人的…… 不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。</p><p>部分服务通常成为库。如果不从代码中删除大量 Spring 注解，则更容易创建。</p><h3 id="10、推荐使用构造函数注入"><a href="#10、推荐使用构造函数注入" class="headerlink" title="10、推荐使用构造函数注入"></a>10、推荐使用构造函数注入</h3><p>这一条实践来自 Phil Webb（Spring Boot 的项目负责人, @phillip_webb）。</p><p>保持业务逻辑免受 Spring Boot 代码侵入的一种方法是使用构造函数注入。不仅是因为<code>@Autowired</code>注解在构造函数上是可选的，而且还可以在没有 Spring 的情况下轻松实例化 bean。</p><h3 id="11、熟悉并发模型"><a href="#11、熟悉并发模型" class="headerlink" title="11、熟悉并发模型"></a>11、熟悉并发模型</h3><p>我写过的最受欢迎的文章之一是 “介绍 Spring Boot 中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。</p><blockquote><p><a href="https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/">https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/</a></p></blockquote><p>在 Spring Boot 中，Controller 和 Service 是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。</p><p>如果你正在使用新的 WebFlux 风格的 Spring Boot 应用程序，我已经解释了它在 “Spring’s WebFlux&#x2F;Reactor Parallelism and Backpressure” 中是如何工作的。</p><h3 id="12、加强配置管理的外部化"><a href="#12、加强配置管理的外部化" class="headerlink" title="12、加强配置管理的外部化"></a>12、加强配置管理的外部化</h3><p>这一点超出了 Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……</p><p>你可以手动处理 Spring 应用程序的配置。如果你正在处理多个 Spring Boot 应用程序，则需要使配置管理能力更加强大。</p><p>我推荐两种主要方法：</p><ul><li>使用配置服务器，例如 Spring Cloud Config；</li><li>将所有配置存储在环境变量中（可以基于 git 仓库进行配置）。</li></ul><p>这些选项中的任何一个（第二个选项多一些）都要求你在 DevOps 更少工作量，但这在微服务领域是很常见的。</p><h3 id="13、提供全局异常处理"><a href="#13、提供全局异常处理" class="headerlink" title="13、提供全局异常处理"></a>13、提供全局异常处理</h3><p>你真的需要一种处理异常的一致方法。Spring Boot 提供了两种主要方法：</p><ul><li>你应该使用 HandlerExceptionResolver 定义全局异常处理策略；</li><li>你也可以在控制器上添加 @ExceptionHandler 注解，这在某些特定场景下使用可能会很有用。</li></ul><p>这与 Spring 中的几乎相同，并且 Baeldung 有一篇关于 REST 与 Spring 的错误处理的详细文章，非常值得一读。</p><blockquote><p><a href="https://www.baeldung.com/exception-handling-for-rest-with-spring">https://www.baeldung.com/exception-handling-for-rest-with-spring</a></p></blockquote><h3 id="14、使用日志框架"><a href="#14、使用日志框架" class="headerlink" title="14、使用日志框架"></a>14、使用日志框架</h3><p>你可能已经意识到这一点，但你应该使用 Logger 进行日志记录，而不是使用 System.out.println() 手动执行。这很容易在 Spring Boot 中完成，几乎没有配置。只需获取该类的记录器实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(MyClass.class);</span><br></pre></td></tr></table></figure><p>这很重要，因为它可以让你根据需要设置不同的日志记录级别。</p><h3 id="15、测试你的代码"><a href="#15、测试你的代码" class="headerlink" title="15、测试你的代码"></a>15、测试你的代码</h3><p>这不是 Spring Boot 特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。</p><p>如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。</p><p>由于存在 Spring Boot 最佳实践，因此你应该考虑将 Spring Cloud Contract 用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。</p><h3 id="16、使用测试切片让测试更容易，并且更专注"><a href="#16、使用测试切片让测试更容易，并且更专注" class="headerlink" title="16、使用测试切片让测试更容易，并且更专注"></a>16、使用测试切片让测试更容易，并且更专注</h3><p>这一条实践来自 Madhura Bhave（Spring 开发者, @madhurabhave23）。</p><p>使用 Spring Boot 测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物…… 实际上并不是那么难！答案是使用测试切片。</p><p>使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自 spring.io 的一篇名为 Custom test slice with Spring test 1.4 的博客文章解释了这种技术。</p><blockquote><p><a href="https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4">https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感谢 Spring Boot，编写基于 Spring 的微服务正变得前所未有的简单。我希望通过这些最佳实践，你的实施过程不仅会变得很快，而且从长远来看也会更加强大和成功。祝你好运！</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊API网关的作用</title>
      <link href="/2020/03/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%81%8A%E8%81%8AAPI%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2020/03/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%81%8A%E8%81%8AAPI%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>一、API网关的用处</strong></p><p>API网关我的分析中会用到以下三种场景。 </p><ol><li>Open API。 企业需要将自身数据、能力等作为开发平台向外开放，通常会以rest的方式向外提供，最好的例子就是淘宝开放平台、腾讯公司的QQ开发平台、微信开放平台。 Open API开放平台必然涉及到客户应用的接入、API权限的管理、调用次数管理等，必然会有一个统一的入口进行管理，这正是API网关可以发挥作用的时候。</li><li>微服务网关。微服务的概念最早在2012年提出，在Martin Fowler的大力推广下，微服务在2014年后得到了大力发展。 在微服务架构中，有一个组件可以说是必不可少的，那就是微服务网关，微服务网关处理了负载均衡，缓存，路由，访问控制，服务代理，监控，日志等。API网关在微服务架构中正是以微服务网关的身份存在。 </li><li>API服务管理平台。上述的微服务架构对企业来说有可能实施上是困难的，企业有很多遗留系统，要全部抽取为微服务器改动太大，对企业来说成本太高。但是由于不同系统间存在大量的API服务互相调用，因此需要对系统间服务调用进行管理，清晰地看到各系统调用关系，对系统间调用进行监控等。 API网关可以解决这些问题，我们可以认为如果没有大规模的实施微服务架构，那么对企业来说微服务网关就是企业的API服务管理平台。</li></ol><p><strong>二、API网关在企业整体架构中的地位</strong></p><p>一个企业随着信息系统复杂度的提高，必然出现外部合作伙伴应用、企业自身的公网应用、企业内网应用等，在架构上应该将这三种应用区别开，三种应用的安排级别、访问方式也不一样。 因此在我的设计中将这三种应用分别用不同的网关进行API管理，分别是：API网关（OpenAPI合伙伙伴应用）、API网关（内部应用）、API网关（内部公网应用）。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e2277268a52f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>三、企业中在如何应用API网关</strong></p><p>1、对于OpenAPI使用的API网关来说，一般合作伙伴要以应用的形式接入到OpenAPI平台，合作伙伴需要到 OpenAPI平台申请应用。 因此在OpenAPI网关之外，需要有一个面向合作伙伴的使用的平台用于合作伙伴，这就要求OpenAPI网关需要提供API给这个用户平台进行访问。 如下架构:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22771fcfb2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>当然如果是在简单的场景下，可能并不需要提供一个面向合作伙伴的门户，只需要由公司的运营人员直接添加合作伙伴应用id&#x2F;密钥等，这种情况下也就不需要合作伙伴门户子系统。 </p><p>2、对于内网的API网关，在起到的作用上来说可以认为是微服务网关，也可以认为是内网的API服务治理平台。 当企业将所有的应用使用微服务的架构管理起来，那么API网关就起到了微服务网关的作用。 而当企业只是将系统与系统之间的调用使用rest api的方式进行访问时使用API网关对调用进行管理，那么API网关起到的就是API服务治理的作用。 架构参考如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22773d85f4b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>3、对于公司内部公网应用（如APP、公司的网站），如果管理上比较细致，在架构上是可能由独立的API网关来处理这部分内部公网应用，如果想比较简单的处理，也可以是使用面向合作伙伴的API网关。 如果使用独立的API网关，有以下的好处：</p><ul><li>面向合作伙伴和面向公司主体业务的优先级不一样，不同的API网关可以做到业务影响的隔离。</li><li>内部API使用的管理流程和面向合作伙伴的管理流程可能不一样。</li><li>内部的API在功能扩展等方面的需求一般会大于OpenAPI对于功能的要求。</li></ul><p>基于以上的分析，如果公司有能力，那么还是建议分开使用合作伙伴OPEN API网关和内部公网应用网关。</p><p><strong>四、API网关有哪些竞争方案</strong></p><p>1、对于Open API平台的API网关，我分析只能选择API网关作为解决方案，业界没有发现比较好的可以用来作为Open API平台的入口的其他方案。</p><p>2、对于作为微服务网关的API网关，业界的选择可以选择的解决方案比较多，也取决于微服务器的实现方案，有一些微服务架构的实现方案是不需要微服务网关的。</p><ul><li>Service Mesh，这是新兴的基于无API网关的架构，通过在客户端上的代理完成屏蔽网络层的访问，这样达到对应用层最小的改动，当前Service Mesh的产品还正在开发中，并没有非常成熟可直接应用的产品。 发展最迅速的产品是Istio。 建议大家密切关注相关产品的研发、业务使用进展。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22773e3b43d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><ul><li>基于duboo架构，在这个架构中通常是不需要网关的，是由客户端直接访问服务提供方，由注册中心向客户端返回服务方的地址。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22774198749~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>五、API网关解决方案</strong></p><p>私有云开源解决方案如下：</p><ul><li>Kong kong是基于Nginx+Lua进行二次开发的方案， <a href="https://konghq.com/">https://konghq.com/</a></li><li>Netflix Zuul，zuul是spring cloud的一个推荐组件，<a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a></li><li>orange,这个开源程序是国人开发的， <a href="http://orange.sumory.com/">http://orange.sumory.com/</a></li></ul><p>公有云解决方案：</p><ul><li>Amazon API Gateway，<a href="https://aws.amazon.com/cn/api-gateway/">https://aws.amazon.com/cn/api-gateway/</a></li><li>阿里云API网关，<a href="https://www.aliyun.com/product/apigateway/">https://www.aliyun.com/product/apigateway/</a></li><li>腾讯云API网关， <a href="https://cloud.tencent.com/product/apigateway">https://cloud.tencent.com/product/apigateway</a></li></ul><p>自开发解决方案：</p><ul><li>基于Nginx+Lua+ OpenResty的方案，可以看到Kong,orange都是基于这个方案</li><li>基于Netty、非阻塞IO模型。 通过网上搜索可以看到国内的宜人贷等一些公司是基于这种方案，是一种成熟的方案。</li><li>基于Node.js的方案。 这种方案是应用了Node.js天生的非阻塞的特性。</li><li>基于java Servlet的方案。 zuul基于的就是这种方案，这种方案的效率不高，这也是zuul总是被诟病的原因。</li></ul><p><strong>六、企业怎么选择API网关</strong></p><p>如果是要选择一款已有的API网关，那么需要从以下几个方面去考虑。 </p><p>1、性能与可用性</p><p>如果一旦采用了API网关，那么API网关就会作为企业应用核心，因此性能和可用性是必须要求的。</p><ul><li>从性能上来说，需要让网关增加的时间消耗越短越好，个人觉得需要10ms以下。 系统需要采用非阻塞的IO，如epoll，NIO等。网关和各种依赖的交互也需要是非阻塞的，这样才能保证整体系统的高可用性，如：Node.js的响应式编程和基于java体现的RxJava和Future。</li><li>网关必须支持集群部署，任务一台服务器的crash都应该不影响整体系统的可用性。</li><li>多套网关应该支持同一管理平台和同一监控中心。 如： 一个企业的OpenAPI网关和内部应用的多个系统群的不同的微服务网关可以在同一监控中心进行监控。</li></ul><p>2、可扩展性、可维护性</p><p>一款产品总有不能满足生产需求的地方，因此需求思考产品在如何进行二次开发和维护，是否方便公司团队接手维护产品。</p><p>3、需求匹配度</p><p>需要评估各API网关在需求上是否能满足，如： 如果是OpenAPI平台需要使用API网关，那么需要看API网关在合作伙伴应用接入、合作伙伴门户集成、访问次数限额等OpenAPI核心需求上去思考产品是否能满足要求。 如果是微服务网关，那么要从微服务的运维、监控、管理等方面去思考产品是否足够强大。</p><p>4、是否开源？公司是否有自开发的能力？</p><p>现有的开源产品如kong，zuul，orange都有基础的API网关的核心功能，这些开源产品大多离很好的使用有一定的距离，如：没有提供管理功能的UI界面、监控功能弱小，不支持OpenAPI平台，没有公司运营与运维的功能等。 当然开源产品能获取源代码，如果公司有比较强的研发能力，能hold住这些开源产品，经过二次开发kong、zuul应该还是适应一些公司，不过需求注意以下一些点：</p><ul><li>kong是基于ngnix+lua的，从公司的角度比较难于找到能去维护这种架构产品的人。 需求评估当前公司是否有这个能力去维护这个产品。</li><li>zuul因为架构的原因在高并发的情况下性能不高，同时需要去基于研究整合开源的适配zuul的监控和管理系统。</li><li>orange由于没有被大量使用，同时是国内个人在开源，在可持续性和社区资源上不够丰富，出了问题后可能不容易找到人问。</li></ul><p>另外kong提供企业版本的API网关，当然也是基于ngnix+lua的，企业版本可以购买他们的技术支持、培训等服务、以及拥有界面的管理、监控等功能。</p><p>5、公有云还是私有云</p><p>现在的亚马逊、阿里、腾讯云都在提供基础公有云的API网关，当然这些网关的基础功能肯定是没有问题，但是二次开发，扩展功能、监控功能可能就不能满足部分用户的定制需求了。另外很多企业因为自身信息安全的原因，不能使用外网公有网的API网关服务，这样就只有选择私有云的方案了。</p><p>在需求上如果基于公有云的API网关只能做到由内部人员为外网人员申请应用，无法做到定制的合作伙伴门户，这也不适合于部分企业的需求。<br>如果作为微服务网关，大多数情况下是希望网关服务器和服务提供方服务器是要在内网的，在这里情况下也只有私有云的API网关才能满足需求。</p><p>综合上面的分析，基础公有云的API网关只有满足一部分简单客户的需求，对于很多企业来说私有云的API网关才是正确的选择。</p><p>转自</p><h3 id="BLOG地址：www-liangsonghua-com"><a href="#BLOG地址：www-liangsonghua-com" class="headerlink" title="BLOG地址：www.liangsonghua.com"></a>BLOG地址：<a href="https://link.juejin.cn/?target=http://www.liangsonghua.com">www.liangsonghua.com</a></h3>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务核心架构梳理</title>
      <link href="/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/"/>
      <url>/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>作业总结的不错，转载一下～</p><p>作者：tengshe789</p><p>链接：<a href="https://urlify.cn/zYJzee">https://urlify.cn/zYJzee</a></p><p>下文，你将看到业界主流微服务框架的核心原理，包括服务发现，网关，配置中心，监控等组件，功能和架构原理的简单介绍。感谢阅读！</p><h1 id="Hello，Microservices"><a href="#Hello，Microservices" class="headerlink" title="Hello，Microservices"></a>Hello，Microservices</h1><p><strong>什么是微服务</strong></p><p>微服务Microservices之父，马丁.福勒，对微服务大概的概述如下：</p><blockquote><p>就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。但通在其常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p></blockquote><p>根据马丁.福勒的描述，我总结了一下几点：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/724387762baa49dabc8fae5f36edade1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ser3itD8NC19CaClz4hTVfpAGkA=" alt="img"></p><p><strong>小服务</strong></p><p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p><p><strong>进程独立</strong></p><p>每一组服务都是独立运行的，可能我这个服务运行在tomcat容器，而另一个服务运行在jetty上。可以通过进程方式，不断的横向扩展整个服务。</p><p><strong>通信</strong></p><p>过去的协议都是很重的，就像ESB，就像SOAP，轻通信，着意味着相比过去更智能更轻量的服务相互调用，就所谓smart endpoints and dumb pipes，这些endpoint都是解耦的，完成一个业务通信调用串起这些micro service就像是linux系统中通过管道串起一系列命令业务。</p><p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p><p><strong>部署</strong></p><p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维指责</p><p><strong>管理</strong></p><p>传统的企业级SOA服务往往很大，不易于管理，耦合性高，团队开发成本比较大。微服务，可以让团队各思其政的选择技术实现，不同的service可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p><h1 id="微服务的利与弊"><a href="#微服务的利与弊" class="headerlink" title="微服务的利与弊"></a><strong>微服务的利与弊</strong></h1><p>为什么用微服务呢？因为好玩？</p><p>不是的。下面是我从网络上找到说的比较全的优点：</p><blockquote><p>优点每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求<br>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。<br>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。<br>微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。<br>微服务能使用不同的语言开发。<br>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins,Hudson,bamboo。<br>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需- - 通过合作才能体现价值。微服务允许你利用融合最新技术。<br>微服务只是业务逻辑的代码，不会和 HTML,CSS或其他界面组件混合。<br>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</p></blockquote><p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p><p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p><h1 id="什么组织适合使用微服务？"><a href="#什么组织适合使用微服务？" class="headerlink" title="什么组织适合使用微服务？"></a><strong>什么组织适合使用微服务？</strong></h1><p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务？</p><p><strong>墨菲定律（设计系统）和康威定律（系统划分）</strong></p><p>康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/9e4d43792c37454aab148326328dcead~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=Fy0R5j/IHPDuxHSy/55w+RiOGBc=" alt="img"></p><p>感兴趣的各位可以研究一下</p><h1 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a><strong>架构演化</strong></h1><p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/c1e94e85a2c842e69cc79b5968dfdbb4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=lknzFU4sJ2RpxE25224WUSlSECA=" alt="img"></p><p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/b8127c777e884c4e8c4fdfabca298d1d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=UwJFqfOgqTedDW253kdV7CIcBiw=" alt="img"></p><p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用API方式发布他们的功能，而平台使用他们的功能发布产品</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/7c64a067343943759a1418e0dccd7f5d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=YXJpXxB/aiO3D4MC5L84bOjJv6U=" alt="img"></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/429bf7c0a7a84099894e9b7cdfda1fe1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aMnhFdwrd+teQLj2ZUPbDZJtJYs=" alt="img"></p><h1 id="微服务技术架构体系"><a href="#微服务技术架构体系" class="headerlink" title="微服务技术架构体系"></a><strong>微服务技术架构体系</strong></h1><p>下面我分享一下大部分公司都使用的微服务技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/1a3105e8d32d46379189e66a232c5f5a~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ij1N/fUpKJzAvGEZlC5KBiLQyaY=" alt="img"></p><p><strong>服务发现</strong></p><p>主流的服务发现，分为三种</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/54bed4ea976241cdbf877ea00744b3ce~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cdJ1FzkKqJmQGQvYq/HY9r9kn4Y=" alt="img"></p><p>第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过dns就能找到我们对应的服务</p><p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/d899c1e6e46142498850771ecaff515f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=VDVwjxxbVq+BMeEc0YiYWvoHfQY=" alt="img"></p><p>第二种，是目前普遍的做法。可以参考我上篇博客分析的zuul网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p><p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在spring cloud上的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/dfa8e250379c48ebae7ca4e035afe9f3~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SEkNf7rkzF306T7LFZtnVqoV6gY=" alt="img"></p><p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p><p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p><p><strong>网关</strong></p><p>\1. 微服务的网关是什么？</p><p>我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p><p>将生活实际联系到微服务上，就不难理解网关的意思了。</p><p>\2. 网关有什么用</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/68c66bd974f0477d887ce55aefdbcc44~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cZR+tSGtIE2FDJLjo7kgOUpwT7M=" alt="img"></p><ul><li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务条用</li><li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li><li>限流熔断：参考我学好分布式zookepper的博客，当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题</li><li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息</li><li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</li></ul><p>\3. 开源网关Zuul架构</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/6924461c3b584f178a6c1c71eb27dd63~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aG4q8LZQ37wxOjllgVJsWlmADYc=" alt="img"></p><p>zuul网关核心其实是一个servlet，所有请求都会经过zuul servlet传到zuulFilter Runner，然后分发到三种过滤器。</p><p>先说说架构图左半部分，分别是使用Groovy实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p><p>一般请求都会先经过前置路由过滤器处理，一般的自定义java封装逻辑也会在这里实现。</p><p>路由过滤器，实现的是找到对应的微服务进行调用。</p><p>调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p><p>可以说zuul网关最大的特色就是它三层过滤器。</p><p>架构图右半部分，是zuul网关设计的自定义过滤器加载机制。网关内部会有生产者消费者模型，自动的将过滤器脚本发布到zuul网关读取加载运行。</p><p><strong>配置中心</strong></p><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p><p>因此就有配置中心这个喽~</p><p>现在的开源中心有百度配置中心 Disconf，spring cloud config，Apollo，今天重点说说现在应用质量不错的配置中心阿波罗。</p><h1 id="携程开源的Apollo："><a href="#携程开源的Apollo：" class="headerlink" title="携程开源的Apollo："></a>携程开源的Apollo：</h1><p>开源地址：<br><a href="http://github.com/ctripcorp/a%E2%80%A6">http://github.com/ctripcorp/a…</a></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/491e23c2faf6474591de5c6315747bf4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=25CNEBPSxaikMdxrij2U3KeXce0=" alt="img"></p><p>apollo的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。</p><p><strong>通讯方式</strong></p><p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/ed64b2a43bce4d0ba8ad9d098b6d0471~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=OIlCDdABP9f+xZvHYmwNyNHHg7E=" alt="img"></p><p><strong>监控预警</strong></p><p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。一般监控分为如下层次：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/10bde5726cbf454cabb768571febb1c2~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=P1vOxOdm3N1HsbgQ9XtWN1zDRWY=" alt="img"></p><p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。总体来说，微服务可分5个监控点：日志监控，Metrics监控，健康检查，调用链检查，告警系统</p><p><strong>监控架构</strong></p><p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个agent，agent收集到关键信息，会传到一些MQ中，为了解耦。同时将日志传入ELK，将Metrics传入InfluxDB时间序列库。而像nagios，可以定期向agent发起信息检查微服务。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/3b101e363c9c4ec487a25ba97bdaff98~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=sEFV5fgBICGW5MenbusWvbH83B8=" alt="img"></p><p><strong>调用链监控APM</strong></p><p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的Cat，大部分调用链监控（没错，我指的Zipkin）架构是这样的</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/aee3fd28e0cd42299b83486a608251c8~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=4kZFphBO9qDIRp1Oj3YKNb61Bgw=" alt="img"></p><p>当请求进入Web容器的时候，会经过创建Tracer，连接spans（模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过http headers）。Spans有一个上下文，其中包含tracer标识符，将其放在表示分布式操作的树的正确位置。当我们把图中的各种span放到后端的时候，我们的服务调用链会动态的生成调用链。</p><p>下面是一些市场上用的比较多的调用链监控：</p><p>1、Pinpointgithub地址：GitHub - naver&#x2F;pinpoint: Pinpoint is an open source APM (Application Performance Management) tool for large-scale distributed systems written in Java.对java领域的性能分析有兴趣的朋友都应该看看这个开源项目，这个是一个韩国团队开源出来的，通过JavaAgent的机制来做字节码代码植入，实现加入traceid和抓取性能数据的目的。NewRelic、Oneapm之类的工具在java平台上的性能分析也是类似的机制。</p><p>2、SkyWalkinggithub地址：wu-sheng&#x2F;sky-walking这是国内一位叫吴晟的兄弟开源的，也是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统，在github上也有400多颗星了。功能相对pinpoint还是稍弱一些，插件还没那么丰富，不过也很难得了。</p><p>3、Zipkin官网：OpenZipkin · A distributed tracing systemgithub地址：GitHub - openzipkin&#x2F;zipkin: Zipkin is a distributed tracing system这个是twitter开源出来的，也是参考Dapper的体系来做的。</p><p>Zipkin的java应用端是通过一个叫Brave的组件来实现对应用内部的性能分析数据采集。Brave的github地址：<br><a href="http://github.com/openzipkin/%E2%80%A6%E8%BF%99%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84java%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E6%9D%A5%E5%81%9A%E5%88%B0%E5%AF%B9http/servlet%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E8%B7%9F%E8%B8%AA%E3%80%82%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E5%9C%A8spring%E4%B9%8B%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8C%E5%8A%A0%E5%85%A5%E8%BF%99%E4%BA%9B%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E5%AE%8C%E6%88%90%E5%AF%B9java%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%82">http://github.com/openzipkin/…这个组件通过实现一系列的java拦截器，来做到对http/servlet请求、数据库访问的调用过程跟踪。然后通过在spring之类的配置文件里加入这些拦截器，完成对java应用的性能数据采集。</a></p><p>4、CATgithub地址：GitHub - dianping&#x2F;cat: Central Application Tracking这个是大众点评开源出来的，实现的功能也还是蛮丰富的，国内也有一些公司在用了。不过他实现跟踪的手段，是要在代码里硬编码写一些“埋点”，也就是侵入式的。这样做有利有弊，好处是可以在自己需要的地方加埋点，比较有针对性；坏处是必须改动现有系统，很多开发团队不愿意。</p><p>5、Xhprof&#x2F;Xhgui这两个工具的组合，是针对PHP应用提供APM能力的工具，也是非侵入式的。Xhprof github地址：GitHub - preinheimer&#x2F;xhprof: XHGUI is a GUI for the XHProf PHP extension, using a database backend, and pretty graphs to make it easy to use and interpret.Xhgui github地址：GitHub - perftools&#x2F;xhgui: A graphical interface for XHProf data built on MongoDB我对PHP不熟，不过网上介绍这两个工具的资料还是蛮多的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/4507d426ed7146688375580da41906ff~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=rypjolffor+bucyFBSFu7Oh2mZY=" alt="img"></p><p><strong>熔断、隔离、限流、降级</strong></p><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用）措施。</p><p>下面介绍一下hystrix的运行流程（没找到架构图不好意思）：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/159090c7e4cb48c3b028fbd031bcc1e7~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SaFR9FsnPR98f8EH08yjHM83Y+Y=" alt="img"></p><p>每一个微服务调用时，都会使用hystrix的command方式（上图的左上角那个），然后使用command同步的，或者是响应式的，或者是异步的，判断电路是否熔断（顺着图从左往右看），</p><p>如果断路则走降级fallback；</p><p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施（看图的第5步）；</p><p>如果走完了，执行成功了，则走run()方法，获取response，但是这个过程如果出错了，则继续走降级fallback.</p><p>同时，看图最上面有一个后缀是health的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p><p><strong>容器与服务编排引擎</strong></p><p>从物理机到虚拟机，从虚拟机到容器；从物理集群到open stack，open stack到kubernetes；科技不断的变化，我们的认知也没刷新。</p><p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。 虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。虚拟机依赖于hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致hypervisor在某些方面被认为是一种操作系统。</p><p>一旦 hypervisor安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层Runtime，然后供应用程序运行。</p><p>对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如LXC或libcontainer)安装在主机操作系统(通常是Linux变种)之上。在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p><p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味相比于虚拟机，单个操作系统能够承载更多的容器。云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p><p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p><p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。正因为如此，容器才拥有极为出色的轻量化特性。</p><p>我们最常用的容器是daocker，网址如下<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>容器编排：</p><p>过去虚拟机可以通过云平台open stack管理虚拟化，容器时代如何管理容器呢？这就要看看容器编排引擎了。</p><p><strong>Apache mesos</strong></p><p>mesos是基于master，slave架构，框架决定如何利用资源，master负责管理机器，slave会定期的将机器情况报告给master，master再将信息给框架。master是高可用的，因为zk，也有leader的存在。下面是架构图</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/39a21281f9334b1b853f04a48107336b~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=WPM760vVO3zapa972giTo+2WRLY=" alt="img"></p><p><strong>kubernetes</strong></p><p>kubernetes是最近十分火热的开源容器编排引擎，具体可以参考kubernetes中文文档</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/596e958431f54c18a22592150ca8c103~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=yG+jZsDug8lqC7rMQSawQEqBlQI=" alt="img"></p><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，先说说每一个Kubernetes节点内部，kubelet管理全局全局pod，而每一个pod承载着一个或多个容器，kube-proxy负责网络代理和负载均衡 。</p><p>Kubernetes节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p><p><strong>服务网格化</strong></p><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 内存布局及细节分析</title>
      <link href="/2020/02/12/java/JVM%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/12/java/JVM%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本JVM系列属于本人学习过程当中总结的一些知识点，目的是想让读者更快地掌握JVM相关的知识要点，难免会有所侧重，若想要更加系统更加详细的学习JVM知识，还是需要去阅读专业的书籍和文档。</p><p>本文主题内容：</p><ul><li>JVM 内存区域概览</li><li><strong>堆区的空间分配是怎么样？堆溢出的演示</strong></li><li><strong>创建一个新对象内存是怎么分配的？</strong></li><li><strong>方法区 到 Metaspace 元空间</strong></li><li><strong>栈帧是什么？栈帧里有什么？怎么理解？</strong></li><li>本地方法栈</li><li>程序计数器</li><li><strong>Code Cache 是什么？</strong></li></ul><blockquote><p><strong>注：请 区分 JVM内存结构（内存布局） 和 JMM（Java内存模型）这两个不同的概念！</strong></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略 ，保证了 JVM 的高效稳定运行。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750982daa7b6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>上图描述了当前比较经典的Java内存布局。（堆区画小了2333，按理来说应该是最大的区域）</p><p>如果按照线程是否共享来分类的话，如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f47509829e2b5b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><blockquote><p>PS：线程是否共享这点，实际上理解了每块区域的实际用处之后，就很自然而然的就记住了。不需要死记硬背。</p></blockquote><p>下面让我们来了解下各个区域。</p><h2 id="一、Heap-堆区）"><a href="#一、Heap-堆区）" class="headerlink" title="一、Heap (堆区）"></a>一、Heap (堆区）</h2><h3 id="1-1-堆区的介绍"><a href="#1-1-堆区的介绍" class="headerlink" title="1.1 堆区的介绍"></a>1.1 堆区的介绍</h3><p>我们先来说堆。堆是 OOM故障最主要的发生区域。它是内存区域中最大的一块区域，被所有<strong>线程共享</strong>，存储着<strong>几乎所有</strong>的实例对象、数组。<strong>所有的对象实例以及数组都要在堆上分配</strong>，但是随着JIT编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，<strong>所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</strong>。</p><blockquote><p>延伸知识点：JIT编译优化中的一部分内容 - <strong>逃逸分析</strong>。</p><p>推荐阅读：<a href="https://link.juejin.cn/?target=https://www.hollischuang.com/archives/2583">深入理解Java中的逃逸分析</a></p></blockquote><p>Java堆是垃圾收集器管理的主要区域，因此<strong>很多时候也被称做“GC堆”</strong>。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代</strong>。再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor空间</strong>等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><h3 id="1-2-堆区的调整"><a href="#1-2-堆区的调整" class="headerlink" title="1.2 堆区的调整"></a>1.2 堆区的调整</h3><p>根据Java虚拟机规范的规定，<strong>Java堆可以处于物理上不连续的内存空间中</strong>，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以在运行时动态地调整。</p><p><strong>如何调整呢？</strong></p><p>通过设置如下参数，可以设定堆区的初始值和最大值，比如 <code>-Xms256M -Xmx 1024M</code>，其中 <code>-X</code>这个字母代表它是JVM运行时参数，<code>ms</code>是<code>memory start</code>的简称，中文意思就是内存初始值，<code>mx</code> 是 <code>memory max</code>的简称，意思就是最大内存。</p><p><strong>值得注意的是，在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力 所以在线上生产环境中 JVM的<code>Xms</code>和 <code>Xmx</code>会设置成同样大小，避免在GC 后调整堆大小时带来的额外压力。</strong></p><h3 id="1-3-堆的默认空间分配"><a href="#1-3-堆的默认空间分配" class="headerlink" title="1.3 堆的默认空间分配"></a>1.3 堆的默认空间分配</h3><p>另外，再强调一下堆空间内存分配的大体情况。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750983bf3620~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>这里可能就会有人来问了，你从哪里知道的呢？如果我想配置这个比例，要怎么修改呢？</p><p>我先来告诉你怎么看虚拟机的默认配置。命令行上执行如下命令，就可以查看当前JDK版本所有默认的JVM参数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="variable constant_">XX</span><span class="symbol">:+PrintFlagsFinal</span> -version</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对应的输出应该有几百行，我们这里去看和堆内存分配相关的两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">[Global flags]</span><br><span class="line">...</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">InitialSurvivorRatio</span>                      <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">    <span class="type">uintx</span> <span class="variable">NewRatio</span>                                  <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">java version <span class="string">&quot;1.8.0_131&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_131</span>-b11)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.131</span>-b11, mixed mode)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:InitialSurvivorRatio</td><td>新生代Eden&#x2F;Survivor空间的初始比例</td></tr><tr><td>-XX:NewRatio</td><td>Old区&#x2F;Young区的内存比例</td></tr></tbody></table><p>因为新生代是由Eden + S0 + S1组成的，所以按照上述默认比例，如果eden区内存大小是40M，那么两个survivor区就是5M，整个young区就是50M，然后可以算出Old区内存大小是100M，堆区总大小就是150M。</p><h3 id="1-4-堆溢出-演示"><a href="#1-4-堆溢出-演示" class="headerlink" title="1.4 堆溢出 演示"></a>1.4 堆溢出 演示</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * @author Richard_Yi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">            byteList.<span class="built_in">add</span>(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Java</span> <span class="selector-tag">heap</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">Dumping</span> <span class="selector-tag">heap</span> <span class="selector-tag">to</span> <span class="selector-tag">java_pid32372</span><span class="selector-class">.hprof</span> ...</span><br><span class="line"><span class="selector-tag">Heap</span> <span class="selector-tag">dump</span> <span class="selector-tag">file</span> <span class="selector-tag">created</span> <span class="selector-attr">[7774077 bytes in 0.009 secs]</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> &quot;<span class="selector-tag">main</span>&quot; <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Java</span> <span class="selector-tag">heap</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">jvm</span><span class="selector-class">.HeapOOMTest</span><span class="selector-class">.main</span>(HeapOOMTest.<span class="attribute">java</span>:<span class="number">18</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>-XX:+HeapDumpOnOutOfMemoryError</code> 可以让JVM在遇到OOM异常时，输出堆内信息，特别是对相隔数月才出现的OOM异常尤为重要。</p><h2 id="创建一个新对象-内存分配流程"><a href="#创建一个新对象-内存分配流程" class="headerlink" title="创建一个新对象 内存分配流程"></a>创建一个新对象 内存分配流程</h2><p>看完上面对堆的介绍，我们趁热打铁再学习一下JVM创建一个新对象的内存分配流程。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750983d600e5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发<code>Young Garbage Collection</code>，即<code>YGC</code>。垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区。Survivor区分为so和s1两块内存空间。每次<code>YGC</code>的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果<code>YGC</code>要移送的对象大于Survivor区容量的上限，则直接移交给老年代。一个对象也不可能永远呆在新生代，就像人到了18岁就会成年一样，在JVM中<code>－XX:MaxTenuringThreshold</code>参数就是来配置一个对象从新生代晋升到老年代的阈值。默认值是<strong>15</strong>， 可以在Survivor区交换14次之后，晋升至老年代。</p><blockquote><p>上述涉及到一部分垃圾回收的名词，不熟悉的读者可以查阅资料或者看下本系列的垃圾回收章节。</p></blockquote><h2 id="二、Metaspace-元空间"><a href="#二、Metaspace-元空间" class="headerlink" title="二、Metaspace 元空间"></a>二、Metaspace 元空间</h2><p>在 HotSpot JVM 中，**永久代（ ≈ 方法区）**中用于**存放类和方法的元数据以及常量池**，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code>，为此我们不得不对虚拟机做调优。</p><p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？（详见：<a href="https://link.juejin.cn/?target=http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation</a>）：</p><ol><li>由于 PermGen 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li><li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li></ol><p>根据上面的各种原因，PermGen 最终被移除，<strong>方法区移至 Metaspace，字符串常量池移至堆区</strong>。</p><p>准确来说，Perm 区中的<strong>字符串常量池被移到了堆内存</strong>中是在Java7 之后，Java 8 时，PermGen 被元空间代替，<strong>其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区</strong>。比如<code>java/lang/Object</code>类元信息、静态属性<code>System.out</code>、整形常量 <code>100000</code>等。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。（和后面提到的直接内存一样，都是使用本地内存）</p><blockquote><p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p></blockquote><p><strong>对应的JVM调参：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:MetaspaceSize</td><td>分配给Metaspace（以字节计）的初始大小</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td></tr><tr><td>-XX:MinMetaspaceFreeRatio</td><td>在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td></tr><tr><td>-XX:MaxMetaspaceFreeRatio</td><td>在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td></tr></tbody></table><blockquote><p>延伸阅读：关于Metaspace比较好的两篇文章。</p><blockquote><ol><li><a href="https://link.juejin.cn/?target=http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html">Metaspace in Java 8</a></li><li><a href="https://link.juejin.cn/?target=http://lovestblog.cn/blog/2016/10/29/metaspace/">lovestblog.cn&#x2F;blog&#x2F;2016&#x2F;1…</a></li></ol></blockquote></blockquote><h2 id="三、-Java-虚拟机栈"><a href="#三、-Java-虚拟机栈" class="headerlink" title="三、 Java 虚拟机栈"></a>三、 Java 虚拟机栈</h2><p>对于每一个线程，JVM 都会在线程被创建的时候，创建一个单独的栈。也就是说虚拟机栈的生命周期和线程是一致，并且是线程私有的。除了Native方法以外，Java方法都是通过Java 虚拟机栈来实现调用和执行过程的（需要程序技术器、堆、元空间内数据的配合）。所以Java虚拟机栈是虚拟机执行引擎的核心之一。而Java虚拟机栈中出栈入栈的元素就称为「栈帧」。</p><p><strong>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</strong></p><blockquote><p>栈对应线程，栈帧对应方法</p></blockquote><p>在活动线程中， 只有位于栈顶的帧才是有效的， 称为<strong>当前栈帧</strong>。正在执行的方法称为<strong>当前方法</strong>。在执行引擎运行时， 所有指令都只能针对当前栈帧进行操作。而<code>StackOverflowError</code> 表示请求的<strong>栈溢出</strong>， 导致内存耗尽， 通常出现在递归方法中。</p><p>虚拟机栈通过pop和push的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现了异常，会进行异常回溯，返回地址通过异常处理表确定。</p><p>可以看出栈帧在整个JVM 体系中的地位颇高。下面也具体介绍一下栈帧中的存储信息。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750984563c2a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h3 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h3><blockquote><p>局部变量表就是<strong>存放方法参数和方法内部定义的局部变量的区域</strong>。</p></blockquote><p><strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</strong>。</p><p>这里直接上代码，更好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果局部变量是Java的8种基本基本数据类型，则存在局部变量表中，如果是引用类型。如new出来的String，局部变量表中存的是引用，而实例在堆中。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750984f45f1e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h3 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2. 操作栈"></a>2. 操作栈</h3><p><strong>操作数栈（Operand Stack）**看名字可以知道是一个栈结构。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当JVM为方法创建栈帧的时候，在**栈帧**中为方法创建一个</strong>操作数栈**，保证方法内指令可以完成工作。</p><p>还是用实操理解一下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author Richard_yyf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperandStackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>编译生成<code>.class</code>文件之后，再反汇编查看汇编指令</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; javac OperandStackTest.java</span></span><br><span class="line"><span class="quote">&gt; javap -v OperandStackTest.class &gt; 1.txt</span></span><br><span class="line">复制代码</span><br><span class="line">  public int sum(int, int);</span><br><span class="line"><span class="code">    descriptor: (II)I</span></span><br><span class="line"><span class="code">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="code">    Code:</span></span><br><span class="line"><span class="code">      stack=2, locals=3, args_size=3 // 最大栈深度为2 局部变量个数为3</span></span><br><span class="line"><span class="code">         0: iload_1 // 局部变量1 压栈</span></span><br><span class="line"><span class="code">         1: iload_2 // 局部变量2 压栈</span></span><br><span class="line"><span class="code">         2: iadd    // 栈顶两个元素相加，计算结果压栈</span></span><br><span class="line"><span class="code">         3: ireturn</span></span><br><span class="line"><span class="code">      LineNumberTable:</span></span><br><span class="line"><span class="code">        line 10: 0</span></span><br><span class="line"><span class="code">复制代码</span></span><br></pre></td></tr></table></figure><h3 id="3-动态连接"><a href="#3-动态连接" class="headerlink" title="3. 动态连接"></a>3. 动态连接</h3><p>每个栈帧中包含一个在常量池中<strong>对当前方法的引用</strong>， 目的是<strong>支持方法调用过程的动态连接</strong>。</p><h3 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h3><p>方法执行时有两种退出情况：</p><ul><li>正常退出，即正常执行到任何方法的返回字节码指令，如 <code>RETURN</code>、<code>IRETURN</code>、<code>ARETURN</code>等</li><li>异常退出</li></ul><p>无论何种退出情况，都将返回至方法当前<strong>被</strong>调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给<strong>能够处理</strong>的栈帧</li><li>PC 计数器指向方法调用后的下一条指令</li></ul><blockquote><p>延伸阅读：<a href="https://link.juejin.cn/?target=https://louluan.blog.csdn.net/article/details/50412126">JVM机器指令集图解</a></p></blockquote><h2 id="四、本地方法栈"><a href="#四、本地方法栈" class="headerlink" title="四、本地方法栈"></a>四、本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，<strong>它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong>。</p><h2 id="五、程序计数器"><a href="#五、程序计数器" class="headerlink" title="五、程序计数器"></a>五、程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间。是线程私有的。<strong>它可以看作是当前线程所执行的字节码的行号指示器</strong>。什么意思呢？</p><blockquote><p><strong>白话版本：因为代码是在线程中运行的，线程有可能被挂起。即CPU一会执行线程A，线程A还没有执行完被挂起了，接着执行线程B，最后又来执行线程A了，CPU得知道执行线程A的哪一部分指令，线程计数器会告诉CPU。</strong></p></blockquote><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换并分配处理器执行时间的方式来实现</strong>的，CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于CPU 时间片轮限制，众多线程在并发执行过程中，<strong>任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</strong>。</p><p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。此区域也不会发生内存溢出异常。</p><h2 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以<strong>使用Native函数库直接分配堆外内存</strong>，然后通过一个<strong>存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作</strong>。这样能在一些场景中显著提高性能，因为<strong>避免了在Java堆和Native堆中来回复制数据</strong>。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。如果内存区域总和大于物理内存的限制，也会出现OOM。</p><h2 id="Code-Cache"><a href="#Code-Cache" class="headerlink" title="Code Cache"></a>Code Cache</h2><p>简而言之， <strong>JVM代码缓存是JVM将其字节码存储为本机代码的区域</strong> 。我们将可执行本机代码的每个块称为 <code>nmethod</code> 。该  <code>nmethod</code>可能是一个完整的或内联Java方法。</p><p>实时（JIT）编译器是代码缓存区域的最大消费者。这就是为什么一些开发人员将此内存称为JIT代码缓存的原因。</p><p>这部分代码所占用的内存空间成为CodeCache区域。一般情况下我们是不会关心这部分区域的且大部分开发人员对这块区域也不熟悉。如果这块区域OOM了，在日志里面就会看到 <code>java.lang.OutOfMemoryError code cache</code>。</p><h3 id="诊断选项"><a href="#诊断选项" class="headerlink" title="诊断选项"></a>诊断选项</h3><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>PrintCodeCache</td><td>false</td><td>是否在JVM退出前打印CodeCache的使用情况</td></tr><tr><td>PrintCodeCacheOnCompilation</td><td>false</td><td>是否在每个方法被JIT编译后打印CodeCache区域的使用情况</td></tr></tbody></table><blockquote><p>延伸阅读 <a href="https://link.juejin.cn/?target=https://www.baeldung.com/jvm-code-cache">Introduction to JVM Code Cache</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《深入理解Java虚拟机》 - 周志明</li><li>《码出高效》</li><li><a href="https://link.juejin.cn/?target=http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html">Metaspace in Java 8</a></li><li><a href="https://link.juejin.cn/?target=https://louluan.blog.csdn.net/article/details/50412126">JVM机器指令集图解</a></li><li><a href="https://link.juejin.cn/?target=https://www.baeldung.com/jvm-code-cache">Introduction to JVM Code Cache</a></li></ol><p>作者：Richard_Yi<br>链接：<a href="https://juejin.cn/post/6844904033396719624">https://juejin.cn/post/6844904033396719624</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD架构思想的旧瓶新酒</title>
      <link href="/2020/01/31/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/DDD%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%A7%E7%93%B6%E6%96%B0%E9%85%92/"/>
      <url>/2020/01/31/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/DDD%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%A7%E7%93%B6%E6%96%B0%E9%85%92/</url>
      
        <content type="html"><![CDATA[<p>DDD 和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 DDD-China 2019 上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。</p><p>DDD、DSL 和 DCI</p><p>DDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：</p><ol><li>首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。</li><li>第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；</li><li>第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；</li><li>第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；</li><li>第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。</li></ol><p>张晓龙此前曾在 DDD-China 峰会和 ArchSummit 全球架构师峰会上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。</p><p>DDD 和 DSL 的融合有三点：</p><ol><li>面向领域；</li><li>模型的组装方式；</li><li>分层架构演进。</li></ol><p>DSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。</p><p>DCI 的作用主要体现在两方面：</p><p>首先，DCI 助力 DDD 战术设计：</p><ol><li>显式的对 ROLE 建模，解决了贫血模型与充血模型之争；</li><li>一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；</li><li>当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；</li></ol><p>其次，DCI 助力 DDD 代码落地：</p><ol><li>对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。</li><li>根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；</li><li>小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。</li></ol><p>张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。</p><p>开发团队真的需要 DDD</p><p>DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。</p><p>对于开发团队而言，需要关注以下几点：</p><ul><li>首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；</li><li>其次是团队中各个角色都围绕领域模型开展工作；</li><li>第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？</li></ul><p>更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。</p><p>在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：</p><ol><li>嵌入式软件；</li><li>兼业务复杂性和技术复杂性；</li><li>软件规模大，功能复杂，特性交叉；</li><li>高质量，高性能，高可靠等要求。</li></ol><p>张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：领域专家下团队，和团队一起交流和协作；教练指导，开展战训营，定期 review；架构、设计、编码和工程实践：</p><p>（1）DCI，DSL，正交设计，组合式设计；</p><p>（2）编码规范和纪律；</p><p>（3）嵌入式 C&#x2F;C++ 最佳实践；软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。</p><p>DDD 与微服务</p><p>DDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是微服务的热风让人们才重新发现了领域驱动设计的价值。</p><p>微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。</p><p>“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。</p><p>对于业界目前流行的中台概念，张晓龙同样也有自己的看法：</p><p>中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。</p><p>中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。</p><p>DDD 的困局</p><p>最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？</p><p>张晓龙总结了 DDD 目前面临的几大困局：</p><ul><li>首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；</li><li>第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C# 写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；</li><li>第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；</li><li>第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；</li><li>第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。</li></ul><p>针对以上几大困局，张晓龙也给出了自己的解决方案：</p><ol><li>培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；</li><li>领域专家和团队一起工作，确保大家头脑中的画面是一致的；</li><li>DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。</li></ol><p>软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术人如何转型做管理</title>
      <link href="/2020/01/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BD%AC%E5%9E%8B%E5%81%9A%E7%AE%A1%E7%90%86-%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E4%B8%93%E5%AE%B6%E5%85%AC%E5%BC%8010%E5%A4%A7%E6%80%9D%E8%80%83/"/>
      <url>/2020/01/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BD%AC%E5%9E%8B%E5%81%9A%E7%AE%A1%E7%90%86-%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E4%B8%93%E5%AE%B6%E5%85%AC%E5%BC%8010%E5%A4%A7%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者：张荣，花名威视，<br>现任职阿里巴巴 CRO 线 NLP 算法团队 leader ，长期聚焦于 NLP 、图像识别、视频分析算法领域。</p></blockquote><p>因为信任，所以简单。</p><p><strong>团队的定位是什么？——做正确的事</strong></p><p><strong>定位</strong></p><p>团队的定位是重要的事情之一，一旦有了偏差，后续做得越多错得越多。确定团队的定位花了我很长时间，中间还发生了一次组织变化，和两任主管有多次讨论。</p><p>首先，这个团队配置在 CRO 线，肯定要为风险管理业务服务；同时，这又是一支能力团队，还要考虑和业务团队的协同关系。最终，我确定了3点：</p><p>1、能力建设为主，同时也需要有业务抓手；</p><p>2、不做业务团队已经做得好的事情；</p><p>3、立志高远，勇攀高峰，要做就做到最好。</p><p><img src="https://d.ifengimg.com/w1080_h656_q90_webp/x0.ifengimg.com/res/2020/5951249EA607BFCE5669AA10F244E3297507DEA4_size66_w1080_h656.jpeg"></p><p><strong>壁垒与价值</strong></p><p>不夸张地说，现在是NLP领域的大航海时代，新算法层出不穷，日新月异，后浪各种把前浪碾死在沙滩上。尤其是 BERT 横空出世之后，整个 NLP 的研究范式都发生了变化，从原来的 task-specific 的模型结构设计转变到语言模型 pretrain+ 下游任务 finetuning 的模式，预训练模型是含金量高的工作。研究一下预训练模型，你会发现这是个需要海量金钱+数据+技术才能玩的游戏。</p><p>这就陷入两难：如果搞预训练模型，没那么多资源；如果不搞，用开源模型做下游任务，实际上很难有什么技术壁垒。其实就算你真的搞出什么新算法可以充当技术壁垒，可能两三个月之后就又有人做出了更强的结果。</p><p>困境的根源在于，目前 NLP 算法这个领域发展速度太快了，在高速变化的领域是很难形成壁垒的。 <strong>所以，我们需要结合自身所处的环境，寻找变化不那么快的东西。</strong></p><p>我经过好多天的考虑之后，<strong>认为沉淀风险管控知识可以作为壁垒。</strong>原因：1）风险知识随时间有变化，但速度明显比算法慢很多；2）CRO 线在这方面有一定积累，也需要用于实际业务管控，并沉淀到产品。</p><p>所以，团队的宗旨我定义为：基于知识驱动的 NLP 算法团队。为 CRO 线乃至集团沉淀风险知识，并提供不同层次的服务：</p><p><img src="https://d.ifengimg.com/w1080_h390_q90_webp/x0.ifengimg.com/res/2020/E5E25AC5F58F5D173D31362D2064B0E2943B7FB9_size46_w1080_h390.jpeg"></p><p>图：4层服务体系</p><p>最近，CRO 线在清华举办了 AI 与安全研讨会，会上张钹院士谈到了第三代人工智能，尤其强调了其中知识的核心作用；我们走访中科院信工所，对方的宗旨也是建设基于知识驱动的算法，和业界发生的共鸣，更坚定了我们走这条道路的决心和信心。</p><p><strong>团队需要什么能力？</strong></p><p>先要搞清楚团队所处的环境。</p><p><strong>阿里是一个什么结构的组织？</strong></p><p>有人说是矩阵式的，有人说是树+网状的，我不知道确切的答案。不过，如果把每个小团队看作节点的话，有 2 点是确定的：</p><p>1、体量巨大，各种节点（业务、产品、工程、算法）种类繁多数量大。</p><p>2、单元节点之间比较容易发生跨大团队甚至跨 BU 的联系，条件合适可以发生协同关系。</p><p>继续观察，你会发现：</p><p>1、你所需要的一切资源几乎都能找到提供者，而且往往不止一个。</p><p>2、你也可以给各种需求节点提供服务，只要还在你的能力范围内。</p><p>3、由于规模巨大，需求节点和资源节点相互之间往往不知道对方在哪。</p><p>基于以上，我认为一个身处中台的算法团队，需要具备 4 项能力： <strong>连接-生产-传播-服务。</strong></p><p><img src="https://d.ifengimg.com/w1080_h345_q90_webp/x0.ifengimg.com/res/2020/E4460108A903A5D993ED96EA772BE2DD8169A191_size59_w1080_h345.png"></p><p>图：能力中台的算法团队需要具备的能力</p><p><strong>四项能力</strong></p><p><strong>连接：</strong> 就是寻找到自己所需要的资源，筛选出其中最优的，建立长期稳定的合作关系。比如算法团队需要的爬虫、标注工具、分布式模型训练工具、模型的评测工具等，都能在公司范围内获取，就没必要刀耕火种从头开始自己建设了。</p><p><strong>生产：</strong> 这是传统意义上算法工程师的工作，指获取数据后产出效果和效率达标的算法模型，并上线。</p><p>对算法的要求，主管的主管早有论述：算法要全！算法要强！算法要快！算法要便宜！精炼简洁，振聋发聩，细化一下就有：</p><p><img src="https://d.ifengimg.com/w1080_h541_q90_webp/x0.ifengimg.com/res/2020/A2F6BC931DE9E608EF1B444DE503F15D2DEFE110_size71_w1080_h541.jpeg" alt="img"></p><p>图：对算法的要求</p><p><strong>传播：</strong> 针对中台的算法团队提的要求，因为你需要让目标业务节点知道你的存在，知道你的能力项，以及细节。</p><p><strong>服务：</strong> 如果是专属某业务的算法团队，只需要考虑该业务下的 SLA 即可；如果是中台的算法团队，还需要考虑如何满足不同业务节点的需求，同时又不至于做开发和维护成本很高的个性化定制，避免随着接入业务的增长各种资源的开销也随着线性增长。</p><p><strong>能力雷达图</strong></p><p>团队的能力雷达图是由成员的个人能力长板组成的。（话越短意思越长）</p><p><img src="https://d.ifengimg.com/w569_h453_q90_webp/x0.ifengimg.com/res/2020/D5E088F9ED8E9791AA2BC2969C343CAA220E1680_size31_w569_h453.jpeg"></p><p>图：团队能力雷达图</p><p><strong>组织与个人的关系</strong></p><p><strong>为什么需要一个组织呢？</strong></p><p>先从一个现象出发：在小区业主和物业公司的纠纷斗争中，业主获胜的概率很低。从人数、个体的教育背景和素质来看，业主都占据绝对优势，可是为什么会输？</p><p>粗略分析，大体有三个原因：</p><p>1、共同利益，目标明确。物业的目标非常清晰，就是为了从业主那里赚钱，这也是物业人员的共同利益。业主人多，情况各有不同，各自的利益诉求差异大，容易被分化。</p><p>2、组织严密，相互协同。物业内部有明确的分工，平时也长期一起工作，相互间有信任感，能够进行配合。业主彼此之间往往是陌生人，缺乏信任感，难以统一行动，是原子化的散点。</p><p>3、局部相对优势。相对单个业主，物业具有明显力量优势。比如，物业有资金，而业主因为缺乏信任很难筹措资金。</p><p>好，看出来了，小规模组织的力量可以超过大规模原子化散点存在的个体集合的力量。</p><p><strong>组织为个人提供什么？</strong></p><p>1、组织能使资源增效组织能把各种资源组合成有机的整体，使各种分散的力量形成合力，从而产生大于这些资源和力量机械总和的效能。这个原理 2000 多年前亚里斯多德就论述过了，后来马克思又更严密地论述过一次。</p><p>2、组织是实现目标的依托： 个人可以依托组织的能力和资源去做事，而组织的能力和资源远大于个人，所以依托组织的时候，个人能够实现比单打独斗模式大得多的目标。</p><p>举个例子，我们团队做了 UGC 场景效果超越开源模型的预训练模型，每个同学都可以在这个预训练模型的基础上去做下游的有监督学习任务，起点就比别人高。</p><p><img src="https://d.ifengimg.com/w1080_h608_q90_webp/x0.ifengimg.com/res/2020/35F66BB41272DE113E2829A1BD1E452AB58FF5C3_size42_w1080_h608.jpeg"></p><p><strong>个人为组织提供什么？</strong></p><p><strong>是否有短板不是那么重要，关键是要有长板，能够对组织的能力雷达图做贡献。</strong></p><p>这一节留一个思考题：公司设置主管这个职位的目的是什么？是为了像幼儿园阿姨那样，保障每一个小朋友都有自己喜欢的玩具，高高兴兴上学来，平平安安回家去？</p><p><strong>招聘团队需要的人才</strong></p><p><strong>招聘为什么特别重要？</strong></p><p>世界有个普遍规律：在前序阶段做严格的控制会大大降低后序阶段的实现难度，比如数据标注、写代码、模型中的预处理等等。人招进来之后是要用要管的，招聘的时候高标准严要求，后续管理会轻松很多；如果降低标准甚至放水，后续管理付出的代价远远高于招聘时偷懒省的功夫。</p><p>所以，我花了至少 1&#x2F;3 的时间在招聘上。对的，至少 1&#x2F;3 ，你没有看错。从 2019 年 2 月到现在，社招弄了 300+ 份简历；校招 100+ 份简历。从统计数据看，每 100 份简历产生 2-3 个offer，入职 1-2 个人。从 100 份简历中招来的人绝对比 10 份简历中招来的省心很多。</p><p>我给算法团队找来过不少人，both 社招 and 校招，具体的展开讨论见彩蛋部分的【招聘】。</p><p><strong>招聘要考察哪些能力？</strong></p><p>招聘，首先要确定 job model 。限于篇幅，这里只讨论“生产”环节所需要的能力。</p><p>所处的时代背景：快速变化，新算法层出不穷。</p><p>不变的是什么： <strong>数学基础、计算机基础、动手能力。</strong></p><p>我们很难预测新技术的具体实现，但是当新技术出现的时候，需要能够快速地分析、学习、掌握。而且，我们经常要解决从来没有遇到过的新问题，这就要求候选人在面对没见过的问题时具备分析判断，在具体约束条件下找完整解决方案的能力。另外，在复杂的业务场景里，问题经常没有确定性的答案，我们往往通过对过程的合理性来判断整个方案是否合乎要求。寻找答案的过程很少有一帆风顺的，大概率会遭遇挫折，非常需要候选人不断尝试不断修正去抵达终点。</p><p>至于教育背景、之前从业经历，反而不怎么重要。我不赞成对于毕业好几年的社招候选人还要参考毕业学校、最高学位，甚至本科学校是否 985 ——如果一个人能力强，是不需要靠学校学位来旁证的，直接用行动证明就行了。</p><p>对于候选人的考察，我往往从基础的硬技能、创新性&#x2F;开放性思维、精神素质三方面考察。</p><p><img src="https://d.ifengimg.com/w1080_h721_q90_webp/x0.ifengimg.com/res/2020/0F544D1CB42108A81D39BE9192138FA04ACE126B_size53_w1080_h721.jpeg"></p><p><strong>硬技能</strong></p><p>数学：概率论与数理统计、矩阵论、随机过程。</p><p>计算机基础：操作系统、组成原理、数据结构。</p><p>算法能力：领域内主流模型的演进，优缺点对比；在具体设定的场景下选择合适的方案。</p><p>动手：C++&#x2F;python&#x2F;Java （什么？你说matlab？工业界里这个不算编程语言）。</p><p>有人说，面试过程中要求做代码测试，就像相亲时要求看存款证明一样残暴。我赞同这个说法，因为不少候选人听到要写代码就高傲地拒绝了。我给大家推荐一个在线代码测试工具：</p><p><a href="http://collabedit.com/">http://collabedit.com</a></p><p>从我长期的观察情况看，发展得好的算法同学，动手能力都比较强。毕竟，算法工程师，首先是一个工程师。</p><p><strong>创新性&#x2F;开放性思维</strong></p><p>其实我还经常干比代码测试更令人发指的事情——做智力题。这个不是我的创新，是学来的，甚至是直接找网上流传的面试题换个马甲来用。</p><p>前面的硬技能，看的往往是结果；这里对思考能力的考察，看的是过程：是否有方法论，思路是否清晰，是否言之有据。所以，这种问题的面试方式往往是讨论式。</p><p>如果候选人能够完成，最后再请TA做个总结，观察归纳要点的能力，视线的高度。</p><p>有些候选人结束面试后仍然会继续思考，给出更好的回答。</p><p><strong>精神素质</strong></p><p>公司对人才的要求是： <strong>乐观、皮实、聪明、自省。</strong></p><p>你看，四个词里面有两个都在强调坚韧不拔。在面试过程中，我会看候选人在解题不顺时的表现，有时甚至故意小刺激一下观察候选人的反应，偶尔还会故意中途改变限制条件。阿里内部竞争激烈，经常需要拥抱变化，如果心理承受力脆弱，是不适合当同路人的。</p><p>还有一点很重要： <strong>自我驱动力。</strong> 这是从降低对内管理成本来要求的，后面会具体说。</p><p>在我看来，硬技能、创新性&#x2F;开放性思维和精神素质缺一不可。即使这三方面我都满意了，如果主管，主管的主管， HR 对候选人明确提出疑虑，我一般不申辩直接放弃掉。因为，他们比我 level 高，阅人无数，往往不会错。</p><p>有的同学会问：这样子做，会不会错失优秀人才？是的，我的方式几乎可以确保招进来的同学肯定是好的，但会漏掉一些优秀的候选人，不过这不会造成严重的后果。相比之下，招进来不合格的人才会有大麻烦。</p><p><img src="https://d.ifengimg.com/w1080_h721_q90_webp/x0.ifengimg.com/res/2020/F755D9972607B8B3835F9AFAE90326FFC3192725_size53_w1080_h721.jpeg"></p><p><strong>用人</strong></p><p><strong>主管的角色是什么？</strong></p><p>以前有句话，叫做“火车跑得快，全靠车头带”，这说的是前动车时代。动车和高铁为什么比传统的火车速度更快？根本原因是：大多数车厢都能提供动力。</p><p>同样的，如果一个团队完全靠主管来驱动，来提供动力，主管很容易成为团队的瓶颈。我的团队成员，很多都是自己领域的高手，专业能力在我之上，我就应该顺应实际情况，不要拿自己的愚见去束缚同学们的发挥。因此，我的角色更多的是眺望远方，掌握方向盘，有时踩一下刹车；团队大多数同学一起构成动力引擎。</p><p><img src="https://d.ifengimg.com/w200_h200_q90_webp/x0.ifengimg.com/res/2020/F37D3362395911C71A96302B60A98BDDEC4B2A65_size5_w200_h200.png"></p><p>图：动车&#x2F;高铁跑得快，是因为大多数车厢都提供动力</p><p><strong>对内管理模式</strong></p><p>一个不恰当的比喻：放羊。</p><p>这么做，堂而皇之的理由是“因为信任，所以简单”。技术层面的原因，对算法类同学做过程管理性价比太低。</p><p>算法类工作，创造性在其中占据重要地位，而创造性很难在过程中量化度量，也很难从外部观测现象来判断。比如：身边的同学坐在工位直视屏幕目不转睛，我不知道他到底是在思考论文中的公式还是在回味昨天晚上看的电影。再比如，我base在杭州，没办法知道团队内base北京的同学是不是在工作时间打游戏。</p><p>所以，我选择信任我的同学，只在一些必须监管的事项上把关，比如数据安全、安全生产等，其他事项一般不做过程管理，只做结果管理。得益于招聘时把关严格，绝大多数同学的自我驱动力都比较强，我并不用操心偷懒的事情；相反，偶尔需要操心一下少部分同学拼过了头的问题。关于这一点，更多的内容见彩蛋中的【认真生活，快乐工作】。</p><p>肯定有同学问：上面说的是不担心出工不出力，那么，怎么解释出力的问题呢？你难道不指导同学做项目吗？</p><p>我一般只给出项目的目标，有时给一个粗略的方案设想，有时不给。公司对于P6同学已经有“独当一面拿结果” 的要求，大家都应该具备独立作战的能力。而且，按照前面说的，团队内大部分同学都应该是提供动力的车厢，没必要依赖我。人是否有自我意志？这个问题我不知道答案。但我知道，如果一个人认为主意是自己想出来的，决定是自己做的，会更有动力去实现。尝试做决策，尝试完成不确定的任务，都有利于自己的成长。</p><p>思考题：管理有很多种style。有的主管喜欢自己做需求分析，然后拆解细化到原子级的技术问题，让下属做执行。这种模式，和“放羊”模式相比，从主管视角，以及下属视角看，各有什么优缺点？</p><p>综合以上两点，我觉得放羊是可行的。而且，放羊这件事，羊倌也是要做很多工作的：选择合适的天气，找到草地，把羊群带到草地，放哨保护羊群，是不是？如果还要把青草割好喂给羊吃，那成什么了？</p><p>羊倌应该把更多的精力花在寻找丰美的草地，购买强壮的羊，与其他羊倌交流这些事情上，要是成天忙于喂羊，督促偷懒的羊快点吃草，拉开打架的羊这些内部事务，羊群怎么发展壮大？</p><p>鼓舞团队信心，最好的方式是什么？</p><p><strong>痛痛快快地赢一次。如果不够，就两次。</strong></p><p>接手团队的时候，在商业化方向上局势是很差的：去年三次PK竞品都输了，稳定性问题频发以至于新版本都无法发布……团队好几个人都扑在这一个阵地上干得很苦但就是拿不到结果。</p><p>这个时候我要是去发表个类似《至暗时刻》里丘吉尔那样让人热血沸腾的演讲是否可以解决问题？可能有短暂的强心剂作用，但是不长久，因为实际困难没解决。何况，我也肯定不具备丘吉尔的演说能力。最有用的办法，还是分析失败的原因，制定正确的打法，指导同学们获得一次成功。鼓舞信心最好的方式还是靠实实在在的成功。</p><p>结果大家都看到了，今年我们PK竞品的战绩是N：0，付费调用量上涨25倍以上。大家肯定好奇：正确的打法是什么样的呢？我放在后面“正确地做事”那一节讲。</p><p><img src="https://d.ifengimg.com/w1080_h608_q90_webp/x0.ifengimg.com/res/2020/5FE8855BCD79B24F13B1EDEC95617E49ACC67197_size124_w1080_h608.jpeg"></p><p><strong>做有吸引力的事情</strong></p><p>目标要定得高一些，有挑战性，达成的时候内心的成就感会更高一些。这个很容易理解，就好比你打游戏，虐了个菜，没多少快感；如果能赢下之前屡战屡败的对手，一定会兴奋很久。</p><p>目标定得太低，不仅不能逼出自己的潜力，还容易让自己关注于一些鸡毛蒜皮的小问题。</p><p>前几天，我的主管在一个项目 kick off 会上说，当你回首往事时，要有一件做过的事情能够拿出来吹牛逼，人生才有意义。深以为然。</p><p><strong>过程即享受</strong></p><p>在阿里的工作肯定是辛苦的，我没看到过谁能随随便便就成功。如果只是冲着收入来做工作，难免在过程中会感觉到很多痛苦。物质的刺激是短暂的，不管是加薪、年终奖，或者 option ，兴奋高兴个几天就过去了。如果喜欢自己做的事情，专注于工作本身，从中源源不断地获得成就感，就能做到虽然辛苦但是不痛苦。我家做饭的阿姨是拆迁户，坐拥 N 套房，每天仍然跑几家做饭，我问她为什么？她说，以前是开苍蝇馆子的，拆迁后没得开了，但是自己就是喜欢做饭。理想状况下就是要招聘这种人。</p><p><strong>采取什么工作模式？——正确地做事</strong></p><p><strong>四个在线化</strong></p><p>互联网的本质是连接，最大价值也是连接。</p><p>这句话不知道是谁说的，第一次听说是在《计算机网络》课程上。互联网连接的可以是人和人，人和文档，人和数据，人和代码，人和……和一切你工作中需要的东西。</p><p>接手团队之后，我发现同学们的工作模式真的是自耕农一般：各做各的模型，各用各的数据，各读各的 paper ，完全是原子化的散点存在。说得不客气一点，除了聚餐的时候，平时感觉不到这是一个组织。也就是说，身处中国顶级互联网公司，大家却像农业社会时期一样在进行生产，当着不折不扣的“码农”。</p><p>团队里一个同学说得很好：相互间建立信任关系的最好办法是发生工作上的协同。我觉得，要发生工作上的协同，前提就是把工作相关的资源都在线化，与组织成员发生连接，于是，我设想做4个在线化。</p><p><img src="https://d.ifengimg.com/w1080_h386_q90_webp/x0.ifengimg.com/res/2020/26A39F0D08A994E69353776363FF7096D649E8D7_size27_w1080_h386.jpeg"></p><p>图：文档、数据、代码、评测在线化</p><p><strong>1、文档在线化：</strong> 春节期间我建了个团队语雀，自己做顶层设计，写好框架，然后让同学们把业务、技术、资源、技术影响力等等和工作相关的内容都填写其中。这样子，每个同学都可以看到团队的各种信息和资源，以及其他人的工作。目前团队的语雀还对部分关联紧密的兄弟团队完全开放。</p><p><strong>2、数据在线化：</strong> 如果同学们各自管理自己的数据，形成数据孤岛不说，发生机器重装，或者转岗、离职，往往数据就丢了。接手的时候，能清理出来的有标签数据远远低于应有的数量，就是因为一直没有做数据的在线化管理。团队里的言奇同学做了样本大表项目，已经完成了将整个智能认知团队的全面标签数据在线化。这一点非常重要，后续在开发各种新模型，以及做预训练模型时，就拥有不同业务不同场景不同风险的大量数据，在短时间内取得了良好的效果。</p><p><strong>3、代码在线化：</strong> 这个正在进行中，预期 S2 结束时完成，出发点是：</p><p>a.代码是团队重要的技术资产，应该统一管理，提高安全性。</p><p>b.在线化后方便团队协作，共享优秀代码</p><p>c.基础性模块代码统一，降低维护成本</p><p><strong>4、评测在线化：</strong> 也在进行中，设想是在一些特定任务上做几种经典模型和确认无误的主流模型，能够一键实现自己的模型和前者的自动化比对，提升工作效率。除此之外还有个作用：经典模型的结果可以作为baseline，帮助验证深度模型的正确性。因为，你做了一个深度模型，效果好也就罢了，效果不好的时候都搞不清楚是模型不适用，还是自己的代码写错了。</p><p><strong>找对前进的方向</strong></p><p>主管最重要的职责之一是当同学们迷茫的时候明确前进的方向。</p><p>接着前面商业化的例子，详细情况是这样的：我们通过阿里云对外输出文本风险识别的算法能力做商业化，比如涉政、色情低俗、广告、辱骂等。我接手的时候，有 3-4 个同学全职投入这项工作，他们工作非常努力，干得也很辛苦，但是效果并不好， PK 竞品的时候并无胜算。出了什么问题呢？</p><p>分析之后，我发现以下问题：</p><p>1、确实是一个内容维度的问题，但只使用了分类模型一种方式。</p><p>分类模型适合解决静态标准的问题，并不适合及时响应业务上的快速变化。模型迭代更新的速度做到极限也只能是 T+1 或者 T+2 天，且人力消耗高。之前的主管为了解决这个问题，在分类模型中塞了一个风险词包，由算法同学维护更新，接到运营反馈的 badcase 之后手动添加到风险词包，然后定时推送到分类模型应用中。这个复杂的机制带来了词典的频繁构建，结果导致应用的稳定性问题频发，甚至已经无法更新。</p><p>2、缺乏顶层设计，同学们各自为战。</p><p>几个风险各自单独做模型，技术选型高度自由，百花齐放，starspace、SVM、CRF、kenlm、textCNN 都有，难以统一提升能力，维护的难度大。</p><p>3、做了过多的个性化定制，导致后续维护和升级的成本非常高。</p><p>几乎为每一个稍微大一点的用户都单独做了模型，付费调用量不大，模型倒是有了好几十个。同学们频繁地做模型的迭代更新（每周都至少有 1-2 次），占用大量人力。</p><p><img src="https://d.ifengimg.com/w1080_h720_q90_webp/x0.ifengimg.com/res/2020/A02919B1B041935B06400F0A0D30DC46E44FA640_size62_w1080_h720.jpeg"></p><p>怎么办呢？</p><p>建设技术体系去解决某一类问题，而不是某个技术点去解决某一个问题；结合安全业务的特点，设计可以强化通用算法效果的基础能力或处理框架。</p><p>——上面两句话不是我说的，来源于前主管。（插一句：本文还有一些内容来源于前主管和主管，向主管学习是提升自己的一个重要途径。）</p><p><strong>具体来说，解法有几点：</strong></p><p>明确风险词包、相似性检索、分类模型、风险知识图谱 4种手段适合完成的任务，且相互配合。</p><p>把风险词包从分类模型中拆出来，降低应用的复杂度，以及模型迭代的频率，解决稳定性问题。</p><p>分类模型的结构尽可能统一，标准尽可能不变，持续把效果做强。</p><p>自从 BERT 提出以来，NLP 问题的基本范式从原来的 task-specific 的模型结构设计转变到语言模型 pretrain+ 下游任务 finetuning 的模式。工作重点应该转向预训练模型与知识蒸馏。</p><p>由于目前对内的内容交互风险管控业务也在我的团队内，我就贴一张全局视角的问题分析与解决方案。</p><p><img src="https://d.ifengimg.com/w1080_h625_q90_webp/x0.ifengimg.com/res/2020/594172351E03D9F3065388CE0FF76D0E434A075F_size71_w1080_h625.jpeg"></p><p>图：全局视角的UGC风险管控思路</p><p>明确解法之后，同学们快速做了实践，到 4 月份就基本扭转了被动的局面，随后打了翻身仗，付费调用量增长 25 倍。现在模型的更新周期降低到以月为周期，稳定性大幅度提升，同学们也不再疲于奔命；而且，投入的人力也明显下降了。</p><p><strong>绩效的考核</strong></p><p>绩效考核决定了收益的分配，也是团队最重要的事情之一。</p><p>如果把团队比作一个模型，考核的标准就是 loss function。loss function 一旦确定，模型的优化方向也就定了，团队成员会按照利益最大化原则沿着这个方向调整自己的 action 。</p><p>所以，考核标准的设计需要体现团队的定位、价值和需求；在执行的过程中需要满足平等性。</p><p><img src="https://d.ifengimg.com/w1080_h450_q90_webp/x0.ifengimg.com/res/2020/30BAD34EB2C3BE6434F48EFCFC98851DE23226BD_size43_w1080_h450.jpeg"></p><p>图：绩效考核的3个维度</p><p><strong>业务结果</strong></p><p>阿里有个文雅的说法是：为过程鼓掌，为结果付酬。</p><p>还有个话糙理不糙的说法是：没有过程的结果是垃圾，没有结果的过程是放屁。</p><p>你觉得哪一句对你的胃口就看哪一句。</p><p>配置在业务BU的算法团队，帮助业务目标达成肯定是首要任务。今年以来，AI 行业也都渐渐挤出泡沫，回归本质，开始强调创造业务价值了。</p><p><strong>能力进步</strong></p><p>从价值观上讲，今天的最好表现是明天的最低要求。</p><p>从业务需求讲，量级越来越大，业务形态越来越复杂，老算法是解决不了新问题的。</p><p>从团队利益讲，成员的能力进步可以扩展团队的能力雷达图。</p><p>参加百阿的时候，一位讲师的发言我到现在都记得：在座的各位最终都是要离开阿里的，离开的时候无非两种情况：1，公司不要你了；2，你不要公司了。怎么离开，取决于是你的能力提高快，还是公司对能力的要求提高快。</p><p><img src="https://d.ifengimg.com/w1080_h781_q90_webp/x0.ifengimg.com/res/2020/24800EE6598EACFA9390D8B550C4EE08E04B382A_size57_w1080_h781.jpeg"></p><p><strong>技术影响力</strong></p><p><strong>什么是技术影响力？</strong></p><p>有形物：Paper 、竞赛成绩、著作、专利、 ATA 文章等。</p><p>无形物：对内对外合作、对外 PR 、对内分享、组织机构任职、参会做报告等。</p><p><strong>为什么要建设技术影响力？</strong></p><p>团队的四项基本能力：连接、生产、传播、服务，其中“传播”就需要技术影响力。</p><p>CRO 线的使命“四心”中，有一条叫“让监管单位放心”。技术影响力是让监管放心的有效方式之一。</p><p>商业化需要资质：搞过投标的同学都知道。</p><p>招聘需要名气：对候选人讲解我们的技术水平时，如果用内部业务举例，不容易产生共鸣；但是如果直接亮出顶会论文、刷榜名次之类的，对方马上就懂了。</p><p>个人的市场价值需要证明：这些东西都可以作为个人技术品牌，到哪都能带着。</p><p>假定一个场景，有人问：“你说这个业务做得好，说明你的算法水平高。会不会换一个人能够做得更好？”你打算怎么回答这个问题？</p><p>再假定一个场景，你打算给自己团队的算法能力定性为“xx领先”或者“xx第一梯队”，如果没有硬核的技术影响力做支撑，是否还能理直气壮？</p><p><strong>平等性</strong></p><p>团队协作的基础是团结，团结的基础是平等。</p><p>平等性最重要的体现，就是在考核过程中尽可能只衡量以上三项，不去考虑地域、教育背景、从业经历、之前表现、颜值、性别、个人动向等等其他因素。我认为：结果体现的就是能力，直截了当，最能服众。</p><p>当然，这个世界上是否有完全客观的判断？或者，完全客观的判断如果存在，是不是就是最合适的？我不知道答案。不过，我觉得不能因为做不到完全的平等而放弃追求平等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计全攻略</title>
      <link href="/2019/12/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%A8%E6%94%BB%E7%95%A5/"/>
      <url>/2019/12/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%A8%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>正文开始前，先花大量笔墨推荐几个我工作中常用的思考框架、实践框架，后续文章中会使用这几种思考框架作为工具来描述、拆解、分析问题。当然你也可以使用到其它工作内容中，掌握几种利器，比无头苍蝇样做事效率会高很多。</p><h2 id="一-几个思考、实践框架"><a href="#一-几个思考、实践框架" class="headerlink" title="一. 几个思考、实践框架"></a>一. 几个思考、实践框架</h2><h3 id="1、目标驱动、可量测的行动框架"><a href="#1、目标驱动、可量测的行动框架" class="headerlink" title="1、目标驱动、可量测的行动框架"></a><strong>1、目标驱动、可量测的行动框架</strong></h3><p>OGSM 是 Objective（目的）、Goal（目标）、Strategy（策略）、Measurement（测量）的英文首字母组成。一种实践策略的手段，以达成理想的目的与目标。</p><p>学术界一个研究方向快速进展的关键，是清晰地定义了问题的目标函数。当年 Google 和雅虎的几位大师把广告清晰地定义为一个优化问题，这个领域的进展才日新月异。按照某前辈的话说，管理一个工程团队，只需要做好两件事：一是 <strong>定义好目标</strong>，二是建立一个 <strong>评测系统</strong>。 可见目标、可量测不是神秘职务，在各个领域都有案例。</p><p>当我们做事情时候，可以按照以下流程来实践：</p><ul><li><p>目的：明白领导意图。通常这个目的是领导层或上层给予执行层面、部门、团队的任务。通常比较含糊或者宏大，一方面不容易快速达到，另一方面这个目的，对于执行者来说，很不容易测量。</p></li><li><p>目标：当我们面临一项任务或目的时候，都会把目的拆分为 <strong>易执行</strong>、 <strong>可量测的小目标</strong>。 可以拆解成小目标、小任务，排优先、定重点、分配给下属、并制定 KPI 或 OKR 关键性指标。</p></li><li><p>策略：执行层面考究团队执行力，可以针对小目标或可量测指标，做很多 TIP 或工作策略。例如：写代码时，对代码的测试覆盖、结对编程、Code Review 等。具体到不同时期，有不同方法论，这里暂不展开。</p></li><li><p>量测：拆解的目标必须是可量测、可量化，有指标可以衡量任务是否完成、完成度等。如果特别特别放到量测指标，其实算过度 KPI， 对我们架构创造性事情，需要更深层次考虑。毕竟，软件不是富士康计件类型工作。</p></li><li><p>不断迭代：通过量测指标，不断调整执行策略，甚至调整拆解目标。小步快进，达成目的，良好的完成上游给予的任务。</p></li></ul><p>业内实践或很多书籍，从不同角度验证该工作方法的适用：</p><ul><li>很多运营方面，尤其是增长黑客、数字营销方面工作，特别强调数字指标设定、运营方法、迭代运营。比如：《增长黑客》中海盗模型转化漏斗，以及衍生出来一些列案例；《运营之光》提到的“优秀的运营要以目标为导向，主动行事。”</li><li>目标驱动、数字衡量的新型运营手段：大数据时代，数据带给决策更加丰富、准确的素材或理由。改变了企业运营、运作的传统方法。个人认为传统运营偏文科一些，需要更多活动策划、文案文字相关工作。而有些领域，如计算广告中，广告优化师，需要很强的数据能力。市面上运营两类书，一类一看就是文科写的，增加很多数据指标之类问题，不深入，但写的很好看。后一类一看理科生写的，很多数据模型，但是看得很头大。</li><li>测试先行的敏捷实践：当项目足够复杂的时候，想要保证尽可能的减少 Bug，有两种有效的方式分别是代码审核和测试先行。我们完成正式逻辑前，先编写测试用例，就是编写量测方法。</li><li>ABTest 的产品衡量手段：ABTest 在互联网公司广泛使用，并在各个领域发扬光大。比如：拆分用户，针对不同用户界面功能使用投票等。推荐系统中评估体系的建设。广告优化师，通过不断的调整素材、定向等优化投放姿势。甚至抖音这类 App，整体产品逻辑，就是“ABTest ”。</li><li>机器学习算法中，假设空间、优化目标、寻解算法三角中，优化目标的设计是为了设定衡量标准。可以说机器学习、深度学习背后的理论，跟测试用例编写是很像的。注：例子还可以很多，前面例子可以当成一个职业方向去学习研究，这里点到为止，也可以留言沟通交流。</li></ul><h3 id="2、互联网思维-迭代思维"><a href="#2、互联网思维-迭代思维" class="headerlink" title="2、互联网思维-迭代思维"></a><strong>2、互联网思维-迭代思维</strong></h3><p>“迭代思维”是互联网产品开发的典型方法论。“天下武功，唯快不破”，只有快速地对消费者需求做出反映，产品才更容易贴近消费者。这里暂且不说这个“快字”，按照我们传统思维方式，我已经足够了解产品需求了，我直接设计满足用户需求的产品不就可以了嘛？答案是否定的！</p><p>互联网产品是迭代而成的，（无数案例证实这点，这里不展开篇幅）！那么我们为这些产品设计的后台、前台、数据架构，也必定是迭代而成的！按照达尔文进化论来解释的话，物种是迭代进化而来的。人这个物种对外界的需求、诉求、主动变革，都在不停地迭代。那么软件产品、架构也肯定需要迭代。</p><p>产品生命周期理论如图1所示（PLC 模型）是由美国经济学家 Raymond Vernon 提出的，即一种新产品从开始进入市场到被市场淘汰的整个过程。用户、产品、人、事都存在生命周期。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20191228/3b00282cd1b0483493847748ebcf8e84.jpeg" alt="img"></p><p>图 1 PLC模型</p><p>从另一方面来看，我们看待用户、产品、人、事，绝对不能是静态思维，我们制定计划、制定目标时候，不可能是不变的。举个例子：笔者原来在北大方正工作，每年集团都会制定***战略目标，等落实到各个子公司、子部门时候，整体外部环境都已经改变，这些“战略目标”很可能不合适了，但是由于集团最大，也没法反驳。造成整个集团、公司 运转效率、努力方向、同业竞争都产生很大的问题。</p><p>这个问题摊开讲，会很复杂，回到软件架构这一领域，一定要明白架构是从简单合适，通过业务需求推进，再到复杂的演进过程。近一年挺火的中台概念，阿里需要中台，难道小创业公司也需要中台战略吗？不了解中台演进或推进中台的业务需求痛点，根本了解不了中台，更不可能架构好。</p><h3 id="3、5W1H-认识、分析一件事物时的思维方法"><a href="#3、5W1H-认识、分析一件事物时的思维方法" class="headerlink" title="3、5W1H-认识、分析一件事物时的思维方法"></a><strong>3、5W1H-认识、分析一件事物时的思维方法</strong></h3><p>IT 从业者要不断面临新的语言、新的技术、新的框架，如何才能快速学习、认知一门新技术呢？5W1H（WWWWWH）分析法也叫六何分析法，是一种思考方法，也可以说是一种创造技法。在企业管理、日常工作生活和学习中得到广泛的应用。</p><p>5W+1H：是对选定的项目、工序或操作，都要从原因（何因 Why）、对象（何事 What）、地点（何地 Where）、时间（何时 When）、人员（何人 Who）、方法（何法 How）等六个方面提出问题进行思考。</p><p><strong>实践案例：</strong></p><p>认识 Redis、认识微服务、认识 Docker、Kubernetes、认识机器学习、认识深度学习，让我们面临新的技术或概念时候，都会需要学习。我是怎么学习的呢？</p><p>以 Redis 为例，不一定强调内容全面或完全正确，主要体会思考学习方法：</p><ul><li>What： 基于内存实现的 K-V 存储系统； 内存数据库； NoSQL； 支持 sting、list、set、hashmap、zset 五种数据结构。</li><li>Why： 在分布式系统中，本地缓存不能满足需求。 分布式缓存系统，类似框架 Memacache、基于 SSD 低磁盘的成本分布式缓存系统。</li><li>Where：相当于使用场景。如果系统按照 App-&gt;Gateway-&gt;Service-&gt;Dao-&gt;持久层来分的话。Dao 与持久层（MySQL）之间使用，减少与持久化数据访问频率，提高 QPS；Service 层可以使用，例如：做一些业务缓存；Gateway 层，也可以把鉴权 token 放到 Redis 中。</li><li>When：性能、QPS需要提升时，缓存是第一时间想到的解决手段。当然 Redis 扩展出很多其它用法，例如：分布式锁、分布式优先队列、布隆过滤器、set 交集等较为高级用法。</li><li>Who：通常架构师、后端工程师使用。</li><li>How：API 查阅文档，看看例子就能明白。</li><li>类似比较学习：当我们认识新事物时候，类比法也是特别好的使用方法。假如我么使用过本地缓存 Ehcache、Guava，再去学习 Redis 会简单很多。</li></ul><p>近几年我很少看源码，不是源码不重要，而是你了解了初衷后，对框架本身兴趣点会降低，而会思考生态，思考思维路径。摘录一段如下，期望有启发：</p><blockquote><p>建议大家观看一个视频，伟大领袖如何激励行动 TED 演讲：伟大的领袖如何激励行动_腾讯视频 ；里面提到一个非常有意思的认知“三环”,绝大多数人是由外而内（What&#x3D;&gt;How&#x3D;&gt;why），但伟大的公司或领导者，思考的路径通常是由内而外（why&#x3D;&gt;How&#x3D;&gt;what），团队或者客户认可的常常是你的理念&#x2F;信念即“为什么”，从而愿意接受你的产品或服务。</p></blockquote><h3 id="4、多元视角看问题"><a href="#4、多元视角看问题" class="headerlink" title="4、多元视角看问题"></a><strong>4、多元视角看问题</strong></h3><p>著名的大文豪苏轼的《题西林壁》</p><blockquote><p>横看成岭侧成峰，远近高低各不同。</p></blockquote><blockquote><p>不识庐山真面目，只缘身在此山中。</p></blockquote><p>猎豹 CEO 傅盛曾说：</p><blockquote><p>一个创业者想要成功，首先要用多种视角看事情。</p></blockquote><blockquote></blockquote><blockquote><p>在看待问题时候，既将自己深入其中，能敏锐感受内里变化；抽身其外，又能让自己变成一个旁观者，观察很多事情的发生和结果。</p></blockquote><blockquote></blockquote><p>如果看问题的视角只有一种，即从自己出发的视角，我们看到的世界就会过于局限。笔者传统 i 行业转型互联网创业过程中，对这点深有体会。以前都是站在技术角度看问题或个人视角看问题，根本不会站在用户角度思考。</p><blockquote><p>“微信之父”张小龙就曾说，乔布斯最厉害的地方是什么？“乔布斯最厉害的地方是他 1 秒钟就能变成傻瓜，而马化腾大概需要 5 秒钟，而我差不多需要 10 秒钟。”</p></blockquote><blockquote><p>所以，更重要的是思维观念上的通达，越聪明的人越可以“大道至简”</p></blockquote><blockquote><p>周鸿祎喜欢用“一分钟变小白”来作为评价产品经理能力的一个要素。而张小龙，据传私下里说过“我可以在五分钟内变成小白，而马化腾立即就可以”这样的话。无论真假，可以看出“变小白”这种能力在这几位产品大拿眼里是极其重要的，以至于变小白的时间的长短决定了产品能力的段位。</p></blockquote><blockquote></blockquote><blockquote><p>这三位所说的“变小白”，其实是“变用户”，也就是从“产品设计人员”或“产品经理”的角色切换为“用户”角色。只不过由于这三位所掌控的产品面向的用户以“小白”为主，所以有了“变小白”一说。</p></blockquote><p>一个人有足够的视角或多维视角观察能力，总是能认清楚要解决的问题，找准目标、确定方向，执行上如何错误，至少是在进步。如果不能全面的掌握问题，使劲的方向都不对，可能会事半功倍。</p><p>前几天跟群里几个同学聊起中台，有的同学拿起微服务说事，有的拿起标准说事，有的说是什么新的框架技术，有的转发了微信的几篇中台文章，我感觉都不是全面或准备。为什么，因为视角不对，中台战略最终受益者是谁呢？我觉得站在最终受益者（用户）视角考虑整个问题可能会全面些！</p><blockquote><p>据说连马云都带人去北欧 Supercell 学习所谓的“大中台架构”，据此调整阿里巴巴的组织结构，以 <strong>避免了大公司常见的部门与部门争夺资源</strong>，不同的小组做同样的事情。</p></blockquote><p>如果以上为真的话，按照 OGSM 框架分析一下。马教主为了避免“大公司常见的部门与部门争夺资源，不同的小组做同样的事情” ，提出大中台架构的目的。各个执行部门针对教主提出的目的，制定自己职权内的目的、目标。技术部门或事业群接收到任务不同，拆分出业务中台、数据中台的概念。我们换个视角思考， 公司的组织结构需要调整吗？考核标准需要调整？奖金激励手段需要调整吗？权利责任各个组织结构节点变了吗？个人在创业公司，这辈子有可能不会做中台相关工作，理解不深，展开也说不清楚（憨笑）。如果我们理解一个新的概念时候，可以换多个视角或提升视角，站在更高的角度看这个问题，可能会更加全面，那么处理手头面临的问题时，会很容易。</p><p><strong>分享几个视角：</strong></p><p><strong>宇宙视角：</strong>宇宙视角能将我们禁锢已久的国与国、区域与区域、地区与地区、公司与公司、个人与个人的界限彻底打破，从而带给我们更为广博的胸怀以及更加宽阔的视野。 说白了，自己能跳出利益，看清楚利益相关方的嘴脸，灵魂附体后再争取利益时，会更有优势（汗一下自己）。</p><p><strong>利益相关方视角：</strong>做商业产品或撮合交易系统，尤其需要有这方面能力。当然要站在不同利益相关方看问题，需要有同理心、换位思考等等更方面的训练。可以看一些产品方面的书籍。</p><p><strong>用户视角：</strong>产品经理需要经常用用户视角来思考。当我们做系统、架构时，必须了解是谁使用它。可以确定的是，肯定不是自己使用，所以切勿以自我为中心的思考、设计等。</p><p><strong>时间线视角：</strong></p><ul><li>你可以让自己退后一步，离开正在进行的一切，站在时间线的后面，注视它，感受它。 眼前这根时间线代表的正是你的一生，它像是一条不断奔涌向前的河，不论你是否正在其中，还是已经退后一步，它的奔涌都从不止息。</li><li>你也可以试着站在未来某一时点上看问题，它能让我们从此时此刻的纠结中抽离出去，站到更远一点的地方回望。</li><li>当我们不知道自己真正想要什么、真正在乎什么的时候，可以尝试时间线临终视角。 它能帮我们滤尽铅华，看清内心真实渴望，甚至是我们的核心价值观。</li></ul><h2 id="二-这些模型如何在架构设计中使用？"><a href="#二-这些模型如何在架构设计中使用？" class="headerlink" title="二. 这些模型如何在架构设计中使用？"></a><strong>二. 这些模型如何在架构设计中使用？</strong></h2><p><strong>第一、</strong> 使用目标驱动的行动框架。 明确我们要去哪里？知道架构设计的目的、阶段性目标， 才能有针对性的少走弯路。</p><p><strong>第二、</strong> 我们怎么才能知道我们现在在哪？ 明白评价架构、系统的常见评价体系，才能针对目标，一步一个台阶的走下去。评价指标通常是与数据相关的，但是容易评估的目的，往往是简单容易实现或案例很多的。</p><p><strong>第三、</strong> 无论我们面对的需求或目标多么高大，路要一步一步走，饭要一口一口吃。 零零散散各个目标指标，只能有侧重、有优先不断迭代、夯实、拔高的达到目标。</p><p><strong>第四、</strong> 如何理解大厂、书籍、国外传播的最佳实践呢？ 我们需要明白，任何最佳都是迭代出来的，而不是一蹴而就的。</p><p><strong>第五、</strong> 针对架构设计目的，常用的有哪些手段呢？ 我们如何建立自己的武器库，常见的解决问题的手段呢，通过 5W1H 来了解梳理。</p><p><strong>第六、</strong> 架构师岗位是与其他岗位高度协同的岗位，了解业务、了解其它岗位、协同人职责视角很重要。 多元视角不光可以让自己更深刻理解架构本身，还可以了解业务、了解场景，更有效的协同工作。</p><p>注：文章只是抛砖引玉，笔者也是在其它岗位的一些经验，反哺总结到架构岗位上。不一定正确，适合自己的才是最好的。</p><h2 id="三-架构定义"><a href="#三-架构定义" class="headerlink" title="三. 架构定义"></a><strong>三. 架构定义</strong></h2><p>软件架构（Software Architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。其实我们把架构当成一个技能、工种、职位、岗位，<strong>核心还是为了应对软件设计、构建中的复杂度，降低成本、提升效率。</strong></p><p>对我们常见系统做一下分类。如果按照行业分，篇幅不够、积累也少，无法全面分类。这里尝试按照时间线分类，后面阅读会更加顺畅一些。</p><p><strong>事中业务</strong></p><p>常见的业务系统。如：电商、交易系统等等大多属于这类。实际业务中，对业务反馈需要越实时，实现难度相对越高，比如：共享单车APP、股票交易等，需要实时的提示、预警、交互。除了传统型业务型架构外，对大数据流计算架构要求逐步提高。</p><p><strong>事后业务</strong></p><p>事后肯定有数据沉淀，有数据肯定可以对未来决策做指导。自然而然查询统计、报表决策、数据挖掘、事后总结等数据应用类系统。</p><p><strong>事前业务</strong></p><p>事前基本为业务预测、分类、推荐、决策辅助灯业务。随着机器学习、深度学习的火热，这部分应用越来越广泛。例如：量化投资、广告点击率预测、短视频推荐、电商推荐等。</p><p><strong>趋势</strong></p><p>人类欲望膨胀，业务需求无止境，从而推进技术、架构发展。人工智能、流计算、大数据发展，离线&#x2F;在线、事后&#x2F;事前&#x2F;事中、人工决策&#x2F;机器预测 等界限已经很模糊。也是我个人认为的技术方向， 大数据、流计算、推荐系统、广告系统。（机器学习、深度学习等业务系统）。</p><h2 id="四-架构目的有哪些？"><a href="#四-架构目的有哪些？" class="headerlink" title="四. 架构目的有哪些？"></a><strong>四. 架构目的有哪些？</strong></h2><p>架构的目的其实每个架构师、程序员都很清楚，或日常工作中自然而然都会面对。但是我们很容易迷失自我。如果你是个架构师，现在闭上眼睛，回想三十秒，想想当天工作内容的解决了什么问题？达成什么目的？晚上加餐学习内容的目的是什么？是在熬时间等工资？是在踢皮球推卸责任？还是为了少干点活？还是学习新的知识为了提升个人价值，升职跳槽？</p><p>面试时，面试官通常会从项目经验中考察以下几点：<strong>业务复杂引起的复杂度</strong>、 <strong>数据量引起的复杂度</strong>、 <strong>用户数引起的复杂度</strong>。 比如，做过什么项目，是否了解电商交易系统？你们用户数有多少，峰值 QPS 多少？你们一天产生多少数据？如何存储处理等？</p><p>面临架构设计 Case 时候，无论是架构升级、还是构建架构地基，主要目的肯定只有一到两个。比如：用户规模扩大，原有架构在并发、性能上无法容忍；又如：业务快速发展，7*24 小时运转下，升级迭代新功能太麻烦， 是否可以考虑微服务架构等。</p><p>如果从客观来说，架构需求肯定包含在以下需求之列：<strong>高并发、高性能、高可用、安全性、规模扩展性、规模成本</strong>。 书籍、网上都是这样说的，因为这样说都没错。</p><p>小节：基本很多书上、文章都有讲解，下面来点很少地方能看到的知识点！就算我们设计的架构，都能满足需求，达到目的，算合格的架构吗？答案是不算！为啥，回到前面 OGSM， 能够明确量测方式、可量化任务的目的、目标，其实都不是难事。我们做很多事情时，尤其是探索性架构师，可量测性其实是很模糊的。<strong>举个例子：****当初 MapReduce 框架刚出来时，谁有说它慢呢？是否直到 Spark 在更短时间完成相同任务，才发现 MapReduce 框架如此之慢！</strong></p><p><strong>所以是否有个结论，可量测方法、量化指标都是在实践后的结果</strong>。 当然，不是说目标的评测不重要，对于初学者肯定是重要的， 但是用这些评价架构或评判事物，可能陷入自欺欺人的境地。</p><h2 id="五-如何评测这些目标？"><a href="#五-如何评测这些目标？" class="headerlink" title="五. 如何评测这些目标？"></a><strong>五. 如何评测这些目标？</strong></h2><p>SLA 服务等级协议(Service-Level Agreement)，指的是系统服务提供者（Provider）对客户（Customer）的一个服务承诺。这是衡量一个大型分布式系统是否“健康”的常见方法。SLA 设定一些指标，来考核、衡量系统。</p><p><strong>1. 系统可用性：</strong>也就是常说的 4 个 9、5 个 9 指标。</p><p><strong>2. 准确性或错误率：</strong>可以简单理解为 错误请求数&#x2F;全部请求数&#x3D;错误率。</p><p><strong>3. 系统容量&#x2F;吞吐量&#x2F;预期负载：</strong>也就是常说的 QPS&#x2F;TPS 等， 每秒可处理的查询数或事务数。</p><p><strong>4. 延迟或 RT 等：</strong>系统响应时间。</p><p>注：关于这部分概念，上网查询即可，不展开描述。</p><p>当系统架构在不停迭代的时候，有了一个明确的 SLA，我们可以知道下一个版本架构的改进目标以及优化好的系统架构是否比上一代的系统 SLA 更加优秀。当然评测系统还有很多其它指标，比如：可扩展性，随着云计算的发展，硬件层面扩展性基本不用考虑，我们通常考虑业务需求的扩展性即可， 但这个需求、业务扩展往往无法衡量，而架构师又容易过渡设计，是个考验架构师火候的指标之一。还比如分布式系统数据一致性、持久性、数据可靠性能，这里不展开阐述。</p><p>当架构搭建基础较好的时候，这些指标其实比较容易提升。从另外一方面说，真正架构难度，不是业务架构，而是 <strong>支撑核心业务稳定运行的点点滴滴</strong>，以微服务为例来看：</p><ul><li>冗余部署是提高系统可用性唯一法宝。服务的冗余部署，是为了提升系统可用性。另外使用微服务架构，有个很重要目标，就是要无感知升级系统模块。汽车的备用轮胎也可以提升汽车可用性，但汽车爆胎后，需要换轮胎的时间，这个可用级别上不去。而微服务，把功能拆分成小服务，可以通过技术手段，无感知的升级。</li><li>服务治理都会包含服务监测、预警功能。当服务错误率达到一定阈值， 很可以报警或开启限流、服务降级、熔断等策略，把影响降低到最小。</li><li>微服务架构中，通常会在在 Gateway 层，甚至 Service、Dao 层 设置限流措施。当流量大于预期时，开启防御手段。也有一些弹性扩容的设定，当流量大于阈值时，自动扩展服务，应对突发流量，这个过程甚至不用人工参与。</li><li>系统延迟或相应时间，也会在服务监测平台设置相应指标，超过阈值时，启动相关服务降级、限流、熔断等策略。</li></ul><p>注：个人理解，其实微服务、Kubernetes 等，很大一部分功能都是为了应对 SLA 的智能化扩展。</p><h2 id="六-架构设计常用手段"><a href="#六-架构设计常用手段" class="headerlink" title="六. 架构设计常用手段"></a><strong>六. 架构设计常用手段</strong></h2><p>相信大多数人都认同，与其说架构是设计出来的， <strong>不如是说抄袭或拼装而成的</strong>。 所以我们需要熟悉常用的手段或成熟的框架来解决日常工作中的问题。每个架构师工作经历不同、应对过的业务系统不同、兴趣点不同，手头的弹药库也不同。我列举一些自己认为重要的知识点或框架。（前端太久没接触，只列举后端，大多以微服务为例，后续文章有机会展开探讨）</p><p>业务处理相关技术点和框架</p><p><strong>单机：****高性能、高并发手段相关</strong></p><p><strong>1. 单机高性能手段：</strong> 可以上网查询 C10K 问题，获取相关文章。 把进程、线程、池、IO 多路复用相关知识点弄清楚。</p><p><strong>2. 分清楚 IO 密集型和 CPU 密集型场景：</strong> 一般互联网应用多为 IO 密集型。 但是类似：滴滴出行、股市量化投资、在线游戏之类，属于 IO 密集型和 CPU 密集型并存的场景，甚至对响应时间要求也很高。幸好大多数 CPU 密集型应用也是多租户、区域独立性架构，容易扩展拆分。</p><p><strong>3. 程序访问存储介质或链路快慢：</strong> 程序肯定要与存储进行消息交换。 一定明白，CPU 高速存储器、内存、SSD 硬盘、机械硬盘、同交换机网络、同机房网络、同城网络、同运营商网络等。细节展开很多内容，包含缓存、CDN、多机房等，从细节编程到部署架构的知识点。</p><p><strong>集群：****高性能、高并发相关</strong></p><p><strong>1. 负载均衡反向代理：</strong> 其实把 Nginx 了解就可以了。 如果是初创小公司，基本使用云上 SLB 负载均衡(Server LoadBalancer)就可以， 如果需要自建机房，有专门运维负责这些工作，到时候补补 LVS、F5 相关技术即可。</p><p><strong>2. 服务无状态：</strong> 以微服务为例来说，服务无状态会带来太多的好处，扩展冗余部署服务会很方便。 不谈微服务，就说前后端分离，鉴权这块 token 的实现，其实根本目的也是把用户状态剥离出来，实现服务的无状态化。（提个小插曲，估计老人才了解 J2EE EJB 规范，当初居然专门设计了一个 sessionBean 有状态的服务规范）。</p><p><strong>3. 任务（服务）拆分：</strong> 可以理解为服务拆解、功能拆解。 其实拆分准则很多，可以按照实际需求来权衡。比如：按照人头分、按照功能划分、按照数据库表划分、按照功能重要性划分、按照功能访问频度划分。不过，水平按照 Gateway、逻辑层、数据层、存储层算基本规范了。</p><p><strong>4. 常用的语言及框架：</strong> 了解语言特性，如 Node 语言的快速开发、前后端语言一致带来的便利、多路复用回调的原生支持等； go 语言 “goroutines”特性带来的编程便利；Java 优秀的生态及开源框架；C++性能优势等。当然技术选型，跟团队及业务成熟度很大关系。</p><p><strong>5. 缓存：</strong> 分布式缓存是提升系统性能利器。基本掌握 Redis 即可，需要知晓 Codis 和 Redis 官方集群部署方式。</p><p><strong>6. 消息队列：</strong> 消息队列也是常用提升系统性能利器，如业务逻辑异步化、削峰、解耦等。 熟悉 Kafka、RocketMQ即可。</p><p><strong>高可用手段（集群）：</strong></p><p>高可用手段核心解决思路是冗余部署，同样的服务冗余多份，会带来服务出错通知、服务自动切换、容错等一系列问题。高可用的实现更有技术含量，现在微服务框架服务治理组件，很多在高可用上做创新突破。（高性能冗余部署为了扩展节点，带来更高的处理性能）</p><p><strong>1. 服务无状态：</strong> 当某个服务故障时，自动切换到新的服务，不用产生状态丢失等问题。</p><p><strong>2. 调用方支持超时、重试配置：</strong>由于网络抖动等原因，某个服务可能某次调用不可用，调用方需要重试重新调用。 当然超时是调用方通用遇到的故障之一，也会有在其它故障发生，然后发起重试的配置。</p><p><strong>3. 被调用方需要幂等支持：</strong> 显而易见，无论是重试、还是调用方自动切换到的新的服务， 被调用方服务幂等支持的必备的。</p><p><strong>4. 服务状态监测：</strong> 所有服务都可用，那是理想情况。 当某个服务发生故障时，整个体系必须知道这个服务有问题了，重试调用多少次也不会成功了。按照微服务框架来说，需要两方知道这个信息：1、服务注册组件。2、服务上游调用方。当然报警让运维技术恢复是常规。</p><p><strong>5. 服务状态通知：</strong> 按照微服务架构，服务的状态 在注册中心都会体现。 但是注册中心跟服务之间一般是通过心跳来检测的，有时间延时。另外，服务调用方会缓存注册中心数据，其中就包含服务状态。所以说，从注册中心获取服务状态，是有延时，可能会造成很多无效的请求。高效的服务状态机制，很难组件化框架化， 所以这块需要高性能、较实时的自研通信机制或高性能集中存储机制保证。具体可以留言讨论或后续文章探讨。</p><p><strong>6. 调用方智能路由：</strong> 除了负载均衡以外，当调用方 A1 知晓下游服务 C1 故障后，可以自动切换到 C2 等服务上。 另外，通过服务状态通知机制，最好可以告诉 A2、A3，C1 服务故障了，你们别去尝试了。</p><p><strong>7. 服务故障恢复有，状态通知机制：</strong> 这部分就比较简单了。 注册中心状态变化后，调用方会慢慢更新注册中心元数据，来获取最新状态。当时，如果有更实时的消息机制，时效性会更高。</p><p>系统可靠性（牺牲少部分可容忍体验，降低问题到最低）</p><p><strong>8. 服务（功能）分类</strong>： 不管是微服务框架也好，单体框架也好，架构师必须对功能、服务进行分类。分类维度很多，比如：重要程度、QPS 量级、是否可以降级停止等等。</p><p><strong>9. 应用限流：</strong> 对于一般规模的应用，在 Gateway 层做即可，从源头保护整个应用。 对于超大应用（个人没经验），我觉得架构会更加复杂，可能 Gateway 会分为很多层或多个，甚至有业务中台，层次会更复杂。</p><p><strong>10. 服务降级：</strong> 服务是在服务分类的基础上的。 比如：百度贴吧的发帖功能，信息流广告功能，紧急情况下是可以降级处理的。可以人工或自动执行。其实 限流也是一种特殊的服务降级。（服务可以是个功能、也可以是接口，就看团队内如何达成一致）</p><p><strong>11.</strong> <strong>接口熔断：</strong> 熔断一般在接口方法级别，因为调用链路很长，容易引起调用雪崩。 让某个接口方法出现问题，我们可以按照预定配置处理业务，快速返回预设结果，防止整个链路的奔溃。</p><p><strong>12. 弹性扩容：</strong> 弹性扩容是理想的智能运维，但是具体操作也做大厂才会做相关工作。 例如新年红包业务，双十一电商业务，秒杀业务，明星结婚对新浪微博的影响等，这些可以预知或未知的突发流量，如果系统可以自动扩容，那将很是完美。其实很多当前 Docker + kubernetes 的使用案例，还只是方便运维工作量，对弹性扩容这块实践感觉不是很好。</p><p><strong>存储相关：</strong></p><p><strong>1. 关系型数据库：</strong> 传统的 MySQL 数据需要掌握。 如果做互联网业务，对分库分表肯定有需求，关注 NewSQL，如 TiDB，可以避免分库分表的麻烦。</p><p><strong>2. NoSQL 存储：</strong> Elasticsearch、MongoDB至少掌握一个。 笔者对 Elasticsearch 还是比较看好，综合性 文档数据、列式存储、反向索引 都支持，社区生态也很不错。</p><p><strong>3. 大数据数据库：</strong> 强烈建议熟悉 HDFS + HBase + openTSDB。 如果熟悉时序数据库 openTSDB 设计以后，对了解各个监控系统如 OpenFalcon 有很大的帮助。基本自研监控系统也难度不是特别大了。</p><p><strong>4. 内存数据库：</strong> 有些特殊应用使用内存数据会事半功倍。 Redis 提供丰富的数据结构及良好特性，并且有很多插件，巧妙使用可以降低业务代码复杂度。</p><p><strong>5. 消息队列：</strong> 消息队列也有存储机制，使用得当，也可以当成存储介质使用。 例如：kappa 架构、RocketMQ 事务消息支持等。</p><p>注：存储相关其实只是中间件的学习，自研或改造几率机会还是比较少。</p><p><strong>最佳实践：</strong></p><p>笔者强烈建议架构师研究商业化广告系统的架构，有心得也可以与我交流。广告系统涵盖知识点很多，如：高并发、高性能的广告引擎；倒排索引的广告定向召回；流计算计费系统；批处理反作弊大数据处理系统；大数据DMP用户设备画像系统；点击率预测机器学习、深度学习方向；adx + ssp + dsp 之间跨公司、跨系统间通信调用；频次控制等需要的缓存系统设计；交易相关资金方面的处理等等。</p><h2 id="七-提升认知"><a href="#七-提升认知" class="headerlink" title="七. 提升认知"></a><strong>七. 提升认知</strong></h2><p>每个架构师都梦想架构世界，设计未来。可惜当你真正有能力或有义务为社会做点贡献时候，往往忘了初心或体力有限。所以年轻时候，精力充沛时候，往往经验能力有限，年轻时候过度设计都会经历，为了可扩展性、可重用、预防需求变更做这样那样的设计。前文互联网思维-迭代思维中也讲到，世事万物都是在变化的。无论我们如何封装变化、兼容变化，都有个刻度。变化始终要面对，一劳永逸是不可能的， 好的设计模式本身就是封装变化、应对变化的最佳实践。</p><p>笔者在多元视角看问题章节也提到过，学会用时间线眼光看待问题。这里很是适用，刻意练习自己多元视角思维，可能会找到事物发展的趋势或固有轨迹。如果你能够把我企业内部、业内流行架构趋势，或推动架构演进的企业内部业务发展趋势， 做架构方面取舍时，可能会有更加全面的考虑，从而设计出扩展性更好的架构。</p><p>注：当然，做任何事情也是如此，顺势而为。</p><h2 id="八-THIS-IS-NOT-THE-END"><a href="#八-THIS-IS-NOT-THE-END" class="headerlink" title="八. THIS IS NOT THE END"></a><strong>八. THIS IS NOT THE END</strong></h2><p>《道生一，一生二，二生三，三生万物》出自老子的《道德经》第四十二章，是老子的宇宙生成论。这里老子说到“一”、“二”、“三”，乃是指“道”创生万物的过程。主要讲述了一、二、三这几个数字，并不把一、二、三看作具体的事物和具体数量。它们只是表示“道”生万物从少到多，从简单到复杂的一个过程。</p><p><strong>我们对任何事物的认知，尤其用文字表达出来，都是“一”、“二”、“三”这几个数字，而它们不代表具体事物和数量，就和这篇文章一样，只是思考的开始或过程，无法代表特定结论。</strong></p><p>作者介绍：张凯江，低调的骨灰级架构师。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>张勇：经营的核心是突破，管理的核心是效率</title>
      <link href="/2019/12/28/%E6%9D%82%E8%AE%B0/%E5%BC%A0%E5%8B%87%EF%BC%9A%E7%BB%8F%E8%90%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E7%AA%81%E7%A0%B4%EF%BC%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E6%95%88%E7%8E%87/"/>
      <url>/2019/12/28/%E6%9D%82%E8%AE%B0/%E5%BC%A0%E5%8B%87%EF%BC%9A%E7%BB%8F%E8%90%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E7%AA%81%E7%A0%B4%EF%BC%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p><strong>张勇 | 作者</strong></p><p><strong>虎嗅APP(ID:huxiu_com) | 来源</strong></p><p>2019年12月17日，阿里巴巴集团董事局主席兼首席执行官张勇和湖畔大学第四期学员进行了最新年度分享。今年年初，他曾经提出，商业设计和组织设计是企业一号位不可推卸的两大责任。最新分享中，他对于聚焦客户价值选择赛道、纵横分合的组织设计、让不确定性不同意见变为确定性的一致意见、领导者如何“落子无悔”等进行了更全面深入的延展和阐释。</p><p><strong>以下是核心观点：</strong></p><blockquote><p>第一天就想做平台的人，基本上都没做成。</p><p>选赛道通常两种方式：一种是垂直整合，另一种是水平延展。</p><p>所谓“落子无悔”，有些决定别人不可能替你做，只有一号位责无旁贷。 </p><p>企图通过共创会解决企业战略发展问题的，是领导者无能的表现。</p><p>以解决信息不对称性而创造的业务，未来终将消失。</p><p>市场是动态的，要在动态中防止焦虑，保持战略定力。地球是圆的，往东坚持到最后，只要你还活着，就是往西。</p><p>最大的确定性就是不确定性，真正的业务一号位，一定是在高度的不确定性当中去寻找确定性。</p><p>要把能努力的都努力好之后，最终等待命运垂青。</p><p>领导者不是万能的，领导者注定孤独。面向未来，不仅要看未来的机会，同时也看未来的问题。</p><p>当一个机会变成广泛共识的时候，是最需要小心的时候。绝望当中都是机会，冲动当中都是陷阱。</p><p>绝大多数的协同问题都不是态度问题，而是生产关系没设计到位。</p><p>要在一个扭曲的生产关系下，希望大家一起合作，本身就违反人性。</p><p>中台是沉淀出来的，不是从底下长起来的，底下长不起来中台。</p><p>经营核心是突破，管理核心是效率。经营和管理永远是“科学+艺术”。留白是一种艺术，必须给客观世界留一些空间。</p><p>有时候要付出一些代价，针对不确定性的不同意见，就会变成确定性的一致意见。</p><p>做取舍的过程，就是建立信用和消费信用的过程。</p><p>老板是封的，是任命的，老大是发自团队内心的。</p><p>领导者就是要敢做别人不敢做的决定；承担不能让团队承担，团队也承担不起的责任；搞定团队搞定不了的资源。</p></blockquote><p><strong>以下是张勇演讲全文：</strong></p><h3 id="1、第一天想做平台的人，基本上都没做成"><a href="#1、第一天想做平台的人，基本上都没做成" class="headerlink" title="1、第一天想做平台的人，基本上都没做成"></a>1、第一天想做平台的人，基本上都没做成</h3><p>首先要考虑客户是谁，你能为他们带来什么价值。这是定义一个新业务时非常要考虑的问题。定义得越具体，业务落地就越顺畅，不然客户画像都不清楚，就很难讨论问题。做平台做久了，反而容易迷失自己，忘掉初心。第一天想做平台的人，基本上都没做成。</p><p>讨论商业设计，无非考虑三个方面，才能真正为企业选好赛道——</p><p>(1)必须聚焦客户价值，同时看客户价值的普适性有多广。这是最关键的问题。一旦入了行，一旦企业定了赛道，一旦开足马力往前走之后，很难换赛道。至少在一个周期里边，做汽车的就做汽车，做装修的就做装修，做教育的就做教育，做环保的就做环保，慢慢它有演化的可能性，但首先要明确主业，主业的客户有多广，取决于你在解决多少人的问题，背后就有多少市场潜力。</p><p>(2)讨论客户是谁的时候，既要明确客户是谁，又要明确能提供的服务和价值是什么，以及对客户覆盖的范围是不是够广。马老师那句名言讲过多次：痛点越大，机会越大。商业设计里找赛道，首先要对痛点进行深度挖掘和研究，换句话说，痛点够不够痛？如果只是表象的痛，解决门槛也会很低，给客户建立不了什么核心价值。紧接着思考这些痛点是不是有普遍性，有没有足够多的人有这样的痛苦？我能不能解决他的问题？这是商业设计的关键之关键。</p><p>(3)除了要看我和我的团队能不能找到不一样的方式去解决客户问题——或者用技术变革，或者用商业变革，或者两者结合——还要看市场上还有没有别人能解决客户同样的痛点，如果有同样的人在解决，或者人家已经解决了一部分，甚至解决得很好了，再去做这件事情意义不大。说白了，是不是有足够的市场优势。哪怕你的商业规划、业务策略的PPT发得满世界都是，别人虽然都听明白了，但不能做。这就是足够的市场优势。</p><p>选赛道通常两种方式：</p><p>一种是垂直整合，上下游产业链打通。做了一点，然后做上游和供应链做到生产资料，下游做到市场终端；</p><p>另一种是水平延展。一个省做完做下一个省，一个国家市场做完做下一个国家的市场。这些都是关键节点的重大选择，这些选择基本上决定了企业的命运。</p><p>比如阿里把员工派去东南亚，这典型是全球化水平延展的做法。你要考虑一些中国员工到东南亚去，他的个体命运就被改变了，他的生活方式、小孩读书，甚至个人发展都改变了。这样的决定团队是没法做的。</p><p>所谓“落子无悔”，一定是作为负责人的首要责任，“此时此刻、非我莫属”。别人不可能替你做，只有一号位责无旁贷。 过程之中，要在动态中保持战略定力。市场是动态的，这就是为什么不仅要看自己，也要看市场中老的新的各种角色，大家在做什么动作，发生什么变化，这些变化也一定会影响到我们自己的判断，影响我们对赛道的选择，影响我们的商业设计。</p><p>可能性格使然。在阿里内部我强调比较多的，就是防止焦虑，保持战略定力。选赛道也好，定义客户痛点也好，寻找客户规模也好，所有这些问题其实不是静态，而是一个动态变化、不断演进的过程。这个过程当中，整个世界也在动态演变，每天都在发生很多事情，这个市场上不只你一个人在玩，别人也在玩。如何避免受到市场因素的干扰或影响？怎么能够真正找到属于你的独特的东西？特别重要的是战略定力。</p><p>我跟我们团队三天两头敲警钟，当业务找不到战略方向、彷徨、要讨论未来突破点或竞争等各种问题的时候，千万不要希望以共创会的形式解决问题。共创会不是来解决战略问题的，共创会是咱们不认识，坐下来谈谈前世今生，我以前干过啥、我的经历、性格是什么，是让人能够产生连接。 </p><p>我原话说得更极端——企图通过共创会解决企业战略发展问题的，是团队一号位无能的表现。如果一号位都想不清楚往哪走，怎么打，怎么选择赛道，怎么定义用户价值，怎么设计商业模式，而想要团队坐下来共创，忆苦思甜，讨论一下前世今生，基本上聊的时候很爽，但是冷静下来什么也没发生。大家宣泄了情绪，没有解决实际问题。</p><p>实际问题的解决，是靠冷静的思考、判断和抉择，是基于领导者的决心和远见。当然这里边有没有孤注一掷的成分？一定有。我的经历和体会告诉我，做一个大的决定，有一些理性成分，但离不开最后决定企业命运的那个选择，也只有企业领军者才能做出这样的决定。这又是一个“落子无悔”，你做的决定就决定了企业的命运。</p><p>早年刚开始做淘宝的时候，eBay在中国是按上传商品数量收费，放一个商品，不知道卖不卖得掉，一天还要付几分钱，大家就不愿意发了。当时马老师做了决定，凡是eBay认为正确的，我们都反对，凡是eBay认为错误的，我们都支持。</p><p>这句话大家不要笑，我认为这句话是面对一个强大竞争市场的时候，非常好的思考方式。也许真理在少数人手里，但有的时候，你找到路就是真理，你找不到路就不是真理。你要在市场参与竞争，对手朝东，你就要往西，核心因为东边这条路已经被占掉了，只有往西才可能找到路，但并不代表西面一定有路。</p><p>在激烈的市场竞争下做商业设计，反过来要有一个相对论——相对于对手，你有什么差异化的策略。如果没有差异化，你再辛苦、再努力也没效果。你不能默认别人比你跑得慢，别人比你懒惰，你要想别人比你更聪明、更勤奋，执行力更强，想得更远，这个时候你该怎么做？只有做得不一样。</p><h3 id="2、商业设计的“两个可持续”"><a href="#2、商业设计的“两个可持续”" class="headerlink" title="2、商业设计的“两个可持续”"></a>2、商业设计的“两个可持续”</h3><p>从历史周期看，当一个企业做了一段后，我们要考虑：随着时间推移，随着世界的发展，随着技术的进步，它定义的用户价值是不是会趋弱，这非常有可能发生。</p><p>过程中切忌用“想当年我多有效”来讨论问题，我经常用这句话刺激阿里的团队——这个世界上，如果第一天是以解决信息不对称性而创造的业务，未来终将消失。今天不是信息稀缺时代，是信息爆炸甚至过度的时代，只解决信息不对称的业务模式终将消逝。潜台词是什么？ 消逝之前还有一个时间窗口，能够找到机会重新定义你对客户的价值——是重新开张，走极端的休克疗法？还是顺着走，活着总比死了强？</p><p>整个业务演进中，你要不断挖掘客户价值。最怕一直认为，第一天做业务时的价值就是客户价值。业务第一天就这么做，今天还要这么做。我个人坚决反对这点，业务都是人创造出来的，它第一天被创造出来有生命力，因为解决了客户的一部分问题。它今天要继续保持生命力，就必须做新的东西。要看时间序列上，你的价值有没有可持续性。作为领导者，我们要不停地去关注、判断，而不是只看我创造的业务很好，规模很大，同比增长也很好，危机就在这其中。</p><p>第二个可持续性跟烧钱相关，就是成本效率的可持续性。用户价值的可持续性，是找到客户痛点，创造可持续的用户价值。而要实现解决方案，提供服务，要看你的成本效率是不是可持续，这是大家普遍关心的问题，也是市场常见的问题。</p><p>我很喜欢看战争史、二战史。我开玩笑说，攻打西西里的战略，难道是在某年某月某日某个地方的哪块门板上画出来的？它充满偶然性，这正是我们的乐趣，也是不确定性带来的各种可能变化。</p><p>如果你只靠亏钱拿到一个市场规模，再融钱继续，这不可持续。东南亚现在满地都是这样的业务模式，各个行业都这么搞，包括国内现在很多业务。我每次看那些数据，真的看不懂，当然也存在看不懂也要学习。但有很多业务，第一天你就可以知道它的未来结局，是能够预判出来的。</p><p>我的观点是，尽最大努力，最终等待命运垂青。不能说所有业务都是算出来的，但如果你不算，光等命运垂青，这也不行。“尽人事、听天命”，这是商业设计中必须要考虑的问题。 </p><h3 id="3、领导者不是万能的，领导者注定孤独"><a href="#3、领导者不是万能的，领导者注定孤独" class="headerlink" title="3、领导者不是万能的，领导者注定孤独"></a>3、领导者不是万能的，领导者注定孤独</h3><p>领导者也不是万能的，领导者注定孤独。你做一个企业，有些事情可以跟人商量，有些事情是你一个人要去做决定的。做企业最痛苦的时候，有的事没人可商量。为什么不能？要去商量的几个人，哥们、姐们全是利益相关方。只有你自己可以跳出来想。</p><p>说实话，马老师对我个人影响非常大，我从他身上看到和体会他怎么去看问题——一个真正的领导人，应该始终面向未来。</p><p>面向未来，不仅是看未来的机会，同时也看未来的问题。其实我们说的客户痛点和客户价值，不一定解决今天的问题。相反，对未来的问题判断越准确，越及早准备，成就可能越大。这世界不缺聪明人，很多人都能看到未来。你如何判断未来这个世界的演进，会出现什么问题，带来什么机会？</p><p>有的时候我们很容易看重现在的机会，包括特别在意错失现在的机会。我有个“头班车末班车”的理论——人们讲要赶上风口：当年无线互联网来了，现在物联网来了，自动驾驶的风真的来了，至少在进行或还在早期。但有些风口已经不是风口了，我们已经在风里边了。</p><p>一个企业在某个领域没有抓住一个大机会的时候，会集体性陷入焦虑，认为它是命根子，不抓住它就可能被别人干趴下了。但有时候跳出来看看，这世界永远是轮回，你错过了这趟，永远会有下一趟。能活着很重要。</p><p>不是矫情，其实每天要考虑的真的是“活着”的问题，不是说做大了就没有这个问题。各种新商业模式也好、创新也好、社会问题也好，萤火虫般的火点都可能分分钟带来“活着”的问题。</p><p>活着的基础上，才能等到下一个风口的到来，并且做好坐上头班车的准备。这就是“头班车末班车”的理论。</p><p>我们通常说，4G来了短视频会超过长视频，必须抓住机遇。但当时哪几个人坚信短视频一定比长视频更好的？没几个人。从最初的各持己见到变成广泛共识的时候，是最需要小心的时候。</p><p>绝望当中都是机会，冲动当中都是陷阱，历史上无数次重复这样的过程。</p><p>这个过程中，怎么把握市场的脉搏？怎么看风口，看未来的机会？我只分享一些个人体会和做法。我非常喜欢聊天，其实我话不多，基本听人家聊，听别人讲有很多的输入，所以跟我聊天挺吃亏的。我提醒自己，做事情必须有对市场的脉搏，这个脉搏来自于体感，这是任何的人工智能数据分析，各种美妙的PPT都解决不了的。团队给我们的输入，客户给我们的输入，永远代替不了我们自己对市场的敏锐度。</p><p>春江水暖鸭先知。所有商业设计的源泉，都来自对市场的敏锐度。敏捷对一个组织很重要，对领导者也至关重要，你有没有敏锐度、敏捷度，能不能洞察市场的反应变化，哪怕是一些微妙变化。</p><p>这是一个企业保持独特生命力的源泉。</p><p>今天阿里那么大，我又在掌勺，要保持一个独特的方法去倾听和了解市场。不是为了挑毛病，而是找感觉。有时团队也会给我很多输入，这时候我的做法就是要反着听。</p><p>最近我讲，PPT是数字时代的八股文。同样要表达一个内容，用PPT的方式，无论你是什么样的高手，花的时间比写下来讲出来要多N倍。我有个习惯，团队和我交流，开会前PPT发到钉钉给我，然后他们开始讲。我是倒过来看PPT，看最后一页写什么，一般是他需要的帮助，前面都是成绩。难得见老板，还不让人显摆，看看有多努力，多有成就。团队难得见我一次，他也肯定有所希望。</p><p>这是人性，不是说把这些全砍掉，要尊重人性。我们都是从小朋友做起的，从练习生出身的，老板就是高高在上。尽管有的老板发自内心说我不是你老板，我们是一样的，但员工并不这么想，员工觉得我好不容易跟你有次见面机会，我得让你记住我，这是最朴素的人性。他能让你记住他，这就是他很大的成就了，他最惦记你帮他解决了什么问题。基本上团队开始讲五分钟、十分钟，PPT我就都翻完了。 </p><p>不同的人做法不同，很难说好坏。我的做法是耐着性子听他讲，除非万不得已去打断。为什么会迅速看完？其实你是在看他没讲的东西，甚至没写的东西。大概有个概念后，最重要的不是他跟你讲了什么，而是他没跟你讲什么。</p><p>其实我讲这些，并不是说这是一个心存杂念、心理阴暗的同学。世界上很多时候就是这样，一群好人，只讲他愿意让你听的话，最后你感受很差。他只表述了一个他想让你知道的世界，而真实世界更立体广阔。他没讲的才是最重要的东西，甚至，没讲的跟他讲的东西合在一起，才是最重要的。语言最奇妙的是，一句话可以用不同方法表达，在不同语境来表达，会产生不一样的效果。</p><p>一些人说，逍遥子你一看就是思考力很严谨、很缜密。其实最难的，就是把一个严谨的人搞成不严谨。这是我一直在努力折磨自己的地方。你明明很有逻辑，但是你必须要放弃一些逻辑，或者说，有些时候你大胆预见到这件事情干了以后，也许就是个悲剧，但是你还是让它发生。</p><p>有多种原因，一要培养人。就跟小孩一样，火是烫手的，小孩还是要碰，你让他碰过一次，他不会碰第二次。第二，面对很多不同意见，有时候你要付出一些代价，让一些不确定性变成确定性。针对不确定性的不同意见，就会变成确定性的一致意见。这句话有点拗口，你们体会一下，当有不确定性的时候，企业内部上上下下、前后左右会有很多观点，你也有观点，不管你有多自信，你有多想，都说服不了别人。</p><p>唯一的方法，是让这件事情发生一下，发生完了，所有人都达成共识。大家会说，这是不是又变上帝了。我们要有敬畏心，我们真不是上帝，真不是每件事情都能算清楚。我想讲的是，要给商业设计的演化留白，要给它一些自然演化的空间，给它一些团队创造的空间。你要相信你的团队，相信这个市场，我们不是万能的，不可能把所有问题都想到，要给市场留下一点空间，让它自然演进。</p><p>世界的发展不是靠策划出来的。最终，经营和管理永远是“科学+艺术”。留白是一种艺术，它必须给客观世界留一些空间。</p><p>大概十年前，当时我刚刚转到业务没多久，很多人问我，做财务和做业务最大不同是什么？ 我说最大的不同是你要敢做不完美的决定。</p><p>做业务一定要敢于做不完美的决定，不完美的决定背后是什么？是取舍。这是我们在商业设计里最难的东西。团队是没有办法做取舍的。 从战略上“既要又要”永远是对的，一到战役组织策略和策略安排执行上，如果“既要又要还要”，一定是错的。 </p><p>一个高级指挥员最重要的事情，是真正能够给下面非常简单的方向和决定，又能把下面的不同方向和决定组合起来，让他们的不同方向、决定发生化学反应后，能达到你的战略目标。</p><h3 id="4、生产关系不对，再好的商业设计都是空中楼阁"><a href="#4、生产关系不对，再好的商业设计都是空中楼阁" class="headerlink" title="4、生产关系不对，再好的商业设计都是空中楼阁"></a>4、生产关系不对，再好的商业设计都是空中楼阁</h3><p>前面一部分我们讲商业设计，如何创造生产力，激发生产力，如何为未来的生产力发展留白，希望有些意想不到的收获。</p><p>任何生产力的创造，回到商业基本原理，都离不开生产关系。合适的生产关系会激发和创造生产力，反过来再好的战略途径、业务策略、竞争打法，最终如果生产关系不对，基本上都是空中楼阁，就是内耗，一号位天天号召大家协同。</p><p>在阿里，我们旗帜鲜明地号召大家要协同，但是我认为，绝大多数的协同问题不是态度问题，不是团队愿不愿意协同，而是生产关系到没到位。要在一个扭曲的生产关系下，希望大家一起合作，本身就违反人性。</p><p>讨论生产关系，企业中就是组织设计。在一个战略方向明确、赛道选择明确，要进行阵型排布的时候，要考虑这个企业处于什么阶段，要解决的主要问题和主要矛盾是什么。从大的层面来讲，组织设计解决的主要矛盾是突破的问题，还是整体效率的问题？两者不同。</p><p>兵无常势，水无常形。组织怎么排，组织设计怎么做，本质反映了企业在特定阶段要解决的特定问题，并且从现在更好地走向下一步，走向未来，如何做好一个铺路石，铺垫好。这里叫“下一步”，而不是广义的未来。为什么？因为组织可以调整，可以一步一步调，当你既定战略目标达到，发觉原来的设计成为走向下一步未来的瓶颈时，就到了该调组织的时候。</p><p>阿里这几年，特别2015年以后我当CEO后，每年双11之后，就是我们调组织的时候。我们马上一轮正在进行，确保全阿里数字经济体能“一张图、一颗心、一场仗”，实现更加完美的战略一体化。</p><h3 id="5、经营核心是突破，管理核心是效率"><a href="#5、经营核心是突破，管理核心是效率" class="headerlink" title="5、经营核心是突破，管理核心是效率"></a>5、经营核心是突破，管理核心是效率</h3><p>“经营“和“管理”是两件事。经营核心是突破。用盒马举例，它能够满足基本需求，又不断创新产品和服务，给用户带来意想不到的惊喜，这是经营问题。</p><p>管理是效率问题。组织运行是不是高效，是不是人浮于事，包括阿里很多团队应该有全国性的组织，地区性的组织、分公司、城市，层层下去能不能管住，这些统称为管理问题。</p><p>其实经营问题、管理问题都有特定阶段的特征。两个问题的效果，基本上符合木桶原理，一定是由最短板决定的。你有再好的想法，再好的商品创新，管理不好，企业也是一团糟，但在特定阶段，作为一号位，要对大的局有判断。组织设计中，如何考虑阶段性的焦点问题和当前首要矛盾，或者说在经营上要解决什么具体问题，管理上要解决什么具体问题，并且经营和管理之间如何微妙地动态平衡，是向左偏一点还是向右偏一点。</p><p>动态平衡最重要。任何企业不论大小一号位，任何的左倾和右倾，哪怕只有五度，在一线就是180度大转弯。我们讲任何问题，只要态度上有鲜明表达，哪怕随口说的，也很容易被断章取义。</p><p>组织设计核心就是几个关键字——纵或者横、分或者合。通常来讲，纵和分是对应的。什么时候纵向，团队需要单兵突进的时候，需要打开一条血路，拓展一个市场，就需要组织敏捷、快速推进，甚至不惜犯错、不惜损耗。有的时候单纯的管理者很容易把效率损耗看成天大的问题，这也是我不断提醒自己的，因为我背景是CFO。我一直在想，马老师以前讲CFO不能干CEO，他的道理是什么？他到今天还是坚持这个观点，只不过说张勇是个例外。他一定是有道理的，所以任何东西不能绝对。</p><p>管理是个保健因子，没有管理不行、没有效率不行，人浮于事不行，重复岗位设计不行，但它不是一个激励因子，企业要创造未来，靠管，把灯都关上是不行的；考勤再严格，也考不出一个面向未来的企业。工厂化管理容易把人管成机器，管成零件，互联网公司不是这样，数字化运营也不是这样，管理哲学上要发挥人的主观能动性，而不是把人变成机器。</p><p>过程中，怎么把握纵和横、分和合。纵的时候，业务要突破，要快速、锋利，横的怎么样都不能锋利，只会敦实厚重。马步扎得稳，但要锋利，一定是纵来得好。企业最终都会有很多职能性设计，是放在一个团队里，还是做成共享，也就是我们叫的中台？</p><p>每个团队都是麻雀虽小、五脏俱全，它自己一定跑得快。当中没有对错，要分清当前主要矛盾。没有任何人可以替我做决定。我会反反复复考虑这些问题。这些问题都是在日常通过不断观察各种现象、情况，最后你发觉不动不行，必须做个选择。</p><p>插一点题外话。对于一个大组织，很多问题不是先来先到。最重要的是，我的Calendar是我自己排。很多人习惯说，我跟你约，找你秘书，其实我想说没用的，我写下来，进入挂号名单，但不代表先挂号的先看病。他没来找我挂号，说不定我盯着他要开会。他找我开会，我可能拖他一个月。为什么？还有比这更重要的。我习惯永远掌握自己的Calendar，时间管理是我的最重要工作。如果我的时间不由自己决定，那就出了大问题。</p><p>我自己手机上会写好，谁找过我，我没答应他。很长一个List，有的我知道他等得很急，我就是不找他，因为我有更重要的事情要办。不是说他的事情不重要。重要不重要，紧急不紧急，永远是相对的。</p><p>回到“分”这个话题。阿里后来立一些新业务的时候，包括钉钉也好，盒马也好、零售通也好，天猫精灵也好，我跟大家可以直截了当地分享，新业务起来必须另立番号，没有番号不成军，不成军就是乌合之众。大家凑一凑，干赢了也不知道算谁的，干输了没人担责任，这肯定不行，你必须要独立成军去打一个山头，尽量减少协同。</p><p>反过来，两个团队做同样的事情，要让两个团队都具备资源，至少有要赢的心，你不能说你跟它对冲，那肯定不行，你还是让每个团队都要全力去赢，所以要纵向和分开。最怕是在新业务、新战场，由职能部门协作，这太麻烦，业务Leader说了不算，财务怎么说、法务、投资、技术、物流、外部协作都怎么说，而最终自己都不管。 </p><p>如果这样，要你这个一号位干嘛？所有人都是提问题的，不是解决问题的。你要不要输赢，要不要把命交给他，这样人家输了也服气。我自己做的决定最后没搞成，我为此买单，而不是说最后一肚子冤屈。这些事情都不是我决定的，结果要我买单，这就完了。</p><h3 id="6、做取舍的过程，也是建立和消费信用的过程"><a href="#6、做取舍的过程，也是建立和消费信用的过程" class="headerlink" title="6、做取舍的过程，也是建立和消费信用的过程"></a>6、做取舍的过程，也是建立和消费信用的过程</h3><p>大家听中台战略很多。中台是阿里非常独特的战略。在独立业务拓展期、突破期，一定用独立团、独立师、独立旅建制来做。反过来管理到一定阶段，出现太多独立师、独立旅，大家各自建小煤窑，每个人都觉得自己能够建成现代化的煤炭产业。这时候要统一搞、要关停并转、要合并同类项。横的问题是你问管理要效率，取消重复性建设。</p><p>我们说，如果第一天奔着平台来创业，基本上都是死。同样，如果一个企业内部奔着中台做中台，也是死。所有平台都是从实战当中打出来的，没有实战当中的经历和建设，你都不知道客户需求是什么，凭什么说我是上帝，能够为所有人服务，这是不可能的。</p><p>这时中台做得不好就会变成瓶颈。做得好的中台都是依托一个大业务，就是这个业务的一部分，做着做着，我们发觉它已经足够茁壮，而且能支持其它业务场景，我们把它中台化。中台是沉淀出来的，不是从底下长起来的。底下长不起来中台。</p><p>我强烈建议大家看一下自己的组织。一号位最难的一点，就是既是商业架构师，又是技术架构师。这对于人的综合要求太高了。我肯定不是技术架构师，我可能成为一个产品架构师，但一个企业最终是一个好的商业架构师，和一个心灵相通的技术架构师呼应合一，这跟职位无关、跟汇报关系无关。在座可能有技术出身的，如果你做的不是纯技术研发类业务，最终还是要把自己变成一个商业架构师，不然很难变成企业的一号位。</p><p>横过来就是当出现多业务发展，中间越来越雷同，你就开始进行抽象沉淀，并通过抽象沉淀以后的平台或中台，来支撑一部分新业务发展。支撑里面的局部模块，这是我自己体会的纵和横、分和合的过程。</p><p>最终回到管理哲学，天下分久必合、合久必分，做企业也一样，分分合合。这是马老师的原话，我最早听没有感触，现在有了心灵感应。最终就是搭积木一样，合久了就分分开，分久了就合起来。</p><p>排阵型离不开一个关键因素，人。</p><p>我自己是个深度足球迷，我最喜欢类型的球队或者教练，都是因地制宜变化阵型。有些教练到哪儿都踢352，或者现在流行4231，两个中场，前面单箭头，高的把制空权掌握，把球过渡下来，左边一个、右边一个，两边总要两匹飞马，左边锋、右边锋，可以往下移。前腰是组织，后面两个防守型后腰，一个可以前后动，一个可以左右动。而有些教练则是到了球队，先看有什么菜，就排什么阵型。比如352就需要两个边后卫很厉害，攻的时候需要像左右前锋一样，守的时候变成两个边后卫，有这样的材料才能做325这盘菜。</p><p>企业管理、组织设计一样。理想的画组织结构图，我认为不成立。我们永远面临的是在特定历史阶段，看有没有合适的人。没有合适的人是常态，完全合适非常难。永远要根据手里有几张牌，你有几个王、你有几个K，就怎么打，怎么布局。这当中一定根据你有的“将”来排布。</p><p>我一直说我比较喜欢用“主将”这样的词，而不看总裁们有几个D。我有时跟总裁聊天，往往问你的左膀右臂是谁，你的干将是谁，不一定是你的D，可能是你的DD。一个企业、一个领军者一定有一个核心团队，这是客观的，不然就变成了孤胆英雄。当中怎么选择主将，要考虑不同阶段的不同问题。</p><p>真正的业务一号位，一定是在高度的不确定性当中去寻找确定性。不确定性是最大的确定性。怎么从各种现象表现，来看到这个人是否有主将特质。最普通的一点，这个人要有观点。我们开会讨论经常发生，只要位置比较高的人说了后，这个事情就变成你定了调，基本上团队就朝那边走了。</p><p>这是人性。在一个快速发展的创新业务里面，最怕人没观点，并且不能坚持和捍卫自己的观点。这样的人几乎不可能成为主将，他只是个manager。manager是个管理者。经营和管理是两件事，他也许是好的一个house keeper，管家，这在企业里也需要。一个企业做得好，也需要一些管家型的人物，但业务要有突破，一定要有主将。在此基础上，怎么样找到这些人的特质，并且看他怎么看待这个组织和机会，这非常重要。</p><p>最终对所有企业一号位来讲，最重要的时间要花在选人，其实就是定战略、定组织、选主将，这几件事情决定了企业的命运。我花很多时间跟同事聊天，正式的、非正式的，开会是最无效的一种，但没办法，有些形式还是要走。我认为这个无效，可能团队觉得很重要，跟逍遥子开会，得到他的认可，或者你讲几句，这个团队就获得很多资源，经常很多变成了CEO工程，必须理解这个。</p><p>要通过合适的方式去倾听这个人的思考。要看这个人正不正，再聪明的人，如果心术不正，在任何企业都会引发灾难。人总有一点自己的小九九，不能完全说大公无私。这是个过程，你给他多大的信任，给他多大的责任，他就越来越大公无私，同时他自己要有独特观点。他必须能够在不确定性当中表达自己清晰的选择。观点是取舍。一个没有取舍的主将、一个没有取舍的组织很难做好，必须在“既要又要还要”下面，在战略思想下面，承受巨大的痛苦和压力、挑战，做关键取舍。做取舍的过程，也是一个建立信用、消费信用的过程。你做对了就建立了信用，老做错，错两次、三次以后，就没有人信你了。</p><p>另一个观点是，一定要搏，所有事情没有那么面面俱到。最终到零秒，总要有人按Button，说朝这边走。这么多年下来，我也在挑战原有的性格。一般到我这儿的决定，下面已经没法做决定了。</p><p>第二，一旦决定以后，就要坚持，地球是圆的，坚持到最后，往东了，只要你还活着，就是往西。最怕来回折腾，最消耗、最没有成果，而且最让团队崩溃。产业终局一定不是一段路可以走到的，我的工作就是在产业终局和现在之间，找到一条歪歪斜斜的路，今天偏五度，后天要往回十度，那边有个坑要跨过去，有时要背道而驰。</p><h3 id="7、业务1号位要有杀伐决断、影响力和气质"><a href="#7、业务1号位要有杀伐决断、影响力和气质" class="headerlink" title="7、业务1号位要有杀伐决断、影响力和气质"></a>7、业务1号位要有杀伐决断、影响力和气质</h3><p>组织阵型最后还是回到人。</p><p>作为业务一号位，他的观点、杀伐决断，他的影响力和气质很关键。有些东西是天生的，只不过需要被激发。现在很多时候，包括马老师，包括Lucy（彭蕾）跟我开玩笑，说你跟以前不一样，没想到你是这么一个人。人是靠被激发出来的，到那个位置上，你自然调动所有潜能去做一件事。</p><p>一号位需要的特质是决断和担当，这非常重要。因为我们面对高度的不确定性。一个好的领导者，一定不是一个manager。一个好的领导者的特质，我把它总结为三句话，都跟担当有关系——</p><p>第一，就是敢做别人不敢做的决定。</p><p>第二，承担不能让团队承担、团队也承担不起的责任。</p><p>第三，就是搞定团队搞定不了的资源。</p><p>第三点特别体现我的特色。前面两个大家都容易想，肯定要做决定，肯定要担责任，但如果只有这两个，你不帮团队解决一些实际问题也没用，你讲得很好，我们必须干这个，责任我来担。但怎么干，要有条件，要有技术资源，人的资源，钱的资源。所以你要搞定一些资源，这是必须的。最终永远缺的是资源，广义的“资源”，因为机会总比资源多。</p><p>反过来，如果跟团队有共同的战斗、共同的经历、共同的体验，才能看出在团队眼中，这个人只是你的老板还是你的老大。我认为，老大是正向的描述，如果一个大组织里面，一个团队里面没有老大的感觉，这个团队没有真正的凝聚力。老板是封的，是任命的，老大是发自团队内心的。</p><p>这个过程要靠共同战斗经历，荣辱与共、彼此担当，甚至为团队承担一些东西。我经常问自己，到底大家认我这个人，还是认我的官衔？人要有自知之明，我当然希望认我这个人。我也理解过程中，如果没有亲密接触、没有共同经历战斗，可能认的就是官衔。但一个组织要健康发展，就要能荣辱与共，共同战斗，成为战友。</p><p>我以前经常跟团队讲，没有一起打过仗的只能叫同事，不能叫战友，一起打过仗就是战友，你才会知道，要死的心是什么，一起共同在海底淹死之前求生，彼此拉，也拉不住谁，都要往下沉的感觉，这是生死与共的感觉，这是一个企业最宝贵的。一个企业真的成功，所谓敢于把后背交给对方、敢于互相信任，无条件支持，就来自这种胜过同事的感觉。</p><p>锦上添花容易，雪中送炭最难。真到抉择时刻，能不能同舟共济，真的到企业有危难的时候，才知道什么是真正的友谊、什么是真正的支持。平时鼓掌、笑脸、问候不差一个，但到那个时候，能不能帮人家一下，哪怕慰问一下，最后用实际行动做些事情，这是真正的友谊，同时才能建立更紧密的信任。</p><p>阿里叫“因为信任、所以简单”，信任是很高阶段的事情，首先人要互相认识、熟悉，有很多交往，经历一些事情，慢慢累积一些信任，你没有办法要求两个不认识的人因为信任、所以简单，听了以后没有感觉的。</p><p>首先要自己感动，才能感动别人，才能真的发自内心让团队、让主将、让员工有机会变成更好的自己。这是阿里文化的主题。还是要用心。这跟做业务一样，最终做一个企业领导者，是智商、情商，最后是爱商，这也是我们的坚信。我总结阿里巴巴的文化内核，就是相信人和社会的美好。尽管世界有很多丑恶的事情，但是你还是愿意相信美好，并且愿意去相信别人。</p><p>碰到问题的时候，你敢不敢首先相信别人，哪怕有时候会被骗，哪怕有时候不顺利，但是你愿不愿意做这个事情，这是企业的DNA，也是阿里的DNA。</p><p>这次阿里的新六脉神剑，我给提的观点是，不是传承，不是我传给你，是寻找共鸣，找到同路人。每个人心里都有这样一部分，你能把他激发出来，原来大家都信这个，都觉得这样世界会更美好，为什么我们不一起努力一下？这才是真正把文化和业务融在一起，只有这样才能走向一个更健康的组织。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做好团队的目标和技术规划</title>
      <link href="/2019/12/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%9B%A2%E9%98%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%9B%A2%E9%98%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>管理规划有四个相互关联的要素：职能、目标、团队和路径。在上一篇文章中，我们已经探讨了第一个要素，也就是如何界定团队职能。我想现在你应该很清楚自己团队该承担什么样的基本职责，以及希望背负什么样的使命了。</p><p>接下来的一个问题就是，未来的一段时间里，三个月、六个月也好，一年也好，你希望带着你的团队抵达一个什么样的目的地呢？这就是我们通常所说的“目标”。</p><p>今天这篇文章我们就一起来看看目标到底该如何设定，包括如下三个方面：</p><blockquote><p>你会更加清楚目标都意味着什么，它可不是让团队有事儿干那么简单。</p><p>你会掌握目标设定的要点，即使你之前没做过目标管理，你也可以实际操作了。</p><p>一起探讨在团队频繁调整，公司战略都不稳定的情况下，如何管理团队目标。</p></blockquote><p><strong>1.为什么目标会那么重要？</strong></p><p>我希望你做目标设定的时候，是基于你自己的动力，而不是被惯性推着走。那么，目标对于团队管理到底都意味着什么呢？</p><p><strong>第一，最基本的，目标包含着你和上级的诉求</strong>，即你们希望收获的东西。</p><p><strong>第二，目标意味着资源的有效配置</strong></p><p>明确的目标可以让你把资源投注在有效的方向上，从“该做什么”去调配资源，而不是“能干什么”。</p><p><strong>第三，目标意味着执行力</strong></p><p>很多管理者都把执行力和目标分开来谈，其实在我的访谈和观察中，技术管理者在任务执行上大多是很强的，并不是短板；而表现出“执行力不够”的最大的原因，都在于目标的不清晰或多变。我让他们回想自己做的执行力最棒的项目是不是都具有精确的目标，结果无一例外都是肯定的答案。显然，清晰的目标是高效执行的必要条件。</p><p><strong>第四，目标意味着凝聚力</strong></p><p>很多管理者问我到底该如何提升团队的凝聚力，我都会告诉他们：明确的团队目标和愿景，就是提升团队凝聚力的重要手段之一。大家因为相同的目标而并肩作战，在一起取得成就的过程中建立起深厚的“革命友情”，这对凝聚力有莫大帮助。</p><p><strong>第五，目标也意味着激励</strong></p><p>在提升员工自驱力的要素中，员工在工作中产生沉浸其中、物我两忘的“心流”状态，就需要有清晰的目标为前提。而且，团队目标感带给员工对工作的意义感和使命感，也是提升自驱力的重要来源。</p><p><strong>2.什么样的目标才是合理的目标呢？</strong></p><p>这就涉及到目标设定的原则，即“SMART”原则。分别对应着 5 个英文单词，即 Specific、Measurable、Attainable、Relevant 和 Time-bound，用中文来说就是目标的明确性、可衡量性、可达性、相关性和时限性。</p><p><strong>关于<strong><strong>目标的</strong></strong>可达性原则：</strong></p><p>你也许听很多人说过，“踮起脚尖能够到的目标最合适”，只是强调了其中的可达性原则，即，不能定一个完全实现不了的很高的目标，也不能定一个不需要努力就能实现的很低的目标。作为团队负责人，你会不会认为，定一个肯定能实现的相对保守的目标，对于向上级交差非常有利？</p><p>如果你真的这么想，那你就忽略了关于目标的一个重要的原则：<strong>目标是设定给团队的，而不是设定给上级的，其目的是为了让团队集中资源做出有效的成绩。当你为了容易交差而给团队设定一个没有挑战的目标时，团队成员是得不到激励的，也无法让员工进入“心流”状态。</strong></p><p><strong>另外，一个非常常见的情况是，如果你总让员工做没有挑战的工作，他很可能会因为没有成长而跟你提离职。所以，一个有挑战且努力能达到的目标，才是恰当的。</strong></p><p><strong>关于目标的明确性和可衡量性原则</strong></p><p>我认为这两个原则是分不开的。“目标要明确”这句话，我相信你听得耳朵都磨出茧子了。那么究竟什么叫“明确”呢？我觉得你可以简单地理解为，把目标设定到可以衡量的程度，就叫做明确了。</p><p>比如，下面两组目标说法的对比。</p><p>第一组：</p><p>a)“我们的目标是提升某个服务的性能。”这不是一个明确的可以衡量的目标。</p><p>b)“我们的目标是把某个服务的单机性能从 300qps 提升到 500qps。”这就是一个可以明确衡量的目标。</p><p>第二组：</p><p>a）“我们的目标是发布 BI 系统 1.0。”这看似是一个可以衡量的目标，但是 BI 系统 1.0 如何衡量是否完成了呢？又比较模糊。</p><p>b）“我们的目标是发布 BI 系统 1.0，支持 KPI 数据统计、全量数据导出功能。”这样就清楚 BI 系统 1.0 如何衡量了，要支持这样两项核心功</p><p>能才行。</p><p><strong>关于目标的相关性原则</strong></p><p>对于技术团队来说很难跑偏，因为技术这个角色决定了其工作内容必定是和上、下游及上级目标相关联的。所以，在这儿我就不展开细讲了。</p><p><strong>关于目标的时限性原则</strong></p><p>所有的目标都是基于一定时限的，缺少时间限制的目标没有意义。比如前面我们提到的“提升单机性能”的目标或“发布 BI 系统 1.0”的目标，如果没有限定一个时间，就不清楚该什么时候去衡量，也就无所谓是否有挑战和是否完成。</p><p>所以，一定要有个明确的时间点，比如“到 9 月底，把单机性能从 300qps 提升到 500qps”“到 12 月底，发布 BI 系统 1.0，支持 KPI 数据统计、全量数据导出分析功能”，就是两个完整且合理的目标描述了。</p><p>所以，当你要评判一个目标是否合理时，需要从 SMART 这五个原则去逐个审视，如果都符合了，说明你这个目标是清晰可行的。</p><p><strong>3.目标的形式是怎样的？</strong></p><p>目标的描述形式，大体分为两类：一类是可以量化的指标，就是大家常说的 KPI（Key Performance Indicator，关键绩效指标）；</p><p>另外一类是不可量化的目标，用关键结果来衡量，就是我们常说的 KRA(Key Result Areas) 或 OKR(Objectives &amp; Key Results)，总之就是对关键结果的一种描述。</p><p>它们大体上的描述形式是：</p><p>KPI：到某时间点，什么指标达到什么数字；</p><p>KRA R：到某时间点，完成什么工作，该工作实现了哪些功能或达到了哪些效果。</p><p><strong>4.目标制定经常遇到的坑</strong></p><p>新经理在目标设定上，常常会踩一些坑，面临诸多挑战，如下四类问题和挑战是最为常见的。</p><p><strong>第一类问题是基于现有资源做目标，而不是基于远方的目标往前推</strong>。</p><p>这类问题常见的说法就是，“我们团队只能做到个程度”“这些项目能做完就不错了”等。其实，更为合理的做法应该是，从上级的角度来讲，你的团队需要保证哪几项重要的结果，然后再看看如何调配和补充资源。面对这类问题和挑战的钥匙叫做“以终为始的出发点”。</p><p><strong>第二类问题是目标不明确。</strong></p><p>你可能会说，“从上面你说的来看，一个明确的目标很容易制定啊！”但问题在于，新管理者很少会因为“目标笼统或太大”导致不明确；不过，倒是常常会因为“过程化描述”而引发目标不明确的情况出现。</p><p>常见的说法是，“我们要在 10 月底，完成架构改造”“我们要在 12 月底，上线反作弊系统 1.0”等等。这类描述的问题在于，主要强调“我做了什么”，而没有交代做完这些工作后，“取得了什么效果”。 因此，面对这类问题和挑战的钥匙叫做“结果导向的描述”。</p><p><strong>第三类问题是目标设定好之后，自己和自己的上级都很清楚了，但是没有刻意地向团队成员来传达，只是按照目标拆解去安排大家的工作。</strong></p><p>这样的做法，导致团队成员对于整个团队的方向感不清晰，那么前面我提到的那些目标能带来的效果就无法显现，比如起不到对团队的凝聚和激励的效果。面对这类问题和挑战的钥匙叫做“目标的向下同步”。</p><p><strong>第四类问题，也是大家最头疼的一个问题，就是目标总是被迫变来变去。互联网领域很少有非常稳定的公司，业务总是在调整，自己的上级也时不时就换个新的，甚至于公司的战略也每隔一段时间就变一次。</strong></p><p>显然，之前为团队设定的目标，也得跟着变来变去。于是，目标慢慢变得形同虚设。面对这类问题和挑战的钥匙叫做“设定专业目标”，用专业目标来增强团队的内在定力。</p><p>团队和人是一样的，如果总是被外在需求牵着走，内心必然会充满焦虑，所以还需要弄清楚自己的内在追求。而专业目标，就是为团队树立明确的内在追求。</p><p>说到这里，你可能又会问：什么是“专业目标”呢？</p><p>要解释“专业目标”，我们就得先来谈谈“业务目标”。“业务目标”简单来说就是需要完成的业务业绩目标，也就是我们常说的 KPI 和 KRA，是公司和上级对你团队的业绩要求，这类目标一般是自上而下拆解下来的，所以来自于外部，一般不容易被忽略。</p><p>和“业务目标”来自外部要求相对应，“专业目标”来自你团队的内在要求，一般是由你和团队自己设定的，属于自我要求，所以新的管理者往往会忽略不做，有的是想不到，有的是懒得做。而恰恰是这个内在目标的设定，最能体现你的管理价值，因为这是最能展示你的自主性的地方。</p><p>专业目标设定的核心步骤就两步：第一，选择你要提升的关键维度；第二，设定目标，可以是量化的 KPI，也可以是非量化的 KRA。</p><p>关于团队的关键维度，上篇文章中我提到，就好像每个人都有自己的价值观一样，每个团队也都有自己最核心的评价维度，这是由团队职能决定的，比如服务端团队的稳定性和性能，数据团队的准确性和安全性，功能迭代团队的高效和质量，等等，这些维度是最能体现团队核心能力及价值的。</p><p>因此，即使上级没有提出要求，团队负责人也要为团队基于这些专业维度来设定目标，比如作为服务端团队，可以把“半年内提升 40% 的并发性能”作为团队的专业目标，以此来不断修炼团队的内功，并作为团队的内在追求。</p><p>如此，当外部的业务目标不稳定时，相对稳定的专业目标可以让团队内部一直有个“指南针”，从而降低目标频繁调整引起的员工焦虑，而且还避免了目标变来变去导致的“瞎忙”或“白忙”。</p><p>你可能会说，内在的专业目标还没有达成的时候，上级的业务目标又压下来了怎么办？这类冲突的处理办法和“重要紧急”四象限的权衡思路是一致的，内在的专业目标属于重要的事情，而外部压过来的目标，属于紧急的事情。重要紧急的权衡和决策是管理者的日常工作内容，慢慢你会有自己的心得体会的，现在我们先探讨的是“团队定力”的问题。</p><p>最后，你是否可以制定出自己团队的目标了呢？除了业务目标，你制定专业目标了吗？如果你已经有自己的团队目标，他们符合 SMART 原则吗？如果你都做得非常到位，你把这个非常棒的目标周知到团队每个成员了吗?</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发下的接口幂等性</title>
      <link href="/2019/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2019/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>作者 | 抽离的心</p><h2 id="来源-blog-csdn-net-x2F-u011635492-x2F-article-x2F-details-x2F-81058153"><a href="#来源-blog-csdn-net-x2F-u011635492-x2F-article-x2F-details-x2F-81058153" class="headerlink" title="来源 | blog.csdn.net&#x2F;u011635492&#x2F;article&#x2F;details&#x2F;81058153"></a>来源 | blog.csdn.net&#x2F;u011635492&#x2F;article&#x2F;details&#x2F;81058153</h2><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。</p><p>例如：</p><ol><li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li><li>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；</li><li>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。</li></ol><p>等等很多重要的情况，这些逻辑都需要幂等的特性来支持。</p><h1 id="二、幂等性概念"><a href="#二、幂等性概念" class="headerlink" title="二、幂等性概念"></a>二、幂等性概念</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p><p>这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.</p><p>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</p><h1 id="三、技术方案"><a href="#三、技术方案" class="headerlink" title="三、技术方案"></a>三、技术方案</h1><p><strong>1. 查询操作</strong> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p><p><strong>2. 删除操作</strong> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p><p><strong>3.唯一索引，防止新增脏数据</strong> 比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p><p><strong>要点：</strong> 唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</p><p><strong>4. token机制，防止页面重复提交</strong></p><p>业务要求：</p><p>页面的数据只能被点击提交一次</p><p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p><p>解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） 单JVM环境：采用token加redis或token加jvm内存</p><p>处理流程：</p><ol><li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li><li>提交后后台校验token，同时删除token，生成新的token返回</li></ol><p>token特点：</p><p>要申请，一次有效性，可以限流</p><p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p><p><strong>5. 悲观锁</strong> 获取数据的时候加锁获取</p><p>select * from table_xxx where id&#x3D;’xxx’ for update;</p><p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p><p><strong>6. 乐观锁</strong> 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p><p>1、通过版本号实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_xxx set name=#name#,version=version+1 where version=#version#</span><br></pre></td></tr></table></figure><p>如下图(来自网上)：</p><p><img src="https://aimak.cn/blog_img/java/version_mideng.png" alt="图片"></p><p>2、通过条件限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p>要求：quality-#subQuality# &gt;&#x3D; ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</p><p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set name=#name#,version=version+1 where id=#id# and version=#version#</span><br><span class="line"></span><br><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p><strong>7. 分布式锁</strong> 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定</p><p>这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁</p><p>这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p><p><strong>8. select + insert</strong> 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p><p>注意：核心高并发流程不要用这种方法</p><p><strong>9. 状态机幂等</strong> 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机</p><p>如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p><p><strong>10. 对外提供接口的api如何保证幂等</strong></p><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</p><p>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p><p><strong>重点</strong>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引</p><p>这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p><p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java  50+ Spring 常用注解</title>
      <link href="/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>使用注解的优势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.采用纯java代码，不在需要配置繁杂的xml文件</span><br><span class="line"></span><br><span class="line">2.在配置中也可享受面向对象带来的好处</span><br><span class="line"></span><br><span class="line">3.类型安全对重构可以提供良好的支持</span><br><span class="line"></span><br><span class="line">4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</span><br></pre></td></tr></table></figure><p><strong>Spring部分</strong></p><p><strong>1、声明bean的注解</strong></p><p>@Component 组件，没有明确的角色</p><p>@Service 在业务逻辑层使用（service层）</p><p>@Repository 在数据访问层使用（dao层）</p><p>@Controller 在展现层使用，控制器的声明（C）</p><p><strong>2、注入bean的注解</strong></p><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><p><strong>3、java配置类相关注解</strong></p><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><p><strong>4、切面（AOP）相关注解</strong></p><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><p><strong>5、@Bean的属性支持</strong></p><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</p><p>Protetype （每次调用新建一个bean）</p><p>Request （web项目中，给每个http request新建一个bean）</p><p>Session （web项目中，给每个http session新建一个bean）</p><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><p><strong>6、@Value注解</strong></p><p>@Value 为属性注入值（属性上）</p><p>支持如下方式的注入：</p><p>》注入普通字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;Michael Jackson&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入操作系统属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;systemPropreties[&#x27;os.name&#x27;]&#125;&quot;)</span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure><p>》注入表达式结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;@&#123; T(java.lang.Math).radom() * 100 &#125;&quot;)</span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><p>》注入其它bean属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入文件资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)</span><br><span class="line">Resource file</span><br></pre></td></tr></table></figure><p>》注入网站资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;http://www.baidu.com&quot;)</span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><p>》注入配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;book.name&#125;&quot;)</span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure><p>注入配置使用方法：</p><p>① 编写配置文件（test.properties）</p><p>book.name&#x3D;《三体》</p><p>② @PropertySource 加载配置文件(类上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</span><br></pre></td></tr></table></figure><p>③ 还需配置一个</p><p>PropertySourcesPlaceholderConfigurer的bean。</p><p><strong>7、环境切换</strong></p><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p><strong>8、异步相关</strong></p><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><p><strong>9、定时任务相关</strong></p><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><p><strong>10、@Enable*注解说明</strong></p><p>这些注解主要用来开启对xxx的支持。</p><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p><p>@EnableAsync 开启异步方法的支持</p><p>@EnableScheduling 开启计划任务的支持</p><p>@EnableWebMvc 开启Web MVC的配置支持</p><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableCaching 开启注解式的缓存支持</p><p><strong>11、测试相关注解</strong></p><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(&quot;SpringJUnit4ClassRunner.classs&quot;)</span><br></pre></td></tr></table></figure><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(&quot;classes=&#123;TestConfig.class&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>SpringMVC部分</strong></p><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>@RequestMapping：@RequestMapping(“&#x2F;path”)表示该控制器处理所有“&#x2F;path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>value:指定请求的实际地址，指定的地址可以是URI</p><p>Template 模式</p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等</p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application&#x2F;json,text&#x2F;html;</p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：用在方法的参数前面。</p><p>@RequestParam</p><p>String a &#x3D;request.getParameter(“a”)。</p><p>@PathVariable:路径变量。如 参数与大括号里的名字一样要相同。</p><p><strong>SpringBoot部分</strong></p><p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：</p><p>@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p><p>@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p><p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p><p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><p>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p><p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>@Import：用来导入其他配置类。</p><p>@ImportResource：用来加载xml配置文件。</p><p>@Autowired：自动导入依赖的bean</p><p>@Service：一般用于修饰service层的组件</p><p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>@Bean：用@Bean标注方法等价于XML中配置的bean。</p><p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p><p>@Inject：等价于默认的@Autowired，只是没有required属性；</p><p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。</p><p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><p>@Resource(name&#x3D;”name”,type&#x3D;”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>二、注解列表如下</p><p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p><p>@ComponentScan：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>@Configuration ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p><p>@EnableAutoConfiguration ：自动配置。</p><p>@ComponentScan ：组件扫描，可自动发现和装配一些Bean。</p><p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p><p>@RestController：注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p><p>@Autowired：自动导入。</p><p>@PathVariable：获取参数。</p><p>@JsonBackReference：解决嵌套外链问题。</p><p>@RepositoryRestResourcepublic：配合spring-boot-starter-data-rest使用。</p><p>三、JPA注解</p><p>@Entity：@Table(name&#x3D;”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p><p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p><p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p><p>@Column：如果字段名与列名相同，则可以省略。</p><p>@Id：表示该属性为主键。</p><p>@GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE,generator &#x3D; “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p><p>@SequenceGeneretor(name &#x3D; “repair_seq”, sequenceName &#x3D; “seq_repair”, allocationSize &#x3D; 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p><p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch&#x3D;FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>@JoinColumn（name&#x3D;”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p><p>五、全局异常处理</p><p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p><p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p><p>六、项目中具体配置解析和使用环境</p><p>@MappedSuperclass： 1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</p><p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p><p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p><p>@Column：</p><p>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p><p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。具体如下：</p><p> 1 name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</p><p> 2 unique属性：unique属性表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table注解中的@UniqueConstraint</p><p> 3 nullable属性：nullable属性表示该字段是否可以为null值，默认为true</p><p> 4 insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</p><p> 5 updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</p><p> 6 insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</p><p> 7 columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</p><p> 8 table属性：table属性定义了包含当前字段的表名</p><p> 9 length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</p><p> 10 precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</p><p>  具体如下：   1.double类型将在数据库中映射为double类型，precision和scale属性无效</p><p>  2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准</p><p>  3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效</p><p>  4.precision和scale属性只在BigDecimal类型中有效</p><p>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p><p>4.@Column标注也可置于属性的getter方法之前</p><p>@Getter和@Setter（Lombok）</p><p>@Setter：注解在属性上；为属性提供 setting 方法</p><p>@Getter：注解在属性上；为属性提供 getting 方法</p><p>@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法  @Setter：注解在属性上；为属性提供 setting 方法  @Getter：注解在属性上；为属性提供 getting 方法  @Log4j2 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似  @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法  @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法</p><p>@EqualsAndHashCode:默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p><p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p><p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，只能自己手写了  @NonNull：注解在属性上，如果注解了，就必须不能为Null  @val:注解在属性上，如果注解了，就是设置为final类型，可查看源码的注释知道</p><p>当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</p><p>@javax.persistence.PostLoad：加载后。</p><p>@javax.persistence.PrePersist：持久化前。</p><p>@javax.persistence.PostPersist：持久化后。</p><p>@javax.persistence.PreUpdate：更新前。</p><p>@javax.persistence.PostUpdate：更新后。</p><p>@javax.persistence.PreRemove：删除前。</p><p>@javax.persistence.PostRemove：删除后。</p><p>1）数据库查询</p><p>@PostLoad事件在下列情况下触发：</p><p>执行EntityManager.find()或getreference()方法载入一个实体后。</p><p>执行JPQL查询后。</p><p>EntityManager.refresh()方法被调用后。</p><p>2）数据库插入</p><p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p><p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p><p>@PostPersist事件在数据已经插入进数据库后发生。</p><p>3）数据库更新</p><p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p><p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p><p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p><p>4）数据库删除</p><p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p><p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p><p>@PostRemove事件在实体从数据库中删除后触发。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40753536/article/details/81285046">https://blog.csdn.net/weixin_40753536/article/details/81285046</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考错误的工作方式</title>
      <link href="/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>《浪潮之巅》的作者吴军，在《得到》专栏里，提及了Google刚进中国时候的一件事。</p><p>刚开始，Google总部对中国研发团队的评价非常低，因为“出工不出活儿”，北京的三四个工程师都抵不上Google总部的一个工程师。</p><p>后来吴军帮忙分析了原因，他发现，那些工程师都不善于找到最重要的工作并优先完成它们。</p><blockquote><p>中国研发团队里，所有的工程师都是新人，没有人告诉他们该如何工作；</p><p>而在Google总部，新员工只是一小部分，所以很容易在有经验的员工带动下快速掌握工作技能。</p></blockquote><p>之后两年，Google总部的工程师陆续来中国帮助团队梳理工作方式，而中国团队也会去Google总部交流，这种情况就得到了改善，中国研发团队也最终得到了总部的认可。</p><p>Google工程师这么聪明的一群人，尚且需要学习正确的工作方式，才能有效产出，何况大多数人？</p><p>我们一直都认为，如果一个人智商情商正常、学习和工作意愿高，就一定能出成绩。</p><p>然而，我带过很多人，也招过很多人，却发现一个奇怪的现象：</p><blockquote><p>有一些人，十分有意愿学习，非常努力，智商情商也都正常，然而工作产出却非常低，甚至不如很多资质低于他们的人。</p></blockquote><p>我一直百思不得其解，一度怀疑自己看人不准。直到前阵子看到吴军的这段叙述，才幡然醒悟。</p><p>我仔细回想了这些人的工作方式，将他们与产出高的人相比，发现他们无一例外都存在三个问题。</p><p><strong>一、只关注任务，不关注目标</strong></p><p>假如你的老板正在飞机上，还有1小时落地，下来之后需要给客户做一个重要汇报，而你需要给他做一份PPT。</p><p>但因为你错估了时间，导致PPT草草做完，而且发现其中一些数据没有，你怎么办？</p><p><strong>低效人士</strong>的做法是：疯狂地找数据，最后可能数据有了，然而PPT没有来得及做完，或者质量不高。</p><p><strong>一般人</strong>的做法是：找人帮自己一起找数据。</p><p>而<strong>最高效</strong>的那些人，会根据老板此次汇报的目的，判断这些数据在其中的作用大小：</p><p>如果作用不大，那么就把时间花在完善重要页数、而不是找数据上，如果很关键，那么就找其他人帮忙，或者找一些替代数据。</p><p>这三类人之间的差距，其实就是<strong>任务导向与目标导向的差距</strong>。</p><p>我此前的咨询公司，在做高潜人才研究的时候，有个发现：</p><p>高潜力的人才是有共性的，具备这些共性的人，几乎做什么都能做好，而不具备的，几乎做任何工作都会障碍重重。</p><p>这其中，有一项共性就是<strong>Result-driven</strong>（结果驱动）。</p><p>那些高产出的人，未必动作更快，而是更善于判断，什么事情对结果是最有效的，然后，用尽一切办法保证结果达成，而不是死守着原有的工作任务。</p><p>实际上，<strong>结果驱动不仅仅是一种工作习惯，更是一种思维方式</strong>。</p><p>这种以终为始的思维模式，是我自己刻意训练的最有用的思维模式之一。</p><p>比如思维训练营里，有学员问我：“如何让自己对一个行业有真知灼见？ ”</p><p>想想看，如果是你，会如何回答？ </p><p>我的回答方式，是反问她：“ 具备真知灼见的目的是什么呢？是想让客户更加信任你、还是想让老板看到你的进步？”</p><p>假设你是希望客户信任你，觉得你懂他，那你要做的，就是看这个行业里的客户有什么痛点，然后针对这几个痛点，下功夫研究和分析，有更多洞见，然后借机沟通出去。</p><p>了解一个行业，是一个太大的话题，没有目标，根本无从下手。</p><p>所以，<strong>没有结果驱动的思维，而仅仅死守着工作任务，最终就是，出工不出活儿</strong>。</p><p><strong>二、应激式工作，而非统筹式工作</strong></p><p>如果你观察周围的同事，会发现，整天风风火火、急得上蹿下跳、各种任务来回切换的人，有时候产出并不高。</p><p>看他们工作，就好像打地鼠一样，打完一个，另一个又冒上来，连看的人都跟着焦虑起来。</p><p>而另一类人，他们做事专注、条理清晰、看起来很淡定，但最后，多困难的事儿都默默搞定了。</p><p>两者的差别就在于，第一类人总<strong>是应激式</strong>工作。</p><p>他们每天起来的第一件事，不是规划当天的工作，而是马上投入工作，以至于到了下班之后，发现还有很多事情没做完，而没做完的，可能又是最重要的。</p><p>另外，领导临时给个任务、客户临时有个要求、同事临时要个数据，他们都会停下手里的事情，去忙这些，最终，在任务的切换上花费了巨大的精力。</p><p>我跟公司的运营打过一个比方：</p><blockquote><p>假设你每项工作任务平均半小时可以做完，而任务之间的切换通常也要半小时，如果你经常一项不做完就切换到下一项，就算每个任务中途切换一次吧。</p><p>那就意味着，8小时的工作时间，你至少有4小时都花在任务切换上了。</p></blockquote><p>这种应激式工作方式无疑是低效的。</p><p>那什么才是高效的呢？统筹式工作。</p><p>真正的统筹式工作，有几个特征：</p><p><strong>1.有计划地工作</strong></p><p>我通常周日晚上就会排好下周每天的工作，而每天早上会排好当天的工作。</p><p>而且，任务清单在工作的时候一直开着、实时更新，完成一项删掉一项，临时增加一项就插入相应的时间段，当天完不成的、非紧急的任务，我就改成第二天的日期。</p><p>这种方式，会让自己很有掌控感，多少事情来了，都不会乱了阵脚。</p><p>当然，在做计划的时候，你需要为高价值问题分配最多专门的时间。</p><p>因为，大部分人在80%的时间里都是做无用功，根本原因就是没搞清楚真正要解决的问题。</p><p><strong>2.形成自己固定的时间习惯</strong></p><p>比如我的习惯是：</p><blockquote><p>在上午做需要烧脑的事情、在交通工具上听书、在饭后效率不高的时候集中回复微信消息和留言、在等人的时候构思下篇文章主题、在疲劳的时候刷一下公众号、在傍晚的时候跟团队开会、在晚上做一个简单总结。</p></blockquote><p>这种习惯，一方面把不同难度的工作跟自己的效率波峰波谷相匹配，达到效率最大化；</p><p>另一方面，我会清楚地知道，5分钟、10分钟、30分钟，对我来说分别可以干什么，这样就不会一有碎片时间，就习惯性地刷朋友圈了。</p><p><strong>3.及时记录、每天总结</strong></p><p>当你正在工作的时候，老板布置了一个任务、客户又来了一个问题，你会如何呢？</p><p>很多人就直接扑到临时任务上去了，但真正好的做法是：</p><p>如果不是十万火急，你可以快速用关键词记在笔记本上，不需要任何思考，然后马上回到刚才的任务，做完再看笔记本。</p><p>另外，你在一天当中，学到了什么、犯了什么错误，当时也要记下来，因为过了那个时候，你很快就会忘，然后继续犯这个错误。</p><p>当然，这些记录，晚上都需要进行整理。</p><p>我曾说过，此前8年多的顾问生涯里，成长最快的那半年，我每天都坚持写工作日记。</p><p>另外，记录还有一个好处，就是可以减轻大脑负担。</p><p>每天的例行工作、自己常犯的错误，这些都可以列清单。</p><p><strong>你的大脑是用来思考的，是很宝贵的，别把一支笔就可以做的事情，强加给你的大脑来做。</strong></p><p><strong>三、几乎从不“偷懒”</strong></p><p>“懒癌”是第一生产力。仔细盘点一下，我们哪样创新不是因为懒呢？</p><blockquote><p>不想走路，有了汽车；不想爬楼，有了电梯；不想打扫，有了扫地机器人……</p></blockquote><p>工作中的大部分事情，并不是一次性的，而是持续的，那么就可以在第一次做的时候，搭好框架。</p><p>比如，我让运营每周做一次数据分析，这个事情是重复性的，所以高效的做法是：</p><p>建一张excel表格，把固定需要分析的参数都做好公式，每周只需要把导出来的源数据贴进去，刷新之后参数就出来，然后只需要看参数来得出结论。</p><p>当然，这里所说的“偷懒”，不仅是善用工具，还包括善用他人。</p><blockquote><p>比如，你从来没做过数据分析，那么就先去找找前人怎么做的；</p><p>比如，你有自己的团队或者实习生，那就不要做任何他们就可以做的事情；</p><p>再比如，去运营社群，摸索出一套群主激励机制，比你自己去做群主，要高效得多。</p></blockquote><p>所以，这三个让你Work Smart的工作方式，听起来难吗？一点也不，而且你很可能也听说过。</p><p>但是，为什么很多人做不到呢？我观察下来，有几个障碍：</p><p><strong>1.工作环境所限</strong></p><p>很多人的工作性质，就不是结果导向型的，而是任务导向型的。</p><p>他的工作岗位要求他做的，就是完成任务，至于背后的出发点，不需要知道。而且，领导有可能就是考核努力、考核苦劳，而不是考核产出。</p><p>实际上，工作性质对一个人的思维方式、行为习惯的影响，大到超乎想象。</p><p>你去看，刚毕业的时候，一个学校一个专业的同学，看起来差不多。</p><p>但过了几年，你会发现，只要接触一个人几分钟，听他说几句话，就能大致判断出他的职业。</p><p>再极端一些的，多年前我曾经因为要帮客户设计流程，去他们的产线观察生产过程。</p><p>在噪音极大、灯光昏暗的厂房里，我看着流水线工人机械地盯着机器、等待换箱，几个小时下来，我自己也开始反应迟钝、敏锐度下降了。</p><p><strong>2.没有资深的人辅导</strong></p><p>从开头的案例可以看出，Google工程师那么优秀的一群人，在从校园进入公司之后，也需要有经验的人辅导。</p><p>但很多公司并不像Google那样，重视对新人工作方式的培养，将Work Smart提到非常高的位置。</p><p>他们往往只重视教员工What（需要做哪些事情、用什么工具等等），却没有How（如何聪明地做这些事情）和Why（这些事情对公司、对客户有什么帮助、要达到何种目的），导致员工的聪明才干发挥不出来，没有成就感。</p><p><strong>3.思维方式固化</strong></p><p>一部分人，会在工作多年之后，发现工作性质和工作环境的负面影响，醒悟过来想要改变。</p><p>然而，从学校踏入社会的这几年，是思维和工作方式形成的关键几年，如果任务导向、应激式努力、闷头蛮干的工作方式在大脑中固化了，形成了下意识思维，是很难扭转过来的。</p><p>我带过几个人，此前的工作经历都是任务式、应激式的，在跟他们合作的时候，的确能够感受到他们与自己固有思维作斗争的痛苦与挣扎。</p><p>然而，并不是每个人最终都能挣扎出来、突破自我的。</p><p>所以，<strong>年轻时候的工作选择，你选择的不只是一份工作，而是一种思维习惯、工作方式、价值观甚至生活方式</strong>。</p><p>在初入职场的几年，处于何种工作环境、跟谁一起工作、被谁辅导工作，足以影响你的下半辈子。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7条高效能的“黄金定律”</title>
      <link href="/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/"/>
      <url>/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>作者：洞见Neo</p><p>来源：洞见（ID：DJ00123987）</p><hr><p>听过一个笑话。</p><p>有个人跑去问上司：我都有10年工作经验了，为什么你还是不给我涨工资？</p><p>上司说：你不是有10年工作经验，你是把一年工作经验用了10年。</p><p>我认识一个人就是如此，他经常向人吐槽：“我兢兢业业干了6年，老板交代的事我连一句抱怨都没有，加班加点地做完，到头来还不如刚来一两年的新人。”</p><p>他说得悲愤，我只替他难过。</p><p>他的努力，除了证明自己的低效之外，没有任何用处。</p><p><strong>让人成功的，从不是“work hard”，而是“work smart”。</strong></p><p>掌握高效的方法，远胜过低效的苦熬。</p><p>真正厉害的人，其实都赢在了思维上。</p><p><strong>我接触过许多行业精英，这些人无一例外都掌握了一些高效能的黄金定律。</strong></p><p><strong>总结起来，有7条。</strong></p><p>现在看到还不算晚，学会它，像成功者一样思考。</p><p><strong>01</strong></p><p><strong>蘑菇定律</strong></p><p>我们都想在工作上大展拳脚、一战成名，但实际情况却是，默默坐在座位上，不被关注，只能做点杂事。</p><p><strong>得不到指导和提携，偶尔还会被指责、批评，就像长在阴暗角落里的蘑菇，自生自灭。</strong></p><p><strong>这种现象有个专业名词，叫做蘑菇定律。</strong></p><p>得不到阳光又没有肥料的蘑菇，只有长到足够高、足够壮的时候，才会被人关注。</p><p>而那段在黑暗中结茧的时光，是最最难熬的。</p><p>放弃谁都会，只有懂得蛰伏的人，才会羽化成蝶。</p><p>惠普公司前CEO卡莉·费奥丽娜从斯坦福毕业之后，第一份工作是一家地产公司的电话接线员。</p><p>她每天的任务，是打字、复印、收发文件、整理文件。</p><p>虽都是些杂货，但她穿梭于公司的每个角落，观察学习，渐渐对大部分业务都熟练于心。</p><p>蛰伏很久之后，她终于等来了自己的机会。</p><p>公司经纪人问她是否还愿意干点别的什么，于是她得到了一次撰写文稿的机会。</p><p>也就是这次撰文，改变了她的一生。当你被看作是“蘑菇”时，再怎么拼命强调自己是“灵芝”都没用。</p><p><strong>只有利用环境，尽快成长，从蘑菇堆里脱颖而出，人们才会看见你的价值。</strong></p><p><strong>02</strong></p><p><strong>备份定律</strong></p><p>程序员编程的时候，一定会有一个备份。</p><p>万一硬盘故障、代码丢失，没有备份，损失就会相当惨重。</p><p>备份，就是另一手准备。</p><p>人生也是如此。</p><p><strong>当你只给自己留了一种选择，一旦那扇门被关上，便只能作困兽之斗。</strong></p><p>备份，就是另一种可能。</p><p>西方一位哲人说过：“学习用左手剪指甲，因为你的右手未必永远管用。”</p><p><strong>这就是备份定律：思路清晰的人，凡事都有两手准备，从来不是一根筋走到底。</strong></p><p>早年间，我认识一个人，那时他在一家报社做记者。</p><p>别人都羡慕他稳定，但他不相信什么“铁饭碗”，选择自己出去创业。</p><p>三年下来，买了两套房子。</p><p>大家又羡慕他有钱有闲，下半生可以躺平，但他又决定去找一份正式工作。</p><p>几百人的竞争中，被录取为上市公司高级总监。</p><p>如今，他一边工作，一边做自己的项目。</p><p>他说，我不会再担心自己被淘汰。</p><p>人人都希望岁月静好，可现实往往是大江奔流。</p><p>可怕的不是突然的变故，而是遭遇变故之后，连选择的余地都没有。</p><p>给自己多一份备份，就是给人生多一种可能。</p><p><strong>03</strong></p><p><strong>奥卡姆剃刀定律</strong></p><p>你知道自己一周内，处于高效工作状态的时间有多长吗？</p><p>研究数据表明：人平均每周工作45小时，其中有17个小时是根本没有效率的。</p><p><strong>很多人习惯以“多”取胜，但想做的事越多，能完成的就越少。</strong></p><p><strong>于是，我们每日身心疲惫，又成果寥寥。</strong></p><p>想改变现状，首先要学会简化你的工作。</p><p>14世纪，逻辑学家奥卡姆提出一条“剃刀定律”，拉丁文为lex parsimoniae，意思就是简约法则：</p><p><strong>像拿起剃刀一样，把多余的步骤剃掉，把复杂的事情简单化。</strong></p><p><strong>两步可以做成，就不要三步。</strong></p><p>刘慈欣的科幻小说《三体》中有一段故事让我印象非常深刻。</p><p>来自各国的军事家聚在一起，讨论对付敌方游轮“审判日”号的方案，要消灭所有敌人，又不能毁掉船上的硬盘信息。</p><p>有人说用间谍潜伏，有人说用中子弹，有说用化学毒气，甚至还有说用次声波武器……极尽复杂之能事，却没一个可行方案。</p><p>只有一位办事直接果断的警官，说了一句非常简单的话：“两岸立两根柱子，中间拉上纳米丝，船一经过，就会被切割。”</p><p>在场人无不惊叹。</p><p>高手总喜欢一招制敌，击中要害，决不会啰啰嗦嗦大战300回合再结束。</p><p>能化繁为简的人，都抄“近道”走向了成功。</p><p><strong>04</strong></p><p><strong>沃尔森定律</strong></p><p>我们努力提升专业技能，却常忽略了另一件重要的事情：信息。</p><p><strong>很多人比你厉害，并不是能力比你强，而是知道的比你多。</strong></p><p>美国企业家S·M·沃尔森提出过一条定律：把信息和情报放在第一位，金钱就会滚滚而来。</p><p>终身学习的时代，聪明人都知道什么才是让自己变得重要的“加分项”。</p><p>美国弗洛伦萨州有两个年轻人，一个叫约翰，一个叫哈里，同时应聘进入一家蔬菜贸易公司。</p><p>3个月后，约翰直升组长，工资翻倍，哈里还在原地踏步。</p><p>哈里不满，质问老板，老板没有正面解答他的疑惑，而是说：现在公司准备订一批土豆，你去打听看看。</p><p>半小时后，哈里急匆匆跑回来汇报，“集农蔬菜批发中心”有土豆卖。</p><p>老板问，多少钱一斤？有几家在卖？</p><p>哈里愣了一下，转身跑出去问。</p><p>又过了半小时，他回来向老板一一汇报。</p><p>这次老板问他，库存有多少？质量怎么样？能给多少折扣？</p><p>哈里还是不知道，准备再回去问。</p><p>老板叫住了他，把约翰喊了过来。</p><p>约翰有条不紊地说：“20公里外的‘集农蔬菜批发中心’有3家卖土豆的，其中两家是0.9美元一斤，一家是0.8美元一斤。</p><p>对比发现，0.8美元的不但便宜，质量还要更好。</p><p>我跟他们谈了一下，最低0.7美元可以拿到，他们库存有500吨，有货车，可以免费送货……”</p><p>一个不用临时出门打听，就知道市场的实时动态，把握着咨询和信息的人，无需竞争，就已经赢了。</p><p><strong>想要抓住机会，就先学会发现机会。</strong></p><p><strong>比别人先获得情报，并迅速采取行动，这样的你，想不成功都难。</strong></p><p><strong>05</strong></p><p><strong>苹果定律</strong></p><p>如果一堆苹果，有好有坏，你先吃哪个？</p><p>最明智的答案是，先吃好的，把坏的扔掉。</p><p>因为，如果你先吃坏的，好的也会慢慢变坏，于是你永远也吃不到甘甜的好苹果。</p><p>这条“苹果定律”，在工作中也同样适用。</p><p>有时候，让我们晕头转向的，并不是因为多大的工作量，而是我们分不清轻重缓急，不知道该先做什么。</p><p>其实，<strong>先做哪件事，比做了多少事，更为重要。</strong></p><p>戴尔·卡耐基曾说过一个故事：</p><p>著名的心理治疗专家山德尔博士，用非常简单的方法治愈了一位病人。</p><p>这位病人是芝加哥一家大公司的高级主管。</p><p>当他初次来到山德尔的诊所，整个人都处于紧张、不安的状态，时刻都有崩溃的危险。</p><p>他说，他的办公室有3大张写字台，堆满了报表和文件，事情似乎永远都干不完，快把他逼疯了。</p><p>山德尔听过之后只给了一点建议：回去之后，把办公室全部清理干净，只留下最重要的文件。</p><p>病人照他说的办，清理干净写字台，又把留下的重要文件一一处理完。</p><p>之后，事情一到，立马办完。</p><p>再也没有堆积如山的工作威胁着他，他的身体也渐渐恢复了健康。</p><p>这也是时间管理的第一要义：<strong>永远先做最重要的事。</strong></p><p><strong>否则，空把精力耽误在不甚重要的事上，真正要紧的事只会被拖延到时间的死角，无暇也无力处理。</strong></p><p><strong>06</strong></p><p><strong>标杆定律</strong></p><p>上世纪70年代末80年代初，日本成为世界企业界学习的榜样。</p><p>在美国学习日本的运动中，施乐公司提出了名为“标杆定律”的管理方式：竞争对手的水平，就是改进自己的标杆。</p><p>放在今天，这条定律依然是帮我们接近成功的不二法则：<strong>你憎恶的那些对手，都是你最好的老师，最精准的标杆。</strong></p><p>挪威著名剧作家亨利·易卜生写作的时候，总把与他名气相当的剧作家斯特林堡的画像放在桌上，一边写作，一边看看画像。</p><p>有人不解，他说：“斯特林堡是我的死对头，但我不去伤害他，把他放在桌上，让他激励我写作。”</p><p>正是在斯特林堡“目光”的注视下，易卜生完成了《玩偶之家》《社会支柱》等经典之作。</p><p>哪有那么多“丧”，不过是在面对竞争时，你满嘴都是吐槽、挑刺和嫉妒。</p><p>但不与对手过招，你又如何进步？</p><p>瞄准你身边最优秀的人，把他们当做免费的拔高班。</p><p>正是因为对手的存在，你才会持续不断地变强。</p><p>**07<br>**</p><p><strong>卡贝定律</strong></p><p><strong>有时候，成功需要一点格局，这个格局名叫“放弃”。</strong></p><p>美国电话电报公司前总裁卡贝就给员工提出过一条建议：放弃有时比争取更有意义，它是创新的钥匙。</p><p>这就是后来被奉为经典的“卡贝定律”。</p><p>巴菲特有个私人飞行员叫Mike Flint，曾为美国四任总统开过飞机，但他想在事业上做出更大的成就。</p><p>他去请教巴菲特，巴菲特让他写下想要达成的25个目标。</p><p>写完之后，巴菲特又让他圈出其中最重要的5个。</p><p>巴菲特问：你现在知道该怎么做了吧？</p><p>Flint说：知道了，我马上开始着手于这5个目标，另外20个放在闲暇时间再做。</p><p>巴菲特摇摇头：不，你错了，那些你没有圈出来的目标，正是你应该全力避免的事，不要花任何时间和精力在它们上面。</p><p>如果你空有一腔热血，却始终在无足轻重的事情上摸爬滚打、费尽心思，那不是执着，而是愚蠢。</p><p><strong>当方向错了的时候，停下来也是一种进步。</strong></p><p>弄清自己的擅长，了解自己的力量，只有选对了方向，才有可能看见希望。</p><p>当你紧握双手，里面什么也没有；当你打开双手，世界就在你手中。</p><p>爱因斯坦曾说：“如果给我一个小时，去解答一道关于我生死的问题，我会先花55分钟弄清楚这道题到底在问什么。</p><p>一旦清楚了它到底在问什么，剩下的5分钟足以解答这个问题。”</p><p>你看，想法决定做法，做法决定活法。</p><p>你与高手之间，差的只是思维方式的不同。</p><p>了解并掌握这7条黄金定律，让你懂得在最关键的环节用力。</p><p>高效能，才能事半功倍。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构的缓存、限流、分布式锁、幂等的使用方式</title>
      <link href="/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>概述</strong></p><hr><p>互联网应用发展到今天，从单体应用架构到 SOA 以及今天的微服务，随着微服务化的不断升级进化，服务和服务之间的稳定性变得越来越重要，分布式系统之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠，微服务很重要的一个特质就是需要保证服务幂等，保证幂等性很重要的前提需要分布式锁控制并发，同时缓存、降级和限流是保护微服务系统运行稳定性的三大利器。</p><p>随着业务不断的发展，按业务域的划分子系统越来越多，每个业务系统都需要缓存、限流、分布式锁、幂等工具组件， distributed-tools 组件(暂未开源)正式包含了上述分布式系统所需要的基础功能组件。</p><p>distributed-tools 组件基于 tair、redis 分别提供了 2 个 springboot starter ，使用起来非常简单。</p><p>以使用缓存使用 redis 为例， application.properties 添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis.extend.hostName=127.0.0.1</span><br><span class="line">redis.extend.port=6379</span><br><span class="line">redis.extend.password=pwdcode</span><br><span class="line">redis.extend.timeout=10000</span><br><span class="line"></span><br><span class="line">redis.idempotent.enabled=true</span><br></pre></td></tr></table></figure><p>接下来的篇幅，重点会介绍一下缓存、限流、分布式锁、幂等的使用方式。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><hr><p>缓存的使用可以说无处不在，从应用请求的访问路径来看，用户 user -&gt; 浏览器缓存 -&gt; 反向代理缓存-&gt; WEB服务器缓存 -&gt; 应用程序缓存 -&gt; 数据库缓存等，几乎每条链路都充斥着缓存的使用，缓存最直白的解释就是“用空间换时间”的算法。缓存就是把一些数据暂时存放于某些地方，可能是内存，也有可能硬盘。总之，目的就是为了避免某些耗时的操作。我们常见的耗时的操作，比如数据库的查询、一些数据的计算结果，或者是为了减轻服务器的压力。其实减轻压力也是因查询或计算，虽然短耗时，但操作很频繁，累加起来也很长，造成严重排队等情况，服务器抗不住。</p><p>distributed-tools 组件提供了一个 CacheEngine 接口，基于 Tair、Redis 分别有不同的实现，具体 CacheEngine 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public String get(String key);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取指定的key对应的对象,异常也会返回null</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param clazz</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T get(String key, Class&lt;T&gt; clz);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据,忽略过期时间</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @param expiredTime</span><br><span class="line"> * @param unit</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value, int expiredTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于key删除缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">publicbooleaninvalid(String key);</span><br></pre></td></tr></table></figure><p>get 方法针对 key 进行查询， put 存储缓存数据， invalid 删除缓存数据。</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a><strong>限流</strong></h1><hr><p>在分布式系统中，尤其面对一些秒杀、瞬时高并发场景，都需要进行一些限流措施，保证系统的高可用。通常来说限流的目的是通过对并发访问&#x2F;请求进行限速，或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以 拒绝服务（定向到错误页或告知资源没有了）、排队 或 等待（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。</p><p>常见的一些限流算法包括固定窗口、滑动窗口、漏桶、令牌桶，distributed-tools 组件目前基于计数器只实现了固定窗口算法，具体使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 指定过期时间自增计数器，默认每次+1，非滑动窗口</span><br><span class="line">    *</span><br><span class="line">    * @param key 计数器自增key</span><br><span class="line">    * @param expireTime 过期时间</span><br><span class="line">    * @param unit  时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publiclongincrCount(String key, int expireTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 指定过期时间自增计数器,单位时间内超过最大值rateThreshold返回true，否则返回false</span><br><span class="line">    *</span><br><span class="line">    * @param key 限流key</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param expireTime 固定窗口时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publicbooleanrateLimit(final String key, finalint rateThreshold, int expireTime, TimeUnit unit);</span><br></pre></td></tr></table></figure><p>基于 CacheEngine 的 rateLimit 方法可以实现限流， expireTime 只能设定固定窗口时间，非滑动窗口时间。</p><p>另外 distributed-tools 组件提供了模板 RateLimitTemplate 可以简化限流的易用性，可以直接调用 RateLimitTemplate 的 execute 方法处理限流问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @param limitKey 限流KEY</span><br><span class="line">    * @param resultSupplier 回调方法</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param limitTime 限制时间段</span><br><span class="line">    * @param blockDuration 阻塞时间段</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定限流错误码</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public &lt;T&gt; T execute(String limitKey, Supplier&lt;T&gt; resultSupplier, long rateThreshold, long limitTime,</span><br><span class="line">                        long blockDuration, TimeUnit unit, ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       boolean blocked = tryAcquire(limitKey, rateThreshold, limitTime, blockDuration, unit);</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return resultSupplier.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外 distributed-tools 组件还提供了注解 @RateLimit 的使用方式，具体注解 RateLimit 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RateLimit &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流KEY</span><br><span class="line">     */</span><br><span class="line">    String limitKey();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许访问的次数，默认值MAX_VALUE</span><br><span class="line">     */</span><br><span class="line">    longlimitCount()default Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间段</span><br><span class="line">     */</span><br><span class="line">    longtimeRange();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞时间段</span><br><span class="line">     */</span><br><span class="line">    longblockDuration();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位，默认为秒</span><br><span class="line">     */</span><br><span class="line">    TimeUnit timeUnit()default TimeUnit.SECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于注解的方式限流使用代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RateLimit(limitKey = &quot;#key&quot;, limitCount = 5, timeRange = 2, blockDuration = 3, timeUnit = TimeUnit.MINUTES)</span><br><span class="line">public String testLimit2(String key)&#123;</span><br><span class="line">    ..........</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何方法添加上述注解具备了一定的限流能力(具体方法需要在 spring aop 指定拦截范围内)，如上代码表示以参数 key 作为限流 key ，每 2 分钟请求次数不超过 5 次，超过限制后阻塞 3 分钟。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h1><hr><p>在 Java 单一进程中通过 synchronized 关键字和 ReentrantLock 可重入锁可以实现在多线程环境中控制对资源的并发访问，通常本地的加锁往往不能满足我们的需要，我们更多的面对场景是分布式系统跨进程的锁，简称为分布式锁。分布式锁实现手段通常是将锁标记存在内存中，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Tair ，至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。分布式锁相对单机进程的锁之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠。</p><p> distributed-tools 组件提供的分布式锁要具备如下特性：</p><ul><li>互斥性:同本地锁一样具有互斥性，但是分布式锁需要保证在不同节点进程的不同线程的互斥。</li><li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li><li>锁超时:和本地锁一样支持锁超时，防止死锁，通过异步心跳 demon 线程刷新过期时间，防止特殊场景(如 FGC 死锁超时)下死锁。</li><li>高性能、高可用:加锁和解锁需要高性能，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li><li>支持阻塞和非阻塞:同 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock ( long timeOut )。</li><li>公平锁和非公平锁(不支持):公平锁是按照请求加锁的顺序获得锁，非公平锁就相反是无序的，目前 distributed-tools 组件提供的分布式锁不支持该特性。</li></ul><p>distributed-tools 组件提供的分布式锁，使用起来非常简单，提供了一个分布式锁模板：DistributedLockTemplate ，可以直接调用模板提供的静态方法(如下)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 分布式锁处理模板执行器</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey 分布式锁key</span><br><span class="line">    * @param resultSupplier 分布式锁处理回调</span><br><span class="line">    * @param waitTime 锁等待时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定特殊错误码返回</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static &lt;T&gt; T execute(String lockKey, Supplier&lt;T&gt; resultSupplier, long waitTime, TimeUnit unit,</span><br><span class="line">                               ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       AssertUtils.assertTrue(StringUtils.isNotBlank(lockKey), ExceptionEnumType.PARAMETER_ILLEGALL);</span><br><span class="line">       boolean locked = false;</span><br><span class="line">       Lock lock = DistributedReentrantLock.newLock(lockKey);</span><br><span class="line">       try &#123;</span><br><span class="line">           locked = waitTime &gt; 0 ? lock.tryLock(waitTime, unit) : lock.tryLock();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           throw new RuntimeException(String.format(&quot;lock error,lockResource:%s&quot;, lockKey), e);</span><br><span class="line">       &#125;</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           return resultSupplier.get();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a><strong>幂等</strong></h1><hr><p> 在分布式系统设计中幂等性设计中十分重要的，尤其在复杂的微服务中一套系统中包含了多个子系统服务，而一个子系统服务往往会去调用另一个服务，而服务调用服务无非就是使用 RPC 通信或者 restful ，分布式系统中的网络延时或中断是避免不了的，通常会导致服务的调用层触发重试。具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。</p><p>幂等通常会有两个维度：</p><ol><li>空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易。</li><li>时间维度上的幂等，即幂等的保证时间，是几个小时、几天还是永久性的。</li></ol><p>在实际系统中有很多操作，不管操作多少次，都应该产生一样的效果或返回相同的结果。以下这些应用场景也是通常比较常见的应用场景：</p><ol><li>前端重复提交请求，且请求数据相同时，后台需要返回对应这个请求的相同结果。</li><li>发起一次支付请求，支付中心应该只扣用户账户一次钱，当遇到网络中断或系统异常时，也应该只扣一次钱。</li><li>发送消息，同样内容的短信发给用户只发一次。</li><li>创建业务订单，一次业务请求只能创建一个，重试请求创建多个就会出大问题。</li><li>基于 msgId 的消息幂等处理。</li></ol><p>在正式使用 distributed-tools 组件提供的幂等之前，我们先看下 distributed-tools 幂等组件的设计。</p><p><img src="https://aimak.cn/blog_img/tools/midengliucheng.jpeg"></p><p><strong>幂等 key 提取能力：获取唯一幂等 key</strong></p><p>幂等 key 的提取支持 2 中注解：IdempotentTxId、IdempotentTxIdGetter，任意方法添加以上 2 注解，即可提取到相关幂等 key ，前提条件是需要将 Idempotent 注解添加相关需要幂等的方法上。</p><p>如果单纯使用幂等模板进行业务处理，需要自己设置相关幂等key，且要保证其唯一性。</p><p><strong>分布式锁服务能力：提供全局加锁、解锁的能力</strong></p><p>distributed-tools 幂等组件需要使用自身提供的分布式锁功能，保证其并发唯一性， distributed-tools 提供的分布式锁能够提供其可靠、稳定的加锁、解锁能力。</p><p><strong>高性能的写入、查询能力：针对幂等结果查询与存储</strong></p><p>distributed-tools 幂等组件提供了基于 tair 、 redis 的存储实现，同时支持自定义一级、二级存储通过 spring 依赖注入到 IdempotentService ，建议 distributed-tools 幂等存储结果一级存储 tair mdb ，二级存储ldb或者 tablestore ，一级存储保证其高性能，二级存储保证其可靠性。</p><p>二级存储并行查询会返回查询最快的幂等结果。</p><p>二级存储并行异步写入，进一步提高性能。</p><p><strong>高可用的幂等写入、查询能力：****幂等存储出现异常，不影响业务正常流程，增加容错</strong></p><p>distributed-tools 幂等组件支持二级存储，为了保证其高可用，毕竟二级存储出现故障的概率太低，不会导致业务上不可用，如果二级存储同时出现故障，业务上做了一定的容错，针对不确定性的异常采取重试策略，会执行具体幂等方法。</p><p>一级存储与二级存储的写入与查询处理进行隔离，任何一级存储的异常不会影响整体业务执行。</p><p>在了解了 distributed-tools 组件幂等之后，接下来我们来看下如何去使用幂等组件，首先了解下 common-api 提供的幂等注解,具体幂等注解使用方式如下：</p><p><img src="https://aimak.cn/blog_img/tools/common-api-duibi.png"></p><p>幂等拦截器获取幂等 ID 的优先级：</p><ol><li>首先判断 Idempotent 的 spelKey 的属性是否为空，如果不为空会根据 spelKey 定义的 spring 表达式生成幂等 ID 。</li><li>其次判断参数是否包含 IdempotentTxId 注解，如果有 IdempotentTxId ，会直接获取参数值生成幂等 ID 。</li><li>再次通过反射获取参数对象属性是否包含 IdempotentTxId 注解，如果对象属性包含 IdempotentTxId 注解会获取该参数对象属性生成幂等 ID 。</li><li>最后以上三种情况仍未获取到幂等 ID ，会进一步通过反射获取参数对象的 Method 是否定义 IdempotentTxIdGetter 注解，如果包含该注解则通过反射生成幂等 ID 。</li></ol><p>代码使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Idempotent(spelKey = &quot;#request.requestId&quot;, firstLevelExpireDate = 7，secondLevelExpireDate = 30)</span><br><span class="line">publicvoidexecute(BizFlowRequest request)&#123;</span><br><span class="line">   ..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码表示从 request 获取 requestId 作为幂等 key ，一级存储有效期 7 天，二级存储有效期 30 天。</p><p>distributed-tools 除了可以使用幂等注解外，幂等组件还提供了一个通用幂等模板 IdempotentTemplate ，使用幂等模板的前提必须设置 tair.idempotent.enabled&#x3D;true或者redis.idempotent.enabled&#x3D;true ，默认为 false ，同时需要指定幂等结果一级存储，幂等结果存储为可选项配置。</p><p>具体使用幂等模板 IdempotentTemplate 的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 幂等模板处理器</span><br><span class="line">     *</span><br><span class="line">     * @param request 幂等Request信息</span><br><span class="line">     * @param executeSupplier 幂等处理回调function</span><br><span class="line">     * @param resultPreprocessConsumer 幂等结果回调function 可以对结果做些预处理</span><br><span class="line">     * @param ifResultNeedIdempotence 除了根据异常还需要根据结果判定是否需要幂等性的场景可以提供此参数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public R execute(IdempotentRequest&lt;P&gt; request, Supplier&lt;R&gt; executeSupplier,</span><br><span class="line">                     Consumer&lt;IdempotentResult&lt;P, R&gt;&gt; resultPreprocessConsumer, Predicate&lt;R&gt; ifResultNeedIdempotence)&#123;</span><br><span class="line"></span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>request：</strong><br>幂等参数 IdempotentRequest 组装，可以设置幂等参数和幂等唯一 ID 。</p><p><strong>executeSupplier：</strong><br>具体幂等的方法逻辑，比如针对支付、下单接口，可以通过 JDK8 函数式接口 Supplier Callback 进行处理。</p><p><strong>resultBiConsumer：</strong><br>幂等返回结果的处理，该参数可以为空，如果为空采取默认的处理，根据幂等结果，如果成功、不可重试的异常错误码，直接返回结果，如果失败可重试异常错误码，会进行重试处理。</p><p>如果该参数值不为空，可以针对返回幂等结果进行特殊逻辑处理设置 ResultStatus(ResultStatus 包含三种状态包括成功、失败可重试、失败不可重试)。</p><p><em><strong>作者信息：</strong></em></p><p>孔凡勇，花名云狄，阿里云-开放平台高级技术家，对高并发、高性能、高可用、可伸缩的分布式系统架构设计有丰富经验，Cloud Native坚定拥护者，坚守开发一线打磨匠艺的架构师。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团在全链路压测自动化方面的实践</title>
      <link href="/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="美团在全链路压测自动化方面的实践"><a href="#美团在全链路压测自动化方面的实践" class="headerlink" title="美团在全链路压测自动化方面的实践"></a>美团在全链路压测自动化方面的实践</h1><p>境内度假是一个低频、与节假日典型相关的业务，流量在节假日较平日会上涨五到十几倍，会给生产系统带来非常大的风险。因此，在 2018 年春节前，基于美团基础的压测平台 Quake，我们把整个境内度假业务接入了全链路压测，来系统性地评估容量和发现隐患，最终确保了春节期间系统的稳定。</p><p>在整个过程中，我们意识到，全链路压测在整个系统稳定性建设中占有核心重要的位置，也是最有效的方案。结合实际业务节假日的频率（基本平均一个月一次），如果能够把它作为稳定性保障的常规手段，我们的系统质量也能够得到很好的保障。同时，为了解决周期常态化压测过程中人力成本高、多个团队重复工作、压测安全不可控，风险高等痛点，我们提出了全链路压测自动化的设想。</p><p>通过对压测实施的具体动作做统一的梳理，在压测各个阶段推进标准化和自动化，尽力提升全流程的执行效率，最终达到常态化的目标，如图 1 所示：</p><p><img src="https://static001.infoq.cn/resource/image/d1/22/d132f820e00ae26e629b9ac725721c22.jpg" alt="img"></p><p>图 1 自动化落地整体思路</p><p>另外，在全链路压测的整个周期中，压测安全和压测有效性也是需要一直关注的质量属性。基于这些思考，如图 2 所示，我们把压测自动化需要解决的关键问题进行了归类和分解：</p><ul><li>基础流程如何自动化，提高人效；</li><li>如何自动做好压测验证，保障压测安全；</li><li>压测置信度量化如何计算，保证压测有效。</li></ul><p><img src="https://static001.infoq.cn/resource/image/38/c1/386f0c0cbd05a802f916ec0abc9e39c1.png" alt="img"></p><p>图 2 问题分析</p><p>最终，基于美团基础的压测平台 Quake（在整个系统，主要提供流量录制、回放、施压的功能），设计并实现了全链路自动化压测系统，为不同业务实施全链路压测提效，并确保压测安全。该系统：</p><ul><li>提供链路梳理工具，能够自动构建压测入口链路完整的依赖信息，辅助链路梳理；</li><li>支持链路标注和配置功能，对于无需压测触达的依赖接口，可以通过配置化手段，完成相关接口的 Mock 配置，不用在业务代码中嵌入压测判断逻辑；</li><li>提供抽象的数据构造接口，通过平台，用户可以配置任意的数据构造逻辑和流程；</li><li>在压测前&#x2F;压测中，自动对压测服务和流量做多项校验，保障压测安全性；</li><li>在平日，基于压测计划提供周期性小流量的压测校验，使得业务迭代变更带来的压测安全风险被尽早发现；</li><li>提供压测计划管理功能，通过系统自动调度和控制施压过程，解放人力；同时强制前置预压测，也提高了安全性；</li><li>一键压测，自动生成报告，收集链路入口和告警信息，提供问题记录和跟进功能。</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="系统总体设计"><a href="#系统总体设计" class="headerlink" title="系统总体设计"></a>系统总体设计</h3><p><img src="https://static001.infoq.cn/resource/image/93/cb/93f34b102890c1809d6dd8fc507ee0cb.jpg" alt="img"></p><p>图 3 系统总体逻辑架构</p><p>系统的总体逻辑架构，如图 3 所示，主要包括链路构建&#x2F;比对、事件&#x2F;指标收集、链路治理、压测配置管理、压测验证检查、数据构造、压测计划管理、报告输出等功能模块。通过这些模块，为全链路压测的整个流程提供支持，尽力降低业务部门使用全链路压测的门槛和成本。</p><p>链路构建&#x2F;比对：负责服务接口方法调用链路的构建、更新、存储。</p><p>链路治理：基于构建的链路关系，提供链路中核心依赖、出口 Mock 接口等标注、上下游分析、展示，以及出口 Mock 的配置等功能。</p><p>压测配置管理：自动发现注册服务的 Mafka（美团基于 Kafka 开发的一个分布式消息中间件综合解决方案）&#x2F;Cellar（基于 Tair 开发的分布式 KV 存储服务）&#x2F;Squirrel（基于 Redis-Cluster 模式进行二次开发的分布式缓存系统）&#x2F;Zebra（美团数据库访问层中间件）的压测配置，辅助压测方核查和配置相关配置项。</p><p>压测验证检查：确保系统可压测，通过多种校验手段和机制设计，来保证压测的安全性。</p><p>数据构造：为不同业务压测实施准备基础和流量数据。</p><p>压测计划管理：设定压测执行计划，并依赖“压测控制”模块，自动调度整个压测执行过程。</p><p>故障诊断：依据收集的关键业务&#x2F;服务指标、报警等信息，判断分析服务是否异常，以及是否终止压测。</p><p>置信度评估：从数据覆盖、链路覆盖、技术指标等维度评估压测结果的置信度，即与真实流量情况下各评估维度的相似性。</p><p>非功能性需求说明：</p><ul><li>可扩展性</li><li>能够兼容不同业务线数据构造逻辑的差异性。</li><li>能够支持不同的流量录制方式。</li><li>安全性</li><li>集成 SSO，按用户所属团队分组，展示所属的压测服务信息。对关键操作留存操作日志。</li><li>压测验证检查，是确保压测安全的关键。支持周期性压测验证，能发现待压测服务可压测性随时间的退化。</li><li>可重用性</li><li>长远看，链路构建、事件&#x2F;指标收集&#x2F;故障诊断等模块，在稳定性领域是可重用的基础设施，按独立通用模块建设。</li></ul><p>约束说明：</p><ul><li>基于 Quake 搭建，流量的录制、回放、施压等依赖 Quake。</li><li>以下对部分关键模块设计做详细介绍。</li></ul><h2 id="链路治理模块设计"><a href="#链路治理模块设计" class="headerlink" title="链路治理模块设计"></a>链路治理模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/60/89/6060c68e8ee1eb2d6856a59c5b484c89.png" alt="img"></p><p>图 4 链路治理示意图</p><p>链路治理模块是基于链路构建模块实现的。链路构建模块，底层是以闭包表的方式存储两个维度（服务和接口）的链路关系的，会周期自动地构建或更新。</p><p>链路治理模块主要提供链路入口选取、链路标注、服务出口分析、出口 Mock 配置等功能。如图 4 所示，注册压测的服务构成了压测服务的范围，也就确定了各个链路的边界。通过系统自动构建的树结构方式的链路关系，可以辅助压测方对整个链路的梳理，它解决了以往链路梳理靠翻代码等低效手段，缺少全链路视角无法做到完备梳理等问题。</p><p><img src="https://static001.infoq.cn/resource/image/d0/7a/d08f41a776cbe9a9f6141bda4798067a.png" alt="img"></p><p>图 5 出口 Mock 配置化</p><p>同时，针对整个压测范围，依赖接口可以做人工标注。哪些需要 Mock，哪些不需要 Mock，如此压测特有的链路信息能够得到持续的维护。</p><p>对于需要 Mock 的外部接口（如图 4 中的接口 C），待压测系统通过引入专有 SDK 的方式，获得出口配置化 Mock 的能力。如图 5 所示，这里使用了美团酒旅 Mock 平台的基础能力，采用 JVM-Sandbox 作为 AOP 工具，对配置的需要 Mock 的外部接口做动态能力增强。在接口调用时，判断是否是压测流量，是的话走 Mock 逻辑，做模拟时延处理，返回提前配置的响应数据。这样的话，第一，简化了出口 Mock 的操作，业务代码里 Mock 逻辑 0 侵入；第二，把之前本地 Mock 与借助 Mockserver 的两种解决方案用一种方案替代，便于统一管理；第三，在实际压测时，平台还可以通过 SDK 收集 Mock 逻辑执行的数据，自动与后台标注的 Mock 数据对比，来确保应该被 Mock 的出口确实被 Mock 掉。</p><h2 id="数据构造模块设计"><a href="#数据构造模块设计" class="headerlink" title="数据构造模块设计"></a>数据构造模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/f9/20/f9a2e1b507526e109982ecac0359b620.png" alt="img"></p><p>图 6 数据构造</p><p>数据构造模块是为了解决不同业务对于基础数据和流量数据的差异化构造流程。提出了两个关键的概念：数据构造逻辑和数据构造流程。数据构造逻辑，是数据构造的细粒度可复用的基本单元，由一段 Java 代码表示。平台提供统一抽象的数据构造接口，基于 Java 动态编译技术，开发了一个 Java 版的脚本引擎，支持构造逻辑的在线编辑与更新。同时，基于美团 RPC 中间件泛化调用能力，构建了泛化调用工具，帮助用户把外部基础数据构造接口的调用集成到一个数据构造逻辑中。</p><p>数据构造流程，定义了压测基础数据和流量数据生成的整个流程。通过与 Quake 的交互，获取原始真实的线上数据；构建了一个简版的流程引擎，在统一设定的流程中，如图 6 所示，通过在标准扩展槽中，配置不同类型的数据构造逻辑和执行顺序，来定义整个数据构造执行的流程；最后，把构造的流量数据与 Quake 压测场景绑定，作为后续 Quake 压测施压中，场景回放流量的来源。</p><p>通过这样的设计，能够支持任意数据构造逻辑，通用灵活。同时集成了 Quake 已有的流量录制功能，一键执行数据构造流程，大大地提升了效率。</p><h2 id="压测验证模块设计"><a href="#压测验证模块设计" class="headerlink" title="压测验证模块设计"></a>压测验证模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/65/6b/65ba4cd007740cf35772e7ea4633a56b.jpg" alt="img"></p><p>图 7 美团服务压测验证示意</p><p>对于压测安全性的保障，一直是自动化的难点。之前的经验多是在非生产环境压测或预压测过程中，依靠不同服务相关负责人的人工确认。这里针对压测验证，提供两条新的思考角度：一个是从待压测服务系统可压测性的角度看；一个是从压测流量特征的角度看。对于第一个角度，一个服务支持压测需要满足压测数据和流量的隔离。对于不同的系统生态，需要满足的点是不同的，对于美团生态下的服务，可压测的条件包括组件版本支持压测、影子存储配置符合预期等等。</p><p>从这些条件出发，就可以得到下面这些静态的校验项：</p><ul><li>服务依赖中间件版本要求校验；</li><li>Zebra 压测配置校验；</li><li>Cellar&#x2F;Squirrel 压测配置校验；</li><li>Mafka 压测开关同步及校验；</li><li>服务 Mock 逻辑存在性校验。</li></ul><p>而从第二个角度来看，就是关注压测流量下会产生哪些特有的流量特征数据，通过这些特有的数据来确保压测的安全性。这里主要有三类数据：美团分布式追踪系统（MTrace）中调用链路的压测标记数据（正常的压测链路应该是一直带有压测标记，直到压测范围的边界节点，可参考图 4）；标记 Mock 的外部接口被调用时，上报的运行数据；基于监控系统得到的压测流量特有的监控数据。利用这些数据，我们设计了三种动态的校验项，发现压测标记丢失、Mock 出口被调用等异常情况：</p><ul><li>MTrace 链路标记校验，从压测链路入口出发，收集压测链路信息，校验压测标记信息传递是否符合预期。</li></ul><p><img src="https://static001.infoq.cn/resource/image/07/11/07d0100434cec699bfbd7b823d369611.png" alt="img"></p><p>图 8 MTrace 链路标记校验示意</p><ul><li>服务 Mock 逻辑压测标记校验，通过增强的校验逻辑，把执行信息上报到平台，与 Mock 配置时的标注数据对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/42/f4/424b9e7782e721f1524796dbd117a5f4.png" alt="img"></p><p>图 9 服务 Mock 压测校验示意</p><ul><li>压测与真实链路比对校验，利用链路治理模块构建链路的能力，采集压测监控数据重构链路，与真实链路对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/31/91/31d13eba73a566e5075e674ff8661691.png" alt="img"></p><p>图 10 压测与真实链路对比示意</p><p>除了明确静态和动态两类压测校验规则，在具体流程安排上，在压测时和平日两个时期执行这些规则。既能把压测校验的压力分散到平时，也能尽快地发现服务因代码迭代引入的新风险。</p><p>在压测时，通过强制前置预压测的流程设计以及静态&#x2F;动态压测校验项的自动执行，保障安全这个事情。校验不通过，给出告警，甚至在允许的情况下直接终止设定的压测计划。</p><p>在平日，通过执行周期性小流量压测校验，在施压过程中对 QPS 做个位数的精细控制，以尽量小的代价快速发现压测范围内压测安全性的退化。</p><h2 id="压测计划管理模块设计"><a href="#压测计划管理模块设计" class="headerlink" title="压测计划管理模块设计"></a>压测计划管理模块设计</h2><p>压测计划管理模块，提供压测计划的提前设定，然后模块能够自动调度和控制整个施压过程。如图 11 所示，这里的压测计划是多个压测场景的组合，包含 QPS 的增长计划等信息，主要分为预压测和正式压测两个阶段。压测计划的自动实施，能够解决尤其多场景组合压测，操作耗时多、多场景压测 QPS 无法同步变更、压测方无法兼顾操作和观测等问题，提升了效率。同时，在压测计划执行状态机里，预压测正常执行完成，状态才能迁移到正式压测的开始状态，提高了压测安全性。</p><p><img src="https://static001.infoq.cn/resource/image/76/3f/76fd6115851f9b4d5503e7995b4e4d3f.png" alt="img"></p><p>图 11 压测计划执行</p><p>从图 11 可以看到，压测计划模块，是整个自动化压测的核心，协同起了各个模块。通过具体的计划任务执行产生的事件，触发了压测验证检查、压测进展播报、收集压测监控&#x2F;告警等数据，来检测服务是否异常，并根据配置来终止压测，能够故障时及时止损。最后，报告生成模块收到压测终止事件，汇总各种信息，自动生成包括压测基本信息等多维度信息的压测报告，节省了一些压测后分析的时间。</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>以下以实际压测的过程来做个案例分享。</p><p><strong>团队&#x2F;服务注册</strong></p><ul><li>设定实施压测的虚拟团队和压测覆盖范围的应用服务。</li></ul><p><img src="https://static001.infoq.cn/resource/image/9b/ea/9b5572017d1fb136366b80241713adea.jpg" alt="img"></p><p><strong>链路治理</strong></p><ul><li>选定压测链路入口，可以得到入口以下的接口链路关系树，便于梳理。</li><li>明确需要 Mock 的外部接口，并做配置，参考“链路治理模块设计”一节。</li></ul><p><img src="https://static001.infoq.cn/resource/image/f4/e4/f4a172982f91243b0cb410c603536ce4.jpg" alt="img"></p><p><strong>应用改造与压测配置</strong></p><ul><li>对待接入压测应用改造，满足“服务的可压测条件”，参考图 7。</li><li>压测应用依赖中间件配置，系统依据构建的链路信息，能够自动发现。提供统一配置和核对的页面功能。</li><li><img src="https://static001.infoq.cn/resource/image/a4/85/a442826c7c90692248e423c781f5e985.png" alt="img"></li></ul><p><strong>Quake 准备</strong></p><ul><li>压测自动化系统是基于 Quake 构建的，流量录制、回放、施压等依赖于此。因此需要到 Quake 上配置流量录制的“流量任务”和压测执行的“压测场景”。</li></ul><p><img src="https://static001.infoq.cn/resource/image/4a/7e/4a7e7fe8a1d2f3aa98661c3779ef977e.png" alt="img"></p><p><strong>数据构造</strong></p><p>配置数据构造逻辑，当然已有的逻辑都是可复用的单元，可以先查看已有逻辑是否能满足自己的需要。</p><p><img src="https://static001.infoq.cn/resource/image/8c/37/8c44afa725c533ddf446e446d3d84537.jpg" alt="img"></p><ul><li>配置数据构造流程。</li></ul><p><strong>压测实施</strong></p><ul><li>设定压测计划，到启动时间，系统会自动启动压测。</li></ul><p><img src="https://static001.infoq.cn/resource/image/7d/1b/7db495027bea72fc8cd1b7ad0d8f651b.png" alt="img"></p><p>压测中，注意关注压测验证校验的告警信息，及时处理。</p><p><img src="https://static001.infoq.cn/resource/image/29/f7/29c96d574b217c5bca4b50cfe99015f7.png" alt="img"></p><ul><li>压测后，可查看压测报告。记录和跟进发现的问题。</li><li><img src="https://static001.infoq.cn/resource/image/a9/39/a986012a95836b5b44ab064c775d3939.png" alt="img"></li></ul><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>目前，压测自动化系统已经投入使用，美团酒店和境内度假的全部团队已经接入，有效地提升了压测效率。后续会在两个大方向上持续建设升级，一个是把全链路压测放到“容量评估与优化”领域来看，不仅关注整体系统的稳定性，同时也期望兼顾成本的平衡；另一个是与稳定性其他子领域的生态集成，比如故障演练、弹性伸缩等等，在更多场景发挥压测的作用。最后，通过这些努力，使得线上系统的稳定性成为一个确定性的事情。</p><p><strong>作者简介：</strong></p><p>欧龙，美团研发工程师，2013 年加入美团，目前主要负责境内度假交易稳定性建设等工作。</p><p><strong>本文转载自技术琐话公众号。</strong></p><p><strong>原文链接：</strong><a href="https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w">https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理的4C模型</title>
      <link href="/2019/10/28/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E7%9A%844C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/10/28/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E7%9A%844C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="管理的4C模型"><a href="#管理的4C模型" class="headerlink" title="管理的4C模型"></a>管理的4C模型</h2><p>提升团队的综合执行力是每一个管理者的核心工作，在企业中的执行力绝非是军队命令式的管理，而是建立在尊重，共赢的基础上，高品质，高效率地完成相关工作，如何实现这一目的呢？管理的4C模型是一个非常有效的方法。</p><p><img src="https://p9.itc.cn/q_70/images03/20210810/2853f61d7ad149129faf20876669d052.jpeg"></p><p><strong>C:CLARITY(澄清):</strong> 这里需要提醒管理者是管理者讲清楚了并不等于员工理解了，如何确保员工100%地理解工作任务是确保执行的前提，在我们过去的培训项目调查中，员工的工作偏差有45%是由于双方对工作的理解不一致导致的。在澄清任务过程中，管理者需要做到：</p><p><img src="https://p0.itc.cn/q_70/images03/20210810/e246215bef104e5fb3080f85fa6b4474.jpeg"></p><p>如何做到、简洁、完整、清晰</p><p>如何根据员工的不同情况选择不同的沟通风格及策略</p><p>如何确认员工已经理解了任务</p><p>常见错误及注意事项是什么？</p><p><img src="https://p4.itc.cn/q_70/images03/20210810/5441bd99088c4f8ba1dd2c2cd0f5448a.jpeg"></p><p><strong>C:COMPETENCE(胜任)：</strong>这里是管理者用人与辅导下属的问题，胜任不仅仅是能力上的胜任，还指态度上的胜任，也是提升团队执行力的重要因素，为了提升团队的胜任度，管理者可以：</p><p><img src="https://p5.itc.cn/q_70/images03/20210810/ea34ec20469c472ebbb3ce54de8b27a8.jpeg"></p><p>选对人吸引与留住优秀人才是一个重要的管理职责</p><p>通过优化工作流程及方法，降低员工完成工作的难度，也降低工作对能力的要求</p><p>分解工作，通过团队合作完成复杂任务</p><p>持续地辅导员工</p><p><strong>C:COMMITMENT(承诺)：</strong>员工胜任工作，也有能力完成任务，但这并不是意味着员工就能高效地执行任务，员工高效地完成任务还需要另外一个条件就是员工发自内心地承诺100%地完成任务，从管理的角度去看，很多时候不是员工不愿意做出承诺，而是面对任务，员工缺乏承诺所需要的条件，包括：</p><p>员工是否有意愿与热情想完成任务</p><p>是否具备了完成任务的条件与资源</p><p>不能完成任务带来的风险与完成任务带来收益的权衡</p><p><strong>C:CONTROL(控制)：</strong>当员工明白了任务、也有能力完成任务，并且也100%的发自内心地承诺完成任务，那么是否就意味着管理者就可以高枕无忧了呢？很显然，有经验的管理者还是会担心出现各种状况，有意思的是越担心的事情则越容易发生，因此100%地保证完成任务，从管理者的角度去看，管理者还需要做好事前、事中（最重要）以及事后的控制：</p><p><img src="https://p5.itc.cn/q_70/images03/20210810/05154139b17c4445a49bbc34b32ee5ed.jpeg"></p><p><strong>在事前：</strong>主要做好计划、澄清与确保胜任即可</p><p><strong>在事中：</strong>管理者需要做好及时获得任务状态并纠正员工的工作偏差</p><p><strong>在事后：</strong>做好总结与复盘</p><p>那么在强调执行的同时，如何通过有效的沟通改善执行带来的压力并激发员工创造性地解决问题呢？以下的沟通循环将是有效地提升团队执行力的好帮手……</p><p><img src="https://p8.itc.cn/q_70/images03/20210810/cc48300c5ac1435ba9fc6060776666c1.jpeg"></p><p>团队有效沟通是项目类管理执行的前提，团队组员之间能够创造出和谐的氛围与环境，沟通中清晰表达每个人的意愿与信息，促进想法的交换，最终形成双方的接受，这是团队每个人都需要知道团队共创的几个主要问题：</p><p><strong>准备：</strong>事前准备好主题信息、参会者资料、主持人等</p><p><strong>创造良好的氛围：</strong>即便遇到冲突也不要上来就指责对方，沟通多了你会发现，对方在沟通中的情绪有很多时候比沟通的内容更重要</p><p><strong>信息交换：</strong>在这个步骤项目成员需要具备2个核心的能力：结构化讲解+逻辑聆听的能力</p><p><strong>达成一致：</strong>就达成一致的部分形成清晰的行动指南，对未达成一致的部分，搁置再谈！</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能优化高阶总结</title>
      <link href="/2019/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%AA%A8%E7%81%B0%E7%BA%A7%EF%BC%8C%E9%AB%98%E9%98%B6%E7%A5%9E%E6%8A%80/"/>
      <url>/2019/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%AA%A8%E7%81%B0%E7%BA%A7%EF%BC%8C%E9%AB%98%E9%98%B6%E7%A5%9E%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：崔皓 转载于 <a href="https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg">https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg</a></p></blockquote><h2 id="MySQL性能优化之骨灰级，高阶神技"><a href="#MySQL性能优化之骨灰级，高阶神技" class="headerlink" title="MySQL性能优化之骨灰级，高阶神技"></a>MySQL性能优化之骨灰级，高阶神技</h2><hr><p>大量信息的存储和查询都会用到 MySQL，因此它的优化就对系统性能提升就尤为重要了。<br>由于 MySQL 的优化范围较广，从软件到硬件，从配置到应用，无法一一道来。<br>今天就从开发者的角度介绍一下 MySQL 应用优化。包括数据类型，数据表查询&#x2F;修改，索引和查询等几个方面。</p><h2 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h2><hr><p>字段是用来存放数据的单元，设计好字段是设计数据库的第一步，同样会影响到系统的性能。<br>设计字段有一个基本的原则，保小不保大，也就是能够用字节少的字段就不用字节数大的字段，目的是为了节省空间，提高查询效率。<br>更小的字段，占用更小的磁盘空间，内存空间，更小的 IO 消耗。下面针对使用场景，说一些字段类型选取的经验，供大家参考。</p><ul><li><p>数值类型</p><ul><li>手机号：通常我们在存储手机号的时候，喜欢用 Varchar 类型。</li><li>如果是 11 位的手机号，假设我们用 utf8 的编码，每位字节就需要 3 个字节，那么就需要 11*33&#x3D;33 个字节来存放；如果我们使用 bigint，只需要 8 个字节就可以存放。</li><li>IP 地址：同上，IP 地址也可以通过 int（4 字节）在存放，可以通过 INET_ATON() 函数把 IP 地址转成数字。这里需要注意溢出的问题，需要用无符号的 int。</li><li>年龄，枚举类型：可以用 tinyint 来存放，它只占用 1 个字节，无符号的 tinyint 可以表示 0-255 的范围，基本够用了。</li></ul></li><li><p>字符类型</p><ul><li>Char 和 Varchar 是我们常用的字符类型。char(N) 用来记录固定长度的字符，如果长度不足 N 的，用空格补齐。</li><li>varchar(N) 用来保存可变长度的字符，它会额外增加 1-2 字节来保存字符串的长度。</li><li>Char 和 Varchar 占用的字节数，根据数据库的编码格式不同而不同。Latin1 占用 1 个字节，gbk 占用 2 个字节，utf8 占用 3 个字节。</li><li><strong><strong>用法方面，如果存储的内容是可变长度的，例如：家庭住址，用户描述就可以用 Varchar。</strong></strong></li><li><em><strong><strong>如果内容是固定长度的，例如：UUID（36 位），或者是 MD5 加密串（32 位），就可以使用 Char 存放。</strong></strong></em></li></ul></li><li><p>时间类型</p><ul><li><p><em>Datetime 和 Timestamp 都是可以精确到秒的时间类型，但是 Datetime 占用 8 个字节，而 Timestamp 占用 4 个字节。</em></p></li><li><p><strong>所以在日常建表的时候可以有限选择 Timestamp。不过他们有下面几个小区别，需要注意的。</strong></p></li><li><p><strong>区别一：存储数据方式不一样。</strong></p></li><li><ul><li><strong>Timestamp 是转化成 utc 时间进行存储，查询时，转化为客户端时间返回的。</strong></li></ul></li><li><p>区别二：两者存储时间的范围不一样。</p><ul><li><em>Timestamp 为’1970-01-01 00:00:01.000000’ 到’2038-01-19 03:14:07.999999’。</em></li><li><strong>Datetime为’1000-01-01 00:00:00.000000’到’9999-12-31 23:59:59.999999’。</strong></li></ul></li></ul></li></ul><h2 id="数据表查询-x2F-修改优化"><a href="#数据表查询-x2F-修改优化" class="headerlink" title="数据表查询&#x2F;修改优化"></a>数据表查询&#x2F;修改优化</h2><hr><p>说了如何高效地选择存储数据的类型以后，再来看看如何高效地读取数据。MySQL 作为关系型数据库，在处理复杂业务的时候多会选择表与表之间的关联。<br>这会导致我们在查询数据的时候，会关联其他的表，特别是一些多维度数据查询的时候，这种关联就尤为突出。<br>此时，为了提高查询的效率，我们会对某些字段做冗余处理，让这些字段同时存在于多张表中。<br>但是，这又会带来其他的问题，例如：如果针对冗余字段进行修改的时候，就需要对多张表进行修改，并且需要让这个修改保持在一个事物中。<br>如果处理不当，会导致数据的不一致性。这里需要根据具体情况采取查询策略，例如：需要跨多张表查询公司销售额信息。<br>由于，销售信息需要连接多张表，并且对销售量和金额做求和操作，直接查询显然是不妥当的。<br>可以生成后台服务，定时从相关表中取出信息，计算出结果放入一张汇总表中。<br>将汇总表中需要查询的条件字段加上索引信息，提高查询的效率。这种做法，限于查询数据实时性不强的情况。<br>在高速迭代开发过程中，业务变化快，数据库会根据业务的变化进行迭代。所以，在开发新产品初期，表结构会面临频繁地修改。<br>MySQL 的 ALTERTABLE 操作性能对大表来说是个问题。MySQL 执行修改表结构操作的方法是，用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。<br>这一操作需要花费大量时间，如果内存不足而表数据很大，并且索引较多的情况，会造成长时间的锁表。<br>有极端的情况，有些 ALTERTABLE 操作需要花费数个小时甚至数天才能完成。</p><h3 id="这里推荐两种小技巧："><a href="#这里推荐两种小技巧：" class="headerlink" title="这里推荐两种小技巧："></a>这里推荐两种小技巧：</h3><hr><ul><li>先把数据库拷贝到一台非生产服务器上，在上面做修改表操作，此时的修改不会影响生产库。<ul><li>　　修改完毕以后在做数据库的切换，把非生产数据库切换成生产库。不过需要注意的时候，在做表结构修改的时候，生产库会生成一些数据。这里需要通过脚本根据时间区间导入这部分数据。</li></ul></li><li>“影子拷贝”，即生成一张表结构相同的不同名新数据表（更改数据结构以后的表）。<ul><li>　<em>然后导入原表的数据到新表，导入成功以后停止数据库，修改原表和新表的名字，最终将数据访问指向新表。</em></li><li><strong>在运行正常以后，将原表删除。这里有现成的工具可以协助完成上述操作，“online schema change”,”openark toolkit”</strong></li></ul></li></ul><p>　　如果只是删除或者更改某一列的默认值，那么直接可以使用 Alert table modify column 和 Alert table alert column 来实现。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><hr><p>说了字段和表再来聊聊索引。对于索引的优化网上有很多的说法，都是在实际工作中总结出来的，这里没有一定的标准。<br>针对我们使用比较多的 InnoDB 的存储引擎（使用的 B-Tree 索引），推荐几个方法给大家。</p><ul><li><p>索引独立</p><ul><li>“索引独立”是指索引列不能是表达式的一部分，也不能是函数的参数。例如：假设 User 表中分别把 create_date 和 userId 设置为索引。</li><li><code>select</code> <code>*``from</code> <code>user</code> <code>where</code> <code>date``(create_date)=curdate()``selectuserId ``from</code> <code>user</code> <code>where</code> <code>userId+1=5</code></li><li><em>类似上面的语句就是将索引作为了函数中的参数和表达式的一部分，是不推荐这样使用的。</em></li></ul></li><li><p>前缀索引</p><ul><li>有时候索引字段长度较大，例如：VarChar，Blob，Text。当搜索的时候，这会让索引变得大且慢。<br>通常的做法是，可以索引开始的部分字符，这样可以节约索引空间，提高索引效率。<br>既然索引全部字符行不通，那么索引多少字符就是我们要讨论的问题了<br>这里需要引入一个概念，索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数的比值。<br>索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</li><li>例如：有一张 user 表，其中有一个字段是 FirstName，如何计算这个字段的选择性，如下：</li><li><code>Select1.0*``count``(``distinct</code> <code>FirstName)/``count``(*) ``from</code> <code>user</code></li><li>假设这个结果是 0.75 再用 left 函数对该字段取部分字符，例如取从左开始的 3，4，5 个字段。</li><li>分别查看其选择性，目的是看当选择多少字符的时候，选择性最接近 0.75。</li><li><code>从左取3个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,3))/``count``(*) ``from</code> <code>user``结果为0.58</code>“__mceDel”<code> </code>style&#x3D;<code>&quot;background-color: rgba(255, 255, 255, 1); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px&quot;</code>&gt;　&#96;</li><li><code>从左取4个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,4))/``count``(*) ``from</code> <code>user``结果为0.67</code></li><li><code>从左取5个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,5))/``count``(*) ``from</code> <code>user``结果为0.74</code></li></ul><p>　　从上面尝试发现，字段 FirstName 取左边字符，从 3-5 的获取可以看出，当从左边取第 5 个字符的时候，选择性 0.74 最接近 0.75。</p></li></ul><p> 　　因此，可以将 FirstName 的前面 5 个字符作为前缀索引，这样建立索引的效果基本和 FirstName 全部字符建立索引的效果一致。而又不用将 FirstName 整个字段都当成索引。</p><p>　　　于是可以用下面语句修改索引信息：　　　</p><p>　　　　Alter tableuser add key(FirstName(5))</p><h2 id="多列索引及其顺序"><a href="#多列索引及其顺序" class="headerlink" title="多列索引及其顺序"></a>多列索引及其顺序</h2><hr><p>多列索引，顾名思义就是将多列字段作为索引。假设在 user 表中通过搜索 LastName 和 FirstName 条件来查找数据。</p><p>可能出现以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `*``from` `user` `where` `LastName = ‘Green’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName = ‘Jack’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `(FirstName = ‘Jack’ ``or` `FirstName =‘Michael’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName &gt;=‘M’ ``and` `FirstName&lt;‘N’</span><br></pre></td></tr></table></figure><p>如果分别在 LastName 和 FirstName 上面建立索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName = ‘Jack’</span><br></pre></td></tr></table></figure><p>当运行上面这段代码的时候，系统会让选择性高的 SQL 的索引生效，另外一个索引是用不上的。因此我们就需要建立多列索引（合并索引）。</p><p> 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter` `table` `user` `add` `key``(LastName, FirstName)</span><br></pre></td></tr></table></figure><p>既然定义了多列索引，那么其中的索引顺序是否也需要考虑呢？在一个多列 B-Tree 索引中，索引列的顺序意味着，索引首先按照最左列进行排序，其次是第二列。<br>索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的 ORDERBY、GROUPBY 和 DISTINCT 等子句的查询需求。<br>所以，多列索引的顺序是需要考虑的。这里给出的建议是，将选择性最高的索引列放在前面。<br>接上面的例子，还是 LastName 和 FirstName 作为多列索引。看谁应该放前面。</p><p>通过按照选择性规则，写如下 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先计算LastName的选择性``Selectcount(disctinc LastName)/``count``(*) ``from` `user``结果为0.02</span><br></pre></td></tr></table></figure><p>　　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再计算FirstName的选择性``Selectcount(disctinc FirstName)/``count``(*) ``from` `user``结果0.05</span><br></pre></td></tr></table></figure><p>　　</p><p>FirstName 的选择性要高于 LastName 的选择性。因此调整多列索引的顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter` `tableuser ``add` `key``(FirstName ，LastName)</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h2><hr><p>当使用 Select 的数据列只用从索引中取得，而不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</p><p>例如：User 表中将 LastName 作为索引。如果写以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `LastName ``from` `user</span><br></pre></td></tr></table></figure><p>LastName 及作为索引，又在查询内容中显示出来，那么 LastName 就是覆盖索引。<br>覆盖索引是高效查找行方法，通过索引就可以读取数据，就不需要再到数据表中读取数据了。</p><p><em>而且覆盖索引会以 Usingindex 作为标示，可以通过 Explain 语句查看。</em></p><p><em><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184646933-1864623193.png" alt="img"></em></p><p> 覆盖索引主要应用在 Count 等一些聚合操作上，提升查询的效率。例如上面提到的 Selectcount(LastName) from user 就可以把 LastName 设置为索引。</p><p> <em>还有可以进行列查询的回表优化，如下：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `LastName, FirstName ``from` `user` `where` `LastName=‘Jack’</span><br></pre></td></tr></table></figure><p>如果此时 LastName 设置为索引，可以将 LastName 和 FirstName 设置为多列索引（联合索引）。<br>避免回表行为的发生。这里的回表是指二级索引搜索到以后，再找到聚合索引，然后在查找 PK 的过程。</p><p>这里需要通过两次搜索完成。简单点说就是使用了覆盖索引以后，一次就可以查到想要的记录，不用在查第二次了。</p><p><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184741370-1321441480.png" alt="img"></p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>作为程序开发人员来说，使用得最多的就是 SQL 语句了，最多的操作就是查询了。<br>我们一起来看看，哪些因素会影响查询记录，查询基本原理是什么，以及如何发现和优化 SQL 语句。</p><h2 id="影响查询效率的因素"><a href="#影响查询效率的因素" class="headerlink" title="影响查询效率的因素"></a><strong>影响查询效率的因素</strong></h2><hr><h2 id="一般来说，影响查询的因素有三部分组成，如下："><a href="#一般来说，影响查询的因素有三部分组成，如下：" class="headerlink" title="一般来说，影响查询的因素有三部分组成，如下："></a><strong>一般来说，影响查询的因素有三部分组成，如下：</strong></h2><ul><li><p><strong>响应时间，</strong>由两部分组成，他们分别是，服务时间和排队时间。服务时间是指数据库处理查询花费的时间。</p><p>排队时间是指服务器因为等待某些资源花费的时间。例如：I&#x2F;O 操作，等待其他事务释放锁的时间。</p></li><li><p><strong>扫描记录行数，</strong>在查询过程中数据库锁扫描的行记录。理想情况下扫描的行数和返回的行数是相同的。不过通常来说，扫描的行数都会大于返回记录的行数。</p></li><li><p><strong>返回记录行数，</strong>返回实际要查询的结果。</p></li></ul><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a><strong>查询基础</strong></h2><hr><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184843459-995983551.png" alt="img"></h2><p> 说了影响查询效率的因素以后，来看看查询这件事情在 MySQL 中是如何运作的，可以帮助我理解，查询优化工作是在哪里进行的：</p><ul><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。</li><li>解析器对 SQL 进行解析，它通过关键字将 SQL 语句进行解析，并生成一棵对应的“解析树”。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。</li><li>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，并且验证权限。例如，检查数据表和数据列是否存在，解析名字和别名看是否有歧义。</li><li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端。</li></ul><h2 id="如何发现查询慢的-SQL"><a href="#如何发现查询慢的-SQL" class="headerlink" title="如何发现查询慢的 SQL"></a><strong>如何发现查询慢的 SQL</strong></h2><hr><p>说了影响查询缓慢的因素以及查询的基本流程以后，再来看看如何发现查询慢的 SQL。这里 MySQL 提供了日志，其中可以查询执行比较慢的 SQL。</p><p><strong>①查看慢查询日志是否开启</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOWVARIABLESLIKE``&#x27;%slow_query_log%&#x27;``;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184941956-1039646703.png" alt="img"></p><p><strong>②如果没有开启，通过命令开启慢查询日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGLOBAL slow_query_log=1;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185011545-561623481.png" alt="img"></p><p> ③设置慢查询日志的时间，这里的单位是秒，意思是只要是执行时间超过 X 秒的查询语句被记录到这个日志中。这里的 X 就是你要设置的。（下面的例子设置的是 3 秒）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGLOBAL long_query_time=3;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185031869-815149857.png" alt="img"></p><p> ④查看多少 SQL 语句是超过查询阀值的（3 秒）</p><p> <img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185101608-213106289.png" alt="img"></p><h2 id="Explain-分析-SQL-查询"><a href="#Explain-分析-SQL-查询" class="headerlink" title="Explain 分析 SQL 查询"></a><strong>Explain 分析 SQL 查询</strong></h2><hr><p>**通过上面的方法可以知道哪些 SQL 花费了较多的时间，那么如何对这些 SQL 语句进行分析呢。毕竟，我们的目的是通过分析以后，优化 SQL 从而提高其性能。<br>**</p><p>将 Explain 关键字放在要执行的 SQL 语句前面，可以模拟优化器执行 SQL 语句，从而知道 MySQL 是如何处理你的 SQL 语句的。</p><p><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185115583-1996317626.png" alt="img"></p><p> 上面每个字段的含义，在这里不展开描述。</p><h2 id="SQL-优化建议"><a href="#SQL-优化建议" class="headerlink" title="SQL 优化建议"></a><strong>SQL 优化建议</strong></h2><hr><p><strong>如果发现慢查询的 SQL，我们就需要针对其问题进行优化。这里针对几个常见的 SQL 给出一些优化建议。<br>类似 SQL 优化的文章和例子在网上种类繁多，千奇百怪。建议在优化之前，先查看慢查询日志和 Explain 的语句，再进行优化，做到有的放矢。</strong></p><p><strong><strong>①Count 优化</strong></strong></p><p>从 user 表中搜索 id 大于 7 的所有用户。如果是 InnoDB 存储引擎会进行逐行扫描，如果表中记录比较多，性能就是问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(*) ``from` `user` `where` `id&gt;7</span><br></pre></td></tr></table></figure><p>如果先将所有的行数 Count 出来，再减去 id&lt;&#x3D;7 的记录，这样速度就会快一些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `(``select` `count``(*) - (``select` `count``(*) ``from` `user` `where` `id &lt;=7) ``from` `user``)</span><br></pre></td></tr></table></figure><p>如果有一个货物表 items，其中有一个 color 字段来表示货物的颜色，如果需要知道颜色是蓝色或者红色的货物的数量，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(color=‘blue’ ``or` `color=‘red’) ``from` `items``Select` `count``(*) ``from` `items ``where` `color=‘blue’ ``and` `color=‘red’</span><br></pre></td></tr></table></figure><p>不过颜色本身是除斥的字段，所以可以优化成下面的 SQL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(color=‘blue’ ``or` `null``) ``as` `blue, ``count``(color=‘red’ ``or` `null``) ``as` `red ``from` `items</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="②GROUPBY-优化"><a href="#②GROUPBY-优化" class="headerlink" title="②GROUPBY 优化"></a><strong>②GROUPBY 优化</strong></h3><p>MySQL 通过索引来优化 GROUPBY 查询。在无法使用索引的时候，会使用两种策略优化：临时表和文件排序分组。<br>可以通过两个参数 SQL_BIG_RESULT 和 SQL_SMALL_RESULT 提升其性能。<br>这两个参数只对 Select 语句有效。它们告诉优化器对 GROUPBY 查询使用临时表及排序。<br>SQL_SMALL_RESULT 告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。<br>如果是 SQL_BIG_RESULT，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectSQL_BUFFER_RESULTfield1, ``count``(*) ``from` `table1 groupby field1</span><br></pre></td></tr></table></figure><p>　　</p><p>假设两个表做关联查询，选择查询表中的标识列（主键）分组效率会高。<br>例如 actor 表和 film 表通过 actorId 做关联，查询如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `actor.FirstName, actor.LastName,``count``(*) ``from` `film ``inner` `join` `actor using(actorId)``Group` `by` `actor.FirstName,actor.LastName</span><br></pre></td></tr></table></figure><p>就可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `actor.FirstName, actor.LastName, ``count``(*) ``from` `film ``inner` `join` `actor using(actorId)``Group` `by` `film.actorId</span><br></pre></td></tr></table></figure><p>　　</p><p>③Limit<br>Limit 对我们再熟悉也不过了，特别是在做分页操作的时候，经常会用到它。但在偏移量非常的时候问题就来了。<br>例如，Limit 1000，20 就需要偏移 1000 条数据以后，再返回后面的 20 条记录，前面的 1000 条数据是被抛弃掉的。<br>按照上例 SQL 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `name` `from` `user` `order` `by` `id limit1000,20</span><br></pre></td></tr></table></figure><p>这里通过 id 索引到第 1001 条记录，然后取 20 条记录。这里利用 id 的索引的优势直接跳过了前面 1000 条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `name` `from` `user` `where` `id&gt;=1001order ``by` `id limit 20</span><br></pre></td></tr></table></figure><p>　　</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>从开发者的角度了解 MySQL 的应用优化。从数据类型的选择开始，针对数值类型，字符类型，时间类型进行了举例说明。<br>接下来谈到，作为数据表的查询，修改的优化，我们应该注意哪些细节。然后，聊了索引独立，前缀索引，多列索引，覆盖索引的优化方法。<br>最后，针对使用最多的查询优化进行了探讨。从影响查询的因素到查询基础，再到如何发现慢查询，用几个 SQL 优化的建议结束了我们的 MySQL 应用优化之旅。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中常用Git 命令总结</title>
      <link href="/2019/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="工作中常用Git-命令总结"><a href="#工作中常用Git-命令总结" class="headerlink" title="工作中常用Git 命令总结"></a>工作中常用Git 命令总结</h1><blockquote><p>git整理的有好几篇了，不过确实比较重要，又收集一些比较实用的</p></blockquote><ul><li><p>分支操作</p></li><li><p>暂存操作</p></li><li><p>回退操作</p></li><li><p>标签操作</p></li><li><p>常规操作</p></li><li><ul><li>git创建项目仓库</li><li>忽略已加入到版本库中的文件</li><li>取消忽略文件</li><li>拉取、上传免密码</li></ul></li></ul><hr><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ol><li>git branch 创建分支</li><li>git branch -b 创建并切换到新建的分支上</li><li>git checkout 切换分支</li><li>git branch 查看分支列表</li><li>git branch -v 查看所有分支的最后一次操作</li><li>git branch -vv 查看当前分支</li><li>git brabch -b 分支名 origin&#x2F;分支名 创建远程分支到本地</li><li>git branch –merged 查看别的分支和当前分支合并过的分支</li><li>git branch –no-merged 查看未与当前分支合并的分支</li><li>git branch -d 分支名 删除本地分支</li><li>git branch -D 分支名 强行删除分支</li><li>git branch origin :分支名 删除远处仓库分支</li><li>git merge 分支名 合并分支到当前分支上</li></ol><h1 id="暂存操作"><a href="#暂存操作" class="headerlink" title="暂存操作"></a>暂存操作</h1><ol><li>git stash 暂存当前修改</li><li>git stash apply 恢复最近的一次暂存</li><li>git stash pop 恢复暂存并删除暂存记录</li><li>git stash list 查看暂存列表</li><li>git stash drop 暂存名(例：stash@{0}) 移除某次暂存</li><li>git stash clear 清除暂存</li></ol><h1 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h1><ol><li>git reset –hard HEAD^ 回退到上一个版本</li><li>git reset –hard ahdhs1(commit_id) 回退到某个版本</li><li>git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)</li><li>git reset HEAD file 撤回暂存区的文件修改到工作区</li></ol><h1 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h1><ol><li>git tag 标签名 添加标签(默认对当前版本)</li><li>git tag 标签名 commit_id 对某一提交记录打标签</li><li>git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注</li><li>git tag 列出所有标签列表</li><li>git show 标签名 查看标签信息</li><li>git tag -d 标签名 删除本地标签</li><li>git push origin 标签名 推送标签到远程仓库</li><li>git push origin –tags 推送所有标签到远程仓库</li><li>git push origin :refs&#x2F;tags&#x2F;标签名 从远程仓库中删除标签</li></ol><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><ol><li>git push origin test 推送本地分支到远程仓库</li><li>git rm -r –cached 文件&#x2F;文件夹名字 取消文件被版本控制</li><li>git reflog 获取执行过的命令</li><li>git log –graph 查看分支合并图</li><li>git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录</li><li>git check-ignore -v 文件名 查看忽略规则</li><li>git add -f 文件名 强制将文件提交</li></ol><h2 id="git创建项目仓库"><a href="#git创建项目仓库" class="headerlink" title="git创建项目仓库"></a>git创建项目仓库</h2><ol><li>git init 初始化</li><li>git remote add origin url 关联远程仓库</li><li>git pull</li><li>git fetch 获取远程仓库中所有的分支到本地</li></ol><h2 id="忽略已加入到版本库中的文件"><a href="#忽略已加入到版本库中的文件" class="headerlink" title="忽略已加入到版本库中的文件"></a>忽略已加入到版本库中的文件</h2><ol><li>git update-index –assume-unchanged file 忽略单个文件</li><li>git rm -r –cached 文件&#x2F;文件夹名字 (. 忽略全部文件)</li></ol><h2 id="取消忽略文件"><a href="#取消忽略文件" class="headerlink" title="取消忽略文件"></a>取消忽略文件</h2><ol><li>git update-index –no-assume-unchanged file</li></ol><h2 id="拉取、上传免密码"><a href="#拉取、上传免密码" class="headerlink" title="拉取、上传免密码"></a>拉取、上传免密码</h2><ol><li>git config –global credential.helper store</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术管理者应该管些什么？</title>
      <link href="/2019/10/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E5%BA%94%E8%AF%A5%E7%AE%A1%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
      <url>/2019/10/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E5%BA%94%E8%AF%A5%E7%AE%A1%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="技术管理者应该管些什么"><a href="#技术管理者应该管些什么" class="headerlink" title="技术管理者应该管些什么"></a>技术管理者应该管些什么</h1><p><strong>作者介绍</strong></p><blockquote><p><strong>韩锋</strong>，**CCIA（中国计算机行业协会）常务理事、Oracle ACE、宜信技术研发中心主任工程师。精通多种关系型数据库，曾任职于当当网、TOM在线等公司，曾任多家公司首席DBA、数据库架构师等职，多年一线数据库架构、设计、开发经验。著有《SQL优化最佳实践》一书。</p></blockquote><p>在讲清楚技术管理者需要做哪些工作之前，我们通过一个驾马车的比喻类比描述下。</p><p>在驾驶马车之前，我们首先要看看马车的定位是什么(拉人?运货?等);其次，要看看目的地在哪里，该走哪条路，朝哪个方向行进;再次是当前马匹的情况怎么样(满员?伤病?等)。这些对应到管理中，就是得弄清楚团队的基本职能、工作目标、团队情况及可选路径，它们代表这方向性的东西，可简称为“管理规划”。</p><p>当我们开始驾驶马车时，至少需要做两件事：一边抓住马缰，关照好马的状态和组织分工;一边挥舞马鞭，协调好整个马队的前进方向和节奏，让马匹一起用力把车拉到一个个里程碑和目的地，完成一段一段的旅程。前者对应到管理中，很像是在做人和组织相关的工作，我们称为“带人”，或者“团队建设”;后者对应到管理中，很像是在完成一个个项目或一项项任务，我们称为“做事”，或者叫“任务管理”。</p><p>综合上面的比喻示例，可抽象概括下技术管理者需完成的工作如下，下面将展开说明。</p><p>(以下内容部分来自果见-刘建国系列文章)。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/8e40627a69be4ed088835ab666f1ebfe.jpeg" alt="img"></p><p><strong>一、管理规划：“敢问路在何方?”</strong></p><p>管理规划对于技术管理者来说，非常之重要。在日常工作中，技术管理者往往需面对大量纷繁复杂的事情，特别是有很多救火类的工作。但在忙乱之余，是不是有一个“全盘规划”的指引，清不清楚把团队带往何方，这才是不同leader领导水平的差距所在。出现问题就解决问题，是一种“问题驱动型思维”。而今天我们所谈论的”管理规划”，就是要回答”把团队带往何方”的这个方向性问题。通过理清未来的发展来理顺当前问题的带团队思路，称之为“规划驱动型思维”。</p><p><strong>1、职能</strong></p><p>在我们开始管理规划之初，首先要弄清楚就是“这是一支背负着什么样职责和使命的团队”。在明确之后，才能决定了你需要设定什么样的工作目标，并通过哪些要素来衡量你的目标;决定了你需要什么样的人加入你的团队，以及需要多少;还决定了你选择什么样手段，投入什么样的资源来完成工作。这个问题是如此重要，可将其作为管理规划的第一个要素，称之为团队“职能”;这是管理工作的起点。</p><p><strong>1)职能层次</strong></p><p>团队职能可分为两个层次：基本的职责和升华的使命。前者解决的是团队生存问题，后者解决的是团队发展问题。</p><p>职责。是团队职能的下限，即至少要完成的工作。如果这些职责都搞不定，意味着团队的基本价值都不能体现。一般来说，团队的基本职责，是由上级给定的，上级在把这个团队交给你负责的时候，已经给你提了期待，只不过有的上级会明确交代，而有的上级默认你很清楚。所以，你无论如何都需要弄清楚团队的基本职责，否则肯定会失职。</p><p>使命。是团队职能的上限，即，如果我们团队做得好，就能承担更大的职责，体现出更大的价值。使命达成后的愿景，常常是令人期待和憧憬的。使命愿景常常是团队leader自己的规划和设想。上级一般不会作出这样的要求，最多就是提一下期待，团队做不到也不会认为是团队失职。</p><p><strong>2)设定职能方法</strong></p><p><strong>①收集信息。</strong>可从多角度收集方方面面的信息，包括上级、同级和下级。对上级而言，需关注上级对团队的期待和要求，特别是用什么维度来衡量团队工作。团队的初始定位和基本职责，一般都是上级直接给定的。同级，则需关注与兄弟部门的职能边界，做好无缝衔接、共同发展。下级则可与大家讨论对团队工作的看法，以及对未来发展的期待。这也可为后续的沟通做好铺垫。当然最为重要的是管理者本身对工作的理解、期许。</p><p><strong>②提炼和升华。</strong>团队的职责和使命，不能只停留在leader的脑海中，为了方便记忆和传播，则必须从上述信息中进行提炼和升华。提炼和升华有三个要点：</p><p>职责的提炼。基于上级的期待和要求，以及你对业务核心价值的理解，最好用上级和团队成员、兄弟部门都易于理解的语言，对职责进行简短化提炼，并尽可能长时间稳定下来。</p><p>使命的升华。基于基本职责，寻找团队对于部门和公司的独特价值，并和行业发展趋势结合，设定自己的期待。要注意使用基于“结果”的描述，而非基于“过程”的描述，基于结果的描述会更有使命感。</p><p>确定衡量维度。一般来说，团队的职责和使命决定了衡量的维度，但是如果有明确的关于衡量维度的说法，会让员工对职责和使命有更深刻的理解。需要根据自己团队的职能，向员工明确传递，什么指标维度对团队是最重要的。</p><p><strong>③确认和主张。</strong>提炼完成之后，接下来就是确认和主张。确认主要是和自己的上级确认，得到上级的认同和支持后，就可以向团队内外进行主张了。主张的过程，就是一个长期宣贯的过程，不可能一蹴而就。这也是团队的文化建设的重要组成部分。</p><p><strong>2、目标</strong></p><p>在明确了团队职能后，下一步就是确定目标。类别前面的比喻，就是需要明确要去的目的地在哪里，才能评估需要什么样的马、多少匹，以及有哪些路线可以选择。这个关于”目的地在哪里”的问题，是管理规划的第二个要素，称为“目标”。</p><p><strong>1)设定目标意义</strong></p><p>问题明确的目标，对于技术团队管理非常具有意义。</p><p>目标设定，可以实现资源的有效配置。明确的目标可以让你把资源投注在有效的方向上，从“该做什么”去调配资源，而不是“能干什么”。</p><p>清晰明确的目标可以凝聚团队成员的力量，让大家劲往一处使，提升团队凝聚力。大家因为相同的目标而并肩作战，在一起取得成就的过程中建立起深厚的“革命友情”，这对凝聚力有莫大帮助。</p><p>清晰的目标，还是执行力的必要要素。回想一下，有多少工作是因为目标不够清晰，而最终有始无终。</p><p>清晰的目标还能提升判断力。当面对某个突发状况快速决策，你非常清晰想要的是什么。</p><p>清晰的目标本身就是激励，当员工很清楚自己的工作目标，方向感很清晰的时候，他们更容易进入一种投入度非常高，沉浸其中、物我两忘的工作状态。</p><p><strong>2)目标设定原则</strong></p><p>目标的设定，可遵从SMART原则。</p><p>Specific - 明确性。把目标设定到可以衡量的程度，就叫做明确了。常见的误区是，只做过程化描述，而没有结果。因此，面对这类问题和挑战的钥匙叫做“结果导向的描述”。</p><p>Measurable - 可衡量性。跟明确性紧密相关。在具体实施上，可参考有量化指标的KPI，或者目标导向的OKR形式。</p><p>Attainable - 可达性。标准上，不能定一个完全实现不了的很高的目标，也不能定一个不需要努力就能实现的很低的目标。定义一个有挑战且努力能达到的目标，才是恰当的。</p><p>Relevant - 相关性。对于技术团队来说很难跑偏，因为技术这个角色决定了其工作内容必定是和上、下游及上级目标相关联的。</p><p>Time-bound - 时限性。所有的目标都是基于一定时限的，缺少时间限制的目标没有意义。</p><p><strong>误区：以资源定目标</strong></p><p>常见的一类问题是基于现有资源做目标，而不是基于远方的目标往前推。常见的说法就是，“我们团队只能做到个程度”、“这些项目能做完就不错了”等。其实，更为合理的做法是，从上级的角度来讲，你的团队需要保证哪几项重要的结果，然后再看看如何调配和补充资源。简言之，破解之道就是“以终为始”。</p><p><strong>误区：目标变来变去</strong></p><p>定义的目标，有时不得不面临一些调整。有些是因为业务的原因，有些是因为上级领导变更的缘故等等。应对此类问题的方法就是“设定专业目标”，用专业目标来增强团队的内在定力。简言之，就是“做正确的事”。</p><p><strong>误区：事情太多忙不过来</strong></p><p>这是一个优先级的问题，可遵循“重要&#x2F;紧急象限法”进行分析。具体可参考下图，原则就是将“重要紧急”转换为“重要不紧急”，尽量减少“不重要紧急”类工作;以上措施就可以减少上述问题。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/443c8da203e440be8308cfd473819e46.jpeg" alt="img"></p><p><strong>3、团队</strong></p><p>针对团队，可以从多个视角来看待。</p><p><strong>1)根据团队目标去梳理团队</strong></p><p>作为管理规划的一部分，团队规划是管理者必须重点考量问题。这里需要去设定”团队目标”，即在某个时间点，团队发展成什么状态。有如下衡量指标：</p><p>团队的规模。也就是你团队有多少人，这其中要理清楚有多少人是现有的，有多少人是接下来要新增的，即实际人数和预算人数，加起来就是你规划的团队总规模。</p><p>团队的分工。即，你的团队都负责哪些业务，每个业务配置了多少人力，以及这些人员都如何分工，人力分布和业务目标是否匹配等。</p><p>团队的梯队。一个团队的梯队情况代表了团队的成熟度和复原力。梯队成熟的团队，不会因为一些偶然的因素(例如核心人员离职)就随便垮掉。复原力强的团队只是短暂影响部分业务进展，但是不会伤筋动骨、元气大伤，很快就会恢复正常。</p><p><strong>2)从资源角度来审视团队</strong></p><p>在很多互联网公司里，技术团队往往是最昂贵的资源和成本。作为一个管理者，在盘点自己当前人力和预算人力的时候，需要有成本意识，要考虑投入这么多资源和成本是否值得，是否合理。其实，即便你不考虑这个问题，你的上级也会考虑，所以，你预算人力的时候，最好能给出十分充分的理由。</p><p><strong>3)从人才培养角度看梯队规划</strong></p><p>对团队的盘点，还需要从人才培养角度来看。即，到下一个时间节点，你需要重点培养出哪些人，给他们什么样的平台和空间，以及你有能力提供给他们什么指导和支持，期待他们能够胜任什么职能和角色。</p><p><strong>4、路径</strong></p><p>在选择路径之前，需先考虑一个重要因素-资源。脱离资源评估的路径选择是没有意义的。</p><p><strong>1)资源评估</strong></p><p>这里所提到的资源，不仅仅包括通常意义上的“人、才、物”，还包括其他一些容易忽略的因素。</p><p>人。最为常见的资源，为参与到项目的人员。</p><p>财&#x2F;物。一般也是围绕着团队的人员来说的。</p><p>时间。最容易忽视的一类资源，时间长短直接影响人的投入。这里需要参考上级的预期，及你个人的客观分析，需要综合你对紧急重要程度的理解做出判断。</p><p>信息。是另外一个常被忽视的资源。有的时候，你需要更多的公司内外的信息，你的工作如果需要特殊的信息和数据，需要提前和上级沟通，寻求必要的支持。</p><p>权限。是否需要获得某些权限，作为资源投入。比如获得绩效评估的权限，以此来掌握人员激励的手段等。</p><p><strong>2)路径评估</strong></p><p>站在管理者视角上，就需要评估一段时间内的产出效率。完成一项工作，原来还有很多的手段可以选择。对于你来说，不同的方案意味着着多大程度的成本呢，可以尝试使用如下评估表。把你认为的“大”“中”“小”填入下表中。这个表格最大的意义不在于让你去评估每一种方案的成本大小，而在于扩展你的管理思路，看到解决问题手段的多样性，避免思路过于单一，就达到目的了。在不同的公司、不同的期待之下，不同的管理者会做出不同的选择。这不同的选择会带来不同的效果，同时也意味着不同的成本。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/26b48f944acd47ccaeb6b84cb7e4f50a.jpeg" alt="img"></p><p>对于自研来说，由于靠自己团队的力量，资金开销比较低，维护成本也可控;而由于需要边学边做，时间成本会比较高。</p><p>对于招聘来说，不确定性比较高，招聘顺利固然好，但招聘不顺则时间完全不可预期，整体上时间成本比较高。</p><p>对于借调来说，如果能借调到合适的人，各方面的成本是最低的，但是需要这个事情足够重要才能获得支持。</p><p>对于跨部门合作来说，项目推进的可控性取决于合作情况，这里最大的风险就是合作成本能否控制住。</p><p>对于外包来说，时间和资金成本一般都可控，用来做尝试性项目或者demo是比较合理的。但如果是长期的任务，你会发现外包的解决方案可维护性比较差，迁移和替换的成本会比较高。</p><p>采购云服务，对于中小公司来说，其实是很好的解决方案，对人才成本、维护成本、时间成本，都可以降得很低，特别适合初创公司，所以你看业内的云服务层出不穷，确实有价值。</p><p>商业方案，是时间成本很低，资金成本略高的一种方案。在应急的情况下，或者是公司非核心业务的场景下，这倒不失为一种好的解决方案。</p><p><strong>二、团队建设：“众人拾柴火焰高”</strong></p><p>团队建设的核心，在于提高“效率”。参照之前的”工作目标达成分解图”，可将其划分为个体、个体间和团队三个层次。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/e42773433d1e4b21a19d2db36dc7097f.jpeg" alt="img"></p><p>针对个体而言，重点在于提升能力和个人意愿。</p><p>针对个体间而言，在于加强分工和协作。</p><p>针对团队，在于构建梯队和文化认同。</p><p><strong>1、能力</strong></p><p><strong>1)能力分层</strong></p><p>员工的工作能力是由三个方面共同决定的，下图可见。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/855cebce2af34c7fb9f145873bc041b3.jpeg" alt="img"></p><p>人格力量。通常是指一个人在面对某一情形时稳定的态度和表现，比如迎难而上、坚持不懈、积极正向、主动担当等等。这些人格力量对于个人能否搞定一件事情有时至关重要，但是培养起来却不是一朝一夕的，关键在于平时。</p><p>通用能力。没有一个统一的标准，比如我会把沟通表达能力、团队协作能力、快速学习能力等作为重要的通用能力，并和我的团队达成共识。这些能力是可以迁移的，会伴随员工受益终身。</p><p>专业能力。对于技术人来说，一般是指技术能力。很多公司都有技术能力衡量标准和体系，用于评估工程师的技术水平。所以，工程师专业能力的评价维度和标准相对于通用能力更加有据可循。</p><p><strong>2)鼓励学习</strong></p><p>可以组织多种形式，鼓励员工学习。</p><p>第一类：帮助员工自学。可组织内外部培训、购买书籍等形式。</p><p>第二类：相互交流讨论。可通过定期复盘、技术交流、代码审核等手段进行。</p><p>第三类：工作实践。给员工独立负责重要工作的机会，并给予辅导和反馈。</p><p>对于提升员工个人能力来说，最关键的往往不是学习的方法，而是学习的意愿。对于很多团队来说，并不缺少学习的机制，而是没有能够有效激发员工的学习动力。主动学习的员工总会是少数派，不只是公司的员工如此，社会生活中的人们亦是如此，所以有人说，“学习是反人性的事情!”。可通过下面多种手段，激发很多员工的学习动力了，你甚至可以把学习和成长放入团队文化建设当中。当然，如果你要把学习作为团队文化的一部分，那就需要你自己首先有学习的“基因”。</p><p>推 - 给予压力，推动他们学。比如提出明确的学习机制、工作要求，必要时与绩效、晋升机会、调薪挂钩。</p><p>拉 - 指明方向，引导他们学。通过树立榜样、配备导师、辅导方式，引导大家学习。</p><p>放 - 给予空间，让他们自主学。在可控情况下，给予员工空间、机会及耐心，让员工充分施展。</p><p><strong>2、激励</strong></p><p>1)理论 - 马斯洛的需求层次模型</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/14a18dc853b74ff4822d35e980eee4a6.jpeg" alt="img"></p><p>最原始的驱动力主要来源于对生存和安全的渴望，需求层次处于“马斯洛需求模型”的最底层。这类驱动力是人们为了寻求生存下去的基本要素而努力。</p><p>第二类驱动，就是“奖励好的行为、惩罚坏的行为”，也就是人们经常念叨的“胡萝卜加大棒”。这是被广泛认同的激励方式，也是当前大部分管理者最常用的激励手段。</p><p>第三类驱动，更加强调自驱力。随着中国经济和文化发展，物质奖惩和别人的评价变得不如从前那么令人关注。很多 90 后职场人有着自己笃定的价值观。此外，在这样一个信息时代，员工的创造力更能为公司创造价值，而创造力需要更多的自主和差异。</p><p>2)如何激励</p><p>第一，激励要立体。你需要从单一的激励维度，升级为更加立体的激励体系，从而适应新职场环境的要求。</p><p>第二，激励在平时。不能指望一些临时性刺激方案来做好激励，激励体系的搭建应在平时。当员工跟你提离职的时候，它就已经不再是一个激励问题了。</p><p>第三，激励要设计。由于每个人的业务特点不同、团队性质不同、管理风格不同、员工特征不同、问题挑战不同，所以不要迷信别人给你的激励建议，我更建议你充分考虑自己面临的实际情况，结合自己的特质和激励框架，来设计适用于自己的激励体系。</p><p><strong>3、分工</strong></p><p>不能简单地认为分工一定是件好事。分工是不是好事取决于协作水平，协作水平又受限于管理者的管理水平。通常分工的目的是为了实现规模化(多人干大事)或实现专业化分工(用人之长、避人之短)。</p><p><strong>组织结构</strong></p><p>从一个业务所涉及的各个角色的分工情况来看，互联网领域最常见的组织结构有两类，一类是矩阵式的，一类是BU式的。</p><p>矩阵式结构。员工按照角色被划分到不同的团队，每个团队都有自己的负责人。要做项目的时候，会有专门的项目经理来向各个角色的leader协调人力，然后把申请到的各个角色的人组织在一起去完成这个特定项目。一旦项目完成之后，人员将回归各自团队去迎接新的项目。人力资源是按照角色“横向”来组织的，而项目执行是按照任务“纵向”来推动的，就形成了一个纵横交错的矩阵式结构，所以叫矩阵式组织结构。这类组织架构的好处是各个角色团队的专业度都会很高，而且角色归属感比较强，资源调配灵活;但不足之处是项目执行起来较为低效，因为每次都要重新申请人力，而且每次的项目团队都需要重新磨合。</p><p>BU式结构。就是“业务单元”式，也叫事业部制，是指做某项业务所有的人员和资源都统一调配，无论这个事业部是大是小，都角色齐全。这样做的好处是团队长期合作磨合充分，协作效率高，执行速度快;不足是各种角色自己都要有，资源冗余和浪费比较多。另外，由于某些角色不在业务主干上，团队规模比较小，能力要求也不高，所以其角色专业度很难提升。</p><p><strong>4、协作</strong></p><p>“就是只要一句话，甚至是一个动作、一个眼神，对方就知道是什么意思。”显然，协作水平很高的团队，就好像一部良好运转的机器一样，既有分工，又彼此紧密连接，形成一个有机整体。其核心在于：</p><p>一是建立协作机制，通过机制来约定协作的动作，以此来保证大家“动作协调”;</p><p>二是提升团队凝聚力，通过提升团队成员间的信任度、认同度和默契度来降低协作成本，提高协作效率。</p><p>可以说，“硬件”靠机制，而“软件”靠凝聚力。</p><p><strong>1)提升凝聚力</strong></p><p>设立共同愿景。想提升团队凝聚力的时候，总是希望大家“心往一处想，劲往一处使。这就要求团队首先要有一个使命和愿景，有一个共同的长远目标，供大家“往一处想”。如果团队有着自己的使命，又能得到团队成员的普遍认同，大家会更容易朝着一个方向共同努力，也更容易肩并肩地一起迎接挑战，即所谓的“志同道合”。</p><p>提升员工归属，让员工从心里就认为自己是团队的一份子。你要分给他一份职责，人的内心深处是渴望承担适当的责任的。有当员工清楚自己能为团队做出什么贡献的时候，才会心安，才会感受到自己是团队的一份子。要让员工清楚他肩负的职责对于团队的意义，让他觉得自己做的事有价值，这就是所谓的“事对”。</p><p>要营造良好的团队人际关系，让彼此间形成紧密的连接。团队成员间良好的关系，和团队凝聚力的提升是互为因果的，所以不要小看能促进员工间关系的一些小事，恰恰是这些小事，能够促使员工间的合作关系走上正向循环的轨道，员工会因为喜欢和团队的人相处而觉得有归属感。这就是所谓的“人对”。</p><p>明确亮出团队的文化价值观。团队的文化和价值观是否是员工认同和欣赏的，决定了他能否长期留在团队。价值观方面的冲突是很难调和的，好的团队文化本身就是一个筛选器，最终留在团队发挥核心作用的都会是认同团队价值观的人。因喜欢一个团队的文化和氛围而产生归属感，这就是所谓的“味对”。</p><p>加强相互了解。团队成员间需要不断深入地相互了解和认同。可以通过一些方式增加员工间了解，例如团建活动。这里是需要花点心思去设计的，对增进大家的了解和信任做必要的设计。</p><p>共同面对挑战。一起面对挑战的时候，特别能够让大家拧成一股绳。显然一起扛过枪的兄弟，感情是很铁的，毕竟是经历过不离不弃的并肩作战。可以通过攻关项目、紧急故障等，甚至是一些组队的对抗性游戏，都可以得到提升。</p><p><strong>5、梯队</strong></p><p>一个团队的梯队，就好像一个团队的“骨架子”，这“骨架子”是否健康良好，决定了团队是否健壮。其重点在于梯队的规划和建设方面。规划在前文已谈到，建设就是需要选拨人，并培养成核心骨干的过程。</p><p><strong>1)选拔人才</strong></p><p>对骨干人员的选择要遵从你团队建设的理念。除了基本的个体能力要强，有成长潜质之外。更重要的是强调其协作能力，因为这些骨干未来不是一个人工作，而是要带领团队的。要强调其行为风格和价值观与团队整体文化相匹配。例如团队强调“勇于创新”，那么一个墨守成规的人员显然不适合成为骨干去培养。</p><p><strong>2)培养人才</strong></p><p>对齐期待，达成共识。常用方式是IDP，即个人发展计划。可以将IDP与绩效结合起来，就是说培养人才也是要以做出绩效为依托，而不只是为了培养而培养。通过IDP可以对齐你和培养对象彼此的期待，让他清楚你关注的是什么，在这个事情上形成共识，从而形成良好的互动和有效的反馈。但在这过程中需要注意，不要以晋升等作为承诺。一方面，晋升等是需要靠员工表现来获得，而不是靠承诺;另一方面也要留有培养失败的退路，避免不必要的人才流失。</p><p>提供机会，做好授权。培养的过程是需要在做事上体现的，你需要给培养对象足够的发挥空间，也就不可避免地要做工作授权。</p><p><strong>工作授权三段法</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/e837205563b04f07bc00595b7b82d7d7.jpeg" alt="img"></p><p>授权整个过程可划分为事前、事中、事后三个阶段。其重点在于事前的安排和事后的反馈。因为既然是授权，事中最好不要干涉太多，只做约定好的check和支持就好。</p><p>事前阶段。管理者首先要明确此次授权的初衷是什么。如果是有多重目标，那么主次关系如何。进而让培养对象明确你的期待是什么。此处可沿用目标管理的SMART原则，双方需要明确要求、口径等。在完成授权任务后，需听取其对工作的看法和思路，进而大致判断是否可行，规避风险。最后约定一个沟通机制，为事中做铺垫。</p><p>事中阶段。需要管理者定期了解工作进度、评估风险，必要时给予支持，而不是放任自流。在支持方面可遵循“授人以渔”的原则。</p><p>事后阶段。对于授权后的工作结果进行评估，并与培养对象充分沟通反馈。注意你的授权目标本身不仅仅只有事情，还有培养目标的。对于培养对象在工作中好的表现，要给予充分肯定，特别是要其优势所在;针对不足之处提供1~2条修改建议，以利后续改进。</p><p><strong>6、文化</strong></p><p>团队文化就好像是团队的气质和调性，它会吸引“气味相投”的人持续加入，而把不符合团队气质的人筛选出去，越来越鲜明的团队价值观让大家紧密地聚拢在一起，从而让团队越来越“结实”，越来越“经得起折腾”，不断增强团队的耐力和韧劲。关于团队文化部分，我之前有文章专门说明，这里就不展开了。</p><p><strong>三、任务管理：“不以规矩，不成方圆”</strong></p><p>我们研究任务管理，就是为了把事情做出来，产出实实在在的业绩和成果。作为结果导向的管理者，这才是管理工作的落脚点。同时，也是验证管理规划是否合理、团队建设是否有效的最重要的标准和依据。对任务执行，可划分为三个阶段：</p><p>在做事之前，我们需要回答的问题是：要做哪些事?先做哪件，后做哪件?也就是分清楚轻重缓急，也叫优先级梳理。</p><p>在做事过程中，我们要确保事情的进展按照计划推进，尽在掌握之中，也就是有效执行。</p><p>在做事之后，我们要复盘做事的整个过程，并从过去的经验之中抽取一些流程机制，以便以后在类似的场景下也可以做得更好、更顺畅。</p><p><strong>1、轻重缓急</strong></p><p>对于每个团队来说，当下能做的工作是有限的，增加并发并不会让大家的产出更高效，所以，多任务并行问题归根结底还是优先级问题，即，你要优先保证哪项工作的顺利进行。</p><p><strong>1)重要紧急四象限</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/c00a9160cdc3483392b0cf12c933fa4c.jpeg" alt="img"></p><p><strong>2)判断标准</strong></p><p>如果做，收益是否很大?收益越大，这个事情就越重要。</p><p>如果不做，损失是否很大?损失越大，这个事情就越紧急。</p><p><strong>3)应对策略</strong></p><p>对于“计划内的工作”，关注它在一个规划周期内的价值和收益有多大。收益越大就越重要，也就越需要给予相匹配的优先级、资源和关注度;收益相对不大，就放入“To do list”，作为待办任务处理。</p><p>对于“计划外的工作”，看损失是否足够大，这里包括自身损失和因中断正常工作带来的损失。损失够大，就按照紧急任务安排，以止损为核心目的;如果损失可控，就放入“计划内工作”列表。</p><p><strong>4)持续改进</strong></p><p>原则上，管理者的中心应该在那些“重要不紧急”的工作上，这些是对团队长期受益的，应该作为主要目标。</p><p>“重要且紧急”的工作，要分析其紧急原因，将其流程化、自动化，逐步过渡到不紧急的状态。</p><p>“不重要紧急”的工作，往往是事务类的，可交由下属处理，长期可通过自动化改进其紧急状态。</p><p>“不重要不紧急”的工作，要反思其价值，是否仍然作为核心工作之一。</p><p><strong>2、有效执行</strong></p><p>在项目执行中，是否能有效执行，取决于多个因素。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/4ce8392efb0d4422a8ce5ed43d98bc8c.jpeg" alt="img"></p><p>目标清晰。在执行之初，就需要对目标有明确且具体的定义，具体到可执行层面;而且要确保上下级对其理解是一致，没有偏差。当目标出现变化时，要做到及时同步。如果目标不清晰，必然会引起员工在紧急程度、质量水平和效果取舍上的偏差，最后也就引发了执行上的偏离预期。</p><p>责任明确。明确工作的“唯一”负责人，避免出现无人负责、多人负责等情况。负责人要起到对应的责任，有关项目中所有涉及项目执行和协调的问题都要负责。</p><p>机制健全。不要沉迷于依靠个人完成项目，需要有完善的流程和机制，让员工做事有依据。同时对应还需要必要的监督机制，不要将“流程机制”束之高阁。</p><p>沟通到位。在执行中，强调主动沟通意识，要做到沟通闭环，而不要想当然。</p><p><strong>3、流程机制</strong></p><p>在任务执行之后，针对任务中可抽象出来的部分，可制订必要的流程机制。在指定过程中，可明确几个原则：明确目标、责任到人、检查复核、降低成本、全员共识。避免出现为了流程而制定流程的情况，要做到尽量简化，能解决具体问题。</p><p><strong>观点：人靠谱 OR 机制靠谱?</strong></p><p>人的靠谱度的方差比机制大，即，人靠谱的时候比机制靠谱，人不靠谱的时候会比机制更加不靠谱。即便是最靠谱的员工，也会由于身体状态、精神状态、情绪状态以及外部干扰变得偶尔不靠谱;而机制的意义就在于，当人不靠谱时，事情也不至于变得很差。所以，机制是为了保证做事的“下限”的。同时，机制有很好的迁移性和传承性，不会随着某个人的缺位而产生大的影响。因此，必要的机制是不可或缺的。</p><p><strong>番外篇：“如何做好技术判断?”</strong></p><p>作为技术管理者，和普通管理者最大的区别，就是”技术”二字，这也是技术管理者最鲜明的标签和最大的竞争力。从技术工程师到技术管理者的转型，有很多做事的思路和方法都需要转变，其中一个重要的转变就是你和技术的关系。其核心在于从技术实现者到技术应用者的转变，不断提升的是技术的使用能力，而技术实现能力由于投入的时间越来越少，会逐渐减弱。从技术管理者自身来说，既然你选择了做更大的事情，就不得不适当放弃一些细节，放弃一些技术实现能力，不断提升你的技术判断力，让团队行走在正确的方向上。</p><p><strong>1、角色转换</strong></p><p>技术管理者，对待技术与技术人员会有所区别，是有个角色的转换。</p><p>技术实现者：程序设计能力、编码实现能力、技术攻坚能力和技术评估能力，都是需要具备的，主要关心的是”怎么做”，属于”how”的范畴。</p><p>技术应用者：技术评估能力变得尤其重要，因为技术管理者主要关心的是”要不要做”、”做什么”，属于”why”和”what”的范畴，是要在综合评估之后，做出决策和判断的</p><p><strong>2、评估维度</strong></p><p><strong>1)结果评估</strong></p><p>要回答”要不要做”，希望拿到什么结果，你要从哪几个维度去衡量结果，从哪几个技术指标去验收成果。事关每项工作的效果和业绩，对结果的评估能力最为关键。虽然结果验收都是放在项目完成后，但是在事先就要明确如何验收，这样才能让大家有的放矢，以终为始。</p><p><strong>2)可行性评估</strong></p><p>可行性有两层含义：一是”能不能做”，二是”值不值得”。作为技术管理者需要做好角色转换，更多从”值不值得”着手，就是成本收益问题。收益，往往是显而易见的;而成本，就有很多方面需要考虑了，这正是体现技术判断力的地方。</p><p>资源成本 — “人财物时”。需要投入多少人、多少时间，甚至是多少资金和物资在该项目上，这项成本相对容易评估。</p><p>维护成本。这是评估技术方案时要重点考虑的。考虑维护成本是技术管理者和架构师视野宽阔、能力成熟的体现。这里面包括：技术选型成本、升级成本、问题排查成本、代码维护成本等。</p><p>协作成本。多人协作所增加的时间精力开销。一个方案的协作方越多，需要沟通协调的成本也就越高，可控度越低。如果可能的话，尽量减少不同团队和人员之间的耦合，这样会大大降低协作成本。</p><p>机会成本。这是技术管理者做决策时要意识到的。即当你把人力、时间花在这件事上，同时就等于放弃了另外一件事，而没有做另外这件事将带来什么样的影响呢?就是你要考虑的机会成本。</p><p><strong>3)技术风险评估</strong></p><p>也叫技术风险判断力。即，有哪些技术风险需要未雨绸缪，考虑该技术方案带来最大损失的可能性和边界，以及在什么情形下会发生。这项评估工作很考验技术管理者的技术经验和风险意识，而且需要借助全团队的技术力量来做出准确判断。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术团队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程总结</title>
      <link href="/2019/09/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这篇文章将总结多线程并发的各种处理方式，希望对大家有所帮助。</p><h2 id="一、多线程为什么会有并发问题"><a href="#一、多线程为什么会有并发问题" class="headerlink" title="一、多线程为什么会有并发问题"></a>一、多线程为什么会有并发问题</h2><p>为什么多线程同时访问（读写）同个变量，会有并发问题？</p><blockquote><ol><li>Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。</li><li>线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</li><li>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</li><li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li></ol></blockquote><h2 id="二、Java-内存模型（JMM）"><a href="#二、Java-内存模型（JMM）" class="headerlink" title="二、Java 内存模型（JMM）"></a>二、Java 内存模型（JMM）</h2><p>Java 内存模型(JMM) 作用于工作内存（本地内存）和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步，如下图。</p><p><img src="https://aimak.cn/blog_img/java/jmm-model.jpg" alt="JMM"></p><h2 id="三、并发三要素"><a href="#三、并发三要素" class="headerlink" title="三、并发三要素"></a>三、并发三要素</h2><p><strong>原子性</strong>：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</p><p><strong>可见性</strong>：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</p><h2 id="四、怎么做，才能解决并发问题？（重点）"><a href="#四、怎么做，才能解决并发问题？（重点）" class="headerlink" title="四、怎么做，才能解决并发问题？（重点）"></a>四、怎么做，才能解决并发问题？（重点）</h2><p>下面结合不同场景分析解决并发问题的处理方式。</p><h3 id="一、volatile"><a href="#一、volatile" class="headerlink" title="一、volatile"></a>一、volatile</h3><h4 id="1-1-volatile-特性"><a href="#1-1-volatile-特性" class="headerlink" title="1.1 volatile 特性"></a>1.1 volatile 特性</h4><p><strong>保证可见性，不保证原子性</strong></p><blockquote><ol><li>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</li><li>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。</li></ol></blockquote><p><strong>禁止指令重排序</strong> 指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则：</p><blockquote><ol><li>不会对存在依赖关系的指令重排序，例如 a &#x3D; 1;b &#x3D; a;  a 和b存在依赖关系，不会被重排序</li><li>不能影响单线程下的执行结果。比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作,前两个操作可以重排序，但是c&#x3D;a+b不会被重排序，因为要保证结果是3</li></ol></blockquote><h4 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h4><p>对于一个变量，只有一个线程执行写操作，其它线程都是读操作，这时候可以用 volatile 修饰这个变量。</p><h4 id="1-3-单例双重锁为什么要用到volatile？"><a href="#1-3-单例双重锁为什么要用到volatile？" class="headerlink" title="1.3 单例双重锁为什么要用到volatile？"></a>1.3 单例双重锁为什么要用到volatile？</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestInstance</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TestInstance mInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestInstance <span class="title">getInstance</span>()</span>&#123;       <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;                     <span class="comment">//2</span></span><br><span class="line">        synchronized (TestInstance.<span class="keyword">class</span>)&#123;      <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;             <span class="comment">//4</span></span><br><span class="line">                mInstance = <span class="keyword">new</span> TestInstance(); <span class="comment">//5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>}</p><p>假如没有用volatile，并发情况下会出现问题，线程A执行到注释5 <code>new TestInstance()</code> 的时候，分为如下几个几步操作：</p><ol><li>分配内存</li><li>初始化对象</li><li>mInstance 指向内存</li></ol><p>这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断mInstance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。</p><h4 id="1-4-volatile-原理"><a href="#1-4-volatile-原理" class="headerlink" title="1.4 volatile 原理"></a>1.4 volatile 原理</h4><p>在JVM底层volatile是采用<strong>内存屏障</strong>来实现的，内存屏障会提供3个功能：</p><blockquote><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将缓存的修改操作立即写到主内存</li><li>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</li></ol></blockquote><h4 id="1-5-volatile-的局限性"><a href="#1-5-volatile-的局限性" class="headerlink" title="1.5 volatile 的局限性"></a>1.5 volatile 的局限性</h4><p><strong>volatile 只能保证可见性，不能保证原子性</strong>写操作对其它线程可见，但是不能解决多个线程同时写的问题。</p><h3 id="二、Synchronized"><a href="#二、Synchronized" class="headerlink" title="二、Synchronized"></a>二、Synchronized</h3><h4 id="2-1-Synchronized-使用场景"><a href="#2-1-Synchronized-使用场景" class="headerlink" title="2.1 Synchronized 使用场景"></a>2.1 Synchronized 使用场景</h4><p>多个线程同时写一个变量。</p><p>例如售票，余票是100张，窗口A和窗口B同时各卖出一张票， 假如余票变量用 volatile 修饰，是有问题的。<br> A窗口获取余票是100，B窗口获取余票也是100，A卖出一张变成99，刷新回主内存，同时B卖出一张变成99，也刷新回主内存，会导致最终主内存余票是99而不是98。</p><p>前面说到 volatile 的局限性，就是多个线程同时写的情况，这种情况一般可以使用<strong>Synchronized</strong>。</p><p><strong>Synchronized 可以保证同一时刻，只有一个线程可执行某个方法或某个代码块。</strong></p><h4 id="2-2-Synchronized-原理"><a href="#2-2-Synchronized-原理" class="headerlink" title="2.2 Synchronized 原理"></a>2.2 Synchronized 原理</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    synchronized (SynchronizedTest.<span class="keyword">class</span>) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将这段代码先用<code>javac</code>命令编译，再<code>java p -v SynchronizedTest.class</code>命令查看字节码，部分字节码如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line"><span class="attr">descriptor:</span> <span class="string">([Ljava/lang/String;)V</span></span><br><span class="line"><span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_STATIC</span></span><br><span class="line"><span class="attr">Code:</span></span><br><span class="line">  <span class="string">stack=2,</span> <span class="string">locals=3,</span> <span class="string">args_size=1</span></span><br><span class="line">     <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // class com/lanshifu/opengldemo/test/SynchronizedTest</span></span><br><span class="line">     <span class="attr">2:</span> <span class="string">dup</span></span><br><span class="line">     <span class="attr">3:</span> <span class="string">astore_1</span></span><br><span class="line">     <span class="attr">4:</span> <span class="string">monitorenter</span></span><br><span class="line">     <span class="attr">5:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">     <span class="attr">8:</span> <span class="string">ldc</span>           <span class="comment">#4                  // String 123</span></span><br><span class="line">    <span class="attr">10:</span> <span class="string">invokevirtual</span> <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">    <span class="attr">13:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">14:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">15:</span> <span class="string">goto</span>          <span class="number">23</span></span><br><span class="line">    <span class="attr">18:</span> <span class="string">astore_2</span></span><br><span class="line">    <span class="attr">19:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">20:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">21:</span> <span class="string">aload_2</span></span><br><span class="line">    <span class="attr">22:</span> <span class="string">athrow</span></span><br><span class="line">    <span class="attr">23:</span> <span class="string">invokestatic</span>  <span class="comment">#6                  // Method method:()V</span></span><br><span class="line">    <span class="attr">26:</span> <span class="string">return</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>4: monitorenter</code> 和 <code>14: monitorexit</code>，中间是打印的语句。</p><p>执行同步代码块，首先会执行<code>monitorenter</code>指令，然后执行同步代码块中的代码，退出同步代码块的时候会执行<code>monitorexit</code>指令 。</p><blockquote><p>使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就进入同步队列，线程状态变成BLOCK，同一时刻只有一个线程能够获取到monitor，当监听到monitorexit被调用，队列里就有一个线程出队，获取monitor。详情参考：<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/d53bf830fa09">www.jianshu.com/p/d53bf830f…</a></p></blockquote><p>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一，所以只要这个锁的计数器大于0，其它线程访问就只能等待。</p><h4 id="2-3-Synchronized-锁的升级"><a href="#2-3-Synchronized-锁的升级" class="headerlink" title="2.3 Synchronized 锁的升级"></a>2.3 Synchronized 锁的升级</h4><p>大家对Synchronized的理解可能就是重量级锁，但是Java1.6对 Synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p><p><strong>偏向锁：</strong> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><blockquote><p>当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。</p></blockquote><p><strong>轻量级锁：</strong> 在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。</p><p><strong>重量级锁：</strong> 如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p><h4 id="2-4-Synchronized-缺点"><a href="#2-4-Synchronized-缺点" class="headerlink" title="2.4  Synchronized 缺点"></a>2.4  Synchronized 缺点</h4><ol><li>不能设置锁超时时间</li><li>不能通过代码释放锁</li><li>容易造成死锁</li></ol><h3 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h3><p>上面说到<code>Synchronized</code>的缺点，不能设置锁超时时间和不能通过代码释放锁，<code>ReentranLock</code>就可以解决这个问题。</p><p><strong>在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适</strong>，ReentrantLock还提供了<code>Condition</code>，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</p><h4 id="3-1-ReentrantLock-的使用"><a href="#3-1-ReentrantLock-的使用" class="headerlink" title="3.1 ReentrantLock 的使用"></a>3.1 ReentrantLock 的使用</h4><p><strong>lock 和 unlock</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;lock&quot;</span>);</span><br><span class="line">        reentrantLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;睡眠2秒...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>实现可定时的锁请求：tryLock</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    public static void <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        ReentrantLock reentrantLock = new <span class="built_in">ReentrantLock</span>();</span><br><span class="line">        Thread thread1 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread1<span class="selector-class">.setName</span>(&quot;thread1&quot;);</span><br><span class="line">        thread1<span class="selector-class">.start</span>();</span><br><span class="line">        Thread thread2 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread2<span class="selector-class">.setName</span>(&quot;thread2&quot;);</span><br><span class="line">        thread2<span class="selector-class">.start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class Thread_tryLock extends Thread &#123;</span><br><span class="line">        ReentrantLock reentrantLock;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Thread_tryLock</span>(ReentrantLock reentrantLock) &#123;</span><br><span class="line">            this<span class="selector-class">.reentrantLock</span> = reentrantLock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                boolean tryLock = reentrantLock<span class="selector-class">.tryLock</span>(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                if (tryLock) &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock success :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;睡眠一下：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    Thread<span class="selector-class">.sleep</span>(<span class="number">5000</span>);</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;醒了：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock 超时 :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;unlock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                reentrantLock<span class="selector-class">.unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>打印的日志：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> lock:thread1</span><br><span class="line"><span class="keyword">try</span> lock:thread2</span><br><span class="line"><span class="keyword">try</span> lock success :thread2</span><br><span class="line">睡眠一下：thread2</span><br><span class="line"><span class="keyword">try</span> lock 超时 :thread1</span><br><span class="line">unlock:thread1</span><br><span class="line"><span class="built_in">Exception</span> in thread <span class="string">&quot;thread1&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock<span class="variable">$Sync</span>.<span class="title function_ invoke__">tryRelease</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">151</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.<span class="title function_ invoke__">release</span>(AbstractQueuedSynchronizer.<span class="attr">java</span>:<span class="number">1261</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.<span class="title function_ invoke__">unlock</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">457</span>)</span><br><span class="line">at com.lanshifu.demo_module.test.lock.ReentranLockTest<span class="variable">$Thread_tryLock</span>.<span class="title function_ invoke__">run</span>(ReentranLockTest.<span class="attr">java</span>:<span class="number">60</span>)</span><br><span class="line">醒了：thread2</span><br><span class="line">unlock:thread2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面演示了<code>trtLock</code>的使用，<code>trtLock</code>设置获取锁的等待时间，超过3秒直接返回失败，可以从日志中看到结果。 有异常是因为thread1获取锁失败，不应该调用unlock。</p><h4 id="3-2-Condition-条件"><a href="#3-2-Condition-条件" class="headerlink" title="3.2 Condition 条件"></a>3.2 Condition 条件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Thread_Condition thread_condition = <span class="keyword">new</span> Thread_Condition();</span><br><span class="line">        thread_condition.setName(<span class="string">&quot;测试Condition的线程&quot;</span>);</span><br><span class="line">        thread_condition.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread_condition.singal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Thread_Condition</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">await</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">public</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:我在等待通知的到来...&quot;</span>);</span><br><span class="line">                condition.<span class="keyword">await</span>();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                <span class="comment">//condition.await(2, TimeUnit.SECONDS); //设置等待超时时间</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:等到通知了，我继续执行&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singal</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;我要通知在等待的线程，condition.signal()&quot;</span>);</span><br><span class="line">                condition.signal();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行打印日志</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span></span><br><span class="line">测试Condition的线程:我在等待通知的到来...</span><br><span class="line"><span class="keyword">lock</span></span><br><span class="line">我要通知在等待的线程，condition.signal()</span><br><span class="line">unlock</span><br><span class="line">测试Condition的线程:等到通知了，我继续执行&gt;&gt;&gt;</span><br><span class="line">unlock</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面演示了<code>Condition的 await 和 signal</code> 使用，前提要先lock。</p><h4 id="3-3-公平锁与非公平锁"><a href="#3-3-公平锁与非公平锁" class="headerlink" title="3.3 公平锁与非公平锁"></a>3.3 公平锁与非公平锁</h4><p>ReentrantLock 构造函数传true表示公平锁。</p><p>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的顺序。而非公平锁就是一种锁的抢占机制，是随机获得锁的，可能会导致某些线程一致拿不到锁，所以是不公平的。</p><h4 id="3-4-ReentrantLock-注意点"><a href="#3-4-ReentrantLock-注意点" class="headerlink" title="3.4 ReentrantLock  注意点"></a>3.4 ReentrantLock  注意点</h4><ol><li>ReentrantLock使用lock和unlock来获得锁和释放锁</li><li>unlock要放在finally中，这样正常运行或者异常都会释放锁</li><li>使用condition的await和signal方法之前，必须调用lock方法获得对象监视器</li></ol><h3 id="四、并发包"><a href="#四、并发包" class="headerlink" title="四、并发包"></a>四、并发包</h3><p>通过上面分析，并发严重的情况下，使用锁显然效率低下，因为同一时刻只能有一个线程可以获得锁，其它线程只能乖乖等待。</p><p>Java提供了并发包解决这个问题，接下来介绍并发包里一些常用的数据结构。</p><h4 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h4><p>我们都知道HashMap是线程不安全的数据结构，HashTable则在HashMap基础上，get方法和put方法加上Synchronized修饰变成线程安全，不过在高并发情况下效率底下，最终被<code>ConcurrentHashMap</code>替代。</p><p>ConcurrentHashMap 采用分段锁，内部默认有16个桶，get和put操作，首先将key计算hashcode，然后跟16取余，落到16个桶中的一个，然后每个桶中都加了锁（ReentrantLock），桶中是HashMap结构（数组加链表，链表过长转红黑树）。</p><p>所以理论上最多支持16个线程同时访问。</p><h4 id="4-2-LinkBlockingQueue"><a href="#4-2-LinkBlockingQueue" class="headerlink" title="4.2 LinkBlockingQueue"></a>4.2 LinkBlockingQueue</h4><p>链表结构的阻塞队列，内部使用多个ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>源码不贴太多，简单说一下<code>LinkBlockingQueue</code> 的逻辑：</p><blockquote><ol><li>从队列获取数据，如果队列中没有数据，会调用<code>notEmpty.await();</code>进入等待。</li><li>在放数据进去队列的时候会调用<code>notEmpty.signal();</code>，通知消费者，1中的等待结束，唤醒继续执行。</li><li>从队列里取到数据的时候会调用<code>notFull.signal();</code>，通知生产者继续生产。</li><li>在put数据进入队列的时候，如果判断队列中的数据达到最大值，那么会调用<code>notFull.await();</code>，等待消费者消费掉，也就是等待3去取数据并且发出<code>notFull.signal();</code>，这时候生产者才能继续生产。</li></ol></blockquote><p><code>LinkBlockingQueue</code> 是典型的生产者消费者模式，源码细节就不多说。</p><h4 id="4-3-原子操作类：AtomicInteger"><a href="#4-3-原子操作类：AtomicInteger" class="headerlink" title="4.3  原子操作类：AtomicInteger"></a>4.3  原子操作类：AtomicInteger</h4><p>内部采用CAS（compare and swap）保证原子性</p><p>举一个int自增的例子</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        AtomicInteger <span class="attr">atomicInteger</span> = new AtomicInteger(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">        atomicInteger.incrementAndGet()<span class="comment">;//自增</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>源码看一下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>U 是 Unsafe，看下 <code>Unsafe#getAndAddInt</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过<code>compareAndSwapInt</code>保证原子性。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>面试中问到多线程并发问题，可以这么答：</p><blockquote><ol><li>当只有一个线程写，其它线程都是读的时候，可以用<code>volatile</code>修饰变量</li><li>当多个线程写，那么一般情况下并发不严重的话可以用<code>Synchronized</code>，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。</li><li><code>ReentranLock</code> 可以通过代码释放锁，可以设置锁超时。</li><li>高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如<code>ConcurrentHashMap</code>，<code>LinkBlockingQueue</code>，以及原子性的数据结构如：<code>AtomicInteger</code>。</li></ol></blockquote><p>面试的时候按照上面总结的这个思路回答基本就ok了。既然说到并发包，那么除了<code>ConcurrentHashMap</code>，其它一些常用的数据结构的原理也需要去了解下，例如<code>HashMap、HashTable、TreeMap</code>原理，<code>ArrayList、LinkedList</code>对比，这些都是老生常谈的，自己去看源码或者一些博客。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里毕玄：系统架构师如何做好系统设计？</title>
      <link href="/2019/08/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/08/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里毕玄：系统架构师如何做好系统设计？"><a href="#阿里毕玄：系统架构师如何做好系统设计？" class="headerlink" title="阿里毕玄：系统架构师如何做好系统设计？"></a>阿里毕玄：系统架构师如何做好系统设计？</h1><blockquote><p>本文转自毕玄老师个人公众号：<strong>hellojavacases</strong></p></blockquote><p>系统设计我一直觉得是远比Java编程技能更难多了的培训，很容易变成务虚课，全是一堆理论，所以，以前从来不敢尝试做这方面的培训，今年由于一些情况，决定大胆尝试下，就在内部搞了个民间的培训，还真有不少同学捧场。在开始上这门课后，我觉得收获最大的搞不好是我自己，整理思路，从和学员的互动中学习到了很多，能更好地对系统设计的一些方法论进行抽象总结，所以我对这些捧场的学员们说：其实是我们一起在共创系统设计的课程 </p><p>我给系统设计培训定的目标是：</p><ol><li>通过这堂课掌握一个思考框架，知道做系统设计的套路，系统设计不是简单的上来就画画框什么，必须按照一定的套路才能更好的进行系统设计；</li><li>拓宽知识面，系统设计中非常重要的是考虑的全面性，以更好的进行权衡取舍，所以能不能借助系统设计培训来拓宽知识面非常重要。</li></ol><p>而要达到这样的效果，怎么去上这堂课挑战其实是不小的：想要传达的思考框架到底是什么？怎么样变成不是纯粹的理论，务虚的传达，从而让大家能更好的掌握并真正的去运用这个思考框架？以前真的没仔细的思考过系统设计的思考框架的问题，其实吧很多的系统设计的模板就是一个思考框架，但在不理解的情况下，是很难应用好的。</p><p><strong>系统设计的套路</strong></p><p>回顾了下自己做过的几个系统的设计，发现现在自己在做系统设计的时候确实是会按照一个套路去做，这个套路就是：</p><p><strong>系统设计的目的-&gt;系统设计的目标-&gt;围绕目标的核心设计-&gt;围绕核心设计形成的设计原则-&gt;各子系统，模块的详细设计。</strong></p><p><strong>1) 系统设计的目的</strong>  </p><p>是指做这个系统设计的目的到底是什么，很多人在做系统设计时，是搞不清为什么要做一个新系统的设计，或者为什么要做一个系统的重构&#x2F;演进的设计，如果搞不清楚这个目的，后面的系统设计上是很容易形成偏差的，导致本来是为了解决一个问题，要去做新的系统或重构&#x2F;升级旧的系统，但最后完全脱离了初心。</p><p>另外，还有很重要的一点是，一个大架构师是需要给很多人讲解系统设计的，只有理解并讲清了系统设计的目的，团队才能更好的去实现。</p><p><strong>2) 系统设计的目标</strong>  </p><p>围绕上面的目的，能不能形成一些可衡量的目标，从而确保最终系统实现和最初的目的不要出现太大的偏差，相信很多人都经历过最终的系统实现和系统设计偏差极大的现象，主要的原因基本都是没有制定衡量系统设计的目标，并在系统设计上让系统能透出这些目标的情况。</p><p><strong>3) 围绕目标的核心设计</strong> </p><p>这步最重要的就是通过设计如何去实现上面的目标，这个环节中技术的专业、视野、全面的考虑、权衡取舍的主观原则、解题的思路，这是形成最后的核心设计的关键。</p><p>在核心设计的这个阶段中，会产生一些新的衡量设计最后实现情况的目标，这些也都要增加到系统设计中，确保最后的实现和设计的偏差度是可视的。</p><p><strong>4) 围绕核心设计形成的设计原则</strong> </p><p>有了上面的核心设计后，可以真正的形成一些设计原则，确保后面的子系统&#x2F;模块的详细设计中能够遵循，并在详细设计中体现出来，这样才能让整个大的系统设计的一致性。</p><p><strong>5) 各子系统&#x2F;模块的详细设计</strong> </p><p>这个部分我倒觉得难度不会太大，毕竟有了前面的铺垫，就是解好一个更小范围的题，程序员群体在解题能力上通常是不错的，所以我一直觉得数学功底好是程序员的基本，数学就是典型的解题的学科。</p><p>ps: 这就是做分享&#x2F;培训的好处，借机仔细整理自己的碎片，从而形成体系。</p><p>关于怎么更好的让大家能掌握并运用这个思考框架，我的想法就是在讲每个步骤的时候讲讲自己当年在这些步骤上犯的错，实际的经验，这样我觉得也许大家以后在做系统设计时就能想起，所以我觉得系统设计这种培训绝对是需要具备大量实际经验的架构师才能做。</p><p>在运用部分，采取的方法就是通过互动，让大家按照同样的思考框架来讲自己的所负责的系统，通过互动来更好的彼此对齐，并借此逐渐变成习惯。</p><p><strong>系统设计之系统建设的目的</strong></p><p>作为系统设计的第一步，重要性毋庸置疑，如果连系统建设的目的都没搞清楚，后面所有的步骤都会错误。如果我们去看很多的系统设计，会发现压根就没有系统建设的目的的仔细分析。</p><p>当需要做系统设计时，就意味着需要建设一套新系统，或者对原有的系统进行比较大的架构的改造升级，这一定是基于什么原因才要去做的。之所以要分析好系统建设的目的，<strong>一方面是为了避免出发点有问题，系统建设的目的应该是充分反映出解决业务层面临的挑战</strong>，或者系统用户层面面临的问题的，而不是出于个人诉求，<strong>另一方面是为了确保在后续的系统设计中能保证目的的达成。</strong></p><p>从对系统建设的目的的分析中，是很容易看出格局和高度的，这两个词看起来非常虚，但其实很实，格局和高度通常是指所做的事影响的范围大小，例如从所在的一个小团队，到所在的大部门，到所在的大BU，到所在的大BG，到跨多BG的业务板块，到整个集团，甚至是到这个社会，这里一定要实事求是，别这里讲的是世界形势，后面的整个系统设计又完全解决不了这里所说的。</p><p>结合我自己的经历来说，在早期做HSF时，在系统建设的目的这点上是最为缺失的，也导致了自己在HSF阶段犯下了几次大的错误，例如最典型的就是HSF做动态化的那次系统架构改造，如果仔细的去分析当时做这件事的目的，就会看到这个是出于技术情怀，而不是业务端面临的业务挑战，或者说HSF的用户面临的问题，也就是之前说的出发点的问题，我觉得这是很多技术人员非常容易犯的错误，就是纯粹是出于技术诉求发动的很大动作的系统重构，我自己是在有一年有一位阿里的高管在给我做辅导时，提到首先要思考清楚为什么做某件事，并且能讲清楚原因，才明白了动机真的是非常重要的，后面做事的时候才能没那么技术化了。</p><p>因为HSF&#x2F;Ali HBase的经历，到了后面做阿里容器&#x2F;调度、异地多活的时候在目的这块才算是能更好的把握，能更好的去结合阿里的业务所面临的挑战来看要做的事。</p><p>大多数时候，驱动系统设计这件事的发生是其他方提出的，作为架构师，做好需求的转换，决定是否要建设新系统，或重构升级老系统，深刻地去理解系统建设的目的也非常重要，因为架构师是最终要给整个技术团队讲为什么要做的，这能够更好地让团队明白做这件事的价值和意义。</p><p><strong>总得来说，我认为做系统设计前，一定要先对于系统建设的目的分析清楚，确保系统建设有价值和有意义，同时确保后面的整个系统设计是能让目的达成的。</strong></p><h2 id="系统建设的目标"><a href="#系统建设的目标" class="headerlink" title="系统建设的目标"></a><strong>系统建设的目标</strong></h2><p>在分析清楚了系统建设的目的后，到了目标这个环节，最重要的是要把前面的目的的描述，<strong>转换为可衡量的目标的描述</strong>，之所以要形成可衡量的目标，最重要的原因是为了确保最后实现的系统是达成了系统建设的目的的，相信很多人都碰到过设计出来的系统和最后落地的系统很不一致的现象，通常这都是缺乏了可衡量的目标造成的。</p><p>举两个例子说下：</p><p>第一个是2011年做容器化，建设这套系统的目的是为了应对预计会越来越大的机器成本，目标相应的制定为支撑相同的业务量，机器下降一半。</p><p>第二个是2013年做异地多活，建设这套系统的目的是为了能够让业务具备更强的抵御灾害的能力，尽管后面发现因为有了异地多活，有了更多的好处，但那些确实在系统设计之初是完全没放在建设目的里的，后面能做到纯属巧合，例如因为有了异地多活使得后面的弹性借助云资源成为了现实，因为有了异地多活，基础设施技术的演进可以更加快速，在设计之初根据目的相应制定的目标为业务能够部署在中国多个地点（地点间距离&gt;1千公里），多个地点部署的业务都处于承接流量的状态，且流量从A点切换到B点能在30s内完成。</p><p>有了清晰的可衡量的系统建设的目标，意味着：</p><ol><li>确保了系统设计过程中可以非常针对性的围绕目标来做，避免偏题；</li><li>更重要也是最容易遗漏的一点，是可以做一个用来跟踪系统建设效果的系统，例如之前做容器化，我们会有一个展示，是容器化后的集群多少机器支撑了多少的业务量，和目前还未容器化的集群的一个对比；异地多活，会有一个管控系统，用来展示系统的部署情况，以及流量切换。只有有了跟踪系统建设目标是否达标的系统，才能真正确保系统建设完毕后和初心保持了一致，否则很多系统建设的时候是一个目的，最后做完了是另外的状况，所以这个跟踪效果的体系是一定要在系统建设的时候同步就做好的。</li></ol><p>从目的-&gt;目标这个部分，理论上并不复杂，但也很容易漏掉，导致后面的系统设计环节出问题，关键是要形成可衡量的目标，以及相应的跟踪目标达成情况的系统。</p><p><strong>达成目标的核心问题</strong> </p><p>如果要达成系统设计的可衡量的目标，到底面临了一些什么核心问题，只有明白了面临什么核心问题，才能更加明确的进行系统设计来解决这些问题。</p><p>还是用我自己的经历来讲这个话题。</p><p>最开始做HSF的时候，为什么要做HSF是比较清晰的，在可衡量的目标上也有一个大概的要支持每条上亿的服务调用，但由于当时的技术功底问题，导致了在提炼核心问题上是有很大差距的，这些也造成了后来HSF总是不断的重构、修修补补之类。所以，我从来就不认为技术功底不好的人能做好一个架构师，架构师绝对不是看到的随手画几个框那么简单，那通常只是个结果，但要合理的把框画出来是需要基于非常坚实的技术功底，HSF在最初设计时认为的核心问题就是怎么实现一个易用有服务定义的RPC框架，但对于如何支撑好上亿的交互调用量，服务化上线后给业务研发会带来什么问题（例如排查问题变复杂了），在核心问题上是有很大的缺失的，例如HSF上线后才发现的中间的负载均衡的问题，而这个问题是导致了HSF结构重新设计的，这个后来回头看就会发现如果是一个知识面更广的架构师可能一开始就会想到这个核心问题，所以如果回过头去看，HSF这样的框架，要达成目标，要解决的核心问题应该是：</p><ol><li>易用、能支撑上亿次服务交互的RPC框架；</li><li>服务间的软件负载均衡问题；</li><li>服务交互的问题排查；</li></ol><p>在做T4（容器）的时候，目的、目标都还比较清晰，问题的提炼现在回顾也做的还ok，T4要解的核心问题为如何实现在一台机器上跑20个应用，T4出现的问题更多是对于核心问题的设计方案上，这个到下篇讲围绕核心问题的系统设计上再写。</p><p>到了做异地多活的时候，目的、目标的清晰化都ok，对于异地多活而言，要做到在中国多个城市都可同时支撑流量，并且可在几十秒内完成流量切换，异地多活中物理距离所带来的网络延时是不可突破的，怎么做到多地活且流量可动态切换，要做到这个，面临的核心问题是：</p><ol><li>如何将流量进行切分，且让请求的整个处理过程能封闭在local完成；</li><li>如何保障异地多活后的数据一致性？</li></ol><p>到了最近几年做统一调度的时候，整个做系统设计的思考框架我觉得算是比较熟练了，所以统一调度的目的、目标都很清晰，结合当时的情况，要实现统一调度的目标，其面临的核心问题是：</p><ol><li>如何实现一套在线业务资源的调度系统去满足各种资源诉求？</li><li>如何尽可能扩大统一的资源池，解决资源池统一面临的资源竞争、资源被抢、多种不同资源规格等问题？</li><li>如何实现在线业务、离线任务两套调度系统的互通？</li><li>如何解决在线业务、离线任务混合部署时的资源竞争的问题？</li></ol><p>从上面的这些cases来看，可以看到，从可衡量的目标映射到技术层面要去解决的核心问题，是很需要技术功底的，对于工程类型的项目、产品而言，工程经验在这个时候也会特别重要，而通常我也觉得这是衡量一个优秀架构师很直接的地方。</p><p><strong>解决核心问题的设计</strong></p><p>继前面的系统建设的目的、可衡量的目标，达成目标的核心问题后，进入到解决核心问题的设计环节了，技术人员其实最擅长的是直奔这个主题，而且估计更期盼的也是这篇，有些时候会导致跳过前面的目的、目标环节，导致最终做出来的系统要么没贴合业务挑战，要么嘛偏离了做这个系统的初衷，所以我仍然强烈建议做系统设计的同学不要着急，一步一步来。</p><p>继续结合自己的cases来讲讲解决核心问题的设计这个环节，回顾自己的cases，犯了不少的错误，也碰到了非常多复杂的权衡选择的状况，才逐渐更加明白一个架构师应该具备的一些能力。</p><p><strong>HSF的设计</strong></p><p>HSF在设计之初要解决的第一个核心问题就是做一个易用，能支撑每天上亿次服务调用的服务方式的RPC框架。</p><p>易用这点在第一个版本犯了错，不过还好是第一个版本，否则纠正错误的代价会无比巨大，那个版本里，如果要把一个spring的bean发布为HSF服务，或者调用一个HSF服务，需要写一个文件，在文件里描述发布的服务和调用的服务，并且在这个文件放在jboss的某个目录里，这个方式看起来对在写代码的过程中完全没有侵入，但导致的巨大问题是这文件放在哪里写，写完后部署的阶段怎么自动放到对应的目录去，在第二个版本里才把这个调整为用一个Spring Bean的方式来做服务的发布和调用，尽管这一定程度导致了业务代码需要有对HSF的明显的依赖，但对维护、部署等都变的很标准，所以从这里可以看到，设计是全方位的，要考虑到的不仅仅是怎么实现，还有别人怎么用，运行、维护阶段又是怎么样的。</p><p>HSF犯的第二个错，就是在能支撑每天上亿次服务调用的RPC框架这点上，是给我自己代码生涯最大的教训，甚至彻底改变了我之后做设计时的技术选型风格。在做HSF之前，我从来没做过一天访问量超过100w的系统，完全搞不清一个每天上亿次的系统到底有什么不同，HSF最早的版本在通讯框架上选择了JBoss-Remoting，原因也其实比较简单，因为我们用的Web容器是JBoss，结果这个版本在一个非常重要的系统上线时，出现了严重的故障，导致了整个网站的响应速度都变的很慢。当时查了几乎整整一天都没查出原因到底是什么，后来回滚恢复，所以可以肯定是HSF上线造成的，等到回滚后的一个星期内才查出原因，是因为JBoss-Remoting在调用远端时，默认的超时时间为60s，而我们后端的那个系统在处理某些服务的时候会特别慢，进而导致了共用的处理线程池满了，所以整个网站的表现就变慢了。</p><p>这次问题让我彻底明白了访问量大的系统最重要的是对整个系统的处理过程要非常的清楚，因为在访问量大的情况下，一些小的问题有可能会放大成很大的问题，进而到故障，所以访问量大的系统对技术的可控性要求是极高的，这也是最大的不同，可控性并不代表一定要完全自己写，但要求如果用到开源的东西，要对开源的东西的代码逻辑非常熟悉，为了解决上面的问题，HSF基于Mina写了一个自己版本的通讯框架，自己来处理连接方式、线程池等，后面在做各种HSF改造，以及其他技术改造时，基本都遵循了技术可控性这个原则。</p><p>在前面核心问题那篇里也讲到，HSF在设计时其实核心问题提炼的就是有问题的，导致了后面在负载均衡、服务化后问题排查这两点上出现了严重的返工现象，而这些本其实都可以避免，就像现在再去做服务化框架的人基本都不会犯这样的错了。</p><p>在负载均衡这点上，在早期版本里，是通过硬件负载均衡设备来做的，这里造成了好几个问题，一是需要先配置要调用的服务的vip地址，当然，这可以通过一个中央的配置服务器之类的方式，第二个是HSF采用的是长连接的方式，通过vip去连接后端的一个集群时，这里会出现非常麻烦的问题，例如后端集群发布重启，很有可能就会造成连接的极度不均衡，进而导致故障。</p><p>除了上面两个问题后，还有一个触发HSF去做改造的原因是当时的硬件负载设备出现了流量跑满的现象，而这是必须要经过的一个点，会造成全站全部崩溃，不希望在未来系统中有个这么大的高风险的集中点，再加上上面的两个问题，决定做彻底的改造，于是HSF开始设计了目前看起来在服务框架体系中非常经典的软件方式的服务注册、发现和寻址的结构。</p><p>在负载均衡这件事上，现在回顾也可以看出这个仍然是当初对一个访问量巨大的系统考虑不够全面造成的。</p><p>在服务化后会带来的排查问题这点上，当初设计的时候更是完全没有考虑到，导致了后面排查问题效率低、人力投入大等等问题，后来为了解决这个问题，学习了Google家Dapper的思想，但花了很长时间这东西才真正落地。</p><p>除了上面这些外，HSF其实还有各种设计问题，例如最早的通讯协议里竟然是没有版本号的，导致后面升级时处理兼容的复杂，又例如更麻烦的一个话题就是在多语言支持上。</p><p>HSF作为我第一个真正做的访问量巨大且核心的系统的设计，由于当初的技术功底，犯下了无数错误，导致了N次返工、故障和弥补，当然也让自己得到了很大的成长，这几年回过头想这个问题，越来越觉得必须无比感谢我当时的主管对我巨大的包容和支持，HSF的经历，让我在解决核心问题的设计这个环节上，明白的是作为一个架构师，在技术选型上深厚的技术功底，在整个设计方案上知识的广度，考虑的全面性（从开发态、部署态、运行态和运维态）都是要求极高的。</p><p><strong>T4的设计</strong></p><p>T4在核心问题的提炼上没有太大的问题，但在怎么解这个问题的设计上那犯下的错误现在来看都是低级到不行。</p><p>为了做到在一台机器上能比以前用虚拟机的方式运行更多的应用进程，最早我们采用的方法是各种hack，其实要实现的就是进程级隔离，结果就是hack到了一定程度后，确实勉强能用了，但上线了一些小范围，有了一些用户后，发现我们的hack是很难枚举的，非常痛苦，直到有一天“发现”了LXC，才走对了路线。</p><p>除了上面这个选型层面的问题外，T4的过程中还碰到过很多类似的问题，例如用什么方法去控制磁盘空间的限制，最早我们也是用的同样的image的方式，但image的方式对磁盘空间超卖其实是非常不友好的，后来为了把这个方案更换成dir quota的方案，一帮人几乎是连续折腾了一个多月，因为线上已经在运行的要通过cp文件等方法来弄。</p><p>HSF的那段看到的很多是在技术深度上的问题，而T4的这段设计，现在回顾最主要的问题是这个技术领域视野的严重问题，所以我认为作为架构师，在相应的技术领域要有足够的视野，一定要知道这个领域的工程界、学术界是什么情况，这样对自己在结合目的、目标以及一些约束条件下做出更合理的技术选型是非常重要的，之前也写过一篇关于<a href="http://mp.weixin.qq.com/s?__biz=MjM5MzYzMzkyMQ==&mid=2649826508&idx=1&sn=cb736765f77d6b13846d63b7ff0310f6&chksm=be91872289e60e34a28abd1588a8eec9289d26024d313621646cd1f0b99409890701b2d0cfa9&scene=21#wechat_redirect">如何扩充技术视野</a>的文章。</p><p><strong>异地多活的设计</strong></p><p>到了做异地多活这个阶段，也许是因为有了前面的一些积累，总结反思，我自己觉得异地多活的设计更多的是选择，至于对错我总体认为还好，所以这里我就讲一些异地多活设计上为了解决核心问题所面临的一些权衡选择，而这也是架构师在做设计上非常重要的一个部分，如何去根据各种约束来做一些方案的权衡选择。</p><p>异地多活在核心问题上要解决的是请求封闭、数据一致性这两个关键问题，在为了解决这两个问题的设计上，参考了工程界的一些情况，最后发现我们所面临的状况还是很不一样。</p><p>在这里就抛出一些异地多活设计上所面临的选择，我就不去讲我的选择逻辑之类的了，方便大家思考，以及交流探讨。</p><ol><li>流量&#x2F;数据拆分的规则到底按什么好？买家&#x2F;卖家&#x2F;商品？</li><li>分流的规则和数据库分库分表的规则的关系：松耦合 Vs 强绑定？</li><li>数据同步策略的选择：部分 Vs 全量？</li><li>数据一致性的保障，在哪些层面做，CAP？</li><li>部署的选择：两地 Vs 三地，地域的分布选择？</li><li>落地节奏，一年？两年？三年？</li></ol><p><strong>架构师应具备的能力总结</strong></p><p>最后根据目的、可衡量的目标、核心问题提炼、解决核心问题的设计这些环节，总结提炼下我觉得架构师需要具备的能力：</p><ol><li>对业务所面临的挑战的理解，从业务挑战到技术挑战映射的能力，或者说技术抽象的能力；</li><li>知识储备以及考虑的全面性，从开发、部署、运行、维护态；</li><li>技术选型能力，极厚的技术功底，开阔的技术视野；</li><li>在各种约束条件下权衡选择的能力，原则。</li></ol><p>所以架构师我觉得绝对不是烂大街的头衔，要做到一个合格的架构师还是相当难的，尤其是工程类型的架构师，需要长期的实战、经验积累。</p><p>系统设计一直是我认为最难讲的内容，主要还是因为我在内部尝试做的一个系统设计的培训，非常感谢一帮同学支持了我做这个培训，要不是他们的参与，我觉得不可能写这篇文章，也不可能较为体系化的说说系统设计，并且更重要的是让我觉得系统设计这个东西其实还是可以不讲的那么虚的，以及系统设计的技能一定程度上确实也是可以培养的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发必须掌握的 20+ 种 Spring 常用注解</title>
      <link href="/2019/08/08/java/Java%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%2020+%20%E7%A7%8D%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/08/08/java/Java%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%2020+%20%E7%A7%8D%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java开发必须掌握的-20-种-Spring-常用注解"><a href="#Java开发必须掌握的-20-种-Spring-常用注解" class="headerlink" title="Java开发必须掌握的 20+ 种 Spring 常用注解"></a>Java开发必须掌握的 20+ 种 Spring 常用注解</h1><p>本文主要罗列Spring|SpringMVC相关注解的简介。</p><h2 id="Spring部分"><a href="#Spring部分" class="headerlink" title="Spring部分"></a><strong>Spring部分</strong></h2><h3 id="1-声明bean的注解"><a href="#1-声明bean的注解" class="headerlink" title="1.声明bean的注解"></a>1.声明bean的注解</h3><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用（service层）</li><li>@Repository 在数据访问层使用（dao层）</li><li>@Controller 在展现层使用，控制器的声明（C）</li></ul><h3 id="2-注入bean的注解"><a href="#2-注入bean的注解" class="headerlink" title="2.注入bean的注解"></a>2.注入bean的注解</h3><ul><li>@Autowired：由Spring提供</li><li>@Inject：由JSR-330提供</li><li>@Resource：由JSR-250提供</li></ul><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><h3 id="3-java配置类相关注解"><a href="#3-java配置类相关注解" class="headerlink" title="3.java配置类相关注解"></a>3.java配置类相关注解</h3><ul><li>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</li><li>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）</li><li>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</li><li>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</li></ul><h3 id="4-切面（AOP）相关注解"><a href="#4-切面（AOP）相关注解" class="headerlink" title="4.切面（AOP）相关注解"></a>4.切面（AOP）相关注解</h3><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li>@After 在方法执行之后执行（方法上）</li><li>@Before 在方法执行之前执行（方法上）</li><li>@Around 在方法执行之前与之后执行（方法上）</li></ul><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><h3 id="5-Bean的属性支持"><a href="#5-Bean的属性支持" class="headerlink" title="5.@Bean的属性支持"></a>5.@Bean的属性支持</h3><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>其设置类型包括：</p><ul><li>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,</li><li>Protetype （每次调用新建一个bean）,</li><li>Request （web项目中，给每个http request新建一个bean）,</li><li>Session （web项目中，给每个http session新建一个bean）,</li><li>GlobalSession（给每一个 global http session新建一个Bean实例）</li></ul><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><h3 id="6-Value注解"><a href="#6-Value注解" class="headerlink" title="6.@Value注解"></a>6.@Value注解</h3><p>@Value 为属性注入值（属性上）</p><p><strong>支持如下方式的注入：</strong></p><p>注入普通字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;Michael Jackson&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>注入操作系统属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;]&#125;&quot;)</span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure><p>注入表达式结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123; T(java.lang.Math).random() * 100 &#125;&quot;)</span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><p>注入其它bean属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>注入文件资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)</span><br><span class="line">String Resource file;</span><br></pre></td></tr></table></figure><p>注入网站资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;http://www.cznovel.com&quot;)</span><br><span class="line">Resource url;12</span><br></pre></td></tr></table></figure><p>注入配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;book.name&#125;&quot;)</span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure><p><strong>注入配置使用方法：</strong></p><p>① 编写配置文件（test.properties）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.name=《三体》</span><br></pre></td></tr></table></figure><p>② @PropertySource 加载配置文件(类上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</span><br></pre></td></tr></table></figure><p>③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。</p><h3 id="7-环境切换"><a href="#7-环境切换" class="headerlink" title="7.环境切换"></a>7.环境切换</h3><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><h3 id="8-异步相关"><a href="#8-异步相关" class="headerlink" title="8.异步相关"></a>8.异步相关</h3><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><h3 id="9-定时任务相关"><a href="#9-定时任务相关" class="headerlink" title="9.定时任务相关"></a>9.定时任务相关</h3><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><h3 id="10-Enable-注解说明"><a href="#10-Enable-注解说明" class="headerlink" title="10.@Enable*注解说明"></a>10.@Enable*注解说明</h3><p>这些注解主要用来开启对xxx的支持。</p><ul><li>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</li><li>@EnableAsync 开启异步方法的支持</li><li>@EnableScheduling 开启计划任务的支持</li><li>@EnableWebMvc 开启Web MVC的配置支持</li><li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li><li>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</li><li>@EnableTransactionManagement 开启注解式事务的支持</li><li>@EnableTransactionManagement 开启注解式事务的支持</li><li>@EnableCaching 开启注解式的缓存支持</li></ul><h3 id="11-测试相关注解"><a href="#11-测试相关注解" class="headerlink" title="11.测试相关注解"></a>11.测试相关注解</h3><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)1</span><br></pre></td></tr></table></figure><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(classes=&#123;TestConfig.class&#125;)1</span><br></pre></td></tr></table></figure><h2 id="SpringMVC部分"><a href="#SpringMVC部分" class="headerlink" title="SpringMVC部分"></a><strong>SpringMVC部分</strong></h2><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，<br>这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术人具备“结构化思维”意味着什么？</title>
      <link href="/2019/07/18/%E6%9D%82%E8%AE%B0/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%85%B7%E5%A4%87%E2%80%9C%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E2%80%9D%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/07/18/%E6%9D%82%E8%AE%B0/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%85%B7%E5%A4%87%E2%80%9C%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E2%80%9D%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="技术人具备“结构化思维”意味着什么？"><a href="#技术人具备“结构化思维”意味着什么？" class="headerlink" title="技术人具备“结构化思维”意味着什么？"></a>技术人具备“结构化思维”意味着什么？</h1><p><strong>什么是结构化思维？</strong></p><p>那么到底是什么是结构化思维呢？简单来说，结构化思维的定义就是：逻辑+套路。</p><p><strong>表达要有逻辑</strong></p><p><strong>所谓逻辑是指我们的结构之间必须是有逻辑关系的</strong>。例如，你说话的时候用“第一、第二、第三”这个逻辑顺序是合理的，但是，用“第一，第二，第四”就会显得很奇怪。当然，即使你用了”一、二、三”，也不一定就意味着你的内容有逻辑关系。想让内容有逻辑关系，我们要学会四种组织思想的逻辑关系：</p><p>1）<strong>演绎（因果）顺序：</strong>“大前提、小前提、结论”的演绎推理方式就是演绎顺序。比如，经典三段论：所有人都要死，苏格拉底是人，苏格拉底要死。</p><p>2）<strong>时间（步骤）顺序：</strong>“第一、第二、第三”，“首先、然后、再者”等，很多的时间顺序同时也是因果顺序。</p><p>3）<strong>空间（结构）顺序：</strong>“前端、后端、数据”，“波士顿、纽约、华盛顿”，化整为零（将整体分解为部分）等都是空间顺序。</p><p>4）<strong>程度（重要性）顺序</strong>：比如“最重要、次重要、不重要”等。</p><p>实际上，所有的逻辑关系都在这四种顺序之内。只要我们的思想和表达在这四种逻辑顺序之内，就是有逻辑的，否则就会显得没有逻辑性。</p><p><strong>做事要有套路</strong></p><p><strong>套路是指我们解决问题的方法论，这个也非常重要</strong>。比如，5W2H 分析法就是一个非常好的，可以帮助我们分析问题的一个”套路”。试想一下，面对任何一个问题，你都能从 Why、Who、When、Where、What、How 和 How much（如下图所示），七个方面去思考。是不是比不知道这个方法论的人，用点状的思考，5W2H 分析法就全面得多。</p><p><img src="https://aimak.cn/blog_img/manager/5w2h.jpeg" alt="图片"></p><p>例如，我们在对问题域进行分析和领域知识提炼的时候，就可以用上5W2H。5W2H模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。</p><p><img src="https://aimak.cn/blog_img/manager/6w.jpeg" alt="图片"></p><p>逻辑是一种能力，而套路是方法论，是经验。逻辑是道的东西，而方法论是术的东西。二者都很重要，只有熟练的掌握二者我们才能更好的进行结构化思考。</p><p><strong>如何进行结构化思考？</strong></p><p>逻辑性和方法论是结构化思维的底层，那么如何进行结构化思考呢？这也是有方法论的，总的来说是有两个步骤，首先是“建立中心”，然后再进行“分解”。</p><p><strong>建立中心</strong></p><p><strong>建立中心也就是要定义清楚要解决的问题，要明确目标</strong>。是我们结构的顶层节点，也是一种以终为始的思考方式。也就是说，我们首先要搞清楚 why，然后再进行 how。</p><p>★ 建立中心有两种方式：</p><ol><li><strong>自上而下</strong>：适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。</li><li><strong>自下而上</strong>：对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。</li></ol><p>建立中心通常不会是一次成型的，随着对问题理解的变化，对中心的抽象也会进行相应的调整。不同的抽象层次其面对的问题宽度是不一样的。具体要用哪个层次的抽象作为“中心”，要视具体情况而定。</p><p>比如面对“系统 bug 多”的问题，向上抽象是“提升代码质量”，向下抽象是“加强测试”，都可以作为中心，选择哪个为中心取决于你当前要解决的问题是什么。</p><p><img src="https://aimak.cn/blog_img/manager/chouxiangcengci.jpeg" alt="图片"></p><p><strong>结构化分解</strong></p><p>确定完中心之后，我们需要构建一个结构，使用结构化的思维对问题进行分解。分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序。</p><p>在做空间分解的时候，要注意满足 MECE（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）原则。</p><p>比如我们要对衣服进行分类，如果按照季节和风格进行分类，就会出现互相重叠，并且不能穷尽的情况，也就不满足 MECE。这种分类是逻辑混乱的。</p><p><img src="https://aimak.cn/blog_img/manager/luojihunluan.jpeg" alt="图片"></p><p>我们可以按季节分：春秋装，冬装，夏装。除了这3类之外，没有其他季节了，这个就是「不遗漏」。</p><p><img src="https://aimak.cn/blog_img/manager/fenlei.jpeg" alt="图片"></p><p><strong>结构化思维应用</strong></p><h1 id="如何落地新团队？"><a href="#如何落地新团队？" class="headerlink" title="如何落地新团队？"></a><strong>如何落地新团队？</strong></h1><p>想象这样一个场景，你刚刚入职一家新公司，或者转岗到一个新团队，作为一个技术人，你将如何落地开展你的工作呢？</p><p>这里，我们就能用上结构化思维来帮我们理清思路，从而有条不紊的开展工作了。我们要知道对一个企业来说，核心要素无外乎就是业务、技术和人，也就是说这三个要素是我们要建立的中心。基于这个中心，我们可以进行进一步拆解，形成子结构。然后对子结构再进行分析找到应对策略。这样一步步递进，我们就已经在用结构化思维解决如何落地新团队的问题了。</p><p><img src="https://aimak.cn/blog_img/manager/zuzhijiagou.jpeg" alt="图片"></p><p>★ 1. 熟悉业务</p><p><strong>1）了解产品</strong>：任何一个团队都有自己要负责的产品，申请一个测试账号去用一下产品，是熟悉产品比较好的方式。</p><p><strong>2）了解流程</strong>：任何业务都有自己的业务流程，而业务流里面最核心的是信息流。我们可以通过人员采访，了解关键节点的信息输入和信息输出；可以画一些泳道活动图，理清楚系统的主要角色，以及他们之间的交互关系。</p><p><strong>3）客户走访</strong>：通过走访客户，我们可以更加获得业务的第一手资料，更加贴近业务和客户诉求。</p><p>★ 2. 熟悉技术</p><p><strong>1）了解系统架构</strong>：可以让团队的技术人员介绍下他们当初系统设计和架构的思路。</p><p><strong>2）了解领域模型</strong>：查看关键的核心表结构和系统 API，这样可以快速了解系统的领域模型。</p><p><strong>3）了解代码结构</strong>：下载系统工程，熟悉整个工程结构和模块职责。以一个最重要的流程为入手点，阅读代码，看清楚核心的执行逻辑。做一个小需求，掌握相关的流程和权限。</p><p>★ 3. 熟悉人</p><p><strong>1）了解组织结构</strong>：查看公司的组织树，知道公司大概是如何运作的，以及哪些是KP（Key Person，关键人）。比如，一个典型的电商公司会包括产品部、运营部、销售部、技术部、人力资源部、财务部、法务部等。</p><p><strong>2）了解人员角色</strong>：了解公司都有哪些岗位，以及各岗位的职责范围。</p><p><strong>3）拜山头</strong>：找到和自己工作息息相关的岗位人员，比如产品和运营。积极和他们沟通，向他们请教业务问题，多多交流。这样一方面可以建立更好的人际关系，另一方面也可以更快地熟悉业务。</p><p><strong>打造极客文化</strong></p><p>我最近刚刚转岗到新部门，新部门的老板抛给我一个命题：如何帮助技术团队打造极客文化？</p><p>这个问题的中心很明确，接下来，看看我是如何使用结构化思维来解这个问题的。首先我们从空间顺序进行分解，也就是打造极客文化，我们可以去做哪些事情。</p><p><img src="https://aimak.cn/blog_img/manager/kongjian.jpeg" alt="图片"><br>空间顺序分解</p><p>确定完要做的事情，我们还可以按照时间顺序对如何落地这些事情进行分解。</p><p><img src="https://aimak.cn/blog_img/manager/shijian.jpeg" alt="图片"><br>时间顺序分解</p><p>这样把按照这两个维度进行结构化拆解的方案给到老板，老板就会很清晰地知道你的规划和落地策略了。</p><p><strong>如何做晋升述职</strong></p><p>作者在阿里巴巴已经做了好几年的晋升评委，发现很多同学都缺乏结构化思维，冗长的 PPT 里，却不能把价值说清楚，不能把推导过程说清楚。实际上，我们需要有一些方法论来指导我们进行关键述职。</p><p>接下来，我主要说一下述职中存在的两个典型问题：“罗列事情”和“价值的背后”</p><p>★ 1.罗列事情</p><p>对自己做过的事情进行简单罗列，也许你的确做了不少事情。但是不能体现你对问题思考的深度和做这个事情带来的价值。这样的述职很难打动评委，更结构化的表达应该是：<strong>“提出问题，定义问题，分析问题，解决问题，最后是展望未来”</strong>。</p><p>这是一个经典的表述问题的结构，也是麦肯锡推荐的问题解决的框架。</p><p><img src="https://aimak.cn/blog_img/manager/maikenxi01.jpeg" alt="图片"></p><p>类似的框架还有 zoom in&#x2F;zoom out。 我们说事情时，应该像电影镜头一样，先从远拉近，再由近拉远。zoom in 是先从宏观背景开始，首先让大家知道你的事情发生的背景，为什么这事重要？然后讲到具体细节，怎么做成的？解决了什么问题？背后的思考是什么？最后 Zoom out，再从细节调回到整体，结果是什么，带来的客户价值是什么，你对未来的思考是什么。</p><p>★ 2.价值的背后</p><p>把价值说清楚的确很重要，正所谓：路走对了，就不怕远。如果你连价值都不明确，后面做的再多也是白搭。但是，仅仅阐述价值也是不够的，会让人觉得你有邀功之嫌。</p><p>比如你说：“我主导研发的风控系统把公司的坏账率从5%降低到2%”。这样的表述是不够的，你还需要把价值背后的过程和思考说清楚。对于这个结果，评委可能会问：</p><ol><li>之前为什么那么高？</li><li>为什么你的方法可以降低？是如何归因的？</li><li>具体解决了什么问题？</li><li>是否可以总结出一套办法，以后别人也能用这个办法解决这些问题？</li></ol><p>如果你在评委提问之前，就能对这些问题进行深入思考和适当呈现。那么你就是既有结果又有过程了。</p><p>通过这些案例，我们可以看到具备结构化思维，可以帮助我们快速的理清处理问题的思路，提升工作效率。经常锻炼结构化思维，可以极大的提升我们职场竞争力，让工作有条不紊，事半功倍。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术团队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理者核心能力如何提升</title>
      <link href="/2019/07/06/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E8%80%85%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87/"/>
      <url>/2019/07/06/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E8%80%85%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>今天读到腾讯大学文章《互联网领导者升级的7种武器》，有感而发，在互联网背景下，尤其互联网+企业，管理者的核心能力应该是什么，从哪些维度升级？</p><p> <strong>一</strong> </p><p><strong>行业咖眼中的互联网领导力五要素</strong></p><p>先看一个行业咖的观点，刘润在《5分钟商学院》书里讲述过，互联网时代领导力的五个要素：专、小、变、快、远.</p><p><strong>1、专——专注</strong></p><p>选择性注意“威胁、此刻、重要”，只做“专注白名单”中的事。</p><p>第一，利用威胁，没有伞的孩子，才会努力奔跑；</p><p>第二，利用此刻，让最后期限，成为第一生产力；</p><p>第三，利用重要，赋予事情重大的意义。</p><p><strong>2、小——通过变小，获得专注</strong></p><p>“小”，是“专”的孪生兄弟。在高速变化的互联网时代，越来越多的管理者开始懂得，通过变小获得专注。</p><p>第一，创业公司，要克制招人冲动；</p><p>第二，成熟公司，要缩小企业规模；</p><p>第三，转型公司，要追求战略专注。</p><p><strong>3、变——修炼“变革之心”</strong></p><p>面对充满VUCA（易变性、不确定性、复杂性、模糊性）的新世界，如何修炼“变革之心”，刘润提出三根轴：</p><p><strong>第一，给管理加上时间轴</strong>。比如KPI不是错的，只是不适合创业期；粗放管理不是错的，只是不适合成熟期。</p><p><strong>第二，给商业加上概率轴</strong>。有些成功是大概率事件；有些成功是小概率事件，要能意识到外部环境、时机、风险的复杂性，以及内部速度、坚持，或者放弃的重要性。</p><p><strong>第三，给个人加上博弈轴</strong>。面对模糊性看一步，走一步，才能修炼自己的“变革之心”。</p><p><strong>4、快——天下武功，唯快不破</strong></p><p>在互联网变革时代，唯有用内部的快，响应外部的变，才能抓住时代机遇。如何训练“以快应变”的领导力，刘润建议大家注意三点：</p><p><strong>第一、不要放弃思考；</strong></p><p><strong>第二、当下就要行动；</strong></p><p><strong>第三、练好刹车转弯。</strong></p><p><strong>5、远——远见</strong></p><p>远见，就是站在未来看今天。谁也不敢说自己能预测未来，但是我们至少可以训练预测未来的几项基础能力：</p><p><strong>第一是洞察力；</strong></p><p><strong>第二是判断力；</strong></p><p><strong>第三是学习力。</strong></p><p> <strong>二</strong> </p><p><strong>腾讯提出的互联网四维领导力</strong></p><p>在2019腾讯T+HR峰会，腾讯咨询助理总经理徐洁以“互联网领导者升级的7种武器”为主题，分享互联网人需要哪些核心领导力。</p><p>徐洁从“提升组织能力、驱动组织绩效、打造全脑效应、注重提升情商”四个维度来谈如何提升互联网领导力的，这四个维度是以下内容：</p><p><strong>1、提升组织能力——四个驱动力因素</strong></p><p>哪些领导力要素可以驱动用户导向、创新和敏捷这些至关重要的组织能力？腾讯咨询通过几十个指标的相关性和驱动性数据分析，发现四点尤为突出：</p><p><strong>（1）明确目标——知道为什么、做什么和如何衡量</strong></p><p>高层在制定目标的时候不用过于担心犯错，更需要关注如何让高层、中层乃至员工“共同看见”，并通过灵活调整和反思学习进行优化。</p><p><strong>（2）建立信任——“信任&#x3D;同理心+共同的价值观+安全可靠”</strong></p><p>信任就像爱，看不见摸不着，每个人都需要，但经常缺乏。如果没有明确目标和共同的价值观作为前提，信任无从谈起。</p><p><strong>（3）有效松绑——在组织中减少不必要的流程和束缚。</strong></p><p>有些互联网组织在经济周期来临时，惊觉“缺了许多功课”，于是拼命补课、着手建立大量流程和规范。这时反而需要注意规避走入“过犹不及”的误区。</p><p><strong>（4）关注创新——变革、突破会成为未来几年的关键词，</strong></p><p>人类大脑天生对熟悉或既有成功路径感到安全，管理者们需要着手建立团队成员对全新路径、打法、行为模式感到安全的氛围。</p><p><strong>2、领导风格升级——“愿景型”+“辅导型”</strong></p><p>为什么有的领导者善于发掘目标、建立信任，而有的领导没日没夜率先投入业务却没有大幅带来绩效？腾讯咨询提出两种领导方式：</p><p><strong>（1）“愿景型”领导——看到未来、描述画面、并激发团队能量。</strong></p><p>腾讯咨询从300多个顶级互联网公司中高层领导者的数据分析来看，排名第一的擅长之处是“愿景型”。</p><p>许多领导者相信企业的初心愿景会比收入、利润这些数值更有意义，就算眼前艰难，依然选择长期相信。</p><p>只是，对于老板来说，需要做好Chief Explain Officer“首席解释官”工作，对于战略方向、文化价值观、战略重点，需要不厌其烦反复宣导，才能提升全员的理解和认同。</p><p><strong>（2）“辅导型”领导——发掘团队的优势，赋能人的成长</strong></p><p>大部分的领导者会关注战略、策略、执行、结果这些“事”上，对“人”的长期发展没那么关注，甚至觉得不重要。</p><p>腾讯咨询，从理论到实际的数据分析都说明，发掘团队的优势、着眼发展等行为，能够强力驱动绩效。</p><p><strong>3、打造全脑效应——高管团队需认知互补</strong></p><p>腾讯咨询建议，作为CEO和HR负责人，需要考虑如何创造机制，让一群人组合成一个更为强大的大脑，并让每一个个体持续升级自我，以适应不同业务战场。</p><p><strong>（1）互联网高管的认知优势</strong></p><p>腾讯调研发现，与传统企业相比，互联网中高管的“思考型”占比上升。</p><p>互联网企业中，倾向提出创意的“发散型”中高管大约占比6%，善于解决问题的“聚焦型”占比57%，适应性强的“行动型”占比19%，而倾向不断琢磨的“思考型”占比18%。</p><p><strong>（2）高层团队需要着力互补</strong></p><p>腾讯咨询建议，从打造高管团队“全脑”效应来看，CEO需要考虑团队中差异性人群长期生存和发展。</p><p>比如“行动型”CEO，可能会嫌弃“思考型”高管想的太多、反应太慢，乃至贻误战机。而“聚焦型”CEO，则常常认为“发散型”高管点子太多、缺乏逻辑、无法落地。</p><p><strong>4、注重提升情商——从自我走向关系，激发出最佳状态。</strong></p><p>腾讯咨询认为，情商作为个人底层操作系统，也是领导风格改善的关键。</p><p><strong>（1）互联网领导者的情商长板</strong></p><p>互联网领导者擅长成就导向、团队协作与积极展望。也愿意“打群架”应对变动不居的世界。</p><p>所谓积极展望，像是环境锻炼出来的成长思维，即使眼前已经亏了100亿、或者股票持续破发，依然能稳定心神、调动正面能量带领组织奋力向前。</p><p><strong>（2）互联网领导者的情商短板</strong></p><p>腾讯咨询认为，互联网领导者不太擅长理解自我、同理心和影响他人。</p><p>对自我情感模式的洞察程度，很大程度驱动着同理心——即洞察他人的能力。而同理心则是建立信任、连接和影响力的基石。</p><p>同时，通过情商分析发现，互联网领导者相对不太擅长发挥影响力，可以看到改变世界、影响他人是许多人内心很爽的事情，但是不太擅长。</p><p>最后，腾讯咨询基于以上四维领导力的分析，提出互联网高管领导力三板斧和中层领导力三板斧。</p><p><strong>5、腾讯版高管领导力的三板斧</strong></p><p><strong>第一、开启认知。</strong></p><p>在战略业务、组织打造和领导力提升等方面，需要高管们更为坦诚分享见解、疑惑甚至尖锐的反馈。</p><p><strong>第二、情商升级。</strong></p><p>过去高管团队注重“脑部”，未来也需要关注“心灵”即情商体系升级。辅导他人、激励式领导、同理心是推荐的3个重点关注素质。</p><p><strong>第三、聚焦核心。</strong></p><p>找到适合自身企业的战略落地和追踪方式。无论采取战略解码或者OKR的方式，集合整个公司的力量在3-5个关键战役上突破。</p><p><strong>6、腾讯版高管领导力的三板斧</strong></p><p><strong>第一、方向驱动。</strong></p><p>对上，打通团队的成果对整个公司的意义；对下，每个员工都知道如何发力贡献价值。</p><p><strong>第二、成长至上。</strong></p><p>现在的人才不仅看给多少钱，更看重未来的成长空间。工作本身的意义和成长契机吸引和激发高绩效成员，同时在工作中可以有空间尝试新方法、新业务。</p><p><strong>第三、信任为基</strong></p><p>团队成员彼此尊重和信任，需要定义团队“心理安全度”。要将真诚、同理、塑造信任纳为己任。</p><p>诸位，从腾讯版的领导力三板斧，你是不是能看出来阿里巴巴九板斧的影子？</p><p>不管怎么样，终于，看到腾讯从管理角度对行业进行理念与模式输出，可喜可贺。</p><p> <strong>三</strong> </p><p><strong>网易的阴性领导力</strong></p><p>最后，再看另外一个大厂的互联网领导力理念。</p><p>“阴性领导力”理念的提出者是网易项目管理专家雷蓓蓓，她写过一本书《网易一千零一夜》，值得推荐。</p><p>网易这个“阴性领导力”（高感受力+高反思力+高感知力），跟阿里巴巴提出的“雌雄同体”的有点异曲同工。</p><p>阴性领导力的理念提出有几个背景：</p><p><strong>一、互联网目前主流的领导风格</strong>，呈现强烈的阳性特征，强势的，结果导向的、简单粗暴的，这种命令控制型的领导模式局限在于，周边遍布着不满情绪和压抑，久而久之影响组织的创造力。</p><p><strong>二、伴随人工智能的兴起</strong>，依赖数据计算和逻辑处理的工作，将会越来越多被替代，而从心出发，具备高感受力、高反思力、高感知力的阴性领导力，将代表着下一代领导力的未来。</p><p>“阴性领导力”核心内容如下：</p><p><strong>1、高感受力</strong></p><p>所谓高感受力，会关注冰山下每个人细微的感受、感觉和感情，而不只是硬邦邦的逻辑、推理和结果。</p><p>作者认为，具备高感受力，首先是一个让人觉得有温度的leader。</p><p>当一件事情遇到困难，持续的努力都没有起色，TA会问，你需要什么帮助？然后一起去找新的可能解法，而不是责问你为什么没有做好。</p><p>交待了几次的事情迟迟没有启动，TA会说“这件事情似乎不在你的兴奋点上，对吗？”，然后仔细听你的诉说，同时思考如何能够让你在做事的同时找到自己的发展。</p><p>一位温度的leader，总是能够最大程度激活个体的能量，通过组织的力量而非个人的力量，让团队完成远大的目标。</p><p><strong>2、高反思力</strong></p><p>所谓高反思能力，不再一味强势坚守自己的观点：“我是对的！你是错的！”而是，时常反观自省：“我可能想错了，原来还可以这样！”</p><p>高反思能力分为三个阶段：</p><p><strong>第一层次，反思通常发生在遭遇巨大变化之时</strong>，特别是面对巨大的打击和挫折，人会因此被迫产生一种自我回观，对之前的行为作出调整。</p><p><strong>第二层次，反思已经变成了一项周期性进行的活动</strong>，每走过一个阶段，就会触发自觉地总结回顾，为后一个阶段积蓄一些改变的动力。</p><p><strong>第三层次，主动反思的意识已经融入了血液</strong>，进行中一旦意识到问题，就会马上响应做出改进。响应速度之快，哪怕在事情发生的前后5分钟，其思维模式和行为模式都在不断进化。</p><p>作者认为，具备高反思能力的人，在心态、思维和意志上，都是非常开放的。一个人如果具备高反思能力，越是环境剧烈变化，越是会锻炼出极强的反脆弱能力。</p><p><strong>3、高感知力</strong></p><p>所谓高感知力，向内看，与初心连接。</p><p>作者说，“我们身边的很多人，包括我自己，从小努力学习，是为了考个好大学；长大后殚精竭虑，是为了找个好工作；然后我们兢兢业业经营自己的事业和人生，是为了得到他人的认可。</p><p>“我们给自己设定了一个又一个的目标，在人生的路上不断狂奔，却渐渐忘了自己为什么要出发。终有一日，某个新的挑战，某件事，某个触动，会让我们停下来，开始调转镜头，看向自己。”</p><p>具备高感知力的人，在践行的同时，会自带超敏锐的感知传感器，一边做一边感知一边调整，迭代反馈都在瞬间同步发生，这才是真正的“知行合一”小编觉得，如果阴性领导力翻译成感性领导力、柔性领导力，感觉也许更好。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术团队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴高级技术专家 至简 聊工程师思维</title>
      <link href="/2019/05/07/%E6%9D%82%E8%AE%B0/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%20%E8%87%B3%E7%AE%80%20%E8%81%8A%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%80%9D%E7%BB%B4/"/>
      <url>/2019/05/07/%E6%9D%82%E8%AE%B0/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%20%E8%87%B3%E7%AE%80%20%E8%81%8A%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里巴巴高级技术专家-至简-聊工程师思维"><a href="#阿里巴巴高级技术专家-至简-聊工程师思维" class="headerlink" title="阿里巴巴高级技术专家 至简 聊工程师思维"></a>阿里巴巴高级技术专家 至简 聊工程师思维</h1><p>本文整理自至简在团队内部的个人分享，希望通过对工程师思维的分析和解读，让工程师能正确对待那些在现实工作中看上去与本职岗位无关，却对团队效能影响极大的一些点和一些事。</p><blockquote><p>至简：阿里巴巴高级技术专家，是集团Service Mesh方向的重要参与者和推动者。曾出版《专业嵌入式软件开发——全面走向高质高效编程》一书，坚信和倡导软件设计是软件质量之根本，并对软件开发的复杂性本质有着深刻的认识，对如何高质高效实施软件开发有着自己独到的见解和方法。</p></blockquote><p>在社会分工的背景下，软件行业的工程师群体被划分成了开发、测试、产品等诸多岗位，以协作的方式共同完成价值创造。高度依赖软件的互联网行业正以全新的方式改善着人们的生活，同时在改善的道路上对价值创造的效能提出了更高的要求，而背后是对个体与团队的协作效能有着更高的诉求。</p><p>专人专岗的协作模式在进一步改善团队的协作效能时所面临的最大挑战在于“岗位墙”，即岗位间衔接不可避免会出现一些模糊地带，而这些模糊地带又很容易相互忽视，导致失去关注而很大程度地拉低了团队效能。比如，开发工程师会认为保证质量是测试工程师单方面的职责；开发工程师不关注用户体验而只需关注实现需求，等等。此外，这种协作模式也会固化个体的思维和心智模式，将个体的思维和心智框定在所处岗位之内，以致对于岗位之外的内容不能很好地理解，使得个体在整个协作活动中会缺乏同理心、系统性，从而影响工作幸福感。</p><p>相信这些现实工作场景读者并不陌生：</p><ul><li>开发工程师对产品工程师所提出的用户体验方面的需求会认为过于吹毛求疵；</li><li>产品工程师因不理解技术的实现原理而提出天马行空、不接地气的需求（我们在此不讨论创新这一特例）；</li><li>测试工程师因为不理解工程效率的内涵而将自己的工作变成了体力活；</li><li>开发工程师不清楚自己对于软件质量的责任，而将那些本因自己做好的琐碎工作心安理得地交给测试工程师去做；</li><li>辛辛苦苦所开发出来的功能，用户抱怨难用。</li></ul><p>这些问题发生的最终结果，一定是团队协作效能的低下。那么在没有找到比专人专岗更好的协作模式的情形下，我们该如何发挥个体的力量去改善团队的协作效能呢？改善的起点在于全面地梳理工程师思维，帮助工程师个体在职场和职业发展中建立起更为全面的思维和视野，以促使每个工程师在协作过程中能最大程度地发挥个体能力去推动团队协作效能的提升。</p><p>我将工程师思维分解为产品、技术和工程三大思维。每个维度主要关注的内容通过几个关键字去表达，如下图所示。下面针对每种思维需要关注的每个词以图中从上至下的顺序去解释。由于解释是基于关键词去展开的，所以段落之间的衔接可能会显得生硬，还请读者见谅。</p><p><img src="https://aimak.cn/blog_img/manager/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%80%9D%E7%BB%B4.jpeg" alt="图片"></p><p><strong>产品思维</strong></p><p>产品思维的起源是用户（或客户）价值。用户价值是通过技术手段以产品或服务的形态去解决用户的痛点，或带去爽点。毫无疑问，工程师在日常工作中应时刻关注并厘清自己的工作与用户（或客户）价值的联系，并且应该通过聚焦于用户价值去安排工作的优先级和分配自己的精力。</p><p>当用户价值足够时，产品能否在市场中立足并真正收获收益，首先考验的是产品的用户体验。良好的用户体验一定是站在用户的角度，基于用户心智来塑造概念，由于概念存在理解和解释成本，所以塑造的概念应足够轻、少且易掌握。概念一旦塑造出来则概念间的关系也随之确定，这些关系基本上决定了产品与用户的交互流程。好的产品体现于“易用”二字，其极致在于迎合用户的本能反应并符合各种生活或专业常识。</p><p>所有产品都存在演进的过程，所创造的用户价值也在被不断地挖掘与探索，那时不同的细化价值需要通过产品特性去区分和表达。特性也是产品差异化的一种体现，特性也间接地确定了软件实现层面的功能模块边界。作为开发工程师，也需要对产品特性有非常透彻的理解，并能将其很好地抽象并转化为软件实现层面的功能模块。特性需要考虑通过售卖license等形式进行开启或关闭去实现售卖，这一点对于2B的产品甚是必要。</p><p>为了产品更好地演进，需要通过数据闭环的形式去检验创造用户价值的效果，让产品的开发、运营、营销工作做到有的放矢。在产品价值创造的道路上，最害怕的事莫过于只顾低头干做加法，做得多却无人关心收效。而我们通过数据化闭环的形式，不仅能让整个产品大团队聚焦于核心价值，还能帮助团队在探索用户价值的道路上理性地做减法。大多情形下，做减法远难于做加法。</p><p><strong>技术思维</strong></p><p>技术思维的源头是需求。需求可以分成市场需求、系统需求、特性需求等不同层次，回答的是技术层面“做什么”的问题。显然，清晰表达的需求以及对需求的精确理解才能确保将事做对。毋容置疑，需求一旦出现偏差所导致的浪费是非常严重的，也正因如此工程师对于需求的质量相当重视。</p><p>需求一旦确立，会基于模块化的思想拆分成多个功能模块去降低实现的局部复杂度，最终将所有功能模块“拼接”在一起去实现整体需求。每个功能模块会安排给一个人或一个团队负责，由于功能模块是需求分解后的产物，容易导致工程师在实现的过程中只看到“树木”而忘记了“森林”。</p><p>性能是工程师在实现一个功能模块时不得不关注的，特别是当功能模块被运用于高频、时效性敏感、算力有限的场合时性能将尤其被关注。在现实中有时会存在工程师乐于追求性能的极致去体现自己的技术实力，甚至出现过早追求性能而滑入过度设计的误区。</p><p>毫无疑问，一个正规的团队，对于功能模块的开发工作多会以项目制、多个迭代的方式去完成交付。不少工程师这里会有一个误区，忘记了敏捷思想所倡导的“项目计划的目的是为了适应变化”，而是将“按时交付”当作是天职，各种赶工爬到终点时却毫不意外地看到了“一地鸡毛”的景象。</p><p>在迈向第四次工业革命的道路上，人工智能、大数据、机器学习，Kubernetes、Istio、Knative、Go、Dart、Flutter等新技术不断冲击着工程师已掌握的技能。快速跟上技术的迭代步伐是每个有追求的工程师不断提升自己专业素养的表现之一。工程师的内心一定不缺乏对新技术的追求，憧憬自己所掌握的技术具有一定的先进性。</p><p><strong>工程思维</strong></p><p>工程思维的起点是流程。流程的背后是科学，以既定的步骤、阶段性的输入&#x2F;输出去完成价值创造，通过过程控制确保最终结果让人满意。由于流程涉及每一个工程师的工作质量与效率，其含义不只在于定义、工具化、检查等内容，而是应基于工程师的日常工作习惯，将流程与工程师的工作环境无缝整合。“无缝”体现于流程中的概念与工程师群体已建立的专业常识相一致、没有增加毫无价值的负担，根本仍是确保易用性。</p><p>机制的含义是通过对所需解决问题的分析，以一种模式去解决同类问题。机制应体现一定的系统性，而非“头痛治头，脚痛治脚”。系统性不是一开始就能被洞察到，可能在演进的过程中逐步发现和完善的，因而需要工程师在工作的过程中不时回顾并付诸实践去落实。对于工程师来说，机制是通过系统性的软件设计去达成的。</p><p>可以说产品质量直接决定了工程师的工作和生活幸福感。一个质量不可靠的产品一定会给用户和工程师自己带去麻烦，甚至造成无法挽回的经济损失并造成负面的社会影响。对于工程师来说，那势必打乱个体的工作与生活节奏。为了让产品的质量做到可靠，单元测试、静态分析、动态分析等确保工程质量的手段应成为工程师的基本工作内容，通过将这些手段与CI（Continuous Integration）流程进行整合去持续构建起对软件产品的质量信心。</p><p>在互联网行业，除了软件产品的质量得可靠外，风险可控是另一个不能忽视的内容。而风险可控是建立于系统性机制和质量可靠之上的。对于服务端软件来说愈是如此。风险往往出现于资源使用的极端场景，当从外部涌入的过多事务远超软件产品的处理能力时，需要有一定的机制让整个产品能相对平滑地应对，或是扩充资源、或是限制涌入事务的流量。</p><p>软件所需的机器成本是比较容易忽视的话题，软件成本不只与软件性能相关，还与软件之间的依赖、技术方案等因素相连。当一个软件需要从公司的内部对外输出时，平时忽视对成本的关注就会暴露出成本问题。比如，为了运行某个软件需要数量庞大的计算资源，所导致的资金开销对于客户来讲很可能是无法接受的。</p><p>至此，大致介绍完了自己所理解的工程师思维。</p><p><strong>延伸</strong></p><p>了解工程师思维的价值在于，工程师个体需要在工作中逐步建立起产品、技术和工程三大思维，以便用更为全面的视角去看待日常工作中所面临的困境和困惑。当站在单一的思维去看待所面临的问题时可能觉得不合理，但从三大思维层面去审视时所得到结论可能完全相反。从团队协作的角度，只有团队中有更多的个体从多维度去进行思考，才容易发现岗位间衔接的那些无人问津的灰色地带，进而通过补位、助攻去更大程度地发挥团队的效能。</p><p>显然，不同岗位、不同职责的工程师对于这三大思维的深度要求是不一样的，但从多维度去思考却应是每个工程师都应该具备的素养。</p><p>最后，也给读者留下一些问题，同样期待您在公众号后台留言分享自己的思考。</p><ul><li>问题1：</li></ul><p>为什么互联网行业对于团队效能的要求更高？背后有什么必然原因吗？</p><ul><li>问题2：</li></ul><p>有些互联网企业进行产研测（指产品、研发和测试）融合的探索，融合的本质是什么？如何表明产研测做到了真正融合？</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术 TL 的核心职责</title>
      <link href="/2019/04/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%20TL%20%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3/"/>
      <url>/2019/04/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%20TL%20%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="技术-TL-的核心职责"><a href="#技术-TL-的核心职责" class="headerlink" title="技术 TL 的核心职责"></a>技术 TL 的核心职责</h1><p>技术 TL 的核心职责</p><blockquote><p>在之前分享的文章《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655822815&idx=1&sn=be007e648940ecfac3dbccaef0b6c03f&chksm=bd74ee088a03671ebf9a2e3fc75bb5cd38c38f2f23c09f65792d8345f93737710d40f8af45f5&scene=21#wechat_redirect">如何成为优秀的技术主管？</a>》中，阿里巴巴高级技术专家云狄从开发规范、开发流程、技术规划与管理三个角度，分享对技术 TL 的理解与思考。</p></blockquote><p>今天的文章，他将继续深入探讨这一话题，从管理的角度分享技术 TL 的核心职责，主要分为如下几个方面与大家共同探讨、交流：</p><ul><li><strong>团队建设</strong></li><li><strong>团队管理</strong></li><li><strong>团队文化</strong></li><li><strong>沟通与辅导</strong></li><li><strong>招聘与解雇</strong></li></ul><p>互联网公司的技术团队管理通常分为两个方向：技术管理和团队管理，互联网公司的技术 TL 与传统软件公司的 PM 还是有很大的区别。</p><p>传统软件公司的 PM 更多注重于对项目的管理，包括项目任务拆解、项目进度以及风险等。</p><p>对于多数互联网公司而言，技术 TL 更多的职责不再局限于项目角度，而是对业务与技术都要有深入的了解，就像黑夜里的灯塔，能够引导和修正团队成员前进的航向。</p><p>综合技术和业务角度去深度思考问题，具备一定的前瞻性，并在技术领域投入持续的学习热情，向团队成员传道，补齐短板，提高整个团队的战斗力。</p><p>技术 TL 职责不仅需要制定日常规范，包括开发规范、流程规范等，推动规范的落地，以公有的强制约定来避免不必要的内耗。</p><p>另外一多半的时间可能花在了开发任务分解分配、开发实践、技术架构评审、代码审核和风险识别上，剩余的时间则花在为了保障系统按时交付所需的各种计划、协作、沟通、管理上。</p><p>管理大师彼得·德鲁克说：“组织的目的，就是让平凡的人做出不平凡的事。”</p><p>然而，不是任何一群平凡的人聚集到一起，都能做出不平凡的事。甚至一群优秀的人聚集到一起，也可能只是一个平庸的组织。</p><p>大到一个国家，小到一个团队，任何一个卓越的组织，都必须有一个卓越的领导者。领导者是一个组织的灵魂，领导者在很大程度上决定了组织所能达到的高度。</p><p>阿里有句土话“平凡人、非凡事”，技术团队同样如此，管理者的战略眼光、管理方法、人格魅力等，都会给团队的工作结果带来决定性的影响。</p><p>其实每个公司、每个团队的背景不太一样，从管理学的角度探讨一些问题，没有统一标准的答案，本文中一些观点仅是个人观点，更多是我个人成长为技术 TL 的一些观点理念。</p><p>同时我也是吸取了前辈们一些优秀的管理理念，包括我最为尊敬的通用电气 CEO 杰克·韦尔奇、苹果 CEO 乔布斯、Intel CEO 格鲁夫，国内我最推崇的技术管理者 Robbin（丁香园的技术副总裁）。</p><h3 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h3><hr><p>从 2014 年开始带这块业务技术团队，至今有 5 个年头。回想起来，团队管理中所有能遇上的问题都遇到过了。</p><p>其中的磕磕绊绊数不胜数，完全是在实践当中吸取教训，团队建设这块在这里和大家简单分享一下，当然这里面也有做得不够好的地方。</p><p>在阿里每个人都能感受到拥抱变化，基本上每年组织架构都会调整，甚至有些团队每半年都会调整一次。</p><p>2014 年我也算是被分配到这个团队负责这块业务，这块业务是集团收购一家子公司的业务，整个团队文化和技术体系与阿里有很大的差异化。</p><p>一般来说新官上任三把火，新的技术 TL 空降之后往往会大肆招人，快速推进改革，而且有些技术 TL 喜欢把原来的一些旧将搬进来。</p><p>当时我没有急于这么去做，没有招过一个新员工，而是立足于稳定现有的团队，主要基于以下原因：</p><ul><li><p><strong>团队和业务了解不够深：</strong>对于目前团队的人员以及业务，我不够了解，不清楚这里面有哪些坑和陷阱，一旦初战不利，领导的信任度被透支，在公司恐怕难有立足之地，更不用谈论改造团队，发挥自己的才能了。</p></li><li><p><strong>流程与制度：</strong>针对团队现状存在的一些问题，我初步判断并不是人的问题，很多问题是一些组织、流程、制度上的问题。</p><p>我认为只有好的制度才能造就好的团队，在没有解决现有团队的痼疾之前招聘新人，不但不会带来新的生产力，反而会造成团队的混乱，应该先打下一个好的根基，再招人，才能事半功倍。</p></li><li><p><strong>团队安全感：</strong>不想让团队现有的成员感觉一朝天子一朝臣，担心自己在团队中会被边缘化，成为弃儿。另外一方面能够让现有团队心理比较安全，可以安心地好好工作，不至于发生更多的动荡。</p></li></ul><p>经过了几个月的摸底了解，大概清楚当时团队存在的一些问题和原因：</p><ul><li><strong>业务配合不规范：</strong>产品、运营、研发部门之间配合没有建立合理的工作流程，比如对于产品需求的 PRD 评审没有标准，对于运营需求没有量化指标，大家都是疲于奔命做需求，导致大家的积极性不够高。</li><li><strong>跨团队协作混乱：</strong>跨部门之间的工作配合毫无规范可言，部门之间相互推诿，随便什么业务人员都会随时给研发人员下命令，长此以往，伤害了研发团队的积极性。</li></ul><p>针对以上问题，我主要把协作流程规范梳理了一番，制定了相对合理、规范的产品合作流程，同产品同学约法三章，明确了 PRD 输出的标准和规范，运营的业务需求也统一由产品输出，杜绝一句话需求。</p><p>同产品、前端、UED、QA 团队的协作统一标准流程，下游对上游依赖方输出的工作必须有明确的标准规范，口头说的统统无效，拒绝合作。</p><p>针对跨团队协作乱的情况，我特别想说明一下，由于研发部门不是直接创造收入的业务部门，而是承担业务部门的服务者角色。</p><p>作为一个服务者，往往站在一个被动和弱势的位置上，很容易被业务人员举着收入的大棒指挥你无条件的服从。</p><p>业务部门人员随便指派任务，随意变更需求，团队同学无所适从。这样一来，部门内部无论怎样合理的计划都会被外部的力量轻易打破，让团队同学无所适从，导致大家的工作积极性不高，喜欢互相推卸责任。</p><p>久而久之，员工就产生了自我保护意识，凡工作尽量往后退，凡责任尽量往别处推，不求有功但求无过。</p><p>为打破员工养成的这种自我封闭的保护意识，鼓励员工更加积极主动做事情，我能够做的就是把这些责任都扛在自己身上，亲自去协调每项工作。</p><p>让团队成员没有后顾之忧，让团队同学相信我可以搞定他们担心的事情，出了任何问题我可以来背锅，给自己的团队创造一个相对宽松和自由的工作空间，保护团队不被外部的各种杂事伤害到。</p><h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><hr><p>人往往会高估自己而低估别人，很多管理者都会觉得手下交上来的工作做得不够完美，这里考虑不周那里做的啰嗦，但很多时候你只是看到了他人不擅长的地方，或者只是对方和你的出发点不同给出了不同的解决方案而已。</p><p>很多时候，我们并不如自己想象的那么强。管理者在充分理解一些管理的理念之后，不断地在实际的管理工作中去实践并收集反馈和迭代，这样才能够形成自己的管理风格，并找到最适合当前团队的管理方法。</p><p>作为一个团队的管理者，通常会有两种风格管理策略，简要概括为：</p><ul><li><strong>集权式的管理风格</strong></li><li><strong>放权式的管理风格</strong></li></ul><p><strong>集权式管理</strong>：管理者的风格是偏细节的，定义清晰的工作目标，并且把工作目标分解得非常细致，让手下的团队能按照整个计划步步为营往前推进，这是一种风格，相对来讲比较集权。</p><p>可以说我带这个团队的第一年是这种风格，我甚至会参加每一次需求评审，无论需求大小，会和研发同学一起去写代码。</p><p>对研发团队我会做详细的 Code Review，亲自带领研发团队做技术交流和分享，参与技术讨论确认架构方案，这样以来和大家建立起了充分的信任。</p><p><strong>放权式管理</strong>：定义大的目标，把握大的方向，做关键性的决策。但是并不深入每个细节去管控手下团队的执行细节，以结果为导向。</p><p>我到这个团队一年后，业务流程已经清晰的建立起来了，骨干员工在业务上能够完全领会并且达到我的要求，这个时候放权可以充分调动团队的自主性和创造性，多数技术人员他们喜欢被领导，不喜欢被管理。</p><p>以上这两类管理风格没有对错之分，究竟哪种方式更适合完全取决于团队的状况。</p><p>其实这里我更想说一下关于放权式的管理风格，对于一个制度刚刚建立，流程还没有跑顺畅，团队残缺，骨干员工业务能力不及格的团队，采用放权式管理是错误的。</p><p>你必须事无巨细，从第一线的业务细节抓起，手把手的带员工，教会他们怎么正确的做事情，怎样达到你的要求，手把手的培养业务骨干，搭建团队核心架构。</p><p>这些年我看到过太多的案例，管理层自己从不真正深入业务，也缺乏对业务的深刻理解，没有找到问题的本质原因。</p><p>总是寄希望于招人来解决问题，结果换了一茬又一茬人，问题永远解决不了，而且从来不深刻反思自己是否亲自尝试解决业务问题。很多时候架构反映出来的问题，其实是组织、流程的问题。</p><p>总之，作为管理层，如果自己没有深入一线去发现问题，自己动手去解决问题的决心和勇气的话，那这个团队很难有新的突破和成功。</p><h3 id="团队文化"><a href="#团队文化" class="headerlink" title="团队文化"></a>团队文化</h3><hr><p>在我刚参加工作的前几年，就听过一些关于团队文化和企业文化的一些概念，并没有特别深刻的印象。</p><p>尤其我读了《基业长青》这本书后，让我感受到对于一个企业而言，决定短期的是技巧，决定中期的是战略，决定长期的是文化。</p><p>企业文化对一家公司来说真的很重要，同样团队文化对于一个团队来说也很重要，我在带团队之初也曾经忽视了团队文化的冲击。</p><p>在带领这个团队之初，我私下找一些团队同学做 1on1 沟通，我发现这里面的问题还是比较严重的。</p><p>很多人为了避免故障遭受惩罚，不敢去重构优化代码，把自己封闭到一个很小的圈子，也没有过多的追求和理想，以前也没有末位淘汰机制，大家觉得可以继续吃大锅饭。</p><p>当时部门都是工作多年的老人，老的风气和习惯已经形成了很顽固的不良文化，工作情绪受到很大的影响。</p><p>老的不良的文化包括：</p><ul><li><strong>做事情没有积极性。</strong></li><li><strong>永远不承认自己的错误，永远找借口推卸责任，永远都是别人的问题。</strong></li><li><strong>不求有功但求无过；责任心差，对待工作自我要求低。</strong></li><li><strong>对工作安排喜欢讨价还价。</strong></li></ul><p>在一个不好的文化氛围下，优秀的员工会被排挤，团队没有向心力，也很难留住好的人才，员工流失率会非常高。</p><p>我认为衡量一个团队文化氛围是否有吸引力，有一个很重要的指标，是新员工的流失率：</p><ul><li>如果一个团队氛围非常好，新员工入职以后往往能够快速融入进来，流失率很低。</li><li>如果团队氛围差，新员工入职以后比较茫然难以融入，往往会很快离职，流失率非常高，实际上留不住新员工远远比留不住老员工更可怕。</li></ul><p>接下来我希望给团队树立的文化是：</p><ul><li><strong>坦诚，公开，透明。</strong></li><li><strong>平等相处，消除等级感。</strong></li><li><strong>工作气氛轻松，团队关系和谐。</strong></li><li><strong>敢于担当，主动承担责任。</strong></li><li><strong>成就他人，乐于分享。</strong></li></ul><p>关于团队文化这个话题其实很泛，可以单独写一篇文章出来的。这里我主要基于团队文化以上几点，谈一下我的一些个人的看法。</p><p><strong>坦诚的力量</strong></p><p>首先，我觉得坦诚无论对于一个 TL 还是团队成员来说，坦诚也是一种价值观，对于一个团队的发展来说是非常重要的。</p><p>作为一个 TL，带领一支团队，我觉得最重要的是 TL 本人必须做到坦诚的态度，只有对团队坦诚，才能和团队之间形成信任，只有和团队形成了信任，才能成为一支默契的团队。</p><p><strong>通用电气 CEO 杰克·韦尔奇说过</strong>：什么是信任？当一个领导真诚、坦率、言出必行的时候，信任就出现了，事情就是这么简单。为什么坦诚精神能行得通？很简单，因为坦诚有化繁为简的力量！</p><p>坦诚的性格是管理者最基本的要求，只有管理者坦诚，才能获得团队的信任，作秀式的演讲和奖励并不能够真正获得团队的心，还是需要在工作中脚踏实地一点一滴去做好最平凡普通的事情。</p><p>坦诚能够让你直面自身的缺陷，有针对性地改变自己，解决团队的问题，造就一个互相信任的团队氛围。</p><p>我见过一个比较典型的案例，日常工作中主管对于下属不够坦诚，下属与主管的平时一些工作沟通中，下属做的不够好的地方，主管不及时进行沟通与辅导，结果最后 KPI 考核被打了低绩效。</p><p>换位思考一下，这个被打低绩效的人是我，我也会不服气，有问题你为啥不提前告诉我，让我提前去改正。</p><p>对待下属要有勇气，敢于指出他们的问题，对于表现不好的员工要敢于批评和管理，例如为什么解雇你。</p><p>这些谈话和冲突往往让人感到不舒服，我也承认每次谈低绩效是硬着头皮的，但是你必须有这样的勇气，坦诚不仅仅要对那些表现良好的人，还要对那些表现糟糕的人。</p><p>苹果创始人乔布斯是一个对自己、对别人坦诚得可怕的人，坦诚的残酷，直面事情最真实的一面。</p><p>的确坦诚的态度在很多时候会让别人感觉不舒服，乔布斯粗暴的坦诚态度也备受争议，但我觉得，如果你是一个结果导向的人，还是应该尽量坚持坦诚的态度，否则最终的结果可能远远偏离你的目标。</p><p><strong>允许你的下属 challenge 你</strong></p><p>其次，我再聊一下关于平等相处，消除等级感，这点我觉得最重要的是让大家感受到你的亲和力，不是一个高高在上的领导。</p><p>比如很多时候团队一些技术方案的决策不是你一个人来决定，有时候还是要善于倾听一下团队成员的意见，要允许团队成员 challenge 你。</p><p>其实，国内外要求下属服从的企业文化很普遍，这不一定是坏事，特别是公司如果有想法的人太多，想法又无法统一起来，公司的整体战略呈现精神分裂状态，那基本上就离死不远了。</p><p>所以管理层统一公司战略，一线员工强调使命必达。</p><p>国内的外企格外强调下属的服从性，把这一点作为员工的基本职业素养来培训，常用来讲解的故事就是《把信送给加西亚》，强调上司安排一项工作以后，下属不允许谈任何条件，不允许 challenge 上司，必须无条件服从，克服一切困难也要完成工作任务，以解领导之忧。</p><p>这种执行力让上司感觉很舒服，而且公司管理实施难度也比较低。</p><p>多数管理者都喜欢比较听话的下属，认为顺从的下属更好用。心态上高人一等，不会放低心态倾听下属的意见，即使自己错了也不会承认错误，一方面害怕自己的权威被挑战，另外害怕向下属认错，觉得抹不开面子。</p><p>我不是圣人，作为 TL 曾经也犯过一些错误，我也曾私下里和个别同学道过歉。放开心态，不需要过多的太在意别人的看法，这些我觉得都是无所谓的小事。</p><p>从我个人自身的一些经历来看，其实一味地要求下属服从是有害的，要适当允许你的下属 challenge 你。</p><p>如果一味地要求下属服从，不能进行任何反驳，长时间下来会导致团队的人缺乏思考，只是一味的按照 TL 的想法去执行，当下属内心并不认可工作本身，仅仅出于职业性完成工作，成绩最多是合格，很难达到卓越。</p><p>同时会导致下属缺乏工作积极性主动性，容易养成下属逃避责任的习惯。</p><p>相反我觉得作为 TL 一定要鼓励下属积极主动地思考，让下属能够自己设定成长目标，对工作拥有归属感和责任感。</p><p>尽量给予下属更自由的空间，不要设置过多形式主义的约束；要允许下属去 challenge 你，参与你的决策，甚至质疑你的决策。</p><p>用这种方式增加下属对工作的归属感，工作责任心更强，更积极主动，能够自我驱动。</p><p>当你的决策错误的时候，下属可以帮你纠错，集体的智慧毕竟高于个人，俗话说“三个臭皮匠赛过诸葛亮”。</p><p><strong>Owner 意识</strong></p><p>“Owner 意识”主要体现在两个层面：</p><ul><li><strong>认真负责的态度。</strong>认真负责是工作的底线。</li><li><strong>积极主动的精神。</strong>积极主动是“Owner 意识”更高一级的要求。</li></ul><p>自私确实是人的天性，不是自己的东西，很难谈什么责任感，更不用说主动性了。</p><p>因此，团队管理就是要努力地培养大家的责任感，主人翁意识，想做到这一点，就需要增强团队成员的参与感，让他们知晓并理解所做事情的价值、来龙去脉，不断地强化使命感。</p><p>例如可以将系统、业务范围等根据团队成员的兴趣点、以往项目经历等多种因素划分给指定人负责，并明确赏罚机制。</p><p>要清晰地传达一种思想，那就是：这块东西就是你的，干好了评优、升职、加薪等都会优先考虑；干不好，出事情了，你要负责，我也会负责。</p><p>如果有一天你看到团队成员像呵护自己的孩子一样，去对待自己的工作，那么你的目的已经达到了，他已经完全具备 Owner 意识了。</p><p><strong>建立学习型的组织</strong></p><p>最后一点我要谈的是建立学习型的组织，团队成员要尽可能地分享自己的知识和想法，大家互相学习，也通过分享能够总结自己学习过程中零散的知识点。</p><p>如何建立人才梯队的，其实就是要建立学习型组织，让大家积极参与学习与分享。</p><p>具体做法 KPI 里设置一项技术分享与团队贡献，团队内部轮流进行技术分享，一方面让大家去学习、研究一些前沿技术。</p><p>尤其是团队可能会用到的一些技术储备，如果他真的能把这个技术给大家讲明白的话，那他就是真的掌握了，同时也让其他人开始了解并学习这项技术，同时还能够锻炼其演讲与口才。</p><p>鼓励团队成员敢于去分享，乐于去分享，开放心态成就他人。把技术培训和分享坚持下去，形成这样一种学习型的文化以后，你就会发现整个研发团队的技术能力的提升速度是非常惊人的，并且不会再占用太多额外的时间。</p><p>当你再招一个资历较浅的新员工时，他也能在这种环境中快速提升，通常半年左右时间就能达到非常好的水平。</p><p>当然，一开始的团队可能没有这样的意识，就需要你作为管理者强行去推动，把要求列入 KPI，很认真地考核他，慢慢地，团队就会形成这样的氛围和文化。</p><p>当然建立这种学习型的组织，也可以建立一些读书分享会，把读的一些书籍感受分享给大家，另外一点团队的 Wiki 知识库一定要建立起来，让团队同学把一些日常的技术方案、项目总结、故障总结通过文档的形式积累起来。</p><h3 id="沟通与辅导"><a href="#沟通与辅导" class="headerlink" title="沟通与辅导"></a>沟通与辅导</h3><hr><p>根据美国普林斯顿大学的调查报告，在所有对工作产生影响的因素中，沟通占的比例高达 75%。而我们工作中出现的 80% 问题都是由沟通不当造成的，可见沟通的重要性。</p><p>多数时候，我们只想着表达自己的观点，只关注自己想说什么，我们会尽量使用漂亮的 PPT、华美的语言、一堆的数据、甚至引章据典，而不关心别人听懂没有，没有思考别人是否想听，别人是否听得懂。</p><p>沟通在我们的工作中无处不在，你会发现尤其在技术这个圈子里，能够进行高效沟通的人占比会更少一些。</p><p>沟通按照沟通对象类型通常分为向下沟通(同下属沟通)、横向沟通(跨团队沟通)、向上沟通(同老板沟通)，接下来只讨论如何同下属进行沟通，<strong>最为有效沟通方式</strong>：<strong>一对一沟通。</strong></p><p>一对一沟通，又被称作一对一会议、One-on-one 等，是互联网公司常用的沟通方式。</p><p>一对一沟通虽然被广泛使用，但是涉及的文章却很少，这里我给大家推荐《格鲁夫给经理人的第一课》、《创业维艰 : 如何完成比难更难的事》，这两本书有更多关于一对一沟通的介绍。</p><p>格鲁夫是 Intel 公司的总裁，成功带领 Intel 公司完成了从半导体存储器到微处理器的转型，也是我非常欣赏的一位 CEO。</p><p>《创业维艰》的作者本·霍洛维茨是硅谷的顶级 VC，投资了 Facebook、Twitter 等公司。</p><p>在《格鲁夫给经理人的第一课》一书中，格鲁夫对「一对一沟通」的介绍如下：</p><blockquote><p>在英特尔，一对一会议通常是由经理人召集他的部属召开的，这也是维系双方从属关系最主要的方法。<strong>一对一会议主要的目的在于互通信息以及彼此学习</strong>。经过对特定事项的讨论，上司可以将其技能以及经验传授给下属，并同时建议他切入问题的方式；而下属也能对工作中碰到的问题进行汇报。</p></blockquote><p>在我看来，技术研发同学多数比较内向，不轻易向别人表达自己内心的一些想法。</p><p>一对一沟通的意义是可以使得信息从下而上地传递，同时可以把一些疑问、想法、意见、问题、规划等等和管理者做沟通，从而获得在其它渠道不易获得的信息，保证透明。</p><p><strong>1on1 沟通聊什么</strong></p><p>在《创业维艰：如何完成比难更难的事》这本书中专门拿出了一节提到了一对一沟通（1on1），具体聊那些内容给了一些建议。</p><p>作为 TL 我通常会与团队的人聊以下话题：</p><ul><li>你有没有认为自己的价值和能力被低估了吗？为什么？</li><li>你觉得在工作中能学到东西吗？你最近学到了什么？你还希望在哪些领域进行学习？</li><li>近期这段时间，对自己有哪些满意、不满意的地方？</li><li>目前工作中，有哪些困惑？希望我如何去帮助你？</li><li>对团队和我的一些期待和建议。</li><li>在公司战略和目标方面，你最不清楚的是什么?</li></ul><p>以上这些内容，除了在一对一沟通中交流之外，很难找到别的渠道来有效解决。</p><p>通过这些 1on1 的沟通，真的可以得到很多反馈信息，甚至得到的一些信息令我感到吃惊，原来还有这些细节问题我没有做好。</p><p>一对一沟通构造了一个渠道，这个渠道自下而上，使得以上这些内容都能够被倾听，从而被解决。</p><p><strong>1on1 沟通的一些注意点</strong></p><h4 id="①找个私密的环境"><a href="#①找个私密的环境" class="headerlink" title="①找个私密的环境"></a><strong>①找个私密的环境</strong></h4><p>找个空会议室或者别人听不到谈话的角落，不要在工位或嘈杂的环境中进行，因为私密的环境才能降低沟通中某些话被他人听到的心理压力，才能更轻松和真实的表达自己。</p><h4 id="②最好提前告知-1on1-的团队成员"><a href="#②最好提前告知-1on1-的团队成员" class="headerlink" title="②最好提前告知 1on1 的团队成员"></a><strong>②最好提前告知 1on1 的团队成员</strong></h4><p>一般需要提前 1 周把 1on1 沟通的话题、具体时间通知到团队成员，这样的好处是团队成员可以提前准备下聊的内容，因为临时性的沟通很容易出现因为人类记忆力的问题，导致一些想聊的问题在当时没想到。</p><h4 id="③定期进行"><a href="#③定期进行" class="headerlink" title="③定期进行"></a><strong>③定期进行</strong></h4><p>在《创业维艰》一书中，本·霍洛维茨认为一对一沟通需要保证至少一个月一次。而格鲁夫认为，需要根据部属对工作的熟悉度，而进行不同程度的掌控。</p><p>另外，格鲁夫还认为，事情变化的速度也是影响一对一沟通频率的因素。作为技术研发部门，我通常会 1-2 月进行一次 1on1 沟通。</p><h4 id="④用心倾听并行动"><a href="#④用心倾听并行动" class="headerlink" title="④用心倾听并行动"></a><strong>④用心倾听并行动</strong></h4><p>沟通要有效，用心倾听、保持真诚是必要的前提，否则员工不可能将心中的问题提出来。</p><p>保持真诚需要不敷衍任何团队同学提出的问题，不管这个问题有多尖锐。如果你也不知道如何解决这个问题，不妨和团队同学一起讨论讨论，看看大家能不能一起寻找可行的办法。</p><p>切忌不要讲空话和套话，一旦团队同学发现这是一个无效的沟通渠道之后，「自下而上」的通道就被关闭了。</p><h4 id="⑤适当引导"><a href="#⑤适当引导" class="headerlink" title="⑤适当引导"></a><strong>⑤适当引导</strong></h4><p>并不是每一个员工都懂得一对一沟通的重要性，也不是每一个员工都能主动倾述问题，寻求帮助。很多程序员的性格都是比较内向的，有一些甚至不善于表达自己。</p><p>所以，虽然员工是一对一沟通的「主角」，但是上司也是需要进行适当的引导。</p><p>对于上司已经发现的员工工作中的困难，可以适当的主动提出来，以便于更好地讨论，这也会让员工感到很体贴。</p><h3 id="招聘与解雇"><a href="#招聘与解雇" class="headerlink" title="招聘与解雇"></a>招聘与解雇</h3><hr><p>对于一个团队来说，人才是最核心、关键的。招聘和解雇尤其对于一个新上任的技术 TL，都是一个很大的挑战，接下来我们重点讨论这两个话题。</p><p><strong>招聘</strong></p><p>招聘很多时候取决于公司在什么发展时期，需要招聘什么样的人。在初创时期，本不太可能招聘到清一色的专家人才，这个时候活下来比啥都重要，态度和味道是重点看的。</p><p>在高速发展之后，可能需要引进能带来新思路的一些人才，这取决于业务、技术、组织三者的对齐。那么这个时候，就是既要高技能，又要好的做事态度、习惯。</p><p>在搭建技术团队招聘前，要先明确所搭团队的类型，一般来说有三种不同类型的技术团队，即：</p><ul><li><strong>项目驱动型</strong></li><li><strong>业务驱动型</strong></li><li><strong>技术驱动型</strong></li></ul><p>不同类型的技术团队在招聘时也有很大的不同，比如技术驱动型团队你可能需要一个在中间件、语言功底非常深厚、有大局观的人，业务驱动型的团队可能需要有业务 Sense，并且具备良好技术和业务架构能力的人。</p><p>在招聘这条路上，我也走过弯路，一开始我对候选人的背景、语言功底、架构能力以及运维、数据库方面比较关注，希望能招到全栈的技术人才，后来发现我忽视了一个很重要的点沟通与协作能力、态度。</p><p>后来导致新人来到团队后，虽然技术牛 B，但喜欢闭门造车，不喜欢和别人沟通，团队协作能力不够好，整体产出和效率不高。</p><p>所以在招聘新人的过程中，不能够只盯着候选人有什么经验，会什么框架等技术面，也需要着重考量他们的综合素质，一个领导力好的候选人，能够非常快速地融入团队，也能够非常快的学习一些知识。</p><p>招聘步骤：</p><ul><li><p><strong>根据搭建团队的目标，做好招聘计划</strong>。根据团队自身的定位，招聘合适的人才。</p><p>有几点需要 TL 特别关注的，作为 TL 要对候选人的成长负责，切忌因人设岗、因单独项目而招人。</p><p>比如前端团队招聘一些后端开发，工程团队招聘算法，这样以来可能会导致候选人进来后很难融入到团队，没有存在感，长时间下来会导致新人离职。</p></li><li><p><strong>确定招聘需求（定岗定责）</strong>：列出每个岗位的职责、需要具备的技能及其他要求。招聘需求归根结底是需要什么样的人，与整体业务和组织发展匹配。</p></li><li><p><strong>合理利用人才招聘渠道</strong>。从我自身的经历来看，人才招聘渠道多数通过互联网招聘渠道以及朋友推荐更可靠一些，对于高级别的人才可以采用猎头定向挖人。</p></li></ul><p><strong>人才筛选</strong>：作为技术面试官，对于人才的筛选也是非常重要关键的一个环节，要根据自己团队的目标来选取合适的人才，设定完成的时间期限，将面试的重点放在专业技能、管理能力、价值观（公司认同）等方面。</p><p>一般要求如下：</p><ul><li><strong>和岗位需要的专业技能高度匹配</strong>：专业技术技能面试过关，定岗定责。</li><li><strong>沟通力强</strong>：理解公司的业务，知晓管理层，了解公司的发展方向。</li><li><strong>责任心</strong>：凡事有交代，件件有着落，事事有回音。</li><li><strong>靠谱并自带正能量</strong>：不抱怨，主动解决问题，懂得纪律的重要性，一诺千金。</li><li><strong>价值观认同</strong>：认同公司，有目标有理想、有激情有冲劲。</li><li><strong>背景调查</strong>：非常有用的一个办法，可以大幅度降低选人风险，不用怕麻烦，这个工作的付出永远都是值得的。</li></ul><p>另外，我想说的对于技术面试官需要有一定甄别人才的能力，同时有意识地提高这方面的能力。</p><p>我提供以下几点建议给技术面试官：</p><ul><li><p>如果对候选人有些犹豫和纠结，请你放弃这个候选人，你最担心的问题往往很大概率上会发生。</p></li><li><p>明确我们招聘的候选人标准，比如后端 Java 研发：Java 基础和分布式领域知识技能考察是必须的，少问记忆性问题和太理论性问题，更多地从候选人的一些实践经历中，提取出对这个候选人的更有价值的判断。</p></li><li><p>一面非常重要，要保证客观、公平，后面的交叉和终面往往参考前面的评价反馈，我们今天不仅是为我们的团队选拔人才，更是为公司选拔人才，还是要高标准的要求。</p><p>从心理学角度讲，必须要交叉面试，而且交叉面试官给出的反馈往往是比较客观、中肯的，而且要以交叉面试官的评价为主。</p></li><li><p>面试官切忌拿自己擅长的东西去考察候选人，需要认真的看候选人的简历，从候选人的经历中去考察这个人的综合能力。</p></li></ul><p>一个团队的健康发展，最重要的是核心技术人，所以招聘工作必须谨慎，一旦有人加入就等于同上了一艘船，其中的纠结、痛苦、欢喜都要一起面对。</p><p>招募一个不合适人员的成本不仅仅是薪资那么简单。所以请一定要放过那些经验不错、资质不错但是很犹豫匹配度、落地融入堪忧的面试者，其结局大部分都是彼此痛苦。</p><p>作为技术 TL 最成功的是招到比你更优秀的人，你不需要担心自己会不会被取代：</p><ul><li><strong>一是成就个人和成就团队</strong>，作为 TL 应该抱着如何成就团队的发展思路，不能让自己成为天花板，本身技术就不应该是你最擅长的事情！</li><li><strong>二是兼容并蓄，发展多样性</strong>。刘邦善用汉初三杰，单项能力不如韩信、张良。TL 不要以自己的长短来衡量招聘的人，而是看团队技能视图的缺口和发展项。</li></ul><p><strong>解雇</strong></p><p>解雇员工通常更多的是针对触犯公司文化、原则红线，或者持续无法跟上公司节奏的员工进行的处理。</p><p><strong>在阿里也有这么一句土话：</strong>“如果你没有开除或解雇过一位员工，算不上真正合格的管理者”，大多数技术管理者性格比较随和，不喜欢开除员工。</p><p>但是出现触犯红线的员工或者跟不上节奏的员工，尤其是不认可团队价值观的同学，会把一些负面情绪、行为影响到团队其他同学，因此需要杀伐决断，当机立断采用合适的方法让员工离开。</p><p>当然，如果只是能力跟不上的员工，你也可以推荐给其他公司适合的岗位，让和自己一起奋战过的兄弟有一个好归宿，也会让在职的员工感觉温暖。</p><p>整体上“慈不掌兵”，在开人这件事情上，高级管理者不要过于犹豫，为了一两个人最后影响整体团队的士气反而得不偿失。</p><p>多数互联网公司对于技术人员都有相应的 KPI 考核，对于达不到预期的人员会进行淘汰。</p><p>解雇尤其对于新上任的技术主管还是有一定挑战的，我相信人的本性还是善良的，作为技术 TL 不想让团队成员面对这一难题，包括我自己在内。</p><p>一家公司在成长，组织肯定要升级，人员的新老交替也是正常的。如果团队成员的表现达不到预期，不通过 KPI 考核机制告诉他，也许他不会意识到自身的一些问题，他永远不会成长起来，相对短期这些经济回报而言，个人的成长更为关键重要。</p><p><strong>在阿里有这么一句土话：</strong>“不经历 3.25 的人生，不是完美的阿里之旅”，当你处于发展的低谷时，经历一次末位考核结果也许能够让他彻底清醒，认识到自己的不足，彻底激发自己的潜能，能够触底反弹。</p><p>心理学上有个著名的邓宁-克鲁格效应，又称达克效应。大意是，人很容易对自我产生认知偏差，最简单来说，就是会过于高估自己。</p><p>达克效应的曲线图：</p><p><img src="https://aimak.cn/blog_img/dakeer.jpeg" alt="图片"></p><p>上面的图片上反映出，大部分人其实都处于愚昧之巅。人能够成长为智者和大师要先从愚昧之巅，掉到绝望之谷，然后辛苦攀爬，积累知识和经验，成为智者和大师。</p><p>有担当的管理者的一个重要责任，就是把下属从愚昧之巅推向绝望之谷，至于能否爬上开悟之坡，看个人造化。</p><p>一个合格的技术 TL 必须要给团队成员塑造一个绝望山谷，同时还要让他看到一个开悟之坡，这样员工会不断突破自我。</p><p>作为一个有担当的管理者，我们不应该是一个老好人的角色，也要有冷酷无情的一面。</p><p><strong>阿里也有一句土话：</strong>“心要仁慈，刀要快”，当团队中出现一些达不到团队要求的人，管理者应该主动去拉他一把，如果多次尝试，最终达不到预期，应该请他离开。</p><p>因为到了中途，再被残酷淘汰，无论对组织，还是对个人，损失都更大。</p><p>每一位开发者眼中，都有自己理想中的技术管理者。你认为优秀的技术 TL 身上有哪些特质？欢迎在留言区讨论，与大家分享交流。</p><p><em>作者**：</em>云狄*</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术团队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云 Redis 开发规范</title>
      <link href="/2019/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E4%BA%91%20Redis%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2019/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E4%BA%91%20Redis%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍在使用阿里云Redis的开发规范，从下面几个方面进行说明。</p><ul><li><p>键值设计</p></li><li><p>命令使用</p></li><li><p>客户端使用</p></li><li><p>相关工具</p></li></ul><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1、key名设计"><a href="#1、key名设计" class="headerlink" title="1、key名设计"></a><strong>1、key名设计</strong></h4><h5 id="可读性和可管理性"><a href="#可读性和可管理性" class="headerlink" title="可读性和可管理性"></a>可读性和可管理性</h5><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ugc:video:1</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h5><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125;简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125;。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="不要包含特殊字符"><a href="#不要包含特殊字符" class="headerlink" title="不要包含特殊字符"></a>不要包含特殊字符</h5><p>反例：包含空格、换行、单双引号以及其他转义字符</p><h4 id="2、value设计"><a href="#2、value设计" class="headerlink" title="2、value设计"></a><strong>2、value设计</strong></h4><h5 id="拒绝bigkey"><a href="#拒绝bigkey" class="headerlink" title="拒绝bigkey"></a>拒绝bigkey</h5><p>防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p><h5 id="选择适合的数据类型"><a href="#选择适合的数据类型" class="headerlink" title="选择适合的数据类型"></a>选择适合的数据类型</h5><p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)。了解下，Redis 为什么这么快？</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line"></span><br><span class="line">set user:1:age 19</span><br><span class="line"></span><br><span class="line">set user:1:favor football</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 19 favor football</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="控制key的生命周期"><a href="#控制key的生命周期" class="headerlink" title="控制key的生命周期"></a>控制key的生命周期</h5><p>redis不是垃圾桶，建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><h5 id="1、O-N-命令关注N的数量"><a href="#1、O-N-命令关注N的数量" class="headerlink" title="1、O(N)命令关注N的数量"></a><strong>1、O(N)命令关注N的数量</strong></h5><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><h5 id="2、禁用命令"><a href="#2、禁用命令" class="headerlink" title="2、禁用命令"></a><strong>2、禁用命令</strong></h5><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><h5 id="3、合理使用select"><a href="#3、合理使用select" class="headerlink" title="3、合理使用select"></a><strong>3、合理使用select</strong></h5><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><h5 id="4、使用批量操作提高效率"><a href="#4、使用批量操作提高效率" class="headerlink" title="4、使用批量操作提高效率"></a><strong>4、使用批量操作提高效率</strong></h5><p>1.原生命令：例如mget、mset。</p><p>2.非原生命令：可以使用pipeline提高效率。</p><p>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p><p>注意两者不同：</p><p>原生是原子操作，pipeline是非原子操作</p><p>pipeline可以打包不同的命令，原生做不到</p><p>pipeline需要客户端和服务端同时支持。</p><h5 id="5-不建议过多使用Redis事务功能"><a href="#5-不建议过多使用Redis事务功能" class="headerlink" title="5.不建议过多使用Redis事务功能"></a><strong>5.不建议过多使用Redis事务功能</strong></h5><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)。分布式事务不理解？一次给你讲清楚！</p><h5 id="6、Redis集群版本在使用Lua上有特殊要求"><a href="#6、Redis集群版本在使用Lua上有特殊要求" class="headerlink" title="6、Redis集群版本在使用Lua上有特殊要求"></a><strong>6、Redis集群版本在使用Lua上有特殊要求</strong></h5><p>1、所有key都应该由 KEYS 数组来传递，redis.call&#x2F;pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn” 2、所有key，必须在1个slot上，否则直接返回error, “-ERR eval&#x2F;evalsha command keys must in same slotrn”</p><h5 id="7、monitor命令"><a href="#7、monitor命令" class="headerlink" title="7、monitor命令"></a><strong>7、monitor命令</strong></h5><p>必要情况下使用monitor命令时，要注意不要长时间使用。</p><h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><h5 id="1、避免多个应用使用一个Redis实例"><a href="#1、避免多个应用使用一个Redis实例" class="headerlink" title="1、避免多个应用使用一个Redis实例"></a><strong>1、避免多个应用使用一个Redis实例</strong></h5><p>不相干的业务拆分，公共数据做服务化。</p><h5 id="2、使用连接池"><a href="#2、使用连接池" class="headerlink" title="2、使用连接池"></a><strong>2、使用连接池</strong></h5><p>可以有效控制连接，同时提高效率，标准使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    //具体的命令</span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(&quot;op key &#123;&#125; error: &quot; + e.getMessage(), key, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span><br><span class="line">    if (jedis != null) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="3、熔断功能"><a href="#3、熔断功能" class="headerlink" title="3、熔断功能"></a><strong>3、熔断功能</strong></h5><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><h5 id="4、合理的加密"><a href="#4、合理的加密" class="headerlink" title="4、合理的加密"></a><strong>4、合理的加密</strong></h5><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><h5 id="5、淘汰策略"><a href="#5、淘汰策略" class="headerlink" title="5、淘汰策略"></a><strong>5、淘汰策略</strong></h5><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p>其他策略如下：</p><p>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p><p>allkeys-random：随机删除所有键，直到腾出足够空间为止。</p><p>volatile-random:随机删除过期键，直到腾出足够空间为止。</p><p>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p><h3 id="四、相关工具"><a href="#四、相关工具" class="headerlink" title="四、相关工具"></a>四、相关工具</h3><h5 id="1、数据同步"><a href="#1、数据同步" class="headerlink" title="1、数据同步"></a><strong>1、数据同步</strong></h5><p>redis间数据同步可以使用：redis-port</p><h5 id="2、big-key搜索"><a href="#2、big-key搜索" class="headerlink" title="2、big key搜索"></a><strong>2、big key搜索</strong></h5><p>redis大key搜索工具</p><h5 id="3、热点key寻找"><a href="#3、热点key寻找" class="headerlink" title="3、热点key寻找"></a><strong>3、热点key寻找</strong></h5><p>内部实现使用monitor，所以建议短时间使用facebook的redis-faina 阿里云Redis已经在内核层面解决热点key问题</p><h3 id="五、删除bigkey"><a href="#五、删除bigkey" class="headerlink" title="五、删除bigkey"></a>五、删除bigkey</h3><p><strong>1.下面操作可以使用pipeline加速。</strong></p><p><strong>2.redis 4.0已经支持key的异步删除，欢迎使用。</strong></p><h5 id="1、Hash删除-hscan-hdel"><a href="#1、Hash删除-hscan-hdel" class="headerlink" title="1、Hash删除: hscan + hdel"></a>1、Hash删除: hscan + hdel</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void delBigHash(String host, int port, String password, String bigHashKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = new ScanParams().count(100);</span><br><span class="line">    String cursor = &quot;0&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        ScanResult&lt;Entry&lt;String, String&gt;&gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);</span><br><span class="line">        List&lt;Entry&lt;String, String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        if (entryList != null &amp;&amp; !entryList.isEmpty()) &#123;</span><br><span class="line">            for (Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; while (!&quot;0&quot;.equals(cursor));</span><br><span class="line"></span><br><span class="line">    //删除bigkey</span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、List删除-ltrim"><a href="#2、List删除-ltrim" class="headerlink" title="2、List删除: ltrim"></a>2、List删除: ltrim</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void delBigList(String host, int port, String password, String bigListKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    long llen = jedis.llen(bigListKey);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    int left = 100;</span><br><span class="line">    while (counter &lt; llen) &#123;</span><br><span class="line">        //每次从左侧截掉100个</span><br><span class="line">        jedis.ltrim(bigListKey, left, llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终删除key</span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、Set删除-sscan-srem"><a href="#3、Set删除-sscan-srem" class="headerlink" title="3、Set删除: sscan + srem"></a>3、Set删除: sscan + srem</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void delBigSet(String host, int port, String password, String bigSetKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = new ScanParams().count(100);</span><br><span class="line">    String cursor = &quot;0&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        if (memberList != null &amp;&amp; !memberList.isEmpty()) &#123;</span><br><span class="line">            for (String member : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey, member);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; while (!&quot;0&quot;.equals(cursor));</span><br><span class="line"></span><br><span class="line">    //删除bigkey</span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、SortedSet删除-zscan-zrem"><a href="#4、SortedSet删除-zscan-zrem" class="headerlink" title="4、SortedSet删除: zscan + zrem"></a>4、SortedSet删除: zscan + zrem</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delBigZset</span><span class="params">(String host, <span class="type">int</span> port, String password, String bigZsetKey)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ScanParams</span> <span class="variable">scanParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>().count(<span class="number">100</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (tupleList != <span class="literal">null</span> &amp;&amp; !tupleList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey, tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">&quot;0&quot;</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里毕玄：我在系统设计上犯过的14个错</title>
      <link href="/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/"/>
      <url>/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p><strong>|</strong> 本文转载至 Hello Java。</p><p>这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中），发现大的错误基本集中在前面几年，从这个点看起来能比较自豪的说在最近的几年在系统设计的掌控上确实比以前成熟了很多。</p><p>除了自己犯的错以外，也还看过其他同学犯的一些错，这个在后面再写一篇文章来分享下，同时也征集大家印象深刻的推倒重来的系统设计的错。</p><p><strong>第1个错</strong></p><p>在设计服务框架时，我期望服务框架对使用者完全不侵入，于是做了一个在外部放一个.xml文件来描述spring里的哪些bean发布为服务的设计，这个版本发布后，第一个小白鼠的用户勉强在用，但觉得用的很别扭，不过还是忍着用下去了，到了发布的时候，发现出现了两个问题，一是这个xml文件研发也不知道放哪好，所以到了发布的时候都不知道去哪拿这个xml文件。</p><p>这个设计的关键错误就在于在设计时没考虑过这个设计方式对研发阶段、运维阶段的影响，后来纠正这个错误的方法是去掉了这个xml文件，改为写了一个Spring FactoryBean，用户在spring的bean配置文件中配置下就可以。</p><p>因此对于一个架构师来说，设计时在全面性上要充分考虑。</p><p><strong>第2个错</strong></p><p>服务框架在核心应用上线时，出现了前端web应用负载高，处理线程数不够用的现象，当时处理这个故障的方式是回滚了服务框架的上线，这个故障排查了比较长的时间后，查到的原因是服务框架用的JBoss Remoting在通信时默认时间是60s，导致一些处理速度慢的请求占据了前端web应用的处理线程池。</p><p>上面这里故障的原因简单来说是分布式调用中超时时间太长的问题，但更深层次来思考，问题是犯在了设计服务框架时的技术选型，在选择JBoss-Remoting时没有充分的掌握它的运行细节，这个设计的错误导致的是后来决定放弃JBoss-Remoting，改为基于Mina重写了服务框架的通信部分，这里造成了服务框架的可用版本发布推迟了两个多月。</p><p>因此对于一个架构师来说，在技术选型上对技术细节是要有很强的掌控力的。</p><p><strong>第3个错</strong></p><p>在服务框架大概演进到第4个版本时，通信协议上需要做一些改造，突然发现一个问题是以前的通信协议上是没有版本号的，于是悲催的只能在代码上做一个很龌蹉的处理来判断是新版本还是老版本。</p><p>这个设计的错误非常明显，这个其实只要在最早设计通信协议时参考下现有的很多的通信协议就可以避免了，因此这个错误纠正也非常简单，就是参考一些经典的协议重新设计了下。</p><p>因此对于一个架构师来说，知识面的广是非常重要的，或者是在设计时对未来有一定的考虑也是非常重要的。</p><p>说到协议，就顺带说下，当时在设计通信协议和选择序列化&#x2F;反序列化上没充分考虑到将来多语言的问题，导致了后来在多语言场景非常的被动，这也是由于设计时前瞻性的缺失，所谓的前瞻性不是说一定要一开始就把未来可能会出现的问题就解掉，而是应该留下不需要整个改造就可以解掉的方法，这点对于架构师来说也是非常重要的。</p><p><strong>第4个错</strong></p><p>在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。</p><p>这个设计的错误主要在于没有考虑生产环境中走硬件负载均衡后，这种单个长连接方式带来的问题，这个错误呢还真不太好纠正，当时临时用的一个方法是服务调用方的连接每发送了1w个请求后，就把连接自动断开重建，最终的解决方法是去掉了负载均衡设备这个中间点。</p><p>因此对于一个架构师来说，设计时的全面性要非常的好，我现在一般更多采用的方式是推演上线后的状况，一般来说在脑海里过一遍会比较容易考虑到这些问题。</p><p><strong>第5个错</strong></p><p>服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本，当时只好用一个临时的扫全网机器的方法来解决。</p><p>这个问题后来纠正的方法是在服务发布和调用者在连接我们的一个点时，顺带把用的服务框架的版本号带上，于是就可以很简单的知道全网的服务框架目前在运行的版本号了。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的，推演能起到很大的帮助作用。</p><p><strong>第6个错</strong></p><p>服务框架这种基础类型的产品，在发布时会碰到个很大的问题，就是需要通知到使用者去发布，导致了整个发布周期会相当的长，当时做了一个决定，投入资源去实现完全动态化的发布，就是不需要重启，等到做的时候才发现这完全就是个超级大坑，最终这件事在投入两个人做了接近半年后，才终于决定放弃，而且最终来看其实升级的问题也没那么大。</p><p>这个问题最大的错误在于对细节把握不力，而且决策太慢。</p><p>因此对于一个架构师来说，技术细节的掌控非常重要，同时决策力也是非常重要的。</p><p><strong>第7个错</strong></p><p>服务发布方经常会碰到一个问题，就是一个服务里的某些方法是比较耗资源的，另外的一些可能是不太耗资源，但对业务非常重要的方法，有些场景下会出现由于耗资源的方法被请求的多了些导致不太耗资源的方法受影响，这种场景下如果要去拆成多个服务，会导致开发阶段还是挺痛苦的，因此服务框架这边决定提供一个按方法做七层路由的功能，服务的发布方可以在一个地方编写一个规则文件，这个规则文件允许按照方法将生产环境的机器划分为不同组，这样当服务调用方调用时就可以做到不同方法调用到不同的机器。</p><p>这个功能对有些场景来说用的很爽，但随着时间的演进和人员的更换，能维护那个文件的人越来越少了，也成为了问题。</p><p>这个功能到现在为止我自己其实觉得也是一直处于争议中，我也不知道到底是好还是不好…</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p>减少犯错误的方法：<strong>多阅读、多实践、多总结。</strong></p><p><strong>第8个错</strong></p><p>服务框架在用的越来越广后，碰到了一个比较突出的问题，服务框架依赖的jar版本和应用依赖的jar版本冲突，服务框架作为一个通用技术产品，基本上没办法为了一个应用改变服务框架自己依赖的jar版本，这个问题到底怎么去解，当时思考了比较久。</p><p>可能是由于我以前OSGi这块背景的原因，在设计上我做了一个决定，引入OSGi，将服务框架的一堆jar处于一个独立的classloader，和应用本身的分开，这样就可以避免掉jar冲突的问题，在我做了引入OSGi这个决定后，团队的1个资深的同学就去做了，结果是折腾了近两个月整个匹配OSGi的maven开发环境都没完全搭好，后来我自己决定进去搞这件事，即使是我对OSGi比较熟，也折腾了差不多1个多月才把整个开发的环境，工程的结构，以及之前的代码基本迁移为OSGi结构，这件事当时折腾好上线后，效果看起来是不错的，达到了预期。</p><p>但这件事后来随着加入服务框架的新的研发人员越来越多，发现多数的新人都在学习OSGi模式的开发这件事上投入了不少的时间，就是比较难适应，所以后来有其他业务问是不是要引入OSGi的时候，我基本都会建议不要引入，主要的原因是OSGi模式对大家熟悉的开发模式、排查问题的冲击，除非是明确需要classloader隔离、动态化这两个点。</p><p>让我重新做一个决策的话，我会去掉对OSGi的引入，自己做一个简单的classloader隔离策略来解决jar版本冲突的问题，保持大家都很熟悉的开发模式。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p><strong>第9个错</strong></p><p>服务框架在用的非常广了后，团队经常会被一个问题困扰和折腾，就是业务经常会碰到调用服务出错或超时的现象，这种情况通常会让服务框架这边的研发来帮助排查，这个现象之所以查起来会比较复杂，是因为服务调用通常是多层的关系，并不是简单的A–&gt;B的问题，很多时候都会出现A–&gt;B–&gt;C–&gt;D或者更多层的调用，超时或者出错都有可能是在其中某个环节，因此排查起来非常麻烦。</p><p>在这个问题越来越麻烦后，这个时候才想起在09年左右团队里有同学看过G家的一篇叫dapper的论文，并且做了一个类似的东西，只是当时上线后我们一直想不明白这东西拿来做什么，到了排查问题这个暴露的越来越严重后，终于逐渐想起这东西貌似可以对排查问题会产生很大的帮助。</p><p>到了这个阶段才开始做这件事后，碰到的主要不是技术问题，而是怎么把新版本升级上去的问题，这个折腾了挺长时间，然后上线后又发现了一个新的问题是，即使服务框架具备了Trace能力，但服务里又会调外部的例如数据库、缓存等，那些地方如果有问题也会看不到，排查起来还是麻烦，于是这件事要真正展现效果就必须让Trace完全贯穿所有系统，为了做成这件事，N个团队付出了好几年的代价。</p><p>因此对于一个架构师来说，设计时的全面性、前瞻性非常重要，例如Trace这个的重要性，如果在最初就考虑到，那么在一开始就可以留好口子埋好伏笔，后面再要做完整就不会太复杂。</p><p><strong>第10个错</strong></p><p>服务的发布方有些时候会碰到一个现象是，服务还没完全ready，就被调用了；还有第二个现象是服务发布方出现问题时，要保留现场排查问题，但服务又一直在被调用，这种情况下就没有办法很好的完全保留现场来慢慢排查问题了。</p><p>这两个现象会出现的原因是服务框架的设计是通过启动后和某个中心建立连接，心跳成功后其他调用方就可以调用到，心跳失败后就不会被调到，这样看起来很自动化，但事实上会导致的另外一个问题是外部控制上下线这件事的能力就很弱。</p><p>这个设计的错误主要还是在设计时考虑的不够全面。</p><p>因此对于一个架构师来说，设计时的全面性非常重要。</p><p><strong>第11个错</strong></p><p>在某年我和几个小伙伴决定改变当时用xen的模式，换成用一种轻量级的“虚拟机”方式来做，从而提升单机跑的应用数量的密度，在做这件事时，我们决定自己做一个轻量级的类虚拟机的方案，当时决定的做法是在一个机器上直接跑进程，然后碰到一堆的问题，例如从运维体系上来讲，希望ssh到“机器”、独立的ip、看到自己的系统指标等等，为了解决这些问题，用了N多的黑科技，搞得很悲催，更悲催的是当时觉得这个问题不多，于是用一些机器跑了这个模式，结果最后发现这里面要黑科技解决的问题实在太多了，后来突然有个小伙伴提出我们试用lxc吧，才发现我们之前用黑科技解的很多问题都没了，哎，然后就是决定切换到这个模式，结果就是线上的那堆机器重来。</p><p>这个设计的主要错误在于知识面不够广，导致做了个不正确的决定，而且推倒重来。</p><p>因此对于一个架构师来说，知识面的广非常重要，在技术选型这点上非常明显。</p><p><strong>第12个错</strong></p><p>还是上面这个技术产品，这个东西有一个需求是磁盘空间的限额，并且要支持磁盘空间一定程度的超卖，当时的做法是用image的方式来占磁盘空间限额，这个方式跑了一段时间觉得没什么问题，于是就更大程度的铺开了，但铺开跑了一段时间后，出现了一个问题，就是经常出现物理机磁盘空间不足的报警，而且删掉了lxc容器里的文件也还是不行，因为image方式只要占用了就会一直占着这个大小，只会扩大不会缩小。</p><p>当时对这个问题极度的头疼，只能是删掉文件后，重建image，但这个会有个要求是物理机上有足够的空间，即使有足够的空间，这个操作也是很折腾人的，因为得先停掉容器，cp文件到新创建的容器，这个如果东西多的话，还是要耗掉一定时间的。</p><p>后来觉得这个模式实在是没法玩，于是寻找新的解决方法，来满足磁盘空间限额，允许超卖的这两需求，最后我们也是折腾了比较长一段时间后终于找到了更靠谱的解决方案。</p><p>这个设计的主要错误还是在选择技术方案时没考虑清楚，对细节掌握不够，考虑的面不够全，导致了后面为了换掉image这个方案，用了极大的代价，我印象中是一堆的人熬了多次通宵来解决。</p><p>因此对于一个架构师来说，知识面的广、对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第13个错</strong></p><p>仍然是上面的这个技术产品，在运行的过程中，突然碰到了一个虚拟机中线程数创建太多，导致其他的虚拟机也创建不了线程的现象（不是因为物理资源不够的问题），排查发现是由于尽管lxc支持各个容器里跑相同名字的账号，但相同名字的账号的uid是相同的，而max processes是限制在UID上的，所以当一个虚拟机创建的线程数超过时，就同样影响到了其他相同账号的容器。</p><p>这个问题我觉得一定程度也可以算是设计问题，设计的时候确实由于对细节掌握的不够，考虑的不全导致忽略了这个点。</p><p>因此对于一个架构师来说，对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第14个错</strong></p><p>在三年前做一个非常大的项目时，项目即将到上线时间时，突然发现一个问题是，有一个关键的点遗漏掉了，只好赶紧临时讨论方案决定怎么做，这个的改动动作是非常大的，于是项目的上线时间只能推迟，我记得那个时候紧急周末加班等搞这件事，最后带着比较高的风险上了。</p><p>这个问题主要原因是在做整体设计时遗漏掉了这个关键点的考虑，当时倒不是完全忽略了这个点，而是在技术细节上判断错误，导致以为不太要做改动。</p><p>因此对于一个架构师来说，对技术细节的掌控是非常重要的，这里要注意的是，其实不代表架构师自己要完全什么都很懂，但架构师应该清楚在某个点上靠谱的人是谁。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解设计模式在Spring中的应用</title>
      <link href="/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：螃蟹<br><a href="http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html">http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html</a><br>Java架构师之路做了编排 </p></blockquote><p>设计模式作为工作学习中的枕边书，却时常处于勤说不用的尴尬境地，也不是我们时常忘记，只是一直没有记忆。</p><p>今天，螃蟹在IT学习者网站就设计模式的内在价值做一番探讨，并以spring为例进行讲解，只有领略了其设计的思想理念，才能在工作学习中运用到“无形”。</p><p>Spring作为业界的经典框架，无论是在架构设计方面，还是在代码编写方面，都堪称行内典范。好了，话不多说，开始今天的内容。</p><p>spring中常用的设计模式达到九种，我们一一举例：</p><p><strong>第一种：简单工厂</strong></p><p>又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 </p><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 </p><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;singletonBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是singletonBean!value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">   &lt;/ bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;itxxzBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;</span><br><span class="line">        singleton=&quot;false&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种：工厂方法（Factory Method）</strong></p><p>通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。</p><p>一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</p><p>螃蟹就以工厂方法中的静态方法为例讲解一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class StaticFactoryBean &#123;</span><br><span class="line">      public static Integer createRandom() &#123;</span><br><span class="line">           return new Integer(new Random().nextInt());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;random&quot;</span><br><span class="line">class=&quot;example.chapter3.StaticFactoryBean&quot;</span><br><span class="line">factory-method=&quot;createRandom&quot; //createRandom方法必须是static的,才能找到</span><br><span class="line">scope=&quot;prototype&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例</span><br><span class="line">      XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;config.xml&quot;));</span><br><span class="line">      System.out.println(&quot;我是IT学习者创建的实例:&quot;+factory.getBean(&quot;random&quot;).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：单例模式（Singleton）</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p><p>spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 </p><p>核心提示点：Spring下默认的bean均为singleton，可以通过singleton&#x3D;“true|false” 或者 scope&#x3D;“？”来指定</p><p><strong>第四种：适配器（Adapter）</strong></p><p>在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</p><p><strong>Adapter类接口</strong>：Target</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface AdvisorAdapter &#123;</span><br><span class="line"></span><br><span class="line">boolean supportsAdvice(Advice advice);</span><br><span class="line"></span><br><span class="line">      MethodInterceptor getInterceptor(Advisor advisor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MethodBeforeAdviceAdapter类</strong>，Adapter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;</span><br><span class="line"></span><br><span class="line">      public boolean supportsAdvice(Advice advice) &#123;</span><br><span class="line">            return (advice instanceof MethodBeforeAdvice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public MethodInterceptor getInterceptor(Advisor advisor) &#123;</span><br><span class="line">            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">      return new MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五种：包装器（Decorator）</strong></p><p>在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ </p><p>首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。<br>spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 </p><p><strong>第六种：代理（Proxy）</strong></p><p>为其他对象提供一种代理以控制对这个对象的访问。 </p><p>从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 </p><p>spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 </p><p><strong>第七种：观察者（Observer）</strong></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 </p><p><strong>第八种：策略（Strategy）</strong></p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>spring中在实例化对象的时候用到Strategy模式在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： </p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/M7B64fHXISuuxb3OYhV7MtTEqMR53b1k2gueQDW4I1oibFLSFGROiaUHUjDRkPBNc0xDfgYnhu5NicENT713wzy4A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>第九种：模板方法（Template Method）</strong></p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p><p>以下是一个具体的例子：<br>JdbcTemplate中的execute方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何激发团队的创造力</title>
      <link href="/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
      <url>/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p><strong>如何激发团队的创造力？</strong></p><p>人生一切难题，知识给你答案。</p><p>提到创意，有一家公司不能不提——皮克斯，《海底总动员》《头脑特工队》《寻梦环游记》……它的每个创意都令人惊叹。</p><p>今天这本书，就带你看看皮克斯有哪些激发创意的高招——</p><p><strong>《创新公司：皮克斯的启示》</strong></p><p><strong>作者: [美] 艾德·卡特姆 埃米·华莱士</strong> </p><p><strong>译者: 靳婷婷</strong> </p><p><strong>出版: 中信出版社</strong></p><p>作者艾德·卡特姆，是皮克斯动画的总裁。他真正厉害的地方不仅是生产创意，而且独创了一套管理创意团队的机制，让天才们能够毫无障碍地通力合作。下面就带你看看他的做法。</p><p><em>1.</em> <strong>设立“智囊团”。</strong>很多公司会设立专门的创意部门，去开发新创意。但皮克斯的智囊团人员从来不是固定的，只要你擅长讲故事、熟悉电影制度，都能加入，包括导演、编剧、故事总监、文化顾问等等。每部电影进行到一定阶段，智囊团就会碰头，讨论新的创意，评价正在制作的电影。</p><p><em>2.</em> <strong>追求最佳效果，不怕“推倒重建”。</strong>几乎所有公司都宣称追求最佳产品质量，可一旦要牺牲大量成本时，很多公司就犹豫了。但皮克斯的电影即便已经制作完毕，一旦有更好的想法，也会推倒重建。你肯定看过《瓦力》，原结局是瓦力救下了心爱的机器人伊娃，但智囊团认为结局没有冲击力，才改为了伊娃违背程序设定，毅然救下瓦力的结尾。也正是这种精益求精的做法，给皮克斯带来了票房和口碑双收的回报。</p><p><em>3.</em> <strong>明确要求员工给出建设性批评。</strong>我们常会听到这样的批评，“这个活动很无聊”“这个方案没有打动我”，但就是不知道到底是哪里不够好。这就是非建设性的批评——只说感受而不点明问题。皮克斯为了杜绝这种现象，明确要求每次样片修改时，都要点出问题并且指出改进的方向。比如“这是重点台词，但现在的表达不够简单有力”。</p><p><em>4.</em> <strong>注重真实，进行“考察旅行”。</strong>很多公司为了获得创意，会广泛收集素材激发灵感。皮克斯在这一点做得更彻底，直接让主创到故事背景地考察旅行。比如以墨西哥为背景的《寻梦环游记》，主角是一个鞋匠世家，主创特意拜访了当地著名的鞋匠，了解做鞋的各种工艺。片中的万寿菊、剪纸等物品，也都是现实中墨西哥街头常见的装饰物。</p><p><em>5.</em> <strong>确保制作中只有导演才有最终决定权。</strong>一个项目参与的人越多，就越容易出现很多人给出意见、话语权混乱的情况，甚至还可能导致由高层“外行指导内行”。在皮克斯，绝不允许这种情况发生，直接明文规定导演在制作中有最终决定权，即便是高层的建议，导演也可以合理回绝。</p><p><em>6.</em> <strong>不浪费时间，尽快试错。</strong>创意制作过程难免会出现问题，很多公司会停下来讨论，一定要找出最完美的方案才继续。但皮克斯不会原地纠结，认为一个方案不行就及时否定，然后尽快尝试其他方向，而不是等待最佳方案。比如《怪物电力公司》，就经过了无数次否定和尝试的过程，主角设定从一个30岁的男人，变成小男孩，最终又改为小女孩，才进入到剧本阶段。</p><p><em>7.</em> **营造团队安全感，**公开分享失误**。**研究发现，想要团队成员能够高效开展工作，给员工营造良好的心理安全感非常关键。不同于其他公司，员工犯错会严厉责备，皮克斯会由领导层带头，公开分析犯错的原因。这让整个公司有良好的氛围，员工都愿意公开表达意见，避免问题再犯。&gt;&gt;&gt;<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjAxOTU4MA==&mid=3009217590&idx=1&sn=14532c49bc8cb0817544181a10e9309f&chksm=90460825a7318133e7905c02e708d5222abfea930e61b4216f15b7504e39734bcd41cfb0a26d&scene=21#wechat_redirect">如何正确对待错误，戳此查看另一篇文章</a></p><p><em>8.</em> <strong>重视新老员工的传承，制定培训制度。</strong>每个公司都重视新老员工的传承，但如果不落实到具体的制度上，最后很可能会变成一纸空话。皮克斯曾经有过一次教训，把一个项目交给无经验的新导演，结果不幸“流产”。此后皮克斯直接明文规定，资深导演每周都要和新人进行交流，并设置了一套新人培训课程，确保新老员工不断层。</p><p><em>9.</em> <strong>改善办公环境，打破层级来交流。</strong>打破层级不是光喊口号，而是从细节开始的改变。最初，皮克斯的大会议室摆放了一张能坐30人的长桌，开会时每个人都有座位牌，但后来发现，这让坐在中间的人的意见更重要，反而强化了层级，交流效果不好。因此，皮克斯就取消了长桌和座位牌，换成10个人左右的小桌，更利于自由沟通。</p><p><em>10.</em> <strong>设立“点评日”集思广益。</strong>很多公司会收集员工对公司的建议，但大多是私下场合的零碎建议。皮克斯从2013年起，制定了专门汇集意见的“点评日”传统——全体员工当天暂停工作，只做一件事：讨论如何把皮克斯建设得更好，比如“如何搭建一个跨项目的共享资料库”“如何消灭特权现象”。经过讨论，公司再选出优秀方案试行。</p><p>让我们对《创新公司：皮克斯的启示》的作者艾德·卡特姆、埃米·华莱士 ，译者靳婷婷 ，出版方中信出版社，说一声感谢！</p><p>最后，与你分享金句，欢迎你收藏并转发：</p><p>好创意不只依赖灵光闪现，</p><p>还需要开放包容的团队管理</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的一些新特性、使用建议和最佳实践</title>
      <link href="/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<hr><p>Redis 5.0已经发布，越来越多的新特性被加入，在工作中发现很多人只是了解一些Redis的基本使用，也并未完整的阅读过Redis的官方文档，对于一些命令不熟悉，不同场景下滥用不合理的数据结构，对一些新的特性似乎也不会去关注，本文总结了一些使用建议。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1、SET key value [expiration EX seconds|PX milliseconds][NX|XX]</p><ul><li>Redis 2.6.12版本后的Set命令支持过期时间等参数，不必再像以前一样分为set和expire两个命令</li></ul><p>2、bitmap</p><ul><li>适用于大量数据的位图信息标记，例如如果要标记大量用户的某个状态值，可以考虑使用bitmap</li><li>bitmap的另外一个应用是基于redis的bloom filter</li></ul><p>3、stream</p><ul><li>Redis4开始提供的新的数据结构，可以理解成轻量级的kafka steam，主要解决了pub&#x2F;sub无法保证通知处理成功和blocked list无法多个client消费的问题，具体点击此处查看topic。</li><li>如果想实现一个简单的聊天室，可以尝试下steam。</li></ul><h1 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h1><p>1、合理分配过期时间</p><ul><li>不管是将Redis作为缓存，还是存储，如果不愿意看到内存被慢慢消耗殆尽，最后只能扩容或者人工介入，就给自己的key设置一个合理的过期时间。 当把Redis作为缓存时，更要预估自己的数据量和数据大小，选择一个合理的过期时间。</li></ul><p>2、多个操作使用pinepine</p><ul><li>这是Redis使用中的一项基本原则，同时需要知道，另外如果下一个命令的input基于上一个命令的output，就不可以放到一个pipeline里面执行了</li><li>使用时考虑pipeline中一个命令执行失败的场景，后面的命令未执行是否因为一致性带来问题</li></ul><p>3、使用命名空间</p><ul><li>方便key的管理，我们开发中常用的redis-desktop客户端能够按照命名空间对key进行展示，另外，命名空间方便需要对某一类key进行统计和管理</li><li>如果需要通过key进行分片，命名空间可以作为分片参数</li></ul><p>4、选用合适的数据结构</p><ul><li>理解每个数据结构的用途，和常用的命令，我曾经见过开发人员因为不知道scard命令可以获得set的size，而将所有的元素取出然后在程序中计算，所以需要平时多查看Redis命令文档；如果能够理解每种数据结构背后的原理，使用时会更加得心应手。</li><li>不建议使用Redis缓存单个数据大小较大的对象，尤其是使用Set，Hash此类数据结构时候，考虑到Redis是单线程，过多的大对象访问增加了网络IO压力，对Redis性能有一定影响，另一方面Redis的虚拟内存page较小，如果内存碎片率较高，则分配&#x2F;申请内存时在性能上有些影响。如果要缓存较大的对象，可以考虑memcache</li></ul><p>5、禁用keys</p><ul><li>很基本的Redis使用常识，可以通过rename-command来将一些类似的命令重命名，实现disable的效果</li></ul><p>6、选用lua script</p><ul><li>如果要保证多个操作的原子性，可以选择使用lua脚本</li></ul><p>7、config set parameter value</p><ul><li>redis 2.0后提供了config set 命令来动态修改一些运行参数而不必重启redis，目前已经支持动态修改maxmemory，可以通过CONFIG GET * 查看支持动态修改的参数列表</li></ul><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>1、key的命名</p><ul><li>合理的命名自己的key，不能在查看数据时可读性更强，也更便于统计和管理</li></ul><p>2、key name的长度</p><ul><li>预估key的存活数量，如果key的数量可能达到百万级别，就需要考虑key的名字过长而导致占用太多的存储空间，我在曾经参与过的一个消息系统中使用redis存储消息阅读量，但是后面由于消息量过多，导致name的占用空间达到几百M，如果精简name，可以节省大量的空间，减少不必要的困扰。 例如，保存用户的基本信息可以使用u:${id}</li></ul><p>3、不滥用Lua Script</p><ul><li>由于Redis是单线程，在QPS很高的情况下，过多的lua脚本执行，特别是内部包含较多业务逻辑处理的情况下，会对Redis性能产生很大的影响。曾经参与过的直播业务的生产环境中，我们在Lua脚本中对送礼物触发的的积分和活动信息的有较多的逻辑处理（20行左右），导致Redis负载100%，所以在排查时Lua脚本有可能是负载较高的元凶之一。</li></ul><p>4、关注内存和slowlog等统计数据</p><ul><li><p>通过info memory查看内存的分配和使用大小，碎片等情况</p></li><li><p>slowlog get N 查看最近几条执行较慢的命令</p></li><li><p>通过redis-cli –bigkeys 通过采样scan元素较多的key，不会一直阻塞redis执行</p></li><li><p>更多好玩的redis-cli命令可以查看此处</p><blockquote><p>monitor命令不建议生产环境使用</p></blockquote></li></ul><p>面对一款优秀开源产品，我们除了要了解它的基本使用，也要擅于运用才能更好发挥其作用，否则会有不必要的麻烦，甚至适得其反。当然如果能深入了解其内部运行机制，知其然并知其所以然，并基于此创造出更加优秀的开源产品，就更符合coder的hacker精神。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java12 新特性</title>
      <link href="/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Java 12  发布了，一起来看一看特性。</p></blockquote><p><strong>1 Switch 表达式</strong></p><p>使用Java 12，switch不仅可以作为语句也可以作为表达式。 无论作为语句或者作为表达式，switch都可以使用传统&#x2F;简化的作用域和控制流行为。 这将有助于简化代码，并为在switch中使用模式匹配铺平道路。</p><p>Java开发人员正在增强Java编程语言，以使用模式匹配来解决当前switch语句的几个问题。 这包括：switch块的默认控制流行为，switch块默认作用域（被视为单个作用域的块）和switch仅作为语句。</p><p>在Java 11中，switch语句追随C和C++，默认情况下使用fall-through语义。 虽然传统的控制流程在编写低级代码时很有用，但随着switch在更高级别的环境中采用，易出错会盖过其灵活性。</p><p>Java 11 </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMvNJrP0lcJZmQSmr7YySUnffXDnaRFKbCQAhHO7ib4r4y2ytMBc4S3If0ibas6vqzZOcBIeMx6dU5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Java 12</p><p><strong>2 默认CDS归档</strong></p><p>通过在64位平台上的默认类列表的帮助下生成CDS归档来改进JDK构建过程，从而有效地消除了运行java -Xshare：dump。 此功能的目标包括：1。）改进开箱即用的启动时间，以及2.）摆脱使用-Xshare：dump。</p><p><strong>3 Shenandoah GC</strong></p><p>Shenandoah是一种垃圾收集（GC）算法，旨在保证低延迟（10 - 500 ms的下限）。 它通过在运行Java工作线程的同时执行GC操作减少GC暂停时间。 使用Shenandoah，暂停时间不依赖于堆的大小。 这意味着无论堆的大小如何，暂停时间都是差不多的。</p><p>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p><p><strong>4 JMH 基准测试</strong></p><p>此功能为JDK源代码添加了一套微基准测试（大约100个），简化了现有微基准测试的运行和新基准测试的创建过程。 它基于Java Microbenchmark Harness（JMH）并支持JMH更新。</p><p>此功能使开发人员可以轻松运行当前的微基准测试并为JDK源代码添加新的微基准测试。 可以基于Java Microbenchmark Harness（JMH）轻松测试JDK性能。 它将支持JMH更新，并在套件中包含一组（约100个）基准测试。</p><p><strong>5 JVM 常量 API</strong> </p><p>JEP 334引入了一个API，用于建模关键类文件和运行时artifacts，例如常量池。 此API将包括ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc等类。此 API 对于操作类和方法的工具很有帮助。</p><p><strong>6 G1的可中断 mixed GC</strong></p><p>此功能通过将Mixed GC集拆分为强制部分和可选部分，使G1垃圾收集器更有效地中止垃圾收集过程。通过允许垃圾收集过程优先处理强制集，g1可以更多满足满足暂停时间目标。</p><p>G1是一个垃圾收集器，设计用于具有大量内存的多处理器机器。由于它提高了性能效率，g1垃圾收集器最终将取代cms垃圾收集器。</p><p>G1垃圾收集器的主要目标之一是满足用户设置的暂停时间。G1采用一个分析引擎来选择在收集期间要处理的工作量。此选择过程的结果是一组称为GC集的区域。一旦GC集建立并且GC已经开始，那么G1就无法停止。</p><p>如果G1发现GC集选择选择了错误的区域，它会将GC区域的拆分为两部分（强制部分和可选部分）来切换到处理Mix GC的增量模式。如果未达到暂停时间目标，则停止对可选部分的垃圾收集。</p><p><strong>7 G1归还不使用的内存</strong></p><p>此功能的主要目标是改进G1垃圾收集器，以便在不活动时将Java堆内存归还给操作系统。 为实现此目标，G1将在低应用程序活动期间定期生成或持续循环检查完整的Java堆使用情况。</p><p>这将立即归还未使用的部分Java堆内存给操作系统。 用户可以选择执行FULL GC以最大化返回的内存量。</p><p><strong>8 移除多余ARM64实现</strong></p><p>Java 12将只有一个ARM 64位实现（aarch64）。 目标是删除所有与arm64实现相关的代码，同时保留32位ARM端口和64位aarch64实现。</p><p>这将把重点转移到单个64位ARM实现，并消除维护两个实现所需的重复工作。 当前的JDK 11实现中有两个64位ARM实现。</p><p><strong>原文地址：</strong></p><p><a href="https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/">https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章读懂“中台”架构</title>
      <link href="/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/"/>
      <url>/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一篇文章读懂“中台”架构"><a href="#一篇文章读懂“中台”架构" class="headerlink" title="一篇文章读懂“中台”架构"></a>一篇文章读懂“中台”架构</h1><p>转载来自微信公众号：  archstudy 架构思轩</p><p><strong>中台是什么</strong></p><p>企业互联网中台架构，简称<strong>中台</strong>，起源于阿里巴巴，不同的人对中台有不同解读。</p><p>我认为，中台可定义为：中台是一套结合互联网技术和行业特性，将企业核心能力以共享服务中心进行沉淀，形成“大中台、小前台“的组织和业务机制，供企业快速低成本的进行业务创新的企业架构。</p><p>中台的目的是 **“提供企业快速低成本创新的能力”，核心是 <strong>“构建企业共享服务中心”</strong>，过程是构建 <strong>“大中台、小前台“</strong> 组织和业务机制。</p><p>其中，前台作为一线业务，更敏捷更快速适应市场，中台将整个企业的数字运营能力、产品技术能力，对各业务前台形成强力支撑。</p><p><strong>阿里巴巴的中台架构</strong></p><p><img src="http://p9.itc.cn/images03/20200526/93023c40ab584738931eae938d9cdca5.jpeg" alt="图片"></p><p><em>阿里中台架构</em> </p><p><em>from 钟华编著《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》图</em></p><p>上图可以看出，阿里巴巴有超过数十个业务单元（如淘宝、天猫、聚划算、菜鸟）均不是独立构建在阿里云之上，在后端阿里云技术平台和前端业务之间有“共享业务事业部“，将业务中公共、通用的业务沉淀下来，包括用户中心、商品中心、交易中心、评价中心等十几个共享单元，是“厚平台的真正实现“。</p><p>而后端的阿里云提供资源和中间件云服务能力做载体。同时，使用集团近十年的双11、双12的高可靠、可稳定的运维保障能力，对整个系统进行支撑。</p><p>中台的使命是从下到上逐步完善阿里的整个体系，从阿里云、数据、中间件、算法，到上面支撑的各种业务解决方案，构建阿里自己核心的能力。</p><p><strong>中台在阿里巴巴的诞生</strong></p><p>在淘宝初期，主要面向C2C的电商领域，整个系统都是围绕一套“烟囱式”的淘宝技术框架进行。随着业务的不断扩张，集团成立出天猫事业部主抓B2C电商领域，又形成了一套烟囱式发展。</p><p>这种烟囱式的架构体系带来了诸多不足，比如成本的重复投入和维护、数据之间打通复用的难度、几年之后推到重建的风险。</p><p>为了解决这些问题，集团开始构建<strong>共享服务中心体系</strong>，来沉淀和服用业务能力，但是由于没有过多的业务话语权，共享服务体系的建设一开始并不顺利。 </p><p>之后，随着“聚划算”团购项目的启动，各种系统的流量都需要通过聚划算，这时，共享服务中心得以大展手脚，逐步将集团核心的业务能力构建成<strong>用户中心、商品中心、交易中心、评价中心、店铺中心</strong>等等数十个共享服务。</p><p>可以说整个阿里中台的革命也是共享服务中心的革命，各共享服务中心聚焦核心业务单元能力的构建，协助目前集团上百个前台业务的快速创新。</p><p>这里需要强调一下，中台是<strong>去中心化</strong>的，而共享服务中心正是一个个解耦的服务模块，这里的中心有一些特点：</p><ol><li>共享中心以共享<strong>业务+数据</strong>能力为主，比如领域服务层+API接口</li></ol><ul><li>共享中心的目的是沉淀传统行业业务和数据能力，并<strong>开放出去</strong></li><li>共享中心是中台的重要部分，目的是实现前端应用和后台的<strong>彻底解耦</strong></li></ul><p><strong>中台的好处</strong></p><p>没有中台前，企业的<strong>痛点</strong>体现在：</p><p><strong>复杂</strong>：系统庞大、逻辑复杂 （学习理解成本高，每人了解系统全貌，最懂的是程序员，需要翻代码才能知道具体逻辑）</p><p><strong>重复</strong>：系统差异性大、标准不一 （同样的需求在不同系统重复造轮子，对于一个通用功能，没人说清楚是否有，或知道但现有的够不够支持）</p><p><strong>沟通成本高</strong>：团队多，跨部门的沟通多（无用的拉通对齐会太多，沟通需求和信息获取成本极高）</p><p>中台就是为了让企业进行核心能力的<strong>沉淀</strong>，更给予我们快速创新的<strong>机会</strong>，具体包括：</p><p><strong>1、中台赋予业务快速创新和试错能力</strong></p><p>企业可以聚焦核心共享服务的建设，提高服务的重用。</p><p><strong>2、打造数字化运营能力</strong></p><p>中台有助于业务通过共享核心能力的沉淀，进行数字化运营。通过对中心核心数据的分析，更加精确地对业务进行调整和优化，全方位动态调整资源利用。</p><p><strong>3、改变组织阵型带来组织效能提升</strong></p><p>中台的变化也是组织阵型的变化。一方面，对于公司，中台侧重的是跨部门跨团队的深入合作。另一方面，对于个人，中台推荐的是类微服务的小而精团队，员工从事多种岗位，对全局和整体有更深入的锻炼。</p><p><strong>中台是平台化的自然演进</strong></p><p><img src="https://img1.baidu.com/it/u=1775402040,4133540010&fm=253&fmt=auto&app=138&f=PNG?w=674&h=333" alt="图片"></p><p>这里比较一下中心化、平台化、中台化。</p><p>中心化类似烟囱式架构，一个中心解决整个技术堆栈。</p><p>平台的目标为高内聚、低耦合、职责边界清晰，是单一团队、部门、系统的效率提升。</p><p>中台的目标是提升效能、数据化运营、更好支持业务发展和创新，是<strong>多领域、多BU、多系统的负责协同</strong>。</p><p>中台是平台的自然演进：这种演进带来“去中心化“的组织模式，突出对<strong>能力复用、协调控制的能力</strong>，以及业务创新的差异化构建能力。</p><p><strong>企业中台化转型</strong></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2F80%2Fv2-60d6ae21eb72c390ea7fa74a3b8f955b_1440w.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669873642&t=90c9dc8d95deb7e65fd891c37b80d3d0" alt="图片"></p><p>传统企业应用中台战略进行互联网化转型，主要需要关注以下6点。</p><p><strong>1、尽可能拆分，共享中心建设</strong></p><p>企业应该尽可能地拆分自己的应用，进行共享服务中心的建设，将核心的业务能力复用和沉淀。</p><p>共享中心的拆分要注意层次。</p><p>首先，可以从<strong>基础主数据和核心共享数据</strong>出发去定义中心，例如客户中心，订单中心，所有功能目的都是围绕客户或订单数据本身。</p><p>第二，可以围绕<strong>核心业务展开进行中心的定义</strong>，比如交易中心，人事共享服务中心，这种中心的强调核心业务能力，而不是针对某特定数据。</p><p>另外，可以以<strong>核心业务规则和逻辑构建的中心</strong>，比如包调度中心，规则中心等，这些都是实现核心业务逻辑处理为主的中心。</p><p><strong>2、去中心化，线性扩展</strong></p><p>企业需要采用去中心化架构，<strong>没有核心流量汇入点，服务中心尽量无状态</strong>，便于水平扩展。这样平均分担压力，负载均衡，对单个中心带来的负载更小，故障影响的范围也更小。</p><p>同时，也要求我们的数据服务也要进行<strong>分布式改造</strong>，使用<strong>分库分表，读写分离</strong>的思想，便于根据实际情况扩索容。</p><p><strong>3、数据化运营</strong></p><p>当然，去中心化也会面对系统运维和管理成本上升的问题。企业需要对自身的运维运营过程进行积累和沉淀，整理出数据化、<strong>自动化运维</strong>的经验，同时增强<strong>监控告警、限流降级、性能分析诊断</strong>等方面的能力，精准定位目前系统中存在的问题，并提出相应的改善方案。</p><p>另外，数据是企业最宝贵的财富，企业可以通过各中心的数据，今而挖掘新的业务机会，快速创新。</p><p><strong>4、异步化，最终一致</strong></p><p>在大量的实践中，大部分业务流程不需要强一致性，而使用最终一致来平衡。</p><p>我们需要使用<strong>异步解耦</strong>，如使用<strong>消息队列</strong>来完成业务逻辑，缩短相应周期。</p><p>以双11为例，一个交易需要200多个系统，假设每个系统需要10毫秒，再加上一些网络和前端延迟，总时长将超过3秒。而在互联网领域，3秒的RT会造成大量的用户流失。使用异步化，缩短服务主链路可以大大缓解这一问题。</p><p><strong>5、尽可能自动化</strong></p><p>企业进行中台改造，会面临很多机器来负载业务，要求企业尽可能提高自动化能力，比如<strong>自动部署、自动弹性扩容、自动升降级、自动限流降级</strong>，降低运营成本，也提高系统的稳定性和业务连续性。比如消息队列中以自动化的形式实现系统的秒级切换和快速恢复，对应用几乎没有影响。</p><p><strong>6、尽可能使用成熟组件</strong></p><p>中台的建设要求企业将重心放在服务中心上，对于底层组件，尤其是中间件层面，尽量使用成熟的组件来提高系统稳定性和性能。</p><p>目前，阿里巴巴中间件已经将多年经双十一购物狂欢节的严苛考验的技术沉淀，以阿里云标准云服务的方式输出给外部客户，其中包括多款阿里云中间件产品（比如EDAS&#x2F;MQ&#x2F;DRDS&#x2F;ARMS&#x2F;PTS），并提供全方位的互联网化转型的架构咨询、技术支持、交付培训等服务。并不仅仅是技术红利的分享，更重要的是整个阿里中台战略思想的传播。</p><p><strong>Takeaways</strong></p><ul><li><p>中台可以帮助传统企业将企业核心能力<strong>以共享服务形式沉淀，供企业快速低成本的进行业务创新</strong>的企业架构。</p></li><li><p><strong>中台是平台化的自然演进</strong>，是一种体系&#x2F;生态&#x2F;方法论。</p></li><li><p>中台的目的是“<strong>提供企业快速低成本创新的能力</strong>”。中台的核心是“<strong>构建企业共享服务中心</strong>”。</p></li><li><p>企业中台化转型中，需要关注<strong>拆分&#x2F;去中心化&#x2F;数字化&#x2F;异步化&#x2F;自动化&#x2F;成熟组件</strong>等方面。</p></li></ul><p><strong>Reference</strong></p><p>《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》— 钟华</p><p><a href="http://www.open-open.com/news/view/1f1f312">http://www.open-open.com/news/view/1f1f312</a></p><p><a href="http://www.sohu.com/a/166699898_413980">http://www.sohu.com/a/166699898_413980</a></p><p>作者简介</p><p><strong>王思轩</strong>，计算机专业博士，阿里巴巴中间件技术架构师。</p><p>获得加拿大卡尔顿大学计算机博士学位，并获得法国波尔多大学和哈尔滨工业大学双硕士，哈尔滨工业大学本科，发表过10余篇国际学术论文。多年从事于云计算和系统架构设计工作，曾就职于华为，Qlik，Honeywell。现就职于阿里，花名宇升，负责并参与Aliware云产品重点项目的设计和交付，以及企业互联网架构的咨询培训工作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哪怕1%的提升，效益都非常大 | 当传统拥抱互联网</title>
      <link href="/2019/03/17/%E6%9D%82%E8%AE%B0/%E5%BD%93%E4%BC%A0%E7%BB%9F%E6%8B%A5%E6%8A%B1%E4%BA%92%E8%81%94%E7%BD%91/"/>
      <url>/2019/03/17/%E6%9D%82%E8%AE%B0/%E5%BD%93%E4%BC%A0%E7%BB%9F%E6%8B%A5%E6%8A%B1%E4%BA%92%E8%81%94%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>文章来自笔记侠，一直关注笔记侠的文章，分享</p><p><a href="https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrpg">https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrpg</a></p><p>故事硬核《独家深访：腾讯变革150天全记录》中有这样一个细节。2016年腾讯云峰会，马化腾出现在会场，给云站台。</p><p>他的鲜明风格之一就是不给腾讯任何产品站台——一个例行邀请，“竟然来了”，汤道生回忆，云团队像过节一样开心，“关键他不仅仅是给云的团队看，他出来是给整个行业看”。</p><p>最终，腾讯在2018年“香港总办会议”的共识中达成了最重要的几项：</p><p>一、进行组织架构调整，成立云与智慧产业事业群（CSIG），主攻产业互联网；</p><p>二、从TO C 到 TO B，继续巩固消费互联网，重兵投入产业互联网。</p><p>国家在发生深刻转型，全面的数字化、智能化时代已经来临，每个产业都在拥抱云、大数据与人工智能，“跟以前拥抱电一样”。</p><p>早在2013年底，马化腾就提出互联网+的概念。他当时去国家发改委演讲，向主任、各司局局长、处长将近600人，讲用互联网去“+”传统的各行各业。两场重要演讲之后，这个概念流行开来。</p><p>2015年两会前，马化腾受邀向政府智库提交了“互联网+”的意见。这个概念被写入了政府工作报告。</p><p>那正是“互联网+”如日中天的时候，“互联网+打车”颠覆出行，“互联网外卖”改写餐饮，“互联网支付”影响金融……一时间互联网人都在说赋能、颠覆，仿佛新的大革命已然来临，正大刀阔斧重组重造。</p><p>但互联网当主角，传统行业不服气，说“我+你还差不多” 。他们的忧虑在于，一旦开门欢迎互联网，下场会不会是把自个儿颠覆了。</p><p>行至深水区，“+”的对象变成了那些有着高壁垒的行业——教育、医疗、能源、制造业……腾讯2B前方团队突然发现“+”不了了，许多产业的核心技术，互联网公司不懂，人家也不可能把自己的命脉交到别人手上。</p><p>僵局之中，马化腾捕捉到一个奇特的变化信号。</p><p>2016年两会期间，他去拜访链家CEO左晖，了解到了全新的故事样本：一个线下传统中介机构不仅没有被互联网企业入侵、颠覆，还倒攻线上，成功逆袭，“最终成了老大”。</p><p><strong>一、拥抱互联网，如火如荼</strong></p><p>王兴在2016年就新美大公司上半年工作进行了一次内部讲话，他说：“往后看，‘互联网＋’要做的是各个行业从上游到下游的产业互联网化。</p><p>不是仅仅停留在最末端做营销、做交易那一小段，而是真正能够用互联网、用IT全面提升整个行业的效率…</p><p>‘互联网＋’根本上还是要靠创新服务于各行各业，靠互联网、靠IT技术为各行各业的各个环节提升体验、提高效率、降低成本。”</p><p>正如王兴所言：“从最宏大的角度来讲，整个中国经济也进入了‘下半场’。党和政府讲‘新常态’差不多要两年了，从去年年底到现在，也在反复讲‘供给侧结构性改革’。</p><p>如果你去细看这些提法背后的论述，你就能看到这些论述并不是中央领导的‘拍脑袋’和‘心血来潮’，而是中国经济发展到了这个阶段，确实是需要转变增长模式。</p><p>过去那种粗放的高速增长已经一去不复返了，不能再简单追求GDP的数字，中国经济也是进入了‘下半场’的状态。”</p><p>▲ 长按图片保存可分享至朋友圈</p><p>投资了新美大、优步、Airbnb等的宽带资本，也在2016年就已经提出有一个更广阔的市场叫“互联网+”（“互联网+”正是马化腾过去重点在公开场合提及的），也就是“产业互联网”。各种各样的企业，都得拥抱互联网，不拥抱互联网，就会面临着各种问题。</p><p>最先和互联网碰撞的一批是零售行业。</p><p>1.食</p><p>2017年末，2018年初，随着电商红利见底，阿里、京东等线上巨头开始大举进军线下市场，纷纷开设实体店。</p><p>如此一来，零售企业的生存环境便遭到进一步挤压。为求生存发展，零售企业开启转型之路，纷纷推出智慧门店，如沃尔玛的惠选超市、家乐福的Le Marche、优衣库的数字体验馆、苏宁的苏宁极物……</p><p>不同于传统零售门店，这些智慧门店引入了各种“黑科技”，如用自助收银机、“扫码购”等减少排队结账的时间，利用VR技术提供虚拟试装、试衣等。</p><p>永辉超市收到了腾讯集结全公司能力定制的智慧解决方案包——以选址为例，不再凭经验，而是在腾讯云预测销量前提下科学布局。市场占有率前十的超市品牌5家变成了腾讯的盟友。</p><p>永辉超市的互联网升级做得相对较快，其中一个原因是在传统行业基础上，创始人张轩宁非常重视人，重视年轻的高精尖团队，并从互联网挖过去人，发展非常快。</p><p>《第三次零售革命》作者、盛景网联合伙人颜艳春研究了7-11的损益表，发现7-11日本公司8000名员工创造了接近100亿人民币的净利润，人均创造利润为120万元，人效比肩世界上最赚钱的电商平台公司阿里巴巴。</p><p>这背后，是一个快消品行业的产业共同体和命运共同体，90%的参与方，无论上游、中游还是下游都获得了3-5倍的成长。</p><p>之前，在很多人的眼里，7-11是一个传统的连锁便利店，实际上，对7-11的这个认知是错误的。</p><p>它的模型：7-11总部着手把在日本每一个商圈里头部、碎片化的需求连接起来，团结进来。</p><p>就像三峡大坝一样，把需求端2万家夫妻老婆店团结起来，通过产业路由器，把供给端的178个工厂，还有140个物流中心连接起来，但这都不是它自己的资产，全部是这些头牌供给。</p><p>它根本就不是一家传统商业模式的零售公司，7-11将自己打造成为产业路由器平台，将这些小店与这些物流中心和所有工厂实时连接起来。</p><p>将自己唯一一个中介去中介化，4个不赚（不赚差价，不赚通道费，不赚佣金，不赚广告费）。</p><p>通过共享采购、共享配送、共享制造、共享研发、共享库存，共享供应链，为小店、小工厂提供了三大赋能（从商品赋能、经营赋能到基础设施赋能），成就了他们，每家的投资都得到了很大的回报。</p><p>7-11创造了一种新的利他经济模型，把实体经济和电商经济所有的商业逻辑彻底摧毁。</p><p>其实不只是智慧零售，各行各业的盟友越来越多。</p><p>2.衣</p><p>2018年3月30日，优衣库全新独栋概念店将在深圳万象天地正式开业。</p><p>优衣库在这家门店首次推出融合线上线下、打通实体与虚拟的“数字体验馆”，在店内的货架侧面和四方立柱的单面墙上安装了两款智能科技。</p><p>四方立柱上安装的是一款智能语音集成设备“智能小U”：顾客站在智能小U面前，设备自动完成对顾客的五官识别。</p><p>顾客可触摸屏幕商品清单，点击自己喜欢的服饰，然后进入4D虚拟试穿画面。</p><p>货架侧面的电子大屏则主要突出广告功能，只要顾客打开手机QQ的扫一扫功能，对着大屏上的静态海报扫描一遍，手机屏幕立即出现海报对应的TVC广告。</p><p>据悉，3月30日起，数字体验馆将在优衣库全国近600家门店陆续上市。</p><p>3.住</p><p>我们从衣食走到住房。</p><p>有人把近两年疯狂扩张的链家称为现象级公司，这家原本盘踞在北京的房地产中介公司在2015年进行了如火如荼的并购，把业务扩展到了全国。</p><p>链家长期以来就是一家跨界企业，从最初的房地产网站起家，到后来转向线下，再到现在的互联网化，链家既不在互联网圈，也不完全是传统意义上的地产中介公司。</p><p>之前，链家的高管们被分为势均力敌的两队，一队负责用互联网思维来干掉链家(简称“互联网派”)，一队作为传统中介琢磨如何应对(简称“传统派”)。这是左晖一直拷问管理层的一个问题。　</p><p>“当时思路没有现在这么清晰。”链家地产副总裁林倩回忆道。</p><p>管理层们脑洞大开，在讨论互联网到底能在多大程度上取代传统中介时，“互联网派”几乎取得了压倒性的胜利。</p><p>事实上，这直接影响了链家地产之后在线上的布局。从彼时起，每年投在链家在线上的资金都在亿元左右。</p><p>多年布局下来，链家在线促成的二手房买卖成交占到其整体成交量的30%左右，这一数字已经高出链家在其它互联网公司购买端口来促成成交的比例。</p><p>而在链家董事长左晖心目中，链家一直是一个由数据驱动的房地产平台。</p><p>他称自己2013年发微博吹牛说链家已经有100TB的数据。但两年时间后，数据库的规模已经增至1000TB，并且还在不断增长。</p><p>在二手房领域，不仅仅是信息分散，且没有被电子化，定义不够标准和统一。</p><p>贝壳找房和链家网CEO彭永东举例说，北京有700多万套二手房，有10万种户型。</p><p>每套房子的户型图，长、宽、高的尺寸，一个小区到底有多少这样的户型，同样户型能卖多少钱，不同用户定价是多少，都要被整理到数据库中去，以供决策参考。</p><p><strong>二、干不倒的实体店</strong></p><p>开篇，我们就讲到了零售行业。零售行业拥抱互联网的速度更快、也更容易。</p><p>2015年初，盒马鲜生的创始人侯毅，用一个下午的时间改变了阿里对线下店的认知。</p><p>过去，阿里认为电商遇上实体店，就像端机关枪的遇上了冷兵器，简直所向无敌。</p><p>但是，市场是在不断变化的，那时阿里高管第一次意识到，实体店是不可取代的。正因如此，阿里悄悄的布下了一个局，开始正式涉足线下经济。</p><p>两年前，知道盒马鲜生隶属阿里公司的人寥寥无几。</p><p>当这个信息被众人周知的时候，很多人感慨，零售市场到处都是京东和阿里的身影，作为一个零售行业的人，除非加入京东或者阿里，否则没有出路了。</p><p>颜艳春认为，未来相当长的一段时间里，70%的生意仍然是在线下场景完成的。</p><p>▲ 长按图片保存可分享至朋友圈</p><p>米兰有一家超市叫Eataly，在超市里可以坐下来休息、听音乐，甚至点两份牛排，十分受欢迎。</p><p>占地6500平米，一年可以营收4000万欧元。他们在美国纽约的分店，据说一年可以营收5000万美金。</p><p>这家店为什么可以取得成功呢？</p><p>因为互联网没有办法颠覆人性，线下的体验、人类情感的连接和宣泄是美妙的，不可取代的场景。</p><p>所以颜艳春大胆预言：<strong>得实体店者得天下，得头牌实体店，得天下第一</strong>。</p><p>再拿孩子王（”孩子王”是五星控股集团旗下零售事业，总部位于江苏南京。专业从事孕婴童商品一站式购物及提供全方位增值服务）为例。</p><p>孩子王在妈妈圈里拥有200家店、2000万用户，平均每家店拥有10万用户，每一个店每年举办100场线下活动直接连接起来的。将低频的交易场景转变成高频的约会场景，这个模式获得了巨大的成功。</p><p>聚焦到一个领域的实体店做得尤其漂亮。</p><p>包括Costco、Airbnb、7-11在内的公司，都只关注一个领域，亚马逊只卖最畅销的1000本书。</p><p>盒马鲜生只做吃这个品类，并将其发挥到极致，承诺不卖隔夜肉，只卖当天的肉和菜。光上海的10家店铺就拥有200万用户，店铺里面热闹的氛围是很棒的高频场景。</p><p>这些店都有一个共同的特征，它们不是传统的实体店，而是经过互联网加工过的实体店。</p><p>在实体店这个高度碎片化的市场里，即便投资100家公司，也不一定能够控制10%的市场份额。</p><p>这对于创业者来说，是一种机会，不是大家一起集中开喜茶，而是应该去思考如何去团结存量，如何用互联网(数字化)手段，让实体店过得更滋润。</p><p><strong>三、哪怕1%的收益，效益都非常大</strong></p><p>许多大型企业在使用互联网的过程当中迭代速度很快，因为互联网化过程带给它们很多有用的信息数据，让企业经营者能够更深层地理解自己所处的行业，这是互联网带来很重要的变化。</p><p>BAT之后诞生的新型企业，并不依赖简单的商业模式，而是学会驾驭了一种新型工具，对于人工智能更是如此。人工智能出现，会有一批更加新型的企业崛起，BAT很难在商业模式上跟它们直面竞争。</p><p>给大家举几个例子。</p><p>心上，现在是全国最大的二手奢侈品交易平台。最开始的业务全部是线下进行的，进行—、二手奢侈品的洗涤和养护，有4家直营店，40家加盟店。</p><p>在2014年时，创始人董博文决定做线上转型，这个过程势必有很大的困难。她一开始不清楚互联网商业逻辑，于是开始招兵买马一点一点构建互联网团队。</p><p>使用互联网工具之后，她发现很多客户是可以量化的，原来的用户定位和商品定位不够准确。</p><p>转型初期，她认为线上互联网奢侈品的交易平台应该是高端奢侈品，客单价是5000块钱左右，后来通过调整数据定位客户类型后发现，价格越低成交量越大，1750元是最优点。</p><p>二手奢侈品交易平台面对的是小康人群或者是中产人群，在消费过程中的认知应该是：我需要刚需品，而我不需要为了这东西付很多钱。所以她在数据调整过程当中理解到之前的用户定位是错误的。</p><p>同样的，她在供应链里也发现了一些问题。比如公司买的洗涤养护液和面辅料，这些东西可能是通过A公司去买，物流过程很复杂，账期很长，价格很高。</p><p>搭起整个互联网控制结构以后，她发现进货环节、产品特性、用户类型存在问题，然后开始不断地进行迭代。</p><p>这个过程中能非常明显地感觉到她在驾驭工具，最开始使用互联网工具后，她认为只是搭建了一个网站而已，后来这个工具给她带来了大量的数据和参考依据，她也越来越了解自己的商业模式。</p><p>任何一个公司都是倾向于产业升级和企业升级，把企业原来的那套理论体系逐渐的总结成新的规律去推动，把公司做得越来越规范的过程。</p><p>这是一个从经验走向规范化、走向数据化、走向结构化的过程，互联网只是其中一个推动的工具，只是使某一些企业在从信息化走向数据结构化的过程中，让它的数据变得更加标准，所以才能更深刻地理解自己的商业模式过程。</p><p>比如像农业和工业企业也能受到互联网影响，是因为原来他们的管理都是依靠于人进行管理的，依靠于自己的经验进行管理的。</p><p>而突然有了互联网之后，多出了一种数据化、量化的工具，使得整个行业更加标准化。</p><p>比如农业公司甲加由，一个在河南的农业公司，它很快从工业化衍生出了金融属性化，原因是它非常注重量化管理，他们对所有农户的工作状态用信用评级、用数据化衡量，做到了很多村镇银行很难办到的一步。</p><p>通过量化管理，它能给农户进行评级，对接银行、金融产品，给农户发放贷款做保险、卖期货。</p><p><strong>传统行业拥抱互联网，哪怕有1%的提升，都会产生非常高的效益。不管是农业、电力、航空、铁路还是石油。</strong></p><p>中国宽带产业基金合伙人周耘认为，产业互联网产生的经济效益，会有几个方面：</p><p>① 工业升级：</p><p>生产设备和物联网相结合，不管是物联网，还是供应链、工单、流程再造，都跟提升效益相关；</p><p>② 服务升级：</p><p>比如想知道外出人员，去哪了？做什么？你无从了解，现在可以通过移动互联网，通过位置服务，通过跟客户交互，都能知道了，也能提高效率。</p><p>在当前的国家经济形势下，正好赶上下一个浪潮：产业互联网，2B企业越来越多，<strong>传统行业和互联网的相互结合，会孕育着更多的投资和机会。</strong></p><p><strong>四、用对姿势，很关键</strong></p><p>企业的成长其实跟人的进化是很像的，都是不断使用新工具的过程。</p><p>但在工具的使用过程中，一些公司并没有利用得恰如其分。</p><p>2016年，投资了特斯拉、推特、百度的德丰杰，其中国的德丰杰龙脉基金合伙人王岳华指出，消费互联网时代已是过去，产业互联网时代才是未来。</p><p>当时他就已经看到消费者互联网的渗透增长变慢，变为稳定。国内传统制造业很多产业比如陶瓷业、家装业，很多传统产业没有很好地应用互联网化。</p><p>我们来看这样一个故事，古代打仗都用冷兵器，近代打仗用热兵器，这两种兵器的更迭是在什么时候？</p><p>在19世纪美国南北战争中。在那个时候刚配备枪炮的军队根本不知道怎么用，于是两边军队各站成一排，两边的军官在短暂沟通后下令开打，两边就开始相互扫射，这是一个令人啼笑皆非的故事。</p><p>为什么会出现这种问题？</p><p>因为对于军官和士兵来讲，他们使用了新的工具，但是没有更新战术和方法。方法论、战术是非常重要的，当时的枪怎么用，大家都不知道，还是处于拿着枪互相肉搏的状态，这是典型的用工具和战术的更迭过程。</p><p>我们每天都需要接触大量的互联网公司，大多数公司都声称自己的产品是互联网化的，但其实它们并不是标准的互联网公司。</p><p><strong>他们虽然有了新的互联网工具，但却不知道如何使用。</strong></p><p>还有一种情况是，有些科技公司想赋能传统行业，却找不到正确的路径，拿金融客户举例。</p><p>当前，随着经济增速放缓，息差收窄，监管趋严，互联网金融科技企业全面跨界渗透，中小银行的生存环境日益严峻，转型求变已成必然之势。</p><p>行业实践证明，金融科技的运用可以帮助银行提升核心业务能力、业务效率、用户体验，降低风险与成本，是中小银行实现转型的必备能力。</p><p>除了一些大型银行和全国性股份制银行，一些小型的农商行们普遍存在资产规模小、业务区域受限、风险控制能力弱等短板。</p><p>因此，为这类客户服务的供应商也特别多，其中既有各种国际巨头IOE、MBB、四大……，它们把这里视为自己的利润主战场；也有N多本土化的服务商，想进来分一杯羹。</p><p>总之，蛇有蛇路，鼠有鼠道，八仙过海，各显神通。但其中，真正能做到，理解金融类客户业务本质的并不多。</p><p>传统产业的升级，有时需要自己内向成长，有时需要借助外力，当外力的操作姿势不对时，也需要传统产业和外力打成一片，两者真正融合到一起。</p><p>当然，也有一些行业可能真的不适合互联网，这也需要我们警惕。</p><p>很多人认为很多To B的行业可以做线上化，于是出现了找木网、找纱线、纺织、建材这些细分类目的网站，这其实并不算严格意义上的互联网企业。</p><p>比如一家建材公司想把所有的建材、石料板材都放到线上，创始人的网站构想也非常清楚，团队干劲也比较足，每年有几个亿的成交量，开始觉得做得不错。</p><p>最后到公司一看，发现公司的工作状态是什么？虽然有网站，但没有人运营维护，所有人都在打销售电话，这是完全依赖于人和客户进行沟通的一种商业模式，它不能算是一个互联网化的公司。</p><p>互联网化公司最开始的时候要能看到商品是标准的，而不依赖于人和客户沟通，这是很重要的一点。</p><p>再比一个纱线公司，前端的研发和后端的布局是很完善的，以为对于纱这一品类是可以互联网化的。因为这个行业可能是50个SKU（库存进出计量单位），然后把它们全部标准化放到线上，大家在线上进行交易。</p><p>结果到公司去看的时候，很让人震惊的是，纱线有12000到15000种SKU，每一年下雨的雨水不一样，纱线韧性弹性不一样，边纹不一样，口径粗细不一样，颜色不一样，每一种纱线SKU有50多种标签，出来之后有几万种SKU，买方就没有办法在网上选择。</p><p>所有的人买纱线都是要亲自根据手感来挑选——“这种纱线对我有效，以后不要麻烦看别的了，以后我只进货这一种”。它是高度依赖于线下体验的产品，这种产品非常难以互联网化。</p><p>在供应链中从生产过程、到仓储流转、到分销，有很多的企业，比如第二产业中建材类等行业，都是如此。</p><p>并不是所有的行业都可以互联网化，并不是所有的企业用同一种方式进行转型都是可以升级的，完全不是的。</p><p>很多行业没有办法进行互联网转型升级，只能拿它作为辅助性工具管理公司。</p><p>产业互联网的大潮下，行人急匆匆，审时度势很重要，不忘初心更要紧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术团队的4个难题</title>
      <link href="/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/"/>
      <url>/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>以下文章来源于阿里巴巴中间件</p><p>从单个应用到多个应用，从百千级别的访问流量到十万、百万级别，从两三个人的创业技术团队到上千人的技术团队矩阵，这些过程中，技术团队都避不开了以下 4 个问题：</p><ul><li><p>如何预测业务峰值时的容量</p></li><li><p>如何提升业务的稳定性</p></li><li><p>如何提高业务的监控能力</p></li><li><p>如何提高开发效率</p></li></ul><p><strong>如何预测业务峰值时的容量</strong></p><hr><p>早期的做法是在开发测试环境进行压测，来评估线上容量，但线下环境的机器规模，和线上差距很大，很难通过线下推导线上。根据经验，将采购的机器加入不同的应用里面，这时候就会遇到一个问题： <strong>最大业务峰值容量是多少？</strong></p><p>这个问题，其实挺难回答的。这个应用多加几台，那个应用少加几台，整体的业务峰值承受能力就会不一样，加减的规则很难通过人的经验来确定，最多只能作为一些辅助判断。另外，核心交易链路的梳理，也是一个体力活，如果依赖人为处理，有可能会漏掉一些看起来不那么重要的”分支”，这是整个容量不确定的地方，可变的因子很多。</p><p>比较有效的方式， <strong>是在生产系统部署全链路压测</strong>，来验证各个生产环节是否能经受住各类流量的访问，让真实的流量来访问生产环境，实现全方位的真实业务场景模拟，确保各个环节的性能、容量和稳定性均可做到万无一失。</p><p><strong>如何提升业务的稳定性</strong></p><hr><p>日常的各种运营活动，都有可能带来巨大的流量高峰，除了通过引入全链路压测来验证各个生产环节是否能经受住各类流量的访问， <strong>构建系统的高可用保障能力也很关键</strong>，涉及多个组件或模块，例如<strong>软负载和配置中心、服务接入和调度编排、消息接收和发送、容器和调度、限流和降级</strong> 等。</p><p>运营一次活动，最大的流量峰值是可以预测的，这就是服务的最大接待能力，比如50万笔的交易创建峰值，那超过的怎么办？这时候，采用限流的方式，被限流的客户在某一段时间内无法进行购物，一旦系统恢复服务能力，就可以继续服务被限流的客户，从而避免因流量超过上限，而影响整个平台的客户。</p><p><strong>如何提高业务的监控能力</strong></p><hr><p>分布式应用系统在协作性，扩展性和一定的容错性方面，体现出了优势，但是<strong>在监控、运维和诊断层面，面临相当大的挑战。</strong></p><p>早期，架构师可以画出整个应用系统的交互架构图，随着业务的发展，当拥有大量的应用、微服务和容器，即便整理了一幅交互架构关系图，也会因为应用系统的变更，新需求的实现，整个应用系统的交互又会发生变化，这种变化无处不在，每天都在发生。因此，随着业务量的增加，需要覆盖面广且深的<strong>全链路跟踪监控系统</strong> ，来诊断调用链的问题。</p><p>越是复杂的业务形态，定位的难度越大，就越需要全方位、360度无死角的监控，因此，建立一个平台化、跨领域和立体化的监控，能极大的缩短业务遇到问题时的恢复时间。</p><p><strong>如何提高开发效率</strong></p><hr><p>开发效率是一个很广泛的话题。不同的开发岗位，不同的使用场景，会有不一样的开发效率工具。这里，我们介绍几款后端工程师经常会用到的效率工具。</p><p>云端部署效率工具：</p><p>Cloud Toolkit 是一款 IDE插件，可以帮助开发者更高效地开发、测试、诊断并部署应用。借助这个工具，开发者能够方便地将本地应用一键部署到任意机器，或 ECS、EDAS、Kubernetes，并支持高效执行终端命令和 SQL 等。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485392&idx=3&sn=113a67be48740443b9a29d172da48b12&chksm=fdeb35b0ca9cbca6f48b61c8c333683b6acbaac4f1e8101ff54546d9256347bff629e0e513c5&scene=21#wechat_redirect">点此了解详情。</a></p><p>MacOS 搜索利器：</p><p>MacOS 自带的聚焦搜索（Spotlight），可以将文稿、邮件、应用等整合在一起，通过关键词匹配来进行搜索。Alfred 可以看作是Spotlight的增强版，是计算机依赖者的效率神器，支持添加自定义网络搜索引擎，指定规则精准定位本地文件，以及在命令框内使用计算器、词典等实用工具。</p><p>画图效率工具：</p><p>系统架构图是为了抽象的表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。通过架构图，可以让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体，所谓一图胜千言。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485842&idx=2&sn=39bf21a40e810d8993aaeb6054f4cada&chksm=fdeb3bf2ca9cb2e4e40442c80fc833372686f373c3c0e23f5b3cf438d00ebd6586bd4772f36c&scene=21#wechat_redirect">点此了解详情。</a></p><p>JSON 浏览效率插件</p><p>对于 JSON 的数据，如果不编排，格式查看起来会很费劲。JSON-handle 是一款对 JSON 格式的内容进行浏览和编辑，以树形图样式展现 JSON 文档的插件，支持实时编辑。</p><p>Java 代码规约扫描效率插件</p><p>这是一款 Java 代码规约扫描工具，旨在以工具的手段进行代码规约的落地，项目包含三部分：PMD规则实现、IntelliJ IDEA 插件、Eclipse 插件，帮助开发人员在工程研发的多个阶段进行代码规约检查， 降低故障率、提升编码效率和质量。<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDU0MTE0OA==&mid=2661009238&idx=1&sn=3813042bae641ce8cac04ff57bf30ee2&chksm=80feaf65b789267361c560cb2b134e325343a927925b985642cba95210fe9222aaf2f006c90b&token=2107695414&lang=zh_CN&scene=21#wechat_redirect">点此了解详情。</a></p><p>当然，除了这些现成的效率工具，提升整个技术团队的开发效率，需要单独开发或改造一些系统，例如团队协作平台、服务化改造等，当你以实习生的身份加入公司后，若有机会参与到这些提升开发效率的项目过程中。由此形成的效率意识，将会影响到你今后的工作习惯和理念。</p><blockquote><p>本文部分内容来源于阿里巴巴中间件资深产品专家丹臣的内部分享《阿里巴巴中间件上云实践》。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面了解HTTP和HTTPS</title>
      <link href="/2019/03/02/%E7%BD%91%E7%BB%9C/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3HTTP%E5%92%8CHTTPS/"/>
      <url>/2019/03/02/%E7%BD%91%E7%BB%9C/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3HTTP%E5%92%8CHTTPS/</url>
      
        <content type="html"><![CDATA[<p>作者：左大人，链接：jianshu.com&#x2F;p&#x2F;27862635c077</p><p> <strong>前言</strong> </p><p>Http和Https属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。<br>在学习Http和Https的过程中，主要是参考了阮一峰老师的博客，讲的很全面，并且通俗易懂，有兴趣的同学可以去学习学习。</p><p><em><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">http://www.ruanyifeng.com/blog/2016/08/http.html</a></em></p><p>这篇文章主要是按照自己的思路来讲解对Http和Https的理解。文章将会从以下几个方面介绍。</p><p>目录树：</p><ul><li>一、网络层结构</li><li>二、Http协议</li><li>三、Tcp三次握手</li><li>四、Https协议&#x2F;SSL协议</li><li>五、SSL证书</li><li>六、RSA加密和DH加密</li><li>七、Http和Https对比</li></ul><p>从目录结构可以看出，每个标题展开来说都是一个很大的主题。但本文旨在让各位同学对Http和Https相关知识有一个全面的认知，不会太过深入探讨各个主题，有兴趣的同学可以进行针对性研究。</p><p> <strong>01 网络层结构</strong> </p><p>网络结构有两种主流的分层方式：OSI七层模型和TCP&#x2F;IP四层模型。</p><h3 id="OSI七层模型和TCP-x2F-IP四层模型"><a href="#OSI七层模型和TCP-x2F-IP四层模型" class="headerlink" title="OSI七层模型和TCP&#x2F;IP四层模型"></a><strong>OSI七层模型和TCP&#x2F;IP四层模型</strong></h3><p>OSI是指Open System Interconnect，意为开放式系统互联。</p><p>TCP&#x2F;IP是指传输控制协议&#x2F;网间协议，是目前世界上应用最广的协议。</p><table><thead><tr><th align="left">OSI层</th><th align="left">对应TCP&#x2F;IP层</th><th align="left">OSI各层功能</th><th align="left">网络协议</th><th align="left">设备</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left">应用层</td><td align="left">应用程序（电子邮件，文件服务）,用户接口</td><td align="left">HTTP，FTP，TFTP，NFS</td><td align="left">网关</td></tr><tr><td align="left">表示层</td><td align="left">应用层</td><td align="left">数据的表示，压缩和加密（数据格式化，代码转换，数据加密）</td><td align="left">TELNET，SNMP</td><td align="left">网关</td></tr><tr><td align="left">会话层</td><td align="left">应用层</td><td align="left">建立、管理和终止会话</td><td align="left">SMTP，DNS</td><td align="left">网关</td></tr><tr><td align="left">传输层</td><td align="left">传输层</td><td align="left">提供端到端可靠报文段传递和错误恢复</td><td align="left">TCP，UDP</td><td align="left">网关</td></tr><tr><td align="left">网络层</td><td align="left">网际互联层</td><td align="left">提供数据包从源到宿的传递和网际交互</td><td align="left">IP，ICMP，ARP，RARP，UUCP</td><td align="left">路由器</td></tr><tr><td align="left">链路层</td><td align="left">网络接口层</td><td align="left">将比特组装成帧和点到点传递</td><td align="left">FDDI，SLIP，PPP，PDN</td><td align="left">交换机</td></tr><tr><td align="left">物理层</td><td align="left">网络接口层</td><td align="left">传输比特流，以二进制数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802，IEEE802.2</td><td align="left">集线器，中继器</td></tr></tbody></table><h3 id="两种模型区别"><a href="#两种模型区别" class="headerlink" title="两种模型区别"></a><strong>两种模型区别</strong></h3><ol><li><p>OSI采用七层模型，TCP&#x2F;IP是四层模型</p></li><li><p>TCP&#x2F;IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。</p></li><li><p>在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP&#x2F;IP是基于协议建立的模型，不适用于非TCP&#x2F;IP的网络。</p></li><li><p>实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP&#x2F;IP已经成为国际标准。</p></li></ol><p> <strong>02 HTTP协议</strong> </p><p>Http是基于TCP&#x2F;IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。</p><h3 id="Http协议的发展历史"><a href="#Http协议的发展历史" class="headerlink" title="Http协议的发展历史"></a><strong>Http协议的发展历史</strong></h3><ol><li>1991年发布Http&#x2F;0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。</li><li>1996年发布Http&#x2F;1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致Http&#x2F;1.0新能很差。</li><li>1997发布Http&#x2F;1.1版本，完善了Http协议，直至20年后的今天仍是最流行的版本。<br>优点：a. 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。b. 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。c. 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。d. 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。e. 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。<br>缺点：TCP连接中的响应有顺序，服务器处理完一个回应才能处理下一个回应，如果某个回应特别慢，后面的请求就会排队等着（对头堵塞）。</li><li>2015年发布Http&#x2F;2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title="** **"></a>** **</h3><h3 id="Http请求和响应格式"><a href="#Http请求和响应格式" class="headerlink" title="Http请求和响应格式"></a><strong>Http请求和响应格式</strong></h3><p>Request格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /barite/account/stock/groups HTTP/1.1</span><br><span class="line">QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCA</span><br><span class="line">DEVICE-TYPE: ANDROID</span><br><span class="line">API-VERSION: 15</span><br><span class="line">Host: shitouji.bluestonehk.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">User-Agent: okhttp/3.10.0</span><br></pre></td></tr></table></figure><p>Response格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.3</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;</span><br></pre></td></tr></table></figure><p>说明一下请求头和响应头的部分字段：</p><ul><li>Host：指定服务器域名，可用来区分访问一个服务器上的不同服务</li><li>Connection：keep-alive表示要求服务器不要关闭TCP连接，close表示明确要求关闭连接，默认值是keep-alive</li><li>Accept-Encoding：说明自己可以接收的压缩方式</li><li>User-Agent：用户代理，是服务器能识别客户端的操作系统（Android、IOS、WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同操作。</li><li>Content-Type：服务器告诉客户端数据的格式，常见的值有text&#x2F;plain，image&#x2F;jpeg，image&#x2F;png，video&#x2F;mp4，application&#x2F;json，application&#x2F;zip。这些数据类型总称为MIME TYPE。</li><li>Content-Encoding：服务器数据压缩方式</li><li>Transfer-Encoding：chunked表示采用分块传输编码，有该字段则无需使用Content-Length字段。</li><li>Content-Length：声明数据的长度，请求和回应头部都可以使用该字段。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title="** **"></a>** **</h2><p>**<br>**</p><p><strong>03 Tcp三次握手</strong> </p><p>Http和Https协议请求时都会通过Tcp三次握手建立Tcp连接。</p><p><strong>那么，三次握手是指什么呢？</strong></p><p><img src="https://aimak.cn/blog_img/tcp_3.jpg" alt="img"></p><p><strong>那么，为什么一定要三次握手呢，一次可以吗？两次可以吗？</strong></p><p>带着这些问题，我们来分析一下为什么必须是三次握手。</p><ol><li>第一次握手，A向B发送信息后，B收到信息。B可确认A的发信能力和B的收信能力</li><li>第二次握手，B向A发消息，A收到消息。A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力</li><li>第三次握手，A向B发送消息，B接收到消息。B可确认A的收信能力和B的发信能力</li></ol><p>通过三次握手，A和B都能确认自己和对方的收发信能力，相当于建立了互相的信任，就可以开始通信了。</p><p>下面，我们介绍一下三次握手具体发送的内容，用一张图描述如下：</p><p><img src="https://aimak.cn/blog_img/tcp_3_1.jpg" alt="img"></p><p>首先，介绍一下几个概念：</p><ul><li>ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1</li><li>SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN&#x3D;1，其他情况都是0</li><li>FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN&#x3D;1，其他情况都是0，跟SYN类似</li><li>seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有</li><li>ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段</li></ul><p>知道了上面几个概念后，看一下三次握手的具体流程：</p><ol><li>第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。</li><li>第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack&#x3D;x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq&#x3D;y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。</li></ol><p>从图中可以看出，建立连接经历了三次握手，当数据传输完毕，需要断开连接，而断开连接经历了四次挥手：</p><ol><li>第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了</li><li>第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。</li><li>第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。</li></ol><p>下面是Tcp报文段首部格式图，对于理解Tcp协议很重要：</p><p><img src="https://aimak.cn/blog_img/tcp_3_baowen.jpg" alt="img"></p><p> <strong>04 Https协议&#x2F;SSL协议</strong> </p><p>Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL&#x2F;TLS），SSL是Https协议的安全基础。Https默认端口号为443。</p><p><strong>前面介绍了Http协议，各位同学能说出Http存在的风险吗？</strong></p><ol><li>窃听风险：Http采用明文传输数据，第三方可以获知通信内容</li><li>篡改风险：第三方可以修改通信内容</li><li>冒充风险：第三方可以冒充他人身份进行通信</li></ol><p>SSL&#x2F;TLS协议就是为了解决这些风险而设计，希望达到：</p><ol><li>所有信息加密传输，三方窃听通信内容</li><li>具有校验机制，内容一旦被篡改，通信双发立刻会发现</li><li>配备身份证书，防止身份被冒充</li></ol><p>下面主要介绍SSL&#x2F;TLS协议。</p><h3 id="SSL发展史（互联网加密通信）"><a href="#SSL发展史（互联网加密通信）" class="headerlink" title="SSL发展史（互联网加密通信）"></a><strong>SSL发展史（互联网加密通信）</strong></h3><ol><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL&#x2F;2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL&#x2F;3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS&#x2F;1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS&#x2F;1.1版本和TLS&#x2F;1.2版本</li></ol><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title="** **"></a>** **</h3><h3 id="SSL原理及运行过程"><a href="#SSL原理及运行过程" class="headerlink" title="SSL原理及运行过程"></a><strong>SSL原理及运行过程</strong></h3><p>SSL&#x2F;TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。</p><p>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。</p><p>下面用一张图表示SSL加密传输过程：</p><p><img src="https://aimak.cn/blog_img/tcp_3_ssl.jpg" alt="img"></p><p>详细介绍一下图中过程：</p><ol><li>客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式</li><li>服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）</li><li>客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端</li><li>服务端使用自己的私钥解密出C</li><li>客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。</li></ol><p><strong>05 SSL证书</strong> </p><p>上面提到了，Https协议中需要使用到SSL证书。</p><p>SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。<br>证书有很多类型，按认证级别分类：</p><ul><li>域名认证（DV&#x3D;Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名</li><li>公司认证（OV&#x3D;Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息</li><li>扩展认证（EV&#x3D;Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。</li></ul><p>EV证书浏览器地址栏样式：</p><p><img src="https://aimak.cn/blog_img/ssl_1.jpg" alt="img"></p><p>OV证书浏览器地址栏样式：</p><p><img src="https://aimak.cn/blog_img/ssl_2.jpg" alt="img"></p><p>DV证书浏览器样式：</p><p><img src="https://aimak.cn/blog_img/ssl_3.jpg" alt="img"></p><p>按覆盖范围分类：</p><ul><li>单域名证书：只能用于单域名，foo.com证书不能用不<a href="http://www.foo.com/">www.foo.com</a></li><li>通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可用于<a href="http://www.foo.com/">www.foo.com</a></li><li>多域名证书：可用于多个域名，比如foo.com和bar.com</li></ul><p>认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广Https，电子前哨基金会成立了Let’s Encrypt提供免费证书。</p><p><em><a href="https://letsencrypt.org/">https://letsencrypt.org/</a></em></p><p>证书的经销商也很多，知名度比较高的有亚洲诚信(Trust Asia)。</p><p><strong>06 RSA加密和DH加密</strong> </p><h3 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a><strong>加密算法分类</strong></h3><p>加密算法分为对称加密、非对称加密和Hash加密算法。</p><ul><li>对称加密：甲方和乙方使用同一种加密规则对信息加解密</li><li>非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。</li><li>Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程</li></ul><p>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</p><p>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。</p><p>常见的非对称加密算法有RSA、DH、DSA、ECC</p><p>Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列</p><p><strong>下面着重介绍一下RSA算法和DH算法。</strong></p><h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a><strong>RSA加密算法</strong></h3><p>Https协议就是使用RSA加密算法，可以说RSA加密算法是宇宙中最重要的加密算法。</p><p>RSA算法用到一些数论知识，包括互质关系，欧拉函数，欧拉定理。此处不具体介绍加密的过程，如果有兴趣，可以参照RSA算法加密过程。</p><p><em><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></em></p><p>RSA算法的安全保障基于大数分解问题，目前破解过的最大秘钥是700+位，也就代表1024位秘钥和2048位秘钥可以认为绝对安全。</p><p>大数分解主要难点在于计算能力，如果未来计算能力有了质的提升，那么这些秘钥也是有可能被破解的。</p><h3 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a><strong>DH加密算法</strong></h3><p>DH也是一种非对称加密算法，DH加密算法过程。</p><p><em><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B</a></em></p><p>DH算法的安全保障是基于离散对数问题。</p><p><strong>07 Http协议和Https协议的对比</strong> </p><p>Http和Https的区别如下：</p><ol><li>https协议需要到CA申请证书，大多数情况下需要一定费用</li><li>Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议</li><li>Http和Https端口号不一样，Http是80端口，Https是443端口</li><li>Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全。</li><li>Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。</li></ol><p> <strong>08 总结</strong> </p><p>经过了3天的学习和总结，总算完成了这篇文章，本文可以帮助读者大体上把握Http和Https的知识框架。</p><p>并没有深入探讨每个主题的内容，当读者有了自己知识框架之后，可以自行深入了解每个知识点的内容。<br>这边提供一份总结资料：计算机网络相关知识汇总。</p><p><em><a href="https://github.com/JeffyLu/JeffyLu.github.io/issues/22">https://github.com/JeffyLu/JeffyLu.github.io/issues/22</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所有社交背后，都藏着孤独和利益</title>
      <link href="/2019/02/28/%E6%9D%82%E8%AE%B0/%E6%89%80%E6%9C%89%E7%A4%BE%E4%BA%A4%E8%83%8C%E5%90%8E%EF%BC%8C%E9%83%BD%E8%97%8F%E7%9D%80%E5%AD%A4%E7%8B%AC%E5%92%8C%E5%88%A9%E7%9B%8A/"/>
      <url>/2019/02/28/%E6%9D%82%E8%AE%B0/%E6%89%80%E6%9C%89%E7%A4%BE%E4%BA%A4%E8%83%8C%E5%90%8E%EF%BC%8C%E9%83%BD%E8%97%8F%E7%9D%80%E5%AD%A4%E7%8B%AC%E5%92%8C%E5%88%A9%E7%9B%8A/</url>
      
        <content type="html"><![CDATA[<p>人天生就是社交动物。</p><p>互联网的出现，给我们提供了更加丰富的社交渠道和信息源。</p><p>哲学家齐泽克用“马桶里面的世界”比喻了一个未知的“彼处”——我们在“此处”看着水流冲向“彼处”，而这个按下冲水键就会去到的地方，的确像极了虚拟的网络世界。</p><p>虚拟世界是没有边界的，它给我们带来了超越日常经验的体验，同时，它也提升了我们的社交效率、降低了社交成本。</p><p>关于社交，有很多可说的，今天我们就聊聊社交，聊聊这个影响了数十亿人群的社交创业梦。</p><h2 id="一、社交的狂欢"><a href="#一、社交的狂欢" class="headerlink" title="一、社交的狂欢"></a><strong>一、社交的狂欢</strong></h2><p>每一年都会有一群人问：社交创业还有机会吗？</p><p>要回答这个问题，我们可以先问问自己，技术飞速发展，我们的社交需求真的能被完全满足了吗？</p><h3 id="1-代际下的商业现象和趋势"><a href="#1-代际下的商业现象和趋势" class="headerlink" title="1. 代际下的商业现象和趋势"></a><strong>1. 代际下的商业现象和趋势</strong></h3><p>改革开放四十年，整个社会无论从组织形态、思想观念还是经济文化方面，都发生了巨大的变化，每一代人都被相应的时代环境打下了差异的烙印。</p><p>同一代际的个体因为生长在相似背景下，很容易形成一代人的共性。然而，随着社会的迅速发展，代际差异的时间间隔变得越来越短。</p><p>对于每一代人而言，他们都有特有的社交方式，而当我们谈论代际差异的时候，本质是在谈需求满足形式的变化。</p><p>QQ的使用功能就具有一定的代际差异。可以说，很多人是伴随QQ成长起来的——虽然如今QQ的发展没能超越微信，但其实这两款软件的使用人群是完全不一样的。</p><p>据报告显示：90后们更加注重QQ的娱乐和生活功能，74%使用QQ空间，29%使用QQ游戏。</p><p>80后们更加注重QQ的使用功能，63%使用QQ邮箱，56%使用传送文件功能，而使用QQ空间和游戏的比例都比90后要低。</p><p>90后在使用QQ的聊天方式上也更富有娱乐性，76%使用表情，66%使用图片，80后聊天时使用表情和图片的比例稍低但也大量使用表情包，68%使用表情，60%使用图片。</p><p>学术界将社交网络中的表情包称为“网络觅母”（meme），能够更加形象生动地传递文化和感情信息，超越了语言文字的局限性，给使用者留下的创作和想象空间更大，既可以富于娱乐性，也可以富于批判性。对于更加追求个性化和多元化的当代青年来讲，“网络觅母”着实是表达自我的最佳工具。</p><p>对于QQ而言，二十年间它做过无数的尝试和取舍，目的都是为了更好地满足不同代际的社交体验。</p><p>即使是在微信和QQ一统社交江湖的情况下，也没有阻挡一波又一波的社交创业浪潮。一个很重要的原因就是：代际社交需求差异是客观存在的，这正是社交创业前赴后继的重要原因。</p><p>在各大应用商城里，搜索关键词“社交”，跳出来的社交软件起码有成百上千个。</p><p>据第三方机构统计，2018年中国社交app用户偏年轻化，尤其是探探一类的陌生人社交app，24岁以下用户占一半以上。</p><p>也就是说：95后用户正在成为社交主力军，这批有想法、更自主的新生代，有着不同于前人的社交需求。</p><p>如果把现在市面上的社交软件分为两大类的话：</p><p>第一类是<strong>广域的社交平台</strong>：有熟人关系的强社交，如facebook、微信；有陌生人关系的弱社交，如陌陌和微博。</p><p>第二种是<strong>垂直的社交平台</strong>：比如在陌生人关系基础上的兴趣社交，豆瓣、知乎；在互动形式上的创新社交，snapchat、secret；针对特殊性向人群的社交，blued、拉拉花园等等。</p><p>人和技术这两大因素的变迁，直接促成了社交产品的变化。</p><p>过去两年，诸多第三方机构都在关心一个群体，认为他们是经济的未来和主要引擎。</p><p>他们就是——Z世代。</p><p>Z世代主要指1995—2010年出生的互联网一代，他们是移动互联网世界的“原住民”，在深度数字化的环境下长大。</p><p>Z世代有着明显的时代特征。他们不仅仅是完全成长于数字技术成熟期的原生一代，他们还是中国社会最为典型的“独一代”——数据显示，中国家庭子女个数在2000 年下降至0.94——基本上，Z世代是所在家庭中唯一的孩子。</p><p>Z世代的说法越来越流行。如今，他们已经成为全球人口最多的群体，人数高达19亿人，占全球总人口的25%，而作为人口大国的中国则为Z世代贡献了大约2.65亿人。</p><p>所以近几年，品牌商们也会想尽办法让品牌年轻化，以此拉拢Z世代。因为它们发现，Z世代购买渠道、动机大多来自社交圈，对品牌消费的首要目的也是进行社交。</p><p>几乎每一份Z世代的消费行为研究报告都会指出，Z世代的消费动机与渠道多来自于社交。</p><p>对于Z世代而言，消费行为即“社交货币”，有了消费就等同于他们手持踏入某个社交圈的“门票”，65%的Z世代期待与朋友们拥有共同的语言。</p><p>根据腾讯《2019年Z世代营销实战手册》报告显示：Z世代典型的消费态度，是通过进行品牌消费融入所在圈层、维护社交圈，其次是打造鲜明的个人人设。相比于“品牌实用主义”的前辈们，Z世代的品牌消费背后都是社交动机在驱使。</p><p>仔细分析会发现，Z世代“消费为社交”的行为又分为两种——突破社交壁垒与维护自我圈子。</p><p>今天有不少女生也开始热衷于购买篮球鞋。一方面她们是受到审美与时尚潮流的影响，另一方面，她们发现这或许可以帮助她们打开新的社交世界。</p><p>从《Z世代消费力白皮书》的数据显示：60%的Z世代表示希望通过消费，可以更好地融入社交的圈子，买出共鸣，吸引同好。也有57%的Z世代表示，消费可以帮助自己维系社交关系。在某个领域的消费潮流，或许就是这个群体的社交通行证及话语体系。</p><p>《Z世代消费力白皮书》称，“Z世代们拥有和同伴们相同的东西，创造更多的共同话题，不落伍，才能更好地维系社交关系，不被排挤。”</p><p>当Z世代成为市场主角的时候，无论是社交产品还是品牌商，也需要被重新定义了。</p><h3 id="2-风口可能一直都在"><a href="#2-风口可能一直都在" class="headerlink" title="2. 风口可能一直都在"></a><strong>2. 风口可能一直都在</strong></h3><p>俗话说“自古流量出社交”，这也就能解释为什么每个产品经理都有一颗做社交的心，每个网站和APP都有个社交梦。</p><p>社交的3个构成要素：人（关系链）、信息、互动。</p><ul><li>关系链是促成双方产生社交的前提，用户在平台上建立关系链，为社交打好地基，关系链建立的越多、越复杂、越成熟，用户的归属感和粘性就会越高。</li><li>信息具有多种表达形式，文字、图片、视频、音频等等。</li><li>互动场景分为公开场景和私密场景，例如我们在微博上分享新鲜事就是在公开场景下进行的，熟人和不认识的人都能看到，但一对一的和其他人聊天是在私密场景下的互动。</li></ul><p>每一个组合，都是社交的可能。</p><p>1967年美国社会心理学家米尔格伦（StanleyMilgram）提出了一个“六度分离”理论。</p><p>按照六度分隔理论，当每一个体的社交圈不断扩大时，最后就构成了一个庞杂的巨型网络。</p><p>后来有人根据这一理论，创立了面向社会性网络的互联网服务，通过“熟人的熟人”来进行网络社交拓展。</p><p>国内最早的 SNS 社交网站就是基于这样的逻辑问世的。</p><p>2011 年腾讯推出了微信。微信是腾讯在移动互联网时代的一款社交产品，专注熟人社交。如今微信拥有超过10亿的用户，跨越各个年龄层。</p><p>微信做熟人社交为何能成？原因之一就是微信腾飞之前，腾讯已经手握QQ这一“国民级”即时通讯应用。腾讯通过QQ对微信的用户导流，在初期快速打败米聊，而后又击败易信、来往等，成长为国民即时通讯应用。</p><p>近年来，随着动漫、轻小说、短视频等形式的火爆，目前不少平台都试图从内容出发，在社交领域切一块蛋糕。</p><p>值得注意的是，2019年1月15日，王欣、张一鸣、罗永浩选择在同一天分别发布了“马桶MT”、“多闪”和“聊天宝”，他们随即全遭微信封杀。此举被社交江湖解读为“围剿微信”的三英战吕布、围攻光明顶，虽然结果不尽人意。</p><p>这件事说明了三点：</p><p>一是在新媒体时代，社交是刚需，人人离不了，移动社交软件通过为人们的社交提供便利积聚人气，也能为自己带来利益；</p><p>二是5G时代即将到来，社交场景、移动应用将更加丰富，移动社交软件的潜能巨大，每一个纬度都可能隐藏着巨大的商机，每一个垂直通道都可能裹挟众多用户；</p><p>三是“共享经济”风口之后，创业领域的风口乏善可陈，“移动社交”具有非常多的遐想空间，具备成为新一波创业风口的可能。</p><h2 id="二、社交，为什么成了新的创业梦？"><a href="#二、社交，为什么成了新的创业梦？" class="headerlink" title="二、社交，为什么成了新的创业梦？"></a><strong>二、社交，为什么成了新的创业梦？</strong></h2><p>今天，几乎每个人都将大把的时间花在移动社交上。</p><p>据统计，全球目前有30亿人口使用网络社交软件，大概占据了全球人口40%左右。平均每人每天花了2小时在使用社交软件，相当于一天的1&#x2F;12。</p><p>前段时间，#加了新好友，聊过几句再无下落#的话题上了热搜，有1.5亿人浏览，1.2万人讨论。</p><p>很多网友纷纷表示，这说的不就是我嘛。</p><p>在一群朋友的饭局上，人们交换一些绝对不会拨打的电话号码或是转眼就不记得是谁的微信，在饭局结束之后，拿着各自的手机说声再见。</p><p>如今的社交怎么了？</p><h3 id="1-技术迭代打开了社交多元化的大门"><a href="#1-技术迭代打开了社交多元化的大门" class="headerlink" title="1. 技术迭代打开了社交多元化的大门"></a><strong>1. 技术迭代打开了社交多元化的大门</strong></h3><p>美国新闻工作者、经济学家弗里德曼在《世界是平的》一书中为我们描绘了当前世界的重大变化：</p><p>由于科技和通信技术的进步，原先横亘在人与人之间的沟壑和藩篱被逐步抹平，全世界的人们彼此空前接近。</p><p>通信和科技的进步对社交产生了深远的影响，科技和通信本身是不带任何感情色彩和社会属性的技术，任何人都可以用它，但用到什么效果和层次，取决于你自身的能力。</p><p>以社交媒体微信为例，理论上说，我们可以用微信通讯录、微信群，结识到任何想结识的人或者被任何人结识。但现实是，有些人你不想加，有些人你加不上。有些圈子你不想进入、有些圈子你进不去。</p><p>在朋友圈管理上，我们发布的和转发的信息正在透露我们的职业、年龄、品位，你屏蔽谁、关注谁，你给谁点赞、给谁留言，你能收获多少留言收获多少赞，都反映你在现实生活中处在什么样的圈层。</p><p>Facebook CEO 马克·扎克伯格在2010年首次引入了社交图谱的概念——一个将人们和不同事物联系起来的地图，社交图谱是一种表明“我认识你”的网络图谱。而这种社交图谱正在被互联网的“圈层化”运动所掩埋。</p><p>圈层，原指一个区域内本身具备很强的社会联系、社会属性相近的群体，现在多用于泛指兴趣爱好相同的人组成的群体，其内部独特丰富的文化被称为圈层文化。</p><p>圈层文化具有原创、年轻、活跃、黏性高的属性，因此文化的传播以内容为主导，散点涟漪式扩大，形成裂变，也就是圈层效应。</p><p>圈层包括两个层面，一个是圈子，一个是关系网层级。</p><p>互联网冲击下，各行各业、各个阶层、各个人都有了自己的“圈子”。在移动互联网时代，圈子的分类更加明显。</p><p>人们常说，你身边的朋友，决定了你的层次。</p><p>这话不无道理，一个人的发展，跟他所处的圈层有很大关系，圈层决定了你的位置。</p><p>主动去链接能人，选择与更强的人同行，你所处的圈层也会越来越强。</p><p>而当你圈层强大起来之后，又会反作用在你身上，推动你的发展，这是一个良性的循环。</p><p>虽然痴迷快手的人望着B站的萌妹子，瞧着新奇，却看不懂，学不来。但是技术的飞速变革，正在加快不同圈层之间的融合。</p><p>圈层融合的价值在圈层文化发展成熟的日本已被证明。</p><p>2010年，日本动画公司 Sunrise、角川书店旗下杂志《电击 G’s magazine》以及唱片公司 Lantis先联合推出了一个叫做《LoveLive!》的二三次元联动的多媒体企划。</p><p>该项目深受粉丝追捧，是日本 Oricon 排行榜前几名的常客。衍生组合μ’s 最终演出的 BD 销量在第一周就达到了 7.1 万张，这个数字在历代日本女性歌手音乐 BD 销售纪录中排行第四。</p><p>《LoveLive!》成功的背后，除了其独特的“读者参与型偶像企划”模式外，是企划团队对圈层文化用户需求的精确分析。</p><p>日本是世界上最大的亚文化聚集地，《LoveLive!》的媒体渠道全方位覆盖，在最大限度宣传推广的同时，用二次元和三次元的偶像对应关系设定，吸引了偶像宅、游戏宅、动画宅、音乐宅等圈层文化的人群，成功地将不同文化背景领域的粉丝聚集在一起，最终实现了二三次元的交汇。</p><p>2017年爆火的《中国有嘻哈》，也是圈层文化在本土的第一次逆袭。</p><p>以原本被认为小众的“嘻哈”作为切入点的综艺，上线四个小时后播放总量就突破了1亿，吴亦凡的一句“你有Freestyle吗？”登上了微博热搜。节目从一开始的吸引嘻哈圈层和导师粉丝，到后来选手的歌曲在音乐平台上线后，横扫榜单，成功地将嘻哈文化由小众人群推向大众，最终节目以近30亿的播放量完美收官。</p><p>圈层文化看似小众，实则不然，其发展已逐渐超越自身圈层，影响主流文化。</p><h3 id="2-每个人都寻找自己的“村落”"><a href="#2-每个人都寻找自己的“村落”" class="headerlink" title="2. 每个人都寻找自己的“村落”"></a><strong>2. 每个人都寻找自己的“村落”</strong></h3><p>耶鲁大学校长彼得·萨洛维在2017毕业季演讲中说，这是一个人们敲敲键盘就可以在社交媒体上同时和几百个人聊天交友的时代，然而，越来越多的人的生活是围着互联网转，越社交越孤独。</p><p>心理学大师罗杰斯也曾经提出来过一个概念，叫“基本孤独感”，是说我们有摆脱不了也无法被安慰的孤独。</p><p>细细体味一下，我们在人际交往关系中，有很多这样的时候，我们明明双方在彼此沟通交流，但是我们总是“不得劲”，觉得没有感受到这场交流有什么意义，至少于我们个人没有达到我们想要达到的意义。哪怕明明我们身处闹市，哪怕明明我们亲朋为伴，好友相陪，我们还是有治愈不了的孤独感。</p><p><strong>我们为什么会孤独？</strong></p><p><strong>① 现有的社交媒体看似热闹，却不完全真实；</strong></p><p>归根结底，我们离不开有温度和力量的肢体接触，而这些，社交媒体永远给不了。</p><p><strong>② 现有社交媒体的关系可控性更强，也更冷酷；</strong></p><p>不论是熟人社交还是陌生人社交，在社交媒体上，拉黑、删除、可见设置等等，这种能主动掌控的社交，让人与人的关系变得冷漠。</p><p><strong>③ 朋友圈，真实也虚假；</strong></p><p>在社交网络，我们可以选择让自己“被看见”或者“不被看见”。为了“被看见”，朋友圈成了舞台，晒幸福的，晒恩爱的，晒豪车豪宅的……一旦没有得到回应，就陷入巨大的失落或者焦虑之中。</p><p><strong>④ 信息茧房下的群体性孤独；</strong></p><p>沉迷于网络社交，忽视现实生活中的人际交流，迷恋网络游戏，成为情感机器人的依赖者，这种情况我们称为信息茧房下的“群体性孤独”。</p><p>社交“群体性孤独”会使得人们更加痴迷于互联网环境，并且心生攀比，这种不良的心态会使得其生活变得更加孤独。</p><p>“群体性孤独”还会影响人们理性辨别能力的培养，对于社交“群体性孤独”的人而言，他们对于尊重和爱的需求是虚拟化的，片面地认为陌生人对于自己的点赞，就是一种人际交往中的关怀。</p><p>越来越多的人陷入到这种社交的孤独和焦虑之中。</p><p><strong>我们要如何摆脱这种状态？</strong></p><p><strong>① 找到社交的最佳尺度；</strong></p><p>社交是可以有一个最佳尺度的，不管是线下社交，还是线上社交，要掌握主动权。</p><p>基于Facebook的研究发现，当主动在社交网络上发起一些行为时，幸福感会更高，积极情绪会更多。</p><p><strong>②明确需要；</strong></p><p>明确需要通过社交网络得到什么。比如需要信息支持或者需要情感依托。</p><p><strong>③ 社交工具的本质；</strong></p><p>看清楚社交工具的本质，有利于更好地管理社交关系。</p><p>在苏珊·平克的《村落效应》中，作者呼吁我们应该“面对面社交”。应该在面对面社交与虚拟社交之间取得平衡。既要与家人及朋友重新建立亲密的联系，又要与邻居、同事或其他人分享共同兴趣。</p><p>这样可以有效改善个人生活质量及情绪，提升人们的幸福感。</p><h3 id="3-社交的本质从来没有变过"><a href="#3-社交的本质从来没有变过" class="headerlink" title="3. 社交的本质从来没有变过"></a><strong>3. 社交的本质从来没有变过</strong></h3><p>风墟先生在《社交的本质》一文中提到，社交分为两种，一种是共情社交，一种是功利社交。</p><p>共情社交是指为了获得情感联结与情感体验，打发无聊，或是有共同的兴趣等而产生的社交行为。</p><p>这种社交不涉及利益的交换，且绝大多数人自小产生的社交行为都是源于这种共情类的需求。</p><p>共情社交存在的根本原因在于：当一个人的心智在某方面尚未成熟独立时，或是当他生活不如意时，他需要从朋友那里获得情感上的联结和支持。</p><p>功利社交是指为了达成某一目的，或是从对方身上获得利益而产生的社交行为。</p><p>随着一个人心智的完善和社会地位的提升，他会越来越注重社交的效益性。</p><p>功利社交有两个基本前提：</p><p><strong>一是“有效”信息的交互传递。</strong></p><p>这个信息是广义的，在人际交往中的如语言、情感、物质、知识等都可以包括在这个信息的范畴内。</p><p>沟通的本质就是信息的传递。而有效是功利性社交的一个基本要素。人们产生功利社交行为之前基本上都是抱有一定的目的性，当我和你产生社交时，我们的交流应该是有价值的，而不是毫无意义的闲扯和浪费时间的各说各话。</p><p><strong>二是较为“对等”的价值水平。</strong></p><p>这个价值水平并不仅仅只是指社会地位。它依据的是具体情况和个人的评判标准。</p><p>功利性社交的根本目的就是能够从对方那里获得一定的利益或是得到帮助，如果一个人和一个人的差距极大，很清楚对方这个人在未来的生活中不可能带来丝毫的利益，那么这段社交关系就是无价值的，所以本能地就会舍弃。</p><p>商业行为的本质是逐利，社交最终还是要回归本质。</p><p>记得新版微信推出的时候，页面出现了这样一句话：“因你看见，所以存在”，这也许是社交帝国缔造者张小龙的社交梦。</p><p>最后，未来的社交产品会是什么样子，我们不知道，但我们永远心怀期待。</p><h3 id="中国社交产品发展路径"><a href="#中国社交产品发展路径" class="headerlink" title="中国社交产品发展路径"></a><strong>中国社交产品发展路径</strong></h3><p>1994年，中国大陆第一个互联网BBS——曙光站上线。</p><p>1995年，马化腾在家搭建了慧多网深圳站点，起名Pony-soft。</p><p>1996年，求伯君在珠海架设了“西线”BBS站，雷军在北京架设了“西点”；同年，丁磊加入广州飞捷，架设了基于公网的BBS，并在上面认识了周卓林；汪延和李嵩波加入四通利方，利方在线成立，并先后开辟了“谈天说地”和“体育沙龙”版块。</p><p>1997年，中国网络论坛兴起。也就是这一年，“猫扑”问世。</p><p>1998年，西祠胡同（综合性网络社区）因“911事件”西祠网友大讨论，创下单个版块在线千人的历史记录。</p><p>1999年2月，QQ上线。这个以企鹅为标志物的即时通讯软件，适逢当年中国互联网大力发展的大环境，其方便快捷的特性一下子吸引了中国大众的眼球，在短短的几年间，席卷全中国。</p><p>2002年8月，博客中国成立。</p><p>2003年12月，全球最大的中文社区百度贴吧上线。</p><p>2005年，王兴、王慧文、赖斌强、唐阳等几位大学生创办校内网（后改名人人网），同年，杨勃创办的社区网站豆瓣上线。</p><p>2006年，校内网与5Q网强强联合，最终成功占领了校园市场；通过熟人关系的突破，SNS终究还是在中国找到了出路。</p><p>2008年3月，定位在白领圈的开心网成立，并在随后的两个月内上线了朋友买卖和争车位应用，类似朋友圈小游戏的社交裂变模式第一次出现在SNS网站上。</p><p>2009年8月，新浪微博上线。</p><p>2010年四季度，QQ空间用户超过4.8亿；2013年末，QQ空间被列为世界第三，中国第一的社交网站。</p><p>2010年5月，腾讯微博上线。</p><p>2010年10月，一款名为“kik”的应用登陆App Store和Android Market，短短15天内就有超过100万人注册下载。</p><p>2010年11月20日，在工信部官方调停3Q大战的当天，“微信”项目正式启动，次年1月21日，微信上线。</p><p>2011年，陌陌上线。</p><p>2012年3月29日凌晨4点，微信用户突破1亿，历时433天。这几乎是互联网历史上的一个奇迹：QQ在线用户数突破1亿用了将近10年，Facebook用了5年半，Twitter用了4年。</p><p>2012年4月19日，朋友圈上线，微信完成了通信工具向社交平台的升级，基于手机的熟人社交圈正式出现，微博、人人遭到沉重打击。</p><p>2013年10月，中国的实名制商业社交平台脉脉上线。</p><p>2014年，探探上线。</p><p>2016年9月，专注年轻人音乐短视频社区平台抖音上线。</p><p>2019年1月15日，王欣、张一鸣、罗永浩选择在同一天分别发布了“马桶MT”、“多闪”和“聊天宝”。“马桶MT”上线1小时就被关停。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>QuestMobile2018年度报告：立足当下泛传媒业，十大趋势定位未来</p><p>圈层文化爆款频出，多圈层融合成为未来趋势 | 行业研究</p><p>中国社交二十年</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful 架构基础</title>
      <link href="/2019/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/RESTful%20%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/RESTful%20%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="http://t.cn/EVBQ2Ug">http://t.cn/EVBQ2Ug</a></p><p>REST（Representational State Transfer）架构风格是一种世界观，把信息提升为架构中的一等公民。通过 REST 可以实现系统的高性能、可伸缩、通用性、简单性、可修改性和可扩展等特性。这篇文章解释了主要的 HTTP 操作，对 HTTP 响应码进行描述，并列举相关开发库和框架。此外，本文还提供了额外的资源，对每个主题进行了更深入的探讨。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>REST 架构风格不是一种可以购买的技术，也不是一个可以添加到软件开发项目中的开发库。首先也是最重要的，REST 是一种世界观，把将信息提升为构建架构中的一等公民。</p><p>Roy Fielding 的博士论文“架构风格和基于网络的软件架构设计”介绍和整理了“RESTful”系统的思想和相关术语。这是一篇学术论文，虽然使用正式语言，但是仍然易于理解并且提供了实践基础。</p><p>总结一下，RESTful 通过体系结构的特定选择能从部署的系统中获得理想特性。尽管这种风格定义的约束细节并没有为所有场合设计，但是的确可以广泛适用。</p><p>由于 Web 对消费者偏好有多重影响，REST 风格的倡导者鼓励企业组织在其边界内使用相同原则，就像他们在面向外部客户的网页上做的那样。本文将讨论现代 REST Web 实现中的基本约束和属性。</p><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><p>REST 表示什么含义？以无状态方式传输、访问和操作文本数据。当正确部署后，REST 为互联网上不同应用程序之间提供了一致的互操作性。无状态（stateless）这个术语至关重要，它使得应用程序可以用不可知的方式进行通信。RESTful API 通过统一资源定位符地址（URL）公开服务。URL 名称将资源的区分为接受内容或返回内容。RFC 1738中定义了 URL scheme，可以在这里找到: <a href="https://tools.ietf.org/rfc/rfc1738.txt">https://tools.ietf.org/rfc/rfc1738.txt</a></p><p>RESTful URL 类似于下面这个 library API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>实际公开的不一定是某种任意的服务，而是代表对消费者有价值的信息资源。URL 作为资源句柄，可以请求、更新或删除内容。</p><p>开始把服务发布到某个地方，然后开始与 REST 服务进行交互。返回的内容可能是 XML、JSON 格式，或者更确切地说是像 Atom 或自定义 MIME 类型等超媒体格式。虽然一般建议尽可能重用现有的格式，但是对正确设计的媒体类型正在变得越来越宽容。</p><p>需要请求资源的时候，客户机会发一个超文本传输协议（HTTP）GET 请求，例如在浏览器中键入一个 URL 然后点击回车，选择书签，或者点击锚引用链接。</p><p>通过编程方式与 RESTful API 交互，有数十个客户端 API 或工具可供选择。使用 curl 命令行工具，可以输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>上面的命令使用默认格式，但你可能不需要这种格式的信息。幸运的是 HTTP 有一种机制，可以指定返回信息的格式。在请求中指定 “Accept” 头，如果服务器支持这种格式，会以指定的格式返回。这个过程称为内容协商，这是 HTTP 中未被充分利用的功能之一，可以使用一个类似于上面例子中的 curl 命令来指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl –H &quot;Accept:application/json&quot; http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>由于资源名称与内容格式是独立的，从而让请求不同格式信息成为可能。虽然 REST 中的 “R” 的含义是 “表现”而非“资源”，但是应该在构建系统时允许客户端指定请求的内容格式，请牢记这一点。在我们的例子中 library API 可能包含以下 URL：</p><ul><li><a href="http://fakelibrary.org/library%EF%BC%9A%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%9B%BE%E4%B9%A6%E3%80%81DVD%E7%AD%89%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E9%93%BE%E6%8E%A5%E3%80%82">http://fakelibrary.org/library：图书馆基本信息，搜索图书、DVD等相关资源基本功能的链接。</a></li><li><a href="http://fakelibrary.org/book%EF%BC%9A%E5%AD%98%E6%94%BE%E4%B9%A6%E7%B1%8D%E7%9A%84%E2%80%9C%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E2%80%9D%E3%80%82%E4%BB%8E%E6%A6%82%E5%BF%B5%E4%B8%8A%E8%AF%B4%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E7%9A%84%E4%B9%A6%E7%B1%8D%E3%80%82%E6%98%BE%E7%84%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%BE%97%E5%88%B0%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%8D%E4%BC%9A%E5%B8%8C%E6%9C%9B%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E5%9B%BE%E4%B9%A6%EF%BC%8C%E8%80%8C%E6%98%AF%E5%B8%8C%E6%9C%9B%E9%80%9A%E8%BF%87%E7%B1%BB%E5%88%AB%E3%80%81%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E7%AD%89%E6%9D%A5%E6%A3%80%E7%B4%A2%E5%9B%BE%E4%B9%A6%E3%80%82">http://fakelibrary.org/book：存放书籍的“信息空间”。从概念上说，这里可能会存放所有的书籍。显然，如果这个问题得到解决，我们不会希望返回所有图书，而是希望通过类别、搜索关键词等来检索图书。</a></li><li><a href="http://fakelibrary.org/book/category/1234%EF%BC%9A%E5%9C%A8%E4%B9%A6%E7%B1%8D%E7%9A%84%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E9%87%8C%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%88%AB%E6%B5%8F%E8%A7%88%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%88%90%E4%BA%BA%E5%B0%8F%E8%AF%B4%E3%80%81%E5%84%BF%E7%AB%A5%E4%B9%A6%E7%B1%8D%E3%80%81%E5%9B%AD%E8%89%BA%E4%B9%A6%E7%B1%8D%E7%AD%89%E3%80%82%E4%BD%BF%E7%94%A8%E6%9D%9C%E5%A8%81%E5%8D%81%E8%BF%9B%E5%88%B6%E5%9B%BE%E4%B9%A6%E5%88%86%E7%B1%BB%E6%B3%95%E6%98%AF%E5%8F%AF%E8%A1%8C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%83%B3%E8%B1%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E3%80%82%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%EF%BC%8C%E8%BF%99%E7%A7%8D%E2%80%9C%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E2%80%9D%E5%8F%AF%E8%83%BD%E6%98%AF%E6%97%A0%E9%99%90%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%94%E5%8F%AF%E8%83%BD%E6%94%B6%E5%88%B0%E4%BA%BA%E4%BB%AC%E5%AE%9E%E9%99%85%E5%85%B3%E5%BF%83%E7%9A%84%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%BD%B1%E5%93%8D%E3%80%82">http://fakelibrary.org/book/category/1234：在书籍的信息空间里，我们可以指定类别浏览，例如成人小说、儿童书籍、园艺书籍等。使用杜威十进制图书分类法是可行的，但我们也可以想象自定义分组。问题的关键在于，这种“信息空间”可能是无限的，而且可能收到人们实际关心的信息类型影响。</a></li><li><a href="http://fakelibrary.org/book/isbn/978-0596801687%EF%BC%9A%E6%8F%90%E5%88%B0%E6%9F%90%E6%9C%AC%E5%85%B7%E4%BD%93%E7%9A%84%E4%B9%A6%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8C%85%E6%8B%AC%E4%B9%A6%E5%90%8D%E3%80%81%E4%BD%9C%E8%80%85%E3%80%81%E5%87%BA%E7%89%88%E5%95%86%E3%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%95%B0%E3%80%81%E5%8F%AF%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">http://fakelibrary.org/book/isbn/978-0596801687：提到某本具体的书，应该包括书名、作者、出版商、系统中的拷贝数、可用拷贝数等信息。</a></li></ul><blockquote><p>译注： 杜威十进制图书分类法由美国图书馆专家麦尔威·杜威发明，于1876年首次发表，历经22次的大改版。该分类法以三位数字代表分类码，共可分为10个大分类、100个中分类及1000个小分类。</p></blockquote><p>就图书馆用户而言，上面提到的这些 URL 可能就是只读的，但是图书馆员使用应用程序时实际上可以操作这些资源。</p><p>例如添加一本新书，可以向 main&#x2F;book 地址 POST 一个 XML。 使用 curl 提交，看起来可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  curl –u username:password -d @book.xml -H &quot;Content-type: text/xml&quot; http://fakelibrary.org/book</span><br></pre></td></tr></table></figure><p>此时，服务器可能会对提交的内容进行校验，创建与图书相关的记录，并返回响应代码201——表示已创建新资源。新资源的 URL 可以在响应的 Location 头中找到。</p><p>RESTful 请求一个重要特性：每次请求都包含了充足的状态信息来响应请求。这为服务器的可见性和无状态创造了条件，并为扩展系统和识别发送的请求内容提供了理想特性。对于缓存结果也非常有帮助。服务器地址和请求状态组合成可计算的 hash 键值，并形成一个结果集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org + /book/isbn/978-0596801687</span><br></pre></td></tr></table></figure><p>接下来我们会先介绍 GET 请求。客户端在需要时发出 GET 请求获取指定资源。客户端可以在本地缓存请求结果，服务器可以在远程缓存结果，系统的中间层可以在请求链路中间缓存结果。这是一个与具体应用程序无关的特性，可以加入系统设计中。</p><p>正因为可以操作资源，也就意味着并不是每个人都可以这样做。我们完全可以建立一个防护模型，要求用户在操作前验证身份，证明他们具有该操作的授权。在本文的最后，将提供一些提升 RESTful 服务安全性的内容。</p><h1 id="2-REST-和-SOAP-比怎么样？"><a href="#2-REST-和-SOAP-比怎么样？" class="headerlink" title="2. REST 和 SOAP 比怎么样？"></a>2. REST 和 SOAP 比怎么样？</h1><blockquote><p>SOAP：简单对象访问协议（Simple Object Access Protocol）。是交换数据的一种协议规范，是一种轻量的、简单的、基于XML的协议。一条 SOAP 消息就是一个普通的 XML 文档，包含必需的 Envelope 元素、可选的 Header 元素、必需的 Body 元素和可选的 Fault 元素。</p></blockquote><p>把 REST 与 SOAP 划等号是错误的。在这两者之间进行比较，带来的困扰远多于好处。简单来说，它们不是一回事。尽管可以用这两种方法解决许多架构问题，但是它们不能相互替换。</p><p>这种混淆很大程度上源于对 “REST 是通过 URL 调用 Web 服务”这句话的误解。这种观点与 RESTful 架构的功能相距甚远。如果不全面深入理解 RESTful 的架构实现，就很容易误解 REST 实践的本意。</p><p>利用 REST 的最佳方式，是将生产和消费过程中的信息与技术分离实现解耦，进而更好地管理系统，让架构具备以下特性：</p><ul><li>高性能</li><li>可扩展</li><li>通用</li><li>简洁</li><li>可修改</li><li>可扩展</li></ul><p>这并不是说，基于 SOAP 构建的系统不能具备上述特性。而是当技术、组织或过程的复杂性造成不能在单个事务中完成请求的生命周期时，这种情况 SOAP 能够发挥最佳效果。</p><h1 id="3-Richardson-成熟度模型"><a href="#3-Richardson-成熟度模型" class="headerlink" title="3. Richardson 成熟度模型"></a>3. Richardson 成熟度模型</h1><p>Leonard Richardson 引入了一种成熟度模型，部分阐述了 SOAP 与 REST 之间的区别，并提供一种对不同类型的系统进行分类的框架。许多人不恰当地称之为 “REST”。可以将这种分类看作系统中不同 Web 技术组件紧密程度的度量标准：包括信息资源、HTTP 作为应用层协议和作超媒体作为控制媒介。</p><table><thead><tr><th>LEVEL</th><th>ADOPTION</th></tr></thead><tbody><tr><td>0</td><td>This is basically where SOAP is. There are no information resources, HTTP is treated like a transport protocol, and there is no concept of hypermedia. Conclusion: REST and SOAP are different approaches.</td></tr><tr><td>1</td><td>URLs are used, but not always as appropriate information resources, and everything is usually a GET request (including requests that update server state). Most people new to REST first build systems that look like this.</td></tr><tr><td>2</td><td>URLs are used to represent information resources. HTTP is respected as an application protocol, sometimes including content negotiation. Most Internet-facing “REST” web services are really only at this level because they only support non- hypermedia formats.</td></tr><tr><td>3</td><td>URLs are used to represent information resources. HTTP is respected as an application protocol including content negotiation. Hypermedia drives the interactions for clients.</td></tr></tbody></table><p>称其为“成熟度模型”似乎意味着应该只构建“成熟度”最高的系统。这种看法是不合适的。第2级是有价值的，从2级向3级转变通常只是采用了一种新的 MIME 类型。然而，从0级到3级的转变要困难得多，因此增量式升级转变通常也会增值。</p><p>首先，确定希望公开哪些信息资源。采用 HTTP 作为处理这些信息资源的应用协议，包括内容协商。接下来，当一切就绪时，使用基于超媒体的 MIME 类型，这样就可以充分享受 REST 的好处了。</p><h1 id="4-动词"><a href="#4-动词" class="headerlink" title="4. 动词"></a>4. 动词</h1><p>动词是用来与服务器资源交互的方法或操作。 RESTful 系统中有限的动词让刚接触该的使用者感到困惑和沮丧。看似武断和不必要的约束，目的是鼓励以应用程序无关的形式提供可预测的行为。通过明确、清晰地定义这些动词的行为，客户端可以在网络中断或故障时自主处理。</p><p>精心设计的 RESTful 系统主要使用4个 HTTP 动词。</p><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>GET 请求是最常用的 Web 动词。 GET 请求将命名资源从服务器传输到客户端。尽管客户端不需要知道请求的资源内容，但是请求返回的结果是带元数据标记的字节流，这表明客户端应该知道如何解释资源。 在 Web 中通常用 “text&#x2F;html” 或 “application&#x2F;xhtml+xml” 表示。正如之前提到的那样，只要服务器支持，客户端可以通过内容协商提前指定请求的返回格式。</p><p>GET 请求关键点之一，不要修改服务器端的任何内容。这是一个基本的安全要求，也是不熟悉 REST 的开发者犯的最大错误之一。你可能会遇到这样的 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/res/action=update?data=1234</span><br></pre></td></tr></table></figure><p><strong>不要这样做！</strong> 由于 GET 请求安全性允许缓存请求，这会让正在构建的 RESTful 系统陷入混乱。 GET 请求也意味着幂等性，即多次请求不会对系统产生任何影响。这是基于分布式基础设施的一个重要特性。如果进行 GET 请求时被打断，由于幂等性，客户端可以再次发起请求。这点非常重要。在设计良好的基础结构中，客户端可以从任意应用程序发起请求。虽然一定会有与应用程序相关的特定行为，但是加入与应用程序无关的行为越多，系统就会越有弹性，也更容易维护。</p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>在辨别 POST 和 PUT 动词意图的时候，情况开始变得不那么清晰。根据定义，二者似乎都可以被客户端用来创建或更新服务器资源，然而它们的用途各有不同。</p><p>当无法预测请求创建的资源的标识时，客户端会使用 POST 请求。在新增雇员、下订单或提交表单的时候，我们无法预测服务器将如何命名正在创建的资源。这就是为什么将资源提交给类似 Servlet 这样的程序处理。接下来，服务器会接受请求、校验请求、验证用户凭据等。成功处理后，服务器将返回 201 HTTP 响应代码，其中包含一个 “Location” 头，代表新创建的资源的位置。</p><p><strong>注意：</strong> 有些人将 POST 视为创建资源的 GET 会话。他们会对创建的资源通过 body 返回200，而不是返回201。这似乎是避免二次请求的一种快捷方式，但是这种做法混合了 POST 和 GET，让缓存资源的潜在影响变得微妙。尽量避免因为走捷径而牺牲大局。短期看这似乎是值得的，但随着时间的推移，这些捷径叠加起来可能会带来不利的影响。</p><p>POST 动词的另一个主要用途是“追加（Append）”资源信息，即增量编辑或部分更新，而不是提交完整的资源。这里应使用 PUT 操作。对已知资源使用 POST 更新，可用于向订单添加新送货地址或更新购物车中某个商品的数量。</p><p>由于是更新资源的部分信息，<strong>POST 既不安全也不幂等</strong>。</p><p>POST 的最后一种常见用法是提交查询。将查询的内容或表单内容进行 URL 编码后提交给服务执行查询。通常可以直接返回 POST 结果，因为没有与查询相关的标识。</p><p><strong>注意：</strong> 建议将这样的查询转换为信息资源本身。如果采用 POST 查询，可以考虑采用 GET 请求，后者支持缓存。你可以与其他人分享这个链接。</p><h2 id="4-3-PUT"><a href="#4-3-PUT" class="headerlink" title="4.3 PUT"></a>4.3 PUT</h2><p>由于 HTML 表单目前还不支持 PUT，许多开发人员基本上会忽略 PUT 动词。然而，PUT 有一个重要作用并且是 RESTful 系统完整愿景的一部分。</p><p>客户端可以向指定 URL 发 PUT 请求，服务器用请求中的数据执行覆盖操作。PUT 请求在某种程度上是等幂的，而 POST 更新不是。</p><p>如果客户端在 PUT 覆盖请求时被打断，由于重新发送覆盖操不会造成任何后果，因此可以再次发送。客户端具备管理状态能力，所以直接重发覆盖命令即可。</p><p><strong>注意：</strong> 这种协议层处理并不意味着要取消更高级别（如应用层）的事务，但是同样地，它也是一种体系结构上理想的属性，可以在应用层以下使用。</p><p>如果客户端能够提前了解资源的标识，那么 PUT 也可用于创建资源。正如我们在 POST 部分中讨论的那样，通常不会出现这种情况。但是如果客户端能够控制服务器端信息空间，那么这种操作也是合理的。</p><h2 id="4-4-DELETE"><a href="#4-4-DELETE" class="headerlink" title="4.4 DELETE"></a>4.4 DELETE</h2><p>在公共网络上 DELETE 动词没有被广泛使用（谢天谢地!）。然而，对于控制信息空间非常有用，它是资源生命周期中非常有用的一部分。</p><p>DELETE 请求意在实现等幂。可能由于网络故障 DELETE 请求被打断，这时我们希望客户端继续尝试。第一次请求无论成功与否，资源都应该返回204（无指定内容）。对之前已删除的资源或不存在的资源可能需要一些额外处理，两种情况都应该返回404。一些安全策略要求为不存在的和已删除的资源返回404，这样 DELETE 请求就不会泄漏有关资源是否存在的信息。</p><p>还有另外三个没有广泛使用但是有价值的动词。</p><h2 id="4-5-HEAD"><a href="#4-5-HEAD" class="headerlink" title="4.5 HEAD"></a>4.5 HEAD</h2><p>HEAD 动词用来请求资源，但不实际检索。客户端可以通过 HEAD 检查资源是否存在，并检查资源相关的元数据。</p><h2 id="4-6-OPTIONS"><a href="#4-6-OPTIONS" class="headerlink" title="4.6 OPTIONS"></a>4.6 OPTIONS</h2><p>OPTIONS 动词也可以用来查询服务器相关资源的情况，方法是询问哪些其它动词可用于该资源。</p><h2 id="4-7-PATCH"><a href="#4-7-PATCH" class="headerlink" title="4.7 PATCH"></a>4.7 PATCH</h2><p>最新的动词 PATCH 直到2010年才正式采纳为 HTTP 的一部分。旨在提供一种标准化方式来表示部分更新。PATCH 请求通过标准格式让交互的意图更明确。这是推荐使用 PATCH 而非 POST 的原因，尽管 POST 可以用于任何事情。 IETF 发布了 RFC 文档，定义用于 PATCH 操作的 XML 和 JSON。</p><p>如果客户端 PATCH 请求的 header 中带 If-Match，则此部分为幂等更新。可以重试中断的请求，因为如果第一次请求成功，那么 If-Match header 会不同于新状态。如果相同，则未处理原始请求可应用 PATCH。</p><h1 id="5-响应码"><a href="#5-响应码" class="headerlink" title="5. 响应码"></a>5. 响应码</h1><p>HTTP 响应码为我们在客户端和服务器之间的对话提供了丰富的请求状态信息。大多数人只熟悉一般意义上的200、403、404或者500，但是还有更多有用的代码可供使用。这里表格并不全面，但是它们涵盖了许多在 RESTful 环境中应该考虑使用的最重要代码。数字可按照以下类别分组：</p><ul><li>1XX：信息类</li><li>2XX：操作成功</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务器错误</li></ul><p>第一组响应码表明客户端的请求格式正确且处理成功。具体操作如下表所示：</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>200</td><td>OK. The request has successfully executed. Response depends upon the verb invoked.</td></tr><tr><td>201</td><td>Created. The request has successfully executed and a new resource has been created in the process. The response body is either empty or contains a representation containing URIs for the resource created. The Location header in the response should point to the URI as well.</td></tr><tr><td>202</td><td>Accepted. The request was valid and has been accepted but has not yet been processed. The response should include a URI to poll for status updates on the request. This allows asynchronous REST requests</td></tr><tr><td>204</td><td>No Content. The request was successfully processed but the server did not have any response. The client should not update its display.</td></tr></tbody></table><p>表1 成功的客户端请求</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently. The requested resource is no longer located at the specified URL. The new Location should be returned in the response header. Only GET or HEAD requests should redirect to the new location. The client should update its bookmark if possible.</td></tr><tr><td>302</td><td>Found. The requested resource has temporarily been found somewhere else. The temporary Location should be returned in the response header. Only GET or HEAD requests should redirect to the new location. The client need not update its bookmark as the resource may return to this URL.</td></tr><tr><td>303</td><td>See Other. This response code has been reinterpreted by the W3C Technical Architecture Group (TAG) as a way of responding to a valid request for a non-network addressable resource. This is an important concept in the Semantic Web when we give URIs to people, concepts, organizations, etc. There is a distinction between resources that can be found on the Web and those that cannot. Clients can tell this difference if they get a 303 instead of 200. The redirected location will be reflected in the Location header of the response. This header will contain a reference to a document about the resource or perhaps some metadata about it.</td></tr></tbody></table><p>表2 — 客户端重定向请求</p><p>表3中的响应代码表示客户端请求无效，如果条件不发生变化，重新请求仍无法处理。这些故障可能有请求格式错误、未授权的请求、请求的资源不存在等。</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>405</td><td>Method Not Allowed.</td></tr><tr><td>406</td><td>Not Acceptable.</td></tr><tr><td>410</td><td>Gone.</td></tr><tr><td>411</td><td>Length Required.</td></tr><tr><td>412</td><td>Precondition Failed.</td></tr><tr><td>413</td><td>Entity Too Large.</td></tr><tr><td>414</td><td>URI Too Long.</td></tr><tr><td>415</td><td>Unsupported Media Type.</td></tr><tr><td>417</td><td>Expectation Failed.</td></tr></tbody></table><p>表3 客户端请求错误</p><p>最后，表4中的响应代码表示服务器暂时无法处理客户端请求（可能仍然无效）。客户端应当在将来的某个时候重新请求。</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error.</td></tr><tr><td>501</td><td>Not Implemented.</td></tr><tr><td>503</td><td>Service Unavailable.</td></tr></tbody></table><p>表4 服务器处理请求错误</p><p>服务根据其自身功能要求具有不同程度的可扩展性。</p><p><strong>注意：</strong> 试试响应代码418，它会返回简洁有力的回复：”我是一个茶壶。”</p><h2 id="5-1-REST-资源"><a href="#5-1-REST-资源" class="headerlink" title="5.1 REST 资源"></a>5.1 REST 资源</h2><h3 id="5-1-1-论文"><a href="#5-1-1-论文" class="headerlink" title="5.1.1 论文"></a>5.1.1 论文</h3><p>Fielding 博士的论文《架构的风格与基于网络的软件架构设计》是对 RESTful 思想的主要介绍：<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></p><h3 id="5-1-2-RFC-规范"><a href="#5-1-2-RFC-规范" class="headerlink" title="5.1.2 RFC 规范"></a>5.1.2 RFC 规范</h3><p>REST 常见用法的技术规范由<strong>国际互联网工程任务组（IETF）定义，按照请求评议（RFC）</strong>流程完善。规范由数字定义，并随着时间推移不时更新版本，以替换已经过时的文件。目前，这里有最新的相关 RFC 文件。</p><h4 id="5-1-2-1-URI"><a href="#5-1-2-1-URI" class="headerlink" title="5.1.2.1 URI"></a>5.1.2.1 URI</h4><p>RFC 3986定义了 URI 命名方案的通用语法。URI 是一种命名方案，包含了对其他如网址、支持名字子空间等编码方案。网址：<a href="http://www.ietf.org/rfc/rfc3986.txt&gt;">http://www.ietf.org/rfc/rfc3986.txt&gt;</a></p><h4 id="5-1-2-2-URL"><a href="#5-1-2-2-URL" class="headerlink" title="5.1.2.2 URL"></a>5.1.2.2 URL</h4><p>Url 是 URI 的一种形式，其中嵌入了充足的信息（通常是访问方案和地址），用于解析和定位资源统一资源定位符。 网址：<a href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a></p><h4 id="5-1-2-3-IRI"><a href="#5-1-2-3-IRI" class="headerlink" title="5.1.2.3 IRI"></a>5.1.2.3 IRI</h4><p>国际化资源标识符（IRI）在概念上是一个用 Unicode 编码的 URI，用于在 Web 上使用的标识符中支持世界上各种语言的字符。 IETF 选择创建一个新的标准，而不是改变 URI 方案本身，以避免破坏现有的系统并明确区分这两种方法。那些支持 IRI 的人故意这样做。 还定义了在 IRI 和 URI 之间进行转换的映射方案。 网址&lt;：<a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a></p><h4 id="5-1-2-4-HTTP"><a href="#5-1-2-4-HTTP" class="headerlink" title="5.1.2.4 HTTP"></a>5.1.2.4 HTTP</h4><p>HTTP 1.1版本定义了一个应用程序协议，用于操作通常以超媒体格式表示的信息资源。虽然它是一个应用级协议，但通常不与应用程序绑定，由此产生了重要的体系结构优势。 大多数人认为 HTTP 和超文本标记语言文（HTML）就是“Web”，但是 HTTP 在非面向文档的系统开发中也很有用。 网址： <a href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</a></p><h4 id="5-1-2-5-PATCH-格式"><a href="#5-1-2-5-PATCH-格式" class="headerlink" title="5.1.2.5 PATCH 格式"></a>5.1.2.5 PATCH 格式</h4><p>JavaScript 对象表示法（JSON）Patch 网址：<a href="https://www.ietf.org/rfc/rfc6902.txt">https://www.ietf.org/rfc/rfc6902.txt</a><br>XML Patch 网址：<a href="https://www.ietf.org/rfc/rfc7351.txt">https://www.ietf.org/rfc/rfc7351.txt</a></p><h2 id="5-2-描述语言"><a href="#5-2-描述语言" class="headerlink" title="5.2 描述语言"></a>5.2 描述语言</h2><p>人们对使用各种语言来描述 API 非常感兴趣，通过描述语言可以更容易地编写客户端和服务器文档，甚至生成骨架代码。一些比较流行、有趣的描述语言包括：</p><h3 id="5-2-1-RAML"><a href="#5-2-1-RAML" class="headerlink" title="5.2.1 RAML"></a>5.2.1 RAML</h3><p>RAML 是一种 YAML&#x2F;JSON 语言，可以定义2级成熟度的 API。它支持可重用模式和特性，通过模式和特性实现功能 API 设计的标准化。网址：<a href="http://raml.org/">http://raml.org</a></p><h3 id="5-2-2-Swagger"><a href="#5-2-2-Swagger" class="headerlink" title="5.2.2 Swagger"></a><strong>5.2.2 Swagger</strong></h3><p>Swagger 是另一种 YAML&#x2F;JSON 语言，支持定义2级成熟度的 API。它包含代码生成器、编辑器、 API 文档可视化功能，能够与其他服务集成的。 网址：<a href="http://swagger.io/">http://swagger.io</a></p><h3 id="5-2-3-Apiary-io"><a href="#5-2-3-Apiary-io" class="headerlink" title="5.2.3 Apiary.io"></a>5.2.3 Apiary.io</h3><p>Apiary.io 是一个协作式的托管站点。它支持 Markdown 格式的 API 文档，可以围绕设计过程进行社交，并且支持模拟数据的托管实现，以便于在 API 实现之前对其进行测试。 网址：<a href="http://apiary.io/">http://apiary.io</a></p><h3 id="5-2-4-Hydra-Cg"><a href="#5-2-4-Hydra-Cg" class="headerlink" title="5.2.4 Hydra-Cg"></a>5.2.4 Hydra-Cg</h3><p>Hydra-Cg 是一种超媒体描述语言，通过像 JSON-LD 这样的标准方便地实现数据关联和并其它数据源的交互。网址：<a href="http://www.hydra-cg.com/">http://www.hydra-cg.com</a></p><h2 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h2><p>有一些用于构建、生成和使用 RESTful 系统的库和框架。虽然任何 Web 服务器都可以配置成提供 REST API，但有了这些框架、库和环境可以让过程变得更容易。</p><p>以下概述了一些主流的环境：</p><h3 id="5-3-1-JAX-RS"><a href="#5-3-1-JAX-RS" class="headerlink" title="5.3.1 JAX-RS"></a>5.3.1 JAX-RS</h3><p>JAX-RS 规范为 JEE 环境增加了对 REST 的支持。网址：<a href="https://jax-rs-spec.java.net/">https://jax-rs-spec.java.net</a></p><h3 id="5-3-2-Restlet"><a href="#5-3-2-Restlet" class="headerlink" title="5.3.2 Restlet"></a>5.3.2 Restlet</h3><p>Restlet API 是构建用于生产和消费 RESTful 系统的 Java API 先行者之一。它专注于为客户端和服务器生成一些非常干净、强大的 API。</p><p>Restlet Studio 是一个免费工具，能够在 RAML 和基于 swagger 的 API 描述之间进行转换，支持 Restlet、 Node 和 JAX-RS 服务器和客户端的骨架和 Stub 代码。网址：<a href="http://restlet.org/">http://restlet.org</a></p><h3 id="5-3-3-NetKernel"><a href="#5-3-3-NetKernel" class="headerlink" title="5.3.3 NetKernel"></a>5.3.3 NetKernel</h3><p>Netkernel 是一个比较有趣的 RESTful 系统。它基于微内核，是支持各种架构风格环境的代表。Netkernel 受益于在软件体系结构中采用 Web 的经济属性。你可以把它想象成“在内部引入 REST”。虽然任何基于 REST 的系统在外面看起来都一样，但在运行环境内部 NetKernel 看起来也一样。网址：<a href="http://netkernel.org/">http://netkernel.org</a></p><h3 id="5-3-4-Play"><a href="#5-3-4-Play" class="headerlink" title="5.3.4 Play"></a>5.3.4 Play</h3><p>两个主要的 Scala REST 框架之一。网址：<a href="https://www.playframework.com/">https://www.playframework.com</a></p><h3 id="5-3-5-Spray"><a href="#5-3-5-Spray" class="headerlink" title="5.3.5 Spray"></a>5.3.5 Spray</h3><p>两个主要的 Scala REST 框架之一。它设计成配合 Akka actor 模型一起工作。网址：<a href="http://spray.io/">http://spray.io</a></p><h3 id="5-3-6-Express"><a href="#5-3-6-Express" class="headerlink" title="5.3.6 Express"></a>5.3.6 Express</h3><p>两个主要的 Node.js REST 框架之一。网址：<a href="http://expressjs.com/">http://expressjs.com</a></p><h3 id="5-3-7-hapi"><a href="#5-3-7-hapi" class="headerlink" title="5.3.7 hapi"></a>5.3.7 hapi</h3><p>两个主要的 Node.js REST 框架之一。网址：<a href="http://hapijs.com/">http://hapijs.com</a></p><h3 id="5-3-8-Sinatra"><a href="#5-3-8-Sinatra" class="headerlink" title="5.3.8 Sinatra"></a>5.3.8 Sinatra</h3><p>Sinatra 是一个领域特定语言（DSL），用来在 Ruby 中创建 RESTful 应用程序。网址：<a href="http://www.sinatrarb.com/">http://www.sinatrarb.com</a></p><h2 id="5-4-客户端"><a href="#5-4-客户端" class="headerlink" title="5.4 客户端"></a>5.4 客户端</h2><p>通过浏览器调用 REST API 是可行的，但是还有其它客户端可用于测试和构建面向资源的系统。</p><h3 id="5-4-1-curl"><a href="#5-4-1-curl" class="headerlink" title="5.4.1 curl"></a>5.4.1 curl</h3><p>curl 是流行的库和命令行工具之一，支持在各种资源上调用各种协议。网址：<a href="https://curl.haxx.se/">https://curl.haxx.se</a></p><h3 id="5-4-2-httpie"><a href="#5-4-2-httpie" class="headerlink" title="5.4.2 httpie"></a>5.4.2 httpie</h3><p>httpie 是一个非常灵活和易用的客户端，支持通过 HTTP 与资源进行交互。网址：<a href="https://httpie.org/">https://httpie.org</a></p><h3 id="5-4-3-Postman"><a href="#5-4-3-Postman" class="headerlink" title="5.4.3 Postman"></a>5.4.3 Postman</h3><p>健全的 API 测试需要能够捕获和重播请求，支持各种身份验证和授权方案等功能。以前的命令行工具允许这样做，但 Postman 是一个较新的桌面应用程序，让这些工作对于开发团队来说变得更容易。网址：<a href="https://www.getpostman.com/">https://www.getpostman.com</a></p><h1 id="6-书籍"><a href="#6-书籍" class="headerlink" title="6. 书籍"></a>6. 书籍</h1><ul><li>“RESTful Web APIs”：Leonard Richardson、Mike Amundsen 和 Sam Ruby，2013，O’Reilly 出版社</li><li>“RESTful Web Services Cookbook”：Subbu Allamaraju，2010，O’Reilly 出版社</li><li>“REST in Practice”：Jim Webber、Savas Parastatidis 和 Ian Robinson，2010，O’Reilly 出版社。中文版《REST实战(中文版)》</li><li>“Restlet in Action” by Jerome Louvel and Thierry Boileau，2011，Manning 出版社</li><li>“Resource-Oriented Architecture Patterns for Webs of Data (Synthesis Lectures on the Semantic Web: Theory and Technology)”：Brian Sletten，2013，Morgan &amp; Claypool</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大成功定律：荷花定律，竹子定律，金蝉定律</title>
      <link href="/2019/02/21/%E6%9D%82%E8%AE%B0/%E4%B8%89%E5%A4%A7%E6%88%90%E5%8A%9F%E5%AE%9A%E5%BE%8B%EF%BC%9A%E8%8D%B7%E8%8A%B1%E5%AE%9A%E5%BE%8B%EF%BC%8C%E7%AB%B9%E5%AD%90%E5%AE%9A%E5%BE%8B%EF%BC%8C%E9%87%91%E8%9D%89%E5%AE%9A%E5%BE%8B/"/>
      <url>/2019/02/21/%E6%9D%82%E8%AE%B0/%E4%B8%89%E5%A4%A7%E6%88%90%E5%8A%9F%E5%AE%9A%E5%BE%8B%EF%BC%9A%E8%8D%B7%E8%8A%B1%E5%AE%9A%E5%BE%8B%EF%BC%8C%E7%AB%B9%E5%AD%90%E5%AE%9A%E5%BE%8B%EF%BC%8C%E9%87%91%E8%9D%89%E5%AE%9A%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>关于成功，有很多定律，比较有名的就是荷花定律、竹子定律和金蝉定律。</p><p>无论是荷花定律、竹子定律，还是金蝉定律，他们都有共同的意义：</p><p><strong>成功，需要厚积薄发</strong></p><p><strong>要忍受煎熬，要耐得住寂寞</strong></p><p><strong>坚持，坚持，再坚持</strong></p><p><strong>直到最后成功的那一刻</strong></p><p> <strong>01</strong> </p><p><strong>荷花定律</strong></p><p>一个池塘里的荷花，每一天都会以前一天的2倍数量在开放。</p><p>如果到第30天，荷花就开满了整个池塘。</p><p>请问：<strong>在第几天池塘中的荷花开了一半？</strong></p><p><strong>第15天？错！是第29天。</strong></p><p>这就是荷花定律。</p><p>第一天开放的只是一小部分，第二天，它们会以前一天的两倍速度开放。</p><p>到第29天时荷花仅仅开满了一半，直到最后一天才会开满另一半。</p><p>也就是说：最后一天的速度最快，等于前29天的总和。</p><p>这就是著名的荷花定律。</p><p>这其中藏着深刻的道理就是：<strong>成功需要厚积薄发，需要积累沉淀。</strong></p><p>这个定律最早是听过马云的一个公开演讲，而透过这个定律去联想人生，你会发生，很多人的一生就像池塘里的荷花，一开始用力地开，玩命地开……</p><p>但渐渐的，人们开始感到枯燥甚至是厌烦，你可能在第9天、第19天甚至第29天的时候放弃了坚持。</p><p><strong>这时，这个时候的放弃，往往离成功只有一步之遥。</strong></p><p>甚至可以说大多时候，人能获得成功，关键在于毅力。</p><p>据说人这一生大概能遇到7次左右的机会，都是可以改变人生的机会，而这样的机会往往都是在前期日复一日的投入和坚持才能遇到这样的机会。</p><p>所以说，如果有梦想就要先动起来，然后坚定不移的去执行下去。</p><p> <strong>02</strong> </p><p><strong>竹子定律</strong></p><p>竹子用了4年的时间，仅仅长了3cm。</p><p>从第五年开始，以每天30cm的速度疯狂地生长，仅仅用了六周的时间，就长到了15米。</p><p>其实，在前面的四年，竹子将根在土壤里延伸了数百平米。</p><p>做人做事亦是如此。</p><p><strong>不要担心你此时此刻的付出得不到回报，因为这些付出都是为了扎根。</strong></p><p>人生需要储备，有多少人，没能熬过那三厘米？</p><p>什么叫价值？同是两根竹子，一支做成了笛子，一支做成了晾衣杠。</p><p>晾衣杠不服气的问笛子：“我们都是同一片山上的竹子，凭什么我天天日晒雨淋，不值一文，而你却价值千金呢？”</p><p>笛子回答说：“<strong>因为你只挨了一刀，而我却经历了千刀万剐，精雕细做。</strong>”</p><p>晾衣杠沉默了。</p><p><strong>人生亦是如此，经得起打磨，耐得起寂寞，扛得起责任，肩负起使命，人生才会有价值。</strong></p><p>看见别人辉煌的时候，不要嫉妒，因为别人付出的比你多。</p><blockquote><p>国学大师钱穆说：“古往今来有大成就者，诀窍无他，都是能人肯下笨劲。”</p><p>胡适也说：“这个世界聪明人太多，肯下笨功夫的人太少，所以成功者只是少数人。”</p></blockquote><p>说起钱钟书的满腹经纶，人们往往归功于他的天分高，记忆力强。</p><p>其实，钱钟书学问博大精深，更多来自后天手不释卷的苦功。</p><p>钱钟书大学同窗许振德这样描述：在校时，以一周读中文经典，一周阅欧美名著，交互行之，四年如一日。每赴图书馆借书还书，必怀抱五六巨册，且奔且驰。且阅毕一册，必作札记……</p><p><strong>代表他学术成就的《管锥编》，引述4000多位名家的上万种著作中的数万条书证，汪洋恣肆，博大精深。</strong></p><p>有些人可能不知道，他进入清华后，目标是“横扫清华图书馆”。</p><p>他的治学心得是：越是聪明人，越要懂得下笨功夫。</p><p>“心在一艺，其艺必工，一心在一职，其职必举”。</p><p><strong>成长不是一蹴而就的，哪有什么人生开挂，只不过是厚积薄发。</strong></p><p>这就叫竹子定律。</p><p> <strong>03</strong> </p><p><strong>金蝉定律</strong></p><p>蝉，要先在地下暗无天日的生活三年（有一种美国的蝉，要在地下生活17年），忍受各种寂寞和孤独，依靠树根的汁一点点长大。</p><p>然后在夏天的一个晚上，悄悄爬到树枝上，一夜之间蜕变成知了。</p><p>然后期待太阳升起的那一刻，它就可以飞向天空，冲向自由。</p><p>这就叫金蝉定律。</p><p> <strong>04</strong> </p><p>很多人的一生就像池塘里的荷花，一开始用力盛开，但是总感觉自己绽放的不够，所以渐渐感到厌倦，在第10天、第20天、甚至第29天的时候，选择了放弃。</p><p>很多人的奋斗也像生长的竹子，一开始卯足了劲，但是由于前面的大部分阶段都在打基，所以成效并不那么明显，在第1年、第3年，甚至第4年的时候选择了放弃。</p><p>就更不用提蝉的淡定和坚守了。</p><p><strong>越接近成功越困难，越需要坚持。</strong></p><p>无论是事业还是人生，我们缺少的不是能力、技巧、模式，需要的是坚持和毅力，只有坚持量变，才能最后完成质变，才能突破成功的临界点，取得最后的成功。</p><p>马云曾说：“今天很残酷，明天更残酷，后天很美好，但是大多数人死在明天晚上，看不到后天的太阳。”</p><p>大部分人都是在离成功一步之遥却放弃了。</p><p>中国有句老话“<strong>行百里半九十</strong>”，就是说走一百里路，走九十里才算走了一半，因为很多人坚持到九十里就放弃了。</p><p>这些定律告诉我们这样一个道理：<strong>人拼到最后，拼的不是运气和聪明，而是毅力。</strong></p><p>来源：京博国学(ID: jingboguoxue)</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java性能优化的50个细节</title>
      <link href="/2019/02/01/java/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8450%E4%B8%AA%E7%BB%86%E8%8A%82/"/>
      <url>/2019/02/01/java/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8450%E4%B8%AA%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h3 id="Java性能优化的50个细节"><a href="#Java性能优化的50个细节" class="headerlink" title="Java性能优化的50个细节"></a>Java性能优化的50个细节</h3><p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p><h4 id="1-尽量在合适的场合使用单例"><a href="#1-尽量在合适的场合使用单例" class="headerlink" title="1. 尽量在合适的场合使用单例"></a>1. 尽量在合适的场合使用单例</h4><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>第一，控制资源的使用，通过线程同步来控制资源的并发访问；</p><p>第二，控制实例的产生，以达到节约资源的目的；</p><p>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p><h4 id="2-尽量避免随意使用静态变量"><a href="#2-尽量避免随意使用静态变量" class="headerlink" title="2. 尽量避免随意使用静态变量"></a>2. 尽量避免随意使用静态变量</h4><p>当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;private static B b = new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p><h4 id="3-尽量避免过多过常地创建Java对象"><a href="#3-尽量避免过多过常地创建Java对象" class="headerlink" title="3. 尽量避免过多过常地创建Java对象"></a>3. 尽量避免过多过常地创建Java对象</h4><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度地重用对象，最好能用基本的数据类型或数组来替代对象。</p><h4 id="4-尽量使用final修饰符"><a href="#4-尽量使用final修饰符" class="headerlink" title="4. 尽量使用final修饰符"></a>4. 尽量使用final修饰符</h4><p>带有final修饰符的类是不可派生的。在JAVA核心API中，有许多应用final的例子，例如java、lang、String，为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关），此举能够使性能平均提高50%。</p><p>如：让访问实例内变量的getter&#x2F;setter方法变成”final：</p><p>简单的getter&#x2F;setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MAF &#123;</span><br><span class="line">public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br><span class="line">更正</span><br><span class="line">class DAF_fixed &#123;</span><br><span class="line">final public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-尽量使用局部变量"><a href="#5-尽量使用局部变量" class="headerlink" title="5. 尽量使用局部变量"></a>5. 尽量使用局部变量</h4><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快；其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p><h4 id="6-尽量处理好包装类型和基本类型两者的使用场所"><a href="#6-尽量处理好包装类型和基本类型两者的使用场所" class="headerlink" title="6. 尽量处理好包装类型和基本类型两者的使用场所"></a>6. 尽量处理好包装类型和基本类型两者的使用场所</h4><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p><h4 id="7-慎用synchronized，尽量减小synchronize的方法"><a href="#7-慎用synchronized，尽量减小synchronize的方法" class="headerlink" title="7. 慎用synchronized，尽量减小synchronize的方法"></a>7. 慎用synchronized，尽量减小synchronize的方法</h4><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以，synchronize的方法尽量减小，并且应尽量使用方法同步代替代码块同步。</p><h4 id="8-尽量不要使用finalize方法"><a href="#8-尽量不要使用finalize方法" class="headerlink" title="8. 尽量不要使用finalize方法"></a>8. 尽量不要使用finalize方法</h4><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p><h3 id="9-尽量使用基本数据类型代替对象"><a href="#9-尽量使用基本数据类型代替对象" class="headerlink" title="9. 尽量使用基本数据类型代替对象"></a>9. 尽量使用基本数据类型代替对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p><h4 id="10-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList"><a href="#10-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList" class="headerlink" title="10. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList"></a>10. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</h4><p>HashTable、Vector等使用了同步机制，降低了性能。</p><h4 id="11-尽量合理的创建HashMap"><a href="#11-尽量合理的创建HashMap" class="headerlink" title="11. 尽量合理的创建HashMap"></a>11. 尽量合理的创建HashMap</h4><p>当你要创建一个比较大的hashMap时，充分利用这个构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor);</span><br></pre></td></tr></table></figure><p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p><h4 id="12-尽量减少对变量的重复计算"><a href="#12-尽量减少对变量的重复计算" class="headerlink" title="12. 尽量减少对变量的重复计算"></a>12. 尽量减少对变量的重复计算</h4><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size();i++)</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,len=list.size();i&lt;len;i++)</span><br></pre></td></tr></table></figure><p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p><h4 id="13-尽量避免不必要的创建"><a href="#13-尽量避免不必要的创建" class="headerlink" title="13. 尽量避免不必要的创建"></a>13. 尽量避免不必要的创建</h4><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">if(i==1)&#123;</span><br><span class="line">list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(i==1)&#123;</span><br><span class="line">A a = new A();</span><br><span class="line">list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-尽量在finally块中释放资源"><a href="#14-尽量在finally块中释放资源" class="headerlink" title="14. 尽量在finally块中释放资源"></a>14. 尽量在finally块中释放资源</h4><p>程序中使用到的资源应当被释放，以避免资源泄漏，这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><h4 id="15-尽量使用移位来代替’a-x2F-b’的操作"><a href="#15-尽量使用移位来代替’a-x2F-b’的操作" class="headerlink" title="15. 尽量使用移位来代替’a&#x2F;b’的操作"></a>15. 尽量使用移位来代替’a&#x2F;b’的操作</h4><p>“&#x2F;“是一个代价很高的操作，使用移位的操作将会更快和更有效</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a / 4;</span><br><span class="line">int num = a / 8;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a &gt;&gt; 2;</span><br><span class="line">int num = a &gt;&gt; 3;</span><br></pre></td></tr></table></figure><p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解。</p><h4 id="16-尽量使用移位来代替’a-b’的操作"><a href="#16-尽量使用移位来代替’a-b’的操作" class="headerlink" title="16.尽量使用移位来代替’a*b’的操作"></a>16.尽量使用移位来代替’a*b’的操作</h4><p>同样的，对于’*’操作，使用移位的操作将会更快和更有效</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a * 4;</span><br><span class="line">int num = a * 8;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a &lt;&lt; 2;</span><br><span class="line">int num = a &lt;&lt; 3;</span><br></pre></td></tr></table></figure><h4 id="17-尽量确定StringBuffer的容量"><a href="#17-尽量确定StringBuffer的容量" class="headerlink" title="17. 尽量确定StringBuffer的容量"></a>17. 尽量确定StringBuffer的容量</h4><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = new StringBuffer(1000);</span><br></pre></td></tr></table></figure><h4 id="18-尽量早释放无用对象的引用"><a href="#18-尽量早释放无用对象的引用" class="headerlink" title="18. 尽量早释放无用对象的引用"></a>18. 尽量早释放无用对象的引用</h4><p>大部分时，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p><p>例如：</p><p>Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">Object obj = new Object();</span><br><span class="line">……</span><br><span class="line">Obj=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p><p>Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">Object obj = new Object();</span><br><span class="line">……</span><br><span class="line">Obj=null;</span><br><span class="line">//执行耗时，耗内存操作；或调用耗时，耗内存的方法</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p><h4 id="19-尽量避免使用二维数组"><a href="#19-尽量避免使用二维数组" class="headerlink" title="19. 尽量避免使用二维数组"></a>19. 尽量避免使用二维数组</h4><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p><h4 id="20-尽量避免使用split"><a href="#20-尽量避免使用split" class="headerlink" title="20. 尽量避免使用split"></a>20. 尽量避免使用split</h4><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p><h4 id="21-ArrayList-amp-LinkedList"><a href="#21-ArrayList-amp-LinkedList" class="headerlink" title="21. ArrayList &amp; LinkedList"></a>21. ArrayList &amp; LinkedList</h4><p>一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p><h4 id="22-尽量使用System-arraycopy-代替通过来循环复制数组"><a href="#22-尽量使用System-arraycopy-代替通过来循环复制数组" class="headerlink" title="22. 尽量使用System.arraycopy ()代替通过来循环复制数组"></a>22. 尽量使用System.arraycopy ()代替通过来循环复制数组</h4><p>System.arraycopy() 要比通过循环来复制数组快的多。</p><h4 id="23-尽量缓存经常使用的对象"><a href="#23-尽量缓存经常使用的对象" class="headerlink" title="23. 尽量缓存经常使用的对象"></a>23. 尽量缓存经常使用的对象</h4><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO&#x2F;FLU等缓存算法。</p><h4 id="24-尽量避免非常大的内存分配"><a href="#24-尽量避免非常大的内存分配" class="headerlink" title="24. 尽量避免非常大的内存分配"></a>24. 尽量避免非常大的内存分配</h4><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p><h4 id="25-慎用异常"><a href="#25-慎用异常" class="headerlink" title="25. 慎用异常"></a>25. 慎用异常</h4><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p><p>如果您创建一个 Exception ，就得付出代价，好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，你甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p><h4 id="26-尽量重用对象"><a href="#26-尽量重用对象" class="headerlink" title="26. 尽量重用对象"></a>26. 尽量重用对象</h4><p>特别是String对象的使用中，出现字符串连接情况时应使用StringBuffer代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p><h4 id="27-不要重复初始化变量"><a href="#27-不要重复初始化变量" class="headerlink" title="27. 不要重复初始化变量"></a>27. 不要重复初始化变量</h4><p>默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成null，整数变量设置成0，float和double变量设置成0.0，逻辑值设置成false。当一个类从另一个类派生时，这一点尤其应该注意，因为用new关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。</p><p>这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法。比如initXXX()中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：public int state &#x3D; this.getState()。</p><h4 id="28-在java-Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。"><a href="#28-在java-Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。" class="headerlink" title="28. 在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。"></a>28. 在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</h4><h4 id="29-在java编程过程中，进行数据库连接，I-x2F-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。"><a href="#29-在java编程过程中，进行数据库连接，I-x2F-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。" class="headerlink" title="29. 在java编程过程中，进行数据库连接，I&#x2F;O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。"></a>29. 在java编程过程中，进行数据库连接，I&#x2F;O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</h4><h4 id="30-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。"><a href="#30-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。" class="headerlink" title="30. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。"></a>30. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</h4><h4 id="31-在使用同步机制时，应尽量使用方法同步代替代码块同步。"><a href="#31-在使用同步机制时，应尽量使用方法同步代替代码块同步。" class="headerlink" title="31. 在使用同步机制时，应尽量使用方法同步代替代码块同步。"></a>31. 在使用同步机制时，应尽量使用方法同步代替代码块同步。</h4><h4 id="32-不要在循环中使用Try-x2F-Catch语句，应把Try-x2F-Catch放在循环最外层"><a href="#32-不要在循环中使用Try-x2F-Catch语句，应把Try-x2F-Catch放在循环最外层" class="headerlink" title="32. 不要在循环中使用Try&#x2F;Catch语句，应把Try&#x2F;Catch放在循环最外层"></a>32. 不要在循环中使用Try&#x2F;Catch语句，应把Try&#x2F;Catch放在循环最外层</h4><p>Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误Exception都能获取到的，虚拟机报错Exception就获取不到，必须用Error获取。</p><h4 id="33-通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能"><a href="#33-通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能" class="headerlink" title="33. 通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能"></a>33. 通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能</h4><p>StringBuffer的默认容量为16，当StringBuffer的容量达到最大容量时，它会将自身容量增加到当前的2倍+2，也就是2*n+2。无论何时，只要StringBuffer到达它的最大容量，它就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给StringBuffer设置一个合理的初始化容量值，是很有必要的！</p><h4 id="34-合理使用java-util-Vector"><a href="#34-合理使用java-util-Vector" class="headerlink" title="34. 合理使用java.util.Vector"></a>34. 合理使用java.util.Vector</h4><p>Vector与StringBuffer类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector的默认存储能力为10个元素，扩容加倍。</p><p>vector.add(index,obj) 这个方法可以将元素obj插入到index位置，但index以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于remove(int index)方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用removeAllElements()方法。</p><p>如果要删除vector里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如int index &#x3D; indexOf（obj）;vector.remove(index)。</p><h4 id="35-不用new关键字创建对象的实例"><a href="#35-不用new关键字创建对象的实例" class="headerlink" title="35. 不用new关键字创建对象的实例"></a>35. 不用new关键字创建对象的实例</h4><p>用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了Cloneable接口，我们可以调用它的clone()方法。clone()方法不会调用任何类构造函数。</p><p>下面是Factory模式的一个典型实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Credit getNewCredit()</span><br><span class="line">&#123;</span><br><span class="line">return new Credit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的代码使用clone()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Credit BaseCredit = new Credit();</span><br><span class="line">public static Credit getNewCredit()</span><br><span class="line">&#123;</span><br><span class="line">return (Credit)BaseCredit.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="36-不要将数组声明为：public-static-final"><a href="#36-不要将数组声明为：public-static-final" class="headerlink" title="36. 不要将数组声明为：public static final"></a>36. 不要将数组声明为：public static final</h4><h4 id="37-HaspMap的遍历："><a href="#37-HaspMap的遍历：" class="headerlink" title="37. HaspMap的遍历："></a>37. HaspMap的遍历：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String[]&gt; paraMap = new HashMap&lt;String, String[]&gt;();</span><br><span class="line">for( Entry&lt;String, String[]&gt; entry : paraMap.entrySet() )</span><br><span class="line">&#123;</span><br><span class="line">String appFieldDefId = entry.getKey();</span><br><span class="line">String[] values = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用散列值取出相应的Entry做比较得到结果，取得entry的值之后直接取key和value。</p><h4 id="38-array-数组-和ArrayList的使用"><a href="#38-array-数组-和ArrayList的使用" class="headerlink" title="38. array(数组)和ArrayList的使用"></a>38. array(数组)和ArrayList的使用</h4><p>array 数组效率最高，但容量固定，无法动态改变，ArrayList容量可以动态增长，但牺牲了效率。</p><h4 id="39-单线程应尽量使用-HashMap-ArrayList-除非必要，否则不推荐使用HashTable-Vector，它们使用了同步机制，而降低了性能。"><a href="#39-单线程应尽量使用-HashMap-ArrayList-除非必要，否则不推荐使用HashTable-Vector，它们使用了同步机制，而降低了性能。" class="headerlink" title="39. 单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。"></a>39. 单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。</h4><h4 id="40-StringBuffer-StringBuilder的区别在于"><a href="#40-StringBuffer-StringBuilder的区别在于" class="headerlink" title="40. StringBuffer,StringBuilder的区别在于"></a>40. StringBuffer,StringBuilder的区别在于</h4><p>java.lang.StringBuffer 线程安全的可变字符序列。一个类似于String的字符串缓冲区，但不能修改。StringBuilder与该类相比，通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p><p>为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用StringBuffer仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用StringBuffer。</p><h4 id="41-尽量使用基本数据类型代替对象。"><a href="#41-尽量使用基本数据类型代替对象。" class="headerlink" title="41. 尽量使用基本数据类型代替对象。"></a>41. 尽量使用基本数据类型代替对象。</h4><h4 id="42-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。"><a href="#42-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。" class="headerlink" title="42. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。"></a>42. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。</h4><h4 id="43-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。"><a href="#43-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。" class="headerlink" title="43. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。"></a>43. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</h4><h4 id="44-应尽可能避免使用内在的GET-SET方法。"><a href="#44-应尽可能避免使用内在的GET-SET方法。" class="headerlink" title="44. 应尽可能避免使用内在的GET,SET方法。"></a>44. 应尽可能避免使用内在的GET,SET方法。</h4><h4 id="45-避免枚举，浮点数的使用。"><a href="#45-避免枚举，浮点数的使用。" class="headerlink" title="45.避免枚举，浮点数的使用。"></a>45.避免枚举，浮点数的使用。</h4><p>以下举几个实用优化的例子：</p><h4 id="46、避免在循环条件中使用复杂表达式"><a href="#46、避免在循环条件中使用复杂表达式" class="headerlink" title="46、避免在循环条件中使用复杂表达式"></a>46、避免在循环条件中使用复杂表达式</h4><p>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Vector;</span><br><span class="line">class CEL &#123;</span><br><span class="line">void method (Vector vector) &#123;</span><br><span class="line">for (int i = 0; i &lt; vector.size (); i++) // Violation</span><br><span class="line">; // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CEL_fixed &#123;</span><br><span class="line">void method (Vector vector) &#123;</span><br><span class="line">int size = vector.size ()</span><br><span class="line">for (int i = 0; i &lt; size; i++)</span><br><span class="line">; // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47、为’Vectors’-和-‘Hashtables’定义初始大小"><a href="#47、为’Vectors’-和-‘Hashtables’定义初始大小" class="headerlink" title="47、为’Vectors’ 和 ‘Hashtables’定义初始大小"></a>47、为’Vectors’ 和 ‘Hashtables’定义初始大小</h4><p>JVM为Vector扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见Vector容量的扩大是一个颇费时间的事。</p><p>通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Vector;</span><br><span class="line">public class DIC &#123;</span><br><span class="line">public void addObjects (Object[] o) &#123;</span><br><span class="line">// if length &gt; 10, Vector needs to expand</span><br><span class="line">for (int i = 0; i&lt; o.length;i++) &#123;</span><br><span class="line">v.add(o); // capacity before it can add more elements.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Vector v = new Vector(); // no initialCapacity.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><p>自己设定初始大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Vector v = new Vector(20);</span><br><span class="line">public Hashtable hash = new Hashtable(10);</span><br></pre></td></tr></table></figure><h4 id="48、在finally块中关闭Stream"><a href="#48、在finally块中关闭Stream" class="headerlink" title="48、在finally块中关闭Stream"></a>48、在finally块中关闭Stream</h4><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><p>四、使用’System.arraycopy ()’代替通过来循环复制数组</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class IRB</span><br><span class="line">&#123;</span><br><span class="line">void method () &#123;</span><br><span class="line">int[] array1 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">array1 [i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int[] array2 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array2.length; i++) &#123;</span><br><span class="line">array2 [i] = array1 [i]; // Violation</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IRB</span><br><span class="line">&#123;</span><br><span class="line">void method () &#123;</span><br><span class="line">int[] array1 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">array1 [i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int[] array2 = new int [100];</span><br><span class="line">System.arraycopy(array1, 0, array2, 0, 100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="49、让访问实例内变量的getter-x2F-setter方法变成”final”"><a href="#49、让访问实例内变量的getter-x2F-setter方法变成”final”" class="headerlink" title="49、让访问实例内变量的getter&#x2F;setter方法变成”final”"></a>49、让访问实例内变量的getter&#x2F;setter方法变成”final”</h4><p>简单的getter&#x2F;setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MAF &#123;</span><br><span class="line">public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DAF_fixed &#123;</span><br><span class="line">final public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="50、对于常量字符串，用’String’-代替-‘StringBuffer’"><a href="#50、对于常量字符串，用’String’-代替-‘StringBuffer’" class="headerlink" title="50、对于常量字符串，用’String’ 代替 ‘StringBuffer’"></a>50、对于常量字符串，用’String’ 代替 ‘StringBuffer’</h4><p>常量字符串并不需要动态改变长度。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class USC &#123;</span><br><span class="line">String method () &#123;</span><br><span class="line">StringBuffer s = new StringBuffer (&quot;Hello&quot;);</span><br><span class="line">String t = s + &quot;World!&quot;;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。</p><h4 id="51、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话"><a href="#51、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话" class="headerlink" title="51、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话"></a>51、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话</h4><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class STR &#123;</span><br><span class="line">public void method(String s) &#123;</span><br><span class="line">String string = s + &quot;d&quot; // violation.</span><br><span class="line">string = &quot;abc&quot; + &quot;d&quot; // violation.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><p>将一个字符的字符串替换成’ ‘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class STR &#123;</span><br><span class="line">public void method(String s) &#123;</span><br><span class="line">String string = s + &#x27;d&#x27;</span><br><span class="line">string = &quot;abc&quot; + &#x27;d&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍，活学活用，变通为宜。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Maven Helper解决Maven冲突</title>
      <link href="/2018/12/29/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8Maven%20Helper%E8%A7%A3%E5%86%B3Maven%E5%86%B2%E7%AA%81/"/>
      <url>/2018/12/29/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8Maven%20Helper%E8%A7%A3%E5%86%B3Maven%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、何为依赖冲突"><a href="#1、何为依赖冲突" class="headerlink" title="1、何为依赖冲突"></a>1、何为依赖冲突</h2><p>Maven是个很好用的依赖管理工具，但是再好的东西也不是完美的。Maven的依赖机制会导致Jar包的冲突。举个例子，现在你的项目中，使用了两个Jar包，分别是A和B。现在A需要依赖另一个Jar包C，B也需要依赖C。但是A依赖的C的版本是1.0，B依赖的C的版本是2.0。这时候，Maven会将这1.0的C和2.0的C都下载到你的项目中，这样你的项目中就存在了不同版本的C，这时Maven会依据<strong>依赖路径最短优先原则</strong>，来决定使用哪个版本的Jar包，而另一个无用的Jar包则未被使用，这就是所谓的<strong>依赖冲突</strong>。</p><p>在大多数时候，依赖冲突可能并不会对系统造成什么异常，因为Maven始终选择了一个Jar包来使用。但是，不排除在某些特定条件下，会出现类似<strong>找不到类的异常</strong>，所以，只要存在依赖冲突，在我看来，最好还是解决掉，不要给系统留下隐患。</p><h2 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h2><p>解决依赖冲突的方法，就是使用Maven提供的<strong><strong>标签，</strong></strong>标签需要放在****标签内部，就像下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>log4j-core</code>本身是依赖了<code>log4j-api</code>的，但是因为一些其他的模块也依赖了<code>log4j-api</code>，并且两个<code>log4j-api</code>版本不同，所以我们使用****标签排除掉<code>log4j-core</code>所依赖的<code>log4j-api</code>，这样Maven就不会下载<code>log4j-core</code>所依赖的<code>log4j-api</code>了，也就保证了我们的项目中只有一个版本的<code>log4j-api</code>。</p><h2 id="3、Maven-Helper"><a href="#3、Maven-Helper" class="headerlink" title="3、Maven Helper"></a>3、Maven Helper</h2><p>看到这里，你可能会有一个疑问。如何才能知道自己的项目中哪些依赖的Jar包冲突了呢？Maven Helper这个InteliJ IDEA的插件帮我们解决了这个问题。插件的安装方法我就不讲了，既然你都会Maven了，我相信你也是会安装插件的。</p><p>在插件安装好之后，我们打开pom.xml文件，在底部会多出一个<strong>Dependency Analyzer</strong>选项</p><p><img src="https://segmentfault.com/img/remote/1460000017542411?w=2560&h=1380" alt="img"></p><p>点开这个选项</p><p><img src="https://segmentfault.com/img/remote/1460000017542412" alt="img"></p><p>找到冲突，点击右键，然后选择<strong>Exclude</strong>即可排除冲突版本的Jar包。</p><h2 id="4、小技巧"><a href="#4、小技巧" class="headerlink" title="4、小技巧"></a>4、小技巧</h2><p>除了使用Maven Helper查看依赖冲突，也可以使用IDEA提供的方法——Maven依赖结构图，打开Maven窗口，选择Dependencies，然后点击那个图标（Show Dependencies）或者使用快捷键（Ctrl+Alt+Shift+U），即可打开Maven依赖关系结构图</p><p><img src="https://segmentfault.com/img/remote/1460000017542413?w=2560&h=1380" alt="img"></p><p>在图中，我们可以看到有一些红色的实线，这些红色实线就是依赖冲突，蓝色实线则是正常的依赖。</p><p><img src="https://segmentfault.com/img/remote/1460000017542414" alt="img"></p><p>作者博客：<a href="https://link.segmentfault.com/?enc=qTVmQeUaGf8+IMp5uJ1ECQ==.y0CD58BzYC8aEMT+g9RDJNr63q4tUkqkNjUq0epQp78=">桔子笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-王阳明</title>
      <link href="/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/"/>
      <url>/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/</url>
      
        <content type="html"><![CDATA[<p>你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-数字化转型核心</title>
      <link href="/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/"/>
      <url>/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/</url>
      
        <content type="html"><![CDATA[<p>数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-小程序带来了什么改变</title>
      <link href="/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/"/>
      <url>/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/</url>
      
        <content type="html"><![CDATA[<p>小程序带来了什么改变？</p><p>（1）用户缩短了完成操作所需的步骤</p><p>（2）开发者更容易上手，开发难度下降</p><p>（3）新的产品形态：更垂直，更细分，更社交，更具创意</p><p>（4）用户红利：基于微信的巨大流量</p><p>什么适合做小程序</p><p>1.行业</p><p>低频刚需，这一点也已经得到公认，尤其O2O</p><p>低频非刚需：工具类适合小程序</p><p>2.产品规模</p><p>功能复杂业务多：具有大量业务，比较适合小程序，往垂直化来做，如58搬家，生活缴费等。</p><p>功能简单业务多：把核心功能迁移至小程序。</p><p>功能简单业务少：可以完全移植，相对效果不会差。</p><p>功能复杂业务少：简化体验流程。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-互联网思维～</title>
      <link href="/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/"/>
      <url>/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/</url>
      
        <content type="html"><![CDATA[<p>前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述，那么，你应该还在每天挤地铁。”</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-张子选《藏地诗篇》</title>
      <link href="/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/"/>
      <url>/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/</url>
      
        <content type="html"><![CDATA[<p>向鱼问水，向马问路</p><p>向神佛打听我一生的出处</p><p>而我呀</p><p>我是疼在谁心头的一抔尘土</p><p>一尊佛祖，两世糊涂</p><p>来世的你呀，如何把今生的我一眼认出</p><p>——张子选《藏地诗篇》</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-刻意练习</title>
      <link href="/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/"/>
      <url>/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/</url>
      
        <content type="html"><![CDATA[<p>1、有目的的练习特点</p><p>定义明确的具体目标，可以有效地用于引导你的练习</p><p>有目的的练习是专注的</p><p>有目的的练习包含反馈</p><p>有目的的练习需要走出舒适区</p><p>总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。还要想办法保持你的动机。</p><p>2、刻意练习的特点</p><p>刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能</p><p>刻意练习发生在舒适区之外，要求不断地尝试那些刚好超出他当前能力范围的事物，需要人们付出最大限度的努力。</p><p>刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进</p><p>刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动</p><p>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。</p><p>如何运用刻意练习原则</p><p>在实践中，这往往归结为带有几个额外步骤的有目的的练习：</p><p>首先辨别杰出人物</p><p>然后推测是什么使他们变得如此杰出</p><p>接着再提出训练方法，这些方法使你也能像他们那样表现卓越</p><p>在自己的工作，仔细思考杰出的表现具有哪些特点，并尝试采用一些方法来度量，即使在你度量时一定存在着某种程度的主观意识也无妨。然后，寻找你所在行业或领域中评分最高、你认为对杰出表现十分关键的人。要记住，理想的情况是找到客观的、可复制的测量指标，以便前后一致地从普通从业者之中挑选出最优异的从业者。</p><p>运用刻意练习原则的人都面临一个重大挑战，那便是：要准确地判断最杰出人物做了些什么，使得他们在普通人中间“鹤立鸡群”。 在IT互联网行业，牛人很多。大多数牛人都有着做出牛逼产品的经历，比如微信之父张小龙、小米创始人雷军。是什么促使他们做出牛逼的产品？到底是什么是他们变得如此杰出？这几个问题其实是不好找到客观的、可复制的测量指标。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-数据化：一切皆可“量化”</title>
      <link href="/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/"/>
      <url>/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/</url>
      
        <content type="html"><![CDATA[<p>数据化：一切皆可“量化”</p><p>莫里的导航图，大数据的最早实践之一</p><p>许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。</p><p>数据从最不可能的地方提取出来</p><p>大数据的核心就是挖掘出庞大的数据库独有的价值</p><p>数据化，不是数字化</p><p>数据化，这是指一种把现象转变可制表分析的量化形式的过程。</p><p>量化一切，数据化的核心</p><p>计量和记录一起促成了数据的诞生，它们是数据化最早的根基</p><p>数字化带来了数据化，但是数字化无法取代数据化</p><p>当文字成为数据</p><p>但文字变成数据，它就大显神通了——人可以用之阅读，机器也可以用之分析。</p><p>当方位变成数据</p><p>“现实挖掘”这里指的是通过处理大量来自手机的数据，发现和预测人类行为。</p><p>位置信息一被数据化，新的用途就犹如雨后春笋般涌现出来，而新价值也会随之不断催生。</p><p>当沟通变成数据</p><p>Twitter情绪数据化</p><p>社交图谱  FICO</p><p>twitter情感分析以获得顾客反馈意见的汇总或对营销获得的效果进行判断</p><p>世间万物的数据化</p><p>只要一点想象，万千事物就能转化为数据形式，并一直带给我们惊喜。</p><p>物联网只是一种典型的数据化手段</p><p>有了大数据的帮助，我们不会再将世界看作是一连串wim认为或是自然或是社会现象的时间，我们会意识到本质上世界是由信息构成的。</p><p>将世界看作信息，看作可以理解的数据还有，为我们提供了一个从未有过的审视现实的视角。它是一种可以渗透到所有生活领域的世界观。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-更多，更杂，更好</title>
      <link href="/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/"/>
      <url>/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/</url>
      
        <content type="html"><![CDATA[<p>更多：不是随机样本，而是全体数据</p><p>样本&#x3D;总体</p><p>更杂：不是精确性，而是混杂性</p><p>允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。</p><p>大数据抵消了错误数据带来的不精确：</p><p>更好：不是因果关系，而是相关关系</p><p>建立在相关关系分析法上的预测是大数据的核心，我们通过大数据分析得到的是“是什么”（相关关系），而得不出“为什么”（因果关系）的结论。</p><p>通过大数据分析，寻找事物、数据之间的关联性来分析现象，而不是揭示其内部机制。往往通过大数据得出的结论只是一个可能性预测，而不知道其背后的原因。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="java问题排查工具单"><a href="#java问题排查工具单" class="headerlink" title="java问题排查工具单"></a>java问题排查工具单</h2><p>转自 作者：红魔七号<br>链接：<a href="https://yq.aliyun.com/articles/69520?utm_content=m_10360">https://yq.aliyun.com/articles/69520?utm_content=m_10360</a></p><p><em>摘要：</em> # 我的问题排查工具箱 ## 前言 平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。 闲话不多说，开搞。 ## Linux命令类 ###tail 最常用的tail -f tail -3</p><h1 id="我的问题排查工具箱"><a href="#我的问题排查工具箱" class="headerlink" title="我的问题排查工具箱"></a>我的问题排查工具箱</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。</p><p>闲话不多说，开搞。</p><h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>1 基础命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $4,$6&#125;&#x27; f.txt</span><br><span class="line">awk &#x27;&#123;print NR,$0&#125;&#x27; f.txt cpf.txt    </span><br><span class="line">awk &#x27;&#123;print FNR,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FNR,FILENAME,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&#x27; f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: &#x27;&#123;print $1,$2,$3,$4&#125;&#x27;</span><br></pre></td></tr></table></figure><p>2 匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/ldb/ &#123;print&#125;&#x27; f.txt   #匹配ldb</span><br><span class="line">awk &#x27;!/ldb/ &#123;print&#125;&#x27; f.txt  #不匹配ldb</span><br><span class="line">awk &#x27;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&#x27; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#x27;$5 ~ /ldb/ &#123;print&#125;&#x27; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find /usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure><h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgm -A -f vm-shopbase &#x27;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#x27;</span><br></pre></td></tr></table></figure><h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar  ##可以查看最近一天的各项指标</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc25b8f22e53818d5576c5d00dd52618.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar --live ##可以查看实时指标，默认五秒一刷</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b68910c5416fd85a99a49a092fc9ffbb.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aafdbfb515b817a2aceb270d1d470c19.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tsar --mem</span><br><span class="line">tsar --load</span><br><span class="line">tsar --cpu</span><br><span class="line">##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/cb46ef4e374e1502d3b672d04d48099a.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/079f3fa722bfa1991557469eb97c7273.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6dd77351ad4d1ad84cdbfba20c9d4c29.png" alt="screenshot.png"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|awk  &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">#查看当前连接，注意close_wait偏高的情况，比如如下</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/250a027410775cf5990d0db6e87ba927.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/639811da529750064e2f70867d6234e0.png" alt="screenshot.png"></p><h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ol><li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</p><p>@OnMethod(clazz &#x3D; “java.util.ArrayList”, method&#x3D;”add”, location &#x3D; @Location(value &#x3D; Kind.CALL, clazz &#x3D; “&#x2F;.<em>&#x2F;“, method &#x3D; “&#x2F;.</em>&#x2F;“))<br>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123;</span><br><span class="line">    println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod  + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance));</span><br><span class="line">    jstack();</span><br><span class="line">    println();</span><br><span class="line">    println(&quot;===========================&quot;);</span><br><span class="line">    println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><p>监控当前服务方法被调用时返回的值以及请求的参数</p><p>@OnMethod(clazz &#x3D; “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method&#x3D;”nav”, location &#x3D; @Location(value &#x3D; Kind.RETURN))<br>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result);</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。<br><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></p><p>注意:</p><ol><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ol><h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p><p><code>trace class method</code>: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:<a href="http://www.atatech.org/articles/52947">http://www.atatech.org/articles/52947</a>。</p><p>其他功能部分和btrace重合，可以选用，感兴趣的请移步。<br><a href="http://www.atatech.org/articles/26247">http://www.atatech.org/articles/26247</a></p><p>另外相关联的是arthas，他是基于Greys的，感兴趣的再移步<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc">http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc</a></p><h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>可以看看我之前写的一篇javOSize的简介<a href="http://www.atatech.org/articles/38546">http://www.atatech.org/articles/38546</a><br>官网请移步<a href="http://www.javosize.com/">http://www.javosize.com/</a></p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<br>官网请移步<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<br>详情请移步<a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p><h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛<br>详情请移步<a href="http://zprofiler.alibaba-inc.com/">zprofiler.alibaba-inc.com</a></p><h2 id="java三板斧，噢不对，是七把"><a href="#java三板斧，噢不对，是七把" class="headerlink" title="java三板斧，噢不对，是七把"></a>java三板斧，噢不对，是七把</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>我只用一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/jps -mlvV</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b156cb53250bf5f91811900c2575a91.png" alt="screenshot.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>普通用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc501bf424b3d2884e6ec118d14554a3.png" alt="screenshot.png"></p><p>native+java栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4c59dc2971f3d8778e1898d64266266a.png" alt="screenshot.png"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc879145e2994e9a09327407ed88382c.png" alt="screenshot.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p><p>1.查看堆的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/00d9eaef08cdb51263d202d26795036b.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3c08bccf81fef8b7bcae2b321012b503.png" alt="screenshot.png"></p><p>2.dump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</span><br></pre></td></tr></table></figure><p>3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/500ec6709fcd03a4fca2679615d54522.png" alt="screenshot.png"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/05743916a9187535c202fb410d30d50d.png" alt="screenshot.png"></p><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是&#x2F;opt&#x2F;taobao&#x2F;java&#x2F;，远程调试端口是8000.那么<br><code>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000</code>.</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/16332fcd45b20137bffc7a3b9a88b0f1.png" alt="screenshot.png"></p><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<br>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html</a></p><h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</span><br></pre></td></tr></table></figure><p>更详细的可见R大此贴<br><a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/356c11885a95e28736a605aecdc8083e.png" alt="screenshot.png"></p><h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p><h2 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h2><ol><li><p>你的类到底是从哪个文件加载进来的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br><span class="line">结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar]</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>应用挂了输出dump文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof</span><br><span class="line">集团的vm参数里边基本都有这个选项</span><br></pre></td></tr></table></figure></li></ol><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p><h3 id="mvn-dependency-tree-gt-x2F-dependency-txt"><a href="#mvn-dependency-tree-gt-x2F-dependency-txt" class="headerlink" title="mvn dependency:tree &gt; ~&#x2F;dependency.txt"></a>mvn dependency:tree &gt; ~&#x2F;dependency.txt</h3><p>打出所有依赖</p><h3 id="mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId"><a href="#mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId" class="headerlink" title="mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId"></a>mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId</h3><p>只打出指定groupId和artifactId的依赖关系</p><h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="greys-sc"><a href="#greys-sc" class="headerlink" title="greys:sc"></a>greys:sc</h3><p>greys的sc命令也能清晰的看到当前类是从哪里加载过来的</p><h3 id="tomcat-classloader-locate"><a href="#tomcat-classloader-locate" class="headerlink" title="tomcat-classloader-locate"></a>tomcat-classloader-locate</h3><p>通过以下url可以获知当前类是从哪里加载的<br>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a></p><h2 id="ALI-TOMCAT带给我们的惊喜-感谢-务观"><a href="#ALI-TOMCAT带给我们的惊喜-感谢-务观" class="headerlink" title="ALI-TOMCAT带给我们的惊喜(感谢@务观)"></a>ALI-TOMCAT带给我们的惊喜(感谢@务观)</h2><ol><li><p>列出容器加载的jar列表</p><p>curl <a href="http://localhost:8006/classloader/jars">http://localhost:8006/classloader/jars</a></p></li><li><p>列出当前当当前类加载的实际jar包位置，解决类冲突时有用</p><p>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4568b16d3db0daf98e852412b830f1a8.png" alt="screenshot.png"></p></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h3><p><a href="http://www.atatech.org/articles/33317">http://www.atatech.org/articles/33317</a></p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg|grep -i kill|less</span><br></pre></td></tr></table></figure><p>去找关键字oom_killer。找到的结果类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0</span><br><span class="line">[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 </span><br><span class="line">[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 </span><br><span class="line">[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span><br><span class="line">[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span><br></pre></td></tr></table></figure><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式:<br>log实际时间&#x3D;格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1970-01-01 UTC `echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&#x27; &#x27;)+12288812.926194&quot;|bc ` seconds&quot;</span><br></pre></td></tr></table></figure><p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步<a href="http://ifeve.com/guava-ratelimiter/">http://ifeve.com/guava-ratelimiter/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-运营该如何被定义和理解</title>
      <link href="/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/"/>
      <url>/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/</url>
      
        <content type="html"><![CDATA[<p>运营该如何被定义和理解<br>1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段</p><p>2.运营工作的流程：<br>1）制定策略：根据不同的产品形态及数据变化制定不用的策略</p><p>2）分解指标，规划工作：对目标进行拆解，向内向外的资源争取及分配，制定具体的工作计划</p><p>3）执行落地，达成目标：通过文案、活动、用户维系等具体运营手段来达成我们的目标</p><p>4）监测数据、调整方向：收集、分析数据及用户反馈，评估运营工作调整新的运营策略</p><p>3.运营的四个关键性思维</p><p>1.流程化思维：一个优秀的运营和一个普通人之间存在的一个核心差别，就是优秀的运营拿到一个问题后，会回归流程，先把整个问题流程梳理出来，然后再从流程中去寻找潜在的解决方案。“先有流程，再有解决方案”这一点，不止对运营，对于产品来说也是一样的。</p><p>2.精细化思维：运营做久了会发现，优秀的运营，很多时候是通过大量的细节和琐碎事务堆积出来一个神奇的产品。这就需要运营具备很强的精细化思维和精细化管理，必须要能够把自己关注的一个问题拆解为无数细小的执行细节，并且能够做到对于所有细节的掌控力。</p><p>3.杠杆思维：好的运营是有层次感的，需要先做好一件事情，再以这件事为一个核心杠杆，去撬动更多的事情和成果发生，比如先服务好一批种子用户，给他们制造大量的超出他们预期的体验，以此为杠杆，撬动他们帮我们宣传。</p><p>4.生态化思维：所谓生态，其实就是一个所有角色在其中都可以互为价值、和谐共存、共同驱动器发展和生存的一个大环境，比如一个好几百人的微信群，一个社区。而能否成功搭建起来生态，最重要的，就是你能够梳理清楚并理解一个生态间的各种价值关系。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/"/>
      <url>/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/</url>
      
        <content type="html"><![CDATA[<p>来源：王韵菲 </p><p><a href="http://www.evget.com/article/2015/11/16/22990.html">www.evget.com/article/2015/11/16/22990.html</a></p><p>本文中，小编搜集了7个最有影响的衡量标注，让你可以不依赖日志文件来了解应用程序。现在，让我们看看这些性能指标，并了解如何查看并收集它们：</p><p><strong>1.响应时间和吞吐量</strong></p><p>根据应用程序的响应时间可以知道程序完成传输数据所用的时间。也可以从HTTP请求级别，或者成为数据库级别来看。对那些缓慢的查询你需要做一些优化来缩短时间。吞吐量是另一个角度衡量传输数据的指标，是指单位时间内系统处理的客户请求的数量。</p><p>我们可以使用APMs（例如New Relic或AppDynamics）来衡量这些指标。使用这些工具，你可以在主报告仪表板中将平均响应时间与昨天的甚至上周的直接进行对比。这有助于我们观察新的部署是否会影响到我们的应用程序。你可以看到网络传输的百分比，测量HTTP完成请求需要多长时间。</p><p>推荐工具：</p><ul><li>AppDynamics</li><li>New Relic</li><li>Ruxit</li></ul><p>New Relic报告：Web传输百分比和吞吐量</p><p><strong>2.平均负载</strong></p><p>第二个应用广泛的指标是平均负载。我们习惯上会把平均负载分为这三步测量，分别是第5分钟、第15分钟和最后1分钟。要保证数量低于机器的内核数。一旦超过内核数，机器就会运行在压力状态下。</p><p>除了简单测量CPU使用率，还需要关注每个内核的队列中有多少进程。在内核使用率都是100%的情况下，队列中只有1个任务和有6个任务有很大不同。因此，平均负载不能只考虑CPU使用率。</p><p>推荐工具：</p><ul><li>htop</li></ul><p><strong>3.错误率</strong></p><p>大多数开发人员判断错误率是根据HTTP传输总失败百分比。但是他们忽略了一个更深层的东西：特定传输的错误率。这直接影响到您应用程序的运行状况。这可以显示出代码方法的错误以及错误或异常出现的次数。</p><p>但单纯的错误率数据对我们没有多大帮助。最重要的是我们要找到它们的根源并解决问题。随着Takipi的运行，我们要在日志文件中需找线索。你可以找到所有关于服务器状态的信息，包括堆栈跟踪、源代码和变量值。</p><p>推荐工具：</p><ul><li>Takipi</li></ul><p><strong>4.GC率和暂停时间</strong></p><p>异常行为垃圾收集器应用程序的吞吐量和响应时间采取深潜的主要原因之一。了解GC暂停频率和持续时间的关键是分析GC日志文件。要分析它们，你需要收集GC日志和JVM参数。你要注意观察不同指标之间的数据是如何相互影响的。</p><p>推荐工具：</p><ul><li>jClarity Censum</li><li>GCViewer</li></ul><p><strong>5.业务指标</strong></p><p>应用程序的性能不完全取决于响应时间和错误率。业务指标也是一方面，例如收益、用户数。</p><p>推荐工具：</p><ul><li>Grafana</li><li>The ELK stack</li><li>Datadog</li><li>Librato</li></ul><p><strong>6.正常运行时间和服务运行状态</strong></p><p>这一指标奠定了整个应用程序性能的基础。不仅可以当做一个提醒指标，也可以让你定义一段时间内的SKA。我们可以使用Pingdom的servlet功能进行运行状态检查。我们可以查到应用程序的所有传输，包括数据库和S3。</p><p>推荐工具：</p><ul><li>Pingdom</li></ul><p><strong>7.日志大小</strong></p><p>日志有一个缺点，它是一直在增加的。当您的服务器启动塞满了垃圾，一切都慢下来。因此，我们需要密切的关注日志大小。</p><p>目前通常的解决办法是使用logstash划分使用日志，并将它们发送并存储在Splunk、ELK或其他的日志管理工具中。</p><p>推荐工具：</p><ul><li>Splunk</li><li>Sumo Logic</li><li>Loggly</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一部震撼人心的电影——《人类》</title>
      <link href="/2018/11/04/%E6%9D%82%E8%AE%B0/%E4%B8%80%E9%83%A8%E9%9C%87%E6%92%BC%E4%BA%BA%E5%BF%83%E7%9A%84%E7%94%B5%E5%BD%B1%E2%80%94%E2%80%94%E3%80%8A%E4%BA%BA%E7%B1%BB%E3%80%8B/"/>
      <url>/2018/11/04/%E6%9D%82%E8%AE%B0/%E4%B8%80%E9%83%A8%E9%9C%87%E6%92%BC%E4%BA%BA%E5%BF%83%E7%9A%84%E7%94%B5%E5%BD%B1%E2%80%94%E2%80%94%E3%80%8A%E4%BA%BA%E7%B1%BB%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>法国著名纪录片导演 Yann Arthus-Bertrand，让2000个人坐在镜头前，讲出他们自己一生中最隐秘的故事，并以此拍摄了一部震撼人心的电影——《人类》！</strong></p><p>这是一部筹备15年，跨越50多个国家，动用88000名员工，21个月拍摄完成，已被翻译成14种语言，中文由周迅配音的，非常美、非常棒的记录片。</p><p>周迅说：“这是一部震撼人心的纪录片，我在配音的过程里哭了好几次。第一次看完这个纪录片，我就觉得一定要为这个电影做些什么</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/741a45be93a3442fa2e84e930c881347.jpeg" alt="img"></p><p>△美国黄石公园大棱镜温泉</p><p>你可曾见过视觉如此唯美震撼的地球？</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/6df1e31f060e4672935bc408c3ff768a.jpeg" alt="img"></p><p>澳大利亚大堡礁</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/6ce853d1b698472f8e008af4c9126070.jpeg" alt="img"></p><p>地球，是宇宙的奇迹，生命的摇篮，人类共同的家园。她给人类提供生存的空间和资源，使人类在这里生息繁衍。</p><p><strong>史上投资最大的环保纪录片——</strong></p><p>这是一部筹备15年，跨越50多个国家，动用88000名员工，21个月拍摄完成，已被翻译成14种语言，中文由周迅配音的，非常美、非常棒的记录片。</p><p>周迅说：“这是一部震撼人心的纪录片，我在配音的过程里哭了好几次。第一次看完这个纪录片，我就觉得一定要为这个电影做些什么，一定要让这个纪录片被更多的人看到。”</p><p>《Home》的导演，是著名法国摄影师、生态学家、环境保护者Yann Arthus-Bertrand (扬·阿尔蒂斯-贝特朗)，Yann Arthus-Bertrand专门从事空中摄影已超过30年，极具声望。</p><p>他的空中摄影作品集《Earth from Above（鸟瞰地球）》被翻译成24种语言，销售量超过3百万册；同名的免费摄影展在全球110个城市展出，观众达1.2亿人次。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/55f1beedf0c24110aed6eeba32c1ae5e.jpeg" alt="img"></p><p>而《Home》，便是Yann Arthus-Bertrand 30年空中摄影和环保工作的一次动态精华荟萃。法国著名导演吕克·贝松 ( Luc Besson, 《这个杀手不太冷》、《第五元素》导演) 则担任《Home》的制片。</p><p>贝特朗和他的团队耗费了一年半时间，遍历整个地球，才得以完成此片。来自五十多个国家的影像给人类带来了这样一个信息：</p><p>我们应当认识到人类对地球的残酷掠夺，应当改变我们的消费模式。</p><p>演员周迅为了将本片引进中国颇费周折，她为该片的中文版进行了旁白配音。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/a04fbd8fb2534cb4a24674e791910c65.jpeg" alt="img"></p><blockquote><p><strong>拍摄幕后</strong></p></blockquote><p>经过四十亿年的漫长演变，地球变成一个物种繁多、资源丰富、奇特美丽的蓝色星球。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/0da717f8fda543cabe0a9226e63f8b03.jpeg" alt="img"></p><p>然而自人类出现以来，我们只用了二十万年的时间，便将地球的宝贵资源消耗殆尽。珍稀物种灭绝，原始资源奇缺，污染日益严重，人类以及地球的明天将何去何从？</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/743f77a3d78b415c92236a2e3b0727b5.jpeg" alt="img"></p><p>被蚕食的森林</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/a20d2d3eff8547b399c452927f3ec87a.jpeg" alt="img"></p><p>印度拉贾斯坦等候取水的人群</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/5331db0a26c64fcbab5e629bf6cc5445.jpeg" alt="img"></p><p>融化的冰川</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/4ba67a4366c449b28f2c9c08a38bff23.jpeg" alt="img"></p><p>本片素材长达488小时，拍摄周期为21个月，共动用88,000名员工，拍摄范围从澳洲海底的大堡礁到非洲肯亚高原的乞力马扎罗山；从亚玛逊热带雨林到戈壁沙漠；从美国德萨斯州连绵不断的棉花田到中国上海、深圳的工业城镇。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/526096197ae74170851c5a8fc5aece01.jpeg" alt="img"></p><p>影片以上帝的俯瞰视角向世人展现地球的绝美以及日趋危急的现状。</p><p>明天并不遥远，但我们该选择怎样的未来？</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/1a43fbdd3ad54cc2ad7e0496491295b5.jpeg" alt="img"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/fd8ff40732af4f1ea3b827f5a84e518a.jpeg" alt="img"></p><p>为了展示各地广阔的风光，《家园》采用了各种不同拍摄方式，导演扬·阿尔蒂斯-贝特朗跟一名摄像师、一位摄影技师和一位飞行员驾驶一架小型直升机飞跃了世界上55个国家，历时18个月。</p><p>拍摄过程中使用了”Cineflex”高清摄像机，这种摄像机原本是一种军事器械，能够有效减轻振动从而获得高清画面。</p><p>在一天内，《家园》在181个国家发行，打破了历史上电影发行量最大的世界纪录。</p><p>在YouTube上发布后，《家园》在头24小时里即获得了400,000的点击率，在世界各地的电视台也收到了很高的收视率。在法国电视2台首映时，仅在法国就有超过八百万的观众收看。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/db35dfb1e7044c79aee8a56464ad63f6.jpeg" alt="img"></p><p>扬·阿尔蒂斯-贝特朗的航空影像，既是对地球直观真实的再现，又美得令人吃惊；粗看恢弘大气，仔细观察又会注意到被清楚展现的细节，画面极具震撼力。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/f2ab7a6a66894837a52cc1282cf405e0.jpeg" alt="img"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/9f88d76026054466ba40b138297bbecb.jpeg" alt="img"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/6b7e9514cc3942f2b980c916f546a22a.jpeg" alt="img"></p><p>让影片增色不少的电影配乐，是由法国著名作曲家Armand Amar创作，并由布达佩斯交响乐团和上海音乐学院打击乐团演绎。</p><p>影片音乐中融汇了蒙古、亚美尼亚、伊朗等国的吟唱和器乐，使影片犹如冥想般舒缓又带着淡淡的哀伤，以另一种方式，传达了对地球家园现状的不安及深切怜爱之情。</p><blockquote><p><strong>地球故事</strong></p></blockquote><p>我们居住的这个蓝色星球，已经存在了45亿年，她孕育出来的万千物种长期一直相互依存。但只有20万年历史的人类，却快速掌控了这个星球并为所欲为，过度索取资源，打破了亿万年来的固有生态平衡。</p><p>在《Home》里面，我们了解到——</p><p>为了满足日益增长的食物需要，全球一半的谷物用于饲养提供肉类的牲口，生产1公斤牛肉就需要消耗1万3千升的水；</p><p>为了生产纸浆而砍伐原始森林大量种植桉树，生物的多样性被人为破坏，快速生长的桉树，抽干了地下的水分，快速消耗地球的资源。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/cb88cb7690d34b26aee49713732df880.jpeg" alt="img"></p><p>过去50年，人类对地球的改变，比前面20万年还要多，令这个美丽的蓝星球千疮百孔：大河断流，资源枯竭；冰川冰冠快速减少，气温上升，气候反常；森林消失，物种灭绝……</p><p>影片中，还列举纽约、拉斯维加斯、洛杉矶、深圳、孟买、东京和迪拜等城市，能源、水及食物被大量消耗的例子。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/3343c6cbe2a34acb85e7f310be8020af.jpeg" alt="img"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/a0a74e78325b48c199d52045a8ffc031.jpeg" alt="img"></p><p>整个纪录片表达了“相互联系”的主题：所有生物以及地球互相处于一个“微妙却至关重要”的自然平衡，任何生物都无法自给自足。</p><p>这是一些资料，可以供我们来了解我们的星球：</p><p>20％的世界人口消耗了80％的地球资源</p><p>全球军费开支多于援助发展中国家经费的12倍</p><p>每天有5千人死于受污染的食水，10亿人没有干净的饮用水</p><p>10亿人在饱受饥饿</p><p>全球超过50％销售的谷物用于喂食牲口与生化燃料上</p><p>全球40％耕地质量下降</p><p>每年有1300万公顷的林地给毁灭</p><p>1&#x2F;4的哺乳动物、1&#x2F;8的鸟类、1&#x2F;3的两栖动物濒临绝种，生物品种的死亡率快于自然速度1000倍</p><p>75％的渔产品已耗尽或面临耗尽</p><p>过去15年的平均温度是有纪录以来的最高</p><p>冰冠的厚度40年来减少了40％</p><p>到2050年，可能导致多达2亿的气候难民</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190412/236c4ae1a0b140498e6eb50144e658ed.jpeg" alt="img"></p><p>正如《Home》影片最后所传达的信息：</p><p>“现在已不再是悲观的时候，让我们立即联手，重要的不是我们失去了什么，而是我们剩下的还有什么。”</p><p>是继续破坏直至毁灭还是行动起来拯救我们唯一的家园？</p><p>答案就在你的一念之间！</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-任何商业模式都来源于用户需求</title>
      <link href="/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/"/>
      <url>/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/</url>
      
        <content type="html"><![CDATA[<p>任何商业模式都来源于用户需求～</p><p>用户需求特点:更快，更多，更便宜，更好玩<br>需求处理:发现，分析，描述<br>产品设计步骤:<br>产品决策:需求是否全面，流程是否打的通，是否战略一致。<br>产品功能设计:基本功能，核心功能<br>用户体验原则:不要强迫用户，不要让用户思考，用户易操作，不破坏用户原则，超出用户预期。</p><p>网络运营<br>网络运营模型:来源量，转化率，活跃度，留存率<br>周期:种子期，爆发期，平台期<br>网络推广:用户互导，资源互换，购买流量</p><p>网络运营总结：<br>1 种子期是产品最难的阶段，留存率是关键，不在乎来多少人，而在乎有多少人留下来。种子期成功，产品成功一半。<br>2 爆发期是产品成功的标志，来源量是关键，产品形成口碑影响力，能成功的产品一定有爆发期。<br>3 平台期是用户爆发增长后有意控制产品节奏的时期，活跃度是关键，重点做好系统稳定和产品用户体验。<br>4 爆发期和平台期交替出现，产品才能不断稳定增长。</p><p>互联网商业模式:<br>循环:做好的产品，吸引用户，产生收入<br>形成比由之路:创造好产品 ，获取海量用户，引导用户消费。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-企业文化三要素</title>
      <link href="/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/"/>
      <url>/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/</url>
      
        <content type="html"><![CDATA[<p>企业文化三要素：</p><p>赋予员工使命：激发员工主人翁意识，从全人类层面考虑问题，打造使命的不可逾越性；</p><p>保障公司透明度：信息共享，给予员工充分信任，会议形成记录，达到有效沟通</p><p>保障员工发声权利：高层权力下放，员工拥有话语权，培养员工独立思考</p><p>谷歌如何招聘人才：</p><p>人才原则：慢工招人才，只招聘比自己优秀的人才</p><p>招聘流程：谷歌求职者调查测试，下属面试，横向面试</p><p>评估工具：采用qDroid, 多人多角度多流程评估面试者</p><p>如何重新定义团队：</p><p>打造“小而美”团队，消除内部地位象征，依据数据做决策，自我职业规划，关注优劣两极员工，保持高期待和高收益；</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly 的未来：将逐渐解锁整个“技能树”</title>
      <link href="/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/"/>
      <url>/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly-的未来：将逐渐解锁整个“技能树”"><a href="#WebAssembly-的未来：将逐渐解锁整个“技能树”" class="headerlink" title="WebAssembly 的未来：将逐渐解锁整个“技能树”"></a>WebAssembly 的未来：将逐渐解锁整个“技能树”</h1><ul><li><a href="https://www.oschina.net/news/101159/the-future-of-webassembly">原文</a></li></ul><p>WebAssembly 在2017年受到主流浏览器的支持，并发布了被 MVP 版本（Minimum Viable Product，最简可行产品）。虽然 WebAssembly 社区组致力于使 WebAssembly 向后相容，让现在开发的 WebAssembly 应用程式，仍可以在未来的浏览器中运作，但这并不代表 WebAssembly 功能已经完整，MVP 绝非最终版本。相反，WebAssembly 还将增加许多新功能，而这些新功能将从根本上颠覆 WebAssembly 所能实现的工作。</p><p>为消除人们对 WebAssembly 的误解，WebAssembly 社区组以 RPG 游戏中人物养成的“技能树”形式，对 <a href="https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/">WebAssembly 的未来发展路径</a>做了非常详细的解释。他们表示目前已经完全掌握这些技能中的前几项，后续需要慢慢解锁整个技能树。</p><p><img src="https://oscimg.oschina.net/oscnet/42ccc510cfd9d1d2670037cba32f3007d47.jpg" alt="img"></p><p>WebAssembly 在 MVP 版本阶段满足 4 个基本技能要求：编译、快速执行、压缩和线性内存分配。使用 WebAssembly 的人知道他们不想只支持 C 和 C ++，而是希望能够将许多不同的语言编译为 WebAssembly 。经 WebAssembly 编译器编译的应用需要能够快速执行，满足需求。而为了加速载入速度，WebAssembly 还需具备压缩能力，减少使用者的等待时间。另外，WebAssembly 需要有别于 JavaScript 使用内存方式，能够直接管理使用的内存，在加上安全因素的考量，WebAssembly 采用线性内存模式。</p><p><img src="https://oscimg.oschina.net/oscnet/48a0162ed0e0f848088cecfa4c9c0d6b5b4.jpg" alt="img"></p><p>社区组表示，WebAssembly 的下一个目标是平滑运行那些更重的应用程序，比如 Photoshop、Gmail 等。为确保此类应用能在浏览器中运行良好，他们需要解锁新一批的“技能”，包括支持多线程、SIMD（单指令流多数据流）、64位寻址、流式编译（在下载的同时编译 WebAssembly 文件）、分层编译器、隐式 HTTP 缓存以及一些其他改进。</p><p><img src="https://oscimg.oschina.net/oscnet/586022e01ab45f31b0d35d223ea932a8827.jpg" alt="img"></p><p>一旦以上功能全部就位，WebAssembly 又将进入下一个阶段 —— 与 JavaScript 互操作，包括 JS 和 WebAssembly 之间的快速调用、简便的数据交换、ES模块集成、工具链集成和向后兼容性。</p><p><img src="https://oscimg.oschina.net/oscnet/5d163b3cfd5ecd82788682365c270636ebe.jpg" alt="img"></p><p>此外，他们还想在 WebAssembly 中重写 JavaScript 框架的大部分内容，并使静态类型的 compile-to-js 语言可编译为 WebAssembly 。想要实现这两个目标，WebAssembly 还需要支持高阶的语言功能，包括垃圾回收、异常处理、调试以及尾调用（Tail calls）。</p><p><img src="https://oscimg.oschina.net/oscnet/c84da0e9a6a4992b6a2219bc3b6f65dc950.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码优化总结</title>
      <link href="/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/"/>
      <url>/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/</url>
      
        <content type="html"><![CDATA[<p><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率</p><p>本文的内容有些来自网络，有些来自平时工作和学习，当然这不重要，重要的是这些代码优化的细节是否真真正正地有用。那本文会保持长期更新，只要有遇到值得分享的代码优化细节，就会不定时地更新此文。</p><p><strong>代码优化细节</strong></p><p><strong>1、尽量指定类、方法的final修饰符</strong></p><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><p><strong>2、尽量重用对象</strong></p><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>3、尽可能使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><p><strong>4、及时关闭流</strong></p><p>Java编程过程中，进行数据库连接、I&#x2F;O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><p><strong>5、尽量减少对变量的重复计算</strong></p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><blockquote><p>for (int i &#x3D; 0; i &lt; list.size(); i++)</p><p>{…}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>for (int i &#x3D; 0, int length &#x3D; list.size(); i &lt; length; i++)</p><p>{…}</p></blockquote><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><p><strong>6、尽量采用懒加载的策略，即在需要的时候才创建</strong></p><p><strong>例如：</strong></p><blockquote><p>String str &#x3D; “aaa”;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　String str &#x3D; “aaa”;</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>7、慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p><p>根据网友们提出的意见，这一点我认为值得商榷</p><p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、</p><p><strong>HashSet等等，以StringBuilder为例：</strong></p><p>（1）StringBuilder()　　　　　　&#x2F;&#x2F; 默认分配16个字符的空间</p><p>（2）StringBuilder(int size)　　&#x2F;&#x2F; 默认分配size个字符的空间</p><p>（3）StringBuilder(String str)　&#x2F;&#x2F; 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><p><strong>10、当复制大量数据时，使用System.arraycopy()命令</strong></p><p><strong>11、乘法和除法使用移位操作</strong></p><p><strong>例如：</strong></p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val * 8;</p><p>　　b &#x3D; val &#x2F; 2;</p><p>}</p></blockquote><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： </p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val &lt;&lt; 3;</p><p>　　b &#x3D; val &gt;&gt; 1;</p><p>}</p></blockquote><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p><strong>12、循环内不要不断创建对象引用</strong></p><p><strong>例如：</strong></p><blockquote><p>for (int i &#x3D; 1; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    Object obj &#x3D; new Object();    </p><p>}</p></blockquote><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><blockquote><p>Object obj &#x3D; null;</p><p>for (int i &#x3D; 0; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    obj &#x3D; new Object();</p><p>}</p></blockquote><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><p><strong>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p><p><strong>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p><p><strong>15、不要将数组声明为public static final</strong></p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><p><strong>16、尽量在合适的场合使用单例</strong></p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><p><strong>17、尽量避免随意使用静态变量</strong></p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><blockquote><p>public class A</p><p>{</p><p>​    private static B b &#x3D; new B();  </p><p>}</p></blockquote><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><p><strong>18、及时清除不再需要的会话</strong></p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><p><strong>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><blockquote><p>if (list instanceof RandomAccess)</p><p>{</p><p>​    for (int i &#x3D; 0; i &lt; list.size(); i++){}</p><p>}</p><p>else</p><p>{</p><p>​    Iterator&lt;?&gt; iterator &#x3D; list.iterable();</p><p>​    while (iterator.hasNext()){iterator.next()}</p><p>}</p></blockquote><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><strong>20、使用同步代码块替代同步方法</strong></p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><strong>21、将常量声明为static final，并以大写命名</strong></p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><p><strong>22、不要创建一些不使用的对象，不要导入一些不使用的类</strong></p><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><p><strong>23、程序运行过程中避免使用反射</strong></p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><strong>24、使用数据库连接池和线程池</strong></p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><p><strong>25、使用带缓冲的输入输出流进行IO操作</strong></p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><p><strong>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</strong></p><p>这个，理解ArrayList和LinkedList的原理就知道了</p><p><strong>27、不要让public方法中有太多的形参</strong></p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><p><strong>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><blockquote><p>String str &#x3D; “123”;</p><p>if (str.equals(“123”))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>String str &#x3D; “123”;</p><p>if (“123”.equals(str))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这么做主要是可以避免空指针异常</p><p><strong>29、请知道，在java中if (i &#x3D;&#x3D; 1)和if (1 &#x3D;&#x3D; i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p><p>平时有人问，”if (i &#x3D;&#x3D; 1)”和”if (1&#x3D;&#x3D; i)”有没有区别，这就要从C&#x2F;C++讲起。</p><p>在C&#x2F;C++中，”if (i &#x3D;&#x3D; 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>C&#x2F;C++判断”i&#x3D;&#x3D;1”不成立，所以以0表示，即false。但是如果：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>万一程序员一个不小心，把”if (i &#x3D;&#x3D; 1)”写成”if (i &#x3D; 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C&#x2F;C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><blockquote><p>int i &#x3D; 2;</p><p>if (1 &#x3D;&#x3D; i)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这样，即使开发者不小心写成了”1 &#x3D; i”，C&#x2F;C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C&#x2F;C++这种”if (i &#x3D; 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i &#x3D;&#x3D; 1)”和”if (1 &#x3D;&#x3D; i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><p><strong>30、不要对数组使用toString()方法</strong></p><p><strong>看一下对数组使用toString()打印出来的是什么：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int[] is &#x3D; new int[]{1, 2, 3};</p><p>​    System.out.println(is.toString());</p><p>}</p></blockquote><p><strong>结果是：</strong></p><blockquote><p>[I@18a992f</p></blockquote><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<E>重写了Object的toString()方法。</p><p><strong>32、不要对超出范围的基本数据类型做向下强制转型</strong></p><p><strong>这绝不会得到想要的结果：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    long l &#x3D; 12345678901234L;</p><p>​    int i &#x3D; (int)l;</p><p>​    System.out.println(i);</p><p>}</p></blockquote><p><strong>我们可能期望得到其中的某几位，但是结果却是：</strong></p><blockquote><p><strong>1942892530</strong></p></blockquote><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l &#x3D; 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f &#x3D; 3.5f”</p><p>2、接下来再写一句”int ii &#x3D; l + i;”会报错，因为long + int是一个long，不能赋值给int</p><p><strong>33、公用的集合类中不使用的数据一定要及时remove掉</strong></p><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><p><strong>34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</strong></p><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int loopTime &#x3D; 50000;</p><p>​    Integer i &#x3D; 0;</p><p>​    long startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; String.valueOf(i);</p><p>​    }    </p><p>​    System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i.toString();</p><p>​    }    </p><p>​    System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i + “”;</p><p>​    }    </p><p>​    System.out.println(“i + “”：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>}</p></blockquote><p><strong>运行结果为：</strong></p><blockquote><p>String.valueOf()：11ms</p><p>Integer.toString()：5ms</p><p>i + “”：25ms</p></blockquote><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><p><strong>35、使用最有效率的方式去遍历Map</strong></p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    HashMap&lt;String, String&gt; hm &#x3D; new HashMap&lt;String, String&gt;();</p><p>​    hm.put(“111”, “222”);</p><p>​        </p><p>​    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet &#x3D; hm.entrySet();</p><p>​    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter &#x3D; entrySet.iterator();</p><p>​    while (iter.hasNext())</p><p>​    {</p><p>​        Map.Entry&lt;String, String&gt; entry &#x3D; iter.next();</p><p>​        System.out.println(entry.getKey() + “” + entry.getValue());</p><p>​    }</p><p>}</p></blockquote><p>如果你只是想遍历一下这个Map的key值，那用”Set<String> keySet &#x3D; hm.keySet();”会比较合适一些</p><p><strong>36、对资源的close()建议分开操作</strong></p><blockquote><p>意思是，比如我有这么一段代码：</p><p>try</p><p>{</p><p>​    XXX.close();</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>try</p><p>{</p><p>​    XXX.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p><p>try</p><p>{</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉</p><p><strong>后记</strong></p><p>优秀的代码来自每一点点小小的优化，关注每一个细节，不仅仅能提升程序运行效率，同样可以规避许多未知的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记-新零售的本质</title>
      <link href="/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/"/>
      <url>/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/</url>
      
        <content type="html"><![CDATA[<p>零售的本质是把人和货连接在一起的场；新零售是一场效率革命。</p><p>1.新零售，是效率更高的零售</p><p>①场的效率</p><p>信息流；资金流；物流。</p><p>②人的效率</p><p>流量革命；转化率；客单价；复购率。</p><p>销售漏斗公式：销售额&#x3D;流量×转化率×客单价×复购率</p><p>该公式可以用来衡量销售额，却无法衡量销售的效率。</p><p>③货的效率</p><p>定倍率：商业世界最基础的逻辑之一，是衡量商业效率的重要指标。定倍率越低，效率越高。</p><p>未来，中国制造的趋势是：</p><p>低质高价和低质低价的商品，存活空间会越来越小，甚至被逐步淘汰；</p><p>高质低价的零售业，将迎来它的时代，而C2M（Customer-to- Manufactory，客对厂）模式是实现高质低价的一个有效手段。</p><p>2.新的商业思维</p><p>① 进化思维</p><p>② 本质思维</p><p>③ 系统思维</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-智识链</title>
      <link href="/2018/08/30/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00830/"/>
      <url>/2018/08/30/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00830/</url>
      
        <content type="html"><![CDATA[<p>食物链排名对个人相当不可控，但是还有另外一条链可以追求，我们不妨称之为 “智识链”。<br>智识，就是智慧和见识，智识不是一种资源。资源可以赠送，可以继承，可以一出生就有，智识不能。<br>资源可以出售变现，智识不能直接转换成钱。<br>智识是“三观”—对世界正确的认识，对人生合理的安排，知道什么东西是好东西；<br>智识还是历史的经验和做事的手段。</p><p>be part of something bigger than yourself</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP定理的含义</title>
      <link href="/2018/08/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2018/08/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E5%AE%9A%E7%90%86%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CAP-定理的含义"><a href="#CAP-定理的含义" class="headerlink" title="CAP 定理的含义"></a>CAP 定理的含义</h1><p>转自阮一峰老师的博客 </p><p><a href="http://www.ruanyifeng.com/home.html">阮一峰</a></p><p>分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。</p><p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p><p>本文介绍该定理。它其实很好懂，而且是显而易见的。下面的内容主要参考了 Michael Whittaker 的<a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/">文章</a>。</p><h2 id="一、分布式系统的三个指标"><a href="#一、分布式系统的三个指标" class="headerlink" title="一、分布式系统的三个指标"></a>一、分布式系统的三个指标</h2><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg" alt="img"></p><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p><blockquote><ul><li>Consistency</li><li>Availability</li><li>Partition tolerance</li></ul></blockquote><p>它们的第一个字母分别是 C、A、P。</p><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><h2 id="二、Partition-tolerance"><a href="#二、Partition-tolerance" class="headerlink" title="二、Partition tolerance"></a>二、Partition tolerance</h2><p>先看 Partition tolerance，中文叫做”分区容错”。</p><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png" alt="img"></p><p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><h2 id="三、Consistency"><a href="#三、Consistency" class="headerlink" title="三、Consistency"></a>三、Consistency</h2><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png" alt="img"></p><p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png" alt="img"></p><p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png" alt="img"></p><p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png" alt="img"></p><p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png" alt="img"></p><h2 id="四、Availability"><a href="#四、Availability" class="headerlink" title="四、Availability"></a>四、Availability</h2><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p><p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p><h2 id="五、Consistency-和-Availability-的矛盾"><a href="#五、Consistency-和-Availability-的矛盾" class="headerlink" title="五、Consistency 和 Availability 的矛盾"></a>五、Consistency 和 Availability 的矛盾</h2><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p><p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><p>[更新 2018.7.17]</p><p>读者问，在什么场合，可用性高于一致性？</p><p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p><p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-什么是活跃起用户的产品</title>
      <link href="/2018/07/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00729/"/>
      <url>/2018/07/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00729/</url>
      
        <content type="html"><![CDATA[<p>“活跃起用户的产品”<br>1.专属性，营造独一无二的价值感；<br>2.情绪性，使人们的高唤醒情绪受到激发；<br>3.社交货币，即谈资，让大家有共同话题，刺激越来越多的人加入。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stereotype组件与Bean扫描</title>
      <link href="/2018/07/28/java/%20Stereotype%E7%BB%84%E4%BB%B6%E4%B8%8EBean%E6%89%AB%E6%8F%8F/"/>
      <url>/2018/07/28/java/%20Stereotype%E7%BB%84%E4%BB%B6%E4%B8%8EBean%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<p>在注解自动装载中介绍了通过注解（Annotation）自动向Bean中注入其他Bean的方法，本篇将介绍通过注解（Annotation）向容器添加Bean的方法。</p><p> Spring的核心容器提供了@Component和@Bean注解来标记如何向IoC容器添加Bean。在核心包中@Component又派生了@Service、@Controller和@Repository这三个注解（在其他的Spring工程或包中还有更多的派生），本文主要介绍@Component及其派生注解的使用。</p><h2 id="一个简单的使用例子"><a href="#一个简单的使用例子" class="headerlink" title="一个简单的使用例子"></a>一个简单的使用例子</h2><p>要想使用@Component等注解来向容器添加Bean，需要向IoC容器指明什么类有这个注解，所以Spring提供了一个扫描机制让使用者指定要检查的路径。配置非常简单，只要使用上下文的component-scan标签即可。我们通过下面的例子来简单说明如何配置。</p><p>例子中的代码仅用于说明问题，并不能运行。源码请到<a href="https://gitee.com/chkui-com/spring-core-sample%E8%87%AA%E8%A1%8Cclone%EF%BC%8C%E4%BE%8B%E5%AD%90%E5%9C%A8*chkui.springcore.example.hybrid.component*%E5%8C%85%E4%B8%AD%E3%80%82">https://gitee.com/chkui-com/spring-core-sample自行clone，例子在*chkui.springcore.example.hybrid.component*包中。</a></p><p>有一个接口和一个实现类作为要添加到IoC容器的Bean：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;public interface NameService &#123;String getName();</span><br><span class="line">&#125;</span><br><span class="line">package chkui.springcore.example.hybrid.component.bean;@Componentpublic class NameServiceImpl implements NameService&#123;@Override</span><br><span class="line">public String getName() &#123;return &quot;This is My Component&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现类NameServiceImpl上使用了@Component注解。</p><p>然后XML（&#x2F;spring-core-sample&#x2F;src&#x2F;main&#x2F;resources&#x2F;hybrid&#x2F;component）配置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;context:component-scan base-package=&quot;chkui.springcore.example.hybrid.component.bean&quot;/&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>XML配置文件中没有任何<bean>的声明，仅仅是通过component-scan启用了路径扫描功能，base-package指定了扫描的包路径。</p><p>然后我们加载这个XML运行Spring IoC容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component;public class SimpleScanApp &#123;public static void main(String[] args) &#123;</span><br><span class="line">print(new ClassPathXmlApplicationContext(&quot;hybrid/component/scanConfig.xml&quot;));</span><br><span class="line">&#125;</span><br><span class="line">private static void print(ApplicationContext context) &#123;</span><br><span class="line">    NameService service = context.getBean(NameService.class);</span><br><span class="line">    System.out.println(service.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后NameServiceImpl就会作为一个Bean添加到IoC容器中。</p><p>在 IOC功能扩展点 一文中已经介绍通过XML、@Component、@Bean任何一种方式去声明一个Bean都会转化为一个 BeanDefinition 的实现类交给BeanFactory来创建实例，所以实际上通过@Component注解和在XML文件中编写一个<bean>标签在结果上并没有什么区别——都是向容器添加了一个Bean实例。但是Spring偏偏提供了@Bean和@Component（以及他的派生注解）2个注解来声名Bean，这当中肯定是有一些差异的。</p><p>@Bean在后续的文章会介绍，它就等价与在XML编写一个<bean>标签。而@Component以及他的派生注解除了是一个IoC容器中的Bean还有许多附加的含义。</p><h2 id="Stereotype与功能分层"><a href="#Stereotype与功能分层" class="headerlink" title="Stereotype与功能分层"></a>Stereotype与功能分层</h2><p>观察@Bean和@Component两个注解的包，前者是在 <em>org.springframework.context.annotation</em> ，而后者是在 <em>org.springframework.stereotype</em> 。不仅仅是@Component，他的派生注解@Service、@Controller和@Repository都在这个包中，实际上它就是在告诉使用者这些注解提供<em>stereotype</em>的特性（或者称为功能、作用）。</p><p>那什么是<em>stereotype</em>特性呢？这很难通过Stereotype这个词的字面意思（这个词能翻译的意思很多，这里最接近的翻译应该是“旧规矩”或者“使固定”）来理解。</p><p>Stereotype特性最早出现在J2EE6中（忘记是哪个JSR提出的了），可以理解为围绕着“元数据”功能而发展出来的一种设计模式，虽然我很难说清楚他属于23个设计模式中的哪一个，但是这确实已经是一种约定俗成的做法，只要看到Stereotype就应该像看到“Factory——工厂模式”、“Adapter——适配器模式”、“Facade——外观模式”一样，一眼就知道他的作用。</p><p>Stereotype特性的目标就是为“组合模式的分层系统”按层标记一个类的功能。所谓的“组合模式的分层系统”实际上就是我们常用的Controller-Service-Dao这种分层模式，只不过有些系统可能会多几层（比如Controller和Service之间加个RPC框架什么的）。根据Stereotype特性的Java官网原文介绍，它是一个用来标记注解的注解（annotating annotation）。一个注解如果被@Stereotype标记证明他提供Stereotype模式的功能，例如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Stereotype @Target(TYPE) </span><br><span class="line">@Retention(RUNTIME) </span><br><span class="line">@interface controller &#123;&#125;@Stereotype @Target(TYPE) </span><br><span class="line">@Retention(RUNTIME) </span><br><span class="line">@interface service &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后我们在使用时可以为不同层的类打上这些标记，表示他们属于不同的分层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UserService&#123;&#125;@Serviceclass UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;@Controllerclass UseController&#123;@Autowired</span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类的实例可能会被用于0到多个分层中（比如Spring的一个Bean既可以是Controller也可以是Service，只要标记对应的注解即可），但是通常情况下一个类最多只会用在一个分层中使用。简单的说Stereotype特性就是用注解来告诉框架某个类是属于系统功能中的哪一层。</p><p>Java的文档上要求提供Stereotype特性的注解需要用@Stereotype来标记。但是Spring的开发大神并没有理会这个事，@Component并没有使用@Stereotype来标记，但是他确实提供了Stereotype的模式。</p><p>在Stereotype模式下，Spring核心工程为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解。我们按照Stereotype的模式为对应的类标记3个注解，然后在引入MVC、ORM、JPA相关的框架之后这些注解会告诉框架对应的类扮演着什么样的功能角色，框架就能很清晰的根据注解提供相关的功能服务。</p><p>例如引入Spring-webmvc之后，一个类如果用@Controller注解标记了之后框架就知道他们都是处理前端请求的，MVC框架就会为他提供RequestMapping之类的功能。随后我们需要将框架调整为WebFlux，基本上直接更换依赖的Jar包就可以了，因为大家都是按照一个模式来开发的。</p><p>所以，如果我们的某个类是用于指定的分层功能，那么最好使用<em>org.springframework.stereotype</em>包中的注解来标记他所属的分层。如果类没有明确的功能（例如用于存储配置数据的类，或者Helper类），使用@Bean等其他方式添加到容器中更合适（@Bean会在后续的文章中介绍）。</p><p>使用Stereotype特性来标记分层，还有一个好处是即使工程的结构再复杂多样，都可以很轻松的使用注解（Annotation）来实现拦截器或者AOP功能。因为我们能够很清晰的知道每个分层的作用，开发AOP的功能就非常便利。</p><h2 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a>扫描配置</h2><p>本文开篇使用了一个简单的例子说明使用<a href="context:component-scan">context:component-scan</a>扫描功能来自动添加被注解标记的Bean。除了使用base-package属性还有其他的标签来控制扫描的路径。</p><p><a href="context:include-filter">context:include-filter</a>和<a href="context:exclude-filter">context:exclude-filter</a>标签用来指定包含和排除的过滤规则。他们提供2个参数——type和expression，用来指定过滤类型和过滤参数，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type=&quot;regex&quot;</span><br><span class="line">                expression=&quot;.*Stub.*Repository&quot;/&gt;</span><br><span class="line">        &lt;context:exclude-filter type=&quot;annotation&quot;</span><br><span class="line">                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>此外还可以使用use-default-filters属性来指定是否扫描默认注解（<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller、``@Configuration</code>），默认值为ture。如果设定成false，需要我们在include-filter中增加对应的annotation。</p><p>除了使用XML配置，还可以使用@ComponentScan注解来指定扫描的路径，他提供和XML配置一样的功能。在后续的文章会介绍纯Java配置的功能。</p><p>关于扫描的详细说明见官网的过滤规则说明。</p><h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h2><p>和普通的Bean一样，我们也可以在@Component上添加注解来指定Bean在IoC容器的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;@Service(&quot;implementNameService&quot;)public class NameServiceImpl implements NameService&#123;@Override</span><br><span class="line">public String getName() &#123;return &quot;This is My Component&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在容器中这个Bean的名称被命名为”implementNameService”。除了直接在注解上添加内容，我们还可以实现 BeanNameGenerator 接口来实现全局的命名方法。看下面这个例子。（源码请到<a href="https://gitee.com/chkui-com/spring-core-sample%E8%87%AA%E8%A1%8Cclone%EF%BC%8C%E4%BE%8B%E5%AD%90%E5%9C%A8*chkui.springcore.example.hybrid.component*%E5%8C%85%E4%B8%AD%E3%80%82%EF%BC%89">https://gitee.com/chkui-com/spring-core-sample自行clone，例子在*chkui.springcore.example.hybrid.component*包中。）</a></p><p>首先在XML中使用 “name-generator” 指定名称的生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:component-scan</span><br><span class="line">base-package=&quot;chkui.springcore.example.hybrid.component.bean&quot;</span><br><span class="line">name-generator=&quot;chkui.springcore.example.hybrid.component.bean.NameGenerator&quot; /&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>然后编写我们的命名生成规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package chkui.springcore.example.hybrid.component.bean;public class NameGenerator implements BeanNameGenerator &#123;@Override</span><br><span class="line">public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">AnnotatedBeanDefinition annotdef = AnnotatedBeanDefinition.class.cast(definition);</span><br><span class="line">AnnotationMetadata meta = annotdef.getMetadata();//生成规则:如果已经命名不做任何调整，如果未命名则在类名车后面增加”_NoDefinedName“字符串</span><br><span class="line">return Optional.of(meta).map(met -&gt; met.getAnnotationTypes()).map(set -&gt; set.toArray(new String[] &#123;&#125;))</span><br><span class="line">.map(array -&gt; array[0]).map(name -&gt; meta.getAnnotationAttributes(name)).map(entry -&gt; entry.get(&quot;value&quot;))</span><br><span class="line">.map(obj -&gt; &quot;&quot;.equals(obj) ? null : obj).orElse(definition.getBeanClassName() + &quot;_NoDefinedName&quot;)</span><br><span class="line">.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用索引提升启动速度"><a href="#使用索引提升启动速度" class="headerlink" title="使用索引提升启动速度"></a>使用索引提升启动速度</h2><p>通常情况下，即使是对整个classpath进行扫描并不会占用太多的时间，但是某些应用对启动时间有极高的要求，对此Spring提供了索引功能。索引功能并不复杂，就是第一次扫描之后生成一个静态文件记录所有的组件，然后下一次扫描就直接读取文件中的内容，而不去执行扫描过程。</p><p>首先引入spring-context-indexer包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;&lt;/dependencies&gt;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly(&quot;org.springframework:spring-context-indexer:5.0.7.RELEASE&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在运行后会生成一个 META-INF&#x2F;spring.components 的文件，之后只要运行工程发现这个文件都会直接使用他。可以通过环境变量或工程根目录的spring.properties中设置spring.index.ignore&#x3D;ture来禁用这个功能。</p><p>这个功能如果没有什么明确的需求，慎重使用，会提高工程的管理成本。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-论认知，论重构</title>
      <link href="/2018/07/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00721/"/>
      <url>/2018/07/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00721/</url>
      
        <content type="html"><![CDATA[<p>领导力是什么，领导力是领导大家去到从未到达过的地方</p><hr><p>论认知！</p><p>1、企业最大的资产是人，企业经营上最大的成本是人的认知力的成本。<br>2、可以花钱买到能干这个事情的人或者技术，但是认知力却是无法花钱培养的。<br>3、认知力就是你知道的和你看到的以及你经历过的，也包括你推理出来的，起源于自我脑力的不断进化，不断自我批判和升级，是不能停下来的。<br>4、一个很强认知力的人同时具备高度的事物分解能力，认知力的形成需要一个很长的过程。</p><p>论重构！<br>1、技术的重构:为了满足产品更新的速度而做出技术架构、技术组件、技术选型等的重构。<br>2、产品的重构:为了满足业务的利益目标而做出的产品功能、产品模式、产品方向等的重构。<br>3、组织重构:分为弹性重构和强制重构，弹性重构是在组织利益面前具体的动作触发完成，强制重构是战略性大规模调整是为了“未来”而做。<br>4、个人重构:是基于个人沉淀在短期、中长期而做出的方向、知识体系上的重构。<br>……<br>“重构”是痛苦的事情，但“重构”比迭代更具革命性和彻底性，应该取代所谓“迭代”的用法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘要-六商原则</title>
      <link href="/2018/07/17/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00717/"/>
      <url>/2018/07/17/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00717/</url>
      
        <content type="html"><![CDATA[<p>高层领导应该具备的六商原则</p><p>分别是智商、情商、韧商、学商、融商和形商。</p><p>（1）智商，同志者同谋，同智者相谋；</p><p>（2）情商，思方行圆，说别人爱听之言，做他人舒坦之事，当成人之美；</p><p>（3）韧商，倾否，而非否倾。自我反省；</p><p>笔记侠注：《易经》否卦有句爻辞“倾否，而非否倾”。颠覆封闭局面，而不是被封闭局面所颠覆。</p><p>（4）学商，学习如春起之苗，辍学如磨刀之石；</p><p>（5）融商，就是融合资源的能力。要学会整合资源，也就是羊毛出在牛身上，猪来买单；</p><p>（6）形商，是不是品牌不重要，像不像品牌才重要。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型总结</title>
      <link href="/2018/07/08/java/%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/08/java/%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型总结"><a href="#Java内存模型总结" class="headerlink" title="Java内存模型总结"></a>Java内存模型总结</h2><p>Hollis <a href="javascript:void(0);">架构师小秘圈</a> <em>7月5日</em></p><p>作者：Hollis，阿里资深攻城狮</p><p>来自：Hollis</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为什么要有内存模型</p><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p><h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><blockquote><p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p></blockquote><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p><p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p><p>那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><blockquote><p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p></blockquote><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p><p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p><p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><blockquote><p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p></blockquote><p>单核CPU只含有一套L1，L2，L3缓存；</p><p>如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><blockquote><p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p><p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p><p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p><p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p></blockquote><p>下图为一个单CPU双核的缓存结构。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjacnr9mmj20ly0bd7wh.jpg"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><blockquote><p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p><p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p><p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjaeger4aj20mj0am7wh.jpg"></p><h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><blockquote><p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p></blockquote><p>并发编程的问题</p><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p><p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>什么是内存模型</p><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>什么是Java内存模型</p><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf%EF%BC%89">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2gy1fyjafgo4uoj20b10abh1f.jpg"></p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p><strong>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</strong></p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Java内存模型的实现</p><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120537&idx=1&sn=f56201217c0ca6fde45ee12965b56296&chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&scene=21#wechat_redirect">synchronized的实现原理</a>文章中，介绍过，这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p><p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像<code>synchronized</code>关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用<code>synchronized</code>的原因。</p><p>但是<code>synchronized</code>是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录摘要-互联网4个关键词</title>
      <link href="/2018/07/08/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00708/"/>
      <url>/2018/07/08/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00708/</url>
      
        <content type="html"><![CDATA[<p>  互联网+时代的四个关键词，分别是专注、极致、口碑和快速，这四大特点</p><hr><p>极致有三个支撑点，<br>第一叫产品思维。’<br>第二个叫痛点思维。我们要了解客户的三个点，叫痛点、痒点和兴奋点。<br>第三个叫尖叫点思维。你的产品一定有一款，哪怕是一点点也行，让人产生尖叫的感觉。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11笔记</title>
      <link href="/2018/07/06/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00706/"/>
      <url>/2018/07/06/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00706/</url>
      
        <content type="html"><![CDATA[<p>  7-11 的核心是：绝大多数都是专用厂商，保证产能和品质；斥巨资（约 180 亿RMB）投入信息系统帮助精准选品、及时订货、门店管理与全链条信息同步；自品牌产品占 7 成以上，每年 SKU 替换率 70%，保证总能让大家买到又喜欢又新颖的产品。7-11 的成长路径非常值得深入研究，国内便利店只学到了门店的形态和关东煮！！背后的学问都在 IT 系统投入和厂商、物流、配送的后端建设。</p><hr><p>流量<em>转化率</em>客单价*复购率 X （付费会员体系） Y（内部员工赋能） &#x3D; Costco</p><hr><p>在互联网技术还没有普及的时候，7-11已经在使用细分的键盘。在结账那一刻，营业员会输入顾客的性别和年龄信息，小男，中男、青男、壮男、老男，多少岁的；小女、中女、青女、壮女、老女，多少岁的。</p><hr><p>从“众人”到“每人”，打造了“新个体”；</p><p>从“长尾”到“头牌”，打造了“新内容”；</p><p>从“低频”到“高频”，打造了“新连接”。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录摘要0705</title>
      <link href="/2018/07/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00705/"/>
      <url>/2018/07/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00705/</url>
      
        <content type="html"><![CDATA[<p>  战略不是不重要，而是很重要。但是怎么看待战略本身，以及如何在不断调整中推动战略执行更为重要。</p><hr><p>军队里流行这样一句话：战术有千百条，头一条就是肯打，离开了肯打，其他的全是白扯。理论玩得非常漂亮，天花乱坠，离开了肯打，一切皆空。</p><p>成功最大的敌人，不是没有机会，而是没有立刻行动。</p><hr><p>取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣</p><hr><h2 id="因为熵减的核心价值就是激活组织和组织中的人。"><a href="#因为熵减的核心价值就是激活组织和组织中的人。" class="headerlink" title="因为熵减的核心价值就是激活组织和组织中的人。"></a>因为熵减的核心价值就是激活组织和组织中的人。</h2><p>就是因为不确定的未来对战略制定的挑战越来越大，做到大致正确相当不容易，决策执行需要充满活力，决策制定、决策落实、决策调整更需要充满活力，用决策层的开放、努力、敢于自我批判、亲力亲为来弥补可能的战略能力缺失。’</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 演变总结</title>
      <link href="/2018/06/30/%E7%BD%91%E7%BB%9C/%20HTTP%20%E6%BC%94%E5%8F%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/30/%E7%BD%91%E7%BB%9C/%20HTTP%20%E6%BC%94%E5%8F%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HTTP-x2F-0-9"><a href="#一、HTTP-x2F-0-9" class="headerlink" title="一、HTTP&#x2F;0.9"></a>一、HTTP&#x2F;0.9</h2><p>HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></blockquote><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>服务器发送完毕，就关闭TCP连接。</p><h2 id="二、HTTP-x2F-1-0"><a href="#二、HTTP-x2F-1-0" class="headerlink" title="二、HTTP&#x2F;1.0"></a>二、HTTP&#x2F;1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP&#x2F;1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，这个格式与0.9版有很大变化。</p><p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><blockquote><ul><li>text&#x2F;plain</li><li>text&#x2F;html</li><li>text&#x2F;css</li><li>image&#x2F;jpeg</li><li>image&#x2F;png</li><li>image&#x2F;svg+xml</li><li>audio&#x2F;mp4</li><li>video&#x2F;mp4</li><li>application&#x2F;javascript</li><li>application&#x2F;pdf</li><li>application&#x2F;zip</li><li>application&#x2F;atom+xml</li></ul></blockquote><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p><p>除了预定义的类型，厂商也可以自定义类型。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure></blockquote><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p><p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></blockquote><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt; </span><br></pre></td></tr></table></figure></blockquote><h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate</span><br></pre></td></tr></table></figure></blockquote><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP&#x2F;1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></blockquote><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></blockquote><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2 id="三、HTTP-x2F-1-1"><a href="#三、HTTP-x2F-1-1" class="headerlink" title="三、HTTP&#x2F;1.1"></a>三、HTTP&#x2F;1.1</h2><p>1997年1月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></blockquote><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure></blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></blockquote><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></blockquote><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承。</p><h2 id="五、HTTP-x2F-2"><a href="#五、HTTP-x2F-2" class="headerlink" title="五、HTTP&#x2F;2"></a>五、HTTP&#x2F;2</h2><p>2015年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3。</p><h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP&#x2F;1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP&#x2F;2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP&#x2F;2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP&#x2F;2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有感随笔</title>
      <link href="/2018/06/21/%E6%9D%82%E8%AE%B0/%E6%9C%89%E6%84%9F%E9%9A%8F%E7%AC%94/"/>
      <url>/2018/06/21/%E6%9D%82%E8%AE%B0/%E6%9C%89%E6%84%9F%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>分享一些自己的理解：</p><p>1.消费市场正在以商品为核心转向以人为核心，更优的用户体验，让用户有专属感，有“谈资”；</p><p>2.企业思考的思路应该是不断的优化端到端的体验，形成闭环；</p><p>3.更优的供应链体系一定是这一闭环上的关键点；</p><p>对未来有助优化供应链体系的一些思路和见解：</p><p>1.SDN,IPv6,HTTP&#x2F;2的快速普及发展，降低了物联网的成本（通信，安全等）必将带来新一波物联网风潮；</p><p>2.区块链的玩好的话，在解决物联网，设备安全，隐私，协同工作等痛点上会产生更多的思路；</p><p>3.供应链体系，新零售借助于物联网的发展，配合区块链的应用必然产生更多的玩法，可能性；</p><p>4.目前形成闭环的成本还比较高，但未来潜力巨大；</p><p>5.未来真的很近；</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存机制及原理总结</title>
      <link href="/2018/05/19/%E7%BD%91%E7%BB%9C/%20HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/19/%E7%BD%91%E7%BB%9C/%20HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="彻底弄懂HTTP缓存机制及原理"><a href="#彻底弄懂HTTP缓存机制及原理" class="headerlink" title="彻底弄懂HTTP缓存机制及原理"></a><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></h1><p>感谢作者！</p><p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端架构师技术汇总</title>
      <link href="/2018/05/02/%E6%9D%82%E8%AE%B0/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/"/>
      <url>/2018/05/02/%E6%9D%82%E8%AE%B0/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="后端架构师技术汇总"><a href="#后端架构师技术汇总" class="headerlink" title="后端架构师技术汇总"></a>后端架构师技术汇总</h1><p>原文链接：<a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">github.com</a></p><blockquote><p>同步到博客来，随时关注github~</p></blockquote><p><strong>最后更新于20180502</strong></p><ul><li>数据结构<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2598%259F%25E5%2588%2597">队列</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259B%2586%25E5%2590%2588">集合</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2593%25BE%25E8%25A1%25A8%25E6%2595%25B0%25E7%25BB%2584">链表、数组</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AD%2597%25E5%2585%25B8%25E5%2585%25B3%25E8%2581%2594%25E6%2595%25B0%25E7%25BB%2584">字典、关联数组</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A0%2588">栈</a></li><li>树<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%258C%25E5%2585%25A8%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">完全二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%25B3%25E8%25A1%25A1%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591">平衡二叉树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%258F%2589%25E6%259F%25A5%25E6%2589%25BE%25E6%25A0%2591bst">二叉查找树（BST）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25A2%25E9%25BB%2591%25E6%25A0%2591">红黑树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23b-bb%25E6%25A0%2591">B-，B+，B*树</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23lsm-%25E6%25A0%2591">LSM 树</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23bitset">BitSet</a></li></ul></li><li>常用算法<ul><li>排序、查找算法<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2580%2589%25E6%258B%25A9%25E6%258E%2592%25E5%25BA%258F">选择排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F">冒泡排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258F%2592%25E5%2585%25A5%25E6%258E%2592%25E5%25BA%258F">插入排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BF%25AB%25E9%2580%259F%25E6%258E%2592%25E5%25BA%258F">快速排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BD%2592%25E5%25B9%25B6%25E6%258E%2592%25E5%25BA%258F">归并排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%258C%25E5%25B0%2594%25E6%258E%2592%25E5%25BA%258F">希尔排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A0%2586%25E6%258E%2592%25E5%25BA%258F">堆排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25A1%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F">计数排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A1%25B6%25E6%258E%2592%25E5%25BA%258F">桶排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259F%25BA%25E6%2595%25B0%25E6%258E%2592%25E5%25BA%258F">基数排序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE">二分查找</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java-%25E4%25B8%25AD%25E7%259A%2584%25E6%258E%2592%25E5%25BA%258F%25E5%25B7%25A5%25E5%2585%25B7">Java 中的排序工具</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%2583%25E9%259A%2586%25E8%25BF%2587%25E6%25BB%25A4%25E5%2599%25A8">布隆过滤器</a></li><li>字符串比较<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kmp-%25E7%25AE%2597%25E6%25B3%2595">KMP 算法</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B7%25B1%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588%25E5%25B9%25BF%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588">深度优先、广度优先</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595">贪心算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%259E%25E6%25BA%25AF%25E7%25AE%2597%25E6%25B3%2595">回溯算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2589%25AA%25E6%259E%259D%25E7%25AE%2597%25E6%25B3%2595">剪枝算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592">动态规划</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%25B4%25E7%25B4%25A0%25E8%25B4%259D%25E5%258F%25B6%25E6%2596%25AF">朴素贝叶斯</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258E%25A8%25E8%258D%2590%25E7%25AE%2597%25E6%25B3%2595">推荐算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%2580%25E5%25B0%258F%25E7%2594%259F%25E6%2588%2590%25E6%25A0%2591%25E7%25AE%2597%25E6%25B3%2595">最小生成树算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%2580%25E7%259F%25AD%25E8%25B7%25AF%25E5%25BE%2584%25E7%25AE%2597%25E6%25B3%2595">最短路径算法</a></li></ul></li><li>并发<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%259A%25E7%25BA%25BF%25E7%25A8%258B">多线程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25BF%25E7%25A8%258B%25E5%25AE%2589%25E5%2585%25A8">线程安全</a></li><li>一致性、事务<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258B%25E5%258A%25A1-acid-%25E7%2589%25B9%25E6%2580%25A7">事务 ACID 特性</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%258B%25E5%258A%25A1%25E7%259A%2584%25E9%259A%2594%25E7%25A6%25BB%25E7%25BA%25A7%25E5%2588%25AB">事务的隔离级别</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mvcc">MVCC</a></li></ul></li><li>锁<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java%25E4%25B8%25AD%25E7%259A%2584%25E9%2594%2581%25E5%2592%258C%25E5%2590%258C%25E6%25AD%25A5%25E7%25B1%25BB">Java中的锁和同步类</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25AC%25E5%25B9%25B3%25E9%2594%2581--%25E9%259D%259E%25E5%2585%25AC%25E5%25B9%25B3%25E9%2594%2581">公平锁 &amp; 非公平锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2582%25B2%25E8%25A7%2582%25E9%2594%2581">悲观锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B9%2590%25E8%25A7%2582%25E9%2594%2581--cas">乐观锁 &amp; CAS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23aba-%25E9%2597%25AE%25E9%25A2%2598">ABA 问题</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23copyonwrite%25E5%25AE%25B9%25E5%2599%25A8">CopyOnWrite容器</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ringbuffer">RingBuffer</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258F%25AF%25E9%2587%258D%25E5%2585%25A5%25E9%2594%2581--%25E4%25B8%258D%25E5%258F%25AF%25E9%2587%258D%25E5%2585%25A5%25E9%2594%2581">可重入锁 &amp; 不可重入锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BA%2592%25E6%2596%25A5%25E9%2594%2581--%25E5%2585%25B1%25E4%25BA%25AB%25E9%2594%2581">互斥锁 &amp; 共享锁</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25AD%25BB%25E9%2594%2581">死锁</a></li></ul></li></ul></li><li>操作系统<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%258E%259F%25E7%2590%2586">计算机原理</a></li><li>CPU<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%259A%25E7%25BA%25A7%25E7%25BC%2593%25E5%25AD%2598">多级缓存</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259B%25E7%25A8%258B">进程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BA%25BF%25E7%25A8%258B">线程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%258F%25E7%25A8%258B">协程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23linux">Linux</a></li></ul></li><li>设计模式<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E7%259A%2584%25E5%2585%25AD%25E5%25A4%25A7%25E5%258E%259F%25E5%2588%2599">设计模式的六大原则</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%2323%25E7%25A7%258D%25E5%25B8%25B8%25E8%25A7%2581%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F">23种常见设计模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%259C%25BA%25E6%2599%25AF">应用场景</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F">单例模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25A3%25E4%25BB%25BB%25E9%2593%25BE%25E6%25A8%25A1%25E5%25BC%258F">责任链模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mvc">MVC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ioc">IOC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23aop">AOP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23uml">UML</a></li><li>微服务思想<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%25B7%25E5%25A8%2581%25E5%25AE%259A%25E5%25BE%258B">康威定律</a></li></ul></li></ul></li><li>运维 &amp; 统计 &amp; 技术支持<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%25B8%25E8%25A7%2584%25E7%259B%2591%25E6%258E%25A7">常规监控</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23apm">APM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%259F%25E8%25AE%25A1%25E5%2588%2586%25E6%259E%2590">统计分析</a></li><li>持续集成(CI&#x2F;CD)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23jenkins">Jenkins</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%258E%25AF%25E5%25A2%2583%25E5%2588%2586%25E7%25A6%25BB">环境分离</a></li></ul></li><li>自动化运维<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ansible">Ansible</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23puppet">puppet</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23chef">chef</a></li></ul></li><li>测试<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tdd-%25E7%2590%2586%25E8%25AE%25BA">TDD 理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E5%2585%2583%25E6%25B5%258B%25E8%25AF%2595">单元测试</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258E%258B%25E5%258A%259B%25E6%25B5%258B%25E8%25AF%2595">压力测试</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25A8%25E9%2593%25BE%25E8%25B7%25AF%25E5%258E%258B%25E6%25B5%258B">全链路压测</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ab-%25E7%2581%25B0%25E5%25BA%25A6%25E8%2593%259D%25E7%25BB%25BF%25E6%25B5%258B%25E8%25AF%2595">A&#x2F;B 、灰度、蓝绿测试</a></li></ul></li><li>虚拟化<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kvm">KVM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23xen">Xen</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openvz">OpenVZ</a></li></ul></li><li>容器技术<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23docker">Docker</a></li></ul></li><li>云技术<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openstack">OpenStack</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23devops">DevOps</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2596%2587%25E6%25A1%25A3%25E7%25AE%25A1%25E7%2590%2586">文档管理</a></li></ul></li><li>中间件<ul><li>Web Server<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23nginx">Nginx</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23openresty">OpenResty</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23apache-httpd">Apache Httpd</a></li><li>Tomcat<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E5%258E%259F%25E7%2590%2586">架构原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25A1%2588">调优方案</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23jetty">Jetty</a></li></ul></li><li>缓存<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%25AC%25E5%259C%25B0%25E7%25BC%2593%25E5%25AD%2598">本地缓存</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25A2%25E6%2588%25B7%25E7%25AB%25AF%25E7%25BC%2593%25E5%25AD%2598">客户端缓存</a></li><li>服务端缓存<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23memcached">Memcached</a></li><li>Redis<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584">架构</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%259E%25E6%2594%25B6%25E7%25AD%2596%25E7%2595%25A5">回收策略</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tair">Tair</a></li></ul></li><li>消息队列<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B6%2588%25E6%2581%25AF%25E6%2580%25BB%25E7%25BA%25BF">消息总线</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25B6%2588%25E6%2581%25AF%25E7%259A%2584%25E9%25A1%25BA%25E5%25BA%258F">消息的顺序</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rabbitmq">RabbitMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rocketmq">RocketMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23activemq">ActiveMQ</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kafka">Kafka</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23redis-%25E6%25B6%2588%25E6%2581%25AF%25E6%258E%25A8%25E9%2580%2581">Redis 消息推送</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23zeromq">ZeroMQ</a></li></ul></li><li>定时调度<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E6%259C%25BA%25E5%25AE%259A%25E6%2597%25B6%25E8%25B0%2583%25E5%25BA%25A6">单机定时调度</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E5%25AE%259A%25E6%2597%25B6%25E8%25B0%2583%25E5%25BA%25A6">分布式定时调度</a></li></ul></li><li>RPC<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23dubbo">Dubbo</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23thrift">Thrift</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23grpc">gRPC</a></li></ul></li><li>数据库中间件<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sharding-jdbc">Sharding Jdbc</a></li></ul></li><li>日志系统<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2597%25A5%25E5%25BF%2597%25E6%2590%259C%25E9%259B%2586">日志搜集</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2585%258D%25E7%25BD%25AE%25E4%25B8%25AD%25E5%25BF%2583">配置中心</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23api-%25E7%25BD%2591%25E5%2585%25B3">API 网关</a></li></ul></li><li>网络<ul><li>协议<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23osi-%25E4%25B8%2583%25E5%25B1%2582%25E5%258D%258F%25E8%25AE%25AE">OSI 七层协议</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tcpip">TCP&#x2F;IP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23http">HTTP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23http20">HTTP2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23https">HTTPS</a></li></ul></li><li>网络模型<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23epoll">Epoll</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23java-nio">Java NIO</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kqueue">kqueue</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259E%25E6%258E%25A5%25E5%2592%258C%25E7%259F%25AD%25E8%25BF%259E%25E6%258E%25A5">连接和短连接</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25A1%2586%25E6%259E%25B6">框架</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259Dzero-copy">零拷贝（Zero-copy）</a></li><li>序列化(二进制协议)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hessian">Hessian</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23protobuf">Protobuf</a></li></ul></li></ul></li><li>数据库<ul><li>基础理论<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E8%25AE%25BE%25E8%25AE%25A1%25E7%259A%2584%25E4%25B8%2589%25E5%25A4%25A7%25E8%258C%2583%25E5%25BC%258F">数据库设计的三大范式</a></li></ul></li><li>MySQL<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258E%259F%25E7%2590%2586">原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23innodb">InnoDB</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BC%2598%25E5%258C%2596">优化</a></li><li>索引<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2581%259A%25E9%259B%2586%25E7%25B4%25A2%25E5%25BC%2595-%25E9%259D%259E%25E8%2581%259A%25E9%259B%2586%25E7%25B4%25A2%25E5%25BC%2595">聚集索引, 非聚集索引</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%258D%25E5%2590%2588%25E7%25B4%25A2%25E5%25BC%2595">复合索引</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2587%25AA%25E9%2580%2582%25E5%25BA%2594%25E5%2593%2588%25E5%25B8%258C%25E7%25B4%25A2%25E5%25BC%2595ahi">自适应哈希索引(AHI)</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23explain">explain</a></li></ul></li><li>NoSQL<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mongodb">MongoDB</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hbase">Hbase</a></li></ul></li></ul></li><li>搜索引擎<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2590%259C%25E7%25B4%25A2%25E5%25BC%2595%25E6%2593%258E%25E5%258E%259F%25E7%2590%2586">搜索引擎原理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23lucene">Lucene</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23elasticsearch">Elasticsearch</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23solr">Solr</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sphinx">sphinx</a></li></ul></li><li>性能<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2580%25A7%25E8%2583%25BD%25E4%25BC%2598%25E5%258C%2596%25E6%2596%25B9%25E6%25B3%2595%25E8%25AE%25BA">性能优化方法论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25B9%25E9%2587%258F%25E8%25AF%2584%25E4%25BC%25B0">容量评估</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23cdn-%25E7%25BD%2591%25E7%25BB%259C">CDN 网络</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BF%259E%25E6%258E%25A5%25E6%25B1%25A0">连接池</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2580%25A7%25E8%2583%25BD%25E8%25B0%2583%25E4%25BC%2598">性能调优</a></li></ul></li><li>大数据<ul><li>流式计算<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23storm">Storm</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23flink">Flink</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23kafka-stream">Kafka Stream</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%259C%25BA%25E6%2599%25AF-1">应用场景</a></li></ul></li><li>Hadoop<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hdfs">HDFS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23mapreduce">MapReduce</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23yarn">Yarn</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23spark">Spark</a></li></ul></li><li>安全<ul><li>web 安全<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23xss">XSS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23csrf">CSRF</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23sql-%25E6%25B3%25A8%25E5%2585%25A5">SQL 注入</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23hash-dos">Hash Dos</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%2584%259A%25E6%259C%25AC%25E6%25B3%25A8%25E5%2585%25A5">脚本注入</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%25BC%258F%25E6%25B4%259E%25E6%2589%25AB%25E6%258F%258F%25E5%25B7%25A5%25E5%2585%25B7">漏洞扫描工具</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581">验证码</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23ddos-%25E9%2598%25B2%25E8%258C%2583">DDoS 防范</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%2594%25A8%25E6%2588%25B7%25E9%259A%2590%25E7%25A7%2581%25E4%25BF%25A1%25E6%2581%25AF%25E4%25BF%259D%25E6%258A%25A4">用户隐私信息保护</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%258F%25E5%2588%2597%25E5%258C%2596%25E6%25BC%258F%25E6%25B4%259E">序列化漏洞</a></li><li>加密解密<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AF%25B9%25E7%25A7%25B0%25E5%258A%25A0%25E5%25AF%2586">对称加密</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2593%2588%25E5%25B8%258C%25E7%25AE%2597%25E6%25B3%2595">哈希算法</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%259D%259E%25E5%25AF%25B9%25E7%25A7%25B0%25E5%258A%25A0%25E5%25AF%2586">非对称加密</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E5%25AE%2589%25E5%2585%25A8">服务器安全</a></li><li>数据安全<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%25B0%25E6%258D%25AE%25E5%25A4%2587%25E4%25BB%25BD">数据备份</a></li></ul></li><li>网络隔离<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2586%2585%25E5%25A4%2596%25E7%25BD%2591%25E5%2588%2586%25E7%25A6%25BB">内外网分离</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%2599%25BB%25E5%25BD%2595%25E8%25B7%25B3%25E6%259D%25BF%25E6%259C%25BA">登录跳板机</a></li></ul></li><li>授权、认证<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rbac">RBAC</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23oauth20">OAuth2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258F%258C%25E5%259B%25A0%25E7%25B4%25A0%25E8%25AE%25A4%25E8%25AF%25812fa">双因素认证（2FA）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%258D%2595%25E7%2582%25B9%25E7%2599%25BB%25E5%25BD%2595sso">单点登录(SSO)</a></li></ul></li></ul></li><li>常用开源框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E6%25BA%2590%25E5%258D%258F%25E8%25AE%25AE">开源协议</a></li><li>日志框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23log4jlog4j2">Log4j、Log4j2</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23logback">Logback</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23orm">ORM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BD%2591%25E7%25BB%259C%25E6%25A1%2586%25E6%259E%25B6">网络框架</a></li><li>Web 框架<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23spring-%25E5%25AE%25B6%25E6%2597%258F">Spring 家族</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7%25E6%25A1%2586%25E6%259E%25B6">工具框架</a></li></ul></li><li>分布式设计<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%25A9%25E5%25B1%2595%25E6%2580%25A7%25E8%25AE%25BE%25E8%25AE%25A1">扩展性设计</a></li><li>稳定性 &amp; 高可用<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25A1%25AC%25E4%25BB%25B6%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1">硬件负载均衡</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25BD%25AF%25E4%25BB%25B6%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1">软件负载均衡</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2599%2590%25E6%25B5%2581">限流</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BA%2594%25E7%2594%25A8%25E5%25B1%2582%25E5%25AE%25B9%25E7%2581%25BE">应用层容灾</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B7%25A8%25E6%259C%25BA%25E6%2588%25BF%25E5%25AE%25B9%25E7%2581%25BE">跨机房容灾</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25AE%25B9%25E7%2581%25BE%25E6%25BC%2594%25E7%25BB%2583%25E6%25B5%2581%25E7%25A8%258B">容灾演练流程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%25B3%25E6%25BB%2591%25E5%2590%25AF%25E5%258A%25A8">平滑启动</a></li></ul></li><li>数据库扩展<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25AF%25BB%25E5%2586%2599%25E5%2588%2586%25E7%25A6%25BB%25E6%25A8%25A1%25E5%25BC%258F">读写分离模式</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E7%2589%2587%25E6%25A8%25A1%25E5%25BC%258F">分片模式</a></li></ul></li><li>服务治理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E6%25B3%25A8%25E5%2586%258C%25E4%25B8%258E%25E5%258F%2591%25E7%258E%25B0">服务注册与发现</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259C%258D%25E5%258A%25A1%25E8%25B7%25AF%25E7%2594%25B1%25E6%258E%25A7%25E5%2588%25B6">服务路由控制</a></li></ul></li><li>分布式一致<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23cap-%25E4%25B8%258E-base-%25E7%2590%2586%25E8%25AE%25BA">CAP 与 BASE 理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2594%2581">分布式锁</a></li><li>分布式一致性算法<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23paxos">PAXOS</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23zab">Zab</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23raft">Raft</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23gossip">Gossip</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25A4%25E9%2598%25B6%25E6%25AE%25B5%25E6%258F%2590%25E4%25BA%25A4%25E5%25A4%259A%25E9%2598%25B6%25E6%25AE%25B5%25E6%258F%2590%25E4%25BA%25A4">两阶段提交、多阶段提交</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B9%2582%25E7%25AD%2589">幂等</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E4%25B8%2580%25E8%2587%25B4%25E6%2596%25B9%25E6%25A1%2588">分布式一致方案</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F-leader-%25E8%258A%2582%25E7%2582%25B9%25E9%2580%2589%25E4%25B8%25BE">分布式 Leader 节点选举</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23tcctryconfirmcancel-%25E6%259F%2594%25E6%2580%25A7%25E4%25BA%258B%25E5%258A%25A1">TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F">分布式文件系统</a></li><li>唯一ID 生成<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25A8%25E5%25B1%2580%25E5%2594%25AF%25E4%25B8%2580id">全局唯一ID</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%2580%25E8%2587%25B4%25E6%2580%25A7hash%25E7%25AE%2597%25E6%25B3%2595">一致性Hash算法</a></li></ul></li><li>设计思想 &amp; 开发模式<ul><li>DDD(Domain-driven Design - 领域驱动设计)<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2591%25BD%25E4%25BB%25A4%25E6%259F%25A5%25E8%25AF%25A2%25E8%2581%258C%25E8%25B4%25A3%25E5%2588%2586%25E7%25A6%25BBcqrs">命令查询职责分离(CQRS)</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25B4%25AB%25E8%25A1%2580%25E5%2585%2585%25E8%25A1%2580%25E6%25A8%25A1%25E5%259E%258B">贫血，充血模型</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23actor-%25E6%25A8%25A1%25E5%25BC%258F">Actor 模式</a></li><li>响应式编程<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23reactor">Reactor</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rxjava">RxJava</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23vertx">Vert.x</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23dodaf20">DODAF2.0</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23serverless">Serverless</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23service-mesh">Service Mesh</a></li></ul></li><li>项目管理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E8%25AF%2584%25E5%25AE%25A1">架构评审</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2587%258D%25E6%259E%2584">重构</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581%25E8%25A7%2584%25E8%258C%2583">代码规范</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581-review">代码 Review</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23rup">RUP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%259C%258B%25E6%259D%25BF%25E7%25AE%25A1%25E7%2590%2586">看板管理</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23scrum">SCRUM</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2595%258F%25E6%258D%25B7%25E5%25BC%2580%25E5%258F%2591">敏捷开发</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%2581%25E9%2599%2590%25E7%25BC%2596%25E7%25A8%258Bxp">极限编程（XP）</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%2593%25E5%25AF%25B9%25E7%25BC%2596%25E7%25A8%258B">结对编程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23fmea%25E7%25AE%25A1%25E7%2590%2586%25E6%25A8%25A1%25E5%25BC%258F">FMEA管理模式</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2580%259A%25E7%2594%25A8%25E4%25B8%259A%25E5%258A%25A1%25E6%259C%25AF%25E8%25AF%25AD">通用业务术语</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258A%2580%25E6%259C%25AF%25E8%25B6%258B%25E5%258A%25BF">技术趋势</a></li><li>政策、法规<ul><li>法律<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25A5%25E6%25A0%25BC%25E9%2581%25B5%25E5%25AE%2588%25E5%2588%2591%25E6%25B3%2595253%25E6%25B3%2595%25E6%259D%25A1">严格遵守刑法253法条</a></li></ul></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E5%25B8%2588%25E7%25B4%25A0%25E8%25B4%25A8">架构师素质</a></li><li>团队管理<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258B%259B%25E8%2581%2598">招聘</a></li></ul></li><li>资讯<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25A1%258C%25E4%25B8%259A%25E8%25B5%2584%25E8%25AE%25AF">行业资讯</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25AC%25E4%25BC%2597%25E5%258F%25B7%25E5%2588%2597%25E8%25A1%25A8">公众号列表</a></li><li>博客<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259B%25A2%25E9%2598%259F%25E5%258D%259A%25E5%25AE%25A2">团队博客</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2">个人博客</a></li></ul></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%25BC%25E5%2590%2588%25E9%2597%25A8%25E6%2588%25B7%25E7%25A4%25BE%25E5%258C%25BA">综合门户、社区</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E9%2597%25AE%25E7%25AD%2594%25E8%25AE%25A8%25E8%25AE%25BA%25E7%25B1%25BB%25E7%25A4%25BE%25E5%258C%25BA">问答、讨论类社区</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E8%25A1%258C%25E4%25B8%259A%25E6%2595%25B0%25E6%258D%25AE%25E5%2588%2586%25E6%259E%2590">行业数据分析</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25B8%2593%25E9%25A1%25B9%25E7%25BD%2591%25E7%25AB%2599">专项网站</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%2585%25B6%25E4%25BB%2596%25E7%25B1%25BB">其他类</a></li><li>推荐参考书<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259C%25A8%25E7%25BA%25BF%25E7%2594%25B5%25E5%25AD%2590%25E4%25B9%25A6">在线电子书</a></li><li>纸质书<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E5%258F%2591%25E6%2596%25B9%25E9%259D%25A2">开发方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%259E%25B6%25E6%259E%2584%25E6%2596%25B9%25E9%259D%25A2">架构方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%258A%2580%25E6%259C%25AF%25E7%25AE%25A1%25E7%2590%2586%25E6%2596%25B9%25E9%259D%25A2">技术管理方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259F%25BA%25E7%25A1%2580%25E7%2590%2586%25E8%25AE%25BA-1">基础理论</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7%25E6%2596%25B9%25E9%259D%25A2">工具方面</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE%25E6%2596%25B9%25E9%259D%25A2">大数据方面</a></li></ul></li></ul></li></ul></li><li>技术资源<ul><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25BC%2580%25E6%25BA%2590%25E8%25B5%2584%25E6%25BA%2590">开源资源</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%258B%25E5%2586%258C%25E6%2596%2587%25E6%25A1%25A3%25E6%2595%2599%25E7%25A8%258B">手册、文档、教程</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%259C%25A8%25E7%25BA%25BF%25E8%25AF%25BE%25E5%25A0%2582">在线课堂</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BC%259A%25E8%25AE%25AE%25E6%25B4%25BB%25E5%258A%25A8">会议、活动</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B8%25B8%25E7%2594%25A8app">常用APP</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2589%25BE%25E5%25B7%25A5%25E4%25BD%259C">找工作</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E5%25B7%25A5%25E5%2585%25B7">工具</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E4%25BB%25A3%25E7%25A0%2581%25E6%2589%2598%25E7%25AE%25A1">代码托管</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E6%2596%2587%25E4%25BB%25B6%25E6%259C%258D%25E5%258A%25A1">文件服务</a></li><li><a href="https://link.juejin.im/?target=https://github.com/xingshaocheng/architect-awesome/blob/master/README.md%23%25E7%25BB%25BC%25E5%2590%2588%25E4%25BA%2591%25E6%259C%258D%25E5%258A%25A1%25E5%2595%2586">综合云服务商</a></li></ul></li></ul><p><strong>（Toc generated by simple-php-github-toc ）</strong></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lemon-flm/p/7877898.html">《java队列——queue详细分析》</a><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/mantu/p/5802393.html">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_33642117/article/details/52040345">《Java Set集合的详解》</a></li></ul><h2 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a>链表、数组</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wz249863091/article/details/52853360">《Java集合详解–什么是List》</a></li></ul><h2 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a>字典、关联数组</h2><ul><li><a href="https://link.juejin.im/?target=https://baike.xsoftlab.net/view/250.html">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/javazejian/article/details/53362993">《java数据结构与算法之栈（Stack）设计与实现》</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/java/java-stack-class.html">《Java Stack 类》</a></li><li>《java stack的详细实现分析》<ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/cai2016/article/details/52589952">《二叉树》</a></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>《完全二叉树》<ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/polly333/p/4798944.html">《浅谈数据结构-平衡二叉树》</a></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li></ul><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html">《浅谈算法和数据结构: 七 二叉查找树》</a></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul><li>《最容易懂得红黑树》<ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li></ul><h3 id="B-，B-，B-树"><a href="#B-，B-，B-树" class="headerlink" title="B-，B+，B*树"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/aqzwss/article/details/53074186">《B-树，B+树，B*树详解》</a></li><li>《B-树，B+树与B*树的优缺点比较》<ul><li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。</li></ul></li></ul><h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h3><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/dbanote/article/details/8897599">《LSM树 VS B+树》</a><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014774781/article/details/52105708">《LSM树（Log-Structured Merge Tree）存储引擎》</a><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/java/java-bitset-class.html">《Java Bitset类》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/caiandyong/article/details/51581160">《Java BitSet（位集）》</a></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/gane_cheng/article/details/52652705">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h2 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a>排序、查找算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/gane_cheng/article/details/52652705">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>《Java中的经典算法之选择排序（SelectionSort）》<ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>《冒泡排序的2种写法》<ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²)</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hapjin/p/5517667.html">《排序算法总结之插入排序》</a></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>《坐在马桶上看算法：快速排序》<ul><li>一侧比另外一次都大或小。</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>《图解排序算法(四)之归并排序》<ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。</li></ul></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>TODO</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>《图解排序算法(三)之堆排序》<ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul><li>《计数排序和桶排序》<ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/ahalei/1362789">《【啊哈！算法】最快最简单的排序——桶排序》</a></li><li>《排序算法（三）：计数排序与桶排序》<ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个通单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lemon_tree12138/article/details/51695211">《排序算法系列：基数排序》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/skywang12345/p/3603669.html">《基数排序》</a></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/coderising/p/5708632.html">《二分查找(java实现)》</a><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/maoyuanming0806/article/details/78176957">《java实现二分查找-两种方式》</a><ul><li>while + 递归。</li></ul></li></ul><h3 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a>Java 中的排序工具</h3><ul><li>《Arrays.sort和Collections.sort实现原理解析》<ul><li>Collections.sort算法调用的是合并排序。</li><li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000002729689">《布隆过滤器 – 空间效率很高的数据结构》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zdxiq000/article/details/57626464">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li><li>《基于Redis的布隆过滤器的实现》<ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li>《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》<ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2013/05/Knuth%25E2%2580%2593Morris%25E2%2580%2593Pratt_algorithm.html">《字符串匹配的KMP算法》</a></li></ul><h2 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a>深度优先、广度优先</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/0kk470/p/7555033.html">《广度优先搜索BFS和深度优先搜索DFS》</a></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/MrSaver/p/8641971.html">《算法：贪婪算法基础》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/a345017062/article/details/52443781">《常见算法及问题场景——贪心算法》</a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qfikh/article/details/51960331">《 五大常用算法之四：回溯法》</a></li></ul><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/luningcsdn/article/details/50930276">《α-β剪枝算法》</a></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/little-YTMM/p/5372680.html">《详解动态规划——邹博讲动态规划》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yao_zi_jie/article/details/54580283">《动态规划算法的个人理解》</a></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/amds123/article/details/70173402">《带你搞懂朴素贝叶斯分类算法》</a><ul><li>P(B|A)&#x3D;P(A|B)P(B)&#x2F;P(A)</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html">《贝叶斯推断及其互联网应用1》</a></li><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html">《贝叶斯推断及其互联网应用2》</a></li></ul><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01">《推荐算法综述》</a></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems">《TOP 10 开源的推荐系统简介》</a></li></ul><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/luoshixian099/article/details/51908175">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li></ul><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_35644234/article/details/60870719">《Dijkstra算法详解》</a></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><a href="https://link.juejin.im/?target=http://www.importnew.com/18459.html">《40个Java多线程问题总结》</a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhanht/p/5450325.html">《Java并发编程——线程安全及解决机制简介》</a></li></ul><h2 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a>一致性、事务</h2><h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012440687/article/details/52116108">《数据库事务ACID特性》</a></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化：所有事物串行处理（牺牲了效率）</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_33290787/article/details/51924963">《理解事务的4种隔离级别》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/z-sm/p/7245981.html">数据库事务的四大特性及事务隔离级别</a></li><li><a href="https://link.juejin.im/?target=http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">《MySQL的InnoDB的幻读问题 》</a><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><a href="https://link.juejin.im/?target=http://database.51cto.com/art/201804/570101.htm">《一篇文章带你读懂MySQL和InnoDB》</a><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/chenpingzhao/p/5065316.html">《【mysql】关于innodb中MVCC的一些理解》</a><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whoamiyang/article/details/51901888">《轻松理解MYSQL MVCC 实现机制》</a><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a>Java中的锁和同步类</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/qifengshi/p/6831055.html">《Java中的锁分类》</a><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/waterystone/p/4920797.html">《Java并发之AQS详解》</a></li><li><a href="https://link.juejin.im/?target=http://cuisuqiang.iteye.com/blog/2020146">《Java中信号量 Semaphore》</a><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/davidwang456/p/6094947.html">《java开发中的Mutex vs Semaphore》</a><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。</li></ul></li></ul><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li>《公平锁与非公平锁》<ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhiqian-ali/p/6200874.html">《【MySQL】悲观锁&amp;乐观锁》</a><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/Lawson/p/5008741.html">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zejin2008/p/5262751.html">《Mysql并发时经典常见的死锁原因及解决方法》</a></li></ul><h3 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a>乐观锁 &amp; CAS</h3><ul><li>《乐观锁的一种实现方式——CAS》<ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。</li></ul></li></ul><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/549294286/p/3766717.html">《Java CAS 和ABA问题》</a></li><li>《Java 中 ABA问题及避免》<ul><li>AtomicStampedReference 和 AtomicStampedReference。</li></ul></li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hapjin/p/4840107.html">《JAVA中写时复制(Copy-On-Write)Map实现》</a><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。</li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/a494303877/article/details/53404623">《聊聊并发-Java中的Copy-On-Write容器》</a></li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/l00l/p/4115001.html">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li></ul><h3 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a>可重入锁 &amp; 不可重入锁</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/dj3839/p/6580765.html">《可重入锁和不可重入锁》</a><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/baizhanshi/p/7211802.html">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h3 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。 共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/liang1101/p/6475555.html">《ReadWriteLock场景应用》</a></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yunfenglw/article/details/45950305">《“死锁”四个必要条件的合理解释》</a><ul><li>互斥、持有、不可剥夺、不可剥夺。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014039577/article/details/52351626">Java如何查看死锁？</a><ul><li>JConsole 可以识别死锁。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/bohu83/article/details/51135061">java多线程系列：死锁及检测</a><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000003692840">《操作系统基础知识——操作系统的原理，类型和结构》</a></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zero__007/article/details/54089730">《从Java视角理解CPU缓存和伪共享》</a></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/asdf_1024/article/details/78978437">《线程的生命周期及状态转换详解》</a></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>《终结python协程—-从yield到actor模型的实现》<ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无谓的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/linux/linux-command-manual.html">《Linux 命令大全》</a></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li>《设计模式的六大原则》<ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏代换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成&#x2F;聚合,而不是使用继承。</li></ul></li></ul><h2 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a>23种常见设计模式</h2><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/design-pattern/design-pattern-tutorial.html">《设计模式》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/susanws/p/5510229.html">《23种设计模式全解析》</a></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/62314/">《细数JDK里的设计模式》</a><ul><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是 <strong>一个返</strong>* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>空对象模式：如 java.util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hwaggLee/p/4510687.html">《Spring-涉及到的设计模式汇总》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012387062/article/details/54719114">《Mybatis使用的设计模式》</a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/YECrazy/article/details/79481964">《单例模式的三种实现 以及各自的优缺点》</a></li><li>《单例模式－－反射－－防止序列化破坏单例模式》<ul><li>使用枚举类型。</li></ul></li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>TODO</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>《MVC 模式》<ul><li>模型(model)－视图(view)－控制器(controller)</li></ul></li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/23277575">《理解 IOC》</a></li><li>《IOC 的理解与解释》<ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/yanquan345/blog/203415">《轻松理解AOP(面向切面编程)》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hongwz/p/5764917.html">《Spring AOP详解》</a></li><li>《Spring AOP的实现原理》<ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li>《Spring AOP 实现原理与 CGLIB 应用》<ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类</li></ul></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/uml_tutorial/">《UML教程》</a></li></ul><h2 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wintersun/p/6219259.html">《微服务架构设计》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/micro-service-technology-stack">《微服务架构技术栈选型手册》</a></li></ul><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><ul><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/8611">《微服务架构的理论基础 - 康威定律》</a><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><a href="https://link.juejin.im/?target=https://static.geekbang.org/PDF-%25E4%25BF%25AE%25E6%2594%25B9%25E7%2589%2588-%25E6%259E%2581%25E5%25AE%25A2%25E6%2597%25B6%25E9%2597%25B4-%25E5%259B%25BE%25E7%2589%2587-%25E6%259D%25A8%25E6%25B3%25A2-%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1%25E6%259E%25B6%25E6%259E%2584.pdf">《微服务架构核⼼20讲》</a></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a>常规监控</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/77849205">《腾讯业务系统监控的修炼之路》</a><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/news/67525/monitoring-tools">《开源还是商用？十大云运维监控工具横评》</a><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><a href="https://link.juejin.im/?target=http://developer.51cto.com/art/201612/525373.htm">《监控报警系统搭建及二次开发经验》</a></li></ul><p><strong>命令行监控工具</strong></p><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html">《常用命令行监控工具》</a><ul><li>top、sar、tsar、nload</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/96846/">《20个命令行工具监控 Linux 系统性能》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/feichexia/blog/196575">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM — Application Performance Management</p><ul><li><a href="https://link.juejin.im/?target=http://bigbully.github.io/Dapper-translation/">《Dapper，大规模分布式系统的跟踪系统》</a></li><li><a href="https://link.juejin.im/?target=http://opentracing.io">CNCF OpenTracing</a>，<a href="https://link.juejin.im/?target=https://github.com/opentracing-contrib/opentracing-specification-zh">中文版</a></li><li>主要开源软件，按字母排序<ul><li><a href="https://link.juejin.im/?target=https://github.com/apache/incubator-skywalking">Apache SkyWalking</a></li><li><a href="https://link.juejin.im/?target=https://github.com/dianping/cat">CAT</a></li><li><a href="https://link.juejin.im/?target=https://github.com/jaegertracing/jaeger">CNCF jaeger</a></li><li><a href="https://link.juejin.im/?target=https://github.com/naver/pinpoint">Pinpoint</a></li><li><a href="https://link.juejin.im/?target=https://github.com/openzipkin/zipkin">Zipkin</a></li></ul></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/apm-Pinpoint-practice">《开源APM技术选型与实战》</a><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><ul><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/25195217">《流量统计的基础：埋点》</a><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.25xt.com/company/17066.html">《APP埋点常用的统计工具、埋点目标和埋点内容》</a><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><a href="https://link.juejin.im/?target=https://tech.meituan.com/mt-mobile-analytics-practice.html">《美团点评前端无痕埋点实践》</a><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。</li></ul></li></ul><h2 id="持续集成-CI-x2F-CD"><a href="#持续集成-CI-x2F-CD" class="headerlink" title="持续集成(CI&#x2F;CD)"></a>持续集成(CI&#x2F;CD)</h2><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">《持续集成是什么？》</a></li><li><a href="https://link.juejin.im/?target=https://www.testwo.com/article/1170">《8个流行的持续集成工具》</a></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><ul><li><a href="https://link.juejin.im/?target=https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000">《使用Jenkins进行持续集成》</a></li></ul><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h3><p>开发、测试、生成环境分离。</p><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/sancuo/blog/214904">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul><h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h2><h3 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ansible.com.cn/">《Ansible中文权威指南》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/heiye123/articles/7855890.html">《Ansible基础配置和企业级项目实用案例》</a></li></ul><h3 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/keerya/p/8040071.html">《自动化运维工具——puppet详解》</a></li></ul><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h3><ul><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/">《Chef 的安装与使用》</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a>TDD 理论</h3><ul><li>《深度解读 - TDD（测试驱动开发）》<ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；</li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/happyzm/p/6482886.html">《Java单元测试之JUnit篇》</a></li><li>《JUnit 4 与 TestNG 对比》<ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。</li></ul></li><li>《单元测试主要的测试功能点》<ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。</li></ul></li></ul><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/blueheart20/article/details/52170790">《Apache ab 测试使用指南》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/binyue/p/6141088.html">《大型网站压力测试及优化方案》</a></li><li><a href="https://link.juejin.im/?target=http://news.chinabyte.com/466/14126966.shtml">《10大主流压力&#x2F;负载&#x2F;性能测试工具推荐》</a></li><li><a href="https://link.juejin.im/?target=http://quentinxxz.iteye.com/blog/2249799">《真实流量压测工具 tcpcopy应用浅析》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/jwentest/p/7136727.html">《nGrinder 简易使用教程》</a></li></ul><h3 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h3><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/30306892">《饿了么全链路压测的探索与实践》</a></li><li><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/28355759">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/27060fd61f72">《全链路压测经验》</a></li></ul><h3 id="A-x2F-B-、灰度、蓝绿测试"><a href="#A-x2F-B-、灰度、蓝绿测试" class="headerlink" title="A&#x2F;B 、灰度、蓝绿测试"></a>A&#x2F;B 、灰度、蓝绿测试</h3><ul><li><a href="https://link.juejin.im/?target=https://testerhome.com/topics/11165">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/purplegrape/1403123">《nginx 根据IP 进行灰度发布》</a></li><li><a href="https://link.juejin.im/?target=https://www.v2ex.com/t/344341">《蓝绿部署、A&#x2F;B 测试以及灰度发布》</a></li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/52910082">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><ul><li><a href="https://link.juejin.im/?target=http://blog.chinaunix.net/uid-20201831-id-5775661.html">《KVM详解，太详细太深入了，经典》</a></li><li><a href="https://link.juejin.im/?target=https://www.coderxing.com/kvm-install.html">《【图文】KVM 虚拟机安装详解》</a></li></ul><h3 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sddai/p/5931201.html">《Xen虚拟化基本原理详解》</a></li></ul><h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/longerzone/article/details/44829255">《开源Linux容器 OpenVZ 快速上手指南》</a></li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/SzeCheng/p/6822905.html">《几张图帮你理解 docker 基本原理及快速入门》</a></li><li><a href="https://link.juejin.im/?target=https://draveness.me/docker">《Docker 核心技术与实现原理》</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/docker/docker-tutorial.html">《Docker 教程》</a></li></ul><h2 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h2><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/klb561/p/8660264.html">《OpenStack构架知识梳理》</a></li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/jetzhang/p/6068773.html">《一分钟告诉你究竟DevOps是什么鬼？》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/detail-analysis-of-devops">《DevOps详解》</a></li></ul><h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h2><ul><li><a href="https://link.juejin.im/?target=http://www.confluence.cn/">Confluence-收费文档管理系统</a></li><li>GitLab?</li><li>Wiki</li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_25797077/article/details/52200722">《Ngnix的基本学习-多进程和Apache的比较》</a><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cunkouzh/p/5410154.html">《nginx与Apache的对比以及优缺点》</a><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li><a href="https://link.juejin.im/?target=http://openresty.org/cn/">官方网站</a></li><li>《浅谈 OpenResty》<ul><li>通过 Lua 模块可以在Nginx上进行开发。</li></ul></li></ul><h3 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a>Apache Httpd</h3><ul><li><a href="https://link.juejin.im/?target=http://httpd.apache.org/">官方网站</a></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/hggen/p/6264475.html">《TOMCAT原理详解及请求过程》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/crazylqy/p/4706223.html">《Tomcat服务器原理详解》</a></li><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xlgen157387/article/details/79006434">《四张图带你了解Tomcat系统架构》</a></li><li><a href="https://link.juejin.im/?target=https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/">《JBoss vs. Tomcat: Choosing A Java Application Server》</a><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h4 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sunfenqing/p/7339058.html">《Tomcat 调优方案》</a><ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.chinaunix.net/uid-20662363-id-3012760.html">《tomcat http协议与ajp协议》</a></li><li><a href="https://link.juejin.im/?target=http://dmouse.iteye.com/blog/1354527">《AJP与HTTP比较和分析》</a><ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><ul><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/java/j-lo-jetty/">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li>《jetty和tomcat优势比较》<ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I&#x2F;O请求上更占优势，Tomcat默认采用BIO处理I&#x2F;O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。</li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/clementad/article/details/48229243">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li></ul><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html">《HashMap本地缓存》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html">《EhCache本地缓存》</a><ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html">《Guava Cache》</a><ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html">《Nginx本地缓存》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html">《Pagespeed—懒人工具，服务器端加速》</a></li></ul><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html">《浏览器端缓存》</a><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w">《H5 和移动端 WebView 缓存机制解析与实战》</a></li></ul><h2 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/Memcached/Memcached-tutorial.html">《Memcached 教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chenleixing/article/details/47035453">《深入理解Memcached原理》</a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/36e5cd400580">《Memcached软件工作原理》</a></li><li><a href="https://link.juejin.im/?target=http://zhihuzeye.com/archives/2361">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/liu251890347/article/details/37690045">《memcache 中 add 、 set 、replace 的区别》</a><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%2520Login%2520Sucess&&bduss=&ssnerror=0&traceid="><strong>《memcached全面剖析》</strong></a></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/redis/redis-tutorial.html">《Redis 教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wcf373722432/article/details/78678504">《redis底层原理》</a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><a href="https://link.juejin.im/?target=http://doc.redisfans.com/topic/persistence.html">《Redis持久化方式》</a><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chunlongyu/article/details/53346436">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/sunhuiliang85/article/details/73656830">《Redis单线程架构》</a></li></ul><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_29108585/article/details/63251491">《redis的回收策略》</a></li></ul><h3 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a>Tair</h3><ul><li><a href="https://link.juejin.im/?target=https://github.com/alibaba/tair">官方网站</a></li><li><a href="https://link.juejin.im/?target=http://blog.csdn.net/farphone/article/details/53522383">《Tair和Redis的对比》</a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/charlesblc/p/6045238.html">《消息队列-推&#x2F;拉模式学习 &amp; ActiveMQ及JMS学习》</a><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yunfeng482/article/details/72856762">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yanghua_kobe/article/details/43877281">《消息总线VS消息队列》</a></li></ul><h3 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cjsblog/p/8267892.html">《如何保证消费者接收消息的顺序》</a></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whoamiyang/article/details/54954780">《RabbitMQ的应用场景以及基本原理介绍》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/79ca08116d57">《消息队列之 RabbitMQ》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u013256816/article/details/55515234">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/824066d70da8">《RocketMQ 实战之快速入门》</a></li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wintersun/p/3962302.html">《ActiveMQ消息队列介绍》</a></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p><ul><li><a href="https://link.juejin.im/?target=http://kafka.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/allthesametome/article/details/47362451">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li><li><a href="https://link.juejin.im/?target=http://lxw1234.com/archives/2015/10/538.htm">《Kafka分区机制介绍与示例》</a></li></ul><h3 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_34212276/article/details/78455004">《Redis学习笔记之十：Redis用作消息队列》</a></li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><p>TODO</p><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><h3 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a>单机定时调度</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shuaiqing/p/7742382.html">《linux定时任务cron配置》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/daquan/blog/483305">《Linux cron运行原理》</a><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/drift-ice/p/3817269.html">《Quartz使用总结》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wenniuwuren/article/details/42082981/">《Quartz源码解析 —- 触发器按时启动原理》</a></li><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/bab8e4e32952">《quartz原理揭秘和源码解读》</a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h3 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a>分布式定时调度</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_16216221/article/details/70314337">《这些优秀的国产分布式任务调度系统，你用过几个？》</a><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html">《Quartz任务调度的基本实现原理》</a><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的</li></ul></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/top_code/article/details/54615853">《从零开始实现RPC框架 - RPC原理及实现》</a><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/testcs_dn/article/details/78050590">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></li></ul><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li><a href="https://link.juejin.im/?target=http://dubbo.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/steven520213/p/7606598.html">dubbo实现原理简单介绍</a></li></ul><p>** SPI ** TODO</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><ul><li><a href="https://link.juejin.im/?target=http://thrift.apache.org/">官方网站</a></li><li>《Thrift RPC详解》<ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a href="https://link.juejin.im/?target=https://grpc.io/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/LBSer/p/4853234.html">《你应该知道的RPC原理》</a></li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><h3 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a>Sharding Jdbc</h3><ul><li><a href="https://link.juejin.im/?target=http://shardingjdbc.io/">官网</a></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a>日志搜集</h3><ul><li><a href="https://link.juejin.im/?target=http://cjting.me/misc/build-log-system-with-elkb/">《从零开始搭建一个ELKB日志收集系统》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lzw_2006/article/details/51280058">《用ELK搭建简单的日志收集分析系统》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/beginmind/p/6058194.html">《日志收集系统-探究》</a></li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com/ctripcorp/apollo">Apollo - 携程开源的配置中心应用</a><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011320740/article/details/78742625">《基于zookeeper实现统一配置管理》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shamo89/p/8016908.html">《 Spring Cloud Config 分布式配置中心使用教程》</a></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/dogdogwang/p/7151866.html">《servlet3.0 新特性——异步处理》</a></li></ul><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a href="https://link.juejin.im/?target=http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/">《API网关那些儿》</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo">《谈API网关的背景、架构以及落地方案》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhanglh046/article/details/78651993">《使用Zuul构建API Gateway》</a></li><li><a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A">《HTTP API网关选择之一Kong介绍》</a></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/Robin-YB/p/6668762.html">《OSI七层协议模型、TCP&#x2F;IP四层模型学习笔记》</a></li></ul><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/onepixel/p/7092302.html">《深入浅出 TCP&#x2F;IP 协议》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/whuslei/article/details/6667471/">《TCP协议中的三次握手和四次挥手》</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wangning528/p/6388464.html">《http协议详解(超详细)》</a></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhuyiquan/article/details/69257126">《HTTP 2.0 原理详细分析》</a></li><li>《HTTP2.0的基本单位为二进制帧》<ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhangshitong/p/6478721.html">《https原理通俗了解》</a><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/enweitech/article/details/53213862">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/litaotao/1289790">《web优化必须了解的原理之I&#x2F;o的五种模型和web的三种工作模式》</a><ul><li>五种I&#x2F;O模型：阻塞I&#x2F;O，非阻塞I&#x2F;O，I&#x2F;O复用、事件(信号)驱动I&#x2F;O、异步I&#x2F;O，前四种I&#x2F;O属于同步操作，I&#x2F;O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/Anker/p/3265058.html">《select、poll、epoll之间的区别总结》</a><ul><li>select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><a href="https://link.juejin.im/?target=http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/">《select，poll，epoll比较 》</a><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/geason/p/5774096.html">《深入理解Java NIO》</a><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/skiof007/article/details/52873421">《BIO与NIO、AIO的区别》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u013074465/article/details/46276967">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html">《epoll使用详解（精髓）》</a></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/geason/p/5774096.html">《深入理解Java NIO》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xidianliuy/article/details/51612676">《Java NIO编写Socket服务器的一个例子》</a></li></ul><h3 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/luminocean/p/5631336.html">《kqueue用法简介》</a></li></ul><h2 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a>连接和短连接</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/pangguoping/p/5571422.html">《TCP&#x2F;IP系列——长连接与短连接的区别》</a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li>《Netty原理剖析》<ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h2 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a>零拷贝（Zero-copy）</h2><ul><li>《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》<ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h2 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a>序列化(二进制协议)</h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/happyday56/p/4268249.html">《Hessian原理分析》</a> Binary-RPC;不仅仅是序列化</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/antgan/article/details/52103966">《Protobuf协议的Java应用例子》</a> Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。</li><li><a href="https://link.juejin.im/?target=https://worktile.com/tech/share/prototol-buffers">《Protocol Buffers序列化协议及应用》</a><ul><li>关于协议的解释；缺点：可读性差;</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/eric520zenobia/article/details/53766571">《简单的使用 protobuf 和 protostuff》</a><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h3><ul><li>《数据库的三大范式以及五大约束》<ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://link.juejin.im/?target=http://www.admin10000.com/document/5372.html">《MySQL的InnoDB索引原理详解》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xifeijian/article/details/20316775">《MySQL存储引擎－－MyISAM与InnoDB区别》</a><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.2cto.com/database/201211/172380.html">《myisam和innodb索引实现的不同》</a></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><a href="https://link.juejin.im/?target=https://my.oschina.net/kailuncen/blog/1504217">《一篇文章带你读懂Mysql和InnoDB》</a></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><a href="https://link.juejin.im/?target=http://vdisk.weibo.com/s/muWOT">《MySQL36条军规》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhouyusheng/p/8038224.html">《MYSQL性能优化的最佳20+条经验》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/when_less_is_more/article/details/70187459">《SQL优化之道》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/sivkun/p/7518540.html">《mysql数据库死锁的产生原因及解决办法》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/monkey_d_feilong/article/details/52291556">《导致索引失效的可能情况》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zy_281870667/article/details/51604540">《 MYSQL分页limit速度太慢优化方法》</a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a>聚集索引, 非聚集索引</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/no_endless/article/details/77073549">《MySQL 聚集索引&#x2F;非聚集索引简述》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zlcxbb/p/5757245.html">《MyISAM和InnoDB的索引实现》</a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/summer0space/p/7247778.html">《复合索引的优点和注意事项》</a></li></ul><h4 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a>自适应哈希索引(AHI)</h4><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/Linux_ever/article/details/62043708">《InnoDB存储引擎——自适应哈希索引》</a></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000008131735">《MySQL 性能优化神器 Explain 使用分析》</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li><a href="https://link.juejin.im/?target=http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程</a></li><li>《Mongodb相对于关系型数据库的优缺点》<ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><ul><li><a href="https://link.juejin.im/?target=http://www.thebigdata.cn/HBase/35831.html">《简明 HBase 入门教程（开篇）》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/qiaoyihang/p/6246424.html">《深入学习HBase架构原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/youzhouliu/article/details/67632882">《传统的行存储和（HBase）列存储的区别》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lifuxiangcaohui/article/details/39891099">《Hbase与传统数据库的区别》</a><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u014091123/article/details/73163088">《HBase Rowkey设计》</a><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h2><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/0193dc44135b">《倒排索引–搜索引擎入门》</a></li></ul><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/rodge-run/p/6551152.html">《Lucene入门简介》</a></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/laoyang360/article/details/52244917">《Elasticsearch学习，请先看这一篇！》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/cyony/article/details/65437708">《Elasticsearch索引原理》</a></li></ul><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011936655/article/details/51960005">《 Apache Solr入门教程》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/convict_eva/article/details/53537837">《elasticsearch与solr比较》</a></li></ul><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h2><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/101672/">《Sphinx 的介绍和原理探索》</a></li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread">《15天的性能优化工作，5方面的调优经验》</a><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/tenglizhe/article/details/44563135">《系统性能优化的几个方面》</a></li></ul><h2 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012528360/article/details/70054156">《联网性能与容量评估的方法论和典型案例》</a></li></ul><h2 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a>CDN 网络</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wxiaona/p/5867685.html">《CDN加速原理》</a></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/20536932">《国内有哪些比较好的 CDN？》</a></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/fysuccess/article/details/66972554">《主流Java数据库连接池比较与开发配置实战》</a></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yethyeth/article/details/73266455">《九大Java性能调试工具，必备至少一款》</a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h2><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ul><li><a href="https://link.juejin.im/?target=http://storm.apache.org/">官方网站</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/uisoul/article/details/77989927">《最详细的Storm入门教程》</a></li></ul><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/lisi1129/article/details/54844919">《Flink之一 Flink基本原理介绍》</a></li></ul><h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h3><ul><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/58382">《Kafka Stream调研：一种轻量级流计算模式》</a></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/houbin0912/article/details/72967178">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li><li><a href="https://link.juejin.im/?target=http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html">《史上最详细的Hadoop环境搭建》</a></li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul><li><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000011575458">《【Hadoop学习】HDFS基本原理》</a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/oppo62258801/article/details/72884633">《用通俗易懂的大白话讲解Map&#x2F;Reduce原理》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/foye12/article/details/78358292">《 简单的map-reduce的java例子》</a></li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/codeOfLife/p/5492740.html">《初步掌握Yarn的架构及原理》</a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/tgzhu/p/5818374.html">《Spark(一): 基本架构及原理》</a></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/qq_21956483/article/details/54377947">《xss攻击原理与解决方法》</a></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html">《CSRF原理及防范》</a></li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html">《SQL注入》</a></li></ul><h3 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a>Hash Dos</h3><ul><li>《邪恶的JAVA HASH DOS攻击》<ul><li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/92194?t=t1">《一种高级的DoS攻击-Hash碰撞攻击》</a></li><li><a href="https://link.juejin.im/?target=http://www.iteye.com/news/23939/">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li></ul><h3 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html">《上传文件漏洞原理及防范》</a></li></ul><h3 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html">《DVWA》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html">W3af</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/xygg0801/article/details/53610640">OpenVAS详解</a></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/niaonao/article/details/51112686">《验证码原理分析及实现》</a></li><li><a href="https://link.juejin.im/?target=https://my.oschina.net/jiangbianwanghai/blog/1031031">《详解滑动验证码的实现原理》</a><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/xcj26/p/5242758.html">《淘宝滑动验证码研究》</a></li></ul><h2 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a>DDoS 防范</h2><ul><li><a href="https://link.juejin.im/?target=http://netsecurity.51cto.com/art/201601/503799.htm">《学习手册：DDoS的攻击方式及防御手段》</a></li><li><a href="https://link.juejin.im/?target=http://netsecurity.51cto.com/art/201406/442756.htm">《免费DDoS攻击测试工具大合集》</a></li></ul><h2 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a>用户隐私信息保护</h2><ol><li>用户密码非明文保存，加动态slat。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a href="https://link.juejin.im/?target=https://zhidao.baidu.com/question/1988017976673661587.html">《个人隐私包括哪些》</a></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/20137108">《在互联网上，隐私的范围包括哪些？》</a></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html">《用户密码保存》</a></li></ul><h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/">《Lib之过？Java反序列化漏洞通用利用分析》</a></li></ul><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>《常见对称加密算法》<ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html">《常用的哈希算法》</a><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/zhangruhong168/article/details/78033202">《基于Hash摘要签名的公网URL签名验证设计方案》</a></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p>《常见非对称加密算法》</p><ul><li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p></li><li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p></li><li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p><p><a href="https://link.juejin.im/?target=http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc">《区块链的加密技术》</a></p></li></ul></li></ul><h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><ul><li><a href="https://link.juejin.im/?target=http://www.freebuf.com/articles/system/121540.html">《Linux强化论：15步打造一个安全的Linux服务器》</a></li></ul><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>TODO</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><h3 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a>内外网分离</h3><p>TODO</p><h3 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/zero01/2062618">《搭建简易堡垒机》</a></li></ul><h2 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a>授权、认证</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zq8024/p/5003050.html">《基于组织角色的权限设计》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/shijiaqi1066/p/3793894.html">《权限系统与RBAC模型概述》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/he90227/article/details/38663553">《Spring整合Shiro做权限控制模块详细案例分析》</a></li></ul><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">《理解OAuth 2.0》</a></li></ul><h3 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html">www.ruanyifeng.com/blog/2017/1…</a>)</li></ul><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a>单点登录(SSO)</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/ywlaker/p/6113927.html">《单点登录原理与简单实现》</a></li><li><a href="https://link.juejin.im/?target=https://github.com/apereo/cas">CAS单点登录框架</a></li></ul><h1 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h1><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html">《开源协议的选择》</a></li></ul><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h3 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a>Log4j、Log4j2</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u012422446/article/details/51199724">《log4j 详细讲解》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/vbirdbest/article/details/71751835">《log4j2 实际使用详解》</a></li><li>《Log4j1,Logback以及Log4j2性能测试对比》<ul><li>Log4J 异步日志性能优异。</li></ul></li></ul><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/rulon147/article/details/52620541">《最全LogBack 详解、含java案例和配置说明》</a></li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ul><li>《ORM框架使用优缺点》<ul><li>主要目的是为了提高开发效率。</li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/winclpt/articles/7511672.html">《mybatis缓存机制详解》</a><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/baidu_32877851/article/details/53959268">《MyBatis学习之代码生成器Generator》</a></li></ul><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>TODO</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h2><h3 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a>Spring 家族</h3><p><strong>Spring</strong></p><ul><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/wkspring/">Spring 简明教程</a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a href="https://link.juejin.im/?target=http://projects.spring.io/spring-boot/">官方网站</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/Spring-Boot%25E5%259F%25BA%25E7%25A1%2580%25E6%2595%2599%25E7%25A8%258B/">《Spring Boot基础教程》</a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a href="https://link.juejin.im/?target=http://springboot.fun/">Spring Boot 中文索引站</a></li><li><a href="https://link.juejin.im/?target=https://springcloud.cc/">Spring Cloud 中文文档</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/Spring-Cloud%25E5%259F%25BA%25E7%25A1%2580%25E6%2595%2599%25E7%25A8%258B/">《Spring Cloud基础教程》</a></li></ul><h2 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h2><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/crazylqy/p/4872236.html">《Apache Commons 工具类介绍及简单使用》</a></li><li><a href="https://link.juejin.im/?target=http://ifeve.com/google-guava/">《Google guava 中文教程》</a></li></ul><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hemin1003/article/details/53633926">《架构师不可不知的十大可扩展架构》</a><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。</li></ul></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/38119">《可扩展性设计之数据切分》</a><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/deniro_li/article/details/78458306">《说说如何实现可扩展性的大型网站架构》</a><ul><li>分布式服务+消息队列。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/chaofanwei/article/details/29191073">《大型网站技术架构（七）–网站的可扩展性架构》</a></li></ul><h2 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a>稳定性 &amp; 高可用</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hustspy1990/article/details/78008324">《系统设计：关于高可用系统的一些技术方案》</a><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coolshell.cn/articles/17459.html">《关于高可用的系统》</a><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。</li></ul></li></ul><h3 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/wuyun-blog/p/6186198.html">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a><ul><li>主要是和F5对比。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lcword/p/5773296.html">《软&#x2F;硬件负载均衡产品 你知多少？》</a></li></ul><h3 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/tianzhiliang/articles/2317808.html">《几种负载均衡算法》</a> 轮寻、权重、负载、最少连接、QoS</li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html">《DNS负载均衡》</a><ul><li>配置简单，更新速度慢。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html">《Nginx负载均衡》</a><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/edisonchou/p/4281978.html">《借助LVS+Keepalived实现负载均衡 》</a><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.ttlsa.com/linux/haproxy-study-tutorial/">《HAProxy用法详解 全网最详细中文文档》</a><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><a href="https://link.juejin.im/?target=http://blog.itpub.net/25704976/viewspace-1319781/">《Haproxy+Keepalived+MySQL实现读均衡负载》</a><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/lylife/p/5584019.html">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>《谈谈高并发系统的限流》<ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li></ul></li></ul><h3 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a>应用层容灾</h3><ul><li><p><a href="https://link.juejin.im/?target=https://segmentfault.com/a/1190000005988895">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p></li><li><p>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。</p></li><li><p>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</p></li><li><p>Hystrix设计原则：</p><ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 &#x3D; 请求失败数 &#x2F; 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。</li></ul></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/zeb_perfect/article/details/54135506">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/zeb_perfect/article/details/54135506">《缓存击穿、失效以及热点key问题》</a></p><ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul><h3 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a>跨机房容灾</h3><ul><li><a href="https://link.juejin.im/?target=http://dc.idcquan.com/ywgl/71559.shtml">《“异地多活”多机房部署经验谈》</a><ul><li>通过自研中间件进行数据同步。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/jeffreynicole/article/details/48135093">《异地多活（异地双活）实践经验》</a><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。</li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/yoara/article/details/38013751">容灾技术及建设经验介绍</a></li></ul><h3 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a>容灾演练流程</h3><ul><li>《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》<ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h3 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a>平滑启动</h3><ul><li>平滑重启应用思路 1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u011001084/article/details/73480432">《JVM安全退出（如何优雅的关闭java服务）》</a> 推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li><li><a href="https://link.juejin.im/?target=http://ju.outofmemory.cn/entry/337235">《常见Java应用如何优雅关闭》</a> Java、Srping、Dubbo 优雅关闭方式。</li></ul><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h3 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a>读写分离模式</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/houdj/p/6563771.html">《Mysql主从方案的实现》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/edisonchou/p/4133148.html">《搭建MySQL主从复制经典架构》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/nimasike/article/details/48048341">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zhangsubai/p/6801764.html">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a><ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html">《MySQL Cluster 方式》</a></li></ul><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h3><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/32b3e91aa22c">《分库分表需要考虑的问题及方案》</a><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.2cto.com/database/201503/380348.html">《MySql分表和表分区详解》</a><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/jiaolongdy/article/details/51188798">《永不失联！如何实现微服务架构中的服务发现？》</a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u010963948/article/details/71730165">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><a href="https://link.juejin.im/?target=http://mobile.51cto.com/news-502394.htm">《基于Zookeeper的服务注册与发现》</a><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。</li></ul></li></ul><h3 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a>服务路由控制</h3><ul><li>《分布式服务框架学习笔记4 服务路由》<ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h2 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a>分布式一致</h2><h3 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a>CAP 与 BASE 理论</h3><ul><li>《从分布式一致性谈到CAP理论、BASE理论》<ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><p> 分布式锁</p><ul><li><a href="https://link.juejin.im/?target=http://www.hollischuang.com/archives/1716">《分布式锁的几种实现方式》</a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.tuicool.com/articles/VZJr6fY">《基于Zookeeper的分布式锁》</a><ul><li>清楚的原理描述 + Java 代码示例。</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/0201zcr/p/5942748.html">《jedisLock—redis分布式锁实现》</a><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/albertfly/article/details/77412333">《Memcached 和 Redis 分布式锁方案》</a><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><h4 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h4><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/linbingdong/p/6253479.html">《分布式系列文章——Paxos算法原理与推导》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/u010039929/article/details/70171672">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/leesf456/p/6012777.html">《【分布式】Zookeeper与Paxos》</a></li></ul><h4 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h4><ul><li><a href="https://link.juejin.im/?target=https://www.jianshu.com/p/fb527a64deee">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li></ul><h4 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h4><ul><li>《Raft 为什么是更易理解的分布式一致性算法》<ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><ul><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/tianya23/530743">《Gossip算法》</a></li></ul><h4 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a>两阶段提交、多阶段提交</h4><ul><li><a href="https://link.juejin.im/?target=http://blog.jobbole.com/95632/">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li></ul><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ul><li>《分布式系统—幂等性设计》<ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。</li></ul></li></ul><h3 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a>分布式一致方案</h3><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency">《分布式系统事务一致性解决方案》</a></li><li><a href="https://link.juejin.im/?target=https://weibo.com/ttarticle/p/show?id=2309403965965003062676">《保证分布式系统数据一致性的6种方案》</a></li></ul><h3 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a>分布式 Leader 节点选举</h3><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/johnson_moon/article/details/78809995">《利用zookeeper实现分布式leader节点选举》</a></li></ul><h3 id="TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务"><a href="#TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务" class="headerlink" title="TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务"></a>TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务</h3><ul><li>《传统事务与柔性事务》<ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><ul><li><p><a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/27666295">说说分布式文件存储系统-基本架构</a> ？</p></li><li><p>《各种分布式文件系统的比较》</p><ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h2 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a>唯一ID 生成</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/baiwa/p/5318432.html">《高并发分布式系统中生成全局唯一Id汇总》</a><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();”</li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/hdu09075340/article/details/79103851">《TDDL 在分布式下的SEQUENCE原理》</a><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><ul><li><a href="https://link.juejin.im/?target=https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html">《一致性哈希算法》</a></li></ul><h1 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a>设计思想 &amp; 开发模式</h1><h2 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><hr><p><a href="https://link.juejin.im/?target=https://www.cnblogs.com/netfocus/p/5548025.html">《浅谈我对DDD领域驱动设计的理解》</a></p><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul><p><a href="https://link.juejin.im/?target=https://www.cnblogs.com/butterfly100/p/7827870.html">《领域驱动设计的基础知识总结》</a></p><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面&#x2F;展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/Leo_wl/p/3866629.html">《领域驱动设计(DDD)实现之路》</a><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.hollischuang.com/archives/553">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></li></ul><h3 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/cnblogsfans/p/4551990.html">《领域驱动设计系列 (六)：CQRS》</a><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml">《DDD CQRS架构和传统架构的优缺点比较》</a><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.cnblogs.com/netfocus/p/4055346.html">《CQRS架构简介》</a><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.uml.org.cn/zjjs/201609221.asp">《深度长文：我对CQRS&#x2F;EventSourcing架构的思考》</a><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a>贫血，充血模型</h3><ul><li>《贫血，充血模型的解释以及一些经验》<ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a>Actor 模式</h2><p>TODO</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>TODO</p><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><p>TODO</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h3><p>TODO</p><p> DODAF2.0</p><ul><li><a href="https://link.juejin.im/?target=http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml">《DODAF2.0方法论》</a></li><li><a href="https://link.juejin.im/?target=http://blog.51cto.com/xiaoyong/1553164">《DODAF2.0之能力视角如何落地》</a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>TODO</p><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p>TODO</p><ul><li><a href="https://link.juejin.im/?target=https://time.geekbang.org/article/2355">《什么是Service Mesh？》</a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a>架构评审</h2><ul><li><a href="https://link.juejin.im/?target=http://developer.51cto.com/art/201506/478486.htm">《架构设计之如何评审架构设计说明书》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/wireless_com/article/details/45935591">《人人都是架构师：非功能性需求》</a></li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/architect-12-rules-complete/">《架构之重构的12条军规》</a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>TODO</p><h2 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h2><p>制度还是制度! 另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><a href="https://link.juejin.im/?target=http://www.sohu.com/a/229745352_181657">《为什么你做不好 Code Review？》</a><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/uxyheaven/article/details/49773619">《从零开始Code Review》</a></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com/zuoping/p/5477047.html">《Code Review Checklist》</a></li><li><a href="https://link.juejin.im/?target=https://dzone.com/articles/java-code-review-checklist">《Java Code Review Checklist》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/legend0011/article/details/45585575">《如何用 gitlab 做 code review》</a></li></ul><h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/apanious/article/details/51011946">《运用RUP 4+1视图方法进行软件架构设计》</a></li></ul><h2 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a>看板管理</h2><ul><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/tkchen/article/details/51637643">《说说看板在项目中的应用》</a></li></ul><h2 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a>SCRUM</h2><p>SCRUM - 争球</p><ul><li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li><li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li><li>五个价值观：专注、勇气、公开、承诺、尊重。</li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/inny100_100/article/details/54633757">《敏捷项目管理流程-Scrum框架最全总结！》</a></li><li><a href="https://link.juejin.im/?target=https://blog.csdn.net/superkunkun/article/details/52951142">《敏捷其实很简单3—敏捷方法之scrum》</a></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p><ul><li>《主流敏捷开发方法：极限编程XP》<ul><li>是一种指导开发人员的方法论。</li><li>4大价值：<ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a href="https://link.juejin.im/?target=http://www.baike.com/wiki/%25E7%25BB%2593%25E5%25AF%25B9%25E7%25BC%2596%25E7%25A8%258B">《结对编程》</a></li></ul><h2 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a>FMEA管理模式</h2><p>TODO</p><h1 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a>通用业务术语</h1><p>TODO</p><h1 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h1><p>TODO</p><h1 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a>政策、法规</h1><p>TODO</p><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h2><h3 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p><blockquote><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。</li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul></blockquote><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a href="https://link.juejin.im/?target=https://baike.baidu.com/item/%25E9%259D%259E%25E6%25B3%2595%25E8%258E%25B7%25E5%258F%2596%25E5%2585%25AC%25E6%25B0%2591%25E4%25B8%25AA%25E4%25BA%25BA%25E4%25BF%25A1%25E6%2581%25AF%25E7%25BD%25AA">《非法获取公民个人信息罪》</a></li></ul><h1 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a>架构师素质</h1><ul><li><p><a href="https://link.juejin.im/?target=http://hellojava.info/?p=430">《架构师画像》</a></p><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；</li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><p><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know">《关于架构优化和设计，架构师必须知道的事情》</a></p><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依懒、注意服务之间依懒所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。</li></ul></li><li><p><a href="https://link.juejin.im/?target=https://www.zhihu.com/question/19841397">《如何才能真正的提高自己，成为一名出色的架构师？》</a></p></li><li><p><a href="https://link.juejin.im/?target=https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129">《架构师的必备素质和成长途径》</a></p><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和祖内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。</li></ul></li><li><p><a href="https://link.juejin.im/?target=http://blog.51cto.com/frankfan/1248401">《架构设计师—你在哪层楼？》</a></p><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值</li></ul></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h1><p>TODO</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><h2 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a>行业资讯</h2><ul><li><a href="https://link.juejin.im/?target=http://36kr.com/">36kr</a></li><li><a href="https://link.juejin.im/?target=http://www.techweb.com.cn/">Techweb</a></li></ul><h2 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a>公众号列表</h2><p>TODO</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h3><ul><li><a href="https://link.juejin.im/?target=http://jm.taobao.org/">阿里中间件博客</a></li><li><a href="https://link.juejin.im/?target=https://tech.meituan.com">美团点评技术团队博客</a></li></ul><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><ul><li><a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/">阮一峰的网络日志</a></li><li><a href="https://link.juejin.im/?target=https://coolshell.cn/">酷壳 - COOLSHELL-陈皓</a></li><li><a href="https://link.juejin.im/?target=http://hellojava.info/">hellojava-阿里毕玄</a></li><li><a href="https://link.juejin.im/?target=http://cmsblogs.com/">Cm’s Blog</a></li><li><a href="https://link.juejin.im/?target=http://blog.didispace.com/">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li></ul><h2 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a>综合门户、社区</h2><p><strong>国内：</strong></p><ul><li><a href="https://link.juejin.im/?target=http://csdn.net">CSDN</a> 老牌技术社区、不必解释。</li><li><a href="https://link.juejin.im/?target=http://www.51cto.com/">51cto.com</a></li><li><a href="https://link.juejin.im/?target=http://www.iteye.com/">ITeye</a><ul><li>偏 Java 方向</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.cnblogs.com">博客园</a></li><li><a href="https://link.juejin.im/?target=http://www.tom.net/">ChinaUnix</a><ul><li>偏 Linux 方向</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.oschina.net/">开源中国社区</a></li><li><a href="https://link.juejin.im/?target=http://www.open-open.com/">深度开源</a></li><li><a href="https://link.juejin.im/?target=http://www.jobbole.com/">伯乐在线</a><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.itpub.net/">ITPUB</a></li><li><a href="https://link.juejin.im/?target=https://cloud.tencent.com/developer/column">腾讯云— 云+社区</a></li><li><a href="https://link.juejin.im/?target=https://yq.aliyun.com/">阿里云— 云栖社区</a></li><li><a href="https://link.juejin.im/?target=https://www.ibm.com/developerworks/cn/">IBM DeveloperWorks</a></li><li><a href="https://link.juejin.im/?target=https://toutiao.io/">开发者头条</a></li><li><a href="https://link.juejin.im/?target=http://www.linkedkeeper.com">LinkedKeeper</a></li></ul><p><strong>国外：</strong></p><ul><li><a href="https://link.juejin.im/?target=https://dzone.com">DZone</a></li><li><a href="https://link.juejin.im/?target=https://www.reddit.com">Reddit</a></li></ul><h2 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a>问答、讨论类社区</h2><ul><li>segmentfault<ul><li>问答+专栏</li></ul></li><li><a href="https://link.juejin.im/?target=https://www.zhihu.com/">知乎</a></li><li><a href="https://link.juejin.im/?target=https://stackoverflow.com/">stackoverflow</a></li></ul><h2 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a>行业数据分析</h2><ul><li><a href="https://link.juejin.im/?target=http://report.iresearch.cn/">艾瑞网</a></li><li><a href="https://link.juejin.im/?target=https://www.questmobile.com.cn">QUEST MOBILE</a></li><li><a href="https://link.juejin.im/?target=http://data.stats.gov.cn/">国家数据</a></li></ul><h2 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a>专项网站</h2><ul><li>测试:<ul><li><a href="https://link.juejin.im/?target=http://www.ltesting.net/">领测国际</a></li><li><a href="https://link.juejin.im/?target=https://www.testwo.com/">测试窝</a></li><li><a href="https://link.juejin.im/?target=https://testerhome.com">TesterHome</a></li></ul></li><li>运维:<ul><li><a href="https://link.juejin.im/?target=http://www.yunweipai.com/">运维派</a></li><li><a href="https://link.juejin.im/?target=https://www.abcdocker.com/">Abcdocker</a></li></ul></li><li>Java:<ul><li>ImportNew<ul><li>专注于 Java 技术分享</li></ul></li><li>HowToDoInJava<ul><li>英文博客</li></ul></li></ul></li><li>安全<ul><li><a href="https://link.juejin.im/?target=https://www.2cto.com/">红黑联盟</a></li><li><a href="https://link.juejin.im/?target=http://www.freebuf.com/">FreeBuf</a></li></ul></li><li>大数据<ul><li><a href="https://link.juejin.im/?target=http://www.thebigdata.cn/">中国大数据</a></li></ul></li><li>其他专题网站：<ul><li>DockerInfo<ul><li>专注于 Docker 应用及咨询、教程的网站。</li></ul></li><li>Linux公社<ul><li>Linux 主题社区</li></ul></li></ul></li></ul><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com/TeamStuQ/skill-map">程序员技能图谱</a></li></ul><h2 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h2><h3 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a>在线电子书</h3><ul><li><a href="https://link.juejin.im/?target=https://github.com/forezp/SpringCloudLearning">《深入理解Spring Cloud与微服务构建》</a></li><li><a href="https://link.juejin.im/?target=http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf">《阿里技术参考图册-研发篇》</a></li><li><a href="https://link.juejin.im/?target=http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf">《阿里技术参考图册-算法篇》</a></li><li><a href="https://link.juejin.im/?target=http://dpurl.cn/n/1lqcX">《2018美团点评技术年货（合辑）》70M</a></li><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/architect/">InfoQ《架构师》月刊</a></li><li><a href="https://link.juejin.im/?target=https://www.w3cschool.cn/architectroad/">《架构师之路》</a></li></ul><h3 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h3><h4 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h4><ul><li>《阿里巴巴Java开发手册》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=bVKwZQ">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E9%2598%25BF%25E9%2587%258C%25E5%25B7%25B4%25E5%25B7%25B4Java%25E5%25BC%2580%25E5%258F%2591%25E6%2589%258B%25E5%2586%258C">淘宝</a></li></ul><h4 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h4><ul><li>《软件架构师的12项修炼：技术技能篇》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=gXvRd8">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E8%25BD%25AF%25E4%25BB%25B6%25E6%259E%25B6%25E6%259E%2584%25E5%25B8%2588%25E7%259A%258412%25E9%25A1%25B9%25E4%25BF%25AE%25E7%2582%25BC%25EF%25BC%259A%25E6%258A%2580%25E6%259C%25AF%25E6%258A%2580%25E8%2583%25BD%25E7%25AF%2587">淘宝</a></li><li>《架构之美》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=xJit5I">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%259E%25B6%25E6%259E%2584%25E4%25B9%258B%25E7%25BE%258E">淘宝</a></li><li>《分布式服务架构》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=JS5Od9">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E6%259C%258D%25E5%258A%25A1%25E6%259E%25B6%25E6%259E%2584">淘宝</a></li><li>《聊聊架构》 <a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=FHooH4">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E8%2581%258A%25E8%2581%258A%25E6%259E%25B6%25E6%259E%2584">淘宝</a></li><li>《云原生应用架构实践》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=orkJSj">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BA%2591%25E5%258E%259F%25E7%2594%259F%25E5%25BA%2594%25E7%2594%25A8%25E6%259E%25B6%25E6%259E%2584%25E5%25AE%259E%25E8%25B7%25B5">淘宝</a></li><li>《亿级流量网站架构核心技术》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=RnOSP5">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BA%25BF%25E7%25BA%25A7%25E6%25B5%2581%25E9%2587%258F%25E7%25BD%2591%25E7%25AB%2599%25E6%259E%25B6%25E6%259E%2584%25E6%25A0%25B8%25E5%25BF%2583%25E6%258A%2580%25E6%259C%25AF">淘宝</a></li><li>《淘宝技术这十年》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=LwrDfD">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%25B7%2598%25E5%25AE%259D%25E6%258A%2580%25E6%259C%25AF%25E8%25BF%2599%25E5%258D%2581%25E5%25B9%25B4">淘宝</a></li><li>《企业IT架构转型之道-中台战略思想与架构实战》 <a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=89pAEm">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E4%25BC%2581%25E4%25B8%259AIT%25E6%259E%25B6%25E6%259E%2584%25E8%25BD%25AC%25E5%259E%258B%25E4%25B9%258B%25E9%2581%2593">淘宝</a></li></ul><h4 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a>技术管理方面</h4><ul><li>《CTO说》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=zhTZyr">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=CTO%25E8%25AF%25B4">淘宝</a></li><li>《技术管理之巅》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=LgRBUW">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%258A%2580%25E6%259C%25AF%25E7%25AE%25A1%25E7%2590%2586%25E4%25B9%258B%25E5%25B7%2585">淘宝</a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=jcRz2r">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E7%25BD%2591%25E6%2598%2593%25E4%25B8%2580%25E5%258D%2583%25E9%259B%25B6%25E4%25B8%2580%25E5%25A4%259C%25EF%25BC%259A%25E4%25BA%2592%25E8%2581%2594%25E7%25BD%2591%25E4%25BA%25A7%25E5%2593%2581%25E9%25A1%25B9%25E7%259B%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%25AE%259E%25E6%2588%2598">淘宝</a></li></ul><h4 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h4><ul><li>《数学之美》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=ghIES2">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E6%2595%25B0%25E5%25AD%25A6%25E4%25B9%258B%25E7%25BE%258E">淘宝</a></li><li>《编程珠玑》<a href="https://link.juejin.im/?target=https://union-click.jd.com/jdc?d=YmhdEu">京东</a> <a href="https://link.juejin.im/?target=https://s.taobao.com/search?q=%25E7%25BC%2596%25E7%25A8%258B%25E7%258F%25A0%25E7%258E%2591">淘宝</a></li></ul><h4 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h4><p>TODO</p><h4 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a>大数据方面</h4><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h1><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h2><ul><li><a href="https://link.juejin.im/?target=https://github.com">github</a></li><li><a href="https://link.juejin.im/?target=https://www.apache.org/index.html">Apache 软件基金会</a></li></ul><h2 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a>手册、文档、教程</h2><p><strong>国内：</strong></p><ul><li><a href="https://link.juejin.im/?target=http://w3cschool.cn">W3Cschool</a></li><li><a href="https://link.juejin.im/?target=http://www.runoob.com/">Runoob.com</a><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><a href="https://link.juejin.im/?target=https://love2.io/">Love2.io</a><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a href="https://link.juejin.im/?target=http://gitbook.cn/">gitbook.cn</a><ul><li>付费电子书。</li></ul></li><li><a href="https://link.juejin.im/?target=http://www.apachecn.org/">ApacheCN</a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li>Quick Code<ul><li>免费在线技术教程。</li></ul></li><li>gitbook.com<ul><li>有部分中文电子书。</li></ul></li><li>Cheatography<ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li></ul><h2 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a>在线课堂</h2><ul><li><a href="https://link.juejin.im/?target=http://www.xuetuwuyou.com/">学徒无忧</a></li><li><a href="https://link.juejin.im/?target=https://time.geekbang.org/">极客时间</a></li><li><a href="https://link.juejin.im/?target=https://segmentfault.com/lives">segmentfault</a></li><li><a href="https://link.juejin.im/?target=https://new.stuq.org/course/explore">斯达克学院</a></li><li><a href="https://link.juejin.im/?target=http://nowcoder.com">牛客网</a></li><li><a href="https://link.juejin.im/?target=https://www.jikexueyuan.com/">极客学院</a></li><li><a href="https://link.juejin.im/?target=http://edu.51cto.com/">51CTO学院</a></li></ul><h2 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a>会议、活动</h2><ul><li><a href="https://link.juejin.im/?target=http://www.infoq.com/cn/qcon/">QCon</a></li><li><a href="https://link.juejin.im/?target=https://archsummit.com">ArchSummit</a></li><li><a href="https://link.juejin.im/?target=http://www.thegitc.com/">GITC全球互联网技术大会</a></li></ul><p><strong>活动发布平台:</strong></p><ul><li><a href="https://link.juejin.im/?target=http://www.huodongxing.com/">活动行</a></li></ul><h2 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a>常用APP</h2><ul><li><a href="https://link.juejin.im/?target=https://time.geekbang.org">极客时间</a></li><li><a href="https://link.juejin.im/?target=https://www.igetget.com">得到</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><ul><li><a href="https://link.juejin.im/?target=https://www.zhipin.com">Boss直聘</a></li><li><a href="https://link.juejin.im/?target=https://www.lagou.com">拉勾网</a></li><li><a href="https://link.juejin.im/?target=https://www.liepin.com">猎聘</a></li><li><a href="https://link.juejin.im/?target=https://cn.100offer.com/">100Offer</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>极客搜索<ul><li>技术文章搜索引擎。</li></ul></li></ul><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h2><ul><li><a href="https://link.juejin.im/?target=https://coding.net">Coding</a></li><li><a href="https://link.juejin.im/?target=https://gitee.com/">码云</a></li></ul><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h2><ul><li>七牛</li><li>又拍云</li></ul><h2 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a>综合云服务商</h2><ul><li>阿里云</li><li>腾讯云</li><li>百度云</li><li>新浪云</li><li>金山云</li><li><a href="https://link.juejin.im/?target=https://amazonaws-china.com/cn/">亚马逊云(AWS)</a></li><li><a href="https://link.juejin.im/?target=https://cloud.google.com/?hl=zh-cn">谷歌云</a></li><li><a href="https://link.juejin.im/?target=https://azure.microsoft.com/zh-cn/">微软云</a></li></ul><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul><li><a href="https://link.juejin.im/?target=http://linode.com">Linode</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程总结</title>
      <link href="/2018/04/22/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/22/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p> 1、多线程有什么用？</p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。<strong>单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了</strong>。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p>2、创建线程的方式</p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心。</p><p>3、start()方法和run()方法的区别</p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p>4、Runnable接口和Callable接口的区别</p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future&#x2F;FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p>5、CyclicBarrier和CountDownLatch的区别</p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p>6、volatile关键字的作用</p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是<strong>Java代码–&gt;字节码–&gt;根据字节码执行对应的C&#x2F;C++代码–&gt;C&#x2F;C++代码被编译成汇编语言–&gt;和硬件电路交互</strong>，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p>7、什么是线程安全</p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p>8、Java中如何获取到线程dump文件</p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p>9、一个线程如果出现了运行时异常会怎么样</p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p><p>10、如何在两个线程之间共享数据</p><p>通过在线程之间共享对象就可以了，然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 </p><p>11、sleep方法和wait方法有什么区别</p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p>12、生产者消费者模型的作用是什么</p><p>这个问题很理论，但是很重要：</p><p>（1）<strong>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</strong>，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用</p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p>14、为什么wait()方法和notify()&#x2F;notifyAll()方法要在同步块中被调用</p><p>这是JDK强制的，wait()方法和notify()&#x2F;notifyAll()方法在调用前都必须先获得对象的锁</p><p>15、wait()方法和notify()&#x2F;notifyAll()方法在放弃对象监视器时有什么区别</p><p>wait()方法和notify()&#x2F;notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()&#x2F;notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器</strong>。</p><p>16、为什么要使用线程池</p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 </p><p>17、怎么检测一个线程是否持有对象监视器</p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着**”某条线程”指的是当前线程**。</p><p>18、synchronized和ReentrantLock的区别</p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>19、ConcurrentHashMap的并发度是什么</p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>20、ReadWriteLock是什么</p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，<strong>读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>21、FutureTask是什么</p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>22、Linux环境下如何查找哪个线程使用CPU最长</p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>23、Java编程写一个会导致死锁的程序</p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><p>24、怎么唤醒一个阻塞的线程</p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>25、不可变对象对多线程有什么帮助</p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p>26、什么是多线程的上下文切换</p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p><p>这里区分一下：</p><ol><li>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ol><p>28、Java中用到的线程调度算法是什么</p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>29、Thread.sleep(0)的作用是什么</p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>30、什么是自旋</p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p>31、什么是Java内存模型</p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了<strong>主内存和工作内存</strong>。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p>32、什么是CAS</p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：<strong>内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false</strong>。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p>33、什么是乐观锁和悲观锁</p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>34、什么是AQS</p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p>35、单例模式的线程安全性</p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：<strong>某个类的实例在多线程环境下只会被创建一次出来</strong>。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p>36、Semaphore有什么作用</p><p>Semaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n&#x3D;1，相当于变成了一个synchronized了。</p><p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）<strong>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问</strong>。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）<strong>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住</strong>。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。<strong>即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个</strong>。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p>38、线程类的构造方法、静态块是被哪个线程调用的</p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p>39、同步方法和同步块，哪个是更好的选择</p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好</strong>。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong>锁粗化</strong>的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新域名aimak.cn，挂载了婚礼互动，和博客了</title>
      <link href="/2018/04/14/%E6%9D%82%E8%AE%B0/%E6%96%B0%E5%9F%9F%E5%90%8Daimak.cn%EF%BC%8C%E6%8C%82%E8%BD%BD%E4%BA%86%E5%A9%9A%E7%A4%BC%E4%BA%92%E5%8A%A8%EF%BC%8C%E5%92%8C%E5%8D%9A%E5%AE%A2%E4%BA%86/"/>
      <url>/2018/04/14/%E6%9D%82%E8%AE%B0/%E6%96%B0%E5%9F%9F%E5%90%8Daimak.cn%EF%BC%8C%E6%8C%82%E8%BD%BD%E4%BA%86%E5%A9%9A%E7%A4%BC%E4%BA%92%E5%8A%A8%EF%BC%8C%E5%92%8C%E5%8D%9A%E5%AE%A2%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>.cc的域名不给备案了，之前备案步骤走了一些步骤了，太忙没来及完成步骤，后面直接不给.cc备案了，婚礼前，想到了做一个现场互动的东东，于是就又申请了一个新域名，aimak.cn 好吧，第一个.cn的域名，aimak(AI) ～哈</p></blockquote><p>哈哈，现场好多祝福弹幕～ 有空再整理心得撒！～ </p><ul><li><a href="http://wedding.aimak.cn/">微信端</a></li><li><a href="http://wedding.aimak.cn/wall">大屏幕</a></li></ul><p>最近又把博客搬一份到这个域名下面</p><ul><li><a href="https://blog.aimak.cn/">blog.aimak.cn</a>  支持HTTPS</li></ul><p>HTTPS 方案依然使用Let’s Encrypt</p><p>好吧，自己的服务器带宽只有1M～ 😂 </p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf 常用的th标签</title>
      <link href="/2018/03/24/java/%20thymeleaf%20%E5%B8%B8%E7%94%A8%E7%9A%84th%E6%A0%87%E7%AD%BE/"/>
      <url>/2018/03/24/java/%20thymeleaf%20%E5%B8%B8%E7%94%A8%E7%9A%84th%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>功能介绍</th><th>案例</th></tr></thead><tbody><tr><td>th:id</td><td>替换id</td><td><code>&lt;input th:id=&quot;&#39;xxx&#39; + $&#123;collect.id&#125;&quot;/&gt;</code></td></tr><tr><td>th:text</td><td>文本替换</td><td><code>&lt;p th:text=&quot;$&#123;collect.description&#125;&quot;&gt;description&lt;/p&gt;</code></td></tr><tr><td>th:utext</td><td>支持html的文本替换</td><td><code>&lt;p th:utext=&quot;$&#123;htmlcontent&#125;&quot;&gt;conten&lt;/p&gt;</code></td></tr><tr><td>th:object</td><td>替换对象</td><td><code>&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</code></td></tr><tr><td>th:value</td><td>属性赋值</td><td><code>&lt;input th:value=&quot;$&#123;user.name&#125;&quot; /&gt;</code></td></tr><tr><td>th:with</td><td>变量赋值运算</td><td><code>&lt;div th:with=&quot;isEven=$&#123;prodStat.count&#125;%2==0&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:style</td><td>设置样式</td><td><code>th:style=&quot;&#39;display:&#39; + @&#123;($&#123;sitrue&#125; ? &#39;none&#39; : &#39;inline-block&#39;)&#125; + &#39;&#39;&quot;</code></td></tr><tr><td>th:onclick</td><td>点击事件</td><td><code>th:onclick=&quot;&#39;getCollect()&#39;&quot;</code></td></tr><tr><td>th:each</td><td>属性赋值</td><td><code>tr th:each=&quot;user,userStat:$&#123;users&#125;&quot;&gt;</code></td></tr><tr><td>th:if</td><td>判断条件</td><td><code>&lt;a th:if=&quot;$&#123;userId == collect.userId&#125;&quot; &gt;</code></td></tr><tr><td>th:unless</td><td>和th:if判断相反</td><td><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt;</code></td></tr><tr><td>th:href</td><td>链接地址</td><td><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td>th:switch</td><td>多路选择 配合th:case 使用</td><td><code>&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</code></td></tr><tr><td>th:case</td><td>th:switch的一个分支</td><td><code>&lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt;</code></td></tr><tr><td>th:fragment</td><td>布局标签，定义一个代码片段，方便其它地方引用</td><td><code>&lt;div th:fragment=&quot;alert&quot;&gt;</code></td></tr><tr><td>th:include</td><td>布局标签，替换内容到引入的文件</td><td><code>&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt;</code></td></tr><tr><td>th:replace</td><td>布局标签，替换整个标签到引入的文件</td><td><code>&lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:selected</td><td>selected选择框 选中</td><td><code>th:selected=&quot;($&#123;xxx.id&#125; == $&#123;configObj.dd&#125;)&quot;</code></td></tr><tr><td>th:src</td><td>图片类地址引入</td><td><code>&lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@&#123;/img/logo.png&#125;&quot; /&gt;</code></td></tr><tr><td>th:inline</td><td>定义js脚本可以使用变量</td><td><code>&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;</code></td></tr><tr><td>th:action</td><td>表单提交的地址</td><td><code>&lt;form action=&quot;subscribe.html&quot; th:action=&quot;@&#123;/subscribe&#125;&quot;&gt;</code></td></tr><tr><td>th:remove</td><td>删除某个属性</td><td><code>&lt;tr th:remove=&quot;all&quot;&gt;</code> 1.all:删除包含标签和所有的子节点。2.body:不包含标记删除,但删除其所有的子节点。3.tag:包含标记的删除,但不删除它的子节点。4.all-but-first:删除所有包含标签的子节点,除了第一个。5.none:什么也不做。这个值是有用的动态评估</td></tr><tr><td>th:attr</td><td>设置标签属性，多个属性可以用逗号分隔</td><td>比如 <code>th:attr=&quot;src=@&#123;/image/aa.jpg&#125;,title=#&#123;logo&#125;&quot;</code>，此标签不太优雅，一般用的比较少</td></tr></tbody></table><p>还有非常多的标签，这里只列出最常用的几个，由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:</p><pre><code>    include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。 </code></pre><blockquote><p>Thymeleaf 是一个非常灵活和优秀的前端页面模板引擎，使用 Thymeleaf 可以非常灵活的对页面进行布局，复用通用页面。Thymeleaf 提供了各种常用的语法，非常方便我们在前端页面中使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac高效工作的玩法配置总结</title>
      <link href="/2018/03/20/%E6%9D%82%E8%AE%B0/%20Mac%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%8E%A9%E6%B3%95%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/03/20/%E6%9D%82%E8%AE%B0/%20Mac%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%8E%A9%E6%B3%95%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Mac 上有很多提升工作效率的工具，及配置，以下是一些来自网络和自己的总结汇总，希望给小伙伴们带来帮助</p></blockquote><h2 id="1-硬件提升"><a href="#1-硬件提升" class="headerlink" title="1. 硬件提升"></a>1. 硬件提升</h2><p>MacBook Pro + 外接一台显示器，事半功倍～</p><h2 id="2-系统设置"><a href="#2-系统设置" class="headerlink" title="2. 系统设置"></a>2. 系统设置</h2><h3 id="2-1-设置触摸板轻触为单击"><a href="#2-1-设置触摸板轻触为单击" class="headerlink" title="2.1 设置触摸板轻触为单击"></a>2.1 设置触摸板轻触为单击</h3><p>通过轻点触摸板来实现点按，提高效率<br>打开<code>系统偏好设置</code>，点击<code>触摸板</code>图标，勾选<code>轻点来点按</code>选项，现在手指轻轻一碰触摸板，就达到鼠标单击的顺滑效果。</p><h3 id="2-2-设置三指拖移"><a href="#2-2-设置三指拖移" class="headerlink" title="2.2 设置三指拖移"></a>2.2 设置三指拖移</h3><p>点按拖动好累，可以设置为三指拖动<br>打开<code>系统偏好设置</code>，点击<code>辅助功能</code>图标，选中<code>鼠标和触摸板</code>,点击<code>触摸板选项...</code>,勾选<code>启动拖移</code>选项，下拉选择三指拖移，确认后，只要把鼠标指针指向窗口标题栏位置，就可以三个指头拖着窗口移动了～</p><h3 id="2-3-三指查词"><a href="#2-3-三指查词" class="headerlink" title="2.3 三指查词"></a>2.3 三指查词</h3><p>在浏览网页时，突然一些单词想英转中，亦或中转英，Mac可是支持的哦，简单设置一下即可<br>打开<code>系统便好设置</code>，点击<code>触摸板</code>，在<code>光标与点按</code>选项卡中，勾选<code>查询与数据检测器</code>。</p><p>网页上随意选中一个单词，三指点按触摸板，即可查询词语含义及中英文</p><h3 id="2-4-将Dock停靠在屏幕左边"><a href="#2-4-将Dock停靠在屏幕左边" class="headerlink" title="2.4 将Dock停靠在屏幕左边"></a>2.4 将Dock停靠在屏幕左边</h3><p>为什么要将<code>Dock</code>停靠在屏幕左边？MacBook的屏幕是一个长方形，如果你将<code>Dock</code>放在下面，那么屏幕的可用<code>宽度</code>就会减少，另外人眼阅读时的顺序是从左往右，因此<code>Dock</code>放在左边更适合将MacBook作为工作电脑的人。</p><p>打开<code>系统偏好设置</code>，点击<code>Dock</code>图标，</p><ol><li>将图标的<code>大小</code>调到合适大小</li><li>关闭<code>放大</code>特效（即鼠标放到Dock上图标放大的效果，此效果干扰注意力）</li><li>在<code>置于屏幕上的位置</code>一栏，选择<code>左边</code></li><li>勾选<code>将窗口最小化为应用图标</code></li><li>勾选<code>自动显示和隐藏Dock</code> 增加工作显示区域～</li></ol><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj53f3p8qj210q0ke773.jpg"><br>图2.3-1</p><h3 id="2-5-全键盘控制模式"><a href="#2-5-全键盘控制模式" class="headerlink" title="2.5 全键盘控制模式"></a>2.5 全键盘控制模式</h3><p>全键盘控制模式是什么？ 举一个例子，如下图所示，我正在写一个文档，此文档还没有保存，也没有文件名，如果不不小心点了<code>关闭</code>按钮，将会弹出一个对话框：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/d390b46f0e56030ee7731af9231d52b8a997c4ee"><br>图2.4-1</p><p>当前，<code>[Save]</code>按钮处于默认激活状态，按<code>回车</code>将会弹出保存对话框。但是如果我不想保存呢？ 只能通过鼠标或者触摸板来移动光标后点击<code>[Don&#39;t Save]</code>来取消保存。那我能不能通过键盘控制光标激活<code>[Don&#39;t Save]</code>按钮呢？ 答案是肯定的，做一个简单设置就好。</p><p>如图，首先打开<code>系统偏好设置</code>，点击<code>键盘</code>图标，选择<code>快捷键</code>这个Tab, 选中<code>所有控制</code></p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj56gp6toj210i0voznz.jpg"><br>图2.4-2</p><p>现在当我再次试图关闭一个未保存的文件时，新弹出的对话框如下，有了些许变化，在<code>[Don&#39;t Save]</code>按钮上多了一个蓝色的外框，当你按键盘上的<code>tab</code>键的时候，蓝色的外框会在3个按钮间切换。 假设现在蓝色的外框在<code>[Don&#39;t Save]</code>按钮上，你按下<code>回车</code>，却发现系统依然进入了<code>保存</code>文件对话框，为什么蓝色的外框不起作用呢？那是因为蓝色的外框选中的按钮是由<code>空格键</code>触发的，当你按下<code>空格键</code>，系统就会不保存文件直接退出。 这样当你不方便使用鼠标和触摸板的时候，可以更快速的和你的MacBook交互。</p><p>  <img src="http://img1.tbcdn.cn/L1/461/1/3abe8997fe7e3180655e05505d532fca0a37e640"><br>图2.4-3</p><h3 id="2-6-快速锁定屏幕-触发脚设置"><a href="#2-6-快速锁定屏幕-触发脚设置" class="headerlink" title="2.6 快速锁定屏幕-触发脚设置"></a>2.6 快速锁定屏幕-触发脚设置</h3><p>如果你长时间离开电脑，最好锁定你的屏幕，以<code>防止数据泄露</code>。 那如何快速的锁定你的MacBook呢？ 答案是只需要<code>一摸触摸板</code>或者<code>一甩鼠标</code>就可以了。</p><ul><li><p>打开<code>系统偏好设置</code>，点击<code>桌面和屏幕保护程序</code>图标，选择<code>屏幕保护程序</code>这个Tab，再点击<code>触发脚...</code>，在弹出的如下界面里面，右下角选择<code>启动屏幕保护程序</code>，点击OK确定。<img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj5c5ckwvj210m0uyafi.jpg"><br>图2.5-1</p></li><li><p>再打开<code>系统偏好设置</code>，点击<code>安全性与隐私</code>图标，在<code>通用</code>Tab内，勾选<code>进入睡眠或开始屏幕保护要求输入密码</code>。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj5guwpkkj210e0ew0uo.jpg"></p></li></ul><p>图2.5-2</p><p>现在当你离开电脑前时，记得<code>一摸触摸板</code>或者<code>一甩鼠标</code>将光标快速的移到屏幕的右下角，MacBook将立刻进入<code>屏幕保护</code>模式并且需要<code>密码</code>才能进入桌面。</p><h2 id="3-系统常用快捷键"><a href="#3-系统常用快捷键" class="headerlink" title="3. 系统常用快捷键"></a>3. 系统常用快捷键</h2><p>请<a href="https://support.apple.com/zh-cn/HT201236">点击</a>这个文档，学习系统快捷键，适当使用快捷键将会提升你的工作效率。</p><h2 id="4-日常软件推荐"><a href="#4-日常软件推荐" class="headerlink" title="4. 日常软件推荐"></a>4. 日常软件推荐</h2><h3 id="4-1-中文输入法"><a href="#4-1-中文输入法" class="headerlink" title="4.1 中文输入法"></a>4.1 中文输入法</h3><p>自带或搜狗吧，发现搜狗跟很多IDE一起玩时，不太兼容，我现在多已经习惯了自带输入法</p><h3 id="4-2-开源窗口管理软件-–-ShiftIt"><a href="#4-2-开源窗口管理软件-–-ShiftIt" class="headerlink" title="4.2 开源窗口管理软件 – ShiftIt"></a>4.2 开源窗口管理软件 – ShiftIt</h3><ol><li>想要文档在左半屏幕，IDE在右半屏幕？</li><li>终于搞好了外接显示器，你是否经常将某个窗口在笔记本和外接显示器屏幕之间直接来回拖动？</li></ol><p><a href="https://github.com/fikovnik/ShiftIt">ShiftIt</a>快速解决这样的需求，分屏软件千千万，在Mac上多是收费的，这是一款开源的，体验很6，当前app窗口中，快捷键按下<code>control+option+command + M</code>，则会立即进入全屏模式。</p><p>刚安装或重启时，可能会需要对<code>ShiftIt</code> 授权</p><p>打开<code>系统偏好设置</code>，点击<code>安全性和隐私</code>图标，在<code>隐私</code>Tab内，点击<code>辅助功能</code>，然后勾选<code>ShiftIt.app</code>（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。）</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj95z8j7cj210a0ton0b.jpg"><br>图4.2-2</p><p>如果你此时接上了外接显示器，快捷键按下<code>control+option+command+ N</code>，则当前左边显示器激活的最前端窗口将被立即发送到旁边的的显示器。</p><p>下面列举一些<code>ShiftIt</code>常用的快捷键，更多的快捷键和使用方式请查询其<a href="https://github.com/fikovnik/ShiftIt">ShiftIt</a>。</p><ul><li><p><code>control+option+command + M</code> ： 使当前窗口全屏</p></li><li><p><code>control+option+command + 方向键上键</code> ： 使当前窗口占用当前屏幕上半部分</p></li><li><p><code>control+option+command + 方向键下键</code> ： 使当前窗口占用当前屏幕下半部分</p></li><li><p><code>control+option+command + 方向键左键</code> ： 使当前窗口占用当前屏幕左半部分</p></li><li><p><code>control+option+command + 方向键右键</code> ： 使当前窗口占用当前屏幕右半部分</p></li><li><p><code>control+option+command + 1</code> ： 使当前窗口占用当前屏幕左上角</p></li><li><p><code>control+option+command + 2</code> ： 使当前窗口占用当前屏幕右上角</p></li><li><p><code>control+option+command + 3</code> ： 使当前窗口占用当前屏幕左下角</p></li><li><p><code>control+option+command + 4</code> ： 使当前窗口占用当前屏幕右下角</p></li><li><p><code>control+option+command + N</code> ： 将当前窗口发送到下一个显示器屏幕</p></li><li><p><code>control+option+command + P</code> ： 将当前窗口发送到前一个显示器屏幕</p></li></ul><h3 id="4-3-效率神器-–-Alfred"><a href="#4-3-效率神器-–-Alfred" class="headerlink" title="4.3 效率神器 – Alfred"></a>4.3 效率神器 – Alfred</h3><p>如果你曾经使用过MacBook，你应该接触过<a href="https://support.apple.com/zh-cn/HT204014">Spotlight</a>，就是屏幕中间弹出一个长条输入框，你输入文件名或者应用程序名，Spotlight将模糊查找到对应的候选项，按回车快速的打开你需要的文件或程序。</p><p><a href="http://www.alfredapp.com/">Alfred</a>的能力远远超过了Spotlight, 你可以直接下载免费版安装使用，Alfred另外还提供了更强大的工作流(Workflows)和剪切板(Clipboard)管理等高级功能，需要购买Powerpack。对于日常的操作，免费版已经足够使用了。</p><p>因为Alfred可以完全取代Spotlight，下面先删除Spotlight占用的快捷键<code>command + 空格</code>，以供Alfred将来使用。</p><p>打开<code>系统偏好设置</code>，选择<code>键盘</code>，切换到<code>快捷键</code>这个Tab下，点击Spotlight，取消对应的2个快捷键设置。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9khpvi9j21000vigpn.jpg"><br>图4.3-1</p><p>打开Alfred，在菜单栏点击Alfred图标，打开<code>Preferences...</code></p><p>如下图所示，设置Alfred的快捷键为<code>command + 空格</code></p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9nqs2snj21ok0mmjws.jpg"><br>图4.3-2</p><p>现在按下快捷键<code>command + 空格</code>，输入微信，Alfred将所有包含dash的应用程序，文档以及历史网址都列出来了，如下图所示，回车打开<code>微信</code>，<code>command+2</code>打开本微信Web开发者工具，你还可以移动键盘上下键或者光标来选择目标。<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpj9t38ywej20va0a83zp.jpg"></p><p>图4.3-3</p><p>更多关于Alfred的使用方式和无限想象力，请参考<a href="http://www.alfredapp.com/">官方网站</a>或者网上现有的大量的教程。</p><h3 id="4-4-快速切换和打开应用程序-—-Command-Tab-Plus-Manico-功效一样一样滴"><a href="#4-4-快速切换和打开应用程序-—-Command-Tab-Plus-Manico-功效一样一样滴" class="headerlink" title="4.4 快速切换和打开应用程序 — Command-Tab Plus | Manico (功效一样一样滴)"></a>4.4 快速切换和打开应用程序 — Command-Tab Plus | Manico (功效一样一样滴)</h3><p>MacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下<code>tab + command</code>，将看到如下图的样式：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/216e6046485410605dc1883952ae22f8a685e3c5"><br>图4.4-1</p><p>如果你想要却换到Firefox，需要再按一下<code>tab</code>，如果要切换到日历，需要按两下‘tab’，如果一次性打开10几个应用程序，你经常需要按十几下<code>tab</code>才能却换到想要的程序。</p><p><a href="http://commandtab.noteifyapp.com/">Command-Tab Plus</a>专为这个场景而设计，安装好后打开，默认快捷键是按住<code>option</code>，如图所示，此时按下数字<code>7</code>就能快速打开编号为<code>7</code>的<code>地图</code>。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/bd61382e4d329f7932dff65e7bf426a3bf6dc8cf"><br>图4.4-2</p><p>这些app会经常限时免购，可以关注一些公众号来获取</p><h3 id="4-5-随心所欲的复制粘贴以及无限想象-—-PopClip"><a href="#4-5-随心所欲的复制粘贴以及无限想象-—-PopClip" class="headerlink" title="4.5 随心所欲的复制粘贴以及无限想象 — PopClip"></a>4.5 随心所欲的复制粘贴以及无限想象 — PopClip</h3><ul><li>日常工作中，你有多少次是从一个应用程序复制一段文本然后粘贴到另外一个地方？</li><li>有多少次是复制一个网址然后打开浏览器粘贴到地址栏然后回车打开？</li><li>有多少次是复制一个名词，然后打开浏览器找到搜索引擎来搜索？</li></ul><p>这些重复的操作模式都是可以简化的，你唯一需要的就是<a href="http://pilotmoon.com/popclip/">PopClip</a>，当你选中一段文字（如下图，选中“当日收益”），PopClip就会弹出来一个快捷操作栏，你可以复制，剪切或者粘贴，更为强大的是，PopClip提供了很多免费的插件，例如使用指定的搜索引擎搜索选中的文字，或者选中英文单词做大小写转换等等。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/43e10d3e2589595b9b371620817878ffa49bf8f2"><br>图4.5-1</p><p>需要注意的是，PopClip需要你的授权才能弹出快捷状态栏，直接点击<code>打开 系统偏好设置</code>或者打开<code>系统偏好设置</code>，点击<code>安全性与隐私</code>图标，在<code>隐私</code>Tab内，点击<code>辅助功能</code>，然后勾选PopClip。（提示：你可能需要先点击右下角的黄色锁，输入密码后才能编辑右边的列表。）</p><h3 id="4-6-增强资源管理器-—-XtraFinder"><a href="#4-6-增强资源管理器-—-XtraFinder" class="headerlink" title="4.6 增强资源管理器 — XtraFinder"></a>4.6 增强资源管理器 — XtraFinder</h3><p>MacBook自带的资源管理器(Finder)已经可以满足一般的需要，但是当你有大量文件维护操作后，你就需要一个更强大的Finder。<a href="https://www.trankynam.com/xtrafinder/">XtraFinder</a>完全集成到Finder里面，你根本感觉不出它是一个第三方的应用程序，同时还提供很多增强特性，比如：</p><ul><li><p>像浏览器那样的标签页(Tab)</p></li><li><p>支持双操作面板(Panel)</p></li><li><p>增强的全局快捷键，例如新建文件(New File)等</p></li><li><p>多彩的侧边栏图标</p></li><li><p>快速在当前文件夹打开终端</p></li><li><p>快速在当前文件夹新建文件</p><p><img src="http://img2.tbcdn.cn/L1/461/1/a9d636d1331d528d71ab9d720c7f64987b1b1350"></p></li></ul><p>图4.8-1</p><h3 id="4-7-随心所欲的全键盘控制-–-Shortcat"><a href="#4-7-随心所欲的全键盘控制-–-Shortcat" class="headerlink" title="4.7 随心所欲的全键盘控制 – Shortcat"></a>4.7 随心所欲的全键盘控制 – Shortcat</h3><p>在系统设置里面，我介绍了<code>全键盘控制模式</code>，但是此模式只能做简单的按钮控制，无法达到随心所欲的控制。下面介绍一款比较geek的软件，<a href="https://shortcatapp.com/">Shortcat</a>帮助你完全使用键盘来控制系统，供有键盘强迫症的同学使用。</p><p>  <img src="http://img3.tbcdn.cn/L1/461/1/5920267ce10a6f28b669919720f4d8b196b78ff9"><br>图4.9-1</p><h3 id="4-8-来杯鸡尾酒-—-Bartender"><a href="#4-8-来杯鸡尾酒-—-Bartender" class="headerlink" title="4.8 来杯鸡尾酒 — Bartender"></a>4.8 来杯鸡尾酒 — Bartender</h3><p>如果你看到这里，相信你已经被我推(hu)荐(you)的安装了一排软件，你的系统状态栏已经<code>人满为患</code>，有时候会因为当前激活的应用程序的菜单比较多挡住你要点击的状态栏图标，这个时候你需要一个<code>酒保</code>来帮你调理一下状态栏，<a href="http://www.macbartender.com/">Bartender 3</a>就可以自定义隐藏某些不常用的状态栏图标，特别适合处女座强迫症。</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/ed09772f6172235bd4b9de1a10c182703e298a35"><br>图4.8-1</p><h3 id="4-9-markdown工具：-typora"><a href="#4-9-markdown工具：-typora" class="headerlink" title="4.9 markdown工具： typora"></a>4.9 markdown工具： typora</h3><p><a href="https://typora.io/">typora</a> 是一款所见即所得的markdown编辑工具，不像其他工具那样，左边写，右边预览效果，整体编辑简介很多还有各种高效特性，推荐之</p><h3 id="4-10-omini家族"><a href="#4-10-omini家族" class="headerlink" title="4.10 omini家族"></a>4.10 omini家族</h3><p><a href="https://www.omnigroup.com/">The Omni Group</a> 家族各种高效软件，件件精品，值得大家关注</p><p>The Omni Group 家族主要有四款：</p><ul><li>OmniFocus：GTD工具，主要用于个人事务的不同维度的清单管理</li><li>OmniGraffle：绘图神器，包括流程图、组织结构图、插图、脑图、原型等</li><li>OmniOutliner：写文章提纲必备</li><li>OmniPlan：项目管理工具，主要用于项目团队的进度、资源、成本管理</li></ul><h3 id="4-11-快速进入Shell"><a href="#4-11-快速进入Shell" class="headerlink" title="4.11 快速进入Shell"></a>4.11 快速进入Shell</h3><p><a href="http://zipzapmac.com/Go2Shell">go2shell</a>是一个对开发者来说非常有用的app, 使用它可以在Finder里快速进入shell环境.</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjcwzekeqj20bw09aaab.jpg"></p><p>图4.11-1</p><p>安装好以后, 打开Finder, 点击Finder上的图标即可进入terminal:</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjd3s6xoij21cm0j4mzd.jpg"></p><p>图4.11-2</p><h3 id="4-12-快速录屏–QuickTimePlayer"><a href="#4-12-快速录屏–QuickTimePlayer" class="headerlink" title="4.12 快速录屏–QuickTimePlayer"></a>4.12 快速录屏–QuickTimePlayer</h3><p>QuickTime Player是一个自带的录屏软件, 你可以用它来录制视屏,音频,以及屏幕操作. 对于开发者, 可以用它来记录屏幕操作, 做成动态图或视频, 供其它人学习; 对于普通工作者, 可以用QuickTime Player录制PPT讲座视频,右键图标，<code>新建影片录制</code></p><blockquote><p>Mac 上有太多的提高工作效率的工具了，我在这里在列一下其他一些常用工具，希望大家多多分享自己的工具和心得～</p></blockquote><ul><li><p>清理工具： cleanMyMac，会自动提醒，该清理啦～</p></li><li><p>api文档查询 ： dash （配合 alfred3 点工作流可以快速查找api文档） 命令行终端：iTerm2</p></li><li><p>文档编辑：sublime3 + 各种插件，vScode也不错</p></li><li><p>抓包工具（还可以用来模拟各种网络环境，给客户端当代理）： charles</p></li><li><p>接口管理及测试：postman</p></li><li><p>压缩工具： BetterZip</p></li><li><p>支持ntfs移动硬盘：好多人都是windows 转的mac ，之前的移动硬盘肯定很多资料，这里推荐两款可以让Mac支持写入NTFS格式硬盘的工具，<a href="https://www.tuxera.com/products/tuxera-ntfs-for-mac/">tuxera</a> （收费），<a href="http://enjoygineering.com/mounty/">Mounty for NTFS</a> (免费)</p></li><li><p>远程windows ： Microsoft Remote Desktop （微软官网下载的）</p></li><li><p>思维导图：xmind，mindnote</p></li><li><p>ftp管理（froklift）我现在基本是用scp命令啥的</p></li><li><p>翻墙：蓝灯 ／ ShadowsocksX （目前我用的ShadowsocksX ，买的VPS）</p></li></ul><p>… 好多好多吧，先举栗这些～</p><h2 id="5-开发环境配置"><a href="#5-开发环境配置" class="headerlink" title="5. 开发环境配置"></a>5. 开发环境配置</h2><p>好了，到了咱们开发环境的配置阶段，在配置开发环境前，建议先将OS X系统升级到最新版，同时去Mac <a href="http://www.apple.com/osx/apps/app-store/">App Store</a>下载最新版的<a href="https://developer.apple.com/xcode/">Xcode</a>，然后使用下面的命令安装Xcode command line tools，这将为你安装很多终端下面常用的命令，将来很可能会使用到：</p><p>Shell</p><table><thead><tr><th>1</th><th>xcode-select –install</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="5-1-命令行终端Terminal"><a href="#5-1-命令行终端Terminal" class="headerlink" title="5.1 命令行终端Terminal"></a>5.1 命令行终端Terminal</h3><p>在用户界面没有发明前，终端Terminal曾经是计算机的唯一交互方式，就算到了今天，很多服务器仍然只提供终端登陆来操作，作为开发测试运维相关人员，在日常工作中合理使用终端将大大提高工作效率。</p><h4 id="5-1-1-替换系统默认Shell-—-Oh-My-ZSH"><a href="#5-1-1-替换系统默认Shell-—-Oh-My-ZSH" class="headerlink" title="5.1.1 替换系统默认Shell — Oh My ZSH!"></a>5.1.1 替换系统默认Shell — Oh My ZSH!</h4><p><a href="http://www.gnu.org/software/bash/">Bash</a>作为大多数系统默认安装的Shell，大家都多少有所接触，<a href="http://www.zsh.org/">Zsh</a>和Bash类似都是一个Shell，但是Zsh更注重用户体验和与人的交互，OS X默认也安装好了Zsh，然而你想自己从头开始配置一个顺手的Zsh是比较浪费时间的，有人已经帮我们配置好了，这个流行的Zsh配置叫—<a href="http://ohmyz.sh/">Oh My ZSH!</a>，直观的效果如下图所示，不是是很炫酷，代码开源在<a href="https://github.com/robbyrussell/oh-my-zsh">github</a>。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpje803mrhj20xy0jewmh.jpg"><br>图5.1.1-1</p><ul><li>切换默认Shell到Zsh</li></ul><p>Mac OS X默认已经安装好了Zsh，你可以打开终端，输入<code>zsh --version</code>来确认，如果没有安装，请参考<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH">这个文档</a>。</p><p>打开终端输入下面的命令，切换默认Shell为Zsh：</p><p>Shell</p><table><thead><tr><th>1</th><th>chsh -s &#x2F;bin&#x2F;zsh</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>关闭终端重新打开后，你将默认使用zsh作为终端Shell。然而你会发现，终端并没有变得多酷炫，接着往下走，<code>安装Oh My ZSH!</code></p><ul><li>安装Oh My ZSH!</li></ul><p>打开终端输入下面的命令：</p><p>Shell</p><table><thead><tr><th>1</th><th>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>耐心等待一会儿，然后你就会发现你的终端变成了彩色的了。</p><p>  <img src="http://img3.tbcdn.cn/L1/461/1/379712ed6ac5b61c40224f663ccd4ce4c4ab0180"><br>图5.1.1-2</p><p>你可以修改终端的Profile，选择深色背景profile，这样就比较炫酷了。如果你对默认的<code>Oh My ZSH</code>的配色不满意，请参考<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes">这里</a>找到你喜欢的配色。</p><h4 id="5-1-2-替换系统默认终端-—-iTerm-2"><a href="#5-1-2-替换系统默认终端-—-iTerm-2" class="headerlink" title="5.1.2 替换系统默认终端 — iTerm 2"></a>5.1.2 替换系统默认终端 — iTerm 2</h4><p>经常使用终端，建议使用<a href="https://www.iterm2.com/">iTerm 2</a>来替代系统自带的终端。关于iTerm 2的特性，请看<a href="https://www.iterm2.com/features.html">这里</a>。</p><p>这里只介绍一个小技巧，我想设置一个快捷键假设为<code>Alt + .</code>(新Mac 不能直观的按功能键了，外接键盘可以设置为F12之类的)，在任意场合，我按一下快捷键<code>Alt + .</code>就弹出终端，输入一些命令执行后，再按一下<code>Alt + .</code>终端就自动隐藏，这对经常使用终端的人，例如经常ssh连接服务器的人来说实在太方便了。</p><p>设置过程如下：</p><ul><li><p>打开iTerm的<code>Preferences...</code>， 在<code>Profiles</code>Tab里面，点击下面的[<code>+</code>]添加一个新的profile，为什么要新建一个profile？答案是为了定制将来<code>弹出</code>的终端样式和大小等等参数。新的profile假设命名为guake，(注：guake这个名称是为了向Linux下的<a href="http://guake.org/">Guake</a>终端致敬)，你可以自己任意起个名称，下面会用到。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjelx1aidj21ec0uugqu.jpg"></p></li></ul><p>图5.1.2-1</p><p>再切换到<code>Window</code>Tab下，将<code>Style</code>，<code>Screen</code>和<code>Space</code>这3个值设置和下图一样。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjenm8g44j21e20rs79v.jpg"><br>图5.1.2-2</p><p>再切换到<code>Keys</code>Tab下，设置如下图所示的<code>Hotkey</code>Alt + .。</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fpjeox6o93j21ga0rq10u.jpg"><br>图5.1.2-3</p><p>现在你按下<code>Alt + .</code>，就立即得到一个占满全屏的黑色命令行终端，再按一下Alt + .隐藏终端，非常的方便。</p><h3 id="5-2-终端下的命令管理-—-Homebrew"><a href="#5-2-终端下的命令管理-—-Homebrew" class="headerlink" title="5.2 终端下的命令管理 — Homebrew"></a>5.2 终端下的命令管理 — Homebrew</h3><p>Mac <a href="http://www.apple.com/osx/apps/app-store/">App Store</a>你一定非常熟悉了，它可以帮你下载和安装大部分常见的软件。</p><p>在终端下，我们也需要一个App Store一样的管理程序，当你需要安装某个终端下的新命令的时候，这个程序可以帮助我们自动下载该命令以及相关的依赖，甚至在下载以后做必要的编译和环境设置。</p><p><a href="http://brew.sh/index.html">Homebrew</a>就是这样一款终端下的命令程序包管理器，安装非常简单，复制如下命令在终端下运行，按回车并输入密码后等待安装成功：</p><p>Shell</p><table><thead><tr><th>1</th><th>&#x2F;usr&#x2F;bin&#x2F;ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是安装截图：</p><p>  <img src="http://img4.tbcdn.cn/L1/461/1/d97a24018bf9c6a95000f66b46800f7c3d9ff208"><br>图5.2-1</p><p>curl和wget是命令行下面常用的命令，其中curl已经默认安装在OS X中了，但是wget没有默认安装，下面演示如何使用Homebrew来安装wget。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install wget</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是运行截图：<br>  <img src="http://img4.tbcdn.cn/L1/461/1/c821f88dc7fa44040ea4261a57f6906fcc41a822"><br>图5.2-2</p><h3 id="5-3-终端下管理非终端软件-—-Homebrew-Cask"><a href="#5-3-终端下管理非终端软件-—-Homebrew-Cask" class="headerlink" title="5.3 终端下管理非终端软件 — Homebrew Cask"></a>5.3 终端下管理非终端软件 — Homebrew Cask</h3><p>因为Apple不允许第三方的浏览器进入Mac App Store，如果你想要安装Google Chrome，只能去Google网站下载后运行安装文件。这一类App Store没有的非终端下的软件能不能享受Homebrew一样的命令行安装的便捷性呢？</p><p><a href="http://caskroom.io/">Homebrew Cask</a>就是这样一款终端下的程序管理器，它扩展了Homebrew，作为Mac App Store的有益补充，方便你快速维护日常软件的安装升级和卸载，复制如下命令在终端下运行，按回车后等待安装成功：</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install caskroom&#x2F;cask&#x2F;brew-cask</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面是运行截图：</p><p>  <img src="http://img2.tbcdn.cn/L1/461/1/fcc161f5926170d0d2bb3ecaf9be280b563b1726"><br>图5.3-1</p><p>那如何使用Homebrew Cask来安装Google Chrome呢？ 首先使用<code>chrome</code>作为关键字查找一下：</p><p>Shell</p><table><thead><tr><th>1</th><th>&gt; brew cask search chrome &#x3D;&#x3D;&gt; Partial matches chrome-devtools chrome-remote-desktop-host chromecast google-chrome</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>上面的命令运行后列出了4个候选项，很明显最后一个<code>google-chrome</code>就是我们要安装的，继续输入</p><p>Shell</p><table><thead><tr><th>1</th><th>&gt; brew cask install google-chrome</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下面只需要稍微等一会儿，最新版的Google Chrome就乖乖的安装在你的MacBook里面了。</p><h3 id="5-4-Java开发环境搭建"><a href="#5-4-Java开发环境搭建" class="headerlink" title="5.4 Java开发环境搭建"></a>5.4 Java开发环境搭建</h3><h4 id="5-4-1-安装Java和Maven"><a href="#5-4-1-安装Java和Maven" class="headerlink" title="5.4.1 安装Java和Maven"></a>5.4.1 安装Java和Maven</h4><p>现在OS X没有默认安装JDK，如果你在终端输入<code>java</code>，系统会引导你到Oracle网站去<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载</a>，然后自己点击下载文件来安装，这个过程一点都不酷，而且不能自动化。现在你有了Homebrew Cask，只要输入如下命令，Java就可以自动安装好啦。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew cask install java</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>现在最近版本的JDK是1.8，Homebrew默认安装最新版软件，如果你要安装非最新版的JDK，那么去Oracle网站下载吧，Homebrew的多版本支持不是很好用。</p><p>同样的，输入如下命令来安装Maven最新版。</p><p>Shell</p><table><thead><tr><th>1</th><th>brew install maven</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在开发中，你很可能会碰到这个错误<code>java.security.InvalidKeyException: Illegal key size or default parameters</code>，那是因为美国对出口软件<a href="http://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters">加密算法长度的限制</a>，你需要去如下链接下载补丁包：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">JCE Unlimited Policy for JDK 6</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">JCE Unlimited Policy for JDK 7</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JCE Unlimited Policy for JDK 8</a></li></ul><p>补丁替换路径为<code>$&#123;java.home&#125;/jre/lib/security/</code>，大约如下所示：</p><p>Shell</p><table><thead><tr><th>1</th><th>&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_51.jdk&#x2F;Contents&#x2F;Home&#x2F;jre&#x2F;lib&#x2F;security</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="5-4-2-安装版本控制软件-—-SmartGit-amp-SmartSVN"><a href="#5-4-2-安装版本控制软件-—-SmartGit-amp-SmartSVN" class="headerlink" title="5.4.2 安装版本控制软件 — SmartGit &amp; SmartSVN"></a>5.4.2 安装版本控制软件 — SmartGit &amp; SmartSVN</h4><p>如果代码就是生命，版本控制系统就是时光机。<a href="https://git-scm.com/">Git</a>和<a href="https://subversion.apache.org/">Subversion</a>分别是现在最流行的2个版本控制系统，<a href="http://www.syntevo.com/smartgit/">SmartGit</a>和<a href="http://www.smartsvn.com/download?file=smartsvn/smartsvn-macosx-8_6_7.dmg">SmartSVN</a>分别是他们的一个第三方客户端，当然他们有很多第三方客户端，我觉得SmartGit和SmartSVN是最好用的。</p><h4 id="5-4-3-安装和配置IDE-—-IntelliJ-IDEA"><a href="#5-4-3-安装和配置IDE-—-IntelliJ-IDEA" class="headerlink" title="5.4.3 安装和配置IDE — IntelliJ IDEA"></a>5.4.3 安装和配置IDE — IntelliJ IDEA</h4><p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>作为最智能的Java IDE，推荐所有Java开发人员使用，你可以在<a href="https://www.jetbrains.com/idea/download/">这里下载</a>安装文件，或者使用如下的Homebrew Cask命令来下载安装：</p><p>Shell</p><table><thead><tr><th>1</th><th>brew cask install intellij-idea</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><blockquote><p>其他一些高效办公的总结</p></blockquote><ul><li><a href="http://fantasykai.cc/2017/12/03/tools/chrome%20tools/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/">Chrome浏览器技巧总结</a></li><li><a href="http://fantasykai.cc/2017/10/14/mac/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/">收藏高效的小工具</a></li><li><a href="http://fantasykai.cc/2017/08/26/mac/iterm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/">iTerm2 快捷操作</a></li><li><a href="http://fantasykai.cc/2017/09/07/Linux/ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/">ssh 设置别名的方式访问服务器</a></li><li><a href="http://fantasykai.cc/2017/10/08/mac/oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/">oh-my-zsh的环境变量配置</a></li><li><a href="http://fantasykai.cc/2016/12/09/mac/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">brew常用命令</a></li><li><a href="https://sspai.com/post/27403">10 个实用技巧，让 Finder 带你飞</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sails守护进程启动</title>
      <link href="/2018/03/11/%E6%B5%8B%E8%AF%95/%20sails%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/03/11/%E6%B5%8B%E8%AF%95/%20sails%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>玩了下 sails ，发现 sails lift –prod 之类的，如果关闭终端窗口，服务就停止了，用 nohup 启动也没啥luan 用，汗，如何使用守护进程后台启动嘞，好吧，Google之 </p></blockquote><p>sails官网推荐 forever、pm2，大家可以根据个人喜好选择。</p><p>使用 forever</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g forever      安装守护进程</span><br><span class="line">forever start app.js --prod  开启守护进程</span><br><span class="line">forever list  显示运行的服务</span><br><span class="line">forever restartall  重启服务(建议用这个)</span><br><span class="line">forever stopall     停止12345</span><br></pre></td></tr></table></figure><p>使用 pm2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g pm2  安装守护进程</span><br><span class="line">pm2 start app.js -x  开启守护进程</span><br><span class="line">pm2 restart all      重启所有进程</span><br><span class="line">pm2 restart 0        重启指定进程</span><br><span class="line">pm2 stop all         停止</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用pm2</p></blockquote><p>生产环境可以这样启动</p><p>pm2 start app.js – –prod<br>sails默认支持 –prod的参数读取生产环境配置 那启动的时候传给他就可以<br>–之后的参数会传递到node app.js里执行</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python性能优化</title>
      <link href="/2018/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>优化算法时间复杂度</strong></p><p>算法的时间复杂度对程序的执行效率影响最大，在 Python 中可以通过选择合适的数据结构来优化时间复杂度，如 list 和 set 查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。</p><h3 id="减少冗余数据"><a href="#减少冗余数据" class="headerlink" title="减少冗余数据"></a><strong>减少冗余数据</strong></h3><p>如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。</p><h3 id="合理使用-copy-与-deepcopy"><a href="#合理使用-copy-与-deepcopy" class="headerlink" title="合理使用 copy 与 deepcopy"></a><strong>合理使用 copy 与 deepcopy</strong></h3><p>对于 dict 和 list 等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用 copy 包里的 copy 和 deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在 ipython 中运行）</p><blockquote><p>import copy</p><p>a &#x3D; range(100000)</p><p>%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)</p><p>%timeit -n 10 copy.deepcopy(a)</p><p>10 loops, best of 3: 1.55 ms per loop</p><p>10 loops, best of 3: 151 ms per loop</p></blockquote><p>timeit 后面的-n表示运行的次数，后两行对应的是两个 timeit 的输出，下同。由此可见后者慢一个数量级。</p><h3 id="使用-dict-或-set-查找元素"><a href="#使用-dict-或-set-查找元素" class="headerlink" title="使用 dict 或 set 查找元素"></a><strong>使用 dict 或 set 查找元素</strong></h3><p>python dict 和 set 都是使用 hash 表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)</p><blockquote><p>a &#x3D; range(1000)s &#x3D; set(a)d &#x3D; dict((i,1) for i in a)%timeit -n 10000 100 in d%timeit -n 10000 100 in s10000 loops, best of 3: 43.5 ns per loop10000 loops, best of 3: 49.6 ns per loop</p></blockquote><p>dict 的效率略高(占用的空间也多一些)。</p><h3 id="合理使用生成器（generator）和-yield"><a href="#合理使用生成器（generator）和-yield" class="headerlink" title="合理使用生成器（generator）和 yield"></a><strong>合理使用生成器（generator）和 yield</strong></h3><blockquote><p>%timeit -n 100 a &#x3D; (i for i in range(100000))%timeit -n 100 b &#x3D; [i for i in range(100000)]100 loops, best of 3: 1.54 ms per loop100 loops, best of 3: 4.56 ms per loop</p></blockquote><p>使用()得到的是一个 generator 对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如 set(i for i in range(100000))会比 set([i for i in range(100000)])快。</p><p>但是对于需要循环遍历的情况：</p><blockquote><p>%timeit -n 10 for x in (i for i in range(100000)): pass%timeit -n 10 for x in [i for i in range(100000)]: pass10 loops, best of 3: 6.51 ms per loop10 loops, best of 3: 5.54 ms per loop</p></blockquote><p>后者的效率反而更高，但是如果循环里有 break,用 generator 的好处是显而易见的。yield 也是用于创建 generator：</p><blockquote><p>def yield_func(ls):    </p><p>​    for i in ls:</p><p>​        yield i+1</p><p>def not_yield_func(ls):    </p><p>​    return [i+1 for i in ls]</p><p>ls &#x3D; range(1000000)%timeit -n 10 for i in yield_func(ls):pass</p><p>%timeit -n 10 for i in not_yield_func(ls):pass</p><p>10 loops, best of 3: 63.8 ms per loop</p><p>10 loops, best of 3: 62.9 ms per loop</p></blockquote><p>对于内存不是非常大的 list，可以直接返回一个 list，但是可读性 yield 更佳(人个喜好)。</p><p>python2.x 内置 generator 功能的有 xrange 函数、itertools 包等。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="优化循环"><a href="#优化循环" class="headerlink" title="优化循环"></a><strong>优化循环</strong></h3><p>循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：</p><blockquote><p>a &#x3D; range(10000)size_a &#x3D; len(a)%timeit -n 1000 for i in a: k &#x3D; len(a)%timeit -n 1000 for i in a: k &#x3D; size_a</p><p>1000 loops, best of 3: 569 µs per loop</p><p>1000 loops, best of 3: 256 µs per loop</p></blockquote><h3 id="优化包含多个判断表达式的顺序"><a href="#优化包含多个判断表达式的顺序" class="headerlink" title="优化包含多个判断表达式的顺序"></a><strong>优化包含多个判断表达式的顺序</strong></h3><p>对于 and，应该把满足条件少的放在前面，对于 or，把满足条件多的放在前面。如：</p><blockquote><p>a &#x3D; range(2000)  %timeit -n 100 [i for i in a if 10 &lt; i &lt; 20 or 1000 &lt; i &lt; 2000]%timeit -n 100 [i for i in a if 1000 &lt; i &lt; 2000 or 100 &lt; i &lt; 20]     %timeit -n 100 [i for i in a if i % 2 &#x3D;&#x3D; 0 and i &gt; 1900]%timeit -n 100 [i for i in a if i &gt; 1900 and i % 2 &#x3D;&#x3D; 0]</p><p>100 loops, best of 3: 287 µs per loop</p><p>100 loops, best of 3: 214 µs per loop</p><p>100 loops, best of 3: 128 µs per loop</p><p>100 loops, best of 3: 56.1 µs per loop</p></blockquote><h3 id="使用-join-合并迭代器中的字符串"><a href="#使用-join-合并迭代器中的字符串" class="headerlink" title="使用 join 合并迭代器中的字符串"></a><strong>使用 join 合并迭代器中的字符串</strong></h3><blockquote><p>In [1]: %%timeit   …: s &#x3D; ‘’   …: for i in a:   …:         s +&#x3D; i   …:10000 loops, best of 3: 59.8 µs per loopIn [2]: %%timeits &#x3D; ‘’.join(a)   …:100000 loops, best of 3: 11.8 µs per loop</p></blockquote><p>join 对于累加的方式，有大约5倍的提升。</p><h3 id="选择合适的格式化字符方式"><a href="#选择合适的格式化字符方式" class="headerlink" title="选择合适的格式化字符方式"></a><strong>选择合适的格式化字符方式</strong></h3><blockquote><p>s1, s2 &#x3D; ‘ax’, ‘bx’</p><p>%timeit -n 100000 ‘abc%s%s’ % (s1, s2)</p><p>%timeit -n 100000 ‘abc{0}{1}’.format(s1, s2)</p><p>%timeit -n 100000 ‘abc’ + s1 + s2</p><p>100000 loops, best of 3: 183 ns per loop</p><p>100000 loops, best of 3: 169 ns per loop</p><p>100000 loops, best of 3: 103 ns per loop</p></blockquote><p>三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得%的可读性最好)</p><h3 id="不借助中间变量交换两个变量的值"><a href="#不借助中间变量交换两个变量的值" class="headerlink" title="不借助中间变量交换两个变量的值"></a><strong>不借助中间变量交换两个变量的值</strong></h3><blockquote><p>In [3]: %%timeit -n 10000    a,b&#x3D;1,2   ….: c&#x3D;a;a&#x3D;b;b&#x3D;c;   ….:10000 loops, best of 3: 172 ns per loopIn [4]: %%timeit -n 10000</p><p>a,b&#x3D;1,2</p><p>a,b&#x3D;b,a   ….:</p><p>10000 loops, best of 3: 86 ns per loop</p></blockquote><p>使用a,b&#x3D;b,a而不是c&#x3D;a;a&#x3D;b;b&#x3D;c;来交换a,b的值，可以快1倍以上。</p><h3 id="使用-if-is"><a href="#使用-if-is" class="headerlink" title="使用 if is"></a><strong>使用 if is</strong></h3><blockquote><p>a &#x3D; range(10000)</p><p>%timeit -n 100 [i for i in a if i &#x3D;&#x3D; True]</p><p>%timeit -n 100 [i for i in a if i is True]</p><p>100 loops, best of 3: 531 µs per loop</p><p>100 loops, best of 3: 362 µs per loop</p></blockquote><p>使用 if is True 比 if &#x3D;&#x3D; True 将近快一倍。</p><h3 id="使用级联比较x-lt-y-lt-z"><a href="#使用级联比较x-lt-y-lt-z" class="headerlink" title="使用级联比较x &lt; y &lt; z"></a><strong>使用级联比较x &lt; y &lt; z</strong></h3><blockquote><p>x, y, z &#x3D; 1,2,3</p><p>%timeit -n 1000000 if x &lt; y &lt; z:pass</p><p>%timeit -n 1000000 if x &lt; y and y &lt; z:pass</p><p>1000000 loops, best of 3: 101 ns per loop</p><p>1000000 loops, best of 3: 121 ns per loop</p></blockquote><p>x &lt; y &lt; z效率略高，而且可读性更好。</p><h3 id="while-1-比-while-True-更快"><a href="#while-1-比-while-True-更快" class="headerlink" title="while 1 比 while True 更快"></a><strong>while 1 比 while True 更快</strong></h3><blockquote><p>def while_1():</p><p>​    n &#x3D; 100000</p><p>​    while 1:</p><p>​        n -&#x3D; 1</p><p>​        if n &lt;&#x3D; 0: break</p><p>def while_true():    n &#x3D; 100000    while True:        n -&#x3D; 1        if n &lt;&#x3D; 0: break    </p><p>m, n &#x3D; 1000000, 1000000 </p><p>%timeit -n 100 while_1()%timeit -n 100 while_true()</p><p>100 loops, best of 3: 3.69 ms per loop</p><p>100 loops, best of 3: 5.61 ms per loop</p></blockquote><p>while 1 比 while true 快很多，原因是在 python2.x 中，True 是一个全局变量，而非关键字。</p><h3 id="使用-而不是-pow"><a href="#使用-而不是-pow" class="headerlink" title="*使用*而不是 pow"></a>*<em>使用*<em>而不是 pow</em></em></h3><blockquote><p>%timeit -n 10000 c &#x3D; pow(2,20)%timeit -n 10000 c &#x3D; 2**2010000 loops, best of 3: 284 ns per loop10000 loops, best of 3: 16.9 ns per loop</p></blockquote><p>**就是快10倍以上！</p><h3 id="使用-cProfile-cStringIO-和-cPickle-等用c实现相同功能（分别对应profile-StringIO-pickle）的包"><a href="#使用-cProfile-cStringIO-和-cPickle-等用c实现相同功能（分别对应profile-StringIO-pickle）的包" class="headerlink" title="使用 cProfile, cStringIO 和 cPickle 等用c实现相同功能（分别对应profile, StringIO, pickle）的包"></a><strong>使用 cProfile, cStringIO 和 cPickle 等用c实现相同功能（分别对应profile, StringIO, pickle）的包</strong></h3><blockquote><p>import cPickle</p><p>import pickle</p><p>a &#x3D; range(10000)</p><p>%timeit -n 100 x &#x3D; cPickle.dumps(a)</p><p>%timeit -n 100 x &#x3D; pickle.dumps(a)</p><p>100 loops, best of 3: 1.58 ms per loop</p><p>100 loops, best of 3: 17 ms per loop</p></blockquote><p>由c实现的包，速度快10倍以上！</p><p><strong>使用最佳的反序列化方式</strong></p><p>下面比较了 eval, cPickle, json 方式三种对相应字符串反序列化的效率：</p><blockquote><p>import json</p><p>import cPickle</p><p>a &#x3D; range(10000)</p><p>s1 &#x3D; str(a)</p><p>s2 &#x3D; cPickle.dumps(a)</p><p>s3 &#x3D; json.dumps(a)</p><p>%timeit -n 100 x &#x3D; eval(s1)</p><p>%timeit -n 100 x &#x3D; cPickle.loads(s2)</p><p>%timeit -n 100 x &#x3D; json.loads(s3)</p><p>100 loops, best of 3: 16.8 ms per loop</p><p>100 loops, best of 3: 2.02 ms per loop</p><p>100 loops, best of 3: 798 µs per loop</p></blockquote><p>可见 json 比 cPickle 快近3倍，比 eval 快20多倍。</p><h3 id="使用C扩展-Extension"><a href="#使用C扩展-Extension" class="headerlink" title="使用C扩展(Extension)"></a><strong>使用C扩展(Extension)</strong></h3><p>目前主要有 CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得 Python 程序可以调用由C编译成的动态链接库，其特点分别是：</p><p>CPython 原生 API: 通过引入 Python.h 头文件，对应的C程序中可以直接使用Python 的数据结构。实现过程相对繁琐，但是有比较大的适用范围。</p><p>ctypes: 通常用于封装(wrap)C程序，让纯 Python 程序调用动态链接库（Windows 中的 dll 或 Unix 中的 so 文件）中的函数。如果想要在 python 中使用已经有C类库，使用 ctypes 是很好的选择，有一些基准测试下，python2+ctypes 是性能最好的方式。</p><p>Cython: Cython 是 CPython 的超集，用于简化编写C扩展的过程。Cython 的优点是语法简洁，可以很好地兼容 numpy 等包含大量C扩展的库。Cython 的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。</p><p>cffi: cffi 的就是 ctypes 在 pypy（详见下文）中的实现，同进也兼容 CPython。cffi提供了在 python 使用C类库的方式，可以直接在 python 代码中编写C代码，同时支持链接到已有的C类库。</p><p>使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。</p><h3 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a><strong>并行编程</strong></h3><p>因为 GIL 的存在，Python 很难充分利用多核 CPU 的优势。但是，可以通过内置的模块 multiprocessing 实现下面几种并行模式：</p><p>多进程：对于 CPU 密集型的程序，可以使用 multiprocessing 的 Process,Pool 等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。</p><p>多线程：对于 IO 密集型的程序，multiprocessing.dummy 模块使用 multiprocessing 的接口封装 threading，使得多线程编程也变得非常轻松(比如可以使用 Pool 的 map 接口，简洁高效)。</p><p>分布式：multiprocessing 中的 Managers 类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。</p><p>不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。</p><h3 id="终级大杀器：PyPy"><a href="#终级大杀器：PyPy" class="headerlink" title="终级大杀器：PyPy"></a><strong>终级大杀器：PyPy</strong></h3><p>PyPy 是用 RPython(CPython 的子集)实现的 Python，根据官网的基准测试数据，它比 CPython 实现的 Python 要快6倍以上。快的原因是使用了 Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前 pypy 中还保留着 GIL，不过正在进行的 STM 项目试图将 PyPy 变成没有 GIL 的 Python。</p><p>如果 python 程序中含有C扩展(非cffi的方式)，JIT 的优化效果会大打折扣，甚至比 CPython 慢（比 Numpy）。所以在 PyPy 中最好用纯 Python 或使用 cffi 扩展。</p><p>随着 STM，Numpy 等项目的完善，相信 PyPy 将会替代 CPython。</p><h3 id="使用性能分析工具"><a href="#使用性能分析工具" class="headerlink" title="使用性能分析工具"></a><strong>使用性能分析工具</strong></h3><p>除了上面在 ipython 使用到的 timeit 模块，还有 cProfile。cProfile 的使用方式也非常简单： python -m cProfile filename.py，filename.py 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p>[1] <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/">http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/</a></p><p>[2] <a href="http://maxburstein.com/blog/speeding-up-your-python-code/">http://maxburstein.com/blog/speeding-up-your-python-code/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9新特性</title>
      <link href="/2018/02/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/02/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Java9新特性之—目录结构"><a href="#1、Java9新特性之—目录结构" class="headerlink" title="1、Java9新特性之—目录结构"></a>1、Java9新特性之—目录结构</h1><p>​    包含jdk8及以前的jdk版本，所有目录结构以及目录含义如图：</p><p><img src="https://static.oschina.net/uploads/space/2018/0223/134757_QthE_3209213.png" alt="img"> </p><p><img src="https://static.oschina.net/uploads/space/2018/0223/134835_7knf_3209213.png" alt="img"></p><p>​    jdk9之后，目录结构发生变化如图：</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/134936_Br5K_3209213.png" alt="img"></p><p>​     这个新特性只要了解下就可以了，这个目录结构是方便为了接下来新特性做保证</p><h1 id="2、Java9新特性之—JShell工具"><a href="#2、Java9新特性之—JShell工具" class="headerlink" title="2、Java9新特性之—JShell工具"></a>2、Java9新特性之—JShell工具</h1><p>​       怎么理解，怎么用呢？这个只是针对于java9来说，相当于cmd工具，你可以和cmd一样，直接写方法等等，不过我认为只是适用于初学者做一些最简单的运算和写一些方法：</p><p>​        在cmd中打开这个工具：</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/141123_Zanv_3209213.png" alt="img"></p><p>​         进入工具后可以做一些简单的java操作</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/141217_v4Rg_3209213.png" alt="img"></p><p>​        。。。。等等，我认为只适用于初学者学习java不用其他编辑工具就可以学习java</p><h1 id="3、Java9新特性之—模块化"><a href="#3、Java9新特性之—模块化" class="headerlink" title="3、Java9新特性之—模块化"></a>3、Java9新特性之—模块化</h1><p>​        一个大型的项目，比如淘宝商城等，都会包含多个模块，比如订单模块，前台模块，后台管理模块，广告位模块，会员模块…..等等，各个模块之间会相互调用，不过这种情况下会很少，只针对特殊情况，如果一个项目有30个模块系统进行开发，但是只要某个单独模块运行时，都会带动所有的模块，这样对于jvm来说在内存和性能上会很低，所以，java9提供了这一个特性，某一个模块运行的时候，jvm只会启动和它有依赖的模块，并不会加载所有的模块到内存中，这样性能大大的提高了。写法上如下：</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/135741_hQRX_3209213.png" alt="img"></p><p>​        一个项目中的两个模块，模块之间通过module-info.java来关联，在IDEA编辑器右键创建package-info.java</p><p>​        <img src="https://static.oschina.net/uploads/space/2018/0223/135923_DO9V_3209213.png" alt="img"></p><p>​        在这个两个模块java9Demo和java9Test中，java9demo编写一个实体类Person,在java9Test调用这样一个过程</p><p>​        这个是java9Demo 将 java9Test 模块需要的文件导出 exports  把它所在的包导出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module java9Demo&#123;</span><br><span class="line">    exports com.mdxl.layer_cj.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后在java9Test模块中创建一个package-info.java,引入java9Demo模块导出包名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module java9Test&#123;</span><br><span class="line">    requires java9Demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接在java9Test中引入Person实体类了，这只是一个简单的例子。exports 控制着那些包可以被模块访问，所以不被导出的包不能被其他模块访问</p><h1 id="4、Java9新特性之—多版本兼容Jar包"><a href="#4、Java9新特性之—多版本兼容Jar包" class="headerlink" title="4、Java9新特性之—多版本兼容Jar包"></a>4、Java9新特性之—多版本兼容Jar包</h1><p>​        怎么理解呢？</p><p>​       好多公司用的jdk大部分还是老版本，jdk6,7 都有，他们都不敢升级主要是因为兼容的问题，但是java9做到了这一点，就是不管公司的项目是用的java6,7,8甚至5，他都可以兼容不出错，打个比方，你之前用的是iphone5，现在出现了iPhone6，iphone7，iphon8和iphone9，但是你不敢买9，因为你自己已经适应了iphone5的所有手机的运行流程，6,7,8每个手机的运行流程不一样，但是这个9很强大，它能够识别你现在所用的版本iphone是5，所以当你升级到iphone9的时候，你的这个手机运行流程还是iphone5的流程，只是在原有基础上拥有了更多的iphone9的所有优势。</p><h1 id="5、Java9新特性之—接口Interface的升级"><a href="#5、Java9新特性之—接口Interface的升级" class="headerlink" title="5、Java9新特性之—接口Interface的升级"></a>5、Java9新特性之—接口Interface的升级</h1><p>​        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface FilterProcess&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //java 7 及以前 特性  全局常量 和抽象方法</span><br><span class="line">    public static final String a =&quot;22&quot;;</span><br><span class="line">    boolean process(T t);</span><br><span class="line"></span><br><span class="line">    //java 8 特性 静态方法和默认方法</span><br><span class="line">    default void love()&#123;</span><br><span class="line">        System.out.println(&quot;java8 特性默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void haha()&#123;</span><br><span class="line">        System.out.println(&quot;java8 特性静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //java 8 特性 支持私有方法</span><br><span class="line">    private void java9()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、Java9新特性之—钻石操作符的升级"><a href="#6、Java9新特性之—钻石操作符的升级" class="headerlink" title="6、Java9新特性之—钻石操作符的升级"></a>6、Java9新特性之—钻石操作符的升级</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//java6及以前</span><br><span class="line">Map&lt;String,String&gt; map7 = new HashMap&lt;String,String&gt;();</span><br><span class="line">//java7和8 &lt;&gt;没有了数据类型</span><br><span class="line">Map&lt;String,String&gt; map8 = new HashMap&lt;&gt;();</span><br><span class="line">//java9 添加了匿名内部类的功能 后面添加了大括号&#123;&#125;  可以做一些细节的操作</span><br><span class="line">Map&lt;String,String&gt; map9 = new HashMap&lt;&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="7、Java9新特性之—异常处理try升级"><a href="#7、Java9新特性之—异常处理try升级" class="headerlink" title="7、Java9新特性之—异常处理try升级"></a>7、Java9新特性之—异常处理try升级</h1><p>​    首先看下jdk6,7,8,9 的try catch的比较</p><p>​    Java6处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//java7及以前写法  每一个流打开的时候都要关闭</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    InputStreamReader reader = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        reader = new InputStreamReader(System.in);</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        if (reader != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    java7,8 共同的处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//java7和8及 每一个流打开的时候都要关闭,但是在try的括号中来进行关闭</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    try(InputStreamReader reader =new InputStreamReader(System.in))&#123;</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    java9的处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//java9及 每一个流打开的时候都要关闭,但是在try的括号中来进行关闭，在</span><br><span class="line">//java8的基础上进一步升级 直接在try括号中直接写入 变量就好，如果有多个流，就用分号隔开</span><br><span class="line">//try(reader;writer)&#123;&#125;</span><br><span class="line">@Test</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    InputStreamReader reader =new InputStreamReader(System.in);</span><br><span class="line">    try(reader)&#123;</span><br><span class="line">        reader.read();</span><br><span class="line">    &#125;catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这下子应该一幕了然了吧</p><h1 id="8、Java9新特性之—特殊标识符增加限制"><a href="#8、Java9新特性之—特殊标识符增加限制" class="headerlink" title="8、Java9新特性之—特殊标识符增加限制"></a>8、Java9新特性之—特殊标识符增加限制</h1><p>​    java8 之前 String _ &#x3D;”hello”;  这样的标识符可以用，java9就用不到。</p><h1 id="9、Java9新特性之—String底层存储结构更换"><a href="#9、Java9新特性之—String底层存储结构更换" class="headerlink" title="9、Java9新特性之—String底层存储结构更换"></a>9、Java9新特性之—String底层存储结构更换</h1><p>​    java8之前 String的底层结构类型都是 char[] ,但是java9 就替换成 byte[] 这样来讲，更节省了空间和提高了性能</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144044_FEnG_3209213.png" alt="img"></p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144120_QBpj_3209213.png" alt="img"></p><p>​    之所以替换是因为 之前一直是最小单位是一个char，用到两个byte,但是java8是基于latin1的，而这个latin1编码可以用一个byte标识，所以当你数据明明可以用到一个byte的时候，我们用到了一个最小单位chat两个byte，就多出了一个byte的空间。所以java9在这一方面进行了更新，现在的java9 是基于ISO&#x2F;latin1&#x2F;Utf-16  ,latin1和ISO用一个byte标识,UTF-16用两个byte标识，java9会自动识别用哪个编码，当数据用到1byte，就会使用iSO或者latin1 ，当空间数据满足2byte的时候，自动使用utf-16,节省了很多空间</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144527_x6kt_3209213.png" alt="img"></p><p><em><strong><strong>同理，StringBuilder StringBuffer也更换了底层数据结构</strong></strong></em>********</p><h1 id="10、Java9新特性之—Stream-API-新方法的添加"><a href="#10、Java9新特性之—Stream-API-新方法的添加" class="headerlink" title="10、Java9新特性之—Stream API 新方法的添加"></a>10、Java9新特性之—Stream API 新方法的添加</h1><p>​    在原有Stream API 新添加了4个方法，takeWhile dropWhile ofNullable iterate(新重载方法)</p><p>​    首先解释 takeWhile 当达到一定条件就结束：输出结果为45 43，如图</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/144923_sNmR_3209213.png" alt="img"></p><p>​    而 dropWhile 则和takeWhile 相反</p><p>​    ofNullable, 在java8中 Stream中的元素不能完全为null，否则空指针异常，而在java9的升级中，允许创建null</p><p>​    iterate 不加条件无线循环</p><p>​    <img src="https://static.oschina.net/uploads/space/2018/0223/145645_gggz_3209213.png" alt="img"></p><h1 id="11、Java9新特性之—引进HttpClient"><a href="#11、Java9新特性之—引进HttpClient" class="headerlink" title="11、Java9新特性之—引进HttpClient"></a>11、Java9新特性之—引进HttpClient</h1><p>​    以往我们都是通过maven添加httpclient ,java9直接引入即可</p><p>Java9所有特性都是为了提高性能和内存。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 安装opencv 报错，解决</title>
      <link href="/2018/02/11/%E6%9D%82%E8%AE%B0/%20mac%20%E5%AE%89%E8%A3%85opencv%20%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/02/11/%E6%9D%82%E8%AE%B0/%20mac%20%E5%AE%89%E8%A3%85opencv%20%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="mac-安装opencv-报错，解决"><a href="#mac-安装opencv-报错，解决" class="headerlink" title="mac 安装opencv 报错，解决"></a>mac 安装opencv 报错，解决</h3><p>安装成功后，引入 cv2 报错</p><p>Python 3.6.4<br>[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin<br>Type “help”, “copyright”, “credits” or “license” for more information.</p><blockquote><blockquote><blockquote><p>import cv2<br>ceback (most recent call last):<br>ile “<stdin>“, line 1, in <module><br>ortError: dlopen(&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;3.4.0_1&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;cv2.cpython-36m-darwin.so, 2): Library not loaded: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;jack&#x2F;lib&#x2F;libjack.0.dylib<br>eferenced from: &#x2F;usr&#x2F;local&#x2F;opt&#x2F;ffmpeg&#x2F;lib&#x2F;libavcodec.57.dylib<br>eason: image not found</p></blockquote></blockquote></blockquote><p>最终通过下面命令解决：</p><p>​brew install opencv3 –with-contrib –with-python3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS分析</title>
      <link href="/2018/01/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAS%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAS%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CAS，Compare And Swap，即比较并交换。Doug lea大神在同步组件中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090001.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090001_thumb.png" alt="201703090001"></a></p><h2 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h2><p>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(this.value == A)&#123;</span><br><span class="line">this.value = B</span><br><span class="line">return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure><p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p><p>valueOffset为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p><p>value当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p><p>我们就以AtomicInteger的addAndGet()方法来做说明，先看源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final int addAndGet(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要是看compareAndSwapInt方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>该方法为本地方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值（有位伙伴告诉我他面试的时候就问到这四个变量是啥意思…+_+）。该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看openjdk的源码。</p><p>CAS可以保证一次的读-改-写操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点儿复杂了。</p><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><p><em>总线加锁</em>：总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p><p><strong>缓存加锁</strong>：其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p><h2 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h2><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p><p><strong>循环时间太长</strong></p><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><p><strong>只能保证一个共享变量原子操作</strong></p><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><p><strong>ABA问题</strong></p><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>用一个例子来阐述ABA问题所带来的影响。</p><p>有如下链表</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090002.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090002_thumb.png" alt="201703090002"></a></p><p>假如我们想要把B替换为A，也就是compareAndSet(this,A,B)。线程1执行B替换A操作，线程2主要执行如下动作，A 、B出栈，然后C、A入栈，最终该链表如下：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090003.png"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090003_thumb.png" alt="201703090003"></a></p><p>完成后线程1发现仍然是A，那么compareAndSet(this,A,B)成功，但是这时会存在一个问题就是B.next &#x3D; null,compareAndSet(this,A,B)后，会导致C丢失，改栈仅有一个B元素，平白无故把C给丢失了。</p><p>CAS的ABA隐患问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。对于上面的案例应该线程1会失败。</p><p>AtomicStampedReference的compareAndSet()方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。源码部门很好理解预期的引用 &#x3D;&#x3D; 当前引用，预期的标识 &#x3D;&#x3D; 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static class Pair&lt;T&gt; &#123;</span><br><span class="line">      final T reference;</span><br><span class="line">      final int stamp;</span><br><span class="line">      private Pair(T reference, int stamp) &#123;</span><br><span class="line">          this.reference = reference;</span><br><span class="line">          this.stamp = stamp;</span><br><span class="line">      &#125;</span><br><span class="line">      static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">          return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private volatile Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。如set方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void set(V newReference, int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    if (newReference != current.reference || newStamp != current.stamp)</span><br><span class="line">        this.pair = Pair.of(newReference, newStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将通过一个例子可以可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将100 —&gt; 110 —&gt; 100，线程2执行 100 —&gt;120，看两者之间的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //AtomicInteger</span><br><span class="line">        Thread at1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                atomicInteger.compareAndSet(100,110);</span><br><span class="line">                atomicInteger.compareAndSet(110,100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread at2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      // at1,执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        at1.start();</span><br><span class="line">        at2.start();</span><br><span class="line"></span><br><span class="line">        at1.join();</span><br><span class="line">        at2.join();</span><br><span class="line"></span><br><span class="line">        //AtomicStampedReference</span><br><span class="line"></span><br><span class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //让 tsf2先获取stamp，导致预期时间戳不一致</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1</span><br><span class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int stamp = atomicStampedReference.getStamp();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tsf1.start();</span><br><span class="line">        tsf2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><a href="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090004_2.jpg"><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/04/201703090004_2_thumb.jpg" alt="201703090004_2"></a></p><p>运行结果充分展示了AtomicInteger的ABA问题和AtomicStampedReference解决ABA问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis相关总结2</title>
      <link href="/2018/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%932/"/>
      <url>/2018/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><blockquote><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</p></blockquote><h3 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h3><p>1 、Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</p><p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p><p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p><p>4、 redis的速度比memcached快很多</p><p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis与Memcached的区别与比较"></p><p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached与Redis》</strong>：<a href="https://link.juejin.im/?target=https://www.imooc.com/article/23549">www.imooc.com/article/235…</a></p><h3 id="Redis与Memcached的选择"><a href="#Redis与Memcached的选择" class="headerlink" title="Redis与Memcached的选择"></a>Redis与Memcached的选择</h3><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis；</p><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。详细了解请参考：《Redis事务介绍（四）》：<a href="https://link.juejin.im/?target=https://blog.csdn.net/cuipeng0916/article/details/53698774">blog.csdn.net&#x2F;cuipeng0916…</a></p><p>redis监控：锁的介绍</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="Redis常见数据结构使用场景"><a href="#Redis常见数据结构使用场景" class="headerlink" title="Redis常见数据结构使用场景"></a>Redis常见数据结构使用场景</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h4><blockquote><p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote><p><strong>常用命令：</strong> hget,hset,hgetall 等。</p></blockquote><p>Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p><p><strong>举个例子：</strong> 最近做的一个电商网站项目的首页就使用了redis的hash数据结构进行缓存，因为一个网站的首页访问量是最大的，所以通常网站的首页可以通过redis缓存来提高性能和并发量。我用<strong>jedis客户端</strong>来连接和操作我搭建的redis集群或者单机redis，利用jedis可以很容易的对redis进行相关操作，总的来说从搭一个简单的集群到实现redis作为缓存的整个步骤不难。感兴趣的可以看我昨天写的这篇文章：</p><p><strong>《一文轻松搞懂redis集群原理及搭建与使用》：</strong> <a href="https://link.juejin.im/?target=https://juejin.im/post/5ad54d76f265da23970759d3">juejin.im&#x2F;post&#x2F;5ad54d…</a></p><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote><p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。</p><p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote><p><strong>常用命令：</strong> sadd,spop,smembers,sunion 等</p></blockquote><p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p><h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote><p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p><h3 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）</h3><p>   相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据</li></ol><h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决?"></a>Redis的并发竞争问题如何解决?</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p><p> 1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。   2.服务器角度，利用setnx实现锁。</p><p> 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h3 id="Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><p><strong>Redis内存回收:LRU算法（写的很不错，推荐）</strong>：<a href="https://link.juejin.im/?target=https://www.cnblogs.com/WJ5888/p/4371647.html">www.cnblogs.com/WJ5888/p/43…</a></p><h3 id="Redis-大量数据插入"><a href="#Redis-大量数据插入" class="headerlink" title="Redis 大量数据插入"></a>Redis 大量数据插入</h3><p>官方文档给的解释：<a href="https://link.juejin.im/?target=http://www.redis.cn/topics/mass-insert.html">www.redis.cn/topics/mass…</a></p><h3 id="Redis-分区的优势、不足以及分区类型"><a href="#Redis-分区的优势、不足以及分区类型" class="headerlink" title="Redis 分区的优势、不足以及分区类型"></a>Redis 分区的优势、不足以及分区类型</h3><p>官方文档提供的讲解：<a href="https://link.juejin.im/?target=http://www.redis.net.cn/tutorial/3524.html">www.redis.net.cn/tutorial/35…</a></p><h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><p><strong>《redis的持久化和缓存机制》</strong> ：<a href="https://link.juejin.im/?target=https://blog.csdn.net/tr1912/article/details/70197085?foxhandler=RssReadRenderProcessHandler">blog.csdn.net&#x2F;tr1912&#x2F;arti…</a></p><p>扩容的话可以通过redis集群实现，之前做项目的时候用过自己搭的redis集群 然后写了一篇关于redis集群的文章：<strong>《一文轻松搞懂redis集群原理及搭建与使用》</strong>：<a href="https://link.juejin.im/?target=https://juejin.im/post/5ad54d76f265da23970759d3">juejin.im&#x2F;post&#x2F;5ad54d…</a></p><h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案:"></a>Redis常见性能问题和解决方案:</h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li></ol><h3 id="Redis与消息队列"><a href="#Redis与消息队列" class="headerlink" title="Redis与消息队列"></a>Redis与消息队列</h3><blockquote><p>作者：翁伟 链接：<a href="https://www.zhihu.com/question/20795043/answer/345073457">https://www.zhihu.com/question/20795043/answer/345073457</a></p></blockquote><p>不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做去消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque： antirez&#x2F;disque:<a href="https://link.juejin.im/?target=https://github.com/antirez/disque">github.com&#x2F;antirez&#x2F;dis…</a>部署、协议等方面都跟redis非常类似，并且支持集群，延迟消息等等。</p><p>我在做网站过程接触比较多的还是使用redis做缓存，比如秒杀系统，首页缓存等等。</p><h2 id="好文Mark"><a href="#好文Mark" class="headerlink" title="好文Mark"></a>好文Mark</h2><p><strong>非常非常推荐下面几篇文章。。。</strong></p><p><strong>《Redis深入之道：原理解析、场景使用以及视频解读》</strong>：<a href="https://link.juejin.im/?target=https://zhuanlan.zhihu.com/p/28073983">zhuanlan.zhihu.com&#x2F;p&#x2F;28073983</a>: 主要介绍了：Redis集群开源的方案、Redis协议简介及持久化Aof文件解析、Redis短连接性能优化等等内容，文章干货太大，容量很大，建议时间充裕可以看看。另外文章里面还提供了视频讲解，可以说是非常非常用心了。</p><p><strong>《阿里云Redis混合存储典型场景：如何轻松搭建视频直播间系统》：</strong><a href="https://link.juejin.im/?target=https://yq.aliyun.com/articles/582487?utm_content=m_46529">yq.aliyun.com&#x2F;articles&#x2F;58…</a>: 主要介绍视频直播间系统，以及如何使用阿里云Redis混合存储实例方便快捷的构建大数据量，低延迟的视频直播间服务。还介绍到了我们之前提高过的redis的数据结构的使用场景</p><p><strong>《美团在Redis上踩过的一些坑-5.redis cluster遇到的一些问》</strong>：<a href="https://link.juejin.im/?target=http://carlosfu.iteye.com/blog/2254573">carlosfu.iteye.com&#x2F;blog&#x2F;225457…</a>：主要介绍了redis集群的两个常见问题，然后分享了 一些关于redis集群不错的文章。</p><p><strong>参考：</strong></p><p><a href="https://www.cnblogs.com/Survivalist/p/8119891.html">https://www.cnblogs.com/Survivalist/p/8119891.html</a></p><p><a href="http://www.redis.net.cn/tutorial/3524.html">http://www.redis.net.cn/tutorial/3524.html</a></p><p><a href="https://redis.io/">https://redis.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 总结</title>
      <link href="/2018/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%20Redis%20%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%20Redis%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后在性能调优等方面进行更深入的介绍和指导。</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>概述</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Redis 是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。</p><p>Redis 支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs 等。</p><p>Redis 具备 LRU 淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过 Redis Sentinel 实现的高可用方案，同时还支持通过 Redis Cluster 实现的数据自动分片能力。</p><p>Redis 的主要功能都基于单线程模型实现，也就是说 Redis 使用一个线程来服务所有的客户端请求，同时 Redis 采用了非阻塞式 IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p><blockquote><ul><li>Redis 是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li><li>Redis 的速度非常快（因为使用非阻塞式 IO，且大部分命令的算法时间复杂度都是 O(1))</li><li>使用高耗时的 Redis 命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为 O(N) 的 KEYS 命令，严格禁止在生产环境中使用）</li></ul></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="Redis-的数据结构和相关常用命令"><a href="#Redis-的数据结构和相关常用命令" class="headerlink" title="Redis 的数据结构和相关常用命令"></a>Redis 的数据结构和相关常用命令</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>本节中将介绍 Redis 支持的主要数据结构，以及相关的常用 Redis 命令。本节只对 Redis 命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的 Redis 命令集，或了解某个命令的详细使用方法，请参考官方文档：<a href="https://redis.io/commands">https://redis.io/commands</a></p><h3 id="常用命令一、Key"><a href="#常用命令一、Key" class="headerlink" title="常用命令一、Key"></a><strong>常用命令一、Key</strong></h3><p>Redis 采用 Key-Value 型的基本数据结构，任何二进制序列都可以作为 Redis 的 Key 使用（例如普通的字符串或一张 JPEG 图片）<br><strong>关于 Key 的一些注意事项：</strong></p><p>不要使用过长的 Key。例如使用一个 1024 字节的 key 就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</p><p>Key 短到缺失了可读性也是不好的，例如”u1000flw” 比起”user:1000:followers” 来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</p><p>最好使用统一的规范来设计 Key，比如”object-type:id:attr”，以这一规范设计出的 Key 可能是”user:1000” 或”comment:1234:reply-to”</p><p>Redis 允许的最大 Key 长度是 512MB（对 Value 的长度限制也是 512MB）</p><h3 id="常用命令二、String"><a href="#常用命令二、String" class="headerlink" title="常用命令二、String"></a><strong>常用命令二、String</strong></h3><p>String 是 Redis 的基础数据类型，Redis 没有 Int、Float、Boolean 等数据类型的概念，所有的基本类型在 Redis 中都以 String 体现。</p><p>与 String 相关的常用命令：</p><blockquote><ul><li>SET：为一个 key 设置 value，可以配合 EX&#x2F;PX 参数指定 key 的有效期，通过 NX&#x2F;XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li><li>GET：获取某个 key 对应的 value，时间复杂度 O(1)</li><li>GETSET：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li><li>MSET：为多个 key 设置 value，时间复杂度 O(N)</li><li>MSETNX：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li><li>MGET：获取多个 key 对应的 value，时间复杂度 O(N)</li></ul></blockquote><p>上文提到过，Redis 的基本数据类型只有 String，但 Redis 可以把 String 作为整型或浮点型数字来使用，主要体现在 INCR、DECR 类的命令上：</p><blockquote><ul><li>INCR：将 key 对应的 value 值自增 1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li><li>INCRBY：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li><li>DECR&#x2F;DECRBY：同 INCR&#x2F;INCRBY，自增改为自减。</li></ul></blockquote><p>INCR&#x2F;DECR 系列命令要求操作的 value 类型为 String，并可以转换为 64 位带符号的整型数字，否则会返回错误。</p><p>也就是说，进行 INCR&#x2F;DECR 系列命令的 value，必须在 [-2^63 ~ 2^63 - 1] 范围内。</p><p>前文提到过，Redis 采用单线程模型，天然是线程安全的，这使得 INCR&#x2F;DECR 命令可以非常便利的实现高并发场景下的精确控制。</p><ul><li><p><strong>例 1：库存控制</strong></p><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。</p><p>设置库存总量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET inv:remain &quot;100&quot;</span><br></pre></td></tr></table></figure><p>库存扣减 + 余量校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR inv:remain</span><br></pre></td></tr></table></figure><p>当 DECR 命令返回值大于等于 0 时，说明库存余量校验通过，如果返回小于 0 的值，则说明库存已耗尽。</p><p>假设同时有 300 个并发请求进行库存扣减，Redis 能够确保这 300 个请求分别得到 99 到 - 200 的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p></li><li><p><strong>例 2：自增序列生成</strong></p><p>实现类似于 RDBMS 的 Sequence 功能，生成一系列唯一的序列号</p><p>设置序列起始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET sequence &quot;10000&quot;</span><br></pre></td></tr></table></figure><p>获取一个序列值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR sequence</span><br></pre></td></tr></table></figure><p>直接将返回值作为序列使用即可。</p><p>获取一批（如 100 个）序列值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY sequence 100</span><br></pre></td></tr></table></figure><p>假设返回值为 N，那么 [N - 99 ~ N] 的数值都是可用的序列值。</p><p>当多个客户端同时向 Redis 申请自增序列时，Redis 能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p></li></ul><h3 id="常用命令三、List"><a href="#常用命令三、List" class="headerlink" title="常用命令三、List"></a><strong>常用命令三、List</strong></h3><p>Redis 的 List 是链表型的数据结构，可以使用 LPUSH&#x2F;RPUSH&#x2F;LPOP&#x2F;RPOP 等命令在 List 的两端执行插入元素和弹出元素的操作。虽然 List 也支持在特定 index 上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。</p><p>与 List 相关的常用命令：</p><blockquote><ul><li>LPUSH：向指定 List 的左侧（即头部）插入 1 个或多个元素，返回插入后的 List 长度。时间复杂度 O(N)，N 为插入元素的数量</li><li>RPUSH：同 LPUSH，向指定 List 的右侧（即尾部）插入 1 或多个元素</li><li>LPOP：从指定 List 的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li><li>RPOP：同 LPOP，从指定 List 的右侧（即尾部）移除 1 个元素并返回</li><li>LPUSHX&#x2F;RPUSHX：与 LPUSH&#x2F;RPUSH 类似，区别在于，LPUSHX&#x2F;RPUSHX 操作的 key 如果不存在，则不会进行任何操作</li><li>LLEN：返回指定 List 的长度，时间复杂度 O(1)</li><li>LRANGE：返回指定 List 中指定范围的元素（双端包含，即 LRANGE key 0 10 会返回 11 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List，避免使用 LRANGE key 0 -1 这样的完整遍历操作。</li></ul></blockquote><p>应谨慎使用的 List 相关命令：</p><blockquote><ul><li>LINDEX：返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 - 1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度 O(N)</li><li>LSET：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度 O(N)，如果操作的是头 &#x2F; 尾部的元素，则时间复杂度为 O(1)</li><li>LINSERT：向指定 List 中指定元素之前 &#x2F; 之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 - 1。如果指定 key 不存在，不会进行任何操作，时间复杂度 O(N)</li></ul></blockquote><p>由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 List 进行遍历，命令的耗时无法预估，在 List 长度大的情况下耗时会明显增加，应谨慎使用。</p><p>换句话说，Redis 的 List 实际是设计来用于实现队列，而不是用于实现类似 ArrayList 这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用 Redis 的 List 数据结构。</p><p>为了更好支持队列的特性，Redis 还提供了一系列阻塞式的操作命令，如 BLPOP&#x2F;BRPOP 等，能够实现类似于 BlockingQueue 的能力，即在 List 为空时，阻塞该连接，直到 List 中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（<a href="https://redis.io/topics/data-types-intro%EF%BC%89">https://redis.io/topics/data-types-intro）</a> 中”Blocking operations on lists” 一节。</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h2 id="常用命令四、Hash"><a href="#常用命令四、Hash" class="headerlink" title="常用命令四、Hash"></a>常用命令四、Hash</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>Hash 即哈希表，Redis 的 Hash 和传统的哈希表一样，是一种 field-value 型的数据结构，可以理解成将 HashMap 搬入 Redis。</p><p>Hash 非常适合用于表现对象类型的数据，用 Hash 中的 field 对应对象的 field 即可。</p><p>Hash 的优点包括：</p><blockquote><ul><li>可以实现二元查找，如” 查找 ID 为 1000 的用户的年龄”</li><li>比起将整个对象序列化后作为 String 存储的方法，Hash 能够有效地减少网络传输的消耗</li><li>当使用 Hash 维护一个集合时，提供了比 List 效率高得多的随机访问命令</li></ul></blockquote><p>与 Hash 相关的常用命令：</p><blockquote><ul><li>HSET：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li><li>HGET：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li><li>HMSET&#x2F;HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N 为一次操作的 field 数量</li><li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li><li>HEXISTS：判断指定 Hash 中 field 是否存在，存在返回 1，不存在返回 0，时间复杂度 O(1)</li><li>HDEL：删除指定 Hash 中的 field（1 个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li><li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li></ul></blockquote><p>应谨慎使用的 Hash 相关命令：</p><blockquote><ul><li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li><li>HKEYS&#x2F;HVALS：返回指定 Hash 中所有的 field&#x2F;value，时间复杂度 O(N)</li></ul></blockquote><p>上述三个命令都会对 Hash 进行完整遍历，Hash 中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历，具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h2 id="常用命令五、Set"><a href="#常用命令五、Set" class="headerlink" title="常用命令五、Set"></a>常用命令五、Set</h2><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><p>Redis Set 是无序的，不可重复的 String 集合。</p><p>与 Set 相关的常用命令：</p><blockquote><ul><li>SADD：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li><li>SREM：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li><li>SRANDMEMBER：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li><li>SPOP：从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li><li>SCARD：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li><li>SISMEMBER：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li><li>SMOVE：将指定 member 从一个 Set 移至另一个 Set</li></ul></blockquote><p>慎用的 Set 相关命令：</p><blockquote><ul><li>SMEMBERS：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li><li>SUNION&#x2F;SUNIONSTORE：计算多个 Set 的并集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li><li>SINTER&#x2F;SINTERSTORE：计算多个 Set 的交集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li><li>SDIFF&#x2F;SDIFFSTORE：计算 1 个 Set 与 1 或多个 Set 的差集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数。</li></ul></blockquote><p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），如果需要做并集 &#x2F; 交集 &#x2F; 差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行。</p><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h2 id="常用命令六、Sorted-Set"><a href="#常用命令六、Sorted-Set" class="headerlink" title="常用命令六、Sorted Set"></a>常用命令六、Sorted Set</h2><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><p>Redis Sorted Set 是有序的、不可重复的 String 集合。Sorted Set 中的每个元素都需要指派一个分数 (score)，Sorted Set 会根据 score 对元素进行升序排序。如果多个 member 拥有相同的 score，则以字典序进行升序排序。</p><p>Sorted Set 非常适合用于实现排名。</p><p>Sorted Set 的主要命令：</p><blockquote><ul><li>ZADD：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li><li>ZREM：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li><li>ZCOUNT：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li><li>ZCARD：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li><li>ZSCORE：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li><li>ZRANK&#x2F;ZREVRANK：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li><li>ZINCRBY：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li></ul></blockquote><p>慎用的 Sorted Set 相关命令：</p><blockquote><ul><li>ZRANGE&#x2F;ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M 为本次返回的 member 数</li><li>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序 &#x2F; 降序排序，min 和 max 可以指定为 - inf 和 + inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li><li>ZREMRANGEBYRANK&#x2F;ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围 &#x2F; 指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li></ul></blockquote><p>上述几个命令，应尽量避免传递 [0 -1] 或 [-inf +inf] 这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h2 id="常用命令七、Bitmap-和-HyperLogLog"><a href="#常用命令七、Bitmap-和-HyperLogLog" class="headerlink" title="常用命令七、Bitmap 和 HyperLogLog"></a>常用命令七、Bitmap 和 HyperLogLog</h2><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><p>Redis 的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令，请参考官方文档 <a href="https://redis.io/topics/data-types-intro">https://redis.io/topics/data-types-intro</a> 中的相关章节</p><p>Bitmap 在 Redis 中不是一种实际的数据类型，而是一种将 String 作为 Bitmap 使用的方法。可以理解为将 String 转换为 bit 数组。使用 Bitmap 来存储 true&#x2F;false 类型的简单数据极为节省空间。</p><p>HyperLogLogs 是一种主要用于数量统计的数据结构，它和 Set 类似，维护一个不可重复的 String 集合，但是 HyperLogLogs 并不维护具体的 member 内容，只维护 member 的个数。也就是说，HyperLogLogs 只能用于计算一个集合中不重复的元素数量，所以它比 Set 要节省很多内存空间。</p><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><blockquote><ul><li>EXISTS：判断指定的 key 是否存在，返回 1 代表存在，0 代表不存在，时间复杂度 O(1)</li><li>DEL：删除指定的 key 及其对应的 value，时间复杂度 O(N)，N 为删除的 key 数量</li><li>EXPIRE&#x2F;PEXPIRE：为一个 key 设置有效期，单位为秒或毫秒，时间复杂度 O(1)</li><li>TTL&#x2F;PTTL：返回一个 key 剩余的有效时间，单位为秒或毫秒，时间复杂度 O(1)</li><li>RENAME&#x2F;RENAMENX：将 key 重命名为 newkey。使用 RENAME 时，如果 newkey 已经存在，其值会被覆盖；使用 RENAMENX 时，如果 newkey 已经存在，则不会进行任何操作，时间复杂度 O(1)</li><li>TYPE：返回指定 key 的类型，string, list, set, zset, hash。时间复杂度 O(1)</li><li>CONFIG GET：获得 Redis 某配置项的当前值，可以使用 * 通配符，时间复杂度 O(1)</li><li>CONFIG SET：为 Redis 某个配置项设置新值，时间复杂度 O(1)</li><li>CONFIG REWRITE：让 Redis 重新加载 redis.conf 中的配置</li></ul></blockquote><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h2 id="Redis-性能调优"><a href="#Redis-性能调优" class="headerlink" title="Redis 性能调优"></a>Redis 性能调优</h2><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><p>尽管 Redis 是一个非常快速的内存数据存储媒介，也并不代表 Redis 不会产生性能问题。<br>前文中提到过，Redis 采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得 Redis 对每个任务的执行效率更加敏感。</p><p>针对 Redis 的性能优化，主要从下面几个层面入手：</p><blockquote><ul><li><p>最初的也是最重要的，确保没有让 Redis 执行耗时长的命令</p></li><li><p>使用 pipelining 将连续执行的命令组合执行</p></li><li><p>操作系统的 Transparent huge pages 功能必须关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></li><li><p>如果在虚拟机中运行 Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过.&#x2F;redis-cli —intrinsic-latency 100 命令查看固有延迟。同时如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis。</p></li><li><p>检查数据持久化策略</p></li><li><p>考虑引入读写分离机制</p></li></ul></blockquote><h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h2><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在文本和官方文档中均对每个命令的时间复杂度有说明。</p><p>通常来说，O(1) 的命令是安全的，O(N) 命令在使用时需要注意，如果 N 的数量级不可预知，则应避免使用。例如对一个 field 数未知的 Hash 数据执行 HGETALL&#x2F;HKEYS&#x2F;HVALS 命令，通常来说这些命令执行的很快，但如果这个 Hash 中的 field 数量极多，耗时就会成倍增长。</p><p>又如使用 SUNION 对两个 Set 执行 Union 操作，或使用 SORT 对 List&#x2F;Set 执行排序操作等时，都应该严加注意。</p><p>避免在使用这些 O(N) 命令时发生问题主要有几个办法：</p><blockquote><ul><li>不要把 List 当做列表使用，仅当做队列来使用</li><li>通过机制严格控制 Hash、Set、Sorted Set 的大小</li><li>可能的话，将排序、并集、交集等操作放在客户端执行</li><li>绝对禁止使用 KEYS 命令</li><li>避免一次性遍历集合类型的所有成员，而应使用 SCAN 类的命令进行分批的，游标式的遍历</li></ul></blockquote><p>Redis 提供了 SCAN 命令，可以对 Redis 中存储的所有 key 进行游标式的遍历，避免使用 KEYS 命令带来的性能问题。同时还有 SSCAN&#x2F;HSCAN&#x2F;ZSCAN 等命令，分别用于对 Set&#x2F;Hash&#x2F;Sorted Set 中的元素进行游标式遍历。SCAN 类命令的使用请参考官方文档：<a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p><p>Redis 提供了 Slow Log 功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than xxxms  #执行时间慢于xxx毫秒的命令计入Slow Logslowlog-max-len xxx  #Slow Log的长度，即最大纪录多少条Slow Log</span><br></pre></td></tr></table></figure><p>使用** SLOWLOG GET [number]** 命令，可以输出最近进入 Slow Log 的 number 条命令。<br>使用** SLOWLOG RESET** 命令，可以重置 Slow Log</p><h3 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h3><blockquote><ul><li><p>尽可能使用长连接或连接池，避免频繁创建销毁连接</p></li><li><p>客户端进行的批量数据操作，应使用 Pipeline 特性在一次交互中完成。具体请参照本文的 Pipelining 章节</p><p>​</p></li></ul></blockquote><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h3><p>Redis 的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p><blockquote><ul><li>AOF + fsync always 的设置虽然能够绝对确保数据安全，但每个操作都会触发一次 fsync，会对 Redis 的性能有比较明显的影响</li><li>AOF + fsync every second 是比较好的折中方案，每秒 fsync 一次</li><li>AOF + fsync never 会提供 AOF 持久化方案下的最优性能<br>使用 RDB 持久化通常会提供比使用 AOF 更高的性能，但需要注意 RDB 的策略配置</li><li>每一次 RDB 快照和 AOF Rewrite 都需要 Redis 主进程进行 fork 操作。fork 操作本身可能会产生较高的耗时，与 CPU 和 Redis 占用的内存大小有关。根据具体的情况合理配置 RDB 快照和 AOF Rewrite 时机，避免过于频繁的 fork 带来的延迟</li></ul></blockquote><blockquote><p>Redis 在 fork 子进程时需要将内存分页表拷贝至子进程，以占用了 24GB 内存的 Redis 实例为例，共需要拷贝 24GB &#x2F; 4kB * 8 &#x3D; 48MB 的数据。在使用单 Xeon 2.27Ghz 的物理机上，这一 fork 操作耗时 216ms。</p><p>可以通过 INFO 命令返回的 latest_fork_usec 字段查看上一次 fork 操作的耗时（微秒）</p></blockquote><h3 id="Swap-引发的延迟"><a href="#Swap-引发的延迟" class="headerlink" title="Swap 引发的延迟"></a><strong>Swap 引发的延迟</strong></h3><p>当 Linux 将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现不正常的延迟。Swap 通常在物理内存不足或一些进程在进行大量 I&#x2F;O 操作时发生，应尽可能避免上述两种情况的出现。</p><p>&#x2F;proc&#x2F;&#x2F;smaps 文件中会保存进程的 swap 记录，通过查看这个文件，能够判断 Redis 的延迟是否由 Swap 产生。如果这个文件中记录了较大的 Swap size，则说明延迟很有可能是 Swap 造成的。</p><h3 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h3><p>当同一秒内有大量 key 过期时，也会引发 Redis 的延迟。在使用时应尽量将 key 的失效时间错开。</p><h3 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a>引入读写分离机制</h3><p>Redis 的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。</p><p>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。</p><p>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p><p>关于读写分离的具体说明，请参见后续章节</p><h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h2 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a>主从复制与集群分片</h2><h2 id="-19"><a href="#-19" class="headerlink" title=""></a></h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis 支持一主多从的主从复制架构。一个 Master 实例负责处理所有的写请求，Master 将写操作同步至所有 Slave。</p><p>借助 Redis 的主从复制，可以实现读写分离和高可用：</p><blockquote><ul><li>实时性要求不是特别高的读请求，可以在 Slave 上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的 Redis 命令，可以专门规划出 1 个或几个 Slave 用于服务这些统计任务</li><li>借助 Redis Sentinel 可以实现高可用，当 Master crash 后，Redis Sentinel 能够自动将一个 Slave 晋升为 Master，继续提供服务</li></ul></blockquote><p>启用主从复制非常简单，只需要配置多个 Redis 实例，在作为 Slave 的 Redis 实例中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379  #指定Master的IP和端口</span><br></pre></td></tr></table></figure><p>当 Slave 启动后，会从 Master 进行一次冷启动数据同步，由 Master 触发 BGSAVE 生成 RDB 文件推送给 Slave 进行导入，导入完成后 Master 再将增量数据通过 Redis Protocol 同步给 Slave。之后主从之间的数据便一直以 Redis Protocol 进行同步</p><h3 id="使用-Sentinel-做自动-failover"><a href="#使用-Sentinel-做自动-failover" class="headerlink" title="使用 Sentinel 做自动 failover"></a><strong>使用 Sentinel 做自动 failover</strong></h3><hr><p>Redis 的主从复制功能本身只是做数据同步，并不提供监控和自动 failover 能力，要通过主从复制功能来实现 Redis 的高可用，还需要引入一个组件：Redis Sentinel</p><p>Redis Sentinel 是 Redis 官方开发的监控组件，可以监控 Redis 实例的状态，通过 Master 节点自动发现 Slave 节点，并在监测到 Master 节点失效时选举出一个新的 Master，并向所有 Redis 实例推送新的主从配置。</p><p>Redis Sentinel 需要至少部署 3 个实例才能形成选举关系。</p><p>关键配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  #Master实例的IP、端口，以及选举需要的赞成票数sentinel down-after-milliseconds mymaster 60000  #多长时间没有响应视为Master失效sentinel failover-timeout mymaster 180000  #两次failover尝试间的间隔时长sentinel parallel-syncs mymaster 1  #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span><br></pre></td></tr></table></figure><p>另外需要注意的是，Redis Sentinel 实现的自动 failover 不是在同一个 IP 和端口上完成的，也就是说自动 failover 产生的新 Master 提供服务的 IP 和端口与之前的 Master 是不一样的，所以要实现 HA，还要求客户端必须支持 Sentinel，能够与 Sentinel 交互获得新 Master 的信息才行。</p><h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h2><h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><p>为何要做集群分片：</p><blockquote><ul><li>Redis 中存储的数据量大，一台主机的物理内存已经无法容纳</li><li>Redis 的写请求并发量大，一个 Redis 实例以无法承载</li></ul></blockquote><p>当上述两个问题出现时，就必须要对 Redis 进行分片了。</p><p>Redis 的分片方案有很多种，例如很多 Redis 的客户端都自行实现了分片功能，也有向 Twemproxy 这样的以代理方式实现的 Redis 分片方案。然而首选的方案还应该是 Redis 官方在 3.0 版本中推出的 Redis Cluster 分片方案。</p><p>本文不会对 Redis Cluster 的具体安装和部署细节进行介绍，重点介绍 Redis Cluster 带来的好处与弊端。</p><h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-的能力"><a href="#Redis-Cluster-的能力" class="headerlink" title="Redis Cluster 的能力"></a>Redis Cluster 的能力</h2><blockquote><ul><li>能够自动将数据分散在多个节点上</li><li>当访问的 key 不在当前分片上时，能够自动将请求转发至正确的分片</li><li>当集群中部分节点失效时仍能提供服务</li></ul></blockquote><p>其中第三点是基于主从复制来实现的，Redis Cluster 的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了 Redis Sentinel 这一额外的组件，由 Redis Cluster 负责进行一个分片内部的节点监控和自动 failover。</p><h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-分片原理"><a href="#Redis-Cluster-分片原理" class="headerlink" title="Redis Cluster 分片原理"></a>Redis Cluster 分片原理</h2><p>Redis Cluster 中共有 16384 个 hash slot，Redis 会计算每个 key 的 CRC16，将结果与 16384 取模，来决定该 key 存储在哪一个 hash slot 中，同时需要指定 Redis Cluster 中每个数据分片负责的 Slot 数。Slot 的分配在任何时间点都可以进行重新分配。</p><p>客户端在对 key 进行读写操作时，可以连接 Cluster 中的任意一个分片，如果操作的 key 不在此分片负责的 Slot 范围内，Redis Cluster 会自动将请求重定向到正确的分片上。</p><h3 id="-24"><a href="#-24" class="headerlink" title=""></a></h3><h2 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h2><p>在基础的分片原则上，Redis 还支持 hash tags 功能，以 hash tags 要求的格式明明的 key，将会确保进入同一个 Slot 中。例如：{uiv}user:1000 和 {uiv}user:1001 拥有同样的 hash tag {uiv}，会保存在同一个 Slot 中。</p><p>使用 Redis Cluster 时，pipelining、事务和 LUA Script 功能涉及的 key 必须在同一个数据分片上，否则将会返回错误。如要在 Redis Cluster 中使用上述功能，就必须通过 hash tags 来确保一个 pipeline 或一个事务中操作的所有 key 都位于同一个 Slot 中。</p><blockquote><p>有一些客户端（如 Redisson）实现了集群化的 pipelining 操作，可以自动将一个 pipeline 里的命令按 key 所在的分片进行分组，分别发到不同的分片上执行。但是 Redis 不支持跨分片的事务，事务和 LUA Script 还是必须遵循所有 key 在一个分片上的规则要求。</p></blockquote><h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a>主从复制 vs 集群分片</h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？</p><p>从各个方面看，Redis Cluster 都是优于主从复制的方案</p><blockquote><ul><li>Redis Cluster 能够解决单节点上数据量过大的问题</li><li>Redis Cluster 能够解决单节点访问压力过大的问题</li><li>Redis Cluster 包含了主从复制的能力</li></ul></blockquote><p>那是不是代表 Redis Cluster 永远是优于主从复制的选择呢？</p><p>并不是。</p><p>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用 Redis Cluster 的弊端包括：</p><blockquote><ul><li>维护难度增加。在使用 Redis Cluster 时，需要维护的 Redis 实例数倍增，需要监控的主机数量也相应增加，数据备份 &#x2F; 持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行 reshard 操作，远比主从模式下增加一个 Slave 的复杂度要高。</li><li>客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</li><li>性能优化难度增加。你可能需要在多个分片上查看 Slow Log 和 Swap 日志才能定位性能问题。</li><li>事务和 LUA Script 的使用成本增加。在 Redis Cluster 中使用事务和 LUA Script 特性有严格的限制条件，事务和 Script 中操作的 key 必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的 key 进行额外的规划和规范要求。如果应用的场景中大量涉及事务和 Script 的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</li></ul></blockquote><p>所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用 Redis Cluster。<br>下面是一些建议：</p><p>需要在 Redis 中存储的数据有多大？未来 2 年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用 LRU 算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出 Redis 需要使用的物理内存。</p><p>用于部署 Redis 的主机物理内存有多大？有多少可以分配给 Redis 使用？对比 (1) 中的内存需求评估，是否足够用？</p><p>Redis 面临的并发写压力会有多大？在不使用 pipelining 时，Redis 的写性能可以超过 10 万次 &#x2F; 秒（更多的 benchmark 可以参考 <a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a> ）</p><p>在使用 Redis 时，是否会使用到 pipelining 和事务功能？使用的场景多不多？<br>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对 Redis 的容量需求，且 Redis 面临的并发写压力距离 Benchmark 值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用 pipelining 和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java性能优化</title>
      <link href="/2017/12/17/java/%20java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2017/12/17/java/%20java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>你是否正打算优化hashCode()方法？是否想要绕开正则表达式？Lukas Eder介绍了很多简单方便的性能优化小贴士以及扩展程序性能的技巧。</p><p>最近“全网域（Web Scale）”一词被炒得火热，人们也正在通过扩展他们的应用程序架构来使他们的系统变得更加“全网域”。但是究竟什么是全网域？或者说如何确保全网域？</p><h2 id="扩展的不同方面"><a href="#扩展的不同方面" class="headerlink" title="扩展的不同方面"></a>扩展的不同方面</h2><p>全网域被炒作的最多的是扩展负载（Scaling load），比如支持单个用户访问的系统也可以支持10 个、100个、甚至100万个用户访问。在理想情况下，我们的系统应该保持尽可能的“无状态化（stateless）”。即使必须存在状态，也可以在网络的不同处理终端上转化并进行传输。当负载成为瓶颈时候，可能就不会出现延迟。所以对于单个请求来说，耗费50到100毫秒也是可以接受的。这就是所谓的横向扩展（Scaling out）。</p><p>扩展在全网域优化中的表现则完全不同，比如确保成功处理一条数据的算法也可成功处理10条、100条甚至100万条数据。无论这种度量类型是是否可行，事件复杂度（大O符号）是最佳描述。延迟是性能扩展杀手。你会想尽办法将所有的运算处理在同一台机器上进行。这就是所谓的纵向扩展（Scaling up）。</p><p>如果天上能掉馅饼的话（当然这是不可能的），我们或许能把横向扩展和纵向扩展组合起来。但是，今天我们只打算介绍下面几条提升效率的简单方法。</p><h2 id="大O符号"><a href="#大O符号" class="headerlink" title="大O符号"></a>大O符号</h2><p>Java 7的 ForkJoinPool 和Java8 的并行数据流（parallel Stream） 都对并行处理有所帮助。当在多核处理器上部署Java程序时表现尤为明显，因所有的处理器都可以访问相同的内存。</p><p>所以，这种并行处理较之在跨网络的不同机器上进行扩展，根本的好处是几乎可以完全消除延迟。</p><p>但不要被并行处理的效果所迷惑！请谨记下面两点：</p><ul><li>并行处理会吃光处理器资源。并行处理为批处理带来了极大的好处，但同时也是非同步服务器（如HTTP）的噩梦。有很多原因可以解释，为什么在过去的几十年中我们一直在使用单线程的Servlet模型。并行处理仅在纵向扩展时才能带来实际的好处。</li><li>并行处理对算法复杂度没有影响。如果你的算法的时间复杂度为 O(nlogn)，让算法在 c 个处理器上运行，事件复杂度仍然为 O(nlogn&#x2F;c)， 因为 c 只是算法中的一个无关紧要的常量。你节省的仅仅是时钟时间（wall-clock time），实际的算法复杂度并没有降低。</li></ul><p>降低算法复杂度毫无疑问是改善性能最行之有效的办法。比如对于一个 HashMap 实例的 lookup() 方法来说，事件复杂度 O(1) 或者空间复杂度 O(1) 是最快的。但这种情况往往是不可能的，更别提轻易地实现。</p><p>如果你不能降低算法的复杂度，也可以通过找到算法中的关键点并加以改善的方法，来起到改善性能的作用。假设我们有下面这样的算法示意图：</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fnyolwd0qhj20a209ajrn.jpg"></p><p>该算法的整体时间复杂度为 O(N3)，如果按照单独访问顺序计算也可得出复杂度为 O(N x O x P)。但是不管怎样，在我们分析这段代码时会发现一些奇怪的场景：</p><ul><li>在开发环境中，通过测试数据可以看到：左分支（N-&gt;M-&gt;Heavy operation）的时间复杂度 M 的值要大于右边的 O 和 P，所以在我们的分析器中仅仅看到了左分支。</li><li>在生产环境中，你的维护团队可能会通过 AppDynamics、DynaTrace 或其它小工具发现，真正导致问题的罪魁祸首是右分支（N -&gt; O -&gt; P -&gt; Easy operation or also *N.O.P.E.*）。</li></ul><p>在没有生产数据参照的情况下，我们可能会轻易的得出要优化“高开销操作”的结论。但我们做出的优化对交付的产品没有起到任何效果。</p><p>优化的金科玉律不外乎以下内容：</p><ul><li>良好的设计将会使优化变得更加容易。</li><li>过早的优化并不能解决多有的性能问题，但是不良的设计将会导致优化难度的增加。</li></ul><p>理论就先谈到这里。假设我们已经发现了问题出现在了右分支上，很有可能是因产品中的简单处理因耗费了大量的时间而失去响应（假设N、O和 P 的值非常大）， 请注意文章中提及的左分支的时间复杂度为 O(N3)。这里所做出的努力并不能扩展，但可以为用户节省时间，将困难的性能改善推迟到后面再进行。</p><p>这里有10条改善Java性能的小建议：</p><h2 id="1、使用StringBuilder"><a href="#1、使用StringBuilder" class="headerlink" title="1、使用StringBuilder"></a>1、使用StringBuilder</h2><p>StingBuilder 应该是在我们的Java代码中默认使用的，应该避免使用 + 操作符。或许你会对 StringBuilder 的语法糖（syntax sugar）持有不同意见，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;a&quot; + args.length + &quot;b&quot;;</span><br></pre></td></tr></table></figure><p>将会被编译为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0  new java.lang.StringBuilder [16] 3  dup 4  ldc &lt;String &quot;a&quot;&gt; [18] 6  invokespecial java.lang.StringBuilder(java.lang.String) [20] 9  aload_0 [args]10  arraylength11  invokevirtual java.lang.StringBuilder.append(int) : java.lang.StringBuilder [23]14  ldc &lt;String &quot;b&quot;&gt; [27]16  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [29]19  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [32]22  astore_1 [x]</span><br></pre></td></tr></table></figure><p>但究竟发生了什么？接下来是否需要用下面的部分来对 String 进行改善呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;a&quot; + args.length + &quot;b&quot;;if (args.length == 1)    x = x + args[0];</span><br></pre></td></tr></table></figure><p>现在使用到了第二个 StringBuilder，而且这个 StringBuilder 不会消耗堆中额外的内存，但却给 GC 带来了压力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder x = new StringBuilder(&quot;a&quot;);x.append(args.length);x.append(&quot;b&quot;);if (args.length == 1);    x.append(args[0]);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上面的样例中，如果你是依靠Java编译器来隐式生成实例的话，那么编译的效果几乎和是否使用了 StringBuilder 实例毫无关系。请记住：在  N.O.P.E 分支中，每次CPU的循环的时间到白白的耗费在GC或者为 StringBuilder 分配默认空间上了，我们是在浪费 N x O x P 时间。</p><p>一般来说，使用 StringBuilder 的效果要优于使用 + 操作符。如果可能的话请在需要跨多个方法传递引用的情况下选择 StringBuilder，因为 String 要消耗额外的资源。JOOQ在生成复杂的SQL语句便使用了这样的方式。在整个抽象语法树（AST Abstract Syntax Tree）SQL传递过程中仅使用了一个 StringBuilder 。</p><p>更加悲剧的是，如果你仍在使用 StringBuffer 的话，那么用 StringBuilder 代替 StringBuffer 吧，毕竟需要同步字符串的情况真的不多。</p><h2 id="2、避免使用正则表达式"><a href="#2、避免使用正则表达式" class="headerlink" title="2、避免使用正则表达式"></a>2、避免使用正则表达式</h2><p>正则表达式给人的印象是快捷简便。但是在 N.O.P.E 分支中使用正则表达式将是最糟糕的决定。如果万不得已非要在计算密集型代码中使用正则表达式的话，至少要将 Pattern 缓存下来，避免反复编译Pattern。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final Pattern HEAVY_REGEX =    Pattern.compile(&quot;(((X)*Y)*Z)*&quot;);</span><br></pre></td></tr></table></figure><p>如果仅使用到了如下这样简单的正则表达式的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] parts = ipAddress.split(&quot;//.&quot;);</span><br></pre></td></tr></table></figure><p>这是最好还是用普通的 char[] 数组或者是基于索引的操作。比如下面这段可读性比较差的代码其实起到了相同的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int length = ipAddress.length();int offset = 0;int part = 0;for (int i = 0; i &lt; length; i++) &#123;    if (i == length - 1 ||            ipAddress.charAt(i + 1) == &#x27;.&#x27;) &#123;        parts[part] =            ipAddress.substring(offset, i + 1);        part++;        offset = i + 2;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码同时表明了过早的优化是没有意义的。虽然与 split() 方法相比较，这段代码的可维护性比较差。</p><p><strong>挑战：</strong>聪明的小伙伴能想出更快的算法吗？</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>正则表达式是十分有用，但是在使用时也要付出代价。尤其是在 N.O.P.E 分支深处时，要不惜一切代码避免使用正则表达式。还要小心各种使用到正则表达式的JDK字符串方法，比如 String.replaceAll() 或 String.split()。可以选择用比较流行的开发库，比如 Apache Commons Lang 来进行字符串操作。</p><h2 id="3、不要使用iterator-方法"><a href="#3、不要使用iterator-方法" class="headerlink" title="3、不要使用iterator()方法"></a>3、不要使用iterator()方法</h2><p>这条建议不适用于一般的场合，仅适用于在 N.O.P.E 分支深处的场景。尽管如此也应该有所了解。Java 5格式的循环写法非常的方便，以至于我们可以忘记内部的循环方法，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (String value : strings) &#123;    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><p>当每次代码运行到这个循环时，如果 strings 变量是一个 Iterable 的话，代码将会自动创建一个Iterator 的实例。如果使用的是 ArrayList 的话，虚拟机会自动在堆上为对象分配3个整数类型大小的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;    int cursor;    int lastRet = -1;    int expectedModCount = modCount;    // ...</span><br></pre></td></tr></table></figure><p>也可以用下面等价的循环方式来替代上面的 for 循环，仅仅是在栈上“浪费”了区区一个整形，相当划算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int size = strings.size();for (int i = 0; i &lt; size; i++) &#123;    String value : strings.get(i);    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><p>如果循环中字符串的值是不怎么变化，也可用数组来实现循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (String value : stringArray) &#123;    // Do something useful here&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>无论是从易读写的角度来说，还是从API设计的角度来说迭代器、Iterable接口和 foreach 循环都是非常好用的。但代价是，使用它们时是会额外在堆上为每个循环子创建一个对象。如果循环要执行很多很多遍，请注意避免生成无意义的实例，最好用基本的指针循环方式来代替上述迭代器、Iterable接口和 foreach 循环。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>一些与上述内容持反对意见的看法（尤其是用指针操作替代迭代器）详见Reddit上的讨论。</p><h2 id="4、不要调用高开销方法"><a href="#4、不要调用高开销方法" class="headerlink" title="4、不要调用高开销方法"></a>4、不要调用高开销方法</h2><p>有些方法的开销很大。以 N.O.P.E 分支为例，我们没有提到叶子的相关方法，不过这个可以有。假设我们的JDBC驱动需要排除万难去计算 ResultSet.wasNull() 方法的返回值。我们自己实现的SQL框架可能像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (type == Integer.class) &#123;    result = (T) wasNull(rs,        Integer.valueOf(rs.getInt(index)));&#125;// And then...static final &lt;T&gt; T wasNull(ResultSet rs, T value)throws SQLException &#123;    return rs.wasNull() ? null : value;&#125;</span><br></pre></td></tr></table></figure><p>在上面的逻辑中，每次从结果集中取得 int 值时都要调用 ResultSet.wasNull() 方法，但是 getInt() 的方法定义为：</p><blockquote><p>返回类型：变量值；如果SQL查询结果为NULL，则返回0。</p></blockquote><p>所以一个简单有效的改善方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;T extends Number&gt; T wasNull(    ResultSet rs, T value)throws SQLException &#123;    return (value == null ||           (value.intValue() == 0 &amp;&amp; rs.wasNull()))        ? null : value;&#125;</span><br></pre></td></tr></table></figure><p>这是轻而易举的事情。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>将方法调用缓存起来替代在叶子节点的高开销方法，或者在方法约定允许的情况下避免调用高开销方法。</p><h2 id="5、使用原始类型和栈"><a href="#5、使用原始类型和栈" class="headerlink" title="5、使用原始类型和栈"></a>5、使用原始类型和栈</h2><p>上面介绍了来自 jOOQ的例子中使用了大量的泛型，导致的结果是使用了 byte、 short、 int 和 long 的包装类。但至少泛型在Java 10或者Valhalla项目中被专门化之前，不应该成为代码的限制。因为可以通过下面的方法来进行替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//存储在堆上Integer i = 817598;</span><br></pre></td></tr></table></figure><p>……如果这样写的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 存储在栈上int i = 817598;</span><br></pre></td></tr></table></figure><p>在使用数组时情况可能会变得更加糟糕：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//在堆上生成了三个对象Integer[] i = &#123; 1337, 424242 &#125;;</span><br></pre></td></tr></table></figure><p>……如果这样写的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 仅在堆上生成了一个对象int[] i = &#123; 1337, 424242 &#125;;</span><br></pre></td></tr></table></figure><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>当我们处于 *N.O.P.E. *分支的深处时，应该极力避免使用包装类。这样做的坏处是给GC带来了很大的压力。GC将会为清除包装类生成的对象而忙得不可开交。</p><p>所以一个有效的优化方法是使用基本数据类型、定长数组，并用一系列分割变量来标识对象在数组中所处的位置。</p><p>遵循LGPL协议的 trove4j 是一个Java集合类库，它为我们提供了优于整形数组 int[] 更好的性能实现。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>下面的情况对这条规则例外：因为 boolean 和 byte 类型不足以让JDK为其提供缓存方法。我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean a1 = true; // ... syntax sugar for:Boolean a2 = Boolean.valueOf(true);Byte b1 = (byte) 123; // ... syntax sugar for:Byte b2 = Byte.valueOf((byte) 123);</span><br></pre></td></tr></table></figure><p>其它整数基本类型也有类似情况，比如 char、short、int、long。</p><p>不要在调用构造方法时将这些整型基本类型自动装箱或者调用 TheType.valueOf() 方法。</p><p>也不要在包装类上调用构造方法，除非你想得到一个不在堆上创建的实例。这样做的好处是为你为同事献上一个巨坑的愚人节笑话。</p><h2 id="非堆存储"><a href="#非堆存储" class="headerlink" title="非堆存储"></a>非堆存储</h2><p>当然了，如果你还想体验下堆外函数库的话，尽管这可能参杂着不少战略决策，而并非最乐观的本地方案。一篇由Peter Lawrey和 Ben Cotton撰写的关于非堆存储的很有意思文章请点击： OpenJDK与HashMap——让老手安全地掌握（非堆存储！）新技巧。</p><h2 id="6、避免递归"><a href="#6、避免递归" class="headerlink" title="6、避免递归"></a>6、避免递归</h2><p>现在，类似Scala这样的函数式编程语言都鼓励使用递归。因为递归通常意味着能分解到单独个体优化的尾递归（tail-recursing）。如果你使用的编程语言能够支持那是再好不过。不过即使如此，也要注意对算法的细微调整将会使尾递归变为普通递归。</p><p>希望编译器能自动探测到这一点，否则本来我们将为只需使用几个本地变量就能搞定的事情而白白浪费大量的堆栈框架（stack frames）。</p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>这节中没什么好说的，除了在 <em>N.O.P.E</em> 分支尽量使用迭代来代替递归。</p><h2 id="7、使用entrySet"><a href="#7、使用entrySet" class="headerlink" title="7、使用entrySet()"></a>7、使用entrySet()</h2><p>当我们想遍历一个用键值对形式保存的 Map 时，必须要为下面的代码找到一个很好的理由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;    V value : map.get(key);&#125;</span><br></pre></td></tr></table></figure><p>更不用说下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K, V&gt; entry : map.entrySet()) &#123;    K key = entry.getKey();    V value = entry.getValue();&#125;</span><br></pre></td></tr></table></figure><p>在我们使用 <em>N.O.P.E.</em> 分支应该慎用map。因为很多看似时间复杂度为 O(1) 的访问操作其实是由一系列的操作组成的。而且访问本身也不是免费的。至少，如果不得不使用map的话，那么要用 entrySet() 方法去迭代！这样的话，我们要访问的就仅仅是Map.Entry的实例。</p><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>在需要迭代键值对形式的Map时一定要用 entrySet() 方法。</p><h2 id="9、使用EnumSet或EnumMap"><a href="#9、使用EnumSet或EnumMap" class="headerlink" title="9、使用EnumSet或EnumMap"></a>9、使用EnumSet或EnumMap</h2><p>在某些情况下，比如在使用配置map时，我们可能会预先知道保存在map中键值。如果这个键值非常小，我们就应该考虑使用 EnumSet 或 EnumMap，而并非使用我们常用的 HashSet 或 HashMap。下面的代码给出了很清楚的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] vals;public V put(K key, V value) &#123;    // ...    int index = key.ordinal();    vals[index] = maskNull(value);    // ...&#125;</span><br></pre></td></tr></table></figure><p>上段代码的关键实现在于，我们用数组代替了哈希表。尤其是向map中插入新值时，所要做的仅仅是获得一个由编译器为每个枚举类型生成的常量序列号。如果有一个全局的map配置（例如只有一个实例），在增加访问速度的压力下，EnumMap 会获得比 HashMap 更加杰出的表现。原因在于 EnumMap 使用的堆内存比 HashMap 要少 一位（bit），而且 HashMap 要在每个键值上都要调用 hashCode() 方法和 equals() 方法。</p><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>Enum 和 EnumMap 是亲密的小伙伴。在我们用到类似枚举（enum-like）结构的键值时，就应该考虑将这些键值用声明为枚举类型，并将之作为 EnumMap 键。</p><h2 id="9、优化自定义hasCode-方法和equals-方法"><a href="#9、优化自定义hasCode-方法和equals-方法" class="headerlink" title="9、优化自定义hasCode()方法和equals()方法"></a>9、优化自定义hasCode()方法和equals()方法</h2><p>在不能使用EnumMap的情况下，至少也要优化 hashCode() 和 equals() 方法。一个好的 hashCode() 方法是很有必要的，因为它能防止对高开销 equals() 方法多余的调用。</p><p>在每个类的继承结构中，需要容易接受的简单对象。让我们看一下jOOQ的 org.jooq.Table 是如何实现的？</p><p>最简单、快速的 hashCode() 实现方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractTable一个通用Table的基础实现：@Overridepublic int hashCode() &#123;    // [#1938] 与标准的QueryParts相比，这是一个更加高效的hashCode()实现    return name.hashCode();&#125;</span><br></pre></td></tr></table></figure><p>name即为表名。我们甚至不需要考虑schema或者其它表属性，因为表名在数据库中通常是唯一的。并且变量 name 是一个字符串，它本身早就已经缓存了一个 hashCode() 值。</p><p>这段代码中注释十分重要，因继承自 AbstractQueryPart 的 AbstractTable 是任意抽象语法树元素的基本实现。普通抽象语法树元素并没有任何属性，所以不能对优化 hashCode() 方法实现抱有任何幻想。覆盖后的 hashCode() 方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractQueryPart一个通用抽象语法树基础实现：@Overridepublic int hashCode() &#123;    // 这是一个可工作的默认实现。    // 具体实现的子类应当覆盖此方法以提高性能。    return create().renderInlined(this).hashCode();&#125;</span><br></pre></td></tr></table></figure><p>换句话说，要触发整个SQL渲染工作流程（rendering workflow）来计算一个普通抽象语法树元素的hash代码。</p><p>equals() 方法则更加有趣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// AbstractTable通用表的基础实现：@Overridepublic boolean equals(Object that) &#123;    if (this == that) &#123;        return true;    &#125;    // [#2144] 在调用高开销的AbstractQueryPart.equals()方法前，    // 可以及早知道对象是否不相等。    if (that instanceof AbstractTable) &#123;        if (StringUtils.equals(name,            (((AbstractTable&lt;?&gt;) that).name))) &#123;            return super.equals(that);        &#125;        return false;    &#125;    return false;&#125;</span><br></pre></td></tr></table></figure><p>首先，不要过早使用 equals() 方法（不仅在*N.O.P.E.*中），如果：</p><ul><li>this &#x3D;&#x3D; argument</li><li>this“不兼容：参数</li></ul><p>注意：如果我们过早使用 instanceof 来检验兼容类型的话，后面的条件其实包含了argument &#x3D;&#x3D; null。</p><p>在我们对以上几种情况的比较结束后，应该能得出部分结论。比如jOOQ的 Table.equals() 方法说明是，用来比较两张表是否相同。不论具体实现类型如何，它们必须要有相同的字段名。比如下面两个元素是不可能相同的：</p><ul><li>com.example.generated.Tables.MY_TABLE</li><li>DSL.tableByName(“MY_OTHER_TABLE”)</li></ul><p>如果我们能方便地判断传入参数是否等于实例本身（this），就可以在返回结果为 false 的情况下放弃操作。如果返回结果为 true，我们还可以进一步对父类（super）实现进行判断。在比较过的大多数对象都不等的情况下，我们可以尽早结束方法来节省CPU的执行时间。</p><blockquote><p>一些对象的相似度比其它对象更高。</p></blockquote><p>在jOOQ中，大多数的表实例是由jOOQ的代码生成器生成的，这些实例的 equals() 方法都经过了深度优化。而数十种其它的表类型（衍生表 （derived tables）、表值函数（table-valued functions）、数组表（array tables）、连接表（joined tables）、数据透视表（pivot tables）、公用表表达式（common table expressions）等，则保持 equals() 方法的基本实现。</p><h2 id="10、考虑使用set而并非单个元素"><a href="#10、考虑使用set而并非单个元素" class="headerlink" title="10、考虑使用set而并非单个元素"></a>10、考虑使用set而并非单个元素</h2><p>最后，还有一种情况可以适用于所有语言而并非仅仅同Java有关。除此以外，我们以前研究的* N.O.P.E. *分支也会对了解从 O(N3) 到 O(n log n)有所帮助。</p><p>不幸的是，很多程序员的用简单的、本地算法来考虑问题。他们习惯按部就班地解决问题。这是命令式（imperative）的“是&#x2F;或”形式的函数式编程风格。这种编程风格在由纯粹命令式编程向面对象式编程向函数式编程转换时，很容易将“更大的场景（bigger picture）”模型化，但是这些风格都缺少了只有在SQL和R语言中存在的：</p><p>声明式编程。</p><p>在SQL中，我们可以在不考虑算法影响下声明要求数据库得到的效果。数据库可以根据数据类型，比如约束（constraints）、键（key）、索引（indexes）等不同来采取最佳的算法。</p><p>在理论上，我们最初在SQL和关系演算（relational calculus）后就有了基本的想法。在实践中，SQL的供应商们在过去的几十年中已经实现了基于开销的高效优化器CBOs (Cost-Based Optimisers) 。然后到了2010版，我们才终于将SQL的所有潜力全部挖掘出来。</p><p>但是我们还不需要用set方式来实现SQL。所有的语言和库都支持Sets、collections、bags、lists。使用set的主要好处是能使我们的代码变的简洁明了。比如下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeSet INTERSECT SomeOtherSet</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Java 8以前的写法Set result = new HashSet();for (Object candidate : someSet)    if (someOtherSet.contains(candidate))        result.add(candidate);// 即使采用Java 8也没有很大帮助someSet.stream()       .filter(someOtherSet::contains)       .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p>有些人可能会对函数式编程和Java 8能帮助我们写出更加简单、简洁的算法持有不同的意见。但这种看法不一定是对的。我们可以把命令式的Java 7循环转换成Java 8的Stream collection，但是我们还是采用了相同的算法。但SQL风格的表达式则是不同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeSet INTERSECT SomeOtherSet</span><br></pre></td></tr></table></figure><p>上面的代码在不同的引擎上可以有1000种不同的实现。我们今天所研究的是，在调用 INTERSECT 操作之前，更加智能地将两个set自动的转化为 EnumSet 。甚至我们可以在不需要调用底层的 Stream.parallel() 方法的情况下进行并行 INTERSECT 操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们讨论了关于*N.O.P.E.*分支的优化。比如深入高复杂性的算法。作为jOOQ的开发者，我们很乐于对SQL的生成进行优化。</p><ul><li>每条查询都用唯一的StringBuilder来生成。</li><li>模板引擎实际上处理的是字符而并非正则表达式。</li><li>选择尽可能的使用数组，尤其是在对监听器进行迭代时。</li><li>对JDBC的方法敬而远之。</li><li>等等。</li></ul><p>jOOQ处在“食物链的底端”，因为它是在离开JVM进入到DBMS时，被我们电脑程序所调用的最后一个API。位于食物链的底端意味着任何一条线路在jOOQ中被执行时都需要* N x O x P* 的时间，所以我要尽早进行优化。</p><p>我们的业务逻辑可能没有*N.O.P.E.*分支那么复杂。但是基础框架有可能十分复杂（本地SQL框架、本地库等）。所以需要按照我们今天提到的原则，用Java Mission Control 或其它工具进行复查，确认是否有需要优化的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx相关状态码总结</title>
      <link href="/2017/12/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目的旨在对http状态码含义做一个基本解释，不会太深入讨论每个状态码</p></blockquote><h1 id="http状态码分类"><a href="#http状态码分类" class="headerlink" title="http状态码分类"></a>http状态码分类</h1><ol><li>消息类（1字头）</li><li>成功类（2字头）</li><li>重定向类（3字头）</li><li>请求错误类（4字头）</li><li>服务器错误类（5、6字头）</li></ol><p>中途可能会穿插nginx自定义的http状态码，nginx状态码本身不属于http状态码了，只是在nginx内部自己定义的一套状态码，但是在nginx日志中，却经常出现</p><h1 id="请求错误类（客户端错误）"><a href="#请求错误类（客户端错误）" class="headerlink" title="请求错误类（客户端错误）"></a>请求错误类（客户端错误）</h1><h2 id="400"><a href="#400" class="headerlink" title="400"></a>400</h2><p>400的英文含义<code>400 Request Header Or Cookie Too Large</code>，顾名思义，头信息或者Cookie信息太多了<br>复现这个状态码只需要添加够长的头信息或者Cookie信息即可，构造一个curl请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --header &quot;Cookie:sidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidisidisisidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisidisidissidisisidisidisisidisidisisidisidisisidisidisisidisidisisi.....&quot; http://localhost:80</span><br></pre></td></tr></table></figure><p>执行这个curl命令可以看到提示：<br><img src="http://leanote.com/api/file/getImage?fileId=56c696edab64413c8b000739" alt="img"></p><h2 id="401"><a href="#401" class="headerlink" title="401"></a>401</h2><p>401的含义是<code>401 Authorization Required</code>,顾名思义，就是需要权限认证，但是客户端又没有通过认证。复现这个状态码必须对nginx调整成认证模式。现在，将nginx调成认证模式，nginx的server模块配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;    auth_basic &quot;secret&quot;;#认证模式    auth_basic_user_file /usr/local/nginx/passwd.db;#密码文件    root   html2;    index  index.html index.htm;&#125;</span><br></pre></td></tr></table></figure><p>接下来生成密码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# htpasswd -c /usr/local/nginx/passwd.db yongxiongzhongNew password: Re-type new password: Adding password for user yongxiongzhong</span><br></pre></td></tr></table></figure><p>更改权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 /usr/local/nginx/passwd.db</span><br></pre></td></tr></table></figure><p>平滑重启nginx之后，再次访问网页可以看到认证界面<br><img src="http://leanote.com/api/file/getImage?fileId=56c74371ab64413b37000dae" alt="img"><br>点击取消按钮，则可以看到以下这个页面<br><img src="http://leanote.com/api/file/getImage?fileId=56c743b6ab64413c8b000e2a" alt="img"></p><h2 id="403"><a href="#403" class="headerlink" title="403"></a>403</h2><p>403的出现，大部分是没有对文件进行授权。<code>403 Forbidden</code>顾名思义就是禁止访问，重现这个状态码只需要修改访问文件的权限，比如给nginx网站根目录中的index文件减少权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 0 /usr/local/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>当我们再次访问这个文件是，就会出现403错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c74731ab64413c8b000e39" alt="img"></p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>404算是我们经常碰到的状态码，<code>404 Not Found</code>当我们访问一个不存在的文件时，就会出现这个错误<br>在URL地址栏上随便访问一个不存在的文件，就会出现<br><img src="http://leanote.com/api/file/getImage?fileId=56c748b5ab64413c8b000e40" alt="img"><br>在实际生产环境中，这样的404页面并不好看，所以可以通过在server中配置自定义404页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page  404              /my_404.html;</span><br></pre></td></tr></table></figure><p>其中在网站根目录新建my_404.html然后写入自定义内容。平滑重启nginx之后，再次访问一些不存在的页面时会提示如下：<br><img src="http://leanote.com/api/file/getImage?fileId=56ca69f9ab64413b37001d8a" alt="img"></p><h2 id="405"><a href="#405" class="headerlink" title="405"></a>405</h2><p>405状态码并不算常见，它表示<code>405 Not Allowed</code>。http请求可以支持GET，POST，PUT，DELETE方式。默认情况下，如果你对一个html静态文件进行post请求的话，就会出现405错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c74c92ab64413b37000dd9" alt="img"></p><h2 id="413"><a href="#413" class="headerlink" title="413"></a>413</h2><p>413也是比较容易出现的一种状态码，413的出现常常伴随着<code>413 Request Entity Too Large</code>表示请求实体过大导致。用户上传的Content-Length大于nginx设定的最大值时。比如上传一张很大的图片，就会出现413错误码<br><img src="http://leanote.com/api/file/getImage?fileId=56c89aa1ab64413b3700152d" alt="img"><br>这个是由参数client_max_body_size控制的，默认是1M。有点小，所以一般线上环境调成以下配置即可消除上面的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size 8m;</span><br></pre></td></tr></table></figure><h2 id="414"><a href="#414" class="headerlink" title="414"></a>414</h2><p>一般出现这个错误的时候，也伴随着一段英文提示<code>414 Request-URI Too Large</code>，也就是说我们请求的url太长了，如果我们把一个很长的url放在浏览器地址栏上，浏览器的保护措施，并不会出现414报错。所以要重现这个414错误码，只能通过curl命令。申请如下一个很长的url,篇幅问题，最后用…代替：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/?key=abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefg....</span><br></pre></td></tr></table></figure><p>运行这个curl命令，就可以看到414错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c89ca0ab64413b37001539" alt="图片标题"><br>在nginx中，以下两个参数共同决定这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_sizelarge_client_header_buffers</span><br></pre></td></tr></table></figure><h2 id="499-nginx-status"><a href="#499-nginx-status" class="headerlink" title="499(nginx status)"></a>499(nginx status)</h2><p>499这个状态码并不是http协议中定义的status code，而是nginx自己定义的一个状态码。<br>当客户端主动断开连接的时候，nginx就会返回499的状态码。按照这个状态码的定义，复现这个状态码很容易，只要在nginx返回结果之前断开客户端连接。所以，下一个data.php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpsleep(10);//睡觉10秒钟</span><br></pre></td></tr></table></figure><p>然后在浏览器访问<a href="http://localhost:8000/data.php">http://localhost:8000/data.php</a>,注意，在10秒之内关闭浏览器以断开客户端连接。然后在查看nginx访问日志就能看到499错误<br><img src="http://leanote.com/api/file/getImage?fileId=56c9b087ab64413b37001a89" alt="img"><br>值得一提的是，在线上环境中，如果并发量大的话，nginx未能及时处理完请求，导致客户端“不干了”，这是会大量爆发499错误。这种情况可以用ab工具测试，ab工具中，-n为请求次数，-c为并发量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 100 -c 100 http://127.0.0.1:8000/data.php</span><br></pre></td></tr></table></figure><p>再观察我们的nginx访问日志，会发现大量的499<br><img src="http://leanote.com/api/file/getImage?fileId=56c9b174ab64413c8b001a58" alt="img"></p><h1 id="服务端错误"><a href="#服务端错误" class="headerlink" title="服务端错误"></a>服务端错误</h1><h2 id="500"><a href="#500" class="headerlink" title="500"></a>500</h2><p>http状态码500表示内部服务器错误，这个错误一般是php代码出现error导致，如果你没有关闭php错误提示，当写一个错误的php脚本时，网页上会出现以下错误提示<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a0f1ab64413c8b0019f2" alt="img"><br>但是一般情况下这些错误我们并不希望就这样暴露给客户端，因为将这些错误信息暴露是一件很危险的事情，别人可以通过你的错误猜测系统漏洞。所以在线上一般是关闭错误显示，关闭方式为：编辑php-fpm.conf关闭错误信息，保存php-fpm以下设置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_flag[display_errors] = off</span><br></pre></td></tr></table></figure><p>平滑重启php-fpm进程之后，再次访问一个包含错误语法的php错误的时候，会报500错误。<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a272ab64413c8b0019fe" alt="img"></p><h2 id="502"><a href="#502" class="headerlink" title="502"></a>502</h2><p>当出现502这个错误的时候，也伴随着一句英文<code>502 bad geteway</code>，很醒目的一段问题，出现这个错误的时候，因为这是服务端错误，可以定位<code>挂掉了</code>。Nginx 502错误的原因比较多，是因为在代理模式下后端服务器出现问题引起的。这些错误一般都不是nginx本身的问题，一定要从后端找原因。比如这里复现一种后端php-fpm进程挂掉的情况，关闭php-fpm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `ps aux | grep php-fpm | grep -v grep | awk -F &#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;`</span><br></pre></td></tr></table></figure><p>再次访问我们的php文件时候，然后就可以看到网站挂掉的情况<br><img src="http://leanote.com/api/file/getImage?fileId=56c9a4a0ab64413c8b001a0b" alt="img"></p><h2 id="503"><a href="#503" class="headerlink" title="503"></a>503</h2><p>注意，出现503的时候服务没挂，出现503的时候伴随着<code>503 Service Temporarily Unavailable</code>,这句话告诉我们服务是暂时性不可用，nginx官方文档上有说明这一点，</p><blockquote><p>Sets the shared memory zone and the maximum allowed number of connections for a given key value. When this limit is exceeded, the server will return the 503 (Service Temporarily Unavailable) error in reply to a request.</p></blockquote><p>简单的说，就是在控制请求频率和并发数，详细配置可以参考nginx官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn">http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn</a><br>这里只复现一种可能的情况，将nginx配置如下(两个核心配置，省去了很多)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http &#123;    limit_conn_zone $binary_remote_addr zone=addr:10m;    server &#123;        limit_conn addr 1;#并发数为1，好测试</span><br></pre></td></tr></table></figure><p>注意测试的时候，不是所有的连接都算进去，也就是并发数为1，并不代表只能并发1，nginx说明：</p><blockquote><p>Not all connections are counted. A connection is counted only if it has a request processed by the server and the whole request header has already been read.</p></blockquote><p>然后采用ab测试工具，运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 2 -c 2 http://127.0.0.1:8000/data.php</span><br></pre></td></tr></table></figure><p>查看nginx访问日志，可以看到503报错信息<br><img src="http://leanote.com/api/file/getImage?fileId=56cd6045ab64413c8b003002" alt="img"></p><h2 id="504"><a href="#504" class="headerlink" title="504"></a>504</h2><p>当出现504的时候也伴随着一段英文，<code>504 Gateway Time-out</code>，顾名思义，就是超时了，复现这个错误码也很简单。让你的php程序模拟耗时请求，比如把php脚本里添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpsleep(70);//模拟耗时，睡70秒echo &quot;睡醒了&quot;;</span><br></pre></td></tr></table></figure><p>然后通过域名访问这个脚本文件，就会出现超时的界面<br><img src="http://leanote.com/api/file/getImage?fileId=56c9c05eab64413b37001afc" alt="img"></p><h1 id="重定向和缓存"><a href="#重定向和缓存" class="headerlink" title="重定向和缓存"></a>重定向和缓存</h1><h2 id="301和302"><a href="#301和302" class="headerlink" title="301和302"></a>301和302</h2><p>之所以将这两个状态码放到一起，因为他们都是重定向，其中，<code>301永久重定向</code>，<code>302暂时重定向</code>。不管是暂时还是临时，对用户而言，这两者没什么区别，都是在访问A网站的时候跳转到了B网站，并看到浏览器上的地址栏变成了B网站的地址。有区别的是搜索引擎，搜索引擎是要建立索引规则和权重的，如果网站A被设定为永久重定向到B，那搜索引擎可以确定A的地址永久改变了，就会把B当做唯一有效的目标地址，这是搜索引擎会把老地址的PageRank等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。所以，所以只要网站不是临时性迁移，都会做301重定向。<br>在nginx的rewrite语法中有两个关键字<br><code>permanent——永久重定向 redirect——临时重定向</code><br>如果我们想要将.asp文件永久重定向到index页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.asp$ &#123;    rewrite ^(.*)$ /index.html permanent;&#125;</span><br></pre></td></tr></table></figure><p><img src="http://leanote.com/api/file/getImage?fileId=56c9bd30ab64413b37001aee" alt="img"><br>如果只想临时重定向到index页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.asp$ &#123;    rewrite ^(.*)$ /index.html redirect;&#125;</span><br></pre></td></tr></table></figure><p>再次访问页面是可以看到302冲重定向了,同样，浏览器地址栏上的地址变成了重定向后的地址<br><img src="http://leanote.com/api/file/getImage?fileId=56c9bdb0ab64413b37001af0" alt="img"></p><h2 id="304"><a href="#304" class="headerlink" title="304"></a>304</h2><p><code>304 Not Modified</code>,默认情况下，nginx会对静态文件进行缓存。为了节省网络宽带，nginx和浏览器会产生如下交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器客户端想请求一个文档，如果浏览器本地已经有缓存了，发送If-Modified-Since给Web服务器2. 服务器将文件最后修改时间将服务器的文档修改时间Last-Modified和浏览器发送过来的If-Modified-Since比较，如果两者一致，返回304给浏览器，告诉浏览器用本地缓存就好了，如果两者不一致，返回200给浏览器，告诉浏览器使用最新的文档</span><br></pre></td></tr></table></figure><p>在默认情况下，在浏览器中输入<code>http://localhost:8000/test.css</code>请求css文件<strong>两次</strong>就会出现304<br><img src="http://leanote.com/api/file/getImage?fileId=56cad79dab64413b37002183" alt="img"></p><p>如果在服务器端编辑<code>test.css</code>文件，由于这个时间文件最后修改时间发生了变更，这时服务器不会返回304状态码了。这时返回200状态码,两个的时间不一样了，浏览器采用最新的。</p><p><img src="http://leanote.com/api/file/getImage?fileId=56cadf78ab64413b370021b4" alt="img"></p><p>有关于各种缓存策略这里不做讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK总结</title>
      <link href="/2017/12/09/%E7%BD%91%E7%BB%9C/AWK%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/09/%E7%BD%91%E7%BB%9C/AWK%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>awk的总结文字，转载之</p></blockquote><hr><h3 id="Awk是什么"><a href="#Awk是什么" class="headerlink" title="Awk是什么"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#whatisawk">Awk是什么</a></h3><p>Awk、sed与grep，俗称Linux下的三剑客，它们之前有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交互式且面向字符流的编辑器（a “non-interactive” stream-oriented editor），而awk则是一门模式匹配的编程语言，因为它的主要功能是用于匹配文本并处理，同时它有一些编程语言才有的语法，例如函数、分支循环语句、变量等等，当然比起我们常见的编程语言，Awk相对比较简单。</p><p>使用Awk，我们可以做以下事情：</p><ul><li>将文本文件视为由字段和记录组成的文本数据库；</li><li>在操作文本数据库的过程中能够使用变量；</li><li>能够使用数学运算和字符串操作；</li><li>能够使用常见的编程结构，例如条件分支与循环；</li><li>能够格式化输出；</li><li>能够自定义函数；</li><li>能够在awk脚本中执行UNIX命令；</li><li>能够处理UNIX命令的输出结果；</li></ul><p>装备以上功能，awk能够做得事情非常多。但千里之行，始于足下，我们首先从最基本的命令行语法开始，一步一步得走入awk的编程世界。</p><hr><h3 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#commandusing">命令行语法</a></h3><p>同sed一样，awk的命令行语法也有两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [-F ERE] [-v assignment] ... program [argument ...]</span><br><span class="line">awk [-F ERE] -f progfile ...  [-v assignment] ...[argument ...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的program类似sed中的script，因为我们一直强调awk是一门编程语言，所以将awk的脚本视为一段代码。而awk的脚本同样可以写到一个文件中，并通过-f参数指定，这一点和sed是一样的。program一般多个pattern和action序列组成，当读入的记录匹配pattern时，才会执行相应的action命令。这里有一点要注意，在第一种形式中，除去命令行选项外，program参数一定要位于第一个位置。</p><p>Awk的输入被解析成多个记录（Record），默认情况下，记录的分隔符是\n，因此可以认为一行就是一个记录，记录的分隔符可以通过内置变量RS更改。当记录匹配某个pattern时，才会执行后续的action命令。</p><p>而每个记录由进一步地被分隔成多个字段（Field），默认情况下字段的分隔符是空白符，例如空格、制表符等等，也可以通过-F ERE选项或者内置变量FS更改。在awk中，可以通过$1，$2…来访问对应位置的字段，同时$0存放整个记录，这一点有点类似shell下的命令行位置参数。关于这些内容，我们会在下面详细介绍，这里你只要知道有这些东西就好。</p><p>标准的awk命令行参数主要由以下三个：</p><ul><li>-F ERE：定义字段分隔符，该选项的值可以是扩展的正则表达式（ERE）；</li><li>-f progfile：指定awk脚本，可以同时指定多个脚本，它们会按照在命令行中出现的顺序连接在一起；</li><li>-v assignment：定义awk变量，形式同awk中的变量赋值，即name&#x3D;value，赋值发生在awk处理文本之前；</li></ul><p>为了便于理解，这里举几个简单的例子。通过-F参数设置冒号:为分隔符，并打印各个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1:2:3&quot; | awk -F: &#x27;&#123;print $1 &quot; and &quot; $2 &quot; and &quot; $3&#125;&#x27;</span><br><span class="line">1 and 2 and 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在awk的脚本中访问通过-v选项设置的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo | awk -v a=1 &#x27;BEGIN &#123;print a&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看到，通过-v选项设置的变量在BEGIN的位置就可以访问了。BEGIN是一个特殊的pattern，它在awk处理输入之前就会执行，可以认为是一个初始化语句，与此对应的还有END。</p><p>好像还没介绍如何指定处理的文件，是不是最后的argument就是指定的文件？在看我这本书之前，我也是这样认为的，但是实际上arguemnt有两种形式，它们分别是输入文件（file）和变量赋值（assignment）。</p><p>awk可以同时指定多个输入文件，如果输入文件的文件名为’-‘，表示从标准输入读取内容。</p><p>变量赋值类似-v选项，它的形式为name&#x3D;value。awk中的变量名同一般的编程语言无太多区别，但是不能同awk的保留关键字重名，可以查看awk的man手册查询哪些是保留关键字。而变量值只有两种形式：字符串和数值。变量赋值必须位于脚本参数的后面，与文件名参数无先后顺序的要求，但是位于不同位置的赋值它的执行时机是不同的。</p><p>我们用实际的例子来解释这个区别，假设有两个文件：a和b，它们的内容分别如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat a</span><br><span class="line">file a</span><br><span class="line">cat b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了说明赋值操作发生的时机，我们在BEGIN，正常处理，END三个地方都打印变量的值。</p><p>第一种情况： 变量赋值位于所有文件名参数之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; var=1 a</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：赋值操作发生在正常处理之前，BEGIN动作之后。</p><p>第二种情况：变量赋值位于所有文件名之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1  </span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：赋值操作发生在正常处理之后，END动作之前。</p><p>第三种情况：变量赋值位于文件名之间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1 b</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>结果：赋值操作发生在处理前面的文件之后，并且位于处理后面的文件之前；</em></p><h5 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h5><ul><li>如果变量赋值在第一个文件参数之前，在BEGIN动作之后执行，影响到正常处理和END动作；</li><li>如果变量赋值在最后一个文件参数之后，在END动作之前执行，仅影响END动作；</li><li>如果文件参数不存在，情况同1所述；</li><li>如果变量赋值位于多个文件参数之间，在变量赋值前面的文件被处理后执行，影响到后续文件的处理和END动作；</li></ul><p>所以变量赋值一定要考虑清楚用途，否则比较容易出错，不过一般情况下也不会用到变量赋值。</p><p>自然地大家会将变量赋值与-v assignment选项进行比较，赋值的形式是一致的，但是-v选项的执行时机比变量赋值要早：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v var=a &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125;&#x27;</span><br><span class="line">BEGIN: a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，-v选项的赋值操作在BEGIN动作之前就执行了。</p><p>变量赋值一定要小心不要与保留关键字重名，否则会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v BEGIN=1 &#x27;BEGIN &#123;print &quot;BEGIN: &quot; BEGIN&#125;&#x27;</span><br><span class="line">awk: fatal: cannot use gawk builtin `BEGIN&#x27; as variable name</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="记录（Record）与字段（Field"><a href="#记录（Record）与字段（Field" class="headerlink" title="记录（Record）与字段（Field)"></a><a href="http://xiaoh.me/2016/03/23/awk-more/recordandfield">记录（Record）与字段（Field)</a></h3><p>对于数据库来说，一个数据库表是由多条记录组成的，每一行表示一条记录（Record）。每条记录由多列组成，每一列表示一个字段（Field)。Awk将一个文本文件视为一个文本数据库，因此它也有记录和字段的概念。默认情况下，记录的分隔符是回车，字段的分隔符是空白符，所以文本文件的每一行表示一个记录，而每一行中的内容被空白分隔成多个字段。利用字段和记录，awk就可以非常灵活地处理文件的内容。</p><p>可以通过-F选项来修改默认的字段分隔符，例如&#x2F;etc&#x2F;passwd的每一行都是由冒号分隔成多个字段的，所以这里就需要将分隔符设置成冒号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过$1引用第一人字段，类似地$2表示第二个字段，$3表示第三个字段…. $0则表示整个记录。内置变量NF记录着字段的个数，所以$NF表示最后一个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/false</span><br><span class="line">/bin/false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，$(NF-1)表示倒数第二个。</p><p>内置变量FS也可以用于更改字段分隔符，它记录着当前的字段分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print FS&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">:</span><br><span class="line">awk -v FS=: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记录的分隔符可以通过内置变量RS更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -v RS=: &#x27;&#123;print $0&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果将RS设置成空，行为有就一点怪异了，它会将连续不为空行的所有行（一个段落）当作一个记录，而且强制回车为字段分隔符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat awk_man.txt </span><br><span class="line">The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">which is specialized for textual data manipulation. An awk program is a sequence</span><br><span class="line">of patterns and corresponding actions.  When  input  is  read  that matches a </span><br><span class="line">pattern, the action associated with that pattern is carried out.</span><br><span class="line"></span><br><span class="line">Input shall be interpreted as a sequence of records. By default, a record is a line, </span><br><span class="line">less its terminating &lt;newline&gt;, but this can be changed by using the RS built-in </span><br><span class="line">variable. Each record of input shall be matched in turn against each pattern in the </span><br><span class="line">program. For each pattern matched, the associated action shall be executed.</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN &#123;RS=&quot;&quot;;FS=&quot;:&quot;&#125; &#123;print &quot;First line: &quot; $1&#125;&#x27; awk_man.txt </span><br><span class="line">First line: The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">First line: Input shall be interpreted as a sequence of records. By default, a record is a line,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，我们将变量赋值放到BEGIN动作中执行，因为BEGIN动作是在文件处理之前执行的，专门用于放初始化的语句。FS的赋值在这里是无效的，awk依然使用回车符来分隔字段。</p><hr><h3 id="脚本（Script）组成"><a href="#脚本（Script）组成" class="headerlink" title="脚本（Script）组成"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#script">脚本（Script）组成</a></h3><p>命令行中的program部分，可以称为awk代码,也可以称为awk脚本。一段awk脚本是由多个’pattern { action }‘序列组成的。action是一个或者多个语句，它在输入行匹配pattern的时候被执行。如果pattern为空，表明这个action会在每一行处理时都会被执行。下面的例子简单地打印文件的每一行，这里不带任何参数的print语句打印的是整个记录，类似’print $0‘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;line1\nline2&#x27; | awk &#x27;&#123;print&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了pattern { action }，还可以在脚本中定义自定义的函数，函数定义格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function name(parameter list) &#123; statements &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的参数列表用逗号分隔，参数默认是局部变量，无法在函数之外访问，而在函数中定义的变量为全局变量，可以在函数之外访问，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo line1 | awk &#x27;</span><br><span class="line">function t(a) &#123;</span><br><span class="line">    b=a;</span><br><span class="line">    print a;</span><br><span class="line">&#125; </span><br><span class="line">&#123;</span><br><span class="line">    print b;</span><br><span class="line">    t(&quot;kodango.me&quot;); </span><br><span class="line">    print b;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Awk脚本中的语句使用空行或者分号分隔，使用分号可以放在同一行，不过有时候会影响可读性，尤其是分支或循环结构中，很容易出错。</p><p>如果Awk中的一个语句太长，要分成多行，可以在行为使用反斜杠’’：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat test.awk</span><br><span class="line">function t(a)</span><br><span class="line">&#123;</span><br><span class="line">        b=a</span><br><span class="line">        print &quot;This is a very long line, so use backslash to escape the newline then we will print the variable a: a=&quot; a</span><br><span class="line">&#125; </span><br><span class="line">&#123; print b; t(&quot;kodango.me&quot;); print b;&#125;</span><br><span class="line">echo 1 | awk -f test.awk</span><br><span class="line"></span><br><span class="line">This is a very long line, so use backslash to escape the newline then we will print the variable a: a=kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>这里我们将脚本写到文件中，并通过-f参数来指定。但是，在一些特殊符号之后，是可以直接换行的，例如”, { &amp;&amp;</th><th></th><th>”。</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="模式（Pattern）"><a href="#模式（Pattern）" class="headerlink" title="模式（Pattern）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#pattern">模式（Pattern）</a></h3><p>模式是awk中比较重要的一部分，它有以下几种情况：</p><ul><li>&#x2F;regular expression&#x2F;： 扩展的正则表达式（Extended Regular Expression）， 关于ERE可以参考 <a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">这篇文章</a>；</li><li>relational expression： 关系表达式，例如大于、小于、等于，关系表达式结果为true表示匹配；</li><li>BEGIN： 特殊的模式，在第一个记录处理之前被执行，常用于初始化语句的执行；</li><li>END： 特殊的模式，在最后一个记录处理之前被执行，常用于输出汇总信息；</li><li>pattern, pattern：模式对，匹配两者之间的所有记录，类似sed的地址对；</li></ul><p>例如查找匹配数字3的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 20 | awk &#x27;/3/ &#123;print&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相反地，可以在在正则表达式之前加上’!’表示不匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;!/3/ &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>除了BEGIN和END这两个特殊的模式外，其余的模式都可以使用’&amp;&amp;’或者’</th><th></th><th>’运算符组合，前者表示逻辑与，后者表示逻辑或：</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 50 | awk &#x27;/3/ &amp;&amp; /1/ &#123;print&#125;&#x27;</span><br><span class="line">13</span><br><span class="line">31</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面的正则都是整行匹配，有时候仅仅需要匹配某个字符，这样我们可以用表达式$n ~ &#x2F;ere&#x2F;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;$1 ~ /xi/ &#123;print&#125;&#x27; /etc/passwd</span><br><span class="line">xingming:x:1000:1000::/home/xingming:/bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时候我们只想显示特定和行，例如显示第一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;NR==1 &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="正则表达式（Regular-Expression）"><a href="#正则表达式（Regular-Expression）" class="headerlink" title="正则表达式（Regular Expression）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#regex">正则表达式（Regular Expression）</a></h3><p>正则表达式的内容介绍起来太麻烦，还是推荐同学阅读现有的文章（如 <a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux&#x2F;Unix工具与正则表达式的POSIX规范</a>），里面对各个流派的正则表达式归纳地很清楚了。</p><hr><h3 id="表达式（Expressions）"><a href="#表达式（Expressions）" class="headerlink" title="表达式（Expressions）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#expressions">表达式（Expressions）</a></h3><p>表达式可以由常量、变量、运算符和函数组成，常数和变量的值可以为字符串和数值。</p><p>Awk中的变量有三种类型：用户定义的变量，内置变量和字段变量。其中，内置变量名都是大写的。变量并不非一定要被声明或者被初始化，未初始化的字符串变量的值为””，未初始化的数值变量的值为0。字段变量可以用$n来引用，n的取值范围为[0,NF]。n可以为一个变量，例如$NF代码最后一个字段，而$(NF-1)表示倒数第二个字段。</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#array">数组</a></h3><p>数组是一种特殊的变量，在awk中，比较特殊地是，数组的下标可以为数字或者字符串。数组的赋值很简单，下面将value赋值给数组下标为index的元素：<code>array[index]=value</code></p><p>可以用for..in..语法遍历数组元素，其中item是数组元素对应的下标：<code>for (item in array)</code></p><p>当然也可以在if分支判断中使用in操作符：<code>if (item in array)</code></p><p>一个完整的例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2 3&quot; | awk &#x27;&#123;</span><br><span class="line">    for (i=0;i&lt;NF;i++)</span><br><span class="line">          a[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">END &#123;</span><br><span class="line">    print 3 in a</span><br><span class="line">        for (i in a)</span><br><span class="line">               printf &quot;%s: %s\n&quot;, i, a[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">0</span><br><span class="line">0: 0</span><br><span class="line">1: 1</span><br><span class="line">2: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#innervalue">内置变量</a></h3><p>Awk在内部维护了许多内置变量，或者称为系统变量，例如之前提到的FS、RS等等。常见的内置变量如下表所示</p><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>ARGC</td><td>命令行参数的各个，即ARGV数组的长度</td></tr><tr><td>ARGV</td><td>存放命令行参数</td></tr><tr><td>CONVFMT</td><td>定义awk内部数值转换成字符串的格式，默认值为”%.6g”</td></tr><tr><td>OFMT</td><td>定义输出时数值转换成字符串的格式，默认值为”%.6g”</td></tr><tr><td>ENVIRON</td><td>存放系统环境变量的关联数组</td></tr><tr><td>FILENAME</td><td>当前被处理的文件名</td></tr><tr><td>NR</td><td>记录的总个数</td></tr><tr><td>FNR</td><td>当前文件中的记录的总个数</td></tr><tr><td>FS</td><td>字段分隔符，默认为空白</td></tr><tr><td>NF</td><td>每个记录中字段的个数</td></tr><tr><td>RS</td><td>记录的分隔符，默认为回车</td></tr><tr><td>OFS</td><td>输出时字段的分隔符，默认为空白</td></tr><tr><td>ORS</td><td>输出时记录的分隔符，默认为回车</td></tr><tr><td>RLENGTH</td><td>被match函数匹配的子串长度</td></tr><tr><td>RSTART</td><td>被match函数匹配的子串位于目标字符串的起始下标</td></tr></tbody></table><p>下面主要介绍几个比较难理解的内置变量：</p><h5 id="ARGV与ARGC"><a href="#ARGV与ARGC" class="headerlink" title="ARGV与ARGC"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#argvargc">ARGV与ARGC</a></h5><p>ARGV与ARGC的意思比较好理解，就像C语言 <code>main(int argc, char **argv)</code>。ARGV数组的下标从0开始到ARGC-1，它存放的是命令行参数，并且排除命令行选项（例如-v&#x2F;-f）以及program部分。因此事实上ARGV只是存储argument的部分，即文件名（file）以及命令行变量赋值两部分的内容。</p><p>通过下面的例子可以大概了解ARGC与ARGV的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    for (i = 0; i &lt; ARGC; i++)</span><br><span class="line">        print ARGV[i]</span><br><span class="line">&#125;&#x27; inventory-shipped BBS-list</span><br><span class="line">awk</span><br><span class="line">inventory-shipped</span><br><span class="line">BBS-list</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ARGV的用法不仅限于此，它是可以修改的，可以更改数组元素的值，可以增加数组元素或者删除数组元素。</p><h6 id="更改ARGV元素的值"><a href="#更改ARGV元素的值" class="headerlink" title="更改ARGV元素的值"></a>更改ARGV元素的值</h6><p>假设我们有a, b两个文件，它们各有一行内容：file a和file b。现在利用ARGV，我们可以做到偷梁换柱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;b&quot;&#125; &#123;print&#125;&#x27; a</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里要注意ARGV[1]&#x3D;”b”的引号不能缺少，否则ARGV[1]&#x3D;b会将变量b的值赋值给ARGV[1]。</p><p>当awk处理完一个文件之后，它会从ARGV的下一个元素获取参数，如果是一个文件则继续处理，如果是一个变量赋值则执行赋值操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;var=1&quot;&#125; &#123;print var&#125;&#x27; a b</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当下一个元素为空时，则跳过不处理，这样可以避开处理某个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中a这个文件就被跳过了。</p><p>而当下一个元素的值为”-”时，表明从标准输入读取内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;-&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">a</span><br><span class="line">a    # --&gt; 这里按下CTRL+D停止输入</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="删除ARGV元素"><a href="#删除ARGV元素" class="headerlink" title="删除ARGV元素"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#deleteargv">删除ARGV元素</a></h6><p>删除ARGV元素和将元素的值赋值为空的效果是一样的，它们都会跳转对某个参数的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;delete ARGV[1]&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除数组元素可以用delete语句。</p><h6 id="增加ARGV元素"><a href="#增加ARGV元素" class="headerlink" title="增加ARGV元素"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#addingargv">增加ARGV元素</a></h6><p>我第一次看到ARGV变量的时候就在想，能不能利用ARGV变量避免提供命令行参数，就像这样: <code>awk &#39;BEGIN&#123;ARGV[1]=&quot;a&quot;;&#125; &#123;print&#125;&#39;</code></p><p>但是事实上这样不行，awk会依然从标准输入中获取内容。下面的方法倒是可以，首先增加ARGC的值，再增加ARGV元素，我到现在也没搞懂这两者的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGC+=1;ARGV[1]=&quot;a&quot;&#125; &#123;print&#125;&#x27;</span><br><span class="line">file a</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CONVFMT与OFMT"><a href="#CONVFMT与OFMT" class="headerlink" title="CONVFMT与OFMT"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#convfmtofmt">CONVFMT与OFMT</a></h5><p>Awk中允许数值到字符串相互转换，其中内置变量CONVFMT定义了awk内部数值到字符串转换的格式，它的默认值为”%.6g”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11</span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%.6g, num=12.110000, str=12.11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过更改CONVFMT，我们可以定义自己的转换格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    CONVFMT=&quot;%d&quot;;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11 </span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%d, num=12.110000, str=12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与此对应地还有一个内置变量 <em>OFMT</em>，它与CONVFMT的作用是类似的，只不过是影响输出的时候数字转换成字符串的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; OFMT=&quot;%d&quot;;print 12.11 &#125;&#x27; </span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ENVIRON"><a href="#ENVIRON" class="headerlink" title="ENVIRON"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#environ">ENVIRON</a></h5><p>ENVIRON是一个存放系统环境变量的关联数组，它的下标是环境变量名称，值是相应环境变量的值。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print ENVIRON[&quot;USER&quot;] &#125;&#x27; </span><br><span class="line">xingming</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用环境变量也可以将值传递给awk：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">U=hello awk &#x27;BEGIN &#123; print ENVIRON[&quot;U&quot;] &#125;&#x27; </span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以利用for..in循环遍历ENVIRON数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    for (env in ENVIRON) </span><br><span class="line">        printf &quot;%s=%s\n&quot;, env, ENVIRON[env]; </span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="RLENGTH与RSTART"><a href="#RLENGTH与RSTART" class="headerlink" title="RLENGTH与RSTART"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#rlengthrstart">RLENGTH与RSTART</a></h5><p>RLENGTH与RSTART都是与match函数相关的，前者表示匹配的子串长度，后者表示匹配的子串位于目标字符串的起始下标。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;match(&quot;hello,world&quot;, /llo/); print RSTART,RLENGTH&#125;&#x27;</span><br><span class="line">3 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#yunsuanfu">运算符</a></h3><p>表达式中必然少不了运算符，awk支持的运算符可以参见man手册中的“Expressions in awk”一小节内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man awk | grep &quot;^ *Table: Expressions in&quot; -A 42 | sed &#x27;s/^ *//&#x27;</span><br><span class="line">Table: Expressions in Decreasing Precedence in awk</span><br><span class="line"> </span><br><span class="line">Syntax                Name                      Type of Result   Associativity</span><br><span class="line">( expr )              Grouping                  Type of expr     N/A</span><br><span class="line">$expr                 Field reference           String           N/A</span><br><span class="line">++ lvalue             Pre-increment             Numeric          N/A</span><br><span class="line">-- lvalue             Pre-decrement             Numeric          N/A</span><br><span class="line">lvalue ++             Post-increment            Numeric          N/A</span><br><span class="line">lvalue --             Post-decrement            Numeric          N/A</span><br><span class="line">expr ^ expr           Exponentiation            Numeric          Right</span><br><span class="line">! expr                Logical not               Numeric          N/A</span><br><span class="line"> </span><br><span class="line">+ expr                Unary plus                Numeric          N/A</span><br><span class="line">- expr                Unary minus               Numeric          N/A</span><br><span class="line">expr * expr           Multiplication            Numeric          Left</span><br><span class="line"> </span><br><span class="line">...以下省略...</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="语句（Statement）"><a href="#语句（Statement）" class="headerlink" title="语句（Statement）"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#statement">语句（Statement）</a></h3><p>到目前为止，用得比较多的语句就是print，其它的还有printf、delete、break、continue、exit、next等等。这些语句与函数不同的是，它们不会使用带括号的参数，并且没有返回值。不过也有意外，比如printf就可以像函数一样的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk &#x27;&#123;printf(&quot;%s\n&quot;, &quot;abc&quot;)&#125;&#x27;</span><br><span class="line">abc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>break和continue语句，大家应该比较了解，分别用于跳出循环和跳到下一个循环。</p><p>delete用于删除数组中的某个元素，这个我们在上面介绍ARGV的时候也使用过。</p><p>exit的用法顾名思义，就是退出awk的处理，然后会执行END部分的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;print;exit&#125; END &#123;print &quot;exit..&quot;&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">exit..</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>next语句类似sed的n命令，它会读取下一条记录，并重新回到脚本的最开始处执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;</span><br><span class="line">    print &quot;Before next..&quot;</span><br><span class="line">    print $0 </span><br><span class="line">    next</span><br><span class="line">    print &quot;After next..&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">Before next..</span><br><span class="line">line1</span><br><span class="line">Before next..</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看出next后面的print语句不会执行。</p><p>print与printf语句是使用最多的，它们将内容输出到标准输出。注意在print语句中，输出的变量之间带不带逗号是有区别的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1, $2&#125;&#x27;</span><br><span class="line">1 2</span><br><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1 $2&#125;&#x27;</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>print输出时，字段之间的分隔符可以由OFS重新定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1 2&quot; | awk &#x27;&#123;OFS=&quot;;&quot;;print $1,$2&#125;&#x27;</span><br><span class="line">1;2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，print的输出还可以重定向到某个文件中或者某个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print items &gt; output-file</span><br><span class="line">print items &gt;&gt; output-file</span><br><span class="line">print items | command</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设有这一样一个文件，第一列是语句名称，第二列是对应的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat column.txt </span><br><span class="line">statement|description</span><br><span class="line">delete|delete item from an array</span><br><span class="line">exit|exit from the awk process</span><br><span class="line">next|read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们要将两列的内容分别输出到statement.txt和description.txt两个文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&#x27;|&#x27; &#x27;&#123;</span><br><span class="line">    print $1 &gt; &quot;statement.txt&quot;;</span><br><span class="line">    print $2 &gt; &quot;description.txt&quot;</span><br><span class="line">&#125;&#x27; column.txt </span><br><span class="line">[kodango@devops awk_temp]$ cat statement.txt </span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line">[kodango@devops awk_temp]$ cat description.txt </span><br><span class="line">description</span><br><span class="line">delete item from an array</span><br><span class="line">exit from the awk process</span><br><span class="line">read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个重定向到命令的例子，假设我们要对下面的文件进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat num.list </span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以通过将print的内容重定向到”sort -n”命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;print | &quot;sort -n&quot;&#125;&#x27; num.list </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>printf命令的用法与print类似，也可以重定向到文件或者输出，只不过printf比print多了格式化字符串的功能。printf的语法也大多数语言包括bash的printf命令类似，这里就不多介绍了。</p><hr><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#mathfunction">数学函数</a></h3><p>awk中支持以下数学函数：</p><ul><li>atan2(y,x)：反正切函数；</li><li>cos(x)：余弦函数；</li><li>sin(x)：正弦函数；</li><li>exp(x)：以自然对数e为底指数函数；</li><li>log(x)：计算以e 为底的对数值；</li><li>sqrt(x)：开平方函数；</li><li>int(x)：将数值转换成整数（绝对值）；</li><li>rand()：返回0到1的一个随机数值，不包含1；</li><li>srand([expr])：设置随机种子，一般与rand函数配合使用，如果参数为空，默认使用当前时间为种子；</li></ul><p>例如，我们使用rand()函数生成一个随机数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是你会发现，每次awk执行都会生成同样的随机数，但是在一次执行过程中产生的随机数又是不同的。因为每次awk执行都使用了同样的种子，所以我们可以用srand()函数来设置种子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.171625 0.00692412</span><br><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.43269 0.782984</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样每次生成的随机数就不一样了。</p><p>利用rand()函数我们也可以生成1到n的整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;</span><br><span class="line">    function randint(n) &#123; return int(n*rand()); &#125;</span><br><span class="line">    BEGIN &#123; srand(); print randint(10);</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#string">字符串函数</a></h3><p>awk中包含大多数常见的字符串操作函数。</p><h5 id="sub"><a href="#sub" class="headerlink" title="sub"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#sub">sub</a></h5><p><em>sub(ere, repl[, in])</em></p><p>描述：简单地说，就是将in中匹配ere的部分替换成repl，返回值是替换的次数。如果in参数省略，默认使用$0。替换的动作会直接修改变量的值。</p><p>下面是一个简单的替换的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello, world&quot; | awk &#x27;&#123;print sub(/ello/, &quot;i&quot;); print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">hi, world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在repl参数中&amp;是一个元字符，它表示匹配的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;var=&quot;kodango&quot;; sub(/kodango/, &quot;hello, &amp;&quot;, var); print var&#125;&#x27;</span><br><span class="line">hello, kodango</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="gsub"><a href="#gsub" class="headerlink" title="gsub"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#gsub">gsub</a></h5><p><em>gsub(ere, repl[, in])</em></p><p>描述：同sub()函数功能类似，只不过是gsub()是全局替换，即替换所有匹配的内容。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#index">index</a></h5><p><em>index(s, t)</em></p><p>描述：返回字符串t在s中出现的位置，注意这里位置是从1开始计算的，如果没有找到则返回0。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;n&quot;)&#125;&#x27;</span><br><span class="line">2</span><br><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;w&quot;)&#125;&#x27;</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="length"><a href="#length" class="headerlink" title="length"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#length">length</a></h5><p><em>length[([s])]</em></p><p>描述：返回字符串的长度，如果参数s没有指定，则默认使用$0作为参数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print length(&#x27;xingming&#x27;);&#125;&#x27;</span><br><span class="line">8</span><br><span class="line">$ echo &quot;first line&quot; | awk &#x27;&#123;print length();&#125;&#x27;</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="match"><a href="#match" class="headerlink" title="match"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#match">match</a></h5><p><em>match(s, ere)</em></p><p>描述： 返回字符串s匹配ere的起始位置，如果不匹配则返回0。该函数会定义RSTART和RLENGTH两个内置变量。RSTART与返回值相同，RLENGTH记录匹配子串的长度，如果不匹配则为-1。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">print match(&quot;xingming&quot;, /ngmin/);</span><br><span class="line">printf &quot;Matched at: %d, Matched substr length: %d\n&quot;, RSTART, RLENGTH;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">Matched at: 3, Matched substr length: 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="split"><a href="#split" class="headerlink" title="split"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#split">split</a></h5><p><em>split(s, a[, fs])</em></p><p>描述：将字符串按照分隔符fs，分隔成多个部分，并存到数组a中。注意，存放的位置是从第1个数组元素开始的。如果fs为空，则默认使用FS分隔。函数返回值分隔的个数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i in arr)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有一个奇怪的地方是for..in..输出的数组不是按顺序输出的，如果要按顺序输出可以用常规的for循环:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    n=split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i=1; i&lt;=n; i++)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#sprintf">sprintf</a></h5><p><em>sprintf(fmt, expr, expr, …)</em></p><p>描述：类似printf，只不过不会将格式化后的内容输出到标准输出，而是当作返回值返回。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    var=sprintf(&quot;%s=%s&quot;, &quot;name&quot;, &quot;value&quot;)</span><br><span class="line">    print var</span><br><span class="line">&#125;&#x27;</span><br><span class="line">name=value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="substr"><a href="#substr" class="headerlink" title="substr"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#substr">substr</a></h5><p><em>substr(s, m[, n])</em></p><p>描述：返回从位置m开始的，长度为n的子串，其中位置从1开始计算，如果未指定n或者n值大于剩余的字符个数，则子串一直到字符串末尾为止。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2, 3); &#125;&#x27;</span><br><span class="line">iao</span><br><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2); &#125;&#x27;</span><br><span class="line">iaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#tolower">tolower</a></h5><p><em>tolower(s)</em></p><p>描述：将字符串转换成小写字符。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print tolower(&quot;XIAOH.ME&quot;);&#125;&#x27;</span><br><span class="line">xiaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="toupper"><a href="#toupper" class="headerlink" title="toupper"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#toupper">toupper</a></h5><p><em>toupper(s)</em></p><p>描述：将字符串转换成大写字符。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print toupper(&#x27;xiaoh.me&#x27;)&#125;&#x27;</span><br><span class="line">XIAOH.ME</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="I-x2F-O处理函数"><a href="#I-x2F-O处理函数" class="headerlink" title="I&#x2F;O处理函数"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#io">I&#x2F;O处理函数</a></h3><h5 id="getline"><a href="#getline" class="headerlink" title="getline"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#getline">getline</a></h5><p>getline的用法相对比较复杂，它有几种不同的形式。不过它的主要作用就是从输入中每次获取一行输入。</p><h6 id="expression-getline-var"><a href="#expression-getline-var" class="headerlink" title="expression | getline [var]"></a><code>expression | getline [var]</code></h6><p>这种形式将前面管道前命令输出的结果作为getline的输入，每次读取一行。如果后面跟有var，则将读取的内容保存到var变量中，否则会重新设置$0和NF。</p><p>例如，我们将上面的statement.txt文件的内容显示作为getline的输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline var) print var&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中命令要用双引号，<code>cat statement.txt</code>，这一点同print&#x2F;printf是一样的。</p><p>如果不加var，则直接写到$0中，注意NF值也会被更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline) print $0,NF&#125;&#x27;</span><br><span class="line">statement 1</span><br><span class="line">delete 1</span><br><span class="line">exit 1</span><br><span class="line">next 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getline-var"><a href="#getline-var" class="headerlink" title="getline [var]"></a><code>getline [var]</code></h6><p>第二种形式是直接使用getline，它会从处理的文件中读取输入。同样地，如果var没有，则会设置$0，并且这时候会更新NF, NR和FNR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;</span><br><span class="line">    while (getline) </span><br><span class="line">       print NF, NR, FNR, $0;</span><br><span class="line">&#125;&#x27; statement.txt</span><br><span class="line">1 2 2 delete</span><br><span class="line">1 3 3 exit</span><br><span class="line">1 4 4 next</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getline-var-lt-expression"><a href="#getline-var-lt-expression" class="headerlink" title="getline [var] &lt; expression"></a><code>getline [var] &lt; expression</code></h6><p>第三种形式从expression中重定向输入，与第一种方法类似，这里就不加赘述了。</p><h5 id="close"><a href="#close" class="headerlink" title="close"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#close">close</a></h5><p>close函数可以用于关闭已经打开的文件或者管道，例如getline函数的第一种形式用到管道，我们可以用close函数把这个管道关闭，close函数的参数与管道的命令一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    while(&quot;cat statement.txt&quot; | getline) &#123;</span><br><span class="line">        print $0;</span><br><span class="line">        close(&quot;cat statement.txt&quot;);</span><br><span class="line">&#125;&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是每次读了一行后，关闭管道，然后重新打开又重新读取第一行就死循环了。所以要慎用，一般情况下也很少会用到close函数。</p><h5 id="system"><a href="#system" class="headerlink" title="system"></a><a href="http://xiaoh.me/2016/03/23/awk-more/#system">system</a></h5><p>这个函数很简单，就是用于执行外部命令，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;system(&quot;uname -r&quot;);&#125;&#x27;</span><br><span class="line">3.6.2-1-ARCH</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>快速了解Awk系列的几篇文章相对比较粗糙，我是参考Awk的man手册以及《Sed &amp; Awk》附录B总结而成的，但是应该可以让大家对awk有一个大致的了解，欢迎大家一起交流。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用函数总结</title>
      <link href="/2017/12/06/%E5%89%8D%E7%AB%AF/%20js%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/06/%E5%89%8D%E7%AB%AF/%20js%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>发现一篇整理的不错的，常用JS函数，支持下作者。</p></blockquote><ul><li><a href="https://github.com/proYang/outils">作者github，start</a></li></ul><h1 id="常用函数汇总"><a href="#常用函数汇总" class="headerlink" title="常用函数汇总"></a>常用函数汇总</h1><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h3 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断两个数组是否相等</span><br><span class="line"> * @param &#123;Array&#125; arr1 </span><br><span class="line"> * @param &#123;Array&#125; arr2 </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function arrayEqual(arr1, arr2) &#123;</span><br><span class="line">    if (arr1 === arr2) return true;</span><br><span class="line">    if (arr1.length != arr2.length) return false;</span><br><span class="line">    for (var i = 0; i &lt; arr1.length; ++i) &#123;</span><br><span class="line">        if (arr1[i] !== arr2[i]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h3 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   为元素添加class</span><br><span class="line"> * @param  &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param  &#123;String&#125; cls </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var hasClass = require(&#x27;./hasClass&#x27;);</span><br><span class="line"></span><br><span class="line">function addClass(ele, cls) &#123;</span><br><span class="line">    if (!hasClass(ele, cls)) &#123;</span><br><span class="line">        ele.className += &#x27; &#x27; + cls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-hasClass"><a href="#2-2-hasClass" class="headerlink" title="2.2 hasClass"></a>2.2 hasClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断元素是否有某个class</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param &#123;String&#125; cls </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function hasClass(ele, cls) &#123;</span><br><span class="line">    return (new RegExp(&#x27;(\\s|^)&#x27; + cls + &#x27;(\\s|$)&#x27;)).test(ele.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-removeClass"><a href="#2-3-removeClass" class="headerlink" title="2.3 removeClass"></a>2.3 removeClass</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 为元素移除class</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @param &#123;String&#125; cls </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var hasClass = require(&#x27;./hasClass&#x27;);</span><br><span class="line"></span><br><span class="line">function removeClass(ele, cls) &#123;</span><br><span class="line">    if (hasClass(ele, cls)) &#123;</span><br><span class="line">        var reg = new RegExp(&#x27;(\\s|^)&#x27; + cls + &#x27;(\\s|$)&#x27;);</span><br><span class="line">        ele.className = ele.className.replace(reg, &#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h3 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 根据name读取cookie</span><br><span class="line"> * @param  &#123;String&#125; name </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function getCookie(name) &#123;</span><br><span class="line">    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&#x27;;&#x27;);</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var tempArr = arr[i].split(&#x27;=&#x27;);</span><br><span class="line">        if (tempArr[0] == name) &#123;</span><br><span class="line">            return decodeURIComponent(tempArr[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-removeCookie"><a href="#3-2-removeCookie" class="headerlink" title="3.2 removeCookie"></a>3.2 removeCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var setCookie = require(&#x27;./setCookie&#x27;);</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 根据name删除cookie</span><br><span class="line"> * @param  &#123;String&#125; name </span><br><span class="line"> */</span><br><span class="line">function removeCookie(name) &#123;</span><br><span class="line">    // 设置已过期，系统会立刻删除cookie</span><br><span class="line">    setCookie(name, &#x27;1&#x27;, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-setCookie"><a href="#3-3-setCookie" class="headerlink" title="3.3 setCookie"></a>3.3 setCookie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  设置Cookie</span><br><span class="line"> * @param &#123;String&#125; name </span><br><span class="line"> * @param &#123;String&#125; value </span><br><span class="line"> * @param &#123;Number&#125; days </span><br><span class="line"> */</span><br><span class="line">function setCookie(name, value, days) &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setDate(date.getDate() + days);</span><br><span class="line">    document.cookie = name + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h3 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取浏览器类型和版本</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function getExplore() &#123;</span><br><span class="line">    var sys = &#123;&#125;,</span><br><span class="line">        ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">        s;</span><br><span class="line">    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:</span><br><span class="line">        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :</span><br><span class="line">        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :</span><br><span class="line">        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :</span><br><span class="line">        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :</span><br><span class="line">        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :</span><br><span class="line">        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;</span><br><span class="line">    // 根据关系进行判断</span><br><span class="line">    if (sys.ie) return (&#x27;IE: &#x27; + sys.ie)</span><br><span class="line">    if (sys.edge) return (&#x27;EDGE: &#x27; + sys.edge)</span><br><span class="line">    if (sys.firefox) return (&#x27;Firefox: &#x27; + sys.firefox)</span><br><span class="line">    if (sys.chrome) return (&#x27;Chrome: &#x27; + sys.chrome)</span><br><span class="line">    if (sys.opera) return (&#x27;Opera: &#x27; + sys.opera)</span><br><span class="line">    if (sys.safari) return (&#x27;Safari: &#x27; + sys.safari)</span><br><span class="line">    return &#x27;Unkonwn&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-getOS"><a href="#4-2-getOS" class="headerlink" title="4.2 getOS"></a>4.2 getOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取操作系统类型</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function getOS() &#123;</span><br><span class="line">    var userAgent = &#x27;navigator&#x27; in window &amp;&amp; &#x27;userAgent&#x27; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &#x27;&#x27;;</span><br><span class="line">    var vendor = &#x27;navigator&#x27; in window &amp;&amp; &#x27;vendor&#x27; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &#x27;&#x27;;</span><br><span class="line">    var appVersion = &#x27;navigator&#x27; in window &amp;&amp; &#x27;appVersion&#x27; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    if (/mac/i.test(appVersion)) return &#x27;MacOSX&#x27;</span><br><span class="line">    if (/win/i.test(appVersion)) return &#x27;windows&#x27;</span><br><span class="line">    if (/linux/i.test(appVersion)) return &#x27;linux&#x27;</span><br><span class="line">    if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &#x27;ios&#x27;</span><br><span class="line">    if (/android/i.test(userAgent)) return &#x27;android&#x27;</span><br><span class="line">    if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &#x27;windowsPhone&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h3 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取滚动条距顶部的距离</span><br><span class="line"> */</span><br><span class="line">function getScrollTop() &#123;</span><br><span class="line">    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-offset"><a href="#5-2-offset" class="headerlink" title="5.2 offset"></a>5.2 offset</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()</span><br><span class="line"> * @param &#123;HTMLElement&#125; ele </span><br><span class="line"> * @returns &#123; &#123;left: number, top: number&#125; &#125;</span><br><span class="line"> */</span><br><span class="line">function offset(ele) &#123;</span><br><span class="line">    var pos = &#123;</span><br><span class="line">        left: 0,</span><br><span class="line">        top: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    while (ele) &#123;</span><br><span class="line">        pos.left += ele.offsetLeft;</span><br><span class="line">        pos.top += ele.offsetTop;</span><br><span class="line">        ele = ele.offsetParent;</span><br><span class="line">    &#125;;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var getScrollTop = require(&#x27;./getScrollTop&#x27;);</span><br><span class="line">var setScrollTop = require(&#x27;./setScrollTop&#x27;);</span><br><span class="line">var requestAnimFrame = (function () &#123;</span><br><span class="line">    return window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        window.mozRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  在$&#123;duration&#125;时间内，滚动条平滑滚动到$&#123;to&#125;指定位置</span><br><span class="line"> * @param &#123;Number&#125; to </span><br><span class="line"> * @param &#123;Number&#125; duration </span><br><span class="line"> */</span><br><span class="line">function scrollTo(to, duration) &#123;</span><br><span class="line">    if (duration &lt; 0) &#123;</span><br><span class="line">        setScrollTop(to);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var diff = to - getScrollTop();</span><br><span class="line">    if (diff === 0) return</span><br><span class="line">    var step = diff / duration * 10;</span><br><span class="line">    requestAnimationFrame(</span><br><span class="line">        function () &#123;</span><br><span class="line">            if (Math.abs(step) &gt; Math.abs(diff)) &#123;</span><br><span class="line">                setScrollTop(getScrollTop() + diff);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            setScrollTop(getScrollTop() + step);</span><br><span class="line">            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            scrollTo(to, duration - 16);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 设置滚动条距顶部的距离</span><br><span class="line"> */</span><br><span class="line">function setScrollTop(value) &#123;</span><br><span class="line">    window.scrollTo(0, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h3 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">var keyCodeMap = &#123;</span><br><span class="line">    8: &#x27;Backspace&#x27;,</span><br><span class="line">    9: &#x27;Tab&#x27;,</span><br><span class="line">    13: &#x27;Enter&#x27;,</span><br><span class="line">    16: &#x27;Shift&#x27;,</span><br><span class="line">    17: &#x27;Ctrl&#x27;,</span><br><span class="line">    18: &#x27;Alt&#x27;,</span><br><span class="line">    19: &#x27;Pause&#x27;,</span><br><span class="line">    20: &#x27;Caps Lock&#x27;,</span><br><span class="line">    27: &#x27;Escape&#x27;,</span><br><span class="line">    32: &#x27;Space&#x27;,</span><br><span class="line">    33: &#x27;Page Up&#x27;,</span><br><span class="line">    34: &#x27;Page Down&#x27;,</span><br><span class="line">    35: &#x27;End&#x27;,</span><br><span class="line">    36: &#x27;Home&#x27;,</span><br><span class="line">    37: &#x27;Left&#x27;,</span><br><span class="line">    38: &#x27;Up&#x27;,</span><br><span class="line">    39: &#x27;Right&#x27;,</span><br><span class="line">    40: &#x27;Down&#x27;,</span><br><span class="line">    42: &#x27;Print Screen&#x27;,</span><br><span class="line">    45: &#x27;Insert&#x27;,</span><br><span class="line">    46: &#x27;Delete&#x27;,</span><br><span class="line"></span><br><span class="line">    48: &#x27;0&#x27;,</span><br><span class="line">    49: &#x27;1&#x27;,</span><br><span class="line">    50: &#x27;2&#x27;,</span><br><span class="line">    51: &#x27;3&#x27;,</span><br><span class="line">    52: &#x27;4&#x27;,</span><br><span class="line">    53: &#x27;5&#x27;,</span><br><span class="line">    54: &#x27;6&#x27;,</span><br><span class="line">    55: &#x27;7&#x27;,</span><br><span class="line">    56: &#x27;8&#x27;,</span><br><span class="line">    57: &#x27;9&#x27;,</span><br><span class="line"></span><br><span class="line">    65: &#x27;A&#x27;,</span><br><span class="line">    66: &#x27;B&#x27;,</span><br><span class="line">    67: &#x27;C&#x27;,</span><br><span class="line">    68: &#x27;D&#x27;,</span><br><span class="line">    69: &#x27;E&#x27;,</span><br><span class="line">    70: &#x27;F&#x27;,</span><br><span class="line">    71: &#x27;G&#x27;,</span><br><span class="line">    72: &#x27;H&#x27;,</span><br><span class="line">    73: &#x27;I&#x27;,</span><br><span class="line">    74: &#x27;J&#x27;,</span><br><span class="line">    75: &#x27;K&#x27;,</span><br><span class="line">    76: &#x27;L&#x27;,</span><br><span class="line">    77: &#x27;M&#x27;,</span><br><span class="line">    78: &#x27;N&#x27;,</span><br><span class="line">    79: &#x27;O&#x27;,</span><br><span class="line">    80: &#x27;P&#x27;,</span><br><span class="line">    81: &#x27;Q&#x27;,</span><br><span class="line">    82: &#x27;R&#x27;,</span><br><span class="line">    83: &#x27;S&#x27;,</span><br><span class="line">    84: &#x27;T&#x27;,</span><br><span class="line">    85: &#x27;U&#x27;,</span><br><span class="line">    86: &#x27;V&#x27;,</span><br><span class="line">    87: &#x27;W&#x27;,</span><br><span class="line">    88: &#x27;X&#x27;,</span><br><span class="line">    89: &#x27;Y&#x27;,</span><br><span class="line">    90: &#x27;Z&#x27;,</span><br><span class="line"></span><br><span class="line">    91: &#x27;Windows&#x27;,</span><br><span class="line">    93: &#x27;Right Click&#x27;,</span><br><span class="line"></span><br><span class="line">    96: &#x27;Numpad 0&#x27;,</span><br><span class="line">    97: &#x27;Numpad 1&#x27;,</span><br><span class="line">    98: &#x27;Numpad 2&#x27;,</span><br><span class="line">    99: &#x27;Numpad 3&#x27;,</span><br><span class="line">    100: &#x27;Numpad 4&#x27;,</span><br><span class="line">    101: &#x27;Numpad 5&#x27;,</span><br><span class="line">    102: &#x27;Numpad 6&#x27;,</span><br><span class="line">    103: &#x27;Numpad 7&#x27;,</span><br><span class="line">    104: &#x27;Numpad 8&#x27;,</span><br><span class="line">    105: &#x27;Numpad 9&#x27;,</span><br><span class="line">    106: &#x27;Numpad *&#x27;,</span><br><span class="line">    107: &#x27;Numpad +&#x27;,</span><br><span class="line">    109: &#x27;Numpad -&#x27;,</span><br><span class="line">    110: &#x27;Numpad .&#x27;,</span><br><span class="line">    111: &#x27;Numpad /&#x27;,</span><br><span class="line"></span><br><span class="line">    112: &#x27;F1&#x27;,</span><br><span class="line">    113: &#x27;F2&#x27;,</span><br><span class="line">    114: &#x27;F3&#x27;,</span><br><span class="line">    115: &#x27;F4&#x27;,</span><br><span class="line">    116: &#x27;F5&#x27;,</span><br><span class="line">    117: &#x27;F6&#x27;,</span><br><span class="line">    118: &#x27;F7&#x27;,</span><br><span class="line">    119: &#x27;F8&#x27;,</span><br><span class="line">    120: &#x27;F9&#x27;,</span><br><span class="line">    121: &#x27;F10&#x27;,</span><br><span class="line">    122: &#x27;F11&#x27;,</span><br><span class="line">    123: &#x27;F12&#x27;,</span><br><span class="line"></span><br><span class="line">    144: &#x27;Num Lock&#x27;,</span><br><span class="line">    145: &#x27;Scroll Lock&#x27;,</span><br><span class="line">    182: &#x27;My Computer&#x27;,</span><br><span class="line">    183: &#x27;My Calculator&#x27;,</span><br><span class="line">    186: &#x27;;&#x27;,</span><br><span class="line">    187: &#x27;=&#x27;,</span><br><span class="line">    188: &#x27;,&#x27;,</span><br><span class="line">    189: &#x27;-&#x27;,</span><br><span class="line">    190: &#x27;.&#x27;,</span><br><span class="line">    191: &#x27;/&#x27;,</span><br><span class="line">    192: &#x27;`&#x27;,</span><br><span class="line">    219: &#x27;[&#x27;,</span><br><span class="line">    220: &#x27;\\&#x27;,</span><br><span class="line">    221: &#x27;]&#x27;,</span><br><span class="line">    222: &#x27;\&#x27;&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * @desc 根据keycode获得键名</span><br><span class="line"> * @param  &#123;Number&#125; keycode </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function getKeyName(keycode) &#123;</span><br><span class="line">    if (keyCodeMap[keycode]) &#123;</span><br><span class="line">        return keyCodeMap[keycode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;Unknow Key(Key Code:&#x27; + keycode + &#x27;)&#x27;);</span><br><span class="line">        return &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h3 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 深拷贝，支持常见类型</span><br><span class="line"> * @param &#123;Any&#125; values</span><br><span class="line"> */</span><br><span class="line">function deepClone(values) &#123;</span><br><span class="line">    var copy;</span><br><span class="line"></span><br><span class="line">    // Handle the 3 simple types, and null or undefined</span><br><span class="line">    if (null == values || &quot;object&quot; != typeof values) return values;</span><br><span class="line"></span><br><span class="line">    // Handle Date</span><br><span class="line">    if (values instanceof Date) &#123;</span><br><span class="line">        copy = new Date();</span><br><span class="line">        copy.setTime(values.getTime());</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle Array</span><br><span class="line">    if (values instanceof Array) &#123;</span><br><span class="line">        copy = [];</span><br><span class="line">        for (var i = 0, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = deepClone(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle Object</span><br><span class="line">    if (values instanceof Object) &#123;</span><br><span class="line">        copy = &#123;&#125;;</span><br><span class="line">        for (var attr in values) &#123;</span><br><span class="line">            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new Error(&quot;Unable to copy values! Its type isn&#x27;t supported.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断`obj`是否为空</span><br><span class="line"> * @param  &#123;Object&#125; obj</span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isEmptyObject(obj) &#123;</span><br><span class="line">    if (!obj || typeof obj !== &#x27;object&#x27; || Array.isArray(obj))</span><br><span class="line">        return false</span><br><span class="line">    return !Object.keys(obj).length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h3 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 随机生成颜色</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">function randomColor() &#123;</span><br><span class="line">    return &#x27;#&#x27; + (&#x27;00000&#x27; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 生成指定范围随机数</span><br><span class="line"> * @param  &#123;Number&#125; min </span><br><span class="line"> * @param  &#123;Number&#125; max </span><br><span class="line"> * @return &#123;Number&#125; </span><br><span class="line"> */</span><br><span class="line">function randomNum(min, max) &#123;</span><br><span class="line">    return Math.floor(min + Math.random() * (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h3 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为邮箱地址</span><br><span class="line"> * @param  &#123;String&#125;  str</span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isEmail(str) &#123;</span><br><span class="line">    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc  判断是否为身份证号</span><br><span class="line"> * @param  &#123;String|Number&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isIdCard(str) &#123;</span><br><span class="line">    return /^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/.test(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为手机号</span><br><span class="line"> * @param  &#123;String|Number&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isPhoneNum(str) &#123;</span><br><span class="line">    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/.test(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否为URL地址</span><br><span class="line"> * @param  &#123;String&#125; str </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isUrl(str) &#123;</span><br><span class="line">    return /[-a-zA-Z0-9@:%._\+~#=]&#123;2,256&#125;\.[a-z]&#123;2,6&#125;\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h3 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   现金额转大写</span><br><span class="line"> * @param  &#123;Number&#125; n </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function digitUppercase(n) &#123;</span><br><span class="line">    var fraction = [&#x27;角&#x27;, &#x27;分&#x27;];</span><br><span class="line">    var digit = [</span><br><span class="line">        &#x27;零&#x27;, &#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;, &#x27;肆&#x27;,</span><br><span class="line">        &#x27;伍&#x27;, &#x27;陆&#x27;, &#x27;柒&#x27;, &#x27;捌&#x27;, &#x27;玖&#x27;</span><br><span class="line">    ];</span><br><span class="line">    var unit = [</span><br><span class="line">        [&#x27;元&#x27;, &#x27;万&#x27;, &#x27;亿&#x27;],</span><br><span class="line">        [&#x27;&#x27;, &#x27;拾&#x27;, &#x27;佰&#x27;, &#x27;仟&#x27;]</span><br><span class="line">    ];</span><br><span class="line">    var head = n &lt; 0 ? &#x27;欠&#x27; : &#x27;&#x27;;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    var s = &#x27;&#x27;;</span><br><span class="line">    for (var i = 0; i &lt; fraction.length; i++) &#123;</span><br><span class="line">        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || &#x27;整&#x27;;</span><br><span class="line">    n = Math.floor(n);</span><br><span class="line">    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123;</span><br><span class="line">        var p = &#x27;&#x27;;</span><br><span class="line">        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123;</span><br><span class="line">            p = digit[n % 10] + unit[1][j] + p;</span><br><span class="line">            n = Math.floor(n / 10);</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replace(/(零.)*零$/, &#x27;&#x27;).replace(/^$/, &#x27;零&#x27;) + unit[0][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    return head + s.replace(/(零.)*零元/, &#x27;元&#x27;)</span><br><span class="line">        .replace(/(零.)+/g, &#x27;零&#x27;)</span><br><span class="line">        .replace(/^整$/, &#x27;零元整&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h3 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 判断浏览器是否支持webP格式图片</span><br><span class="line"> * @return &#123;Boolean&#125; </span><br><span class="line"> */</span><br><span class="line">function isSupportWebP() &#123;</span><br><span class="line">    return !![].map &amp;&amp; document.createElement(&#x27;canvas&#x27;).toDataURL(&#x27;image/webp&#x27;).indexOf(&#x27;data:image/webp&#x27;) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h3 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc   格式化$&#123;startTime&#125;距现在的已过时间</span><br><span class="line"> * @param  &#123;Date&#125; startTime </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function formatPassTime(startTime) &#123;</span><br><span class="line">    var currentTime = Date.parse(new Date()),</span><br><span class="line">        time = currentTime - startTime,</span><br><span class="line">        day = parseInt(time / (1000 * 60 * 60 * 24)),</span><br><span class="line">        hour = parseInt(time / (1000 * 60 * 60)),</span><br><span class="line">        min = parseInt(time / (1000 * 60)),</span><br><span class="line">        month = parseInt(day / 30),</span><br><span class="line">        year = parseInt(month / 12);</span><br><span class="line">    if (year) return year + &quot;年前&quot;</span><br><span class="line">    if (month) return month + &quot;个月前&quot;</span><br><span class="line">    if (day) return day + &quot;天前&quot;</span><br><span class="line">    if (hour) return hour + &quot;小时前&quot;</span><br><span class="line">    if (min) return min + &quot;分钟前&quot;</span><br><span class="line">    else return &#x27;刚刚&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   格式化现在距$&#123;endTime&#125;的剩余时间</span><br><span class="line"> * @param  &#123;Date&#125; endTime  </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function formatRemainTime(endTime) &#123;</span><br><span class="line">    var startDate = new Date(); //开始时间</span><br><span class="line">    var endDate = new Date(endTime); //结束时间</span><br><span class="line">    var t = endDate.getTime() - startDate.getTime(); //时间差</span><br><span class="line">    var d = 0,</span><br><span class="line">        h = 0,</span><br><span class="line">        m = 0,</span><br><span class="line">        s = 0;</span><br><span class="line">    if (t &gt;= 0) &#123;</span><br><span class="line">        d = Math.floor(t / 1000 / 3600 / 24);</span><br><span class="line">        h = Math.floor(t / 1000 / 60 / 60 % 24);</span><br><span class="line">        m = Math.floor(t / 1000 / 60 % 60);</span><br><span class="line">        s = Math.floor(t / 1000 % 60);</span><br><span class="line">    &#125;</span><br><span class="line">    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h3 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   url参数转对象</span><br><span class="line"> * @param  &#123;String&#125; url  default: window.location.href</span><br><span class="line"> * @return &#123;Object&#125; </span><br><span class="line"> */</span><br><span class="line">function parseQueryString(url) &#123;</span><br><span class="line">    url = url == null ? window.location.href : url</span><br><span class="line">    var search = url.substring(url.lastIndexOf(&#x27;?&#x27;) + 1)</span><br><span class="line">    if (!search) &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.parse(&#x27;&#123;&quot;&#x27; + decodeURIComponent(search).replace(/&quot;/g, &#x27;\\&quot;&#x27;).replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;).replace(/=/g, &#x27;&quot;:&quot;&#x27;) + &#x27;&quot;&#125;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   对象序列化</span><br><span class="line"> * @param  &#123;Object&#125; obj </span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> */</span><br><span class="line">function stringfyQueryString(obj) &#123;</span><br><span class="line">    if (!obj) return &#x27;&#x27;;</span><br><span class="line">    var pairs = [];</span><br><span class="line"></span><br><span class="line">    for (var key in obj) &#123;</span><br><span class="line">        var value = obj[key];</span><br><span class="line"></span><br><span class="line">        if (value instanceof Array) &#123;</span><br><span class="line">            for (var i = 0; i &lt; value.length; ++i) &#123;</span><br><span class="line">                pairs.push(encodeURIComponent(key + &#x27;[&#x27; + i + &#x27;]&#x27;) + &#x27;=&#x27; + encodeURIComponent(value[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pairs.push(encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(obj[key]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pairs.join(&#x27;&amp;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h3 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc   函数节流。</span><br><span class="line"> * 适用于限制`resize`和`scroll`等函数的调用频率</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;Number&#125;    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。</span><br><span class="line"> * @param  &#123;Boolean&#125;   noTrailing     可选，默认为false。</span><br><span class="line"> *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。</span><br><span class="line"> *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.</span><br><span class="line"> *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）</span><br><span class="line"> * @param  &#123;Function&#125;  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，</span><br><span class="line"> *                                    执行去节流功能时，调用`callback`。</span><br><span class="line"> * @param  &#123;Boolean&#125;   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。</span><br><span class="line"> *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;Function&#125;  新的节流函数</span><br><span class="line"> */</span><br><span class="line">function throttle(delay, noTrailing, callback, debounceMode) &#123;</span><br><span class="line"></span><br><span class="line">    // After wrapper has stopped being called, this timeout ensures that</span><br><span class="line">    // `callback` is executed at the proper times in `throttle` and `end`</span><br><span class="line">    // debounce modes.</span><br><span class="line">    var timeoutID;</span><br><span class="line"></span><br><span class="line">    // Keep track of the last time `callback` was executed.</span><br><span class="line">    var lastExec = 0;</span><br><span class="line"></span><br><span class="line">    // `noTrailing` defaults to falsy.</span><br><span class="line">    if (typeof noTrailing !== &#x27;boolean&#x27;) &#123;</span><br><span class="line">        debounceMode = callback;</span><br><span class="line">        callback = noTrailing;</span><br><span class="line">        noTrailing = undefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The `wrapper` function encapsulates all of the throttling / debouncing</span><br><span class="line">    // functionality and when executed will limit the rate at which `callback`</span><br><span class="line">    // is executed.</span><br><span class="line">    function wrapper() &#123;</span><br><span class="line"></span><br><span class="line">        var self = this;</span><br><span class="line">        var elapsed = Number(new Date()) - lastExec;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        // Execute `callback` and update the `lastExec` timestamp.</span><br><span class="line">        function exec() &#123;</span><br><span class="line">            lastExec = Number(new Date());</span><br><span class="line">            callback.apply(self, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If `debounceMode` is true (at begin) this is used to clear the flag</span><br><span class="line">        // to allow future `callback` executions.</span><br><span class="line">        function clear() &#123;</span><br><span class="line">            timeoutID = undefined;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (debounceMode &amp;&amp; !timeoutID) &#123;</span><br><span class="line">            // Since `wrapper` is being called for the first time and</span><br><span class="line">            // `debounceMode` is true (at begin), execute `callback`.</span><br><span class="line">            exec();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Clear any existing timeout.</span><br><span class="line">        if (timeoutID) &#123;</span><br><span class="line">            clearTimeout(timeoutID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) &#123;</span><br><span class="line">            // In throttle mode, if `delay` time has been exceeded, execute</span><br><span class="line">            // `callback`.</span><br><span class="line">            exec();</span><br><span class="line"></span><br><span class="line">        &#125; else if (noTrailing !== true) &#123;</span><br><span class="line">            // In trailing throttle mode, since `delay` time has not been</span><br><span class="line">            // exceeded, schedule `callback` to execute `delay` ms after most</span><br><span class="line">            // recent execution.</span><br><span class="line">            //</span><br><span class="line">            // If `debounceMode` is true (at begin), schedule `clear` to execute</span><br><span class="line">            // after `delay` ms.</span><br><span class="line">            //</span><br><span class="line">            // If `debounceMode` is false (at end), schedule `callback` to</span><br><span class="line">            // execute after `delay` ms.</span><br><span class="line">            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return the wrapper function.</span><br><span class="line">    return wrapper;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 函数防抖 </span><br><span class="line"> * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，</span><br><span class="line"> * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。</span><br><span class="line"> * @example 适用场景：如在线编辑的自动存储防抖。</span><br><span class="line"> * @param  &#123;Number&#125;   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。</span><br><span class="line"> * @param  &#123;Boolean&#125;  atBegin       可选，默认为false。</span><br><span class="line"> *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。</span><br><span class="line">                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行</span><br><span class="line"> * @param  &#123;Function&#125; callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，</span><br><span class="line"> *                                  执行去抖动功能时，，调用`callback`。</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;Function&#125; 新的防抖函数。</span><br><span class="line"> */</span><br><span class="line">var throttle = require(&#x27;./throttle&#x27;);</span><br><span class="line">function debounce(delay, atBegin, callback) &#123;</span><br><span class="line">    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p><p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持<strong>按需引入</strong>吧</p><h2 id="1-目录结构说明"><a href="#1-目录结构说明" class="headerlink" title="1.目录结构说明"></a>1.目录结构说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">│  .babelrc</span><br><span class="line">│  .gitignore</span><br><span class="line">│  .travis.yml</span><br><span class="line">│  LICENSE</span><br><span class="line">│  package.json</span><br><span class="line">│  README.md</span><br><span class="line">│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载</span><br><span class="line">│  setScrollTop.js</span><br><span class="line">│  stringfyQueryString.js</span><br><span class="line">│   ...</span><br><span class="line">│   ...</span><br><span class="line">│  </span><br><span class="line">├─min</span><br><span class="line">│      outils.min.js  // 所有函数统一打包生成的全量压缩包</span><br><span class="line">│      </span><br><span class="line">├─script  // 本项目开发脚本目录</span><br><span class="line">│      build.js  // 打包构建脚本</span><br><span class="line">│      test.js  // 测试脚本</span><br><span class="line">│      webpack.conf.js  // webpack打包配置文件</span><br><span class="line">│      </span><br><span class="line">├─src // 源码目录</span><br><span class="line">│  │  index.js  // webpack入口文件</span><br><span class="line">│  │  </span><br><span class="line">│  ├─array</span><br><span class="line">│  │      </span><br><span class="line">│  ├─class</span><br><span class="line">│  │      </span><br><span class="line">│  ├─cookie</span><br><span class="line">│  │      </span><br><span class="line">│  ├─device</span><br><span class="line">│  │      </span><br><span class="line">│  ├─dom</span><br><span class="line">│  │      </span><br><span class="line">│  ├─keycode</span><br><span class="line">│  │      </span><br><span class="line">│  ├─object</span><br><span class="line">│  │      </span><br><span class="line">│  ├─random</span><br><span class="line">│  │      </span><br><span class="line">│  ├─regexp</span><br><span class="line">│  │      </span><br><span class="line">│  ├─string</span><br><span class="line">│  │      </span><br><span class="line">│  ├─support</span><br><span class="line">│  │      </span><br><span class="line">│  ├─time</span><br><span class="line">│  │      </span><br><span class="line">│  └─url</span><br><span class="line">│          </span><br><span class="line">└─test // 测试用例目录</span><br><span class="line">    │  array.test.js</span><br><span class="line">    │  class.test.js</span><br><span class="line">    │  cookie.test.js</span><br><span class="line">    │  device.test.js</span><br><span class="line">    │  dom.test.js</span><br><span class="line">    │  index.html</span><br><span class="line">    │  keycode.test.js</span><br><span class="line">    │  object.test.js</span><br><span class="line">    │  random.test.js</span><br><span class="line">    │  regexp.test.js</span><br><span class="line">    │  string.test.js</span><br><span class="line">    │  support.test.js</span><br><span class="line">    │  time.test.js</span><br><span class="line">    │  url.test.js</span><br><span class="line">    │  </span><br><span class="line">    └─_lib // 测试所用到的第三方库</span><br><span class="line">            mocha.css</span><br><span class="line">            mocha.js</span><br><span class="line">            power-assert.js </span><br></pre></td></tr></table></figure><h2 id="2-构建脚本"><a href="#2-构建脚本" class="headerlink" title="2.构建脚本"></a>2.构建脚本</h2><p>这里主要说明一下项目中<a href="https://github.com/proYang/outils/blob/master/script/build.js"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">// 删除旧的全量压缩包</span><br><span class="line">rm(path.resolve(rootPath, &#x27;min&#x27;, `$&#123;pkg.name&#125;.min.js`), err =&gt; &#123;</span><br><span class="line">    if (err) throw (err)</span><br><span class="line">    webpack(config, function (err, stats) &#123;</span><br><span class="line">        if (err) throw (err)</span><br><span class="line">        building.stop()</span><br><span class="line">        process.stdout.write(stats.toString(&#123;</span><br><span class="line">            colors: true,</span><br><span class="line">            modules: false,</span><br><span class="line">            children: false,</span><br><span class="line">            chunks: false,</span><br><span class="line">            chunkModules: false</span><br><span class="line">        &#125;) + &#x27;\n\n&#x27;)</span><br><span class="line">        resolve()</span><br><span class="line">        console.log(chalk.cyan(&#x27;  Build complete.\n&#x27;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 替换模块文件</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    // 先删除根目录中之前的函数模块</span><br><span class="line">    rm(&#x27;*.js&#x27;, err =&gt; &#123;</span><br><span class="line">        if (err) throw (err)</span><br><span class="line">        let folderList = fs.readdirSync(path.resolve(rootPath, &#x27;src&#x27;))</span><br><span class="line">        folderList.forEach((item, index) =&gt; &#123;</span><br><span class="line">            // 拷贝`src`下面一层目录的所有`js`文件至根目录</span><br><span class="line">            copy(`src/$&#123;item&#125;/*.js`, rootPath, function (err, files) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                if (index === folderList.length - 1) &#123;</span><br><span class="line">                    console.log(chalk.cyan(&#x27;  Copy complete.\n&#x27;))</span><br><span class="line">                    copying.stop()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="3-书写测试用例"><a href="#3-书写测试用例" class="headerlink" title="3.书写测试用例"></a>3.书写测试用例</h2><p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p><p>但是因为时间关系，本项目暂时通过项目中的<a href="https://github.com/proYang/outils/blob/master/script/test.js"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p><p>这里给大家推荐一个好用的断言库<a href="https://www.npmjs.com/package/power-assert"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p><p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p><blockquote><p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://travis-ci.org/"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://github.com/proYang/outils/blob/master/.travis.yml"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://github.com/proYang/outils/blob/master/script/karma.conf.js"> karma.conf.js </a>。</p></blockquote><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://github.com/proYang/outils/">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p><h3 id="1-添加自己的函数"><a href="#1-添加自己的函数" class="headerlink" title="1.添加自己的函数"></a>1.添加自己的函数</h3><p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc   判断是否NaN</span><br><span class="line"> * @param  &#123;Any&#125; value </span><br><span class="line"> * @return &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isNaN(value) &#123;    </span><br><span class="line">    return value !== value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">modules.export = isNaN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后记得在<code>src/index.js</code>文件中暴露<code>isNaN</code>函数</p><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><p>在<code>test</code>文件新建测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;#isNaN()&#x27;, function () &#123;</span><br><span class="line">    it(`outils.isNaN(NaN) should return true`, function () &#123;</span><br><span class="line">        assert(outils.isNaN(NaN))</span><br><span class="line">    &#125;)</span><br><span class="line">    it(`outils.isNaN(&#x27;value&#x27;) should return false`, function () &#123;</span><br><span class="line">        assert.notEqual(outils.isNaN(NaN))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><del>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</del></p><h3 id="3-测试并打包"><a href="#3-测试并打包" class="headerlink" title="3.测试并打包"></a>3.测试并打包</h3><p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p><h3 id="4-发布到npm"><a href="#4-发布到npm" class="headerlink" title="4.发布到npm"></a>4.发布到<code>npm</code></h3><p>在<a href="https://www.npmjs.com/"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://www.npmjs.com/"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1.浏览器"></a>1.浏览器</h3><p>直接下载<code>min</code>目录下的<a href="https://github.com/proYang/outils/blob/master/min/outils.min.js"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var OS = outils.getOS()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://github.com/proYang/outils/releases"> github Release </a>页面下载对应版本号的代码。</p><h3 id="2-Webpack、RequireJS、SeaJS等模块加载器"><a href="#2-Webpack、RequireJS、SeaJS等模块加载器" class="headerlink" title="2.Webpack、RequireJS、SeaJS等模块加载器"></a>2.Webpack、RequireJS、SeaJS等模块加载器</h3><p>先使用<code>npm</code>安装<code>outils</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev outils</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 完整引入</span><br><span class="line">const outils = require(&#x27;outils&#x27;)</span><br><span class="line">const OS = outils.getOS()</span><br></pre></td></tr></table></figure><p><strong>推荐使用方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 按需引入require(&#x27;outils/&lt;方法名&gt;&#x27;)</span><br><span class="line">const getOS = require(&#x27;outils/getOS&#x27;)</span><br><span class="line">const OS = getOS()</span><br></pre></td></tr></table></figure><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import getOS from &#x27;outils/getOS&#x27;</span><br><span class="line">// 或</span><br><span class="line">import &#123; getOS &#125; from &quot;outils&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工欲善其事必先利其器。有了属于自己的这把利器，希望加班也会变成奢望。O(∩_∩)O哈哈~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器技巧总结</title>
      <link href="/2017/12/03/%E5%B7%A5%E5%85%B7/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/03/%E5%B7%A5%E5%85%B7/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单介绍一些chrome浏览器的小技巧</p></blockquote><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>快捷键比较多，这里挑出几个常用的说一下<br>最后会给出一张比较完整的快捷键的表</p><p>下列快捷键可以在所有 开发者工具 面板中可以使用</p><table><thead><tr><th>全局快捷键</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>打开 开发者工具</td><td>F12、Ctrl+Shift+I</td><td>Cmd+Opt+I</td></tr><tr><td>打开 开发者工具 并聚焦到控制台</td><td>Ctrl+Shift+J</td><td>Cmd+Shift+C</td></tr><tr><td>刷新页面</td><td>F5、Ctrl+R</td><td>Cmd+R</td></tr><tr><td>刷新忽略缓存内容的页面</td><td>Ctrl+F5、Ctrl+Shift+R</td><td>Cmd+Shift+R</td></tr></tbody></table><hr><p><strong>在Elements 面板中使用的快捷键</strong></p><table><thead><tr><th>Elements 面板</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>编辑属性</td><td>Enter、双击属性</td><td>Enter、双击属性</td></tr><tr><td>隐藏元素</td><td>H</td><td>H</td></tr><tr><td>切换为以HTML形式编辑</td><td>F2</td><td></td></tr></tbody></table><hr><p><strong>在Styles 边栏中使用的快捷键</strong></p><table><thead><tr><th>Styles 边栏</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>转到源中属性值声明行</td><td>Ctrl+点击属性值</td><td>CMd+点击属性值</td></tr><tr><td>在颜色定义值之间循环</td><td>Shift+点击颜色选取器框</td><td>Shift+点击颜色选取器框</td></tr><tr><td>编辑下一个&#x2F;上一个属性</td><td>Tab、Tab+Shift</td><td>Tab、Tab+Shift</td></tr></tbody></table><hr><p><strong>在控制台中使用的快捷键</strong></p><table><thead><tr><th>控制台</th><th>window</th><th>Mac</th></tr></thead><tbody><tr><td>聚焦到控制台</td><td>Ctrl+&#96;</td><td>Ctrl+&#96;</td></tr><tr><td>清除控制台</td><td>Ctrl+L</td><td>Cmd+K、Opt+L</td></tr><tr><td>多行输入</td><td>Shift+Enter</td><td>Ctrl+Return</td></tr></tbody></table><h3 id="区域截屏"><a href="#区域截屏" class="headerlink" title="区域截屏"></a>区域截屏</h3><p>选取页面中的一部分，保存为图片<br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4uq956h4j20lv0bxt9p.jpg"></p><p>2、选择左上角的元素选择按钮，图标颜色变为蓝色即表示选中了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vhn5xepj207h04l3yi.jpg"></p><p>3、Windows 下按住 Ctrl，Mac 就按住 Command，然后点击鼠标左键在页面选择区域即可，松开鼠标后，截图自动下载。</p><p>4、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示 </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4viypbwuj20bl094mxp.jpg"></p><h3 id="节点截图"><a href="#节点截图" class="headerlink" title="节点截图"></a>节点截图</h3><p>选中页面中某一元素，保存为图片<br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、选中任意元素节点<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vl692wlj20fb04vmxc.jpg"></p><p>3、打开命令工具<br>使用快捷键 Ctrl + Shift + p (Windows) 或 Cmd + Shift + p (Mac)<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vmbp1t0j20fs093q3a.jpg"></p><p>4、点击Capture node screenshot，或者输入这行中任意的关键字，比如输入node，也会出来这个选项，然后点击这个选项，图片会自动下载。<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vmwcwm6j20er04fjrd.jpg"></p><p>5、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示</p><h3 id="截全屏"><a href="#截全屏" class="headerlink" title="截全屏"></a>截全屏</h3><p>保存完整网页为图片<br><strong>第一种方式</strong><br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、打开命令工具<br>使用快捷键 Ctrl + Shift + p (Windows) 或 Cmd + Shift + p (Mac) </p><p>3、点击Capture full size screenshot，或者输入这行中任意的关键字，比如输入full，也会出来这个选项<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vnpqtg4j20ej032q2t.jpg"></p><p>4、图片自动下载好后，点击图片后面的箭头，可以在文件夹中显示 </p><p><strong>第二种方式</strong><br>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、选中 切换开发模式按钮，图标颜色变为蓝色即表示选中了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4votroz4j206j03wweg.jpg"></p><p>3、点右上方的三个 小点，点击Capture full size screenshot，图片会自动下载<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vp9m0pmj20kz08rt9o.jpg"></p><h3 id="拾色器"><a href="#拾色器" class="headerlink" title="拾色器"></a>拾色器</h3><p>在Styles边栏 点击任意颜色的小色块，就可以弹出颜色选择器<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vppvghkj207s079jri.jpg"><br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vq9x3fbj20m80f679a.jpg"><br>1、颜色选择区域。<br>2、吸管。<br>3、复制到剪贴板。将显示值复制到剪贴板。<br>4、显示值。颜色的RGBA，HSLA或十六进制表示。<br>5、调色板。单击其中一个方块将颜色更改为该方块。<br>6、色相。<br>7、透明度。<br>8、显示值切换器。在当前颜色的RGBA，HSLA和Hex表示之间切换。<br>9、调色板切换器。</p><h3 id="快速添加样式规则"><a href="#快速添加样式规则" class="headerlink" title="快速添加样式规则"></a>快速添加样式规则</h3><p>1、在Styles 边栏，鼠标放在每一小块样式规则上，右下方都会有三个小点<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vqjn4ulj20d3087aad.jpg"></p><p>2、鼠标放在这三个小点上，会出现5个小图标，每个小图标都有作用<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vt1zf7wj20cc03vglm.jpg"></p><p>3、他们从左到右分别代表</p><ul><li>添加 text-shadow</li><li>添加 box-shadow</li><li>添加 color</li><li>添加 background-color</li><li>插入样式规则</li></ul><h3 id="增加移动设备"><a href="#增加移动设备" class="headerlink" title="增加移动设备"></a>增加移动设备</h3><p>1、打开开发者工具<br>使用 快捷键 F12 (Windows) 或 Cmd+Opt+I (Mac)</p><p>2、点击右上方的三个小点，然后选择Settings<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vqx6nwoj20m8075gn3.jpg"></p><p>3、选择Devices，然后在需要添加的设备前面打上勾就可以了<br>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fm4vthr10cj20e109jglu.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些小技巧，很简单，希望对大家有所帮助，不过对于有办法，有时间的朋友还是建议去官网看看吧，毕竟那里才更加全面。<br><a href="http://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">Chrome 开发者工具</a></p><p><a href="http://img.blog.csdn.net/20171122155304242">点击查看具体图片</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome 效率插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡相关总结</title>
      <link href="/2017/11/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>先理解一下所谓的“均衡”</p><p>不能狭义地理解为分配给所有实际服务器一样多的工作量，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程序地发挥作用。</p><h1 id="一、http重定向"><a href="#一、http重定向" class="headerlink" title="一、http重定向"></a>一、http重定向</h1><p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p><p>性能缺陷：</p><p>1、吞吐率限制</p><p>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs&#x2F;s，那么主服务器的吞吐率要达到3000reqs&#x2F;s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs&#x2F;s，那么平均分配到子服务器的吞吐率为2000reqs&#x2F;s，而现子服务器的最大吞吐率为1000reqs&#x2F;s，因此就得增加子服务器的数量，增加到6个才能满足。</p><p>2、重定向访问深度不同</p><p>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</p><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><h1 id="二、DNS负载均衡"><a href="#二、DNS负载均衡" class="headerlink" title="二、DNS负载均衡"></a>二、DNS负载均衡</h1><p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p><p>使用dig命令来看下”baidu”的DNS设置</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/205913_PgDS_3341316.jpg" alt="img"></p><p>可见baidu拥有三个A记录</p><p>相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。</p><p>特性:</p><p>1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</p><p>2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</p><p>不足：</p><p>1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</p><p>2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</p><p>3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</p><p>4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</p><p>5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</p><h1 id="三、反向代理负载均衡"><a href="#三、反向代理负载均衡" class="headerlink" title="三、反向代理负载均衡"></a>三、反向代理负载均衡</h1><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。</p><p>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p><p>1、任何对于实际服务器的HTTP请求都必须经过调度器</p><p>2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</p><p>特性：</p><p>1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</p><p>2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</p><p>3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</p><p>4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</p><p>5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</p><h1 id="四、IP负载均衡-LVS-NAT"><a href="#四、IP负载均衡-LVS-NAT" class="headerlink" title="四、IP负载均衡(LVS-NAT)"></a>四、IP负载均衡(LVS-NAT)</h1><p>因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？</p><p>NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。</p><p>从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，<a href="http://lib.csdn.net/base/linux">Linux</a>提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。</p><p>想知道你的服务器内核是否已经安装了IPVS模块，可以</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/211529_WLOE_3341316.jpg" alt="img"></p><p>有输出意味着IPVS已经安装了。IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。</p><p>1、打开调度器的数据包转发选项</p><p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</p><p>2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加</p><p>route add default gw xx.xx.xx.xx</p><p>3、使用ipvsadm配置</p><p>ipvsadm -A -t 111.11.11.11:80 -s rr  </p><p>添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等）</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m  </p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m  </p><p>添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包</p><p>运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。</p><p>实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一睦开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然如果你不差钱，可以去花钱去购买千兆交换机或万兆交换机，甚至负载均衡硬件设备，但如果你是个屌丝，咋办？</p><p>一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><h1 id="五、直接路由-LVS-DR"><a href="#五、直接路由-LVS-DR" class="headerlink" title="五、直接路由(LVS-DR)"></a>五、直接路由(LVS-DR)</h1><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>1、网络设置</p><p>这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。</p><p>2、将ip别名添加到回环接口lo上</p><p>这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行：</p><p><img src="https://static.oschina.net/uploads/space/2017/0411/211643_3QOL_3341316.jpg" alt="img"></p><p>另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行：</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore</p><p>echo “2” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore</p><p>echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce</p><p>配置完了就可以使用ipvsadm配置LVS-DR集群了</p><p>ipvsadm -A -t 10.10.120.193:80 -s rr  </p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g  </p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g  </p><p>-g 就意味着使用直接路由的方式转发数据包</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><h1 id="六、IP隧道-LVS-TUN"><a href="#六、IP隧道-LVS-TUN" class="headerlink" title="六、IP隧道(LVS-TUN)"></a>六、IP隧道(LVS-TUN)</h1><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的ip命令总结</title>
      <link href="/2017/11/22/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20linux%E7%9A%84ip%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/22/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20linux%E7%9A%84ip%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://linux.cn/">Linux中国</a> <a href="https://linux.cn/article-3144-1.html">https://linux.cn/article-3144-1.html</a><br>地址：<a href="https://linux.cn/article-3144-1.html">https://linux.cn/article-3144-1.html</a></p><p>linux的<strong>ip</strong>命令和<strong>ifconfig</strong>类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003404uy9l1t5zayzllylm.png" alt="Net tools vs Iproute2"></p><p><em>Net tools vs Iproute2</em></p><p>要安装ip，请<a href="http://www.linuxgrill.com/anonymous/iproute2/NEW-OSDL/">点击这里</a>下载<strong>iproute2套装工具</strong> 。不过，大多数Linux发行版已经预装了iproute2工具。</p><p>你也可以使用git命令来下载最新源代码来编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://kernel.googlesource.com/pub/scm/linux/kernel/git/shemminger/iproute2.git</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003410tpix2804k660lwu4.png" alt="iproute2 git clone"></p><p><em>iproute2 git clone</em></p><h3 id="设置和删除Ip地址"><a href="#设置和删除Ip地址" class="headerlink" title="设置和删除Ip地址"></a>设置和删除Ip地址</h3><p>要给你的机器设置一个IP地址，可以使用下列ip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip addr add 192.168.0.193/24 dev wlan0</span><br></pre></td></tr></table></figure><p>请注意IP地址要有一个后缀，比如&#x2F;24。这种用法用于在无类域内路由选择（CIDR）中来显示所用的子网掩码。在这个例子中，子网掩码是255.255.255.0。</p><p>在你按照上述方式设置好IP地址后，需要查看是否已经生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show wlan0</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003411qp4xsem5491ee49t.png" alt="set ip address"></p><p><em>set ip address</em></p><p>你也可以使用相同的方式来删除IP地址，只需用del代替add。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip addr del 192.168.0.193/24 dev wlan0</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003412dottfn0jnidyykd2.png" alt="delete ip address"></p><p><em>delete ip address</em></p><h3 id="列出路由表条目"><a href="#列出路由表条目" class="headerlink" title="列出路由表条目"></a>列出路由表条目</h3><p>ip命令的路由对象的参数还可以帮助你查看网络中的路由数据，并设置你的路由表。第一个条目是默认的路由条目，你可以随意改动它。</p><p>在这个例子中，有几个路由条目。这个结果显示有几个设备通过不同的网络接口连接起来。它们包括WIFI、以太网和一个点对点连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003413mnehm4uinhziu287.png" alt="ip route show"></p><p><em>ip route show</em></p><p>假设现在你有一个IP地址，你需要知道路由包从哪里来。可以使用下面的路由选项（译注：列出了路由所使用的接口等）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route get 10.42.0.47</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003414h53e34qwjfo34emm.png" alt="ip route get"></p><p><em>ip route get</em></p><h3 id="更改默认路由"><a href="#更改默认路由" class="headerlink" title="更改默认路由"></a>更改默认路由</h3><p>要更改默认路由，使用下面ip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip route add default via 192.168.0.196</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003415i8d82ulsa4c4jcd4.png" alt="default route"></p><p><em>default route</em></p><h3 id="显示网络统计数据"><a href="#显示网络统计数据" class="headerlink" title="显示网络统计数据"></a>显示网络统计数据</h3><p>使用ip命令还可以显示不同网络接口的统计数据。</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003417l1jc4h5537m050wy.png" alt="ip statistics all interfaces"></p><p><em>ip statistics all interfaces</em></p><p>当你需要获取一个特定网络接口的信息时，在网络接口名字后面添加选项<strong>ls</strong>即可。使用多个选项**-s**会给你这个特定接口更详细的信息。特别是在排除网络连接故障时，这会非常有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip -s -s link ls p2p1</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003418acoo0krhjellollu.png" alt="ip link statistics"></p><p><em>ip link statistics</em></p><h3 id="ARP条目"><a href="#ARP条目" class="headerlink" title="ARP条目"></a>ARP条目</h3><p>地址解析协议（ARP）用于将一个IP地址转换成它对应的物理地址，也就是通常所说的MAC地址。使用ip命令的neigh或者neighbour选项，你可以查看接入你所在的局域网的设备的MAC地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip neighbour</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003419uzm96tbvujb5bvqe.png" alt="ip neighbour"></p><p><em>ip neighbour</em></p><h3 id="监控netlink消息"><a href="#监控netlink消息" class="headerlink" title="监控netlink消息"></a>监控netlink消息</h3><p>也可以使用ip命令查看netlink消息。monitor选项允许你查看网络设备的状态。比如，所在局域网的一台电脑根据它的状态可以被分类成REACHABLE或者STALE。使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip monitor all</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003420ap2j3jjvjk3jvvoo.png" alt="ip monitor all"></p><p><em>ip monitor all</em></p><h3 id="激活和停止网络接口"><a href="#激活和停止网络接口" class="headerlink" title="激活和停止网络接口"></a>激活和停止网络接口</h3><p>你可以使用ip命令的up和down选项来激某个特定的接口，就像ifconfig的用法一样。</p><p>在这个例子中，当ppp0接口被激活和在它被停止和再次激活之后，你可以看到相应的路由表条目。这个接口可能是wlan0或者eth0。将ppp0更改为你可用的任意接口即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip link set ppp0 down $ sudo ip link set ppp0 up</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003421mdudvkazcgkl6g8d.png" alt="ip link set up and down"></p><p><em>ip link set up and down</em></p><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>当你陷入困境，不知道某一个特定的选项怎么用的时候，你可以使用help选项。man页面并不会提供许多关于如何使用ip选项的信息，因此这里就是获取帮助的地方。</p><p>比如，想知道关于route选项更多的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route help</span><br></pre></td></tr></table></figure><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201406/04/003422xh9xm2wihecdjhif.png" alt="ip route help"></p><p><em>ip route help</em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于网络管理员们和所有的Linux使用者们，ip命令是必备工具。是时候抛弃ifconfig命令了，特别是当你写脚本时。</p><hr><p>via: <a href="http://linoxide.com/linux-command/use-ip-command-linux/">http://linoxide.com/linux-command/use-ip-command-linux/</a></p><h2 id="译者：KayGuoWhu-校对：wxy"><a href="#译者：KayGuoWhu-校对：wxy" class="headerlink" title="译者：KayGuoWhu 校对：wxy"></a>译者：<a href="https://github.com/KayGuoWhu">KayGuoWhu</a> 校对：<a href="https://github.com/wxy">wxy</a></h2><p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a href="https://linux.cn/article-3144-1.html">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中list的排序</title>
      <link href="/2017/11/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E4%B8%ADlist%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/11/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20python%E4%B8%ADlist%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里先简单总结下python中排序的用法</p></blockquote><p>python内置的排序函数主要有两个： <code>sort</code> 和 <code>sorted</code></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>sort只能对list排序，sorted可以对list, tuple, dist 以及自定义的类型进行排序</li><li>sort是在原有list上作操作，sorted 不会修改原来的数据结构，而是返回新的list （注意：对tuple排序只能用sorted）</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>1.sort</p><p>参数：reverse，key，cmp</p><pre><code>&gt;&gt;&gt; a = [5,4,6,7,9,1,2]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; print(a)[1, 2, 4, 5, 6, 7, 9]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; print(a)[9, 7, 6, 5, 4, 2, 1]&gt;&gt;&gt;  </code></pre><p>2.sorted</p><ul><li>sorted(data, cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)</li></ul><p>reverse True 从大到小，False 从小到大</p><p>从网上收集到demo，这里直接用下～</p><pre><code>&gt;&gt;&gt; b = [&#39;aa&#39;,&#39;BB&#39;,&#39;bb&#39;,&#39;zz&#39;,&#39;CC&#39;] &gt;&gt;&gt; sorted(b) [&#39;BB&#39;, &#39;CC&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;zz&#39;]    #按列表中元素每个字母的ascii码从小到大排序,如果要从大到小,请用sorted(b,reverse=True)下同  &gt;&gt;&gt; c =[&#39;CCC&#39;, &#39;bb&#39;, &#39;ffff&#39;, &#39;z&#39;]  &gt;&gt;&gt; sorted(c,key=len)             #按列表的元素的长度排序 [&#39;z&#39;, &#39;bb&#39;, &#39;CCC&#39;, &#39;ffff&#39;]  &gt;&gt;&gt; d =[&#39;CCC&#39;, &#39;bb&#39;, &#39;ffff&#39;, &#39;z&#39;] &gt;&gt;&gt; sorted(d,key = str.lower )    #将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 [&#39;bb&#39;, &#39;CCC&#39;, &#39;ffff&#39;, &#39;z&#39;]  &gt;&gt;&gt; def lastchar(s):        return s[-1] &gt;&gt;&gt; e = [&#39;abc&#39;,&#39;b&#39;,&#39;AAz&#39;,&#39;ef&#39;] &gt;&gt;&gt; sorted(e,key = lastchar)      #自定义函数排序,lastchar为函数名，这个函数返回列表e中每个元素的最后一个字母 [&#39;b&#39;, &#39;abc&#39;, &#39;ef&#39;, &#39;AAz&#39;]         #sorted(e,key=lastchar)作用就是 按列表e中每个元素的最后一个字母的ascii码从小到大排序  &gt;&gt;&gt; f = [&#123;&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:20&#125;,&#123;&#39;name&#39;:&#39;def&#39;,&#39;age&#39;:30&#125;,&#123;&#39;name&#39;:&#39;ghi&#39;,&#39;age&#39;:25&#125;]     #列表中的元素为字典 &gt;&gt;&gt; def age(s):        return s[&#39;age&#39;] &gt;&gt;&gt; ff = sorted(f,key = age)      #自定义函数按列表f中字典的age从小到大排序   [&#123;&#39;age&#39;: 20, &#39;name&#39;: &#39;abc&#39;&#125;, &#123;&#39;age&#39;: 25, &#39;name&#39;: &#39;ghi&#39;&#125;, &#123;&#39;age&#39;: 30, &#39;name&#39;: &#39;def&#39;&#125;]  &gt;&gt;&gt; f2 = sorted(f,key = lambda x:x[&#39;age&#39;])    #如果觉得上面定义一个函数代码不美观，可以用lambda的形式来定义函数,效果同上 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS安装docker启动失败</title>
      <link href="/2017/11/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%AE%89%E8%A3%85docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"/>
      <url>/2017/11/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%AE%89%E8%A3%85docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在自己的测试服务器装起了docker，安装成功，but，启动失败了，解决后，在此记录下～</p></blockquote><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><pre><code> [root@fantasykai ~]# uname -r 3.10.0-514.26.2.el7.x86_64 [root@fantasykai ~]# lsb_release -a LSB Version::core-4.1-amd64:core-4.1-noarch Distributor ID:CentOS Description:CentOS Linux release 7.3.1611 (Core) Release:7.3.1611 Codename:Core</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code>yum -y install docker</code></pre><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><blockquote><p>启动报错：</p></blockquote><pre><code>[root@fantasykai ~]# service docder startRedirecting to /bin/systemctl start  docder.serviceFailed to start docder.service: Unit not found.</code></pre><h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><p>新建一个docker.socket 文件</p><p>vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket</p><pre><code>[Unit]Description=Docker Socket for the APIPartOf=docker.service[Socket]ListenStream=/var/run/docker.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.target</code></pre><p>然后运行</p><pre><code>systemctl daemon-reloadsystemctl start docker.socketsystemctl start docker</code></pre><p> OK，启动好了，可以在愉快的玩耍了～</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步github上fork的分支</title>
      <link href="/2017/10/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%90%8C%E6%AD%A5github%E4%B8%8Afork%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2017/10/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%90%8C%E6%AD%A5github%E4%B8%8Afork%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>github 上fork 大牛的持续更新的项目，一段时间后，想把大牛提交的部分，更新到自己fork出来的项目上，为此google一把，了然于心，在此记录下~</p></blockquote><p>实现这个需求，发现有2种玩法：</p><ul><li>Github 上点点就行</li><li>使用命令行的方式同步</li></ul><h3 id="在Github-页面上点击完成"><a href="#在Github-页面上点击完成" class="headerlink" title="在Github 页面上点击完成"></a>在Github 页面上点击完成</h3><p> 看图有真相！</p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lm22286j21ly0q6jz3.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1ln40g4nj21li0l4tdm.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lncoxarj21r40smtfg.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lnkj5wrj21cm0yqagu.jpg"></p><p> <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fl1lnqrersj21a20a2gnp.jpg"></p><h3 id="使用命令行方式同步"><a href="#使用命令行方式同步" class="headerlink" title="使用命令行方式同步"></a>使用命令行方式同步</h3><blockquote><p>怎么不了解命令行到方式呢～</p></blockquote><h4 id="1-配置源项目的地址"><a href="#1-配置源项目的地址" class="headerlink" title="1.配置源项目的地址"></a>1.配置源项目的地址</h4><blockquote><p>讲fork源的项目地址配置到自己的项目上。</p></blockquote><p>举个栗子</p><p>我fork了一个项目：pyeve&#x2F;eve，我的项目地址就是 fantasykai&#x2F;eve</p><p>项目名称上会显示 <code>forked from pyeve/eve</code></p><p>git clone 自己fork的项目后，添加一个远程仓库，即 源项目地址</p><pre><code>git remote add upstream https://github.com/pyeve/eve.git</code></pre><p>执行命令行后，查看下是否配置进来    </p><pre><code>git remote -vorigingit@github.com:fantasykai/eve.git (fetch)origingit@github.com:fantasykai/eve.git (push)upstreamhttps://github.com/pyeve/eve.git (fetch)upstreamhttps://github.com/pyeve/eve.git (push)</code></pre><h4 id="2-获取源项目更新内容。"><a href="#2-获取源项目更新内容。" class="headerlink" title="2.获取源项目更新内容。"></a>2.获取源项目更新内容。</h4><blockquote><p>使用 <code>fetch</code> 命令更新，fetch 后会更新到本地分支 <code>upstream/master</code></p></blockquote><pre><code>git fetch upstream</code></pre><h4 id="3-合并本地分支。"><a href="#3-合并本地分支。" class="headerlink" title="3.合并本地分支。"></a>3.合并本地分支。</h4><blockquote><p>切换到 <code>master</code> 分支，合并<code>upstream/master</code> 分支</p></blockquote><pre><code>git merge upstream/master</code></pre><h4 id="4-提交推送"><a href="#4-提交推送" class="headerlink" title="4.提交推送"></a>4.提交推送</h4><blockquote><p>解决本地冲突的代码，然后推送之</p></blockquote><pre><code>git push origin master</code></pre><blockquote><p>这样以来，之后想同步源项目的commits，就执行2，3，4 步骤</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS内核参数优化参考</title>
      <link href="/2017/10/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/"/>
      <url>/2017/10/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS内核参数优化参考"><a href="#CentOS内核参数优化参考" class="headerlink" title="CentOS内核参数优化参考"></a>CentOS内核参数优化参考</h1><blockquote><p>最近在做性能调优，把centos相关的配置也调整了下，找到一份不错的总结，这里记录下~</p></blockquote><p>所谓Linux服务器内核参数优化，主要是指在Linux系统中针对业务服务应用而进行的系统内核参数调整，优化并无一定的标准。下面以生产环境下Linux常见的内核优化为例进行讲解，仅供参考。</p><p>参考文章：</p><p>linux内核TCP相关参数解释</p><p><a href="http://os.chinaunix.net/a2008/0918/985/000000985483.shtml">http://os.chinaunix.net/a2008/0918/985/000000985483.shtml</a></p><p>linux内核参数优化</p><p><a href="http://blog.chinaunix.net/uid-29081804-id-3830203.html">http://blog.chinaunix.net/uid-29081804-id-3830203.html</a></p><p>linux内核调整和内核参数详解</p><p><a href="http://blog.csdn.net/cnbird2008/article/details/4419354">http://blog.csdn.net/cnbird2008/article/details/4419354</a></p><p>1、linux内核参数注释</p><p><strong>说明：以下表格中红色字体为常用优化参数，根据参数文件所处目录不同而进行分表整理</strong></p><p>（1）下列文件所在目录：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;</p><table><thead><tr><th>参数名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>tcp_syn_retries</td><td>5</td><td>1</td><td>对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,由tcp_retries1决定的)</td></tr><tr><td>tcp_synack_retries</td><td>5</td><td>1</td><td>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。</td></tr><tr><td>tcp_keepalive_time</td><td>7200</td><td>600</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。防止两边建立连接但不发送数据的攻击。</td></tr><tr><td>tcp_keepalive_probes</td><td>9</td><td>3</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td></tr><tr><td>tcp_keepalive_intvl</td><td>75</td><td>15</td><td>探测消息未获得响应时，重发该消息的间隔时间（秒）。默认值为75秒。 (对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</td></tr><tr><td>tcp_retries1</td><td>3</td><td>3</td><td>是3</td></tr><tr><td>tcp_retries2</td><td>15</td><td>5</td><td>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</td></tr><tr><td>tcp_orphan_retries</td><td>7</td><td>3</td><td>在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</td></tr><tr><td>tcp_fin_timeout</td><td>60</td><td>2</td><td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。</td></tr><tr><td>tcp_max_tw_buckets</td><td>180000</td><td>36000</td><td>系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</td></tr><tr><td>tcp_tw_recycle</td><td>0</td><td>1</td><td>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</td></tr><tr><td>tcp_tw_reuse</td><td>0</td><td>1</td><td>表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</td></tr><tr><td>tcp_max_orphans</td><td>8192</td><td>32768</td><td>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</td></tr><tr><td>tcp_abort_on_overflow</td><td>0</td><td>0</td><td>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</td></tr><tr><td>tcp_syncookies</td><td>0</td><td>1</td><td>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</td></tr><tr><td>tcp_stdurg</td><td>0</td><td>0</td><td>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在Linux 打开它﹐或会导致不能和它们正确沟通。</td></tr><tr><td>tcp_max_syn_backlog</td><td>1024</td><td>16384</td><td>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include&#x2F;net&#x2F;tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE*16(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies&#x2F;Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明)</td></tr><tr><td>tcp_window_scaling</td><td>1</td><td>1</td><td>该文件表示设置tcp&#x2F;ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp&#x2F;ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp&#x2F;ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）</td></tr><tr><td>tcp_timestamps</td><td>1</td><td>1</td><td>Timestamps 用在其它一些东西中﹐可以防范那些伪造的sequence 号码。一条1G的宽带线路或许会重遇到带out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</td></tr><tr><td>tcp_sack</td><td>1</td><td>1</td><td>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</td></tr><tr><td>tcp_fack</td><td>1</td><td>1</td><td>打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)[这个是TCP连接靠谱的核心功能]</td></tr><tr><td>tcp_dsack</td><td>1</td><td>1</td><td>允许TCP发送”两个完全相同”的SACK。</td></tr><tr><td>tcp_ecn</td><td>0</td><td>0</td><td>TCP的直接拥塞通告功能。</td></tr><tr><td>tcp_reordering</td><td>3</td><td>6</td><td>TCP流中重排序的数据报最大数量。 (一般有看到推荐把这个数值略微调整大一些,比如5)</td></tr><tr><td>tcp_retrans_collapse</td><td>1</td><td>0</td><td>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)</td></tr><tr><td>：</td><td>4096</td><td>8192</td><td>发送缓存设置</td></tr><tr><td>：</td><td>87380</td><td>32768</td><td>接收缓存设置</td></tr><tr><td>：</td><td>根据内存计算</td><td>786432</td><td>：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 &#x2F; 4096)。 )</td></tr><tr><td>tcp_app_win</td><td>31</td><td>31</td><td>时表示不需要缓冲。</td></tr><tr><td>tcp_adv_win_scale</td><td>2</td><td>2</td><td>计算缓冲开销</td></tr><tr><td>tcp_low_latency</td><td>0</td><td>0</td><td>集群的时候</td></tr><tr><td>tcp_westwood</td><td>0</td><td>0</td><td>通信来说应该启用这个选项。</td></tr><tr><td>tcp_bic</td><td>0</td><td>0</td><td>；这样可以更好地利用以</td></tr><tr><td>ip_forward</td><td>0</td><td>-</td><td>转发支持，把该值写</td></tr><tr><td>ip_local_port_range</td><td>61000</td><td>65000</td><td>，默认比较小，这个范围同样会间接用于</td></tr><tr><td>ip_conntrack_max</td><td>65535</td><td>65535</td><td>，这个值最大</td></tr></tbody></table><p><strong>（2）所处目录&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;netfilter&#x2F;，文件需要打开防火墙才会存在</strong></p><table><thead><tr><th>名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>ip_conntrack_max</td><td>65536</td><td>65536</td><td>，这个值最大</td></tr><tr><td>ip_conntrack_tcp_timeout_established</td><td>432000</td><td>180</td><td>，也就是</td></tr><tr><td>ip_conntrack_tcp_timeout_time_wait</td><td>120</td><td>120</td><td>状态超时时间，超过该时间就清除该连接</td></tr><tr><td>ip_conntrack_tcp_timeout_close_wait</td><td>60</td><td>60</td><td>状态超时时间，超过该时间就清除该连接</td></tr><tr><td>ip_conntrack_tcp_timeout_fin_wait</td><td>120</td><td>120</td><td>状态超时时间，超过该时间就清除该连接</td></tr></tbody></table><p><strong>（3）文件所处目录&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;</strong></p><table><thead><tr><th>参数名称</th><th>默认值</th><th>建议值</th><th>参数描述</th></tr></thead><tbody><tr><td>netdev_max_backlog</td><td>1024</td><td>16384</td><td>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，对重负载服务器而言，该值需要调高一点。</td></tr><tr><td>somaxconn</td><td>128</td><td>16384</td><td>用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制。</td></tr><tr><td>wmem_default</td><td>129024</td><td>129024</td><td>（以字节为单位）</td></tr><tr><td>rmem_default</td><td>129024</td><td>129024</td><td>（以字节为单位）</td></tr><tr><td>rmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据接收缓冲</td></tr><tr><td>wmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据发送缓冲</td></tr></tbody></table><h1 id="2、两种修改内核参数方法"><a href="#2、两种修改内核参数方法" class="headerlink" title="2、两种修改内核参数方法"></a>2、两种修改内核参数方法</h1><p>（1）、使用echo value方式直接追加到文件里如echo “1” &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries，但这种方法设备重启后又会恢复为默认值。</p><p>（2）、把参数添加到&#x2F;etc&#x2F;sysctl.conf中，然后执行sysctl -p使参数生效，永久生效。</p><h1 id="3、内核生产环境优化参数"><a href="#3、内核生产环境优化参数" class="headerlink" title="3、内核生产环境优化参数"></a>3、内核生产环境优化参数</h1><p>net.ipv4.tcp_syn_retries &#x3D; 1</p><p>net.ipv4.tcp_synack_retries &#x3D; 1</p><p>net.ipv4.tcp_keepalive_time &#x3D; 600</p><p>net.ipv4.tcp_keepalive_probes &#x3D; 3</p><p>net.ipv4.tcp_keepalive_intvl &#x3D;15</p><p>net.ipv4.tcp_retries2 &#x3D; 5</p><p>net.ipv4.tcp_fin_timeout &#x3D; 2</p><p>net.ipv4.tcp_max_tw_buckets &#x3D; 36000</p><p>net.ipv4.tcp_tw_recycle &#x3D; 1</p><p>net.ipv4.tcp_tw_reuse &#x3D; 1</p><p>net.ipv4.tcp_max_orphans &#x3D; 32768</p><p>net.ipv4.tcp_syncookies &#x3D; 1</p><p>net.ipv4.tcp_max_syn_backlog &#x3D; 16384</p><p>net.ipv4.tcp_wmem &#x3D; 8192 131072 16777216</p><p>net.ipv4.tcp_rmem &#x3D; 32768 131072 16777216</p><p>net.ipv4.tcp_mem &#x3D; 786432 1048576 1572864</p><p>net.ipv4.ip_local_port_range &#x3D; 1024 65000</p><p>net.ipv4.ip_conntrack_max &#x3D; 65536</p><p>net.ipv4.netfilter.ip_conntrack_max&#x3D;65536</p><p>net.ipv4.netfilter.ip_conntrack_tcp_timeout_established&#x3D;180</p><p>net.core.somaxconn &#x3D; 16384</p><p>net.core.netdev_max_backlog &#x3D; 16384</p><p>对比网上其他人的生产环境优化参数，需要优化的参数基本差不多，只是值有相应的变化。具体优化值要参考应用场景，这里所列只是常用优化参数，是否适合，可在上面查看该参数描述，理解后，再根据自己生产环境而设。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存溢出(OOM)异常总结</title>
      <link href="/2017/10/22/java/%20Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA(OOM)%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/22/java/%20Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA(OOM)%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看到一篇不错的 Java OOM的总结文章，收藏之，需要反复拜读～</p></blockquote><blockquote><p>我的职业生涯中见过数以千计的内存溢出异常均与下文中的8种情况相关。本文分析什么情况会导致这些异常出现，提供示例代码的同时为您提供解决指南。<strong>Nikita Salnikov-Tarnovski</strong><br>Plumbr Co-Founder and VP of Engineering<br>本文内容来源于Plumbr，对原文内容有删减和补充</p></blockquote><p>这也许是目前最为完整的Java OOM异常的解决指南。</p><h3 id="1、java-lang-OutOfMemoryError-Java-heap-space"><a href="#1、java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1、java.lang.OutOfMemoryError:Java heap space"></a>1、<code>java.lang.OutOfMemoryError:Java heap space</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：<code>Heap space（堆空间）</code>和<code>Permgen（永久代）</code>：</p><p>JVM内存模型示意图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><p>当应用程序试图向堆空间添加更多的数据，但堆却没有足够的空间来容纳这些数据时，将会触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。需要注意的是：即使有足够的物理内存可用，只要达到堆空间设置的大小限制，此异常仍然会被触发。</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>触发<code>java.lang.OutOfMemoryError: Java heap space</code>最常见的原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单，提供更大的堆空间即可。除了前面的因素还有更复杂的成因：</p><ul><li>流量&#x2F;数据量峰值：应用程序在设计之初均有用户量和数据量的限制，某一时刻，当用户数量或数据量突然达到一个峰值，并且这个峰值已经超过了设计之初预期的阈值，那么以前正常的功能将会停止，并触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。</li><li>内存泄漏：特定的编程错误会导致你的应用程序不停的消耗更多的内存，每次使用有内存泄漏风险的功能就会留下一些不能被回收的对象到堆空间中，随着时间的推移，泄漏的对象会消耗所有的堆空间，最终触发<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="①、简单示例"><a href="#①、简单示例" class="headerlink" title="①、简单示例"></a>①、简单示例</h5><p>首先看一个非常简单的示例，下面的代码试图创建2 x 1024 x 1024个元素的整型数组，当你尝试编译并指定12M堆空间运行时（java -Xmx12m OOM）将会失败并抛出<code>java.lang.OutOfMemoryError: Java heap space</code>错误，而当你指定13M堆空间时，将正常的运行。</p><blockquote><p>计算数组占用内存大小，不再本文的范围内，读者有兴趣，可以自行计算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class OOM &#123;</span><br><span class="line">    static final int SIZE=2*1024*1024;</span><br><span class="line">    public static void main(String[] a) &#123;</span><br><span class="line">        int[] i = new int[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;javac OOM.java</span><br><span class="line">D:\&gt;java -Xmx12m OOM</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at OOM.main(OOM.java:4)</span><br><span class="line">D:\&gt;java -Xmx13m OOM</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="②、内存泄漏示例"><a href="#②、内存泄漏示例" class="headerlink" title="②、内存泄漏示例"></a>②、内存泄漏示例</h5><p>在Java中，当开发者创建一个新对象（比如：<code>new Integer(5)</code>）时，不需要自己开辟内存空间，而是把它交给JVM。在应用程序整个生命周期类，JVM负责检查哪些对象可用，哪些对象未被使用。未使用对象将被丢弃，其占用的内存也将被回收，这一过程被称为垃圾回收。JVM负责垃圾回收的模块集合被称为垃圾回收器（<code>GC</code>）。</p><p>Java的内存自动管理机制依赖于GC定期查找未使用对象并删除它们。Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</p><p>我们可以非常容易的写出导致内存泄漏的Java代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class KeylessEntry &#123;</span><br><span class="line">    </span><br><span class="line">    static class Key &#123;</span><br><span class="line">        Integer id;</span><br><span class="line">        </span><br><span class="line">        Key(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            return id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Key,String&gt; m = new HashMap&lt;Key,String&gt;();</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            for(int i=0;i&lt;10000;i++) &#123;</span><br><span class="line">                if(!m.containsKey(new Key(i))) &#123;</span><br><span class="line">                    m.put(new Key(i), &quot;Number:&quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中<code>HashMap</code>为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于<code>Key</code>实体没有实现<code>equals()</code>方法，导致for循环中每次执行<code>m.containsKey(new Key(i))</code>结果均为<code>false</code>，其结果就是<code>HashMap</code>中的元素将一直增加。</p><p>随着时间的推移，越来越多的<code>Key</code>对象进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出<code>java.lang.OutOfMemoryError:Java heap space</code>。</p><blockquote><p>上面的代码直接运行可能很久也不会抛出异常，可以在启动时使用-Xmx参数，设置堆内存大小，或者在for循环后打印HashMap的大小，执行后会发现HashMap的size一直再增长。</p></blockquote><p>解决方法也非常简单，只要<code>Key</code>实现自己的<code>equals</code>方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    boolean response = false;</span><br><span class="line">    if (o instanceof Key) &#123;</span><br><span class="line">        response = (((Key)o).id).equals(this.id);</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，你应该确保有足够的堆空间来正常运行你的应用程序，在JVM的启动配置中增加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的配置分配1024M堆空间给你的应用程序，当然你也可以使用其他单位，比如用G表示GB，K表示KB。下面的示例都表示最大堆空间为1GB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1073741824 com.mycompany.MyClass</span><br><span class="line">java -Xmx1048576k com.mycompany.MyClass</span><br><span class="line">java -Xmx1024m com.mycompany.MyClass</span><br><span class="line">java -Xmx1g com.mycompany.MyClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，更多的时候，单纯地增加堆空间不能解决所有的问题。如果你的程序存在内存泄漏，一味的增加堆空间也只是推迟<code>java.lang.OutOfMemoryError: Java heap space</code>错误出现的时间而已，并未解决这个隐患。除此之外，垃圾收集器在GC时，应用程序会停止运行直到GC完成，而增加堆空间也会导致GC时间延长，进而影响程序的吞吐量。</p><p>如果你想完全解决这个问题，那就好好提升自己的编程技能吧，当然运用好<code>Debuggers, profilers, heap dump analyzers</code>等工具，可以让你的程序最大程度的避免内存泄漏问题。</p><h3 id="2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded"><a href="#2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded" class="headerlink" title="2、java.lang.OutOfMemoryError:GC overhead limit exceeded"></a>2、<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code></h3><p>Java运行时环境（<code>JRE</code>）包含一个内置的垃圾回收进程，而在许多其他的编程语言中，开发者需要手动分配和释放内存。</p><p>Java应用程序只需要开发者分配内存，每当在内存中特定的空间不再使用时，一个单独的垃圾收集进程会清空这些内存空间。垃圾收集器怎样检测内存中的某些空间不再使用已经超出本文的范围，但你只需要相信GC可以做好这些工作即可。</p><p>默认情况下，当应用程序花费超过98%的时间用来做GC并且回收了不到2%的堆内存时，会抛出<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误。具体的表现就是你的应用几乎耗尽所有可用内存，并且GC多次均未能清理干净。</p><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><p><code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。那如果没有此限制会发生什么呢？GC进程将被重启，100%的CPU将用于GC，而没有CPU资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。</p><p>所以<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>也可以看做是一个<code>fail-fast（快速失败）</code>实战的实例。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的代码初始化一个<code>map</code>并在无限循环中不停的添加键值对，运行后将会抛出<code>GC overhead limit exceeded</code>错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        Map map = System.getProperties();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            map.put(r.nextInt(), &quot;value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如你所预料的那样，程序不能正常的结束，事实上，当我们使用如下参数启动程序时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseParallelGC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们很快就可以看到程序抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误。但如果在启动时设置不同的堆空间大小或者使用不同的GC算法，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx10m -XX:+UseParallelGC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们将看到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at java.util.Hashtable.rehash(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.addEntry(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.put(Unknown Source)</span><br><span class="line">    at cn.moondev.Wrapper.main(Wrapper.java:12)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用以下GC算法：<code>-XX:+UseConcMarkSweepGC</code> 或者<code>-XX:+UseG1GC</code>，启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseConcMarkSweepGC Wrapper</span><br><span class="line">java -Xmx100m -XX:+UseG1GC Wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception: java.lang.OutOfMemoryError thrown from </span><br><span class="line">the UncaughtExceptionHandler in thread &quot;main&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。</p><p>以上这些变化可以说明，在资源有限的情况下，你根本无法无法预测你的应用是怎样挂掉的，什么时候会挂掉，所以在开发时，你不能仅仅保证自己的应用程序在特定的环境下正常运行。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先是一个毫无诚意的解决方案，如果你仅仅是不想看到<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>的错误信息，可以在应用程序启动时添加如下JVM参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseGCOverheadLimit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是强烈建议不要使用这个选项，因为这样并没有解决任何问题，只是推迟了错误出现的时间，错误信息也变成了我们更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>而已。</p><p>另一个解决方案，如果你的应用程序确实内存不足，增加堆内存会解决<code>GC overhead limit</code>问题，就如下面这样，给你的应用程序1G的堆内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m com.yourcompany.YourClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但如果你想确保你已经解决了潜在的问题，而不是掩盖<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误，那么你不应该仅止步于此。你要记得还有<code>profilers</code>和<code>memory dump analyzers</code>这些工具，你需要花费更多的时间和精力来查找问题。还有一点需要注意，这些工具在Java运行时有显著的开销，因此不建议在生产环境中使用。</p><h3 id="3、java-lang-OutOfMemoryError-Permgen-space"><a href="#3、java-lang-OutOfMemoryError-Permgen-space" class="headerlink" title="3、java.lang.OutOfMemoryError:Permgen space"></a>3、<code>java.lang.OutOfMemoryError:Permgen space</code></h3><p>Java中堆空间是JVM管理的最大一块内存空间，可以在JVM启动时指定堆空间的大小，其中堆被划分成两个不同的区域：新生代（Young）和老年代（Tenured），新生代又被划分为3个区域：<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>，如下图所示。</p><p>图片来源：并发编程网</p><p><code>java.lang.OutOfMemoryError: PermGen space</code>错误就表明持久代所在区域的内存已被耗尽。</p><h4 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h4><p>要理解<code>java.lang.OutOfMemoryError: PermGen space</code>出现的原因，首先需要理解<code>Permanent Generation Space</code>的用处是什么。持久代主要存储的是每个类的信息，比如：<strong>类加载器引用</strong>、<strong>运行时常量池（所有常量、字段引用、方法引用、属性）</strong>、<strong>字段(Field)数据</strong>、<strong>方法(Method)数据</strong>、<strong>方法代码</strong>、<strong>方法字节码</strong>等等。我们可以推断出，<code>PermGen</code>的大小取决于被加载类的数量以及类的大小。</p><p>因此，我们可以得出出现<code>java.lang.OutOfMemoryError: PermGen space</code>错误的原因是：太多的类或者太大的类被加载到<code>permanent generation</code>（持久代）。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><h5 id="①、最简单的示例"><a href="#①、最简单的示例" class="headerlink" title="①、最简单的示例"></a>①、最简单的示例</h5><p>正如前面所描述的，<code>PermGen</code>的使用与加载到JVM类的数量有密切关系，下面是一个最简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;</span><br><span class="line">public class MicroGenerator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100_000_000; i++) &#123;</span><br><span class="line">            generate(&quot;cn.moondev.User&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Class generate(String name) throws Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        return pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行时请设置JVM参数：<code>-XX:MaxPermSize=5m</code>，值越小越好。需要注意的是JDK8已经完全移除持久代空间，取而代之的是元空间（<code>Metaspace</code>），所以示例最好的JDK1.7或者1.6下运行。</p><p>代码在运行时不停的生成类并加载到持久代中，直到撑满持久代内存空间，最后抛出<code>java.lang.OutOfMemoryError:Permgen space</code>。代码中类的生成使用了<code>javassist</code>库。</p><h5 id="②、Redeploy-time"><a href="#②、Redeploy-time" class="headerlink" title="②、Redeploy-time"></a>②、Redeploy-time</h5><p>更复杂和实际的一个例子就是Redeploy（重新部署，你可以想象一下你开发时，点击eclipse的reploy按钮或者使用idea时按ctrl + F5时的过程）。在从服务器卸载应用程序时，当前的<code>classloader</code>以及加载的<code>class</code>在没有实例引用的情况下，持久代的内存空间会被GC清理并回收。如果应用中有类的实例对当前的<code>classloader</code>的引用，那么<code>Permgen</code>区的<code>class</code>将无法被卸载，导致<code>Permgen</code>区的内存一直增加直到出现<code>Permgen space</code>错误。</p><p>不幸的是，许多第三方库以及糟糕的资源处理方式（比如：线程、JDBC驱动程序、文件系统句柄）使得卸载以前使用的类加载器变成了一件不可能的事。反过来就意味着在每次重新部署过程中，应用程序所有的类的先前版本将仍然驻留在<code>Permgen</code>区中，你的每次部署都将生成几十甚至几百M的垃圾。</p><p>就以线程和JDBC驱动来说说。很多人都会使用线程来处理一下周期性或者耗时较长的任务，这个时候一定要注意线程的生命周期问题，你需要确保线程不能比你的应用程序活得还长。否则，如果应用程序已经被卸载，线程还在继续运行，这个线程通常会维持对应用程序的<code>classloader</code>的引用，造成的结果就不再多说。多说一句，<strong>开发者有责任处理好这个问题，特别是如果你是第三方库的提供者的话，一定要提供线程关闭接口来处理清理工作</strong>。</p><p>让我们想象一个使用JDBC驱动程序连接到关系数据库的示例应用程序。当应用程序部署到服务器上的时：服务器创建一个<code>classloader</code>实例来加载应用所有的类（包含相应的JDBC驱动）。根据JDBC规范，JDBC驱动程序（比如：<code>com.mysql.jdbc.Driver</code>）会在初始化时将自己注册到<code>java.sql.DriverManager</code>中。该注册过程中会将驱动程序的一个实例存储在DriverManager的静态字段内，代码可以参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// com.mysql.jdbc.Driver源码</span><br><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can\&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// // // // // // // // // //</span><br><span class="line">// 再看下DriverManager对应代码</span><br><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,DriverAction da) throws SQLException &#123;</span><br><span class="line">    if(driver != null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，当从服务器上卸载应用程序的时候，<code>java.sql.DriverManager</code>仍将持有那个驱动程序的引用，进而持有用于加载应用程序的<code>classloader</code>的一个实例的引用。这个<code>classloader</code>现在仍然引用着应用程序的所有类。如果此程序启动时需要加载2000个类，占用约10MB永久代（PermGen）内存，那么只需要5~10次重新部署，就会将默认大小的永久代（PermGen）塞满，然后就会触发<code>java.lang.OutOfMemoryError: PermGen space</code>错误并崩溃。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="①-解决初始化时的OutOfMemoryError"><a href="#①-解决初始化时的OutOfMemoryError" class="headerlink" title="① 解决初始化时的OutOfMemoryError"></a>① 解决初始化时的<code>OutOfMemoryError</code></h5><p>当在应用程序启动期间触发由于<code>PermGen</code>耗尽引起的<code>OutOfMemoryError</code>时，解决方案很简单。 应用程序需要更多的空间来加载所有的类到<code>PermGen</code>区域，所以我们只需要增加它的大小。 为此，请更改应用程序启动配置，并添加（或增加，如果存在）-XX：MaxPermSize参数，类似于以下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxPermSize=512m com.yourcompany.YourClass</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="②-解决Redeploy时的OutOfMemoryError"><a href="#②-解决Redeploy时的OutOfMemoryError" class="headerlink" title="② 解决Redeploy时的OutOfMemoryError"></a>② 解决<code>Redeploy</code>时的<code>OutOfMemoryError</code></h5><p>分析dump文件：首先，找出引用在哪里被持有；其次，给你的web应用程序添加一个关闭的hook，或者在应用程序卸载后移除引用。你可以使用如下命令导出dump文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump.hprof &lt;process-id&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是你自己代码的问题请及时修改，如果是第三方库，请试着搜索一下是否存在”关闭”接口，如果没有给开发者提交一个bug或者issue吧。</p><h5 id="③-解决运行时OutOfMemoryError"><a href="#③-解决运行时OutOfMemoryError" class="headerlink" title="③ 解决运行时OutOfMemoryError"></a>③ 解决运行时<code>OutOfMemoryError</code></h5><p>首先你需要检查是否允许GC从<code>PermGen</code>卸载类，JVM的标准配置相当保守，只要类一创建，即使已经没有实例引用它们，其仍将保留在内存中，特别是当应用程序需要动态创建大量的类但其生命周期并不长时，允许JVM卸载类对应用大有助益，你可以通过在启动脚本中添加以下配置参数来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，这个配置是未启用的，如果你启用它，GC将扫描<code>PermGen</code>区并清理已经不再使用的类。但请注意，这个配置只在<code>UseConcMarkSweepGC</code>的情况下生效，如果你使用其他GC算法，比如：<code>ParallelGC</code>或者<code>Serial GC</code>时，这个配置无效。所以使用以上配置时，请配合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你已经确保JVM可以卸载类，但是仍然出现内存溢出问题，那么你应该继续分析dump文件，使用以下命令生成dump文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=dump.hprof,format=b &lt;process-id&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你拿到生成的堆转储文件，并利用像Eclipse Memory Analyzer Toolkit这样的工具来寻找应该卸载却没被卸载的类加载器，然后对该类加载器加载的类进行排查，找到可疑对象，分析使用或者生成这些类的代码，查找产生问题的根源并解决它。</p><h3 id="4、java-lang-OutOfMemoryError-Metaspace"><a href="#4、java-lang-OutOfMemoryError-Metaspace" class="headerlink" title="4、java.lang.OutOfMemoryError:Metaspace"></a>4、<code>java.lang.OutOfMemoryError:Metaspace</code></h3><p>前文已经提过，<code>PermGen</code>区域用于存储类的名称和字段，类的方法，方法的字节码，常量池，JIT优化等，但从Java8开始，Java中的内存模型发生了重大变化：引入了称为<code>Metaspace</code>的新内存区域，而删除了<code>PermGen</code>区域。请注意：不是简单的将<code>PermGen</code>区所存储的内容直接移到<code>Metaspace</code>区，<code>PermGen</code>区中的某些部分，已经移动到了普通堆里面。</p><p>OOM-example-metaspace，图片来源：Plumbr</p><h4 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h4><p>Java8做出如此改变的原因包括但不限于：</p><ul><li>应用程序所需要的<code>PermGen</code>区大小很难预测，设置太小会触发<code>PermGen OutOfMemoryError</code>错误，过度设置导致资源浪费。</li><li>提升GC性能，在HotSpot中的每个垃圾收集器需要专门的代码来处理存储在<code>PermGen</code>中的类的元数据信息。从<code>PermGen</code>分离类的元数据信息到<code>Metaspace</code>，由于<code>Metaspace</code>的分配具有和<code>Java Heap</code>相同的地址空间，因此<code>Metaspace</code>和<code>Java Heap</code>可以无缝的管理，而且简化了<code>FullGC</code>的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有GC暂停。</li><li>支持进一步优化，比如：G1并发类的卸载，也算为将来做准备吧</li></ul><p>正如你所看到的，元空间大小的要求取决于加载的类的数量以及这种类声明的大小。 所以很容易看到<code>java.lang.OutOfMemoryError: Metaspace</code>主要原因：太多的类或太大的类加载到元空间。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>正如上文中所解释的，元空间的使用与加载到JVM中的类的数量密切相关。 下面的代码是最简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Metaspace &#123;</span><br><span class="line">    static javassist.ClassPool cp = javassist.ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123; </span><br><span class="line">            Class c = cp.makeClass(&quot;eu.plumbr.demo.Generated&quot; + i).toClass();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序运行中不停的生成新类，所有的这些类的定义将被加载到<code>Metaspace</code>区，直到空间被完全占用并且抛出<code>java.lang.OutOfMemoryError:Metaspace</code>。当使用<code>-XX：MaxMetaspaceSize = 32m</code>启动时，大约加载30000多个类时就会死机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">31023</span><br><span class="line">31024</span><br><span class="line">Exception in thread &quot;main&quot; javassist.CannotCompileException: by java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1170)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1113)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1071)</span><br><span class="line">    at javassist.CtClass.toClass(CtClass.java:1275)</span><br><span class="line">    at cn.moondev.book.Metaspace.main(Metaspace.java:12)</span><br><span class="line">    .....</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，既然应用程序会耗尽内存中的<code>Metaspace</code>区空间，那么应该增加其大小，更改启动配置增加如下参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 告诉JVM：Metaspace允许增长到512，然后才能抛出异常</span><br><span class="line">-XX：MaxMetaspaceSize = 512m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一个方法就是删除此参数来完全解除对<code>Metaspace</code>大小的限制（默认是没有限制的）。默认情况下，对于64位服务器端JVM，MetaspaceSize默认大小是21M（初始限制值），一旦达到这个限制值，FullGC将被触发进行类卸载，并且这个限制值将会被重置，新的限制值依赖于<code>Metaspace</code>的剩余容量。如果没有足够空间被释放，这个限制值将会上升，反之亦然。在技术上<code>Metaspace</code>的尺寸可以增长到交换空间，而这个时候本地内存分配将会失败（更具体的分析，可以参考：<a href="http://ifeve.com/java-permgen-removed/">Java PermGen 去哪里了?</a>）。</p><p>你可以通过修改各种启动参数来“快速修复”这些内存溢出错误，但你需要正确区分你是否只是推迟或者隐藏了<code>java.lang.OutOfMemoryError</code>的症状。如果你的应用程序确实存在内存泄漏或者本来就加载了一些不合理的类，那么所有这些配置都只是推迟问题出现的时间而已，实际也不会改善任何东西。</p><h3 id="5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread"><a href="#5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread" class="headerlink" title="5、java.lang.OutOfMemoryError:Unable to create new native thread"></a>5、<code>java.lang.OutOfMemoryError:Unable to create new native thread</code></h3><p>一个思考线程的方法是将线程看着是执行任务的工人，如果你只有一个工人，那么他同时只能执行一项任务，但如果你有十几个工人，就可以同时完成你几个任务。就像这些工人都在物理世界，JVM中的线程完成自己的工作也是需要一些空间的，当有足够多的线程却没有那么多的空间时就会像这样：</p><p>图片来源：Plumbr</p><p>出现<code>java.lang.OutOfMemoryError:Unable to create new native thread</code>就意味着Java应用程序已达到其可以启动线程数量的极限了。</p><h4 id="原因分析-4"><a href="#原因分析-4" class="headerlink" title="原因分析"></a>原因分析</h4><p>当JVM向OS请求创建一个新线程时，而OS却无法创建新的native线程时就会抛出<code>Unable to create new native thread</code>错误。一台服务器可以创建的线程数依赖于物理配置和平台，建议运行下文中的示例代码来测试找出这些限制。总体上来说，抛出此错误会经过以下几个阶段：</p><ul><li>运行在JVM内的应用程序请求创建一个新的线程</li><li>JVM向OS请求创建一个新的native线程</li><li>OS尝试创建一个新的native线程，这时需要分配内存给新的线程</li><li>OS拒绝分配内存给线程，因为32位Java进程已经耗尽内存地址空间（2-4GB内存地址已被命中）或者OS的虚拟内存已经完全耗尽</li><li><code>Unable to create new native thread</code>错误将被抛出</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例不能的创建并启动新的线程。当代码运行时，很快达到OS的线程数限制，并抛出<code>Unable to create new native thread</code>错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(10000000);</span><br><span class="line">            &#125; catch(InterruptedException e) &#123; &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>有时，你可以通过在OS级别增加线程数限制来绕过这个错误。如果你限制了JVM可在用户空间创建的线程数，那么你可以检查并增加这个限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// macOS 10.12上执行</span><br><span class="line">$ ulimit -u</span><br><span class="line">709</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你的应用程序产生成千上万的线程，并抛出此异常，表示你的程序已经出现了很严重的编程错误，我不觉得应该通过修改参数来解决这个问题，不管是OS级别的参数还是JVM启动参数。更可取的办法是分析你的应用是否真的需要创建如此多的线程来完成任务？是否可以使用线程池或者说线程池的数量是否合适？是否可以更合理的拆分业务来实现…..</p><h3 id="6、java-lang-OutOfMemoryError-Out-of-swap-space"><a href="#6、java-lang-OutOfMemoryError-Out-of-swap-space" class="headerlink" title="6、java.lang.OutOfMemoryError:Out of swap space?"></a>6、<code>java.lang.OutOfMemoryError:Out of swap space?</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，可以通过<code>-Xmx</code>和其他类似的启动参数来指定。在JVM请求的总内存大于可用物理内存的情况下，操作系统会将内存中的数据交换到磁盘上去。</p><p>图片来源：plumbr</p><p><code>Out of swap space?</code>表示交换空间也将耗尽，并且由于缺少物理内存和交换空间，再次尝试分配内存也将失败。</p><h4 id="原因分析-5"><a href="#原因分析-5" class="headerlink" title="原因分析"></a>原因分析</h4><p>当应用程序向JVM native heap请求分配内存失败并且native heap也即将耗尽时，JVM会抛出<code>Out of swap space</code>错误。该错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。</p><blockquote><p>Native Heap Memory是JVM内部使用的Memory，这部分的Memory可以通过JDK提供的JNI的方式去访问，这部分Memory效率很高，但是管理需要自己去做，如果没有把握最好不要使用，以防出现内存泄露问题。JVM 使用Native Heap Memory用来优化代码载入（JTI代码生成），临时对象空间申请，以及JVM内部的一些操作。</p></blockquote><p>这个问题往往发生在Java进程已经开始交换的情况下，现代的GC算法已经做得足够好了，当时当面临由于交换引起的延迟问题时，GC暂停的时间往往会让大多数应用程序不能容忍。</p><p><code>java.lang.OutOfMemoryError:Out of swap space?</code>往往是由操作系统级别的问题引起的，例如：</p><ul><li>操作系统配置的交换空间不足。</li><li>系统上的另一个进程消耗所有内存资源。</li></ul><p>还有可能是本地内存泄漏导致应用程序失败，比如：应用程序调用了native code连续分配内存，但却没有被释放。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题有几个办法，通常最简单的方法就是增加交换空间，不同平台实现的方式会有所不同，比如在Linux下可以通过如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line"># 创建并附加一个大小为640MB的新交换文件</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java GC会扫描内存中的数据，如果是对交换空间运行垃圾回收算法会使GC暂停的时间增加几个数量级，因此你应该慎重考虑使用上文增加交换空间的方法。</p><p>如果你的应用程序部署在JVM需要同其他进程激烈竞争获取资源的物理机上，建议将服务隔离到单独的虚拟机中</p><p>但在许多情况下，您唯一真正可行的替代方案是：</p><ul><li>升级机器以包含更多内存</li><li>优化应用程序以减少其内存占用</li></ul><p>当您转向优化路径时，使用内存转储分析程序来检测内存中的大分配是一个好的开始。</p><h3 id="7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit"><a href="#7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit" class="headerlink" title="7、java.lang.OutOfMemoryError:Requested array size exceeds VM limit"></a>7、<code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code></h3><p>Java对应用程序可以分配的最大数组大小有限制。不同平台限制有所不同，但通常在1到21亿个元素之间。</p><p>图片来源：plumbr</p><p>当你遇到<code>Requested array size exceeds VM limit</code>错误时，意味着你的应用程序试图分配大于Java虚拟机可以支持的数组。</p><h4 id="原因分析-6"><a href="#原因分析-6" class="headerlink" title="原因分析"></a>原因分析</h4><p>该错误由JVM中的<code>native code</code>抛出。 JVM在为数组分配内存之前，会执行特定于平台的检查：分配的数据结构是否在此平台中是可寻址的。</p><p>你很少见到这个错误是因为Java数组的索引是int类型。 Java中的最大正整数为2 ^ 31 - 1 &#x3D; 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：我的环境上(64位macOS，运行Jdk1.8)可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。如果再将数组的长度增加1到Integer.MAX_VALUE-1会导致熟悉的OutOfMemoryError：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，在使用OpenJDK 6的32位Linux上，在分配具有大约11亿个元素的数组时，您将遇到<code>Requested array size exceeded VM limit</code>的错误。 要理解你的特定环境的限制，运行下文中描述的小测试程序。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 3; i &gt;= 0; i--) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int[] arr = new int[Integer.MAX_VALUE-i];</span><br><span class="line">        System.out.format(&quot;Successfully initialized an array with %,d elements.\n&quot;, Integer.MAX_VALUE-i);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该示例重复四次，并在每个回合中初始化一个长原语数组。 该程序尝试初始化的数组的大小在每次迭代时增加1，最终达到Integer.MAX_VALUE。 现在，当使用Hotspot 7在64位Mac OS X上启动代码片段时，应该得到类似于以下内容的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，在出现<code>Requested array size exceeded VM limit</code>之前，出现了更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>。 这是因为初始化2 ^ 31-1个元素的数组需要腾出8G的内存空间，大于JVM使用的默认值。</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code>可能会在以下任一情况下出现：</p><ul><li>数组增长太大，最终大小在平台限制和<code>Integer.MAX_INT</code>之间</li><li>你有意分配大于<code>2 ^ 31-1</code>个元素的数组</li></ul><p>在第一种情况下，检查你的代码库，看看你是否真的需要这么大的数组。也许你可以减少数组的大小，或者将数组分成更小的数据块，然后分批处理数据。</p><p>在第二种情况下，记住Java数组是由int索引的。因此，当在平台中使用标准数据结构时，数组不能超过2 ^ 31-1个元素。事实上，在编译时就会出错：<code>error：integer number too large</code>。</p><h3 id="8、Out-of-memory-Kill-process-or-sacrifice-child"><a href="#8、Out-of-memory-Kill-process-or-sacrifice-child" class="headerlink" title="8、Out of memory:Kill process or sacrifice child"></a>8、<code>Out of memory:Kill process or sacrifice child</code></h3><p>为了理解这个错误，我们需要补充一点操作系统的基础知识。操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，名叫“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，然后选择一个进程杀掉。哪一个进程这么倒霉呢？选择的算法和想法都很朴实：谁占用内存最多，谁就被干掉。如果你对OOM Killer感兴趣的话，建议你阅读参考资料2中的文章。</p><p>OOM Killer，图片来源：plumbr</p><p>当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，就会产生<code>Out of memory:Kill process or sacrifice child</code>错误。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。</p><h4 id="原因分析-7"><a href="#原因分析-7" class="headerlink" title="原因分析"></a>原因分析</h4><p>默认情况下，Linux内核允许进程请求比系统中可用内存更多的内存，但大多数进程实际上并没有使用完他们所分配的内存。这就跟现实生活中的宽带运营商类似，他们向所有消费者出售一个100M的带宽，远远超过用户实际使用的带宽，一个10G的链路可以非常轻松的服务100个(10G&#x2F;100M)用户，但实际上宽带运行商往往会把10G链路用于服务150人或者更多，以便让链路的利用率更高，毕竟空闲在那儿也没什么意义。</p><p>Linux内核采用的机制跟宽带运营商差不多，一般情况下都没有问题，但当大多数应用程序都消耗完自己的内存时，麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。就如同上面的例子中，如果150人都占用100M的带宽，那么总的带宽肯定超过了10G这条链路能承受的范围。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>当你在Linux上运行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    List&lt;int[]&gt; l = new java.util.ArrayList();</span><br><span class="line">    for (int i = 10000; i &lt; 100000; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            l.add(new int[100000000]);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Linux的系统日志中<code>/var/log/kern.log</code>会出现以下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice child</span><br><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：你可能需要调整交换文件和堆大小，否则你将很快见到熟悉的<code>Java heap space</code>异常。在原作者的测试用例中，使用<code>-Xmx2g</code>指定的2g堆，并具有以下交换配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意：原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题最有效也是最直接的方法就是升级内存，其他方法诸如：调整OOM Killer配置、水平扩展应用，将内存的负载分摊到若干小实例上….. 我们不建议的做法是增加交换空间，具体原因已经在前文说过。参考资料②中详细的介绍了怎样微调OOM Killer配置以及OOM Killer选择进程算法的实现，建议你参考阅读。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>① 想要了解更多PermGen与Metaspace的内容推荐你阅读：</p><ul><li><a href="http://www.infoq.com/cn/news/2013/03/java-8-permgen-metaspace">Java 8会解决PermGen OutOfMemoryError问题吗?</a></li><li><a href="http://ifeve.com/java-permgen-removed/">Java PermGen 去哪里了?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里Java开发规约idea插件</title>
      <link href="/2017/10/16/java/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6idea%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/10/16/java/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6idea%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>周六日看了阿里云的云栖大会，周日场（10月15日）研发效能峰会上，阿里正式发布了《阿里巴巴Java开发手册》，并提供了代码规范插件，目前主要使用idea开发，这里简单记录下使用方法</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>编码规约扫描</li></ul><p>扫描结果将以 <code>Blocker</code>&#x2F; <code>Critical</code>&#x2F; <code>Major</code> 三种级别显示</p><ul><li>实时检测</li></ul><p>基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><blockquote><p>安装很简单，在idea的Plugins，–&gt; Browse repositories 里直接搜索alibaba 就可以找到</p></blockquote><p>   <img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/install_2.png" alt="Switch language"></p><p>   <a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/install_2.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/install_2.png</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用也很简单 idea —&gt; tools —&gt; 阿里编码规约</p><ol><li><p>Switch language</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/switch_language.png" alt="Switch language"></p></li><li><p>Inspections</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection.png" alt="Real time"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection.png</a></p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection_setting.png" alt="Settings"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_setting.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_setting.png</a></p></li><li><p>Code Analyze</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/analyze.png" alt="Settings"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze.png</a></p><p>We use the idea standard Inspection Results to show our violations.</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/inspection_result.png" alt="Result"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_result.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/inspection_result.png</a></p><p>We can also analyze file which is modified before vcs checkin.</p><p><img src="https://github.com/alibaba/p3c/raw/master/idea-plugin/doc/images/analyze_before_checkin.png" alt="Before Checkin"></p><p><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze_before_checkin.png">https://github.com/alibaba/p3c/blob/master/idea-plugin/doc/images/analyze_before_checkin.png</a></p></li></ol><blockquote><p>《阿里巴巴Java开发手册（终极版）.pdf》已发 安排时间仔细阅读再~</p></blockquote><ul><li><a href="https://github.com/alibaba/p3c">github 地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏高效的小工具</title>
      <link href="/2017/10/14/%E5%B7%A5%E5%85%B7/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/10/14/%E5%B7%A5%E5%85%B7/%E6%94%B6%E8%97%8F%E9%AB%98%E6%95%88%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>此篇讲持续更新，把用着不错的工具整理出来～，提高效率的同时，也方便学习和分享～</p><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><p><a href="https://brew.sh/">Homebrew — The missing package manager for macOS</a>，Mac上非常好用的包管理工具，很多常见的安装都可以通过<code>brew install app</code>或者<code>brew cask install app</code>直接安装，类似apt-get，yum等，之前已经有篇幅记载。</p><h4 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h4><p><a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> mac上的命令行（bash–&gt;zsh）替代方案，各种强大</p><blockquote><p>Oh My Zsh will not make you a 10x developer…</p></blockquote><p>不管是自动纠错、目录切换、命令补全、参数补全、强大的alias，用起来都很顺手。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/oh-my-zsh.png" alt="oh-my-zsh.png"></p><h4 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h4><p>当简单查询某条命令如何使用时，用man查看简直是噩梦，实在太长了，Too Long Don’t Read!</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/man.png" alt="man"></p><p>而<a href="https://github.com/tldr-pages/tldr">tldr: Simplified and community-driven man pages</a>可以快速get到、回忆起命令的常见用法。对比一下：</p><pre><code>![tldr](http://oioeypcz0.bkt.clouddn.com/tldr-tar.png)</code></pre><h4 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h4><p>有时候cd到某个目录要好几层，用<a href="https://github.com/wting/autojump">Autojump: A cd command that learns</a>可以一步到位，安装之后，第一次需要手动cd，以后就可以<code>j longdir</code>即可。</p><pre><code>![autojump](http://oioeypcz0.bkt.clouddn.com/autojump.png)</code></pre><h4 id="Copy-as-Markdown"><a href="#Copy-as-Markdown" class="headerlink" title="Copy as Markdown"></a>Copy as Markdown</h4><p>对于经常用Markdown写文档的人来说，复制网页链接之后还要插入到<code>[]()</code>里，实在麻烦。<a href="https://github.com/chitsaou/copy-as-markdown">Copying Link, Image and Tab(s) as Markdown</a>解决这个头疼的问题。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/copy-as-markdown.png" alt="copy-as-markdown"></p><h4 id="Github-Hovercard"><a href="#Github-Hovercard" class="headerlink" title="Github Hovercard"></a>Github Hovercard</h4><p>经常混迹于Github人士会浏览无数的Repo，有时候只想大致看看Repo的信息，又懒惰打开那个网页。此时<a href="https://github.com/Justineo/github-hovercard">Github Hovercard</a>是你的不二之选。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/github-hovercard.png" alt="github-hovercard"></p><p>只需要把鼠标悬停在仓库链接即可。</p><h4 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h4><p>想看看Github上开源的代码，又不想一层层目录点下去，此时<a href="https://github.com/buunguyen/octotree">Octotree: Code tree for GitHub</a>正好解决这个难题。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/octotree.png" alt="Octotree"></p><h4 id="OctoLinker"><a href="#OctoLinker" class="headerlink" title="OctoLinker"></a>OctoLinker</h4><p>在Github上的代码，经常会看到<code>import ...</code>，习惯了IDE的你，是不是忍不住跳到那个类？<a href="https://github.com/OctoLinker/browser-extension">OctoLinker</a>满足你的这个需求。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/octo-linker.png" alt="octo-linker"></p><p>也支持Python。</p><h4 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h4><p>Mac下，想直接在某个文件夹下打开Terminal，咋办？去Terminal里打开实在是太麻烦了，试试<a href="http://zipzapmac.com/Go2Shell">Go2Shell</a>。集成在Finder里之后，一点即可。</p><h4 id="Web-Clipper"><a href="#Web-Clipper" class="headerlink" title="Web Clipper"></a>Web Clipper</h4><p>看到一篇好文章，保存链接不放心，怕链接失效；复制粘贴太麻烦。用<a href="https://evernote.com/products/webclipper/">Evernote Web Clipper</a>，直接保存富文本格式的文章，还只能去除广告，好用。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/web-clipper.png" alt="web-clipper"></p><h4 id="Json-Viewer"><a href="#Json-Viewer" class="headerlink" title="Json Viewer"></a>Json Viewer</h4><p>在浏览器上返回的Json文件，如果没有格式化太难看清其结构，利用<a href="https://github.com/tulios/json-viewer">Json Viewer</a>插件，就明了多了。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/json-viewer.png" alt="json-viewer"></p><h4 id="csvkit"><a href="#csvkit" class="headerlink" title="csvkit"></a>csvkit</h4><p>如果你做数据分析，这个命令行工具<a href="https://github.com/wireservice/csvkit/tree/1.0.2">csvkit</a>你一定喜欢。《Data Science at Command Line》一书推荐，很好用。</p><h4 id="Quicklook"><a href="#Quicklook" class="headerlink" title="Quicklook"></a>Quicklook</h4><p>工作中会遇到各种各样格式的文件，比如代码、Json、csv、Excel、markdown文档等。很多时候只想看大概信息，就是quicklook一下，不想打开编辑，这时候<a href="https://github.com/sindresorhus/quick-look-plugins">Quicklook Plugins: List of useful Quick Look plugins for developers</a>特别好用，官网上有很丰富的例子。</p><p>  <img src="http://oioeypcz0.bkt.clouddn.com/quicklook-markdown.png" alt="quicklook-markdown"></p><h4 id="stedolan-x2F-jq"><a href="#stedolan-x2F-jq" class="headerlink" title="stedolan&#x2F;jq"></a>stedolan&#x2F;jq</h4><p>jq是一个轻量级和灵活的命令行JSON处理器,jq 像<code>sed</code> 一样处理json数据，使用起来非常友好，<a href="https://github.com/stedolan/jq">github 地址</a></p><p>常用的场景：配合curl，命令行，格式化json输出</p><p>curl <a href="http://127.0.0.1:5000/people">http://127.0.0.1:5000/people</a> | jq</p><pre><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                Dload  Upload   Total   Spent    Left  Speed100   168  100   168    0     0  21804      0 --:--:-- --:--:-- --:--:-- 24000&#123;&quot;_items&quot;: [],&quot;_links&quot;: &#123;    &quot;parent&quot;: &#123;    &quot;title&quot;: &quot;home&quot;,    &quot;href&quot;: &quot;/&quot;    &#125;,    &quot;self&quot;: &#123;    &quot;title&quot;: &quot;people&quot;,    &quot;href&quot;: &quot;people&quot;    &#125;&#125;,&quot;_meta&quot;: &#123;    &quot;page&quot;: 1,    &quot;max_results&quot;: 25,    &quot;total&quot;: 0&#125;&#125;</code></pre><h4 id="dict-cli"><a href="#dict-cli" class="headerlink" title="dict-cli"></a>dict-cli</h4><p>python的翻译工具，使用pip 安装即可</p><pre><code>sudo pip install dict-cli     </code></pre><p>直接使用 dict 单词</p><pre><code>dict desktop####################################  desktop 桌面#  (U: &#39;dɛsk&#39;tɑp E: &#39;desktɒp)##  n. 桌面；台式机##  desktop : 桌面#             台式机#             桌上型的#  Google Desktop : Google桌面#                    Google桌面#                    桌面搜索#  Desktop search : 桌面搜索#                    桌面搜索#                    桌面搜寻###################################</code></pre><h4 id="终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd"><a href="#终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd" class="headerlink" title="终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd"></a>终端跳快速跳转到指定目录的oh-my-zsh插件：z与wd</h4><blockquote><p>zsh的z插件可以随意跳转最近经常打开的文件夹<br>zsh的wd插件可以任意跳转你标记过的文件夹</p></blockquote><h5 id="安装-z-和-wd-插件"><a href="#安装-z-和-wd-插件" class="headerlink" title="安装 z 和 wd 插件"></a>安装 <code>z</code> 和 <code>wd</code> 插件</h5><p>打开.zshrc 文件添加插件即可</p><pre><code>subl ~/.zshrc plugins=(git z wd)</code></pre><h5 id="使用-z-可查看最近访问最频繁的目录"><a href="#使用-z-可查看最近访问最频繁的目录" class="headerlink" title="使用 z 可查看最近访问最频繁的目录"></a>使用 <code>z</code> 可查看最近访问最频繁的目录</h5><p>z + 目录名部分内容即可跳转到目录</p><h5 id="使用wd插件"><a href="#使用wd插件" class="headerlink" title="使用wd插件"></a>使用wd插件</h5><pre><code>wd                  //查看所有可用命令wd add (label_name) //标记目录wd rm (label_name)  //去除目录标记wd list             //查看所有标记 </code></pre><p>在需要添加快捷方式的目录，直接执行 wd add 标签名称即可</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep命令的实践例子</title>
      <link href="/2017/10/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20grep%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90/"/>
      <url>/2017/10/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20grep%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p><strong>grep</strong> 应该是必备到命令了，看到一篇不错到总结，记录之</p><p><strong>grep</strong>是每个<strong>Linux</strong>发行版都预装的一个强有力的文件模式搜索工具。无论何种原因，如果你的系统没有预装它的话，你可以很容易的通过系统的包管理器来安装它（<strong>Debian&#x2F;Ubuntu</strong>系中的<strong>apt-get</strong>和<strong>RHEl&#x2F;CentOS&#x2F;Fedora</strong>系中的<strong>yum</strong>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install grep #Debian/Ubuntu $ sudo yum install grep #RHEL/CentOS/Fedora </span><br></pre></td></tr></table></figure><p>我发现使用现实世界中的真实例子让你投身其中是让你接触<strong>grep</strong>命令的最容易方式。</p><h3 id="1-搜索和寻找文件"><a href="#1-搜索和寻找文件" class="headerlink" title="1.搜索和寻找文件"></a>1.搜索和寻找文件</h3><p>假设你已经在你的电脑上安装了一个全新的<strong>Ubuntu</strong>，然后你打算卸载<strong>Python</strong>。你浏览网页寻找教程，但是你发现存在两个不同版本的<strong>Python</strong>在使用，而你不知道你的<strong>Ubuntu</strong>安装器到底在你的系统中安装了哪个版本的Python，也不知道它安装了哪些模块。解决这个烦恼只需简单的运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -l | grep -i python </span><br></pre></td></tr></table></figure><h4 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii  python2.7         2.7.3-0ubuntu3.4 Interactive high-level object-oriented language (version 2.7)</span><br><span class="line">ii  python2.7-minimal 2.7.3-0ubuntu3.4 Minimal subset of the Python language (version 2.7)</span><br><span class="line">ii  python-openssl    0.12-1ubuntu2.1  Python wrapper around the OpenSSL library</span><br><span class="line">ii  python-pam        0.4.2-12.2ubuntu4 A Python interface to the PAM library</span><br></pre></td></tr></table></figure><p>首先，我们运行<strong>dpkg -l</strong>列出你系统上安装的**.deb<strong>包。接着，我们使用管道将输出结果传输给命令</strong>grep -i<strong>python，这一步可以简单解释为把结果传输给grep然后过滤出所有含有python的项，并返回结果。–i选项用于忽略大小写,因为 grep 是大小写敏感的。使用选项</strong>-i**是个好习惯，除非你打算进行更细节的搜索。</p><h3 id="2-搜索和过滤文件"><a href="#2-搜索和过滤文件" class="headerlink" title="2.搜索和过滤文件"></a>2.搜索和过滤文件</h3><p>grep还可以在一个或多个文件里用于搜索和过滤。让我们来看一个这样的情景：</p><p>你的<strong>Apache网页服务器</strong>出现了问题，你不得不从许多专业网站里找一个发帖询问。好心回复你的人让你粘贴上来你的**&#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;default-ssl**文件内容。假如你能移除掉所有的注释行，那么对你，对帮你的人，以及所有阅读该文件的人，不是更容易发现问题吗？你当然可以很容易的做到！只需这样做就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep -v &quot;#&quot; /etc/apache2/sites-available/default-ssl </span><br></pre></td></tr></table></figure><p>选项**-v<strong>是告诉</strong>grep<strong>命令反转它的输出结果，意思就是不输出匹配的项，做相反的事，打印出所有不匹配的项。这个例子中，有</strong>#**的是注释行（译注：其实这个命令并不准确，包含“#”的行不全是注释行。关于如何精确匹配注释行，可以了解更多的关于正则表达式的内容。）。</p><h3 id="3-找出所有的mp3文件"><a href="#3-找出所有的mp3文件" class="headerlink" title="3.找出所有的mp3文件"></a>3.找出所有的mp3文件</h3><p><strong>grep</strong>命令对于过滤来自于<strong>标准输出</strong>的结果非常有用。例如，假设你的一个文件夹里面全是各种格式的音乐文件。你要找出艺术家<strong>jayZ</strong>的所有<strong>mp3</strong>格式的音乐文件，里面也不要有任何混合音轨。使用<strong>find命令</strong>再结合管道使用<strong>grep</strong>就可以完成这个魔法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find . -name &quot;.mp3&quot; | grep -i JayZ | grep -vi &quot;remix&quot;&quot; </span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用find命令打印出所有以**.mp3<strong>为后缀名的文件，接着将其使用管道传递给</strong>grep -i<strong>过滤和打印出名字为“</strong>JayZ<strong>”的文件,再使用管道传送给</strong>grep -vi<strong>以便过滤掉含有“</strong>remix**”的项。</p><ul><li><a href="http://www.tecmint.com/35-practical-examples-of-linux-find-command/">35个Linux中find命令的实践例子</a></li></ul><h3 id="4-在搜索字符串前面或者后面显示行号"><a href="#4-在搜索字符串前面或者后面显示行号" class="headerlink" title="4.在搜索字符串前面或者后面显示行号"></a>4.在搜索字符串前面或者后面显示行号</h3><p>另外两个选项是-A和-B之间的切换，是用以显示匹配的行以及行号，分别控制在字符串前或字符串后显示的行数。Man页给出了更加详细的解释，我发现一个记忆的小窍门：-A&#x3D;after、-B&#x3D;before。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -A 4 etho $ sudo ifconfig | grep -B 2 UP </span><br></pre></td></tr></table></figure><h3 id="5-在匹配字符串周围打印出行号"><a href="#5-在匹配字符串周围打印出行号" class="headerlink" title="5.在匹配字符串周围打印出行号"></a>5.在匹配字符串周围打印出行号</h3><p>grep命令的**-C**选项和例4中的很相似，不过打印的并不是在匹配字符串的前面或后面的行，而是打印出两个方向都匹配的行（译注：同上面的记忆窍门一样：-C&#x3D;center，以此为中心）： $ sudo ifconfig | grep -C 2 lo</p><h3 id="6-计算匹配项的数目"><a href="#6-计算匹配项的数目" class="headerlink" title="6.计算匹配项的数目"></a>6.计算匹配项的数目</h3><p>这个功能类似于将<strong>grep</strong>输出的结果用管道传送给计数器（<strong>wc</strong>程序），grep内建的选项可以达到同样的目的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -c inet6 </span><br></pre></td></tr></table></figure><h3 id="7-按给定字符串搜索文件中匹配的行号"><a href="#7-按给定字符串搜索文件中匹配的行号" class="headerlink" title="7.按给定字符串搜索文件中匹配的行号"></a>7.按给定字符串搜索文件中匹配的行号</h3><p>当你在编译出错时需要调试时，<strong>grep</strong>命令的**-n**选项是个非常有用的功能。它能告诉你所搜索的内容在文件的哪一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep -n &quot;main&quot; setup.py </span><br></pre></td></tr></table></figure><h3 id="8-在所有目录里递归的搜索"><a href="#8-在所有目录里递归的搜索" class="headerlink" title="8.在所有目录里递归的搜索"></a>8.在所有目录里递归的搜索</h3><p>假若你要在当前文件夹里搜索一个字符串，而当前文件夹里又有很多子目录，你可以指定一个**-r**选项以便于递归的搜索： $ sudo grep -r “function” *</p><h3 id="9-进行精确匹配搜索"><a href="#9-进行精确匹配搜索" class="headerlink" title="9.进行精确匹配搜索"></a>9.进行精确匹配搜索</h3><p>传递**-w**选项给grep命令可以在字符串中进行精确匹配搜索（译注：包含要搜索的单词，而不是通配）。例如，像下面这样输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -w “RUNNING” </span><br></pre></td></tr></table></figure><p>将打印出含有引号内匹配项的行。另外，你还可以试一下这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig | grep -w “RUN” </span><br></pre></td></tr></table></figure><p>搜索这个匹配项时，若搜索的东西里面没有这样的一个单独的单词，将什么也不会返回。</p><h3 id="10-在Gzip压缩文件中搜索"><a href="#10-在Gzip压缩文件中搜索" class="headerlink" title="10.在Gzip压缩文件中搜索"></a>10.在Gzip压缩文件中搜索</h3><p>我们还要关注一下grep的衍生应用。第一个是<strong>zgrep</strong>，这个与<strong>zcat</strong>很相似，可以用于<strong>gzip</strong>压缩过的文件。它有与<strong>grep</strong>相似的命令选项，使用方式也一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo zgrep -i error /var/log/syslog.2.gz </span><br></pre></td></tr></table></figure><h3 id="11-在文件中匹配正则表达式"><a href="#11-在文件中匹配正则表达式" class="headerlink" title="11.在文件中匹配正则表达式"></a>11.在文件中匹配正则表达式</h3><p><strong>egrep</strong>是另一个衍生应用，代表着“<strong>扩展全局正则表达式</strong>”。它可以识别更多的正则表达式元字符，例如<strong>at + ?</strong> | 和<strong>（）</strong>。在搜索源代码文件时，egrep是一个非常有用的工具，还有其他的一些零碎代码文件的搜索需要，使得这样的搜索能力成为必需。可以在grep命令中使用选项**-E**来启用它。</p><p>$ sudo grep -E</p><h3 id="12-搜索一个固定匹配字符串"><a href="#12-搜索一个固定匹配字符串" class="headerlink" title="12.搜索一个固定匹配字符串"></a>12.搜索一个固定匹配字符串</h3><p><strong>fgrep</strong>用于在一个文件或文件列表中搜索固定样式的字符串。功能与<strong>grep -F</strong>同。<strong>fgrep</strong>的一个通常用法为传递一个含有样式的文件给它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fgrep -f file_full_of_patterns.txt file_to_search.txt </span><br></pre></td></tr></table></figure><p>这仅仅是<strong>grep</strong>命令的开始，你可能已经注意到，它对于实现各种各样的需求简直是太有用了。除了这种我们运行的这种只有一行的命令，<strong>grep</strong>还可以写成<strong>cron</strong>任务或者自动的<strong>shell脚本</strong>去执行。保持好奇心，试验一下<strong>man页</strong>的各个选项，为实现你的目的写出一些<strong>grep表达式</strong>吧。</p><hr><p>via: <a href="http://www.tecmint.com/12-practical-examples-of-linux-grep-command/">http://www.tecmint.com/12-practical-examples-of-linux-grep-command/</a></p><p>译者：<a href="https://github.com/Linux-pdz">Linux-pdz</a> 校对：<a href="https://github.com/jasminepeng">jasminepeng</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-zsh的环境变量配置</title>
      <link href="/2017/10/08/%E5%B7%A5%E5%85%B7/%20oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/08/%E5%B7%A5%E5%85%B7/%20oh-my-zsh%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="配置环境变量的常用文件"><a href="#配置环境变量的常用文件" class="headerlink" title="配置环境变量的常用文件"></a>配置环境变量的常用文件</h2><h3 id="全局公用配置-profile-一般不建议直接配置该文件"><a href="#全局公用配置-profile-一般不建议直接配置该文件" class="headerlink" title="全局公用配置 profile 一般不建议直接配置该文件"></a>全局公用配置 profile 一般不建议直接配置该文件</h3><pre><code>            /etc/profile</code></pre><h3 id="全局公用配置-bashrc-bash-shell-系统级别的环境配置"><a href="#全局公用配置-bashrc-bash-shell-系统级别的环境配置" class="headerlink" title="全局公用配置 bashrc  bash shell 系统级别的环境配置"></a>全局公用配置 bashrc  bash shell 系统级别的环境配置</h3><pre><code>            /etc/bashrc</code></pre><h3 id="用户级别的的配置"><a href="#用户级别的的配置" class="headerlink" title="用户级别的的配置"></a>用户级别的的配置</h3><pre><code>            ~/.bash_profile</code></pre><h2 id="zsh-现在mac一般都会安装zsh，oh-my-zsh"><a href="#zsh-现在mac一般都会安装zsh，oh-my-zsh" class="headerlink" title="zsh 现在mac一般都会安装zsh，oh-my-zsh"></a>zsh 现在mac一般都会安装zsh，oh-my-zsh</h2><h3 id="oh-my-zsh-目录：-它是zsh的安装文件夹"><a href="#oh-my-zsh-目录：-它是zsh的安装文件夹" class="headerlink" title=".oh-my-zsh 目录： 它是zsh的安装文件夹"></a><code>.oh-my-zsh</code> 目录： 它是zsh的安装文件夹</h3><h3 id="zshrc-：-zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等"><a href="#zshrc-：-zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等" class="headerlink" title=".zshrc ： zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等"></a><code>.zshrc</code> ： zsh默认配置，可以用于设置环境变量，alias命令别名，设置主题等</h3><h3 id="x2F-oh-my-zsh-x2F-custom-x2F-my-custom-zsh-用户设置自定义系统变量、自定义命令等等"><a href="#x2F-oh-my-zsh-x2F-custom-x2F-my-custom-zsh-用户设置自定义系统变量、自定义命令等等" class="headerlink" title=".&#x2F;oh-my-zsh&#x2F;custom&#x2F;my_custom.zsh:用户设置自定义系统变量、自定义命令等等"></a>.&#x2F;oh-my-zsh&#x2F;custom&#x2F;my_custom.zsh:用户设置自定义系统变量、自定义命令等等</h3><blockquote><p>zsh不建议直接操作这个默认配置，如果用户需要自定义配置，推荐.&#x2F;oh-my-zsh&#x2F;custom&#x2F;custom.zsh修改。注意：custom文件夹里的所有配置都会被zsh自动读取并配置。</p></blockquote><ul><li><p>小贴士：可以配置一个快捷方式用于编辑<code>my_custom.zsh</code></p><pre><code>          alias zshconfig=&quot;subl ~/.oh-my-zsh/custom/my_custom.zsh&quot;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea中使用Debug</title>
      <link href="/2017/10/06/%E5%B7%A5%E5%85%B7/idea-Debug%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/10/06/%E5%B7%A5%E5%85%B7/idea-Debug%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：baojiangzhou<br><a href="http://www.cnblogs.com/chiangchou/">http://www.cnblogs.com/chiangchou/</a></p></blockquote><p>Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。</p><h2 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a>一、Debug开篇</h2><p>　　首先看下IDEA中Debug模式下的界面。</p><p>　　如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：</p><p>　　① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</p><p>　　② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上&#x2F;取消断点，断点行的颜色可自己去设置。</p><p>　　③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。</p><p>　　④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。</p><p>　　⑤ 服务按钮：可以在这里关闭&#x2F;启动服务，设置断点等。</p><p>　　⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</p><p>　　⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。</p><p>　　⑧ Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </p><p>　　[图1.1]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905221418147-1205043020.png" alt="img"></p><p> 　[图1.2]：在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905111655647-1134637623.png" alt="img"></p><p>　　[图1.3]：如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905112617351-1554043487.png" alt="img"></p><p>　　[图1.4]：在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905124338444-556465721.png" alt="img"></p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a>二、基本用法&amp;快捷键</h2><p>Debug调试的功能主要对应着图一中4和5两组按钮：</p><p>　　1、首先说第一组按钮，共8个按钮，从左到右依次如下：</p><p>　　　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905134837851-1615718043.png" alt="img"> [图2.1]</p><p>　　　　&gt; Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</p><p>　　　　&gt; Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</p><p>　　　　&gt; Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</p><p>　　　　&gt; Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</p><p>　　　　&gt; Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</p><p>　　　　&gt; Drop Frame (默认无)：回退断点，后面章节详细说明。</p><p>　　　　&gt; Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</p><p>　　　　&gt; Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。</p><p>　　2、第二组按钮，共7个按钮，从上到下依次如下：</p><p> 　　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905134011101-1824595229.png" alt="img"> [图2.2]</p><p>　　　　&gt; Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</p><p>　　　　&gt; Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。</p><p>　　　　&gt; Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</p><p>　　　　&gt; Pause Program：暂停程序，启用Debug。目前没发现具体用法。</p><p>　　　　&gt; Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p><p>　　　　&gt; View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。</p><p>　　　　&gt; Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。</p><p>　　　　 [图2.3]：更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。</p><p>　　　　　　　一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。</p><p>　　　　　　　下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。</p><p> 　 　 <img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905143932694-500925087.png" alt="img"></p><p>　　　　[图2.4]</p><p>　　　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905193821194-225518192.png" alt="img"></p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a>三、变量查看</h2><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。</p><p>　　1、如下，在IDEA中，参数所在行后面会显示当前变量的值。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905154209179-9123997.png" alt="img"> [图3.1]</p><p>　　2、光标悬停到参数上，显示当前变量信息。点击打开详情如图3.3。我一般会使用这种方式，快捷方便。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905154425772-770303651.png" alt="img"> [图3.2]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905154724866-160919363.png" alt="img"> [图3.3]</p><p>　　3、在Variables里查看，这里显示当前方法里的所有变量。</p><p> 　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905155339491-1166069157.png" alt="img"> [图3.4]</p><p>　　4、在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905160057038-750351531.png" alt="img"> [图3.5]</p><p>　　如果你发现你没有Watches，可能在下图所在的地方。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905160433710-2004658473.png" alt="img"> [图3.6] </p><p>　  <img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905160515538-1647769062.png" alt="img"> [图3.7]</p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a>四、计算表达式</h2><p>　　在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905160826444-1625048711.png" alt="img"> [图4.1]</p><p>　　1、按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。</p><p>　　　 这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905161614694-93470669.png" alt="img"> [图4.2]</p><p>　　2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了不是。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905162404288-824548249.png" alt="img"> [图4.3]</p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a>五、智能步入</h2><p>　　想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。</p><p>　　那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905152523304-803289488.png" alt="img"> [图5.1]</p><p>　　按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法，如图5.2，点击方法进入方法内部。</p><p>　　如果只有一个方法，则直接进入，类似Force Step Into。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905163730929-1374653206.png" alt="img"> [图5.2]</p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a>六、断点条件设置</h2><p>　　通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>　　通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p><p>　　1、在断点上右键直接设置当前断点的条件，如图6.1，我设置exist为true时断点才生效。</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905165253944-1162138475.png" alt="img"> [图6.1]</p><p>　　2、点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</p><p>　　　　Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</p><p>　　　　勾选Log message to console，则会将当前断点行输出到控制台，如图6.3</p><p>　　　　勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。</p><p>　　 [图6.2]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905170655163-1805982960.png" alt="img"></p><p>　　 [图6.3]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905170947257-1667065155.png" alt="img"></p><p>　　3、再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。</p><p>　　　　Instance filters：实例过滤，输入实例ID(如图6.5中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。</p><p>　　　　Class filters：类过滤，根据类名过滤，同样没有成功….</p><p>　　　　Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p><p>　　[图6.4]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905185247132-1922055922.png" alt="img"> </p><p>　　 [图6.5]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905190253304-1057381593.png" alt="img"></p><p>　　4、异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p>　　如图6.6，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。</p><p>　　我这里添加了一个NullPointerException异常断点，如图6.8，出现空指针异常后，自动定位在空指针异常行。</p><p> 　[图6.6]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905200131851-150143203.png" alt="img"></p><p>　　[图6.7]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905200305147-527881101.png" alt="img"> </p><p>　　[图6.8]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905200726069-688175303.png" alt="img"> </p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a>七、多线程调试</h2><p>　　一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p><p>　　那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图7.1，然后点击Make Default设置为默认选项。</p><p>　　[图7.1]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905204329757-1196950664.png" alt="img"> </p><p>　　切换线程，在图7.2中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。</p><p>　　[图7.2]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905205012663-56609868.png" alt="img"> </p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a>八、回退断点</h2><p>　　在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p><p>　　1、首先认识下这个方法调用栈，如图8.1，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p><p>　　[图8.1]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905210917741-1095775464.png" alt="img"> </p><p>　　2、断点回退</p><p>　　所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p><p>　　回退的方式有两种，一种是Drop Frame按钮(图8.2)，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，如图8.3)。</p><p>　　第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame(图8.4)，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。</p><p>　　但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数&#x2F;数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</p><p>　　图[8.2]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905211428554-1617570377.png" alt="img"></p><p>　　图[8.3]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905211723304-1223322879.png" alt="img"></p><p>　　图[8.4]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905212138101-113776159.png" alt="img"></p><p><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html#_labelTop">回到顶部</a></p><h2 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a>九、中断Debug</h2><p>　　想要在Debug的时候，中断请求，不要再走剩余的流程了？</p><p>　　有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p><p>　　确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程，如图9.1。</p><p>　　点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p><p>　　[图9.1]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905213656241-1998475384.png" alt="img"></p><p>　　[图9.2]</p><p>　　<img src="https://images2017.cnblogs.com/blog/856154/201709/856154-20170905214031397-1943297392.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆节闲记二</title>
      <link href="/2017/10/03/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%BA%8C/"/>
      <url>/2017/10/03/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前各种环境都装在阿里云上，乘着国庆假期，各种环境安装到mac上，记录一笔先，后续有坑，填坑</p></blockquote><p>之前安装好的</p><ul><li><p><input checked="" disabled="" type="checkbox"> mongo</p></li><li><p><input checked="" disabled="" type="checkbox"> nginx</p></li><li><p><input checked="" disabled="" type="checkbox"> mysql</p></li><li><p>tomcat</p></li></ul><p>查看帮助</p><pre><code>    catalina -h </code></pre><p>启动tomcat</p><pre><code>    catalina run / start</code></pre><p>关闭tomcat</p><pre><code>    catalina stop</code></pre><ul><li>ActiveMQ</li></ul><p>启动</p><pre><code>    acivemq start</code></pre><p>关闭</p><pre><code>    activemq stop        </code></pre><ul><li>zookeeper</li></ul><p>启动</p><pre><code>    zkServer start</code></pre><p>停止</p><pre><code>    zkServer stop</code></pre><p>查询状态</p><pre><code>    zkServer status</code></pre><ul><li>kafka</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆节闲记一</title>
      <link href="/2017/10/02/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%B8%80/"/>
      <url>/2017/10/02/%E6%9D%82%E8%AE%B0/%E5%9B%BD%E5%BA%86%E8%8A%82%E9%97%B2%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>国庆节了，也感觉有忙不完的事情，拿了本书回来，还没有怎么读，虽然是很早计划读完的书，到今天第一章还未读完。200多页，希望国庆内读完吧。</p></blockquote><p>晓说这个节目应该是洗澡节目吧，洗澡时，必听。。。今天在笔记本上看到三季的最新一期，于是书单里又要新增2本书了：</p><ul><li>《三体》 好吧，虽然是很早就想看的书，比重排名更往前了；</li></ul><blockquote><p><a href="https://www.amazon.cn/%E4%B8%89%E4%BD%93-%E5%88%98%E6%85%88%E6%AC%A3/dp/B00OB3SNMY/ref=sr_1_1?ie=UTF8&qid=1506958531&sr=8-1&keywords=%E4%B8%89%E4%BD%93">三体</a></p></blockquote><ul><li>《Story》</li></ul><blockquote><p><a href="https://www.amazon.cn/Story-Style-Structure-Substance-and-the-Principles-of-Screenwriting-Mckee-Robert/dp/0060391685/ref=sr_1_2?ie=UTF8&qid=1506958398&sr=8-2&keywords=robert+mckee">Story: Substance, Structure, Style and the Principles of Screenwriting</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes概览</title>
      <link href="/2017/09/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Kubernetes%E6%A6%82%E8%A7%88/"/>
      <url>/2017/09/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Kubernetes%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>这是一篇 Kubernetes 的概览。</p><p>Kubernetes 是一个<a href="http://www.slideshare.net/BrianGrant11/wso2con-us-2015-kubernetes-a-platform-for-automating-deployment-scaling-and-operations">自动化部署、伸缩和操作应用程序容器的开源平台</a>。</p><p>使用 Kubernetes，你可以快速、高效地满足用户以下的需求：</p><ul><li>快速精准地部署应用程序</li><li>即时伸缩你的应用程序</li><li>无缝展现新特征</li><li>限制硬件用量仅为所需资源</li></ul><p>我们的目标是培育一个工具和组件的生态系统，以减缓在公有云或私有云中运行的程序的压力。</p><h4 id="Kubernetes-的优势"><a href="#Kubernetes-的优势" class="headerlink" title="Kubernetes 的优势"></a>Kubernetes 的优势</h4><ul><li><strong>可移动</strong>: 公有云、私有云、混合云、多态云</li><li><strong>可扩展</strong>: 模块化、插件化、可挂载、可组合</li><li><strong>自修复</strong>: 自动部署、自动重启、自动复制、自动伸缩</li></ul><p>Google 公司于 2014 年启动了 Kubernetes 项目。Kubernetes 是在 <a href="https://research.google.com/pubs/pub43438.html">Google 的长达 15 年的成规模的产品级任务的经验下</a>构建的，结合了来自社区的最佳创意和实践经验。</p><h3 id="为什么选择容器"><a href="#为什么选择容器" class="headerlink" title="为什么选择容器?"></a>为什么选择容器?</h3><p>想要知道你为什么要选择使用 <a href="https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/">容器</a>?</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201708/22/115217h7sbftbcbb8fby6u.jpg" alt="img"></p><p>程序部署的<em>传统方法</em>是指通过操作系统包管理器在主机上安装程序。这样做的缺点是，容易混淆程序之间以及程序和主机系统之间的可执行文件、配置文件、库、生命周期。为了达到精准展现和精准回撤，你可以搭建一台不可变的虚拟机镜像。但是虚拟机体量往往过于庞大而且不可转移。</p><p>容器部署的<em>新的方式</em>是基于操作系统级别的虚拟化，而非硬件虚拟化。容器彼此是隔离的，与宿主机也是隔离的：它们有自己的文件系统，彼此之间不能看到对方的进程，分配到的计算资源都是有限制的。它们比虚拟机更容易搭建。并且由于和基础架构、宿主机文件系统是解耦的，它们可以在不同类型的云上或操作系统上转移。</p><p>正因为容器又小又快，每一个容器镜像都可以打包装载一个程序。这种一对一的“程序 - 镜像”联系带给了容器诸多便捷。有了容器，静态容器镜像可以在编译&#x2F;发布时期创建，而非部署时期。因此，每个应用不必再等待和整个应用栈其它部分进行整合，也不必和产品基础架构环境之间进行妥协。在编译&#x2F;发布时期生成容器镜像建立了一个持续地把开发转化为产品的环境。相似地，容器远比虚拟机更加透明，尤其在设备监控和管理上。这一点，在容器的进程生命周期被基础架构管理而非被容器内的进程监督器隐藏掉时，尤为显著。最终，随着每个容器内都装载了单一的程序，管理容器就等于管理或部署整个应用。</p><p>容器优势总结：</p><ul><li><strong>敏捷的应用创建与部署</strong>：相比虚拟机镜像，容器镜像的创建更简便、更高效。</li><li><strong>持续的开发、集成，以及部署</strong>：在快速回滚下提供可靠、高频的容器镜像编译和部署（基于镜像的不可变性）。</li><li><strong>开发与运营的关注点分离</strong>：由于容器镜像是在编译&#x2F;发布期创建的，因此整个过程与基础架构解耦。</li><li><strong>跨开发、测试、产品阶段的环境稳定性</strong>：在笔记本电脑上的运行结果和在云上完全一致。</li><li><strong>在云平台与 OS 上分发的可转移性</strong>：可以在 Ubuntu、RHEL、CoreOS、预置系统、Google 容器引擎，乃至其它各类平台上运行。</li><li><strong>以应用为核心的管理</strong>: 从在虚拟硬件上运行系统，到在利用逻辑资源的系统上运行程序，从而提升了系统的抽象层级。</li><li><strong>松散耦联、分布式、弹性、无拘束的微服务</strong>：整个应用被分散为更小、更独立的模块，并且这些模块可以被动态地部署和管理，而不再是存储在大型的单用途机器上的臃肿的单一应用栈。</li><li><strong>资源隔离</strong>：增加程序表现的可预见性。</li><li><strong>资源利用率</strong>：高效且密集。</li></ul><h4 id="为什么我需要-Kubernetes，它能做什么"><a href="#为什么我需要-Kubernetes，它能做什么" class="headerlink" title="为什么我需要 Kubernetes，它能做什么?"></a>为什么我需要 Kubernetes，它能做什么?</h4><p>至少，Kubernetes 能在实体机或虚拟机集群上调度和运行程序容器。而且，Kubernetes 也能让开发者斩断联系着实体机或虚拟机的“锁链”，从<strong>以主机为中心</strong>的架构跃至<strong>以容器为中心</strong>的架构。该架构最终提供给开发者诸多内在的优势和便利。Kubernetes 提供给基础架构以真正的<strong>以容器为中心</strong>的开发环境。</p><p>Kubernetes 满足了一系列产品内运行程序的普通需求，诸如：</p><ul><li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">协调辅助进程</a>，协助应用程序整合，维护一对一“程序 - 镜像”模型。</li><li><a href="https://kubernetes.io/docs/concepts/storage/volumes/">挂载存储系统</a></li><li><a href="https://kubernetes.io/docs/concepts/configuration/secret/">分布式机密信息</a></li><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">检查程序状态</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">复制应用实例</a></li><li><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">使用横向荚式自动缩放</a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/">命名与发现</a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">负载均衡</a></li><li><a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/">滚动更新</a></li><li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/">资源监控</a></li><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">访问并读取日志</a></li><li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/">程序调试</a></li><li><a href="https://kubernetes.io/docs/admin/authorization/">提供验证与授权</a></li></ul><p>以上兼具平台即服务（PaaS）的简化和基础架构即服务（IaaS）的灵活，并促进了在平台服务提供商之间的迁移。</p><h4 id="Kubernetes-是一个什么样的平台"><a href="#Kubernetes-是一个什么样的平台" class="headerlink" title="Kubernetes 是一个什么样的平台?"></a>Kubernetes 是一个什么样的平台?</h4><p>虽然 Kubernetes 提供了非常多的功能，总会有更多受益于新特性的新场景出现。针对特定应用的工作流程，能被流水线化以加速开发速度。特别的编排起初是可接受的，这往往需要拥有健壮的大规模自动化机制。这也是为什么 Kubernetes 也被设计为一个构建组件和工具的生态系统的平台，使其更容易地部署、缩放、管理应用程序。</p><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标签</a>label可以让用户按照自己的喜好组织资源。 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>annotation让用户在资源里添加客户信息，以优化工作流程，为管理工具提供一个标示调试状态的简单方法。</p><p>此外，<a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes 控制面板</a>是由开发者和用户均可使用的同样的 <a href="https://kubernetes.io/docs/reference/api-overview/">API</a> 构建的。用户可以编写自己的控制器，比如 <a href="https://git.k8s.io/community/contributors/devel/scheduler.md">调度器</a>scheduler，使用可以被通用的<a href="https://kubernetes.io/docs/user-guide/kubectl-overview/">命令行工具</a>识别的<a href="https://git.k8s.io/community/contributors/design-proposals/extending-api.md">他们自己的 API</a>。</p><p>这种<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/principles.md">设计</a>让大量的其它系统也能构建于 Kubernetes 之上。</p><h4 id="Kubernetes-不是什么？"><a href="#Kubernetes-不是什么？" class="headerlink" title="Kubernetes 不是什么？"></a>Kubernetes 不是什么？</h4><p>Kubernetes 不是传统的、全包容的平台即服务（Paas）系统。它尊重用户的选择，这很重要。</p><p>Kubernetes：</p><ul><li>并不限制支持的程序类型。它并不检测程序的框架 (例如，<a href="http://wildfly.org/">Wildfly</a>)，也不限制运行时支持的语言集合 (比如， Java、Python、Ruby)，也不仅仅迎合 <a href="https://12factor.net/">12 因子应用程序</a>，也不区分 <em>应用</em> 与 <em>服务</em> 。Kubernetes 旨在支持尽可能多种类的工作负载，包括无状态的、有状态的和处理数据的工作负载。如果某程序在容器内运行良好，它在 Kubernetes 上只可能运行地更好。</li><li>不提供中间件（例如消息总线）、数据处理框架（例如 Spark）、数据库（例如 mysql），也不把集群存储系统（例如 Ceph）作为内置服务。但是以上程序都可以在 Kubernetes 上运行。</li><li>没有“点击即部署”这类的服务市场存在。</li><li>不部署源代码，也不编译程序。持续集成 (CI) 工作流程是不同的用户和项目拥有其各自不同的需求和表现的地方。所以，Kubernetes 支持分层 CI 工作流程，却并不监听每层的工作状态。</li><li>允许用户自行选择日志、监控、预警系统。（ Kubernetes 提供一些集成工具以保证这一概念得到执行）</li><li>不提供也不管理一套完整的应用程序配置语言&#x2F;系统（例如 <a href="https://github.com/google/jsonnet">jsonnet</a>）。</li><li>不提供也不配合任何完整的机器配置、维护、管理、自我修复系统。</li></ul><p>另一方面，大量的 PaaS 系统运行<em>在</em> Kubernetes 上，诸如 <a href="https://www.openshift.org/">Openshift</a>、<a href="http://deis.io/">Deis</a>，以及 <a href="http://eldarion.cloud/">Eldarion</a>。你也可以开发你的自定义 PaaS，整合上你自选的 CI 系统，或者只在 Kubernetes 上部署容器镜像。</p><p>因为 Kubernetes 运营在应用程序层面而不是在硬件层面，它提供了一些 PaaS 所通常提供的常见的适用功能，比如部署、伸缩、负载平衡、日志和监控。然而，Kubernetes 并非铁板一块，这些默认的解决方案是可供选择，可自行增加或删除的。</p><p>而且， Kubernetes 不只是一个<em>编排系统</em> 。事实上，它满足了编排的需求。 <em>编排</em> 的技术定义是，一个定义好的工作流程的执行：先做 A，再做 B，最后做 C。相反地， Kubernetes 囊括了一系列独立、可组合的控制流程，它们持续驱动当前状态向需求的状态发展。从 A 到 C 的具体过程并不唯一。集中化控制也并不是必须的；这种方式更像是<em>编舞</em>。这将使系统更易用、更高效、更健壮、复用性、扩展性更强。</p><h4 id="Kubernetes-这个单词的含义？k8s？"><a href="#Kubernetes-这个单词的含义？k8s？" class="headerlink" title="Kubernetes 这个单词的含义？k8s？"></a>Kubernetes 这个单词的含义？k8s？</h4><p><strong>Kubernetes</strong> 这个单词来自于希腊语，含义是 <em>舵手</em> 或 <em>领航员</em> 。其词根是 <em>governor</em> 和 <a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>。 <em>K8s</em> 是它的缩写，用 8 字替代了“ubernete”。</p><hr><p>via: <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></p><p>作者：<a href="https://kubernetes.io/">kubernetes.io</a> 译者：<a href="https://github.com/songsuhang00">songshuang00</a> 校对：<a href="https://github.com/wxy">wxy</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9新特性解读</title>
      <link href="/2017/09/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/>
      <url>/2017/09/24/java/%20Java%209%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<em>杨晓峰</em> <a href="http://mp.weixin.qq.com/s/Onj9ZJYbV5pLTAPcYBJREA##">InfoQ</a></p></blockquote><p>在历经多次跳票之后，Java 9 终于在千呼万唤中正式发布。从这个版本开始，Java 将每半年发布一个版本。作为霸占编程语言排行榜鳌头多年的老牌语言，Java 9 中有哪些不得不说的新特性？Java 语言的未来又将如何？</p><blockquote><p>针对 Java 9 新特性的介绍已经非常多了，我这里不想再做一个百科全书一样的列表，希望从不同角度简要点评部分特性。</p></blockquote><p>Jigsaw</p><p>首先，谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目，这是一个雄心勃勃的项目。</p><p>大家知道，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越来越暴露出一些问题，比如 Java 运行环境的膨胀和臃肿，各种类库和工具在提供强大功能的同时，也越来越复杂，不同版本的类库交叉依赖导致 Jar Hell 等让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</p><p>但是由于兼容性等各方面的掣肘，对 Java 进行大刀阔斧的革新越来越困难，Jigsaw 从 Java 7 阶段就开始筹备，Java 8 阶段进行了大量工作，终于在 Java 9 里落地，有种千呼万唤始出来的意味。</p><p>Jigsaw 项目的目标是改进 Java SE 平台，使其可以适应不同大小的计算设备；改进其安全性，可维护性，提高性能；简化各种类库和大型应用的开发和维护。</p><p>这个项目的工作量和难度大大超出了初始规划。JSR 376 Java 平台模块化系统（JPMS, Java Platform Module System）作为 Jigsaw 项目的核心, 其主体部分被分解成 6 个 JEP(JDK Enhancement Proposals)</p><ul><li>200: The Modular JDK</li><li>201: Modular Source Code</li><li>220: Modular Run-Time Images</li><li>260: Encapsulate Most Internal APIs</li><li>261: Module System</li><li>282: jlink: The Java Linker</li></ul><p>可以看到这是一个庞大的系统工程，Java 的方方面面，包括 JDK 编译工具，运行时，Java 公共 API 和私有代码等等，完全是一个整体性的改变。</p><p>随着 Java 平台模块化系统的落地，开发人员无需再为不断膨胀的 Java 平台苦恼，例如，您可以使用 jlink 工具，根据需要定制运行时环境。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。</p><p>从软件开发实践的角度，Java 语言层面提供对模块的支持，可以鼓励（当然在某种程度上也可以看作强制）更加规范的开发实践，利用业界在开发领域几十年的经验、教训总结出的最佳实践，促进 Java 生态的健康发展。比如，更加完善的隐藏实现细节，这不仅可以促进面向接口、约定的编程，也可以避免可能的安全风险等。</p><p>不过，换个角度来说，天下没有免费的午餐，由于 JPMS 是语言平台层面的支持，它并不是完全透明的，也就是说不管用户是否真的需要或从中收益，都会或多或少的受其影响。</p><p>对此，我们可以从 JPMS 评审中针对类似深度反射限制之类的激烈争吵中，深刻体会到。比如，针对反射访问控制，最终 Java 9 开发团队，采取了相对折中的办法，在反射领域默认保持 Java 8 的默认行为。Java 9 在兼容性方面，相比于过往的版本，采取了更大的容忍度。</p><p>不过，Java 9 的相当一部分特性仍然是对用户透明的。只要升级到 Java 9，不需要或者很少需要用户参与动作就能获益。比如，更加紧凑的字符串实现；改进的竞争锁机制；改进安全应用性能 ；利用特定 CPU 指令优化 GHASH 和 RSA 等等，这些都是开箱即用、触手可得的改进。</p><p>Java 9 值得关注的新特性</p><p>对于部分开发者来说，探究 Java 内部 API 或者平台底层能力是一件非常酷的事情，但这往往并不是非常容易，比如部分能力可能并没有在历史版本的公共 API 中暴露出来（比如 Unsafe 相关），或者需要特定领域的知识。在 Java 9 中，不要错过 JEP 193: Variable Handles 和 JEP 274: Enhanced Method Handles，JEP 259: Stack-Walking API，JEP 285: Spin-Wait Hints 等特性。</p><p>另外，Java 9 中还有很多承上启下的特性，为未来创新打下基础或者整合、规范现有碎片化的功能，我会介绍一些有代表性的新特性。</p><p>在 Java 虚拟机领域，JEP 271: Unified GC Logging 和 JEP 158：Unified JVM Logging，对各种 JVM 日志进行了统一，大家终于不用为各种碎片化的日志选项苦恼了。</p><p>Oracle 一直在努力提高 Java 启动和运行时性能，希望其能够在更广泛的场景达到或接近本地语言的性能。但是，直到今天，谈到 Java，很多 C&#x2F;C++ 开发者还是会不屑地评价为启动慢，吃内存。</p><p>简单说，这主要是因为 Java 编译产生的类文件是 Java 虚拟机可以理解的二进制代码，而不是真正的可执行的本地代码，需要 Java 虚拟机进行解释和编译，这带来了额外的开销。</p><p>JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，但是实际应用可能非常庞大，大型 Java 应用的预热往往非常耗时，而且非热点代码可能根本没有机会被 JIT 编译。</p><p>在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件，这样会大大降低启动开销。</p><p>另外 JVMCI （JEP 243: Java-Level JVM Compiler Interface）等特性，对于整个编程语言的发展，可能都具有非常重要的意义，虽然未必引起了广泛关注。目前 Graal Core API 已经被集成进入 Java 9，虽然还只是初始一小步，但是完全用 Java 语言来实现的可靠的、高性能的动态编译器，似乎不再是遥不可及，这是 Java 虚拟机开发工程师的福音。</p><p>与此同时，随着 Truffle 框架和 Substrate VM 的发展，已经让个别信心满满的工程师高呼“One VM to Rule Them All!”， 也许就在不远的将来 Ploygot 以一种另类的方式成为现实。</p><p>谈谈 Java 的未来</p><p>前面简短地谈了谈 Java 9 中的一些令人激动的特性，Java 9 在取得这些进步的同时，那么在其的研发过程中有哪些教训，当前和未来遇到了那些挑战呢？</p><p>首先，就是如何更加快速、敏捷地进行创新。在 Java 9 的开发过程中, 非常突出的一点就是，由于 Jigsaw 项目的延期，导致 Java 9 的发布一再推迟，这带来了很多负面影响。大批特性已经完成多时，却无法及时被实际应用采纳，开发者无法及时地从中获益，也很难尽早发现和反馈可能存在的问题或改进。这不禁让人反思 Java 传统的研发模式的局限性。</p><p>针对这些情况，Java 首席架构师 Mark Reinhold 已经发出倡议，建议从传统的以特性驱动的发布周期，转变为以时间驱动的（6 个月为周期）发布模式，并逐步的将 Oracle JDK 原有商业特性进行开源，Java Flight Recorder 等杀手级工具和特性，一定会大受开发者的欢迎。针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term support）。</p><p>第二，随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。传统的大型企业或互联网应用，正在被云端，容器化应用、模块化的微服务甚至是函数（FaaS， Function-as-a-Service）所替代。</p><p>Java 需要在新的计算场景下，改进开发效率。这话说的有点笼统，我谈一些自己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向，例如，JEP 286: Local-Variable Type Inference；持续改进并发计算框架，Java 的并发特性非常强大和系统，但某种程度上过于复杂，在今年的 JVMLS 上，阿里巴巴 AJDK 组介绍了利用协程改进并发的实践，这是一个令人眼前一亮的创新；Java 非常需要更加友好的本地代码支持，相关的特性有很多好的想法和尝试，比如 Panama 项目；Value Types 和改进的泛型，有兴趣可以参考 Valhalla 项目。</p><p>最后，进一步改进启动和运行性能、优化计算资源使用。目前，相当一部分的 Java 类库和虚拟机特性都是针对长时间、大数据量、高并发等复杂任务进行的优化，但是在部分云计算场景中，比如越来越引起大家关注的 FaaS 应用，短时间、无状态的函数正在成为常见的计算单元。那么在这种场景下，Java 必须进行相应的改进和创新，才能保持和强化目前在软件开发领域的竞争力。比如，提高 Java 运行时启动速度，尤其是在容器环境的初始化表现；保证 CPU 等计算资源调度能力能够适应容器环境的新情况，最直接的就是 Java 平台需要支持基于 cgroup 等技术的资源管理；针对新场景下的 GC 优化；如何提高数据密度和计算效率等等。</p><p>以上很多方面往往不是孤立的，也不是非常简单就可以完成的，很多改进都是依赖于相关语言基础技术的进步和突破，Java 的进步需要持之以恒的耐心和持续的努力与投入。</p><blockquote><p>我们再来看看java成立到现在的所有版本。</p></blockquote><p>    1990年初，最初被命名为Oak；</p><p>    1995年5月23日，Java语言诞生；</p><p>    1996年1月，第一个JDK-JDK1.0诞生；</p><p>    1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术；</p><p>    1996年9月，约8.3万个网页应用了Java技术来制作；</p><p>    1997年2月18日，JDK1.1发布；</p><p>    1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议纪录；</p><p>    1997年9月，JavaDeveloperConnection社区成员超过十万；</p><p>    1998年2月，JDK1.1被下载超过2,000,000次；</p><p>    1998年12月8日，Java 2企业平台J2EE发布；</p><p>    1999年6月，SUN公司发布Java三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）；</p><p>    2000年5月8日，JDK1.3发布；</p><p>    2000年5月29日，JDK1.4发布；</p><p>    2001年6月5日，Nokia宣布到2003年将出售1亿部支持Java的手机；</p><p>    2001年9月24日，J2EE1.3发布；</p><p>    2002年2月26日，J2SE1.4发布，此后Java的计算能力有了大幅提升；</p><p>    2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0；</p><p>    2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME；</p><p>    2006年12月，SUN公司发布JRE6.0；</p><p>    2009年4月20日，甲骨文以74亿美元的价格收购SUN公司，取得java的版权，业界传闻说这对Java程序员是个坏消息（其实恰恰相反）；</p><p>    2010年11月，由于甲骨文对Java社区的不友善，因此Apache扬言将退出JCP；</p><p>    2011年7月28日，甲骨文发布Java SE 7；</p><p>    2014年3月18日，甲骨文发表Java SE 8；</p><p>    2017年7月，甲骨文发表Java SE 9。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc总结</title>
      <link href="/2017/09/16/java/%20springmvc%E6%80%BB%E7%BB%93/"/>
      <url>/2017/09/16/java/%20springmvc%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>温故而知新，今天一起来复习一下spring mvc的内容吧。</p><blockquote><p>spring mvc简介与运行原理</p></blockquote><p>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-9409cf62de5e6d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理.png"></p><ul><li>(1) Http请求：客户端请求提交到DispatcherServlet。</li><li>(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</li><li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。</li><li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。</li><li>(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。</li><li>(8) Http响应：视图负责将结果显示到客户端。</li></ul><blockquote><p>主要注解</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4120002-59a5ee861a98c9e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spring mvc注解.png"></p><blockquote><p>ContextLoaderListener</p></blockquote><p><em>在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。</em></p><ul><li>一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。</li><li>当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param &gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet。（同类多个节点以出现顺序依次加载）</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-746980d0ad376d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web.xml加载过程.png"></p><p><em>而spring mvc启动过程大致分为两个过程：</em></p><ul><li>ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。</li><li>DispatcherServlet初始化。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-110e7ed9ccd22461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web.xml配置.png"></p><p>其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。</p><ul><li><em>ContextLoaderListener在web.xml中的配置</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置contextConfigLocation初始化参数 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置ContextLoaderListerner --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ServletContextListener 接口有两个方法:contextInitialized,contextDestroyed</p><blockquote><p>DispatcherServlet</p></blockquote><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。</p><p>下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。</p><ul><li><em>流程图</em></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4120002-635b0216e6e74921.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spring mvc处理请求的流程.jpg"></p><ul><li><em>在web.xml中的配置</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中</p><ul><li>load-on-startup：表示启动容器时初始化该Servlet；</li><li>url-pattern：表示哪些请求交给Spring Web MVC处理， “&#x2F;” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。</li></ul><p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。</p><p>WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）</p><p><img src="https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/publish/21-2/figures/figure-21-2-typical-context-hierarchy-in-spring-web-mvc.png" alt="DispatcherServlet继承结构"></p><p>spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-d2cafcce5381cd66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特殊bean.png"></p><p>其中，常用的ViewResolver的配置。以jsp作为视图为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对模型视图名称的解析,即在模型视图名称添加前后缀 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置上传文件限制MultipartResolver</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 上传限制 --&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">     &lt;!-- 上传文件大小限制为31M，31*1024*1024 --&gt;</span><br><span class="line">     &lt;property name=&quot;maxUploadSize&quot; value=&quot;32505856&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>applicationContext.xml中的标签</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4120002-7022162217045a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="applicationContext.xml配置文件标签.png"></p><blockquote><p>文件上传</p></blockquote><p>前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。</p><ul><li><em>表单</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;/form&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;</span><br><span class="line">     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">     &lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><em>控制器</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path = &quot;/form&quot;, method = RequestMethod.POST)</span><br><span class="line"> public String handleFormUpload(@RequestParam(&quot;name&quot;) String name, </span><br><span class="line">            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line"></span><br><span class="line">   if (!file.isEmpty()) &#123;</span><br><span class="line">          byte[] bytes = file.getBytes();</span><br><span class="line">          // store the bytes somewhere</span><br><span class="line">          return &quot;redirect:uploadSuccess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;redirect:uploadFailure&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>异常处理</p></blockquote><p>先来说下常见的异常处理有几种方式，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4120002-e9a87d75a1e94c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常处理方式.png"></p><p>Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。</p><p>某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。</p><ul><li><em>HandlerExceptionResolver 提供resolveException接口</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerExceptionResolver &#123;  </span><br><span class="line">    ModelAndView resolveException(  </span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><em>在BaseController中使用 @ExceptionHandler注解处理异常</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(Exception.class)</span><br><span class="line">public Object exceptionHandler(Exception ex, HttpServletResponse response, </span><br><span class="line">             HttpServletRequest request) throws IOException &#123;</span><br><span class="line">String url = &quot;&quot;;</span><br><span class="line">String msg = ex.getMessage();</span><br><span class="line">Object resultModel = null;</span><br><span class="line">try &#123;</span><br><span class="line">if (ex.getClass() == HttpRequestMethodNotSupportedException.class) &#123;</span><br><span class="line">url = &quot;admin/common/500&quot;;</span><br><span class="line">System.out.println(&quot;--------毛有找到对应方法---------&quot;);</span><br><span class="line">&#125; else if (ex.getClass() == ParameterException.class) &#123;//自定义的异常</span><br><span class="line">                               </span><br><span class="line">&#125; else if (ex.getClass() == UnauthorizedException.class) &#123;</span><br><span class="line">url = &quot;admin/common/unauth&quot;;</span><br><span class="line">System.out.println(&quot;--------毛有权限---------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String header = req.getHeader(&quot;X-Requested-With&quot;);</span><br><span class="line">boolean isAjax = &quot;XMLHttpRequest&quot;.equalsIgnoreCase(header);</span><br><span class="line">String method = req.getMethod();</span><br><span class="line">boolean isPost = &quot;POST&quot;.equalsIgnoreCase(method);</span><br><span class="line"></span><br><span class="line">if (isAjax || isPost) &#123;</span><br><span class="line">return Message.error(msg);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ModelAndView view = new ModelAndView(url);</span><br><span class="line">view.addObject(&quot;error&quot;, msg);</span><br><span class="line">view.addObject(&quot;class&quot;, ex.getClass());</span><br><span class="line">view.addObject(&quot;method&quot;, request.getRequestURI());</span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception exception) &#123;</span><br><span class="line">logger.error(exception.getMessage(), exception);</span><br><span class="line">return resultModel;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">logger.error(msg, ex);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>*在web.xml中处理异常 *</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 默认的错误处理页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">&lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">&lt;location&gt;/403.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">&lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">&lt;location&gt;/404.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&gt;</span><br><span class="line">&lt;!-- 这样配置也是可以的，表示发生500错误的时候，转到500.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;error-code&gt;500&lt;/error-code&gt; </span><br><span class="line">&lt;location&gt;/500.html&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; </span><br><span class="line">&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"></span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; </span><br><span class="line">&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 当error-code和exception-type都配置时，exception-type配置的页面优先级高及出现500错误，发生异常Exception时会跳转到500.jsp--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>来一个问题：HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？</li></ul><p><em>解答</em>：如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： ** return a corresponding ModelAndView to forward to, or null for default processing.**</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh 设置别名的方式访问服务器</title>
      <link href="/2017/09/07/%E5%B7%A5%E5%85%B7/%20ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/09/07/%E5%B7%A5%E5%85%B7/%20ssh%20%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Windows上时，一般通过各种客户端(putty、SecureCRT等)连接到远程服务器，而切换到了Mac上，有了强大的终端，自然要好好用起来了。<span id="more"></span> 一般在终端上通过 ssh 命令进行远程服务器登录。</p></blockquote><h3 id="远程登录服务器命令-ssh"><a href="#远程登录服务器命令-ssh" class="headerlink" title="远程登录服务器命令 ssh"></a>远程登录服务器命令 ssh</h3><ul><li>ssh username@ip地址</li></ul><p>例如： ssh <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#x31;&#x2e;&#50;">&#x72;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#x31;&#x2e;&#50;</a></p><p>but 服务端一般多台服务器，好几个ip地址，记住这么多ip地址好难，但是根据不同服务器的用途给他们起个别名，就方便多了，能想到自然能实现，这里简述下具体玩法~</p><h3 id="给服务器起个别名"><a href="#给服务器起个别名" class="headerlink" title="给服务器起个别名"></a>给服务器起个别名</h3><ol><li><p>在 <code>~/.ssh/</code> 目录下，新建一个config（有的话，就不用建了噻）</p></li><li><p>vim config 文件，进行编辑</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host dev</span><br><span class="line">HostName xxx.xx.xx.xx</span><br><span class="line">User root</span><br><span class="line">IdentitiesOnly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ul><li>Host 别名 起一个自己记得住的，比如开发环境 dev 测试环境 test  ..</li><li>HostName 服务器的ip address    </li><li>User 远程登录的用户名</li><li>IdentitiesOnly yes 反正这个就配置yes</li></ul><h3 id="ssh-别名-走起"><a href="#ssh-别名-走起" class="headerlink" title="ssh 别名 走起"></a>ssh 别名 走起</h3><p>配置好文件后，直接 键入 ssh dev 就玩起来了</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 开发常用的终端命令</title>
      <link href="/2017/09/06/%E5%89%8D%E7%AB%AF/%20web%20%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/09/06/%E5%89%8D%E7%AB%AF/%20web%20%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-开发常用的终端命令"><a href="#Web-开发常用的终端命令" class="headerlink" title="Web 开发常用的终端命令"></a>Web 开发常用的终端命令</h2><p>终端是开发人员的军火库中最重要的生产力工具之一。把它掌握好了可以对你的工作产生非常积极的影响。</p><p>这里记录一些常用到的命令</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><a href="https://curl.haxx.se/">curl</a></h2><p>curl 是一个命令行工具，用来通过 HTTP（s），FTP 等其它几十种你可能尚未听说过的协议来发起网络请求。它可以下载文件，检查响应消息头以及方便地访问远程数据。</p><p>在 Web 开发中， curl 经常被用来测试连接，还有调用 REST 风格的 API。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fetch the headers of a URL.</span></span><br><span class="line">curl -I http://google.com</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Referrer-Policy: no-referrer</span><br><span class="line">Location: http://www.google.com/?gfe_rd=cr&amp;ei=0fCKWe6HCZTd8AfCoIWYBQ</span><br><span class="line">Content-Length: 258</span><br><span class="line">Date: Wed, 09 Aug 2017 11:24:01 GMT</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request to a remote API.</span></span><br><span class="line">curl http://numbersapi.com/random/trivia</span><br><span class="line">29 is the number of days it takes Saturn to orbit the Sun.</span><br></pre></td></tr></table></figure><p>curl 的用法还可以比这更复杂。它有许多选项可以用来控制消息头，Cookie，身份验证等等这些要素。你可以通过 <a href="https://ec.haxx.se/">Everything curl</a> 这本优秀的电子书来了解更多。</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a><a href="https://www.computerhope.com/unix/tree.htm">tree</a></h2><p>tree 是一个小巧的命令行工具程序，它可以用可视化的效果向你展示一个目录下的文件。它的运行是递归的，会以树的形式遍历每个级别的嵌套关系，并显示出每一级目录。 如此你就可以快速地进行浏览并找到自己想要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">├── fonts</span><br><span class="line">│   ├── glyphicons-halflings-regular.eot</span><br><span class="line">│   ├── glyphicons-halflings-regular.svg</span><br><span class="line">│   ├── glyphicons-halflings-regular.ttf</span><br><span class="line">│   ├── glyphicons-halflings-regular.woff</span><br><span class="line">│   └── glyphicons-halflings-regular.woff2</span><br><span class="line">└── js</span><br><span class="line">    ├── bootstrap.js</span><br><span class="line">    └── bootstrap.min.js</span><br></pre></td></tr></table></figure><p>它还拥有使用一种类正则表达式的模式来对结果集进行过滤的选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree -P <span class="string">&#x27;*.min.*&#x27;</span></span><br><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">├── fonts</span><br><span class="line">└── js</span><br><span class="line">    └── bootstrap.min.js</span><br></pre></td></tr></table></figure><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><a href="https://tmux.github.io/">tmux</a></h2><p>根据维基的描述，tmux 是一个终端复用器，说人话就是，它是一个可以将多个终端连接到单个终端会话的工具。</p><p><img src="https://static.oschina.net/uploads/space/2017/0906/104206_TcXC_2903254.jpg" alt="img"></p><p>一个 tmux 终端带有三个分屏的效果</p><p>它让你可以在一个终端中进行程序之间的切换，添加分屏窗格，还有就是将多个终端连接到同一个会话，使它们保持同步。 当你在远程服务器上工作时，tmux 特别有用，因为它可以让你创建新的选项卡，然后在选项卡之间切换，而无需反反复复的退出然后登录。</p><h2 id="disk-usage-du"><a href="#disk-usage-du" class="headerlink" title="disk usage - du"></a><a href="https://www.computerhope.com/unix/udu.htm">disk usage - du</a></h2><p>运行 du 命令会生成相关文件和有关目录的空间使用情况的报告。它很容易使用，也可以递归地运行，会遍历每个子目录并且返回每个文件的单个大小。<br>du 通常在你发现某个驱动器的空间不足，但不知道是因为什么造成的时候使用。使用此命令可以快速查看每个文件夹所占用的存储空间，从而把耗费存储的大户给找出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running this will show the space usage of each folder in the current directory.</span></span><br><span class="line"><span class="comment"># The -h option makes the report easier to read.</span></span><br><span class="line"><span class="comment"># -s prevents recursiveness and shows the total size of a folder.</span></span><br><span class="line"><span class="comment"># The star wildcard (*) will run du on each file/folder in current directory.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> -sh *</span><br><span class="line"></span><br><span class="line">1.2G    Desktop</span><br><span class="line">4.0K    Documents</span><br><span class="line">40G     Downloads</span><br><span class="line">4.0K    Music</span><br><span class="line">4.9M    Pictures</span><br><span class="line">844K    Public</span><br><span class="line">4.0K    Templates</span><br><span class="line">6.9M    Videos</span><br></pre></td></tr></table></figure><p>还有一个用途类似的命令 <a href="https://www.computerhope.com/unix/udf.htm">df</a>（Disk Free），它会返回关于可用磁盘空间的各种信息（与 du 正好相反）。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a><a href="https://git-scm.com/">git</a></h2><p>git 是迄今为止最流行的版本控制系统。它是现代 Web 开发的指定工具之一，我们根本没办法把它从列表中给删掉。</p><p>尽管有很多的第三方应用和工具可用，但是大多数人还是喜欢通过终端对 git 来进行本地访问。git CLI 真的很强大，可以用来处理那些盘根错节的项目历史。</p><p>如果想了解更多的关于 git 的信息，建议你看看我们的教程“<a href="https://tutorialzine.com/2016/06/learn-git-in-30-minutes">30 分钟学会用 Git</a>”。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a><a href="https://www.computerhope.com/unix/utar.htm">tar</a></h2><p>tar 是用来处理文件压缩的默认 Unix 工具。它能让你快速的将多个文件打成一个包，这样在后续就更加容易存储和移动它们了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf archive.tar file1 file2 file3</span><br></pre></td></tr></table></figure><p>使用 -x 选项可以对现有的 .tar 压缩包进行解压缩操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf archive.tar</span><br></pre></td></tr></table></figure><p>注意大多数其它的格式，像 .zip 和 .rar 这些，都不能使用 tar 来打开，而是需要用其它的像 <a href="https://www.computerhope.com/unix/unzip.htm">unzip</a> 这样的工具来进行操作。</p><p>如今许多的 Unix 系统都运行着一个 tar 的扩展版本 (GNU tar) ，它也还可以执行限定文件大小的压缩操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create compressed gzip archive.</span></span><br><span class="line">tar -czf file.tar.gz inputfile1 inputfile2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract .gz archive.</span></span><br><span class="line">tar -xzf file.tar.gz</span><br></pre></td></tr></table></figure><p>如果你的操作系统并不支持该版本的 tar，还可以使用 <a href="http://www.gzip.org/">gzip</a>, <a href="https://linux.die.net/man/1/zcat">zcat</a> 或者 <a href="https://www.computerhope.com/unix/ucompres.htm">compress</a> 来限制文件压缩包的大小。</p><h2 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a><a href="https://en.wikipedia.org/wiki/Md5sum">md5sum</a></h2><p>Unix 内置了一些像 <a href="https://www.computerhope.com/unix/md5sum.htm">md5sum</a>、<a href="https://en.wikipedia.org/wiki/Sha1sum">sha1sum</a> 这样的命令行工具，它们在编程中有各自的作用，但最重要的是它们可以用来检查文件的完整性。</p><p>譬如，如果你从不受信的网络下载了一个 .iso 文件，这个文件中存在恶意脚本的风险。为了确认这个 .iso 是安全的，你可以生成它的 md5 或者其它摘要信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> ubuntu-16.04.3-desktop-amd64.iso </span><br><span class="line"></span><br><span class="line">0d9fe8e1ea408a5895cbbe3431989295  ubuntu-16.04.3-desktop-amd64.iso</span><br></pre></td></tr></table></figure><p>然后将生成的字符串与原作者提供的（比如 <a href="https://help.ubuntu.com/community/UbuntuHashes">UbuntuHashes</a>）进行比较。</p><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a><a href="http://hisham.hm/htop/">htop</a></h2><p>Htop 是个比内置的 top 任务管理更强大的工具。它提供了带有诸多选项的高级接口用于监控系统进程。</p><p><img src="https://static.oschina.net/uploads/space/2017/0906/104427_IuFg_2903254.jpg" alt="img"></p><p><em>运行中的 htop 任务管理器</em></p><p>虽然 htop 在终端中运行，但它对鼠标操作支持良好。所以使用 htop 的菜单导航、选择进程，以及通过排序和过滤来管理任务都很容易。</p><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a><a href="https://www.computerhope.com/unix/uln.htm">ln</a></h2><p>Unix 里面的链接同 Windows 中的快捷方式类似，允许你快速地访问到一个特定的文件。链接可以通过 ln 命令创建出来，而且可以有两种类型 : 硬的（hard） 或者符号的（symbolic）。每种类型都有不同的属性而且各有其用途 (<a href="https://www.computerhope.com/unix/uln.htm">了解更多</a>)。</p><p>这里有一个示例，展示了使用链接的最常见方式。假如说我们在桌面上有一个目录叫做 <em>Scripts</em>，里面整齐的摆放着我们最常用的 bash 脚本。每次我们想要调用其中的一个脚本的时候，我们会这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Desktop/Scripts/git-scripts/git-cleanup</span><br></pre></td></tr></table></figure><p>显然，这样做并不方便，每次我们都得写绝对路径。其实我们可以创建一个 symlink，将 <em>Scripts</em>  文件夹链接到 <em>&#x2F;usr&#x2F;local&#x2F;bin</em>，这样就能让脚本在所有的目录下面都可以执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s ~/Desktop/Scripts/git-scripts/git-cleanup /usr/local/bin/</span><br></pre></td></tr></table></figure><p>有了这个创建好的 symlink，我们现在就可以简单地通过其名称在任意一个打开的终端中执行脚本了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-cleanup</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a><a href="https://www.ssh.com/ssh/command/">ssh</a></h2><p>使用 ssh 命令，用户可以快速地连接到一个远程主机，然后登录进入其 Unix shell。这就使得通过自己本地机器的终端在服务器上提交指令成为了可能。</p><p>要定位一个连接，你只需要指定正确的 IP 地址或者 url 就行了。在你第一次连接到一台新的服务器的时候，会需要某种形式的认证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><p>如果你需要快速地在服务器上面执行一条命令，但又不想登录，在 url 之后加上一条命令就可以了。命令将会在服务器上执行，而执行结果也会从它那里返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host <span class="built_in">ls</span> /var/www</span><br><span class="line"></span><br><span class="line">some-website.com</span><br><span class="line">some-other-website.com</span><br></pre></td></tr></table></figure><p>你还可以用 SHH 做更多事情，像创建代理或者隧道，用私钥来保护你的连接，传输文件等。在<a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys">这里的一个指南</a>中你可以了解到更多信息。</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a><a href="https://www.computerhope.com/unix/ugrep.htm">grep</a></h2><p>grep 是一个用来在文本中查找字符串的标准 Unix 工具。它可以从一个文件或者直接就是流的形式获取到输入, 通过一个正则表达式来分析内容，然后返回匹配的行。</p><p>该命令在需要对大型文件进行内容过滤的时候非常趁手。下面我们利用 grep 结合 date 命令，来在一个大型的日志文件中进行查找，然后生成一个只包含当天错误日志的新文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Search <span class="keyword">for</span> today<span class="string">&#x27;s date (in format yyyy-mm-dd) and write the results to a new file. </span></span><br><span class="line"><span class="string">grep &quot;$(date +&quot;%Y-%m-%d&quot;)&quot; all-errors-ever.log &gt; today-errors.log</span></span><br></pre></td></tr></table></figure><p>另外一个用来操作字符串的强大工具就是 <a href="https://www.computerhope.com/unix/used.htm">sed</a>。它比起 grep 更加强大 (当然也更加复杂)，可以执行几乎所有的字符串相关的操作任务，包括添加、删除还有替换字符串的内容。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a><a href="https://www.computerhope.com/unix/ualias.htm">alias</a></h2><p>许多的 Unix 命令，包括本文中提到的一些，在你加上许多选项之后，看起来都相当的长了。为了能更加容易记忆，你可以使用 alias 这个 bash 内置的命令来为它们创建一个短别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create an alias for starting a local web server.</span></span><br><span class="line"><span class="built_in">alias</span> server=<span class="string">&quot;python -m SimpleHTTPServer 9000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instead of typing the whole command simply use the alias.</span></span><br><span class="line">server </span><br><span class="line"></span><br><span class="line">Serving HTTP on 0.0.0.0 port 9000 ...</span><br></pre></td></tr></table></figure><p>只要你保持终端一直是打开的状态， 别名就一直会是可用的。如果想永久使用的话，你可以将 alias  命令操作写到你的 .bashrc 文件中去。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2 快捷操作</title>
      <link href="/2017/08/26/%E5%B7%A5%E5%85%B7/%20iTerm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/08/26/%E5%B7%A5%E5%85%B7/%20iTerm2%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些 iTerm2 的常用快捷操作，方便提高效率</p></blockquote><h2 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h2><ul><li>ctrl + a: 到行首</li><li>ctrl + e: 行末</li><li>ctrl + f&#x2F;b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li><li>ctrl + p: 上一条命令，相当于方向键上</li><li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li><li>ctrl + d: 删除当前字符</li><li>ctrl + h: 删除之前的字符</li><li>ctrl + w: 删除光标前的单词</li><li>ctrl + k: 删除到文本末尾</li><li>ctrl + t: 交换光标处文本</li><li>ctrl + u: 删除一行</li><li>⌘ + —&#x2F;+&#x2F;0: 调整字体大小</li><li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li></ul><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul><li>新建窗口：shift + command + d（横向）command + d（竖向）</li><li>关闭窗口：shift + command + w</li><li>前一个窗口：command + &#96;</li><li>后一个窗口：command + ~</li><li>进入窗口 1,2,3：option + command + 编号</li></ul><h2 id="标签页操作"><a href="#标签页操作" class="headerlink" title="标签页操作"></a>标签页操作</h2><ul><li>新建标签页: Command + T</li><li>关闭标签页: Command + W</li><li>前一个标签页: Command + 左方向键，Shift + Command + [</li><li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li><li>进入标签页1，2，3…: Command + 标签页编号</li><li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li></ul><h2 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h2><ul><li>垂直分割: Command + D</li><li>水平分割: Shift + Command + D</li><li>前一个面板: Command + [</li><li>后一个面板: Command + ]</li><li>切换到上&#x2F;下&#x2F;左&#x2F;右面板: Option + Command + 上下左右方向键</li></ul><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ul><li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show&#x2F;hide iTerm2 with a system-wide hotkey 打上勾之后</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + &#x2F;</li><li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h2 id="文本选取"><a href="#文本选取" class="headerlink" title="文本选取"></a>文本选取</h2><p>文本选取有使用鼠标和不使用鼠标两种方式。</p><p>使用鼠标</p><p>默认情况下，选取的文字会自动复制到剪切板，可以使用以下方式进行文本选取：</p><ul><li>常见的点击并拖拽方式</li><li>双击选取整个单词</li><li>三击选取整行</li><li>选取某一部分，按住Shift，再点击某处，可以选取整个矩形内的文本（类似Windows下按住Shift可以批量选取图标）</li><li>按住Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住Command然后点击某个URL，会在浏览器中打开这个URL，点击某个文件夹，会在Finder里打开这个文件夹（再也不用open . 啦），点击某个文件名，会打开这个文件（文本文件支持MacVim，TextMate和BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回Linux的感觉了）</li></ul><p>不使用鼠标</p><p>(这种方式最多只能选取一行文本) 使用 Command + f，会呼出一个搜索框，可以在当前面板中进行搜索，输入想要选取的部分内容，输入过程中，按Tab可以将选取部分向右扩展，按Shift + Tab向左扩展，按回车转到下一个匹配位置。使用Tab或Shift+Tab扩展得到想要的内容之后，选取内容会自动复制到剪切板，再次按Command + f隐藏搜索框。</p><h2 id="位置书签"><a href="#位置书签" class="headerlink" title="位置书签"></a>位置书签</h2><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p><h2 id="粘贴历史"><a href="#粘贴历史" class="headerlink" title="粘贴历史"></a>粘贴历史</h2><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p><h2 id="即时回放"><a href="#即时回放" class="headerlink" title="即时回放"></a>即时回放</h2><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p><h2 id="窗口状态"><a href="#窗口状态" class="headerlink" title="窗口状态"></a>窗口状态</h2><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动iTerm2时自动恢复窗口状态</p><h2 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h2><ul><li>command+; 根据上下文呼出自动完成窗口，上下键选择</li><li>全屏 command+enter</li><li>光标去哪了？command+&#x2F;</li><li>用鼠标选中某个路径或者某个词汇就自动复制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 从Windows 迁移到Mac 上继续玩耍</title>
      <link href="/2017/08/25/%E6%9D%82%E8%AE%B0/%20hexo%20%E4%BB%8EWindows%20%E8%BF%81%E7%A7%BB%E5%88%B0Mac%20%E4%B8%8A%E7%BB%A7%E7%BB%AD%E7%8E%A9%E8%80%8D/"/>
      <url>/2017/08/25/%E6%9D%82%E8%AE%B0/%20hexo%20%E4%BB%8EWindows%20%E8%BF%81%E7%A7%BB%E5%88%B0Mac%20%E4%B8%8A%E7%BB%A7%E7%BB%AD%E7%8E%A9%E8%80%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近刚刚入手Mac，各种体验Mac的妙处，后面有时间把总结的各种坑记录下，这次先把基本的工具搬迁过来~</p><p>hexo 的搬家路： windows -&gt; mac </p></blockquote><h2 id="迁移思路"><a href="#迁移思路" class="headerlink" title="迁移思路"></a>迁移思路</h2><ul><li>在mac上安装好 <code>hexo</code>，初始化根目录；</li><li>然后生成新的 <code>SSH key</code>，并将其添加到 <code>github</code>；</li><li>将Windows上的资源、配置复制、直接粘贴覆盖Mac上对应的目录。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>安装 node&#x2F;git</strong></p><p>homebrew 安装：</p><p>​brew install node</p><p>​brew install git</p><p><strong>安装 hexo</strong></p><p>用 node 的 npm 安装 hexo：</p><pre><code>    npm install hexo-cli -g</code></pre><ul><li><p>每个版本安装方式可能不一样，这一步需要异步到 官网 </p></li><li><p><a href="https://hexo.io/">hexo 官网</a></p></li></ul><p><strong>初始化 hexo</strong></p><p>hexo init blog<br>cd blog<br>npm install<br>hexo server</p><p>启动成功</p><pre><code>    INFO  Start processing    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p><strong>生成 SSH key</strong><br>先检查一下本机的 SSH key：<code>cd ~/.ssh</code>；<br>生成 SSH key：<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>，<a href="mailto:&#120;&#x78;&#x78;&#120;&#x40;&#120;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#x78;&#120;&#x40;&#120;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a> 为自己注册 github 的邮箱；</p><p><strong>添加 SSH key 至 github</strong><br>进入.ssh文件夹： <code>cd ~/.ssh</code>，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：<em>Settings -&gt; SSH and GPG keys</em>，点击绿色的按钮 <em>New SSH key</em>，然后在输入框中输入刚才复制的内容；</p><p>使用coding的，同理</p><p>测试一下是否成功：<code>ssh git@github.com</code>，<br>看到以下即成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi gjincai! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure><p><strong>文件配置转移</strong><br>windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes；<br>把这几个文件复制到mac的目录下，直接覆盖替换相同的文件文件夹。</p><p>哦了！在mac上愉快的玩耍 <code>hexo</code> 吧！</p><ul><li>注意： 如果在 <code>hexo d</code> 部署不成功，有可能是缺少了模块，</li></ul><p>安装以下再尝试：<code>npm install hexo-deployer-git --save</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OX上安装MongoDb</title>
      <link href="/2017/08/24/%E6%9D%82%E8%AE%B0/%20Mac%20OX%E4%B8%8A%E5%AE%89%E8%A3%85MongoDb/"/>
      <url>/2017/08/24/%E6%9D%82%E8%AE%B0/%20Mac%20OX%E4%B8%8A%E5%AE%89%E8%A3%85MongoDb/</url>
      
        <content type="html"><![CDATA[<p>在mac上安装mongodb有很多方式，HomeBrew 安装 MongoDB是最快速简洁的，也方便后面的维护，这次主要记录使用brew安装的方式</p><ul><li><a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/">官方安装文档</a></li></ul><p>更新Homebrew的package源，在Mac的终端中输入：</p><pre><code>$ brew update</code></pre><h2 id="开始安装MongoDB"><a href="#开始安装MongoDB" class="headerlink" title="开始安装MongoDB"></a>开始安装MongoDB</h2><pre><code>$ brew install mongodb</code></pre><p>然后等待MongoDB下载完成。</p><pre><code>==&gt; Downloading https://homebrew.bintray.com/bottles/mongodb-3.4.7.sierra.bottle.1.tar.gz######################################################################## 100.0%==&gt; Pouring mongodb-3.4.7.sierra.bottle.1.tar.gz==&gt; CaveatsTo have launchd start mongodb now and restart at login:  brew services start mongodbOr, if you don&#39;t want/need a background service you can just run:  mongod --config /usr/local/etc/mongod.conf==&gt; Summary🍺  /usr/local/Cellar/mongodb/3.4.7: 19 files, 281.9MB</code></pre><h2 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h2><p>上面最后提示的直接启动MongoDb的方法.</p><pre><code>mongod —config /usr/local/etc/mongod.conf</code></pre><p>后台方式启动</p><p>   nohup mongod —config &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mongod.conf &amp;</p><h2 id="关闭MongoDB服务"><a href="#关闭MongoDB服务" class="headerlink" title="关闭MongoDB服务"></a>关闭MongoDB服务</h2><p>在 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongo.html#bin.mongo"><code>mongo</code></a> shell中使用 <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> 方法来关闭 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> ，如下所示：</p><pre><code>use admindb.shutdownServer()</code></pre><p>对于启用 <a href="http://docs.mongoing.com/manual-zh/reference/configuration-options.html#security.authorization"><code>authorization</code></a> 的系统，通过验证登陆到 <code>admin</code> 数据库，或者在为开启验证的情况下经由本地主机的系统接口登陆到 <code>admin</code> 数据库时，用户可以仅仅通过发送 <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> 来关闭实例。</p><p>For systems with <a href="http://docs.mongoing.com/manual-zh/reference/configuration-options.html#security.authorization"><code>authorization</code></a> enabled, users may only issue <a href="http://docs.mongoing.com/manual-zh/reference/method/db.shutdownServer.html#db.shutdownServer"><code>db.shutdownServer()</code></a> when authenticated to the <code>admin</code> database or via the localhost interface on systems without authentication enabled.</p><h3 id="使用-shutdown"><a href="#使用-shutdown" class="headerlink" title="使用 --shutdown"></a>使用 <code>--shutdown</code></h3><p>从Linux命令行关闭 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> ，可以使用 <em>–shutdown</em> 选项 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongod --shutdown</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-CTRL-C"><a href="#使用-CTRL-C" class="headerlink" title="使用 CTRL-C"></a>使用 <code>CTRL-C</code></h3><p>当正在运行一个交互模式 (i.e. without <em>–fork</em>) 的 <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> 实例时，发送 <code>Control-C</code> 来进行正常关闭。</p><h3 id="使用-kill"><a href="#使用-kill" class="headerlink" title="使用 kill"></a>使用 <code>kill</code></h3><p>From the Linux command line, shut down a specific <a href="http://docs.mongoing.com/manual-zh/reference/program/mongod.html#bin.mongod"><code>mongod</code></a> instance using one of the following commands:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill &lt;mongod process ID&gt;</span><br><span class="line">kill -2 &lt;mongod process ID&gt;</span><br></pre></td></tr></table></figure><h2 id="连接到MongoDb-直接在命令行使用mongo连接："><a href="#连接到MongoDb-直接在命令行使用mongo连接：" class="headerlink" title="连接到MongoDb,直接在命令行使用mongo连接："></a>连接到MongoDb,直接在命令行使用mongo连接：</h2><p>$ mongo</p><pre><code>MongoDB shell version v3.4.7connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.7Server has startup warnings:2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten]2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.2017-08-24T09:47:55.554+0800 I CONTROL  [initandlisten]&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行使用技巧</title>
      <link href="/2017/08/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/08/24/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="最实用的-Linux-命令行使用技巧-【已翻译100-】"><a href="#最实用的-Linux-命令行使用技巧-【已翻译100-】" class="headerlink" title="最实用的 Linux 命令行使用技巧 【已翻译100%】"></a>最实用的 Linux 命令行使用技巧 【已翻译100%】</h1><p>英文原文：<a href="https://dzone.com/articles/most-useful-linux-command-line-tricks">Most Useful Linux Command Line Tricks</a></p><hr><p>我们可能每天都会要使用到很多的 <a href="https://likegeeks.com/main-linux-commands-easy-guide/">Linux 命令行</a>。 我们也会网络上知晓一些使用它们的小技巧，但是如果我们没有时常来进行练习，就有可能会忘掉怎么去使用它们。 所以我就决定把那些你可能会忘记的小提示和小技巧，或者对你而言可能是全新的东西都列表来。</p><h2 id="将输出内容以表格的形式显示出来"><a href="#将输出内容以表格的形式显示出来" class="headerlink" title="将输出内容以表格的形式显示出来"></a>将输出内容以表格的形式显示出来</h2><p>有时，在你看到命令行执行的输出时，因为字符串过度拥挤（比如说 mount 命令的输出）导致输出内容难以识别。如果我们看到的内容是一张表格会如何呢？其实这是很容易做到的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column –t:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091303_TBUa_2903254.png" alt="img"></p><p>在此例中，由于内容中留了空格，所以输出的形式就美观了起来。 那如果想要的分隔符是别的什么符号，比如说冒号，又该怎么去做呢？ （例如，在 cat&#x2F;etc&#x2F;passwd 的输出内容中使用）</p><p>这时候只需要使用 -s 参数指定分隔符就行了，像下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | column -t -s:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091553_PTLs_2903254.png" alt="img"></p><h2 id="重复执行一个命令，直到它运行成功"><a href="#重复执行一个命令，直到它运行成功" class="headerlink" title="重复执行一个命令，直到它运行成功"></a>重复执行一个命令，直到它运行成功</h2><p>如果在 Google 上搜索这个功能，你会发现很多人都问到了如何重复执行命令，直到这个命令成功返回并且运行正常。 Google上的建议里就包括 ping 服务器，直到它变得空闲为止，还有就是检查是否有向特定的目录上传了具有特定扩展名的文件，还有就是检查特定的URL是否已经存在，诸如此类的办法。</p><p>其实你还可以使用 while true 的循环来实现来实现这个功能：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/091607_Z6PD_2903254.png" alt="img"></p><p>在上面这个示例中，&gt;&#x2F;dev&#x2F;null 2&gt;＆1 会让程序的输出重定向到 &#x2F;dev&#x2F; null。标准错误和标准输出都会被包含进去。</p><p>这是我认为最酷的Linux命令行技巧之一。</p><h2 id="按内存资源的使用量对进程进行排序"><a href="#按内存资源的使用量对进程进行排序" class="headerlink" title="按内存资源的使用量对进程进行排序"></a>按内存资源的使用量对进程进行排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | sort -rnk 4:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091735_Hqk6_2903254.png" alt="img"></p><h2 id="按-CPU-资源的使用量对进程进行排序"><a href="#按-CPU-资源的使用量对进程进行排序" class="headerlink" title="按 CPU 资源的使用量对进程进行排序"></a>按 CPU 资源的使用量对进程进行排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | sort -nk 3:</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/091900_QTKd_2903254.png" alt="img"></p><p>如果想要检查你的机器架构，那就执行 getconf LONG_BIT。</p><h2 id="可以同时查看多个日志文件"><a href="#可以同时查看多个日志文件" class="headerlink" title="可以同时查看多个日志文件"></a>可以同时查看多个日志文件</h2><p>毫无疑问，你可能已经会使用 tail  命令来查看日志文件了，但可能有时候你还想着能同时查看多个日志文件。 使用 multi-tail 命令就支持支持文本的高亮显示，内容过滤以及更多你可能需要的功能：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/091924_12e3_2903254.png" alt="img"><img src="https://static.oschina.net/uploads/space/2017/0823/091937_H48w_2903254.png" alt="img"></p><p>如果系统里还没有这个命令，运行 apt-get install multitail 命令就可以把它给装上。</p><h2 id="回到你操作过的上一个目录去"><a href="#回到你操作过的上一个目录去" class="headerlink" title="回到你操作过的上一个目录去"></a>回到你操作过的上一个目录去</h2><p>只需敲入 cd - 就会返回到你操作过的上一个目录中去。</p><h2 id="让非交互式-Shell-会话可进行交互"><a href="#让非交互式-Shell-会话可进行交互" class="headerlink" title="让非交互式 Shell 会话可进行交互"></a>让非交互式 Shell 会话可进行交互</h2><p>想要这样做，那就把设置从 ~&#x2F;.bashrc 改成 ~&#x2F;.bash_profile 吧。</p><h2 id="定时的监视性命令输出"><a href="#定时的监视性命令输出" class="headerlink" title="定时的监视性命令输出"></a>定时的监视性命令输出</h2><p>使用 watch 命令（watch df -h），你就可以查看到任何命令的任何输出。例如，你可以查看可用空间以及它的使用量增长情况。</p><p>通过利用 watch 命令来操作会变化的数据，你可以尽情想象自己能拿这个来做些什么哦。</p><h2 id="在会话关掉以后继续运行程序"><a href="#在会话关掉以后继续运行程序" class="headerlink" title="在会话关掉以后继续运行程序"></a>在会话关掉以后继续运行程序</h2><p>如果你在后台运行了什么程序，然后你关掉了的 shell 会话，那么这个后台运行的程序就会被你的 shell 杀掉。关闭 shell 以后怎么让程序继续运行下去呢？</p><p>这个可以用 nohup 命令做到 - 该指令表示不做挂断操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup wget site.com/file.zip</span><br></pre></td></tr></table></figure><p>此命令是最容易被遗忘的 Linux 命令行技巧之一，因为我们许多人都会使用另外一个类命令的 screen 环境：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092000_PnE3_2903254.png" alt="img"></p><p>这样会在同一个目录下生成一个名称为 nohup.out 的文件，其中包含了正在运行的程序的输出内容：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092013_Bvae_2903254.png" alt="img"></p><p>命令很酷，对吧？</p><h2 id="自动对任何命令回答-Yes-或者-No"><a href="#自动对任何命令回答-Yes-或者-No" class="headerlink" title="自动对任何命令回答 Yes 或者 No"></a>自动对任何命令回答 Yes 或者 No</h2><p>如果你想自动化需要向用户说的 Yes 的过程，可以使用 yes 命令来实现：yes | apt-get update。</p><p>也许你想做的是自动地说“No”。这个可以使用 yes no | 命令来实现。</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092025_pFb6_2903254.png" alt="img"></p><h2 id="创建具有指定大小的文件"><a href="#创建具有指定大小的文件" class="headerlink" title="创建具有指定大小的文件"></a>创建具有指定大小的文件</h2><p>可以使用 dd 命令来创建出具有指定大小的文件：dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;out.txt bs&#x3D;1M count&#x3D;10。</p><p>这样就会创建出一个 10 MB 的文件，填充零作为内容：</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092151_LtpJ_2903254.png" alt="img"></p><h2 id="以根目录用户来运行最后一个命令"><a href="#以根目录用户来运行最后一个命令" class="headerlink" title="以根目录用户来运行最后一个命令"></a>以根目录用户来运行最后一个命令</h2><p>有时，你会忘记在需要 root 权限的命令之前敲入 sudo。这时候你没必要去重写命令; 只要输入 sudo 就行了！</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092206_tCmM_2903254.png" alt="img"></p><h2 id="对命令行会话进行记录"><a href="#对命令行会话进行记录" class="headerlink" title="对命令行会话进行记录"></a>对命令行会话进行记录</h2><p>如果想要把自己在 shell 屏幕上敲的内容记录下来，可以使用 script 命令将所有敲写的内容保存到一个名为 typescriptscript 的文件中去。</p><p>等你敲入 exit 命令以后，所有命令就都会被写入该文件，以便你事后再回过头去查看。</p><h2 id="用标签符号替换空格符"><a href="#用标签符号替换空格符" class="headerlink" title="用标签符号替换空格符"></a>用标签符号替换空格符</h2><p>可以使用 tr 命令替换任何字符，这个用起来非常方便：cat geeks.txt | tr ‘:[space]:’ ‘\t’ &gt; out.txt.</p><p><img src="https://static.oschina.net/uploads/space/2017/0823/092230_Phyw_2903254.png" alt="img"></p><h2 id="将文件内容转换为大写或者小写"><a href="#将文件内容转换为大写或者小写" class="headerlink" title="将文件内容转换为大写或者小写"></a>将文件内容转换为大写或者小写</h2><p>可以这样实现：cat myfile | tr a-z A-Z&gt; output.txt。</p><h2 id="强大的-Xargs-命令"><a href="#强大的-Xargs-命令" class="headerlink" title="强大的 Xargs 命令"></a>强大的 Xargs 命令</h2><p>xargs 命令是最重要的 Linux 命令行技巧之一。你可以使用这个命令将命令的输出作为参数传递给另一个命令。例如，搜索 png 文件然后对其进行压缩或者其它操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find. -name *.png -type f -print | xargs tar -cvzf images.tar.gz</span><br></pre></td></tr></table></figure><p>又或者你的文件中有一个 URL 的列表，而你想要做的是以不同的方式下载或者处理这些 URL，可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat urls.txt | xargs wget</span><br></pre></td></tr></table></figure><p><img src="https://static.oschina.net/uploads/space/2017/0823/092303_cq15_2903254.png" alt="img"></p><p><img src="https://static.oschina.net/uploads/img/201708/23092445_75a4.png" alt="xargs command"></p><p>请你要记得，第一个命令的输出会在 xargs 命令结尾处传递。</p><p>那如果命令需要中间过程的输出，该怎么办呢？这个简单！</p><p>只需要使用 {} 并结合 -i 参数就行了。如下所示，替换在第一个命令的输出应该去的地方的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/*.conf | xargs -i cp &#123;&#125; /home/likegeeks/Desktop/out</span><br></pre></td></tr></table></figure><p>这只是 Linux 命令行技巧其中的几个而已。你可以使用其他命令来做一些更 HAPPY 的事情，比如 awk 命令和 sed 命令！</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 键盘快捷键</title>
      <link href="/2017/08/12/%E6%9D%82%E8%AE%B0/%20Mac%20%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/08/12/%E6%9D%82%E8%AE%B0/%20Mac%20%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-键盘快捷键"><a href="#Mac-键盘快捷键" class="headerlink" title="Mac 键盘快捷键"></a>Mac 键盘快捷键</h1><p>把<a href="https://support.apple.com/zh-cn/HT201236">官方</a>这个文档，搬过来学习系统快捷键，熟悉使用快捷键将会提升自己的工作效率。</p><p>您可以按下组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。</p><p>要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如，要使用快捷键 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常<a href="https://support.apple.com/kb/PH18802?locale=zh_CN">对某些按键使用符号</a>，其中包括以下修饰键：</p><ul><li><p>Command ⌘</p></li><li><p>Shift ⇧</p></li><li><p>Option ⌥</p></li><li><p>Control ⌃</p></li><li><p>Caps Lock ⇪</p></li><li><p>Fn</p></li></ul><p>如果您使用的是 Windows PC 专用键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。有些 Mac 键盘在顶行中设有特殊按键，快捷键中也会用到它们；这些按键上有音量图标、显示屏亮度图标和其他功能图标。按下图标键可执行相应功能，将其与 Fn 键组合可用作 F1、F2、F3 或其他标准功能键。 </p><p>要了解更多快捷键，请查看您所用应用的菜单。每个应用都有自己的快捷键，在一个应用中有用的快捷键可能不能用于另一个应用。</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="剪切、拷贝、粘贴和其他常用快捷键"><a href="#剪切、拷贝、粘贴和其他常用快捷键" class="headerlink" title="剪切、拷贝、粘贴和其他常用快捷键"></a>剪切、拷贝、粘贴和其他常用快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-X</td><td><strong>剪切</strong>所选项并拷贝到剪贴板。</td></tr><tr><td>Command-C</td><td>将所选项<strong>拷贝</strong>到剪贴板。这同样适用于“访达”中的文件。</td></tr><tr><td>Command-V</td><td>将剪贴板的内容<strong>粘贴</strong>到当前文稿或应用中。这同样适用于“访达”中的文件。</td></tr><tr><td>Command-Z</td><td><strong>撤销</strong>前一个命令。随后您可以按 Command-Shift-Z 来<strong>重做</strong>，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。</td></tr><tr><td>Command-A</td><td><strong>全选</strong>各项。</td></tr><tr><td>Command-F</td><td><strong>查找</strong>文稿中的项目或打开“查找”窗口。</td></tr><tr><td>Command-G</td><td><strong>再次查找</strong>：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command-Shift-G。</td></tr><tr><td>Command-H</td><td><strong>隐藏</strong>最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Command-Option-H。</td></tr><tr><td>Command-M</td><td>将最前面的窗口<strong>最小化</strong>至“程序坞”。要最小化最前面的应用的所有窗口，请按 Command-Option-M。</td></tr><tr><td>Command-N</td><td><strong>新建：</strong>打开一个新文稿或窗口。</td></tr><tr><td>Command-O</td><td><strong>打开</strong>所选项，或打开一个对话框以选择要打开的文件。</td></tr><tr><td>Command-P</td><td><strong>打印</strong>当前文稿。</td></tr><tr><td>Command-S</td><td><strong>存储</strong>当前文稿。</td></tr><tr><td>Command-W</td><td><strong>关闭</strong>最前面的窗口。要关闭应用的所有窗口，请按下 Command-Option-W。</td></tr><tr><td>Command-Q</td><td><strong>退出</strong>应用。</td></tr><tr><td>Option-Command-Esc</td><td><strong>强制退出</strong>：选择要<a href="https://support.apple.com/zh-cn/HT201276">强制退出</a>的应用。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的应用退出。</td></tr><tr><td>Command–空格键</td><td><strong>“聚焦”</strong>：显示或隐藏 <a href="https://support.apple.com/zh-cn/HT201744">“聚焦”</a> 搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。如果您<a href="https://support.apple.com/kb/PH21564?locale=zh_CN">使用多个输入源</a>以便用不同的语言键入内容，这些快捷键会<a href="https://support.apple.com/kb/PH21554?locale=zh_CN">更改输入源而非显示“聚焦”</a>。</td></tr><tr><td>空格键</td><td><strong>快速查看</strong>：使用<a href="https://support.apple.com/zh-cn/HT201067">快速查看</a>来预览所选项。</td></tr><tr><td>Command-Tab</td><td><strong>切换应用</strong>：在打开的应用中切换到下一个最近使用的应用。</td></tr><tr><td>Shift-Command-波浪号 (~)</td><td><strong>切换窗口</strong>：切换到最前端应用中下一个最近使用的窗口。</td></tr><tr><td>Shift-Command-3</td><td><strong>屏幕快照</strong>：拍摄整个屏幕的屏幕快照。<a href="https://support.apple.com/zh-cn/HT201361">了解更多屏幕快照快捷键</a>。</td></tr><tr><td>Command-逗号 (,)</td><td><strong>偏好设置</strong>：打开最前面的应用的偏好设置。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="睡眠、退出登录和关机快捷键"><a href="#睡眠、退出登录和关机快捷键" class="headerlink" title="睡眠、退出登录和关机快捷键"></a>睡眠、退出登录和关机快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>电源按钮</td><td>按下可打开 Mac 电源或将 Mac 从睡眠状态唤醒。当 Mac 处于唤醒状态时，按住这个按钮 1.5 秒钟会显示一个对话框，询问您是要睡眠、重新启动还是关机。如果您不想等待 1.5 秒钟，请按下 Control–电源按钮或 Control–介质推出键 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">。*按住这个按钮 5 秒钟会强制 Mac 关机。</td></tr><tr><td>Control–Command–电源按钮</td><td>强制 Mac 重新启动。*</td></tr><tr><td>Control–Shift–电源按钮或Control–Shift–介质推出键<img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>将显示器置于睡眠状态。*</td></tr><tr><td>Control–Command–介质推出键 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>退出所有应用，然后重新启动 Mac。如果任何打开的文稿有未存储的更改，系统就会询问您要不要存储这些更改。*</td></tr><tr><td>Control–Option–Command–电源按钮或Control–Option–Command–介质推出键<img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img"></td><td>退出所有应用，然后关闭 Mac。如果任何打开的文稿有未存储的更改，系统就会询问您要不要存储这些更改。*</td></tr><tr><td>Shift-Command-Q</td><td>退出登录您的 macOS 用户帐户。系统将提示您确认。</td></tr><tr><td>Option-Shift-Command-Q</td><td>立即退出登录您的 macOS 用户帐户，且系统不提示您确认。</td></tr></tbody></table><p>*不适用于带有<a href="https://support.apple.com/zh-cn/HT207055">触控栏</a>的键盘。</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="文稿快捷键"><a href="#文稿快捷键" class="headerlink" title="文稿快捷键"></a>文稿快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-B</td><td>以粗体显示所选文本，或者打开或关闭粗体显示功能。</td></tr><tr><td>Command-I</td><td>以斜体显示所选文本，或者打开或关闭斜体显示功能。</td></tr><tr><td>Command-U</td><td>对所选文本加下划线，或者打开或关闭加下划线功能。</td></tr><tr><td>Command-T</td><td>显示或隐藏“字体”窗口。</td></tr><tr><td>Command-D</td><td>从“打开”对话框或“存储”对话框中选择“桌面”文件夹。</td></tr><tr><td>Control-Command-D</td><td>显示或隐藏所选字词的定义。</td></tr><tr><td>Shift-Command-冒号 (:)</td><td>显示“拼写和语法”窗口。</td></tr><tr><td>Command-分号 (;)</td><td>查找文稿中拼写错误的字词。</td></tr><tr><td>Option-Delete</td><td>删除插入点左边的字词。</td></tr><tr><td>Control-H</td><td>删除插入点左边的字符。也可以使用 Delete 键。</td></tr><tr><td>Control-D</td><td>删除插入点右边的字符。也可以使用 Fn-Delete。</td></tr><tr><td>Fn-Delete</td><td>在没有向前删除 <img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/osx/modfdl.png" alt=" "> 键的键盘上向前删除。也可以使用 Control-D。</td></tr><tr><td>Control-K</td><td>删除插入点与行或段落末尾处之间的文本。</td></tr><tr><td>Command-Delete</td><td>在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。</td></tr><tr><td>Fn–上箭头</td><td>Page Up：向上滚动一页。</td></tr><tr><td>Fn–下箭头</td><td>Page Down：向下滚动一页。</td></tr><tr><td>Fn–左箭头</td><td>Home：滚动到文稿开头。</td></tr><tr><td>Fn–右箭头</td><td>End：滚动到文稿末尾。</td></tr><tr><td>Command–上箭头</td><td>将插入点移至文稿开头。</td></tr><tr><td>Command–下箭头</td><td>将插入点移至文稿末尾。</td></tr><tr><td>Command–左箭头</td><td>将插入点移至当前行的行首。</td></tr><tr><td>Command–右箭头</td><td>将插入点移至当前行的行尾。</td></tr><tr><td>Option–左箭头</td><td>将插入点移至上一字词的词首。</td></tr><tr><td>Option–右箭头</td><td>将插入点移至下一字词的词尾。</td></tr><tr><td>Shift–Command–上箭头</td><td>选中插入点与文稿开头之间的文本。</td></tr><tr><td>Shift–Command–下箭头</td><td>选中插入点与文稿末尾之间的文本。</td></tr><tr><td>Shift–Command–左箭头</td><td>选中插入点与当前行行首之间的文本。</td></tr><tr><td>Shift–Command–右箭头</td><td>选中插入点与当前行行尾之间的文本。</td></tr><tr><td>Shift–上箭头</td><td>将文本选择范围扩展到上一行相同水平位置的最近字符处。</td></tr><tr><td>Shift–下箭头</td><td>将文本选择范围扩展到下一行相同水平位置的最近字符处。</td></tr><tr><td>Shift–左箭头</td><td>将文本选择范围向左扩展一个字符。</td></tr><tr><td>Shift–右箭头</td><td>将文本选择范围向右扩展一个字符。</td></tr><tr><td>Option–Shift–上箭头</td><td>将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。</td></tr><tr><td>Option–Shift–下箭头</td><td>将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。</td></tr><tr><td>Option–Shift–左箭头</td><td>将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。</td></tr><tr><td>Option–Shift–右箭头</td><td>将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。</td></tr><tr><td>Control-A</td><td>移至行或段落的开头。</td></tr><tr><td>Control-E</td><td>移至行或段落的末尾。</td></tr><tr><td>Control-F</td><td>向前移动一个字符。</td></tr><tr><td>Control-B</td><td>向后移动一个字符。</td></tr><tr><td>Control-L</td><td>将光标或所选内容置于可见区域中央。</td></tr><tr><td>Control-P</td><td>上移一行。</td></tr><tr><td>Control-N</td><td>下移一行。</td></tr><tr><td>Control-O</td><td>在插入点后插入一行。</td></tr><tr><td>Control-T</td><td>将插入点后面的字符与插入点前面的字符交换。</td></tr><tr><td>Command–左花括号 ({)</td><td>左对齐。</td></tr><tr><td>Command–右花括号 (})</td><td>右对齐。</td></tr><tr><td>Shift–Command–竖线 (|)</td><td>居中对齐。</td></tr><tr><td>Option-Command-F</td><td>前往搜索栏。</td></tr><tr><td>Option-Command-T</td><td>显示或隐藏应用中的工具栏。</td></tr><tr><td>Option-Command-C</td><td>拷贝样式：将所选项的格式设置拷贝到剪贴板。</td></tr><tr><td>Option-Command-V</td><td>粘贴样式：将拷贝的样式应用到所选项。</td></tr><tr><td>Option-Shift-Command-V</td><td>粘贴并匹配样式：将周围内容的样式应用到粘贴在这个内容中的项目。</td></tr><tr><td>Option-Command-I</td><td>显示或隐藏检查器窗口。</td></tr><tr><td>Shift-Command-P</td><td>页面设置：显示用于选择文稿设置的窗口。</td></tr><tr><td>Shift-Command-S</td><td>显示“存储为”对话框或复制当前文稿。</td></tr><tr><td>Shift–Command–减号 (-)</td><td>缩小所选项。</td></tr><tr><td>Shift–Command–加号 (+)</td><td>放大所选项。Command–等号 (&#x3D;) 可执行相同的功能。</td></tr><tr><td>Shift–Command–问号 (?)</td><td>打开“帮助”菜单。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="“访达”快捷键"><a href="#“访达”快捷键" class="headerlink" title="“访达”快捷键"></a>“访达”快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Command-D</td><td>复制所选文件。</td></tr><tr><td>Command-E</td><td>推出所选磁盘或宗卷。</td></tr><tr><td>Command-F</td><td>在“访达”窗口中开始“聚焦”搜索。</td></tr><tr><td>Command-I</td><td>显示所选文件的“显示简介”窗口。</td></tr><tr><td>Shift-Command-C</td><td>打开“电脑”窗口。</td></tr><tr><td>Shift-Command-D</td><td>打开“桌面”文件夹。</td></tr><tr><td>Shift-Command-F</td><td>打开“我的所有文件”窗口。</td></tr><tr><td>Shift-Command-G</td><td>打开“前往文件夹”窗口。</td></tr><tr><td>Shift-Command-H</td><td>打开当前 macOS 用户帐户的个人文件夹。</td></tr><tr><td>Shift-Command-I</td><td>打开 <a href="https://support.apple.com/zh-cn/HT201104">iCloud 云盘</a>。</td></tr><tr><td>Shift-Command-K</td><td>打开“网络”窗口。</td></tr><tr><td>Option-Command-L</td><td>打开“下载”文件夹。</td></tr><tr><td>Shift-Command-O</td><td>打开“文稿”文件夹。</td></tr><tr><td>Shift-Command-R</td><td>打开“隔空投送”窗口。</td></tr><tr><td>Shift-Command-T</td><td>将所选的“访达”项目添加到“程序坞”（OS X Mountain Lion 或更低版本）</td></tr><tr><td>Control-Shift-Command-T</td><td>将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）</td></tr><tr><td>Shift-Command-U</td><td>打开“实用工具”文件夹。</td></tr><tr><td>Option-Command-D</td><td>显示或隐藏 <a href="https://support.apple.com/zh-cn/HT201730">“程序坞”</a>。即使您未在“访达”窗口中，这个快捷键通常也有效。</td></tr><tr><td>Control-Command-T</td><td>将所选项添加到边栏（OS X Mavericks 或更高版本）。</td></tr><tr><td>Option-Command-P</td><td>隐藏或显示“访达”窗口中的路径栏。</td></tr><tr><td>Option-Command-S</td><td>隐藏或显示“访达”窗口中的边栏。</td></tr><tr><td>Command–斜线 (&#x2F;)</td><td>隐藏或显示“访达”窗口中的状态栏。</td></tr><tr><td>Command-J</td><td>显示“显示”选项。</td></tr><tr><td>Command-K</td><td>打开“连接服务器”窗口。</td></tr><tr><td>Command-L</td><td>为所选项制作替身。</td></tr><tr><td>Command-N</td><td>打开一个新的“访达”窗口。</td></tr><tr><td>Shift-Command-N</td><td>新建文件夹。</td></tr><tr><td>Option-Command-N</td><td>新建智能文件夹。</td></tr><tr><td>Command-R</td><td>显示所选替身的原始文件。</td></tr><tr><td>Command-T</td><td>在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。</td></tr><tr><td>Shift-Command-T</td><td>显示或隐藏“访达”标签页。</td></tr><tr><td>Option-Command-T</td><td>在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。</td></tr><tr><td>Option-Command-V</td><td>移动：将剪贴板中的文件从原始位置移动到当前位置。</td></tr><tr><td>Option-Command-Y</td><td>显示所选文件的<a href="https://support.apple.com/zh-cn/HT201067">快速查看</a>幻灯片显示。</td></tr><tr><td>Command-Y</td><td>使用“快速查看”预览所选文件。</td></tr><tr><td>Command-1</td><td>以图标方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-2</td><td>以列表方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-3</td><td>以分栏方式显示“访达”窗口中的项目。</td></tr><tr><td>Command-4</td><td>以封面流方式显示“访达”窗口中的项目。</td></tr><tr><td>Command–左中括号 ([)</td><td>前往上一文件夹。</td></tr><tr><td>Command–右中括号 (])</td><td>前往下一文件夹。</td></tr><tr><td>Command–上箭头</td><td>打开包含当前文件夹的文件夹。</td></tr><tr><td>Command–Control–上箭头</td><td>在新窗口中打开包含当前文件夹的文件夹。</td></tr><tr><td>Command–下箭头</td><td>打开所选项。</td></tr><tr><td>Command–“调度中心”</td><td>显示桌面。即使您未在“访达”窗口中，这个快捷键也有效。</td></tr><tr><td>Command–调高亮度</td><td>开启或关闭<a href="https://support.apple.com/zh-cn/HT204592">目标显示器模式</a>。</td></tr><tr><td>Command–调低亮度</td><td>当 Mac 连接到多个显示器时打开或关闭显示器镜像功能。</td></tr><tr><td>右箭头</td><td>打开所选文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td>左箭头</td><td>关闭所选文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td>Option-连按</td><td>在单独的窗口中打开文件夹，并关闭当前窗口。</td></tr><tr><td>Command-连按</td><td>在单独的标签页或窗口中打开文件夹。</td></tr><tr><td>Command-Delete</td><td>将所选项移到废纸篓。</td></tr><tr><td>Shift-Command-Delete</td><td>清倒废纸篓。</td></tr><tr><td>Option-Shift-Command-Delete</td><td>清倒废纸篓而不显示确认对话框。</td></tr><tr><td>Command-Y</td><td>使用“快速查看”预览文件。</td></tr><tr><td>Option–调高亮度</td><td>打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。</td></tr><tr><td>Option–“调度中心”</td><td>打开“调度中心”偏好设置。</td></tr><tr><td>Option–调高音量</td><td>打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。</td></tr><tr><td><em>按住 Command 键拖移</em></td><td>将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option 键拖移</em></td><td>拷贝拖移的项目。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option-Command 键拖移</em></td><td>为拖移的项目制作替身。拖移项目时指针会随之变化。</td></tr><tr><td><em>按住 Option 键点按开合三角</em></td><td>打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。</td></tr><tr><td><em>按住 Command 键点按窗口标题</em></td><td>查看包含当前文件夹的文件夹。</td></tr></tbody></table><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/mac_apps/itunes/divider.png" alt="img"></p><h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><ul><li><a href="https://support.apple.com/zh-cn/HT201255">Mac 启动时可以使用的快捷键</a></li><li><a href="https://support.apple.com/zh-cn/HT204434">辅助功能的快捷键</a></li><li><a href="https://support.apple.com/kb/PH19282?locale=zh_CN">“Safari 浏览器”8 (Yosemite) 的快捷键</a></li><li><a href="https://support.apple.com/kb/PH21483?locale=zh_CN">“Safari 浏览器”9 (El Capitan) 的快捷键</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用指令详解</title>
      <link href="/2017/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Nginx%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx运维常用指令详解"><a href="#Nginx运维常用指令详解" class="headerlink" title="Nginx运维常用指令详解"></a>Nginx运维常用指令详解</h2><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ul><li><p>一、主配置文件框架解析</p></li><li><ul><li><a href="#main_cfg_para">1、Main配置段常用参数</a></li><li><a href="#event_cfg_para">2、event配置段常用参数</a></li><li><a href="#http_cfg_para">3、http配置段常用参数</a></li><li><a href="#clinet_cfg_para">4、面向客户端请求相关的配置</a></li><li><a href="#client_limit">5、对客户端请求进行限制</a></li><li><a href="#file_cfg_para">6、文件操作优化相关的配置</a></li></ul></li><li><p><a href="#ngx_http_access_module">二、ngx_http_access_module模块</a></p></li><li><p><a href="#ngx_http_auth_basic_module">三、ngx_http_auth_basic_module模块</a></p></li><li><p><a href="#ngx_http_log_module">四、ngx_http_log_module模块</a></p></li><li><p><a href="#ngx_http_stub_status_module">五、ngx_http_stub_status_module模块</a></p></li><li><p><a href="#ngx_http_referer_module">六、ngx_http_referer_module模块</a></p></li><li><p><a href="#ngx_http_ssl_module">七、ngx_http_ssl_module模块</a></p></li><li><p><a href="#ngx_http_rewrite_module">八、ngx_http_rewrite_module模块</a></p></li><li><p><a href="#ngx_http_gzip_module">九、ngx_http_gzip_module模块</a></p></li><li><p><a href="#ngx_http_fastcgi_module">十、ngx_http_fastcgi_module模块</a></p></li><li><p><a href="#ngx_http_proxy_module">十一、ngx_http_proxy_module模块</a></p></li><li><p><a href="#ngx_http_headers_module">十二、ngx_http_headers_module模块</a></p></li><li><p><a href="#ngx_http_upstream_module">十三、ngx_http_upstream_module模块</a></p></li></ul><hr><h1 id="nginx常用配置详解"><a href="#nginx常用配置详解" class="headerlink" title="nginx常用配置详解"></a>nginx常用配置详解</h1><h2 id="一、主配置文件框架解析"><a href="#一、主配置文件框架解析" class="headerlink" title="一、主配置文件框架解析"></a>一、主配置文件框架解析</h2><h4 id="1、Main配置段常用参数"><a href="#1、Main配置段常用参数" class="headerlink" title="1、Main配置段常用参数"></a><span id="main_cfg_para">1、Main配置段常用参数</span></h4><h6 id="1-正常运行必备的配置指令"><a href="#1-正常运行必备的配置指令" class="headerlink" title="(1) 正常运行必备的配置指令"></a>(1) 正常运行必备的配置指令</h6><ul><li><p><code>uesr USERNAME [GROUPNAME];</code></p></li><li><ul><li>指定用于运行worker进程的用户和组,默认是nginx用户,nginx组</li></ul></li><li><p><code>pid /path/to/pid_file;</code></p></li><li><ul><li>指定nginx进程的PID文件路径, 默认为:pid &#x2F;var&#x2F;runl&#x2F;nginx&#x2F;nginx.pid</li></ul></li><li><p><code>worker_rlimit_nofile #;</code></p></li><li><ul><li>指定每个worker进程能打开的最大文件描述符数量(nofile: number of file)</li></ul></li><li><p><code>worker_rlimit_sigpending #;</code></p></li><li><ul><li>指定每个用户能够发往worker进程的信号的最大数量</li></ul></li></ul><h6 id="2-性能优化相关的配置"><a href="#2-性能优化相关的配置" class="headerlink" title="(2) 性能优化相关的配置"></a>(2) 性能优化相关的配置</h6><ul><li><p><code>woker_processes #;</code></p></li><li><ul><li>worker进程的个数,通常应该为物理CPU核心数量减1或者减2,worker_processes auto;可以根据物理CPU自动设定. worker不使用进程或线程处理请求, 而是直接将worker绑定到CPU上, 这样就没有进程切换的说法了.</li></ul></li><li><p><code>worker_cpu_affinity CPUMASK CPUMASK...;</code></p></li><li><ul><li>将worker进程与指定的CPU进行绑定,这种绑定不能隔离CPU,CPU还可能会响应其它进程请求.</li></ul></li><li><p><code>worker_priority NICE;</code></p></li><li><ul><li>[-20,19],worker进程的优先级, 默认为0</li></ul></li></ul><h6 id="3-调试定位问题的配置"><a href="#3-调试定位问题的配置" class="headerlink" title="(3)调试定位问题的配置"></a>(3)调试定位问题的配置</h6><ul><li><p><code>daemon [off|on];</code></p></li><li><ul><li>是否以守护进程方式启动nginx</li></ul></li><li><p><code>master_process [on | off];</code></p></li><li><ul><li>是否以master&#x2F;worker模型运行nginx,off后,只单个进程启动Nignx.</li></ul></li><li><p><code>error_log /path/to/error_log Level;</code></p></li><li><ul><li>错误日志文件及级别, 出于调试的需要,可以设定为debug,但在debug级别在编译时使用—with-debug选项时才有效</li></ul></li></ul><h4 id="2、event配置段常用参数"><a href="#2、event配置段常用参数" class="headerlink" title="2、event配置段常用参数"></a><span id="event_cfg_para">2、event配置段常用参数</span></h4><ul><li><p><code>worker_connections #;</code></p></li><li><ul><li>每个worker进程所能够响应的最大并发请求数量, 请求的最大上限为:worker_processes * worker_connections</li></ul></li><li><p><code>use [epoll | rgsig | select | poll]]</code></p></li><li><ul><li>定义使用的事件模型, 建议让nginx自动选择</li></ul></li><li><p><code>accept_mutex [on | off];</code></p></li><li><ul><li>定义内部调用请求至worker时请求的互斥锁文件(各worker接收用户的请求的负载均衡锁),on:能够让多个worker轮流地,序列化的响应新请求</li></ul></li><li><p><code>lockfile /path/to/lockfile</code></p></li><li><ul><li>锁文件定义位置</li></ul></li></ul><h4 id="3、http配置段常用参数"><a href="#3、http配置段常用参数" class="headerlink" title="3、http配置段常用参数"></a><span id="http_cfg_para">3、http配置段常用参数</span></h4><ul><li><p><code>server &#123;&#125;</code></p></li><li><ul><li>定义一个虚拟主机,server可以出现一次或多次</li></ul></li><li><p><code>listen address [:port] [default_server] [[ssl] [http2 | spdy]]</code></p></li><li><p><code>listen port [default_server] [ssl] [http2 | spdy]</code></p></li><li><ul><li>default_server:设置默认虚拟主机, 当用户使用IP地址访问时,就返回default_server的虚拟主机, 如果未定义default_server时,第一个虚拟主机将做为默认的主机</li><li>ssl : 用于限制只能通过SSL连接提供服务,不是以端口确认其协议的, 故需要启用ssl,需要在监听的端口后面, 添加ssl选项</li><li>spdy : spdy protocol(google研发的http协议,比http&#x2F;1.1性能要好, 全称为speedy),在编译时编译了spdy模块的情况下,用于支持spdy协议</li><li>http2 : http version2,在编译时需要开启http2协议支持</li></ul></li><li><p><code>server_name NAME [....];</code> : 指明主机名称</p></li><li><ul><li><p>(1) 先做精确匹配,例如:<a href="http://www.zhenping.me/">www.zhenping.me</a></p></li><li><p>(2) 左侧通配符,例如:*.zhenping.me</p></li><li><p>(3) 右侧通配符,例如:<a href="http://www.zhenping/">www.zhenping</a>.*</p></li><li><p>(4) 正则表达式匹配,例如:~^.*.zhenping.me$</p></li><li><p>default_server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx默认工作法则: 先将域的匹配规则,先做hash计算,把计算的结果放置进内存,下次访问请求过来时, 直接做对比</span><br></pre></td></tr></table></figure></li><li><p>servername后可跟一个或多个主机名, 名称还可以使用通配符和正则表达式(~),域名匹配顺序</p></li></ul></li><li><p><code>tcp_nodelay [on | off];</code></p></li><li><ul><li>对keepalive模式下的连接是否使用tcp_nodelay选项,默认关闭.其功能为:把多个小报文合并为一个报文,一起发送. 此机制可以提高带宽利用率,将发往同一个主机很小的TCP报文合并成一个,实际生产对于用户请求即使浪费带宽也不能合并请求</li></ul></li><li><p><code>tcp_nopush [on | off];</code></p></li><li><ul><li>是否启用tcp_nopush(FreeBSD)或tcp_cork(linux)选项,仅在sendfile为on时有用, 其功能:尝试将多个报文首部压缩成一个发送, 默认为off,不启用该功能</li></ul></li><li><p><code>sendfile [on | off];</code></p></li><li><ul><li>是否启用sendfile功能,静态文件直接在内核中封装响应,而不是从内核空间到用户空间封装后,再发往内核空间.</li></ul></li><li><p><code>roo /PATH/TO/Directory;</code></p></li><li><ul><li>设置web资源的路径映射,用于指明请求的URL所对应的文件的目录路径,可用于server或location中.</li></ul></li><li><p><code>location [ = | ~ | ~* | ^~ ] url &#123; ...&#125;</code></p></li><li><p><code>location @name &#123;...&#125;</code></p></li><li><ul><li><code>=</code> : URI的精确匹配</li><li><code>~</code> : 做正则表达式匹配,区分字符大小写</li><li><code>~*</code> : 做正则表达式匹配,不区分字符大小写</li><li><code>^~</code> : URI的左半部分匹配,不区分字符大小写</li><li>允许根据用户请求的URI来匹配定义的各location,匹配到时, 此请求将被相应的location块中的配置所处理, 简言之:用于为需要用到专用配置的uri提供特定配置.</li><li>当匹配多次时,其匹配优先级为:精确匹配&#x3D;,^<del>,</del>或~*,不带符号的URL, 如果优先级都一样, 就匹配最精确的规则</li></ul></li><li><p><code>alias</code></p></li><li><ul><li>只能用于location配置段,用于定义路径别名</li></ul></li><li><p><code>index</code></p></li><li><ul><li>设置默认主页(nginx_http_index_module模块引入), 可以带上变量,如$geo根据不同IP地址来设置不同的语言主页,应用上下文为:http,server,location</li></ul></li><li><p><code>error_page code ...[=[response]] uri;</code></p></li><li><ul><li>自定义错误页面,根据http状态码重写向错误页面</li></ul></li><li><p><code>try_files file... uri;</code></p></li><li><p><code>try_files file... =code;</code></p></li><li><ul><li>可用于server,location中, 以指定的顺序检查文件的存在性响应</li><li>尝试查找第1至第N-1个文件,第一个即为返回给请求者的资源,若1至N-1文件都不存在, 则跳转至最后一个uri(必须 不能匹配至当前location,而应该匹配至其它location,否则会导致死循环)</li></ul></li></ul><h4 id="4、面向客户端请求相关的配置"><a href="#4、面向客户端请求相关的配置" class="headerlink" title="4、面向客户端请求相关的配置"></a><span id="clinet_cfg_para">4、面向客户端请求相关的配置</span></h4><ul><li><p><code>keepalive_disable none | browser;</code></p></li><li><ul><li>禁止那些浏览器使用keepalive功能,如: keepalive_disable msie6</li></ul></li><li><p><code>keepalive_timeout #s;</code></p></li><li><ul><li>设定keepalive连接的超时时长,0表示禁止长连接,默认启用为75s</li></ul></li><li><p><code>keepalive_requests #;</code></p></li><li><ul><li>在keepalive连接上所允许请求的最大资源数量,默认为100;</li></ul></li><li><p><code>send_timout #;</code></p></li><li><ul><li>发送响应报文的超时时长,默认为60s;</li></ul></li><li><p><code>client_body_buffer_size SIZE(8k | 16k);</code></p></li><li><ul><li>接收客户请求报文body的缓冲区大小, 默认为16k(64位系统,32位系统为8K),超出指定大小时将被移存于磁盘上.</li></ul></li><li><p><code>client_body_temp_path [Level1 [level2 [level3]]]</code></p></li><li><ul><li>设定用于存储客户端请求body的临时存储路径及子目录结构和数量</li></ul></li></ul><h4 id="5、对客户端请求进行限制"><a href="#5、对客户端请求进行限制" class="headerlink" title="5、对客户端请求进行限制"></a><span id="client_limit">5、对客户端请求进行限制</span></h4><ul><li><p><code>limit_except METHOD &#123;...&#125;;</code></p></li><li><ul><li>对指定范围之外的其它方法进行访问控制,应用于location上下文</li></ul></li><li><p><code>limit_rate SPEED;</code></p></li><li><ul><li>限制客户端每秒种所能够传输的字节数, 默认为0,表示不限制,应用于http,server,location,if in location上下文中</li></ul></li><li><p><code>limit_rate_after SIZE;</code></p></li><li><ul><li>超出SIZE的值, 就限制速度,应用于http,server,location,if in locataion上下文中</li></ul></li></ul><h4 id="6、文件操作优化相关的配置"><a href="#6、文件操作优化相关的配置" class="headerlink" title="6、文件操作优化相关的配置"></a><span id="file_cfg_para">6、文件操作优化相关的配置</span></h4><ul><li><p><code>aio on | off;</code></p></li><li><ul><li>是否启用异步IO模式, 应用于http, server,location上下文中</li></ul></li><li><p><code>directio size | off;</code></p></li><li><ul><li>是否启用直接IO操作, 不在内存中缓冲, 直接从硬盘加载使用(当大于指定的size),应用于http,server,location</li></ul></li><li><p><code>open_file_cache off | max=N [inactive=time];</code></p></li><li><ul><li>(1) 文件描述符</li><li>(2) 文件大小</li><li>(3) 最近一次的修改时间</li><li>(4) 打开的目录的结构</li><li>(5) 没有找到或者没有权限操作的文件的相关信息</li><li>对打开的文件进行缓存 ,nginx可以缓存以下三种信息</li><li>max&#x3D;N : 可缓存的最大条目上限,一旦达到上限, 则会使用LRU算法从缓存中删除最近最少使用的缓存项</li><li>inactive&#x3D;time : 在此处指定的时长内没有被访问过的缓存项识别为非活动缓存项, 因此直接删除</li></ul></li><li><p><code>open_file_cache errors on|off;</code></p></li><li><ul><li>是否缓存找不到其路径的文件,或没有权限访问的文件相关信息</li></ul></li><li><p><code>open_file_cache_valid time;</code>    </p></li><li><ul><li>每隔多久检查一次缓存中缓存项的有效性,默认为60秒</li></ul></li><li><p><code>open_file_cache_min_uses number;</code></p></li><li><ul><li>缓存项在非活动其限内最少应该被访问的次数</li></ul></li></ul><h2 id="二、ngx-http-access-module模块"><a href="#二、ngx-http-access-module模块" class="headerlink" title="二、ngx_http_access_module模块"></a><span id="ngx_http_access_module">二、ngx_http_access_module模块</span></h2><h4 id="1、基于用户IP的权限控制"><a href="#1、基于用户IP的权限控制" class="headerlink" title="1、基于用户IP的权限控制"></a>1、基于用户IP的权限控制</h4><ul><li><p><code>allow address | CIDR | unix: | all;</code> 允许</p></li><li><p><code>deny address | CIDR | unix: | all;</code> 拒绝</p></li><li><ul><li><p>应用上下文件:http,server,location,limit_except</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">  location / &#123;</span><br><span class="line">      deny 192.168.1.1;</span><br><span class="line">      allow 192.16.1.0/24;</span><br><span class="line">      allow 10.1.1.0/16;</span><br><span class="line">      allow 2001:0db8::32;</span><br><span class="line">      deny all;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、ngx-http-auth-basic-module模块"><a href="#三、ngx-http-auth-basic-module模块" class="headerlink" title="三、ngx_http_auth_basic_module模块"></a><span id="ngx_http_auth_basic_module">三、ngx_http_auth_basic_module模块</span></h2><h4 id="1、基于Basic认证的权限控制"><a href="#1、基于Basic认证的权限控制" class="headerlink" title="1、基于Basic认证的权限控制"></a>1、基于Basic认证的权限控制</h4><ul><li><p><code>auth_basic string | off;</code></p></li><li><ul><li>用户定义认证的名称,string为所给定字符,其作用在于认证时显示的提示信息</li></ul></li><li><p><code>auth_basic_user_file FILE;</code></p></li><li><ul><li>实现用户认证的用户及帐号文件,文件格式如下(需手动创建):</li><li>密码可以使用httpd程序自带的工具htpasswd创建</li></ul></li></ul><h2 id="四、ngx-http-log-module模块的配置-访问日志"><a href="#四、ngx-http-log-module模块的配置-访问日志" class="headerlink" title="四、ngx_http_log_module模块的配置(访问日志)"></a><span id="ngx_http_log_module">四、ngx_http_log_module模块的配置(访问日志)</span></h2><h4 id="1、访问日志控制"><a href="#1、访问日志控制" class="headerlink" title="1、访问日志控制"></a>1、访问日志控制</h4><ul><li><p><code>log_format name string....;</code></p></li><li><ul><li>定义日志格式及其名称,日志格式一般通过调用内置变量来定义,默认格式为combined</li></ul></li><li><p><code>access_log path [format[buffer=size [flush=time]]];</code></p></li><li><p><code>access_log off</code></p></li><li><ul><li>定义日志文件路径,格式名称以及缓存大小和刷写时间间隔,建议定义缓冲以提升性能</li></ul></li><li><p><code>open_log_file_cache max=N [inactive=time] [min_uses] [valid=time];</code></p></li><li><p><code>open_log_file_cache off;</code></p></li></ul><h2 id="五、ngx-http-stub-status-module模块"><a href="#五、ngx-http-stub-status-module模块" class="headerlink" title="五、ngx_http_stub_status_module模块"></a><span id="ngx_http_stub_status_module">五、ngx_http_stub_status_module模块</span></h2><h4 id="1、nginx自身status的信息配置"><a href="#1、nginx自身status的信息配置" class="headerlink" title="1、nginx自身status的信息配置"></a>1、nginx自身status的信息配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 1 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 2 2 18 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br></pre></td></tr></table></figure><h6 id="各参数说明"><a href="#各参数说明" class="headerlink" title="各参数说明"></a>各参数说明</h6><ul><li>active connections : 当前活动的客户端连接数,包括等待的.</li><li>accepts : 已接受的客户端的连接总数量</li><li>handled : 已处理完成的客户端连接请求总数量</li><li>requests : 客户端总的请求数</li><li>reading : 当前正在读取的客户端请求报文首部信息的数量</li><li>writing : 当前正在向客户端发送响应报文的连接数量</li><li>wating : 等待其发出请求的空闲连接数量</li></ul><h2 id="六、ngx-http-referer-module模块"><a href="#六、ngx-http-referer-module模块" class="headerlink" title="六、ngx_http_referer_module模块"></a><span id="ngx_http_referer_module">六、ngx_http_referer_module模块</span></h2><blockquote><p>基于请求报文中的referer首部的值, 做访问控制 ,可以防止盗链,其只应用于server,location上下文</p></blockquote><ul><li><p><code>referer_hash_bucket_size SIZE;</code></p></li><li><ul><li>可以放多个缓存我要上,默认是64</li></ul></li><li><p><code>referer_hash_max_size SIZE;</code></p></li><li><ul><li>默认2048</li></ul></li><li><p><code>valid_referers none|blocked|server_names|string...;</code></p></li><li><ul><li>none : 请求的报文不存在referer首部</li><li>blocked : 请求报文中存在referer首部,但其没有有效值,或其值非以<a href="">http:&#x2F;&#x2F;或https开头</a></li><li>server_names :其值为一个主机名</li><li>arbitrary string : 直接字符串,可以使用*号匹配</li><li>rugular expression : 以~起始的正则表达式</li></ul></li></ul><h2 id="七、ngx-http-ssl-module模块"><a href="#七、ngx-http-ssl-module模块" class="headerlink" title="七、ngx_http_ssl_module模块"></a><span id="ngx_http_ssl_module">七、ngx_http_ssl_module模块</span></h2><ul><li><p><code>listen 443 ssl;</code></p></li><li><ul><li>在指定端口上启用必须ssl连接</li></ul></li><li><p><code>server_name www.zhenping.me;</code></p></li><li><ul><li>ssl主机的FQDN名称</li></ul></li><li><p><code>ssl_certificate cert.pem;</code></p></li><li><ul><li>ssl的公钥</li></ul></li><li><p><code>ssl_certificate_key cert.key;</code></p></li><li><ul><li>ssl的私钥</li></ul></li><li><p><code>ssl_session_cache off | none | [builtin[:size]] [shard:name:size];</code></p></li><li><ul><li>默认使用shared模式</li><li>off : 禁止缓存 ,关闭缓存,不支持缓存功能</li><li>none :禁止缓存 ,不响应缓存</li><li>builtin : 使用openssl内置的ssl会话缓存 ,此机制为各worker私有</li><li>shared: 在各worker之间使用一个共享的缓存,name:独有名称,size:缓存空间大小, 默认为1M,可以调到10M</li></ul></li><li><p><code>ssl_session_timeout 5m;</code></p></li><li><ul><li>ssl会议超时时长,即ssl session cache中的缓存有效时长,默认为5m</li></ul></li><li><p><code>ssl_prefer_server_ciphers on;</code></p></li><li><ul><li>优先使用服务端选择的加密算法</li></ul></li><li><p><code>ssl on | off;</code></p></li><li><ul><li>启用或关闭ssl,若不在listen处定义，也可以在server{ }中定义ssl on; 来启用https服务</li></ul></li><li><p><code>ssl_buffer_size SIZE;</code></p></li><li><ul><li>ssl缓冲大小</li></ul></li><li><p><code>ssl_ciphers CIPHERS;</code></p></li><li><ul><li>指明由nginx使用的加密算法,可以是openssl库所支持各加密套件</li></ul></li><li><p><code>ssl_client_certificate file;</code></p></li><li><ul><li>需要验证客户端证书</li></ul></li><li><p><code>ssl_crl FILE;</code></p></li><li><ul><li>证书吊销列表</li></ul></li><li><p><code>ssl_protocols [sslv2][sslv3][tlsv1][tlsv1.1][tlsv1.2];</code></p></li><li><ul><li>使用哪些协议版本, 默认为TLSv1,TLSv1.1,TLSv1.2</li></ul></li><li><p><code>ssl_trusted_certificate FILE;</code></p></li><li><ul><li>信任的根证书</li></ul></li><li><p><code>ssl_session_ticket_key FILE;</code></p></li></ul><h2 id="八、ngx-http-rewrite-module模块"><a href="#八、ngx-http-rewrite-module模块" class="headerlink" title="八、ngx_http_rewrite_module模块"></a><span id="ngx_http_rewrite_module">八、ngx_http_rewrite_module模块</span></h2><blockquote><p>将请求的url基于正则表达式进行重写(URL重定向),在如下情况下可以使用:http转换成httpd服务(http→https),域名转换domain.tld →domain2.tld, URL转换uri → uri2,实现SEO搜索引擎优化效果…. 将用户请求的URL基于正则表达式进行重写</p></blockquote><ul><li><p><code>rewrite regex replacement [flag];</code></p></li><li><ul><li>last : 重写完成之后停止对当前uri的进一步处理,改为对新uri的新一轮处理(对URI的重写规则进行匹配,当检查到第一条匹配到的时候,进行重写.然后返回到重写规则的第一条位置进行重新匹配,如果有匹配到的再进行重写,默认只能10次匹配). 此过程用户端感受不到.</li><li>break : 对URI的重写规则进行匹配,只要匹配到就重写,不再进行再次匹配,此过程用户端感受不到.</li><li>redirect : 重写完成之后返回客户端一个临时重定向,由客户端对新的URI重新发起请求, 即302的状态码</li><li>permanent : 重写完成之后,会返回客户端一个永久的重写向,由客户端对新的URI重新发起请求,即301的状态码</li><li>PCRE正则表达式元字符</li><li>字符: .,[],[^]</li><li>次数: *,+,?,{m},{m,}{m,n}</li><li>位置锚定: ^,$</li><li>或者: |</li><li>分组: (), 后向引用: 2,…..</li><li>应用于server,location,if上下文</li><li>regex : 基于perl的正则表达式,用于匹配用户请求的URL;</li><li>replacement : 重写为的结果</li><li>flag:标志位</li></ul></li><li><p><code>if(condition) &#123;...&#125;</code> :条件判断,引用新的配置上下文</p></li><li><ul><li>-f,!-f : 是否存在且为普通文件</li><li>-d,!-d : 是否存在且为目录</li><li>-e,!-e : 是否存在</li><li>-x,!-x : 是否存在且可执行</li><li>&#x3D;&#x3D;, !&#x3D;</li><li>~ : 模式匹配,区分字符大小写</li><li>~* : 模式匹配,不区分字符大小写</li><li>!~ : 模式不匹配, 区分字符大小写</li><li>!~* : 模式不匹配,不区分字符大小写</li><li>condition比较表达式:</li><li>文件及目录判断:</li></ul></li><li><p><code>return</code> : 立即停止对请求的URI的处理,并返回指定的状态码</p></li><li><ul><li>returncode [text];</li><li>returncode URL</li><li>return URL;</li></ul></li><li><p><code>set</code> : 设定变量值,或者自定义变量</p></li><li><ul><li>set $variable value;</li></ul></li><li><p><code>rewrite_log on | off;</code></p></li><li><ul><li>是否将重写日志记录errorlog中,默认为关闭(调试方法:错误日志debug,并开启rewrite_log)</li></ul></li></ul><h2 id="九、ngx-http-gzip-module模块"><a href="#九、ngx-http-gzip-module模块" class="headerlink" title="九、ngx_http_gzip_module模块"></a><span id="ngx_http_gzip_module">九、ngx_http_gzip_module模块</span></h2><ul><li><p><code>gzip on | off;</code></p></li><li><ul><li>启用或禁用gzip压缩响应报文</li></ul></li><li><p><code>gzip_buffers number size;</code></p></li><li><ul><li>default 32位系统4k,64位系统8k</li></ul></li><li><p><code>gzip_comp_level LEVEL;</code></p></li><li><ul><li>压缩比,1-9,默认为1</li></ul></li><li><p><code>gzip_disable regex ...;</code></p></li><li><ul><li>regex是为用于匹配客户端响应器类型的正则表达式,表示对何种浏览器禁止使用压缩功能</li></ul></li><li><p><code>gzip_min_length LENGTH;</code></p></li><li><ul><li>触发压缩功能的响应报文的最小长度</li></ul></li><li><p><code>gzip_http_version 1.0 | 1.1;</code></p></li><li><ul><li>设定启用压缩功能的最小版本</li></ul></li><li><p><code>gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etg | auth | any ...;</code></p></li><li><ul><li>定义对客户端请求的具有何种请求属性的资源启用压缩功能,如expired表示:对由于使用expire首部而无法缓存的对象启用压缩功能</li></ul></li><li><p><code>gzip_types mime.type;</code></p></li><li><ul><li>指明对那些类型的资源进行压缩</li></ul></li></ul><h2 id="十、ngx-http-fastcgi-module模块"><a href="#十、ngx-http-fastcgi-module模块" class="headerlink" title="十、ngx_http_fastcgi_module模块"></a><span id="ngx_http_fastcgi_module">十、ngx_http_fastcgi_module模块</span></h2><blockquote><p>fastcgi_module只能对后端的一台应用服务器进行反代,如果需要给多台应用服务器进行反代实现负载,需借助upstream模块定义一组服务器,由fastcgi功能引用来完成, lnmp的架构中, ningx只支持fastcgi的模式连接后端php服务器,不能将应用服务运行为一个子模块的方式.nginx不支持动态加载模块机制(DSO),所以需要编译php工作为fpm机制时,将ngnx_http_fastcgi_module编译到nginx程序中,在php编译时需使用 —enable-fpm,将Php设置为fpm模式.</p></blockquote><p>LNMP架构仅支持一种nginx+php的结合方式,实现方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location ~* \.php$ &#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、fastcgi模块指令"><a href="#1、fastcgi模块指令" class="headerlink" title="1、fastcgi模块指令"></a>1、fastcgi模块指令</h4><ul><li><p><code>fastcgi_pass address;</code></p></li><li><ul><li>address为fastcgi server监听的地址,如: fastcgi_pass localhost:9000;</li></ul></li><li><p><code>fastcgi_index NAME;</code></p></li><li><ul><li>定义fastcgi应用的默认主机,如: fastcgi_index index.php;</li></ul></li><li><p><code>fastcgi_param PARAMETER VALUE[if_not_empty];</code></p></li><li><ul><li>用户定义客户端请求的哪些属性传递给后端fastcti_server</li></ul></li><li><p><code>fastcgi_pass_header field;</code></p></li><li><ul><li>允许把fastcgi的响应首部直接发送给客户端</li></ul></li><li><p><code>fastcgi_cache_path path [levels=levels][use_temp_path=on|off] keys_zone=name:size [inactive=time][max_szie=size];</code></p></li><li><ul><li>缓存对象名字都以16进制进行编码,故一级目录一般为16个或者256个</li><li>元数据存在内存中,即为keys_zone</li><li>数据存在硬盘,即为path</li><li>用于定义缓存,缓存 空间等,可应用于http上下文,需要运行php的用户对path有写权限.</li><li>缓存机制:</li><li>levels&#x3D;#[:#[:#]] : 表示可以使用三级目录进行保存</li><li>keys_zone&#x3D;name:size : name名称要全局唯一,cache的标识符</li><li>inactive&#x3D;time : 缓存的非活动时间,缓存的访问次数在指定的time内比较少,就需要清理出去</li><li>max-size : 缓存空间上限,指磁盘的缓存空间上限</li></ul></li><li><p><code>fastcgi_cache zone | off;</code></p></li><li><ul><li>调用定义过的缓存,zone即为通过fastcgi_cache_path定义缓存时其keys_zone参数中的name</li></ul></li><li><p><code>fastcgi_cache_key string;</code></p></li><li><ul><li>定义那些键需要进行缓存,如用户访问的URI,如:fastcgi_cache_key $request_uri;</li></ul></li><li><p><code>fastcgi_cache_methods GET|HEAD|POST...;</code></p></li><li><ul><li>为何种请求方法对应的请求进行缓存,默认为get和head</li></ul></li><li><p><code>fastcgi_cache_min_uses number;</code></p></li><li><ul><li>缓存项的最少使用次数,默认为1次</li></ul></li><li><p><code>fastcgi_cache_revalidate on |off;</code></p></li><li><p><code>fastcgi_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | off;</code></p></li><li><ul><li>是否可使用stale缓存项(不新鲜)响应用户请求,默认是off</li></ul></li><li><p><code>fastcgi_cache_valid [code...] time;</code></p></li><li><ul><li>对不同响应码的响应设定可缓时长</li><li>缓存的设定及调用</li></ul></li></ul><h2 id="十一、ngx-http-proxy-module模块"><a href="#十一、ngx-http-proxy-module模块" class="headerlink" title="十一、ngx_http_proxy_module模块"></a><span id="ngx_http_proxy_module">十一、ngx_http_proxy_module模块</span></h2><p>反向代理(reverse proxy)方式是指以代理服务器来接受internet上的连接请求,然后将请求转发给内部网络上的服务器, 并将从服务器上得到的结果返回给internet上请求连接的客户端,此时站在服务器角度来看,代理服务器对外就表现为一个反向代理服务器,对反向代理服务器的攻击并不会使得后端内网web服务器上网页信息破坏,增强了web服务器的安全性</p><ul><li><p><code>proxy_pass URL;</code></p></li><li><ul><li>应用上下文:Location,if in location, limit_except</li><li>如果location URI时使用正则表达模式匹配时, 其proxy_pass后面的路径一定不能带URI地址</li><li>如果location 中有rewrite重写,在proxy_pass后面的连接地址一定不能带URI地址, 那怕有&#x2F;也不可以</li></ul></li><li><p><code>proxy_pass_header field;</code></p></li><li><ul><li>传递首部给客户端</li></ul></li><li><p><code>proxy_hide_header field;</code></p></li><li><ul><li>有意隐藏首部</li></ul></li><li><p><code>proxy_set_header field value;</code></p></li><li><ul><li>proxy_set_header HOST $http_host</li><li>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</li><li>request_host传递给host变量,再由代理服务器发起请求的时候,加入host首部(有的情况下代理服务器与backend服务器连接使用的IP地址, 这种传递host参数的情况下,代理发起的访问,都会转为默认的虚拟主机)</li><li>将客户端的真实IP地址赋值给X-Forwarded-For变量,代理请求的时候,将发送给后端的backend server.如果中间有多层代理 , 每经过一层代理时,代理服务器都会将在后面增加自己的IP地址,并以分号分隔开来</li><li>用于proxy_server向backend_server发请求报文时,将某请求首部重新赋值,或在原有值后面添加一个新的值</li></ul></li><li><p><code>proxy_cache_path path [levels=levels][use_temp_path=on|off] keys_zone=name:size [inactive=time][max_size=size];</code></p></li><li><ul><li>定义缓存,可用于http上下文</li></ul></li><li><p><code>proxy_cache zone | off;</code></p></li><li><ul><li>调用缓存,可用于http,server,location上下文</li></ul></li><li><p><code>proxy_cache_key string;</code></p></li><li><ul><li>$scheme : 所使用的协议</li><li>$proxy_host : 请求的那个代理服务器地址</li><li>$request_uri : 向那个URI发出的请求,带参数的: <a href="http://www.zhenping.me/?username=1&amp;userid=1">www.zhenping.me?username=1&amp;userid=1</a></li><li>$uri : 向那个URI发出的请求,不带参数</li><li>定义缓存键,默认为:proxy_cache_key proxy_host$request_uri;</li></ul></li><li><p>&#96;proxy_cache_valid [code…] time;</p></li><li><ul><li>对不同响应码设定其可缓存时长</li></ul></li><li><p><code>proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 |http_503 | http_504 | http_403 | http_404 | off...;</code></p></li><li><ul><li>定义如果后端服务器连接不成功,是否可以使用缓存数据进行响应</li></ul></li><li><p><code>proxy_connect_timeout time;</code></p></li><li><ul><li>定义后端服务器建立连接的超时时长,默认为60s,此值不应该超过75s</li></ul></li><li><p><code>proxy_send_timeout time;</code></p></li><li><ul><li>把请求发送给后端服务器的超时时长,默认为60s</li></ul></li><li><p><code>proxy_read_timeout time;</code></p></li><li><ul><li>等待后端服务器发送响应报文的超时时长,如果有大量的502,就需要考虑这个时长是否过短</li></ul></li></ul><h2 id="十二、ngx-http-headers-module模块"><a href="#十二、ngx-http-headers-module模块" class="headerlink" title="十二、ngx_http_headers_module模块"></a><span id="ngx_http_headers_module">十二、ngx_http_headers_module模块</span></h2><ul><li><p><code>add_header_name value [always];</code> : (其可操作响应报文首部)</p></li><li><ul><li><p>向响应报文添加自定义首部,并为其赋值,应用上下文为:http,server,location, if in location</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Via $server_addr;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>expires [modified] time;</code></p></li><li><p><code>expires epoch | max | off;</code></p></li><li><ul><li>默认expires off, 允许或禁止向响应报文的cache-control或expires首部添加新值或修改其值</li></ul></li></ul><h2 id="十三、ngx-http-upstream-module模块"><a href="#十三、ngx-http-upstream-module模块" class="headerlink" title="十三、ngx_http_upstream_module模块"></a><span id="ngx_http_upstream_module">十三、ngx_http_upstream_module模块</span></h2><blockquote><p>用于将多个服务器定义成服务器组,而由proxy_pass fastcgi_pass等指令引用,应用于http上下文</p></blockquote><ul><li><p><code>upstream name &#123;...&#125;;</code></p></li><li><ul><li>定义一个后端服务器组,name为组名称,仅用于http上下文</li></ul></li><li><p><code>server address [parameters];</code></p></li><li><ul><li>weight&#x3D;number : 定义服务器权重,默认为1</li><li>max_fails&#x3D;number : 最大失败连接尝试次数(做健康状态检测),失败连接超时时长由fail_timeout参数指定</li><li>fail_timeout&#x3D;number : 等待目标服务器发送响应的时长,总的超时时长</li><li>backup : 备用服务器,所有主服务器均故障时,才启用此服务器(即sorry server)</li><li>down : 手动标记其不再处理任何用户请求</li><li>在upstream中定义一个服务器及相关参数,仅能用于upstream上下文</li><li>常用参数:</li></ul></li><li><p><code>ip hash</code></p></li><li><ul><li>源地址hash,把来自同一个IP地址的请求始终发往同一个backend server,除非backend server不可用</li></ul></li><li><p><code>least_conn;</code></p></li><li><ul><li>最少连接,当各server权重不同时,即为加权最少连接</li></ul></li><li><p><code>match name &#123;...&#125;</code></p></li><li><ul><li>status code[code…]; : 期望的响应状态码</li><li>header HEADER[oprator value] : 期望存在响应首部,也可对期望的响应首部值基于比较操作符和值进行比较</li><li>body : 期望响应报文的主体部分应该有的内容</li><li>对backend server做健康状态检测时,定义其结果判断机制,只能用于http上下文</li><li>常用参数</li></ul></li><li><p><code>health_check [parameters];</code> (较新版本中的nginx支持)</p></li><li><ul><li>interval&#x3D;time :检测的时间频率,默认为5秒钟</li><li>fails&#x3D;number : 判定服务器不可用的失败检测次数,默认为1次</li><li>passes&#x3D;number : 判定服务器可用的检测次数,默认为1次</li><li>uri&#x3D;URI; : 应用层的检测,做健康状态检测测试的目标URI,默认为”&#x2F;“</li><li>match&#x3D;name : 健康状态检测的结果评估调用(match name {…}参数)指定的match配置块</li><li>健康状态检测机制,应用上下文:location</li><li>常用参数</li></ul></li><li><p><code>hash key[consistent];</code></p></li><li><ul><li>$cookie_name : 将一个用户的请求始终发往同一个backend server,能实现会话绑定的功能,此处的name为cookie中某些参数的名称,此处常用的有:cookie_username.</li><li>$request_method</li><li>$request_uri : 将对同一个uri的请求始终发往同一个backend server,后端为cache server时特别有用</li><li>$uri</li><li>应用于upstream中,指明基于hash方式进行调度时,其hash键, hash $remote_addr 相当于ip_hash;</li><li>常用的hash key:</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradle 环境安装配置</title>
      <link href="/2017/07/19/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20gradle%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/07/19/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20gradle%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。[2]<br>当前其支持的语言限于Java、Groovy和Scala[3]，计划未来将支持更多的语言。</p></blockquote><h3 id="特性（优势）"><a href="#特性（优势）" class="headerlink" title="特性（优势）"></a>特性（优势）</h3><ul><li>自动处理包相依关系 - 取自 Maven Repos 的概念</li><li>自动处理布署问题 - 取自 Ant 的概念</li><li>条件判断写法直觉 - 使用 Groovy 语言</li></ul><p> Java 开发者常用 Maven 和 Ant 等工具进行封装布署的自动化，或是两者兼用，不过这两个包彼此有优缺点，如果频繁改变相依包版本，使用 Ant 相当麻烦，如果琐碎工作很多，Maven 功能不足，而且两者都使用 XML 描述，相当不利于设计 if、switch 等判段式，即使写了可读性也不佳，而 Gradle 改良了过去 Maven、Ant 带给开发者的问题，至今也成为 Android Studio 内置的封装布署工具。</p><p> Springboot 也在积极拥抱gradle</p><ul><li><a href="https://gradle.org/">gradle官网</a></li></ul><h3 id="环境部署（Windows）"><a href="#环境部署（Windows）" class="headerlink" title="环境部署（Windows）"></a>环境部署（Windows）</h3><ol><li><p>下载gradle安装文件 <a href="https://gradle.org/install/">官网下载</a> 下载后，解压</p></li><li><p>安装jdk （要求jdk1.7以上）</p></li><li><p>“计算机”–&gt;“属性”–&gt;“高级系统设置” –&gt;“环境变量”。</p></li><li><p>将解压目录\gradle-4.0.1\bin的配置到path中。（或者先配置GRADLE_HOME，再配置%GRADLE_HOME%\bin到path中）</p></li><li><p>检查是否安装成功</p><pre><code> &gt; gradle -v  ------------------------------------------------------------ Gradle 4.0.1 ------------------------------------------------------------</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令整理</title>
      <link href="/2017/07/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2017/07/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git常用命令整理，逐步完善自己经常使用的命令，方便查找，总结</p></blockquote><h2 id="先贴一张网上搜集到的git图"><a href="#先贴一张网上搜集到的git图" class="headerlink" title="先贴一张网上搜集到的git图"></a>先贴一张网上搜集到的git图</h2><p><img src="https://aimak.cn/blog_img/tools/git%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86.pic.jpg"></p><h2 id="git命令速查"><a href="#git命令速查" class="headerlink" title="git命令速查"></a>git命令速查</h2><pre><code>git init                                                  # 初始化本地git仓库（创建新仓库）git config --global user.name &quot;xxx&quot;                       # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件git config --global color.ui true                         # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m &#39;xxx&#39;                                       # 提交git commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）git commit -am &#39;xxx&#39;                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log --stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff --cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch                                                # 显示本地分支git branch --contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch --merged                                       # 显示所有已合并到当前分支的分支git branch --no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features/performance                         # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin/master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支git push --tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch --all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态git log --pretty=format:&#39;%h %s&#39; --graph                   # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”git grep -e &#39;#define&#39; --and -e SORT_DIRENTgit gcgit fsck</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半年总结(2017)</title>
      <link href="/2017/07/05/%E6%9D%82%E8%AE%B0/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93(2017)/"/>
      <url>/2017/07/05/%E6%9D%82%E8%AE%B0/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93(2017)/</url>
      
        <content type="html"><![CDATA[<h1 id="半年总结"><a href="#半年总结" class="headerlink" title="半年总结"></a>半年总结</h1><blockquote><p>2017半年过去了，利用思维导图的方式稍微总结了一下，以便回顾总结，发现不足之处，逐步提高。<br>知识技能上，本是后端上半年却有点”不务正业”，APP上半年还在酝酿中，还没有涉及运维，运营时，自己感觉应该提前梳理出来，趁着后端上不忙碌，自己去熟悉总结了系统监控相关内容，集中式日志监控相关，主要熟悉了一下ELK体系，和阿里云的日志监控等，前端web，对angular,vue,react进行调研，现阶段，Vue应该是最容易入门及开展工作的。于是就了解熟悉了一些前端架构及Vue，并搭建了后台及运营管理的WEB平台。</p></blockquote><p>心得及收获:</p><p>1.拥抱开源，真正关注开源</p><p>2.贡献了第一个npm包</p><p>3.技术变更速度真快…,必须不断学习。</p><p>…</p><p>–不足:<br>1.知识深度不够，需要深层次理解一些底层原理</p><p>2.还是有些粗心大意，通过备忘录，checklist，多自我检查。</p><p>3.自我表达能力亟待提高。</p><p>4.生活上，自己的忙碌，让爸妈操心太多，不够关心家人。</p><p>想要总结的还太多，还是要点点滴滴积累，</p><p>希望下半年家人都能健健康康，自己工作，生活上能有更大的突破。</p><hr><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fhelozhx5dj21gs1qktkl.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-oss-upload 上传到阿里云的oss组件包（npm）</title>
      <link href="/2017/06/18/%E5%89%8D%E7%AB%AF/%20vue-oss-upload%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84oss%E7%BB%84%E4%BB%B6%E5%8C%85%EF%BC%88npm%EF%BC%89/"/>
      <url>/2017/06/18/%E5%89%8D%E7%AB%AF/%20vue-oss-upload%20%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84oss%E7%BB%84%E4%BB%B6%E5%8C%85%EF%BC%88npm%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近使用vue比较多，项目过程中遇到了，上传图片、视频到阿里云的OSS存储服务，<span id="more"></span>发现目前现成的上传组件，都不太支持，于是自己各种查看阿里云的文档及google，百度，自己写了一套符合自己的业务的上传组件，想到其他小伙伴肯定也会遇到类似的问题，就花了些时间，把组件提取出来，上传到了npm。</p></blockquote><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>服务端提供接口，获取阿里云STS临时访问OSS的权限，初始化ossClient，调用oss的sdk进行上传。通过vue2.3重新引入的sync特性返回上传结果</p><p>使用组件时，需要导入Css样式。自己不擅长写样式，写的比较挫，希望可以被改进，哈哈</p><ul><li>TODO: 上传的进度，等尚未实现，只有最终上传结果</li></ul><p><a href="https://cn.vuejs.org/"><img src="https://img.shields.io/badge/Vue-2.x-brightgreen.svg" alt="Vue 2.3.0+"></a></p><p><a href="https://nodei.co/npm/vue-oss-upload/"><img src="https://nodei.co/npm/vue-oss-upload.png?downloads=true&downloadRank=true&stars=true" alt="NPM"></a></p><ul><li><a href="https://github.com/fantasykai/vue-ossUpload">github 地址</a></li></ul><h1 id="vue-oss-upload"><a href="#vue-oss-upload" class="headerlink" title="vue-oss-upload"></a>vue-oss-upload</h1><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="需要依赖阿里云的oss的SDK-可以在index-html中引入"><a href="#需要依赖阿里云的oss的SDK-可以在index-html中引入" class="headerlink" title="需要依赖阿里云的oss的SDK,可以在index.html中引入"></a>需要依赖阿里云的oss的SDK,可以在index.html中引入</h3><p>  <code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://gosspublic.alicdn.com/aliyun-oss-sdk.min.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="组件依赖vue2-3以上的版本"><a href="#组件依赖vue2-3以上的版本" class="headerlink" title="组件依赖vue2.3以上的版本"></a>组件依赖vue2.3以上的版本</h3><p>vue2.3 重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。</p><p><a href="https://cn.vuejs.org/v2/guide/components.html#counter-event-example">.sync 修饰符</a></p><h2 id="Use-Setup"><a href="#Use-Setup" class="headerlink" title="Use Setup"></a>Use Setup</h2><h3 id="Install-vue-oss-upload"><a href="#Install-vue-oss-upload" class="headerlink" title="Install vue-oss-upload"></a>Install vue-oss-upload</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-oss-upload --save</span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code> props: &#123;      // 需要引入阿里云OSS的SDK，并初始化ossClient      ossClient: &#123;        type: Object,        toWay: false      &#125;,      // 是非支持多文件上传      multiple: &#123;        type: Boolean,        twoWay: false      &#125;,      // 上传组件id，区别页面中多次使用上传组件      id: &#123;        type: String,        twoWay: false      &#125;,      // 上传成功后的uri      url: &#123;        type: String,        twoWay: true      &#125;,       // 上传结果      uploadRes: &#123;        type: Boolean,        twoWay: true      &#125;,      // 上传按钮的名称      inputName: &#123;        type: String,      &#125;,      // 上传文件的名称      uploadFileName: &#123;        type: String,      &#125;,      // 上传到OSS的路径      path: &#123;        type: String,      &#125;,    &#125;,</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;upload-ali-oss :url.sync=&quot;uploadForm.content.path&quot; :multiple=&quot;true&quot;                        :id=&quot;uploadForm.id&quot;                        :ossClient=&quot;this.ossClient&quot;                        :inputName=&quot;uploadForm.inputName&quot;                        :uploadFileName=&quot;uploadForm.uploadFileName&quot;                        :path=&quot;uploadForm.upload.path&quot;                        :uploadRes.sync=&quot;uploadForm.uploadRes&quot;        &gt;&lt;/upload-ali-oss&gt;        &lt;div v-show=&quot;uploadForm.uploadRes&quot;             v-text=&quot;uploadForm.content.path&quot;&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;img v-if=&quot;uploadForm.uploadRes&quot;                 :src=&quot;this.imgSrc&quot;&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import VueUploadAliOSS from &#39;vue-oss-upload&#39;;    import Css from &#39;vue-oss-upload/dist/vue-alioss-upload.min.css&#39;    export default &#123;        name: &#39;app&#39;,        components: &#123;            &#39;upload-ali-oss&#39;: VueUploadAliOSS        &#125;,        data() &#123;            return &#123;                ossClient: Object,                uploadForm: &#123;                    id: &#39;imgFile&#39;,                    inputName: &#39;上传图片&#39;,// 自定义                    uploadFileName: &#39;2017063010192023&#39;,// 上传文件的名称                    content: &#123;                        path: &#39;&#39;,                    &#125;,                    upload: &#123;                        path: &#39;img/test/&#39;,// 自定义路径                    &#125;,                    uploadRes: false,                &#125;,                imgSrc: &#39;&#39;            &#125;        &#125;,        methods: &#123;            // 需要引入阿里云的ossSDK            //初始化OSS 权限, 建议后台提供获取oss临时权限的接口            initOSSAuth() &#123;                let Oss = OSS.Wrapper;                this.ossClient = new Oss(&#123;                    region: &#39;&#39;,                    accessKeyId: &#39;&#39;,                    accessKeySecret: &#39;&#39;,                    stsToken: &#39;&#39;,                    bucket: &#39;&#39;,                    endpoint: &#39;&#39;,                &#125;);            &#125;,            // 展示上传的内容（图片）            showUploadContent() &#123;                if (this.uploadForm.content.path) &#123;                    let path = this.uploadForm.content.path;                    var result = this.ossClient.signatureUrl(path, &#123;                        response: &#123;                            // &#39;content-disposition&#39;: &#39;attachment; filename=&quot;&#39; + filename + &#39;&quot;&#39;                            &#39;Content-Type&#39;: &#39;image/jpeg&#39;                        &#125;                    &#125;);                    this.imgSrc = result;                &#125;            &#125;        &#125;,        watch: &#123;            &#39;uploadForm.content.path&#39; (val, oldVal) &#123;//                console.log(&#39;new: %s, old: %s&#39;, val, oldVal)                if (&#39;&#39; !== val) &#123;                    this.showUploadContent();                &#125;            &#125;        &#125;,        mounted() &#123;            this.initOSSAuth();        &#125;    &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h3 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h3><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fgqi3miznuj20kj0l4k4f.jpg"></p><h1 id="Author-Blog"><a href="#Author-Blog" class="headerlink" title="Author Blog"></a>Author Blog</h1><p><a href="https://fantasykai.cc/">kai.fantasy</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解WebAssembly</title>
      <link href="/2017/06/17/%E5%89%8D%E7%AB%AF/%E7%90%86%E8%A7%A3WebAssembly/"/>
      <url>/2017/06/17/%E5%89%8D%E7%AB%AF/%E7%90%86%E8%A7%A3WebAssembly/</url>
      
        <content type="html"><![CDATA[<h1 id="几张图让你看懂WebAssembly"><a href="#几张图让你看懂WebAssembly" class="headerlink" title="几张图让你看懂WebAssembly"></a>几张图让你看懂WebAssembly</h1><p>最近，WebAssembly 在 Java 圈非常的火！人们都在谈论它多么多么快，怎样怎样改变 Web 开发领域。但是没有人讲他到底为什么那么快。在这篇文章里，我将会帮你了解 WebAssembly 到底为什么那么快。</p><p>第一，我们需要知道它到底是什么！WebAssembly 是一种可以使用非 Java 编程语言编写代码并且能在浏览器上运行的技术方案。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c397f83106e5460091a5d65fbf8c3060_th.png" alt="img"></p><p>当大家谈论起 WebAssembly 时，首先想到的就是 Java。现在，我没有必须在 WebAssembly 和 Java 中选一个的意思。实际上，我们期待开发者在一个项目中把 WebAssembly 和 Java 结合使用。但是，比较这两者是有用的，这对你了解 WebAssembly 有一定帮助。</p><p>\1. 一点点性能历史</p><p>1995 年 Java 诞生。它的设计时间非常短，前十年发展迅速。</p><p>紧接着浏览器厂商们就开始了更多的竞争。</p><p>2008年，人们称之为浏览器性能大战的时期开始了。很多浏览器加入了即时编译器，又称之为JITs。在这种模式下，Java在运行的时候，JIT 选择模式然后基于这些模式使代码运行更快。</p><p>这些 JITs 的引入是浏览器运行代码机制的一个转折点。所有的突然之间，Java 的运行速度快了10倍。</p><p><img src="http://img.mp.sohu.com/upload/20170518/199869a47f53403db81c516d1d382028_th.png" alt="img"></p><p>随着这种改进的性能，Java 开始被用于意想不到的事情，比如使用Node.js和Electron构建应用程序。</p><p>现在 WebAssembly 可能是的另一个转折点。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d50035df838b41e7a880d1e853c8d76d_th.png" alt="img"></p><p>在我们没有搞清楚 Java 和 WebAssembly 之间的性能差前，我们需要理解 JS 引擎所做的工作。</p><p>\2. Java 是如何在浏览器中运行的呢？</p><p>作为一个开发人员，您将Java添加到页面时，您有一个目标并遇到一个问题。</p><ul><li>目标：你想要告诉计算机做什么</li><li>问题：你和计算机使用不通的语言。</li></ul><p>您说的是人类的语言，计算机说的是机器语言。尽管你不认为 Java 或者其他高级语言是人类语言，但事实就是这样的。它们的设计是为了让人们认知，不是为机器设计的。</p><p>所以Java引擎的工作就是把你的人类语言转化成机器所理解的语言。</p><p>我想到电影《Arrival》，这就像人类和外星人进行交谈。</p><p><img src="http://img.mp.sohu.com/upload/20170518/67ceb7bfa4294effa890d6d8a7406eec_th.png" alt="img"></p><p>在这部电影中，人类语言不能从逐字翻译成外星语言。他们的语言反映出两种对世界不同的认知。人类和机器也是这样。</p><p>所以，怎么进行翻译呢？</p><p>在编程中，通常有两种翻译方法将代码翻译成机器语言。你可以使用解释器或者编译器。</p><p>使用解释器，翻译的过程基本上是一行一行及时生效的。</p><p><img src="http://img.mp.sohu.com/upload/20170518/98882314037d4f4d90ae8e7537fa3c94_th.png" alt="img"></p><p>编译器是另外一种工作方式，它在执行前翻译。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c4fcbfd4e975496c9c09ddb31f3cf672_th.png" alt="img"></p><p>每种翻译方法都有利弊。</p><p>2.1 解释器的利弊</p><p>解释器很快的获取代码并且执行。您不需要在您可以执行代码的时候知道全部的编译步骤。因此，解释器感觉与 Java 有着自然的契合。web 开发者能够立即得到反馈很重要。</p><p>这也是浏览器最开始使用 Java 解释器的原因之一。</p><p>但是实用解释器的弊端是当你运行相同的代码的时候。比如，你执行了一个循环。然后你就会一遍又一遍的做同样的事情。</p><p>2.2 编译器的利弊</p><p>编译器则有相反的效果。在程序开始的时候，它可能需要稍微多一点的时间来了解整个编译的步骤。但是当运行一个循环的时候他会更快，因为他不需要重复的去翻译每一次循环里的代码。</p><p>因为解释器必须在每次循环访问时不断重新转换代码，作为一个可以摆脱解释器低效率的方法，浏览器开始将编译器引入。</p><p>不同的浏览器实现起来稍有不同，但是基本目的是相同的。他们给 Java 引擎添加了一个新的部分，称为监视器（也称为分析器）。该监视器在 Java 运行时监控代码，并记录代码片段运行的次数以及使用了那些数据类型。</p><p>如果相同的代码行运行了几次，这段代码被标记为 “warm”。如果运行次数比较多，就被标记为 “hot”。</p><p>被标记为 “warm” 的代码被扔给基础编译器，只能提升一点点的速度。被标记为 “hot” 的代码被扔给优化编译器，速度提升的更多。</p><p><img src="http://img.mp.sohu.com/upload/20170518/3963d47dc81a4832918a8e65e107dade_th.png" alt="img"></p><p>了解更多，可以读 <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a></p><p>\3. 耗时比较：Java Vs. WebAssembly</p><p>这张图大致给出了现在一个程序的启动性能，目前 JIT 编译器在浏览器中很常见。</p><blockquote><p>该图显示了 JS 引擎运行程序花费的时间。显示的时间并不是平均的。这个图片表明，JS 引擎做的这些任务花费的时间取决于页面中 Java 做了什么事情。但是我们可以用这个图来构建一个心理模型。</p></blockquote><p><img src="http://img.mp.sohu.com/upload/20170518/0e7c178a93764f739671e7a82bc42120.png" alt="img"></p><p>每栏显示花费在特定任务上的时间。</p><ul><li>Parsing - 讲源码转换成解释器可以运行的东西所用的事情。</li><li>Compiling + optimizing - 花费在基础编译和优化编译上的时间。有一些优化编译的工作不在主线程，所以这里并不包括这些时间。</li><li>Re-optimizing - 当预先编译优化的代码不能被优化的情况下，JIT 将这些代码重新优化，如果不能重新优化那么久丢给基础编译去做。这个过程叫做重新优化。</li><li>Execution - 执行代码的过程</li><li>Garbage collection - 清理内存的时间</li></ul><p>一个重要的事情要注意：这些任务不会发生在离散块或特定的序列中。相反，它们将被交叉执行。比如正在做一些代码解析时，还执行者一些其他的逻辑，有些代码编译完成后，引擎又做了一些解析，然后又执行了一些逻辑，等等。</p><p>这种交叉执行对早期 Java 的性能有很大的帮助，早期的 Java 的执行就像下图一样：</p><p><img src="http://img.mp.sohu.com/upload/20170518/416ed043b72f44e9a4c059ab13bd89a8.png" alt="img"></p><p>一开始，当只有一个解释器运行 Java 时，执行速度相当缓慢。JITs 的引入，大大提升了执行效率。</p><p>监视和编译代码的开销是需要权衡的事情。如果 Java 开发人员按照相同的方式编写Java，解析和编译时间将会很小。但是，性能的提升使开发人员能够创建更大的Java应用程序。</p><p>这意味着还有改进的余地。</p><p>下面是 WebAssembly 如何比较典型 web 应用。</p><p><img src="http://img.mp.sohu.com/upload/20170518/e88618ea7fb0477e9155d0143b6575e1_th.png" alt="img"></p><p>浏览器的 JS 引擎有轻微的不同。我是基于 SpiderMonkey 来讲。</p><p>3.1 请求</p><p>这没有展示在图上，但是从服务器获取文件是会消耗时间的</p><p>下载执行与 Java 等效的 WebAssembly 文件需要更少的时间，因为它的体积更小。WebAssembly 设计的体积更小，可以以二进制形式表示。</p><p>即使使用 gzip 压缩的 Java文件很小，但 WebAssembly 中的等效代码可能更小。</p><p>所以说，下载资源的时间会更少。在网速慢的情况下更能显示出效果来。</p><p>3.2 解析</p><p>Java 源码一旦被下载到浏览器，源将被解析为抽象语法树（AST）。</p><p>通常浏览器解析源码是懒惰的，浏览器首先会解析他们真正需要的东西，没有及时被调用的函数只会被创建成存根。</p><p>在这个过程中，AST被转换为该 JS 引擎的中间表示（称为字节码）。</p><p>相反，WebAssembly 不需要被转换，因为它已经是字节码了。它仅仅需要被解码并确定没有任何错误。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c174c765cffc48aea914270ab46c0fc0_th.png" alt="img"></p><p>3.3 编译 + 优化</p><p>如前所述，Java 是在执行代码期间编译的。因为 Java 是动态类型语言，相同的代码在多次执行中都有可能都因为代码里含有不同的类型数据被重新编译。这样会消耗时间。</p><p>相反，WebAssembly 与机器代码更接近。例如，类型是程序的一部分。这是速度更快的一个原因：</p><ul><li>编译器不需要在运行代码时花费时间去观察代码中的数据类型，在开始编译时做优化。</li><li>编译器不需要去每次执行相同代码中数据类型是否一样。</li><li>更多的优化在 LLVM 最前面就已经完成了。所以编译和优化的工作很少。</li></ul><p><img src="http://img.mp.sohu.com/upload/20170518/dc75aae14a4743cda8b07788bfc8ccf4_th.png" alt="img"></p><p>3.4 重新优化</p><p>有时 JIT 抛出一个优化版本的代码，然后重新优化。</p><p>JIT 基于运行代码的假设不正确时，会发生这种情况。例如，当进入循环的变量与先前的迭代不同时，或者在原型链中插入新函数时，会发生重新优化。</p><p>在 WebAssembly 中，类型是明确的，因此 JIT 不需要根据运行时收集的数据对类型进行假设。这意味着它不必经过重新优化的周期。</p><p><img src="http://img.mp.sohu.com/upload/20170518/0c03cc06b07a4007bc522131579d59e0_th.png" alt="img"></p><p>3.5 执行</p><p>尽可能编写执行性能好的 Java。所以，你可能需要知道 JIT 是如何做优化的。</p><p>然而，大多数开发者并不知道 JIT 的内部原理。即使是那些了解 JIT 内部原理的开发人员，也很难实现最佳的方案。有很多时候，人们为了使他们的代码更易于阅读（例如：将常见任务抽象为跨类型工作的函数）会阻碍编译器优化代码。</p><p>正因如此，执行 WebAssembly 代码通常更快。有些必须对 Java 做的优化不需要用在 WebAssembly 上</p><p>另外，WebAssembly 是为编译器设计的。意思是，它是专门给编译器来阅读，并不是当做编程语言让程序员去写的。</p><p>由于程序员不需要直接编程，WebAssembly 提供了一组更适合机器的指令。根据您的代码所做的工作，这些指令的运行速度可以在10％到800％之间。</p><p><img src="http://img.mp.sohu.com/upload/20170518/cbbf6cb36a9147bbb4609277212b743e_th.png" alt="img"></p><p>3.6 垃圾回收</p><p>在 Java 中，开发者不需要担心内存中无用变量的回收。JS 引擎使用一个叫垃圾回收器的东西来自动进行垃圾回收处理。</p><p>这对于控制性能可能并不是一件好事。你并不能控制垃圾回收时机，所以它可能在非常重要的时间去工作，从而影响性能。</p><p>现在，WebAssembly 根本不支持垃圾回收。内存是手动管理的（就像 C&#x2F;C++）。虽然这些可能让开发者编程更困难，但它的确提升了性能。</p><p><img src="http://img.mp.sohu.com/upload/20170518/5e0ef2344f5b4b5382e3345fbb1a4900_th.png" alt="img"></p><p>总而言之，这些都是在许多情况下，在执行相同任务时WebAssembly 将胜过 Java 的原因。</p><p>在某些情况下，WebAssembly 不能像预期的那样执行，还有一些更改使其更快。我在另一篇文章中更深入地介绍了这些未来的功能。</p><p>\4. WebAssembly 是如何工作的？</p><p>现在，您了解开发人员为什么对 WebAssembly 感到兴奋，让我们来看看它是如何工作的。</p><p>当我谈到上面的 JIT 时，我谈到了与机器的沟通像与外星人沟通。</p><p><img src="http://img.mp.sohu.com/upload/20170518/b4e48c1abb9d4c24a4faa9ba8bbcf804_th.png" alt="img"></p><p>我现在想看看这个外星人的大脑如何工作 - 机器的大脑如何解析和理解交流内容。</p><p>这个大脑的一部分是专注于思考，例如算术和逻辑。有一部分脑部提供短期记忆，另一部分提供长期记忆。</p><p>这些不同的部分都有名字。</p><ul><li>负责思考的部分是算术逻辑单元（ALU）。</li><li>短期储存由寄存器（Registers）提供。</li><li>随机存储器（或RAM）来提供长期储存能力。</li></ul><p><img src="http://img.mp.sohu.com/upload/20170518/83ee9677b2a949a985b63b52ccb8389f_th.png" alt="img"></p><p>机器码中的语句被称为指令。</p><p>当一条指令进入大脑时会发生什么？它被拆分成了多个的部分并有特殊的含义。</p><p>被拆分成的多个部分分别进入不同的大脑单元进行处理，这也是拆分指令所依赖的方式。</p><p>例如，这个大脑从机器码中取出4-10位，并将它们发送到 ALU。ALU进行计算，它根据 0 和 1 的位置来确定是否需要将两个数相加。</p><p>这个块被称为“操作码”，因为它告诉 ALU 执行什么操作。</p><p><img src="http://img.mp.sohu.com/upload/20170518/88a3f256982748938fa8c707f8fa4a12_th.png" alt="img"></p><p>那么这个大脑会拿后面的两个块来确定他们所要操作的数。这两个块对应的是寄存器的地址。</p><p><img src="http://img.mp.sohu.com/upload/20170518/b9480bcd570b485097798d1b460c6a20_th.png" alt="img"></p><p>请注意添加在机器码上面的标注（ADD R1 R2），这使我们更容易了解发生了什么。这就是汇编。它被称为符号机器码。这样人类也能看懂机器码的含义。</p><p>您可以看到，这个机器的汇编和机器码之间有非常直接的关系。每种机器内部有不同的结构，所以每种机器都有自己独有的汇编语言。</p><p>所以我们并不只有一个翻译的目标。</p><p>相反，我们的目标是不同类型的机器码。就像人类说不同的语言一样，机器也有不同的语言。</p><p>您希望能够将这些任何一种高级编程语言转换为任何一种汇编语言。这样做的一个方法是创建一大堆不同的翻译器，可以从任意一种语言转换成任意一种汇编语言。</p><p><img src="http://img.mp.sohu.com/upload/20170518/043aeb5c166145ae9f39f42441031ab1_th.png" alt="img"></p><p>这样做的效率非常低。为了解决这个问题，大多数编译器会在高级语言和汇编语言之间多加一层。编译器将把高级语言翻译成一种更低级的语言，但比机器码的等级高。这就是中间代码（IR）。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d074ef3889144ab0a5ca04646d4b229e_th.png" alt="img"></p><p>意思就是编译器可以将任何一种高级语言转换成一种中间语言。然后，编译器的另外的部分将中间语言编译成目标机器的汇编代码。</p><p>编译器的“前端”将高级编程语言转换为IR。编译器的“后端”将 IR 转换成目标机器的汇编代码。</p><p><img src="http://img.mp.sohu.com/upload/20170518/c36feccdd6554799ba4da393083b2603_th.png" alt="img"></p><p>4.1 WebAssembly 适合在哪里使用？</p><p>您可能会将 WebAssembly 当做是另外一种目标汇编语言。这是真的，这些机器语言（x86，ARM等）中的每一种都对应于特定的机器架构。</p><p>当你的代码运行在用户的机器的 web 平台上的时候，你不知道你的代码将会运行在那种机器结构上。</p><p>所以 WebAssembly 和别的汇编语言是有一些不同的。所以他是一个概念机上的机器语言，不是在一个真正存在的物理机上运行的机器语言。</p><p>正因如此，WebAssembly 指令有时候被称为虚拟指令。它比 Java 代码更快更直接的转换成机器代码，但它们不直接和特定硬件的特定机器代码对应。</p><p>在浏览器下载 WebAssembly后，使 WebAssembly 的迅速转换成目标机器的汇编代码。</p><p><img src="http://img.mp.sohu.com/upload/20170518/d84a8a4c7ca14077b034a8cee345330c_th.png" alt="img"></p><p>如果想在您的页面里上添加 WebAssembly，您需要将您的代码编译成 .wasm 文件。</p><p>\5. 编译到 .wasm 文件</p><p>当前对 WebAssembly 支持最多的编译器工具链称是 LLVM。有许多不同的“前端”和“后端”可以插入到 LLVM 中。</p><p>注意：大多数 WebAssembly 模块开发者使用 C 和 Rust 编写代码，然后编译成 WebAssembly，但是这里有其他创建 WebAssembly 模块的途径。比如，这里有一个实验性工具，他可以帮你使用 Type 创建一个 WebAssembly 模块，你可以在这里直接编辑WebAssembly。</p><p>架设我们想通过 C 来创建 WebAssembly。我们可以使用 clang “前端” 从 C 编译成 LLVM 中间代码。当它变成 LLVM 的中间代码（IR）以后，LLVM 可以理解他，所以 LLVM 可以对代码做一些优化。</p><p>如果想让 LLVM 的 IR 变成 WebAssembly，我们需要一个 “后端”。目前 LLVM 项目中有一个正在开发中的。这个“后端”对做这件事情很重要，应该很快就会完成。可惜，它现在还不能用。</p><p>另外有一个工具叫做 Emen，它用起来比较简单。它还可以有比较有用的可以选择，比如说由 IndexDB 支持的文件系统。</p><p><img src="http://img.mp.sohu.com/upload/20170518/9fb176cae37a45289c06d50b8d4d9d9c_th.png" alt="img"></p><p>不管你使用的什么工具链，最终的结果都应该是以 .wasm 结尾的文件。来让我们看一下如何将它用在你的 web 页面。</p><p>\6. 在 Java 中加载一个 .wasm 组件</p><p>.wasm 文件是 WebAssembly 组件，它可以被 Java 加载。到目前为止，加载过程有点复杂。</p><blockquote><p>functionfetchAndInstantiate(url,importObject){</p><p>returnfetch(url).then(response &#x3D;&gt;</p><p>response.arrayBuffer()</p><p>).then(bytes &#x3D;&gt;</p><p>WebAssembly.instantiate(bytes,importObject)</p><p>).then(results &#x3D;&gt;</p><p>results.instance</p><p>);</p><p>}</p></blockquote><p>您可以在文档中更深入地了解这些。</p><p>我们正在努力使这个过程更容易。我们期望对工具链进行改进，并与现有的模块管理工具（如Webpack）或加载器（如SystemJS）相结合。我相信，加载 WebAssembly 模块越来越简单，就像加载 Java 一样。</p><p>但是，WebAssembly模块和JS模块之间存在重大差异。目前，WebAssembly 中的函数只能使用 WebAssembly 类型（整数或浮点数）作为参数或返回值。</p><p><img src="http://img.mp.sohu.com/upload/20170518/76579804e91847d0a4aab50f4e6a0626.png" alt="img"></p><p>对于任何更复杂的数据类型（如字符串），必须使用 WebAssembly 模块的内存。</p><p>如果你之前主要使用 Java，可能对于直接访问内存是不熟悉的。C，C ++和Rust等性能更高的语言往往具有手动内存管理功能。WebAssembly 模块的内存模拟这些语言中的堆。</p><p>为此，它使用 Java 中称为 ArrayBuffer。ArrayBuffer 是一个字节数组。因此，数组的索引作为内存地址。</p><p>如果要在 Java 和 WebAssembly 之间传递一个字符串，需要将字符转换为等效的字符码。然后你需要将它写入内存数组。由于索引是整数，所以可以将索引传递给 WebAssembly 函数。因此，字符串的第一个字符的索引可以当作指针。</p><p><img src="http://img.mp.sohu.com/upload/20170518/98e2fbd269ad4543b7fa485abc93e42d_th.png" alt="img"></p><p>任何人开发的 WebAssembly 模块很可能被 Web 开发人员使用并为该模块创建一个的装饰器。这样，您当做用户来使用这个模块就不需要考虑内存管理的事情了。</p><p>我已经在另一篇文章中解释了更多关于使用WebAssembly模块的内容。</p><p>\7. WebAssembly 现在是什么状态？</p><p>二月二十八日，四大浏览器宣布达成共识，即 WebAssembly 的 MVP （最小化可行产品）已经完成。大约一周后，Firefox会默认打开 WebAssembly 支持，而Chrome则在第二周开始。它也可用于预览版本的Edge和Safari。</p><p>这提供了一个稳定的初始版本，浏览器开始支持。</p><p><img src="http://img.mp.sohu.com/upload/20170518/f463c848d531411798ab6eb0461a8041_th.png" alt="img"></p><p>该核心不包含社区组织计划的所有功能。即使在初始版本中，WebAssembly 也会很快。但是，通过修复和新功能的组合，将来应该能够更快。我在另一篇文章中详细介绍了这些功能。</p><p>\8. 总结</p><p>使用WebAssembly，可以更快地在 web 应用上运行代码。这里有 几个 WebAssembly 代码运行速度比 Java 高效的原因。</p><ul><li>文件加载 - WebAssembly 文件体积更小，所以下载速度更快。</li><li>解析 - 解码 WebAssembly 比解析 Java 要快</li><li>编译和优化 - 编译和优化所需的时间较少，因为在将文件推送到服务器之前已经进行了更多优化，Java 需要为动态类型多次编译代码</li><li>重新优化 - WebAssembly 代码不需要重新优化，因为编译器有足够的信息可以在第一次运行时获得正确的代码</li><li>执行 - 执行可以更快，WebAssembly 指令更接近机器码</li><li>垃圾回收 - 目前 WebAssembly 不直接支持垃圾回收，垃圾回收都是手动控制的，所以比自动垃圾回收效率更高。</li></ul><p>目前浏览器中的 MVP（最小化可行产品） 已经很快了。在接下来的几年里，随着浏览器的发展和新功能的增加，它将在未来几年内变得更快。没有人可以肯定地说，这些性能改进可以实现什么样的应用。但是，如果过去有任何迹象，我们可以期待惊奇。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios 总结</title>
      <link href="/2017/06/10/%E5%89%8D%E7%AB%AF/axios%20%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/10/%E5%89%8D%E7%AB%AF/axios%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-总结"><a href="#axios-总结" class="headerlink" title="axios 总结"></a>axios 总结</h2><blockquote><p>公司目前没有web端开发，逐步需要做运维，运营的页面，想要快速开展工作，<br>就去了解了下目前比较火的前端框架，前端框架层出不穷技术栈也是日新月异，react vue angular，在做过一段时间了解和对比之后，认为目前vue是最合适的。</p></blockquote><blockquote><p>去官网熟悉了一下基本文档，写了几个demo，就开始设计运营业务的前端架构，借鉴很多github上的优秀作品，今天主要是总结下接口调用的http框架：axios</p></blockquote><blockquote><p>之前使用JQuery时，接口调用是通过$.ajax， 在熟悉vue的过程中，去了解到这块的解决方案，虽然vue全家桶中，提供了vue-resource，但是vue2.0版本以后，尤大宣布不再继续维护vue-resource，并推荐使用 axios，通过实践后，发现axios确实好用~</p></blockquote><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul><li>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端</li></ul><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF&#x2F;XSRF</li></ul><h3 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h3><p>Using npm:</p><pre><code>$ npm install axios</code></pre><p>Using bower:</p><pre><code>$ bower install axios</code></pre><p>Using cdn:</p><pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>我的项目使用的是vue-cli脚手架构建，使用的npm的安装方式进行引入</p><pre><code>npm install --save axios</code></pre><h3 id="使用举例："><a href="#使用举例：" class="headerlink" title="使用举例："></a>使用举例：</h3><ul><li><p>GET 请求</p><pre><code>  // Make a request for a user with a given ID  axios.get(&#39;/user?ID=12345&#39;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);    // Optionally the request above could also be done as  axios.get(&#39;/user&#39;, &#123;      params: &#123;        ID: 12345      &#125;    &#125;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);</code></pre></li><li><p>POST 请求</p><pre><code>  axios.post(&#39;/user&#39;, &#123;      firstName: &#39;Fred&#39;,      lastName: &#39;Flintstone&#39;    &#125;)    .then(function (response) &#123;      console.log(response);    &#125;)    .catch(function (error) &#123;      console.log(error);    &#125;);</code></pre></li><li><p>并发请求</p><pre><code>  function getUserAccount() &#123;    return axios.get(&#39;/user/12345&#39;);  &#125;  function getUserPermissions() &#123;    return axios.get(&#39;/user/12345/permissions&#39;);  &#125;  axios.all([getUserAccount(), getUserPermissions()])    .then(axios.spread(function (acct, perms) &#123;      //两个请求现已完成    &#125;));</code></pre></li></ul><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过向 axios 传递相关配置来创建请求</p><p>axios(config)</p><pre><code>// 发送 POST 请求axios(&#123;  method: &#39;post&#39;,  url: &#39;/user/12345&#39;,  data: &#123;    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;  &#125;&#125;);</code></pre><p>axios(url[, config])</p><pre><code>// 发送 GET 请求（默认的方法）axios(&#39;/user/12345&#39;);</code></pre><h4 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h4><p>为方便起见，为所有支持的请求方法提供了别名</p><pre><code>axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])</code></pre><ul><li>注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</li></ul><p>并发</p><p>处理并发请求的助手函数</p><pre><code>axios.all(iterable)axios.spread(callback)</code></pre><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>可以使用自定义配置新建一个 axios 实例</p><p>axios.create([config])</p><pre><code>var instance = axios.create(&#123;  baseURL: &#39;https://some-domain.com/api/&#39;,  timeout: 1000,  headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;&#125;);</code></pre><h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p><pre><code>axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])</code></pre><h4 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h4><p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</p><pre><code>&#123;  // `url` 是用于请求的服务器 URL  url: &#39;/user&#39;,  // `method` 是创建请求时使用的方法  method: &#39;get&#39;, // 默认是 get  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL  baseURL: &#39;https://some-domain.com/api/&#39;,  // `transformRequest` 允许在向服务器发送前，修改请求数据  // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream  transformRequest: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据  transformResponse: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `headers` 是即将被发送的自定义请求头  headers: &#123;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;,  // `params` 是即将与请求一起发送的 URL 参数  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象  params: &#123;    ID: 12345  &#125;,  // `paramsSerializer` 是一个负责 `params` 序列化的函数  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)  paramsSerializer: function(params) &#123;    return Qs.stringify(params, &#123;arrayFormat: &#39;brackets&#39;&#125;)  &#125;,  // `data` 是作为请求主体被发送的数据  // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;  // 在没有设置 `transformRequest` 时，必须是以下类型之一：  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams  // - 浏览器专属：FormData, File, Blob  // - Node 专属： Stream  data: &#123;    firstName: &#39;Fred&#39;  &#125;,  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)  // 如果请求话费了超过 `timeout` 的时间，请求将被中断  timeout: 1000,  // `withCredentials` 表示跨域请求时是否需要使用凭证  withCredentials: false, // 默认的  // `adapter` 允许自定义处理请求，以使测试更轻松  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).  adapter: function (config) &#123;    /* ... */  &#125;,  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头  auth: &#123;    username: &#39;janedoe&#39;,    password: &#39;s00pers3cret&#39;  &#125;,  // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;  responseType: &#39;json&#39;, // 默认的  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称  xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认的  // `onUploadProgress` 允许为上传处理进度事件  onUploadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `onDownloadProgress` 允许为下载处理进度事件  onDownloadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `maxContentLength` 定义允许的响应内容的最大尺寸  maxContentLength: 2000,  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的  &#125;,  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  // 如果设置为0，将不会 follow 任何重定向  maxRedirects: 5, // 默认的  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：  // `keepAlive` 默认没有启用  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),  // &#39;proxy&#39; 定义代理服务器的主机名称和端口  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。  proxy: &#123;    host: &#39;127.0.0.1&#39;,    port: 9000,    auth: : &#123;      username: &#39;mikeymike&#39;,      password: &#39;rapunz3l&#39;    &#125;  &#125;,  // `cancelToken` 指定用于取消请求的 cancel token  // （查看后面的 Cancellation 这节了解更多）  cancelToken: new CancelToken(function (cancel) &#123;  &#125;)&#125;</code></pre><h4 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h4><p>某个请求的响应包含以下信息</p><pre><code>&#123;  // `data` 由服务器提供的响应  data: &#123;&#125;,  // `status` 来自服务器响应的 HTTP 状态码  status: 200,  // `statusText` 来自服务器响应的 HTTP 状态信息  statusText: &#39;OK&#39;,  // `headers` 服务器响应的头  headers: &#123;&#125;,  // `config` 是为请求提供的配置信息  config: &#123;&#125;&#125;</code></pre><p>使用 then 时，你将接收下面这样的响应：</p><pre><code>axios.get(&#39;/user/12345&#39;)  .then(function(response) &#123;    console.log(response.data);    console.log(response.status);    console.log(response.statusText);    console.log(response.headers);    console.log(response.config);  &#125;);</code></pre><ul><li>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。</li></ul><h3 id="配置的默认值-x2F-defaults"><a href="#配置的默认值-x2F-defaults" class="headerlink" title="配置的默认值&#x2F;defaults"></a>配置的默认值&#x2F;defaults</h3><p>你可以指定将被用在各个请求的配置默认值</p><h4 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h4><pre><code>axios.defaults.baseURL = &#39;https://api.example.com&#39;;axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></pre><h4 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h4><pre><code>// 创建实例时设置配置的默认值var instance = axios.create(&#123;  baseURL: &#39;https://api.example.com&#39;&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;</code></pre><h4 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h4><p>配置会以一个优先顺序进行合并。这个顺序是：在 lib&#x2F;defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：</p><pre><code>// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get(&#39;/longRequest&#39;, &#123;  timeout: 5000&#125;);</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) &#123;    // 在发送请求之前做些什么    return config;  &#125;, function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error);  &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123;    // 对响应数据做点什么    return response;  &#125;, function (error) &#123;    // 对响应错误做点什么    return Promise.reject(error);  &#125;);</code></pre><p>如果你想在稍后移除拦截器，可以这样：</p><pre><code>var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor);</code></pre><p>可以为自定义 axios 实例添加拦截器</p><pre><code>var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;);</code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><pre><code>axios.get(&#39;/user/12345&#39;)  .catch(function (error) &#123;    if (error.response) &#123;      // 请求已发出，但服务器响应的状态码不在 2xx 范围内      console.log(error.response.data);      console.log(error.response.status);      console.log(error.response.headers);    &#125; else &#123;      // Something happened in setting up the request that triggered an Error      console.log(&#39;Error&#39;, error.message);    &#125;    console.log(error.config);  &#125;);</code></pre><p>可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。</p><pre><code>axios.get(&#39;/user/12345&#39;, &#123;  validateStatus: function (status) &#123;    return status &lt; 500; // 状态码在大于或等于500时才会 reject  &#125;&#125;)</code></pre><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>使用 cancel token 取消请求</p><blockquote><p>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。</p></blockquote><p>可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：</p><pre><code>var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&#39;/user/12345&#39;, &#123;  cancelToken: source.token&#125;).catch(function(thrown) &#123;  if (axios.isCancel(thrown)) &#123;    console.log(&#39;Request canceled&#39;, thrown.message);  &#125; else &#123;    // 处理错误  &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&#39;Operation canceled by the user.&#39;);</code></pre><p>还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：</p><pre><code>var CancelToken = axios.CancelToken;var cancel;axios.get(&#39;/user/12345&#39;, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    // executor 函数接收一个 cancel 函数作为参数    cancel = c;  &#125;)&#125;);// 取消请求cancel();</code></pre><ul><li>注意 : 可以使用同一个 cancel token 取消多个请求</li></ul><h3 id="使用application-x2F-x-www-form-urlencoded格式"><a href="#使用application-x2F-x-www-form-urlencoded格式" class="headerlink" title="使用application &#x2F; x-www-form-urlencoded格式"></a>使用application &#x2F; x-www-form-urlencoded格式</h3><pre><code> 默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</code></pre><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>在浏览器中，您可以使用URLSearchParams API，如下所示：</p><pre><code>var params = new URLSearchParams();params.append(&#39;param1&#39;, &#39;value1&#39;);params.append(&#39;param2&#39;, &#39;value2&#39;);axios.post(&#39;/foo&#39;, params);</code></pre><ul><li>请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。</li></ul><p>或者，您可以使用qs库对数据进行编码：</p><pre><code>var qs = require(&#39;qs&#39;);axios.post(&#39;/foo&#39;, qs.stringify(&#123; &#39;bar&#39;: 123 &#125;);</code></pre><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>在node.js中，可以使用querystring模块，如下所示：</p><pre><code>var querystring = require(&#39;querystring&#39;);axios.post(&#39;http://something.com/&#39;, querystring.stringify(&#123; foo: &#39;bar&#39; &#125;);</code></pre><p>当然也可以使用qs库。</p><h3 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h3><p>在vue项目中，新建api&#x2F;index.js</p><pre><code>import axios from &#39;axios&#39;</code></pre><p>将所有的api集中到该文件中，方便管理</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 指纹信息相关</title>
      <link href="/2017/05/19/%E5%89%8D%E7%AB%AF/%20js%20%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/"/>
      <url>/2017/05/19/%E5%89%8D%E7%AB%AF/%20js%20%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="js-浏览器指纹信息相关"><a href="#js-浏览器指纹信息相关" class="headerlink" title="js 浏览器指纹信息相关"></a>js 浏览器指纹信息相关</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>近期的一个需求，app做第三方分享时，用微信，或QQ邀请好友，下载app，<span id="more"></span>在被邀请方从分享页面获取app信息及下载app，安装，注册后，希望<br>可以关联到邀请方信息，可用于在后端统计，及被邀请方注册登录后，直接提示用户是否 添加 邀请方为好友。一般做法为生成邀请码，在注册时，用户填写邀请码，但这种方式，大多数用户不用在注册时，填写难记的邀请码信息。</p></blockquote><blockquote><p>与同事们讨论后，讨论了一种方案，第三方分享是H5页面，用户在点开分享页面时，记录用户的信息（网络，手机设备等），生成一个唯一标识与分享者uid关联。新用户在注册时，关联用户的机型，网络，关联到分享者信息。</p></blockquote><blockquote><p>js一般只能获取到浏览器的信息，浏览器的userAgent中可以获取部分设备信息（手机型号，品牌之类），虽然碰撞率很高，但目前也基本可以满足需求，最终浏览器指纹起到了一些辅助作用，也借此机会了解下相关概念，熟悉下js可以获取哪些用户信息，这里做个简单的记录</p></blockquote><h3 id="js指纹的概念理解"><a href="#js指纹的概念理解" class="headerlink" title="js指纹的概念理解"></a>js指纹的概念理解</h3><blockquote><p>JS浏览器指纹的相关内容。浏览器指纹指的是通过JS采集用户的各种浏览器和设备信息，借此希望能生成相对唯一的uuid，用于区分用户</p></blockquote><h3 id="fingerprintjs2"><a href="#fingerprintjs2" class="headerlink" title="fingerprintjs2"></a>fingerprintjs2</h3><ul><li><a href="https://github.com/Valve/fingerprintjs2">fingerprintjs2 github地址</a></li></ul><blockquote><p>Fingerprintjs2是github上开源的设备指纹采集器。最初的fingerprintjs库创建于2012年，但是由于新版本的开发很难保持向后兼容，因此Fingerprintjs2项目中增加了很多的新内容。</p></blockquote><blockquote><p>该项目将更多、更有效的来源用于指纹识别，并且可配置，也就是说用户可以选择性地开启其中的选项。该项目还将重点关注IE插件，尤其是在中国流行的QQ、Baidu等。另外，该项目使用了semver（语义化的版本控制系统）。</p></blockquote><blockquote><p>Fingerprintjs2的原理是根据所能获取到的设备相关信息：比如系统字体、ua、帆布指纹等数据，筛选计算出一个（94%情况下）近似唯一的24位哈希值，可以作为设备的唯一性标识。它的特点是不依赖cookie，用户无法通过清除缓存来删除。设备指纹现在被很多互联网反欺诈公司拿来作为用户特征识别的方法，也被一些广告公司用来跟踪用户数据。</p></blockquote><h4 id="Fingerprintjs2-源码列出目前可以采集到的信息"><a href="#Fingerprintjs2-源码列出目前可以采集到的信息" class="headerlink" title="Fingerprintjs2 源码列出目前可以采集到的信息"></a>Fingerprintjs2 源码列出目前可以采集到的信息</h4><pre><code>    keys = this.userAgentKey(keys);    keys = this.languageKey(keys);    keys = this.colorDepthKey(keys);    keys = this.pixelRatioKey(keys);    keys = this.hardwareConcurrencyKey(keys);    keys = this.screenResolutionKey(keys);    keys = this.availableScreenResolutionKey(keys);    keys = this.timezoneOffsetKey(keys);    keys = this.sessionStorageKey(keys);    keys = this.localStorageKey(keys);    keys = this.indexedDbKey(keys);    keys = this.addBehaviorKey(keys);    keys = this.openDatabaseKey(keys);    keys = this.cpuClassKey(keys);    keys = this.platformKey(keys);    keys = this.doNotTrackKey(keys);    keys = this.pluginsKey(keys);    keys = this.canvasKey(keys);    keys = this.webglKey(keys);    keys = this.adBlockKey(keys);    keys = this.hasLiedLanguagesKey(keys);    keys = this.hasLiedResolutionKey(keys);    keys = this.hasLiedOsKey(keys);    keys = this.hasLiedBrowserKey(keys);    keys = this.touchSupportKey(keys);    keys = this.customEntropyFunction(keys);    var that = this;</code></pre><p>fingerprintjs的源码已经列出了目前能够收集到的几乎所有API，其中浏览器UA，语言，浏览器所在CPU等级（cpuclass，仅支持IE，chrome和firefox反回undefined），浏览器版本，等都是通过<code>navigator</code>对象获得，还有 <code>window.indexedDB</code> ， <code>window.sessionStorage</code> 和 <code>window.localStorage</code> 这一类h5新增的特性是否存在也被用作区分值</p><p>Fingerprintjs2还考虑到了一些比较特殊的自定义区分值，比如时区，或者是否在浏览器层做了一些UA欺骗，比如 hasLiedLanguagesKey ， HasLiedBrowser ， HasLiedOs 。以 hasliedLanguageKey 为例，通过判断navigator.language和navigator.languages中第一个方法是否相同来实现：</p><pre><code>try &#123;      var firstLanguages = navigator.languages[0].substr(0, 2);      if(firstLanguages !== navigator.language.substr(0, 2))&#123;        return true;      &#125;    &#125; catch(err)&#123;      return true;    &#125;</code></pre><p>其中区分度最高的应该就是浏览器插件检测了，因为它还涉及到了一个插件安装顺序的唯独，也是通过navigator对象获得，需要对IE单独处理，关键代码：</p><pre><code>var plugins = [];      for(var i = 0, l = navigator.plugins.length; i &lt; l; i++) &#123;        plugins.push(navigator.plugins[i]);      &#125;      // sorting plugins only for those user agents, that we know randomize the plugins      // every time we try to enumerate them      if(this.pluginsShouldBeSorted()) &#123;        plugins = plugins.sort(function(a, b) &#123;          if(a.name &gt; b.name)&#123; return 1; &#125;          if(a.name &lt; b.name)&#123; return -1; &#125;          return 0;        &#125;);      &#125;      return this.map(plugins, function (p) &#123;        var mimeTypes = this.map(p, function(mt)&#123;          return [mt.type, mt.suffixes].join(&quot;~&quot;);        &#125;).join(&quot;,&quot;);        return [p.name, p.description, mimeTypes].join(&quot;::&quot;);      &#125;, this);</code></pre><h3 id="其他一些资源获取"><a href="#其他一些资源获取" class="headerlink" title="其他一些资源获取"></a>其他一些资源获取</h3><h4 id="检测字体"><a href="#检测字体" class="headerlink" title="检测字体"></a>检测字体</h4><p>传统的方式是flash读取系统安装的字体，这里面还增加了一个通过css和js检测字体的方法，实现原理非常有趣。<br>以var text &#x3D; ‘mmmmmmmmmmlli’；举例，不同的字体在同一大小的fontsize情况下，这段字体的长度和宽度是不同的，通过比较css的width和height，既可以判断用户是否有安装了相应的字体。实现的时候，可以在页面中动态插入一个span，讲fontsize设置为较大的值便于比较。这个手段也可以用在平常前端开发中，用以判断某种特定字体用户是否安装</p><h4 id="Canvas-画布指纹"><a href="#Canvas-画布指纹" class="headerlink" title="Canvas 画布指纹"></a>Canvas 画布指纹</h4><p>canvas是Html5中非常重要的一个特性，它同时也可以用语js指纹的一个重要熵值。其中的原因是因为同一个canvas图像在不同的设备上（不同的GPU），由于不同的渲染引擎、压缩比例，输出格式，以及同一系统字体安装不同，导致最后输出也不相同。通过在canvas画布上画字体，最后由toDataURL()方法专为64位格式。这一方法实现成本低，无法被禁用，立刻收到了广泛关注，目前这一方法被认为是浏览器指纹中十分重要的一种方法。不过在我的测试中，我发现还是很容易产生碰撞的，最简单的例子是在移动端上，比如高度统一的iPhone上面，同一代机型由于硬件相同，且ios在不越狱的情况下无法自定义字体，这就导致了的任意两台iphone6s通过safari判断画笔指纹会百分之百的获得同样的64位编码….</p><p>相关：</p><p><a href="https://github.com/Valve/fingerprintjs2/wiki/List-of-options">List of options</a></p><p><a href="http://jcarlosnorte.com/security/2016/03/06/advanced-tor-browser-fingerprinting.html">Advanced Tor Browser Fingerprinting</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留意开源项目的变更记录</title>
      <link href="/2017/05/19/%E6%9D%82%E8%AE%B0/%E7%95%99%E6%84%8F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/05/19/%E6%9D%82%E8%AE%B0/%E7%95%99%E6%84%8F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%98%E6%9B%B4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用开源的东东，其版本更新后一定得多看更新记录</p></blockquote><p>今天下午打算把vue的一个项目从私有coding上提交到github上（提取一些组件，毕竟来源于开源，也要回馈开源）。以为只是简单的复制粘贴。提交下<br>提交前，验证下。发现所有引用echarts的地方都显示不了了<br>直接报 Can’t get dom width or height<br>仔细对比代码，一毛一样，一个没问题，一个有问题，又各种google了半天。还是看不出问题。后来想新环境我更新了依赖。echarts3只是有小小版本0.3-升级到0.4 感觉应该没啥，查了下github上的记录，引用方式变了。</p><pre><code>import IEcharts from &#39;vue-echarts-v3&#39;;更新为import IEcharts from &#39;vue-echarts-v3/src/full.vue&#39;;</code></pre><p>经常总结工作的方式，方法，经验，不断提高自己</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 依赖管理(升级)工具 npm-check-updates</title>
      <link href="/2017/05/01/%E5%89%8D%E7%AB%AF/%20npm%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86(%E5%8D%87%E7%BA%A7)%E5%B7%A5%E5%85%B7%20npm-check-updates/"/>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%20npm%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86(%E5%8D%87%E7%BA%A7)%E5%B7%A5%E5%85%B7%20npm-check-updates/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习vue以来，发现更新版本真快，不愧是版本帝。。项目使用的vue及其他一些依赖版本更新后，想验证下最新的稳定版本，就要对<code>dependencies</code> 中各种包进行升级</p></blockquote><p>node 升级的依赖包的传统方法</p><pre><code>npm update 名称</code></pre><p>项目依赖的三方包多了咋办，一个个update不显示，于是继续google，找到了2个工具：</p><ul><li><a href="https://github.com/dylang/npm-check">npm-check</a></li></ul><blockquote><p>检查过时的，不正确的和未使用的依赖项</p></blockquote><ul><li><a href="https://github.com/tjunnone/npm-check-updates">npm-check-updates</a></li></ul><blockquote><p>npm-check-updates是一个命令行工具，允许您将package.json或bower.json依赖关系升级到最新版本，而不管现有的版本约束。</p></blockquote><h3 id="npm-check-updates-安装"><a href="#npm-check-updates-安装" class="headerlink" title="npm-check-updates 安装"></a>npm-check-updates 安装</h3><pre><code>npm install -g npm-check-updates</code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>npm-check-updates （或者直接使用别名(alias) ncu）All dependencies match the latest package versions :)</code></pre><p>出现上面这句话就是表示目前的包都是最新的</p><pre><code> express           4.12.x  →   4.13.x multer            ^0.1.8  →   ^1.0.1 react-bootstrap  ^0.22.6  →  ^0.24.0 react-a11y        ^0.1.1  →   ^0.2.6 webpack          ~1.9.10  →  ~1.10.5Run with -u to upgrade your package.json</code></pre><p>以上是目前的版本，及最新的版本差异</p><p>更新dependencies到新版本：</p><pre><code>    ncu -u</code></pre><p>更新全部dependencies到最新版本(包括当前指定版本范围满足最新版本号的,比如^4.2.0 -&gt; ^4.3.0)：</p><pre><code>     ncu -a</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Encrypt certbot 自动申请https证书</title>
      <link href="/2017/04/20/%E7%BD%91%E7%BB%9C/%20Let&#39;s%20Encrypt%20certbot%20%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7https%E8%AF%81%E4%B9%A6/"/>
      <url>/2017/04/20/%E7%BD%91%E7%BB%9C/%20Let&#39;s%20Encrypt%20certbot%20%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7https%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>服务器之前从Let’s Encrypt申请的https证书到期了，没有自动更新证书，上个月有一台web服务是使用了certbot自动申请，更新证书的，没有记录，这次再操作有点生疏了，还是趁这次，把操作过程记下来，加深印象，理解吧</p></blockquote><h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><blockquote><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL&#x2F;TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性</p></blockquote><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。</p></blockquote><h2 id="SSL-x2F-TLS-是什么？"><a href="#SSL-x2F-TLS-是什么？" class="headerlink" title="SSL&#x2F;TLS 是什么？"></a>SSL&#x2F;TLS 是什么？</h2><blockquote><p>“ HTTP over SSL&#x2F;TLS ”字面意思就是带“安全套接层”的 http 协议，内心纯洁的同学也可以理解为“带安全套的 http ”，因为带了安全套，所以当然会比较安全（&#x2F;(ㄒoㄒ)&#x2F;~~）。其中 SSL 是“ Secure Sockets Layer ” 的缩写，是“安全套接层”的意思。 TLS 是 “Transport Layer Security” 的缩写，是 ” 传输层安全协议 ” 的意思。 SSL 和 TLS 是同一个东西的不同阶段，理解为同一个东西也行，都是安全协议就对了。</p></blockquote><h2 id="为什么要部署-https"><a href="#为什么要部署-https" class="headerlink" title="为什么要部署 https"></a>为什么要部署 https</h2><blockquote><p>说到底，就是 https 更安全。甚至为了安全，一个专业可靠的网站， https 是必须的。 Firefox 和 Chrome 都计划将没有配置 SSL 加密的 http 网站标记为不安全（貌似 Firefox 50 已经这么干了），目前它们也正在联合其他相关的基金会与公司推动整个互联网 https 化，现在大家访问的一些主要的网站。如 Google 多年前就已经全部启用 https ，国内的淘宝、搜狗、知乎、百度等等也全面 https 了。甚至 Google 的搜索结果也正在给予 https 的网站更高的排名和优先收录权。</p></blockquote><h2 id="Let’s-Encrypt-简介"><a href="#Let’s-Encrypt-简介" class="headerlink" title="Let’s Encrypt 简介"></a>Let’s Encrypt 简介</h2><blockquote><p>Let’s Encrypt 是 ISRG （Internet Security Research Group） 提供的一个免费、开放、自动化的证书签发服务。ISRG 是一个美国公益组织，总部在加州。由于得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅速，甚至连老牌的免费 SSL 服务商 StartSSL 也坐不住，推出了类似 Let’s Encrypt 的自动签发和续期工具。</p></blockquote><h2 id="Certbot-简介"><a href="#Certbot-简介" class="headerlink" title="Certbot 简介"></a>Certbot 简介</h2><blockquote><p>Certbot 的官方网站是 <a href="https://certbot.eff.org/">https://certbot.eff.org/</a> ，打开这个链接选择自己使用的 web server 和操作系统，EFF 官方会给出详细的使用方法</p></blockquote><h2 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h2><pre><code>#sudo yum install epel-release#sudo yum install certbot</code></pre><blockquote><p>安装过程中可能会报错，建议安装前，更新下pip</p></blockquote><pre><code>pip install --upgrade pip</code></pre><p>至少这些包要更新下</p><pre><code>pip install requests urllib3 pyOpenSSL --force --upgrade</code></pre><p>还有个错误，需要安装下pyOpenSSL 0.14及以上的版本，我是下载了pyOpenSSL-0.15.1-1.el7.noarch.rpm解决的</p><pre><code>sudo rpm -Uvh pyOpenSSL-0.15.1-1.el7.noarch.rpm</code></pre><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><pre><code>certbot certonly --email ff@mail.com --agree-tos --no-eff-email --webroot -w /var/www/html/home -d xx.xx.com</code></pre><p>证书信息会生成在 <code>/etc/letsencrypt/live</code> 目录</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><pre><code>ssl_certificate /etc/letsencrypt/live/xx.xx.com/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/xx.xx.com/privkey.pem;</code></pre><p>下面是一些本地不想在修改配置到新地址时，做个软连接就好</p><h2 id="建立软连接"><a href="#建立软连接" class="headerlink" title="建立软连接"></a>建立软连接</h2><p>ln -sfn &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xx.xx.com&#x2F;fullchain.pem fullchain.pem<br>ln -sfn &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xx.xx.com&#x2F;privkey.pem privkey.pem</p><h2 id="配置定时任务-没有装crontab的话，安装下"><a href="#配置定时任务-没有装crontab的话，安装下" class="headerlink" title="配置定时任务 (没有装crontab的话，安装下)"></a>配置定时任务 (没有装crontab的话，安装下)</h2><pre><code>yum -y install yum-cron</code></pre><h2 id="crontab-l"><a href="#crontab-l" class="headerlink" title="crontab -l"></a>crontab -l</h2><pre><code>30 2 15 * * /usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log35 2 15 * * /usr/local/openresty/nginx/sbin/nginx -s reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6 import的路径问题</title>
      <link href="/2017/04/10/%E5%89%8D%E7%AB%AF/%20es6%20import%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/10/%E5%89%8D%E7%AB%AF/%20es6%20import%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="es6-import的路径问题"><a href="#es6-import的路径问题" class="headerlink" title="es6 import的路径问题"></a>es6 import的路径问题</h2><blockquote><p>在导入</p></blockquote><pre><code>This dependency was not found:* /src/store/function in ./src/store/modules/checklist/index.js, ./src/store/modules/checklist/mutations.js</code></pre><p>问题原因：</p><blockquote><p>export default 的用法</p></blockquote><p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，相反其它的export 输出 可以有多个，且import时必须加大括号，示例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> xxx &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import xxx from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句，而export需要跟变量声明或者大括号作为输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;　　<span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;　　<span class="comment">// 写法2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>import 时候的路径问题(作为新手，遇到一些坑，刚好记录下)</p><p>开始玩的时候，总是出现 cannot find module 问题，原来 在 import 的时候 如果不使用相对路径或者绝对路径，node默认会去node_modules&#x2F;文件夹下去找，例如：</p><pre><code>import * as obj from &#39;exports&#39;// node 会试着去寻找 node_modules/exports.js 模块 // 正确写法 import * as obj from &#39;./exports&#39;</code></pre><p>关于 import * as obj from ‘xx’  这种写法是把所有的输出包裹到obj对象里</p><p>对了，还有模块的继承写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circleplus.js 当前模块继承了 circle 模块的所有输出</span></span><br><span class="line"><span class="comment">// 此处只是继承了输出，并不能直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;circle&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">exp</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承之后，circleplus.js 相当于下面代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">exp</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2简单总结</title>
      <link href="/2017/04/05/%E5%89%8D%E7%AB%AF/%20vue2%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2017/04/05/%E5%89%8D%E7%AB%AF/%20vue2%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="vue2-简单总结"><a href="#vue2-简单总结" class="headerlink" title="vue2 简单总结"></a>vue2 简单总结</h2><blockquote><p>一些自己的简单总结</p></blockquote><h3 id="一、渐进式："><a href="#一、渐进式：" class="headerlink" title="一、渐进式："></a>一、渐进式：</h3><p>从简单的引入js使用指令到构建大型web应用，都可以应付<br>简易的引入过程：<br>1.html中引入js的方式<br>2.构建自定义组件<br>3.使用组件组成网页<br>4.vue-cli(构建项目),vue,vuex（统一管理状态）,vue-route（页面路由）,webpack（自动构建，打包，发布）等 构建大型SPA(单网页应用)</p><h3 id="二、适合我们现在前端发展"><a href="#二、适合我们现在前端发展" class="headerlink" title="二、适合我们现在前端发展"></a>二、适合我们现在前端发展</h3><p>vue更关注视图层，我们现在页面还比较少，随着业务发展，页面的需求会持续增多，vue本身比较小，又支持渐进式发展，后面页面逐步增多，可以抽取做成vue组件，逐步可以通过插拔组件的方式完成页面开发，提高规范及效率</p><h3 id="三、MVVM"><a href="#三、MVVM" class="headerlink" title="三、MVVM"></a>三、MVVM</h3><p>数据模型&#x2F;页面 双向绑定<br>根据restful的接口，数据上的变动会直接渲染到页面，页面上的文案变化，也会影响到数据模型<br>比较适合我们现在的后端风格，可以考虑客户端mvvm的解决方案。</p><p>假期时，抽空简单总结了下vue常用的指令，就拿之前排行榜的例子重写了下。</p><p><a href="https://github.com/fantasykai/vue2-learn-leaderboard">https://github.com/fantasykai/vue2-learn-leaderboard</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集中式日志监控系统</title>
      <link href="/2017/03/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/03/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="集中式日志监控系统"><a href="#集中式日志监控系统" class="headerlink" title="集中式日志监控系统"></a>集中式日志监控系统</h1><h2 id="为什么需要日志管理系统"><a href="#为什么需要日志管理系统" class="headerlink" title="为什么需要日志管理系统"></a>为什么需要日志管理系统</h2><p>日志，对于任何系统都是重要的组成，作为程序猿，定位问题，查看系统的健康运载情况，都需要通过查询日志进行分析。</p><p>合理的软件架构往往都不会是单点的，即使在同一台应用服务器上，日志有不同的种类，nginx访问日志，操作系统，应用服务，业务逻辑等等。</p><p>没有日志管理系统时，我们如何分析日志：</p><p>tail，cat，grep，sed ，awk ，wc… 显然不可能登录到每一台应用服务器上敲命令。</p><p>于是建立一套集中式的方法，把不同来源的数据集中整合到一起，方便归纳分析，就成为解决以上痛点的方式方法。</p><h2 id="ELK-简介"><a href="#ELK-简介" class="headerlink" title="ELK 简介"></a>ELK 简介</h2><p>ELK 是 Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack,目前ELK Stack 已经成为最流行的集中式日志解决方案。</p><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写</p><p>主要特点</p><ul><li>实时分析</li><li>分布式实时文件存储，并将每一个字段都编入索引</li><li>文档导向，所有的对象全部是文档</li><li>高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。</li><li>支持 JSON</li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写</p><p>主要特点</p><ul><li>几乎可以访问任何数据</li><li>可以和多种外部应用结合</li><li>支持弹性扩展</li></ul><p>它由三个主要部分组成</p><ul><li>Shipper－发送日志数据</li><li>Broker－收集数据，缺省内置 Redis</li><li>Indexer－数据写入</li></ul><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 是一款基于 Apache 开源协议，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。</p><p>Elastic.co 在2016-10-27 发布了 Elastic Stack 5.0 以后目前更新的步伐还是很快的，并且Elastic.co 对部分好用插件开始收费。</p><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p>我在对ELK有了一定了解探索后，决定先使用 ELK 5 之前比较成熟的方案做一次搭建，尝试及进一步熟悉了解集中式日志监控系统，也方便应用到我们的测试及生成环境中。</p><p>各模块版本</p><ul><li>elasticsearch-2.4.4</li><li>logstash-2.3.4</li><li>kibana-4.6.3</li></ul><p>另外还引入消息队列</p><ul><li>zookeeper-3.4.9</li><li>kafka_2.11-0.10.2.0</li></ul><p>Logstash 作为日志收集端，比较消耗 CPU 和内存资源,从Elastic.co的官网找到了更好的替代方案：Beats组件</p><p>Beats 作为日志shipper</p><ul><li>Packetbeat（网络数据）；</li><li>Metricbeat（从系统和服务收集指标。从CPU到内存，Redis到Nginx等等，Metricbeat是一种轻量级的方式来发送系统和服务统计信息）；</li><li>Filebeat（日志文件）；</li><li>Winlogbeat（搜集 Windows 事件日志数据）。</li><li>Heartbeat （使用主动探测监视服务的可用性。给出一个URL列表，Heartbeat询问一个简单的问题：你活着吗？Heartbeat将此信息和响应时间发送到弹性堆栈的其余部分进行进一步分析）</li></ul><p>Beats 将搜集到的数据发送到 Logstash，经 Logstash 解析、过滤后，将其发送到 Elasticsearch 存储</p><p>相比 Logstash，Beats 所占系统的 CPU 和内存几乎可以忽略不计，这样解决了Logstash 在各服务器节点上占用系统资源高的问题。另外，Beats 和 Logstash 之间支持 SSL&#x2F;TLS 加密传输，客户端和服务器双向认证，保证了通信安全。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdj6dwfug4j20mo0jswft"></p><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdfbfjchczj214g10iwpx"></p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><p>简单把部署过程及配置文件进行记录，方便后续回顾及优化</p><h3 id="相关环境："><a href="#相关环境：" class="headerlink" title="相关环境："></a>相关环境：</h3><p>部署平台&#x2F;环境：</p><ul><li>linux centos7.2</li><li>jdk1.8.0_74</li></ul><h3 id="1-部署Elasticsearch集群"><a href="#1-部署Elasticsearch集群" class="headerlink" title="1.部署Elasticsearch集群"></a>1.部署Elasticsearch集群</h3><ul><li><a href="https://www.elastic.co/">elastic 官网</a></li></ul><p>我从官网下载了 <code>elasticsearch-2.4.4.tar.gz</code></p><h4 id="解压缩tar-tz"><a href="#解压缩tar-tz" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h4><pre><code>    cd /usr/local/elasticsearch    tar -zxvf elasticsearch-2.4.4.tar.gz</code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><pre><code>    cd /usr/local/elasticsearch/elasticsearch-2.4.4/config    vim elasticsearch.yml</code></pre><p>配置文件关键配置说明：</p><p>部分配置已经在部署图中有所说明，这里再补充一些字段说明：</p><pre><code> #配置es的集群名称，不同的集群用名字来区分，es会自动发现在同一网段下的es，配置成相同集群名字的各个节点形成一个集群。如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。    cluster.name: blu-es       #节点名称，es启动时会自动创建节点名称，自己配置下更方便维护吧    node.name: es01         #是否作为主节点    node.master: true        #是否存储数据     node.data: false    # 默认情况下，ElasticSearch使用0.0.0.0地址，并为http传输开启9200-9300端口，为节点到节点的通信开启9300-9400端口，可以自行设置IP地址    network.host: 我设置为内网的IP了    # 输监听定制端口    http.port: 9200    # 数据文件存储路径 此路径要创建出来    path.data: /home/elk/data    # 日志文件存储路径，此路径要创建出来    path.logs: /var/log/elasticsearch</code></pre><h4 id="ES环境启动"><a href="#ES环境启动" class="headerlink" title="ES环境启动"></a>ES环境启动</h4><ul><li><strong>elasticsearch默认是不支持用root用户来启动的。</strong></li></ul><p>解决方案：</p><ul><li><p>1.新建专门的用户用来管理elasticsearch，线上环境确实也不建议使用root用户</p></li><li><p>2.启动时，追加 <code>Des.insecure.allow.root=true</code></p><pre><code>  在 `/usr/local/elasticsearch/elasticsearch-2.4.4/bin/elasticsearch` 中增加 ES_JAVA_OPTS=&quot;-Des.insecure.allow.root=true&quot;</code></pre></li></ul><p>启动ES环境</p><pre><code>    cd /usr/local/elasticsearch/elasticsearch-2.4.4/bin    sh ./elasticsearch -d</code></pre><ul><li>-d表示后台启动</li></ul><h4 id="Elasticsearch插件安装"><a href="#Elasticsearch插件安装" class="headerlink" title="Elasticsearch插件安装"></a>Elasticsearch插件安装</h4><p>在熟悉Elasticsearch过程中，了解到有许多不错的插件，这里把简单记录下插件的安装方法</p><ul><li><p>通过plugin 命令进行安装</p><pre><code>  #head 方便对es进行各种操作的客户端，可以查看各个索引的数据量以及分片的状态，  /usr/share/elasticsearch/bin/plugin install mobz/elasticsearch-head  #kopf es的管理工具，也提供了对ES集群操作的API。  /usr/share/elasticsearch/bin/plugin install lmenezes/elasticsearch-kopf  #bigdesk 监控es状态的插  /usr/share/elasticsearch/bin/plugin install hlstudio/bigdesk</code></pre></li><li><p>还可以到github上查找插件的源码进行手动安装，安装细节不再赘述。</p></li><li><p>访问插件： <code>/_plugin/插件名称</code></p><pre><code>  如访问head  http://ip:9200/_plugin/head/</code></pre></li></ul><h4 id="Elasticsearch集群配置"><a href="#Elasticsearch集群配置" class="headerlink" title="Elasticsearch集群配置"></a>Elasticsearch集群配置</h4><p>主要是针对 <code>elasticsearch.yml</code>的配置，上述步骤已经对该文件部分关键字段说明，我在测试环境使用了3台做集群配置，通过head插件可以查看集群的状态：</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdl4okw4u7j20o60hrdks"></p><p>ES 集群搭建OK~</p><h3 id="2-部署kafka集群"><a href="#2-部署kafka集群" class="headerlink" title="2.部署kafka集群"></a>2.部署kafka集群</h3><p>Kafka集群是把状态保存在Zookeeper中的，首先要搭建Zookeeper集群。</p><ul><li>Zookeeper通过复制来实现高可用性，只要集群中半数以上的节点处于可用状态，它就能够保证服务继续。所以搭建集群的服务器台数应该为（2*n+1）台。</li></ul><h4 id="1-Zookeeper的安装配置"><a href="#1-Zookeeper的安装配置" class="headerlink" title="1) Zookeeper的安装配置"></a>1) Zookeeper的安装配置</h4><ul><li><a href="https://zookeeper.apache.org/">zookeeper官网</a></li></ul><p>上述说明zookeeper集群必须保证3台以上的服务器，我这里搭建3台zookeeper服务器</p><h5 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h5><ul><li>myid 为服务器编号，用于标识服务器，这个值必须和dataDir目录下myid文件中的值保证一致</li></ul><table><thead><tr><th>服务IP</th><th>myid</th></tr></thead><tbody><tr><td>10.11.1.11</td><td>11</td></tr><tr><td>10.11.1.12</td><td>12</td></tr><tr><td>10.11.1.13</td><td>13</td></tr></tbody></table><pre><code>为每台机器创建myid文件# 10.11.1.11echo 11 &gt;/home/zookeeper/data/myid# 10.11.1.12echo 12 &gt;/home/zookeeper/data/myid# 10.11.1.13echo 13 &gt;/home/zookeeper/data/myid</code></pre><h5 id="我从官网下载了-zookeeper-3-4-9-tar-gz"><a href="#我从官网下载了-zookeeper-3-4-9-tar-gz" class="headerlink" title="我从官网下载了 zookeeper-3.4.9.tar.gz"></a>我从官网下载了 <code>zookeeper-3.4.9.tar.gz</code></h5><h5 id="解压缩tar-tz-1"><a href="#解压缩tar-tz-1" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h5><pre><code>    cd /usr/local/zookeeper    tar -zxvf zookeeper-3.4.9.tar.gz</code></pre><h5 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><pre><code>    cd /usr/local/zookeeper/zookeeper-3.4.9/conf    cp zoo_sample.cfg zoo.cfg    vim zoo.cfg    # 这个时间是作为Zk服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime     tickTime=2000    # 此配置表示，允许follower(相对于Leaderer言的“客户端”)连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。    initLimit=10    # 此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。    syncLimit=5    # 数据的存放路径    dataDir=/home/zookeeper/data    # the port at which the clients will connect    clientPort=2181    # the maximum number of client connections.    # 最大的并发连接数限制，设置为0或者不设置该参数，表示不进行连接数的限制。    #maxClientCnxns=60        # 集群模式的配置参数    # 第一个端口是master和slave之间的通信端口，默认是2888，第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888    server.11=10.11.1.11:2888:3888    server.12=10.11.1.12:2888:3888    server.13=10.11.1.13:2888:3888        #    # Be sure to read the maintenance section of the     # administrator guide before turning on autopurge.    #    # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance    #    # The number of snapshots to retain in dataDir    #autopurge.snapRetainCount=3    # Purge task interval in hours    # Set to &quot;0&quot; to disable auto purge feature    #autopurge.purgeInterval=1</code></pre><p>每台的zoo.cfg的配置相同，复制到每一台即可</p><h5 id="启动zookeeper环境"><a href="#启动zookeeper环境" class="headerlink" title="启动zookeeper环境"></a>启动zookeeper环境</h5><pre><code>在bin目录下执行nohup ./zkServer.sh start &amp;</code></pre><h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><pre><code>./zkServer.sh statusUsing config: /usr/local/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfgMode: follower 或者 Mode: leader </code></pre><h4 id="2-kafka的安装配置"><a href="#2-kafka的安装配置" class="headerlink" title="2) kafka的安装配置"></a>2) kafka的安装配置</h4><ul><li><a href="https://kafka.apache.org/">kafka官网</a></li></ul><h5 id="我从kafka的官网下载了-kafka-2-11-0-10-2-0-tgz"><a href="#我从kafka的官网下载了-kafka-2-11-0-10-2-0-tgz" class="headerlink" title="我从kafka的官网下载了 kafka_2.11-0.10.2.0.tgz"></a>我从kafka的官网下载了 <code>kafka_2.11-0.10.2.0.tgz</code></h5><h5 id="解压缩tar-tz-2"><a href="#解压缩tar-tz-2" class="headerlink" title="解压缩tar.tz"></a>解压缩tar.tz</h5><pre><code>    cd /usr/local/kafka    tar -zxvf kafka_2.11-0.10.2.0.tgz</code></pre><h5 id="修改配置文件-2"><a href="#修改配置文件-2" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><pre><code>    vim /usr/local/kafka/kafka_2.11-0.10.2.0/config/server.properties</code></pre><p>配置文件主要参数说明</p><pre><code>    #当前机器在集群中的唯一标识，和zookeeper的myid性质一样    broker.id=1          #当前kafka对外提供服务的端口默认是9092    port=9092 #不配置的话，默认为9092        #这个是borker进行网络处理的线程数    num.network.threads=3         #这个是borker进行I/O处理的线程数    num.io.threads=8         #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个    log.dirs=/usr/local/kafka/kafka_2.11-0.10.2.0/logs             #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能    socket.send.buffer.bytes=102400             #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘    socket.receive.buffer.bytes=102400         #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小    socket.request.max.bytes=104857600         #默认的分区数，一个topic默认1个分区数    num.partitions=6        #默认消息的最大持久化时间（小时）    log.retention.hours=60         #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件    log.segment.bytes=1073741824        #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除    log.retention.check.interval.ms=300000         #设置zookeeper的连接端口    zookeeper.connect=10.11.1.11:2181,10.11.1.12:2181,10.11.1.13:2181        指定客户端连接zookeeper的最大超时时间    zookeeper.connection.timeout.ms=6000</code></pre><ul><li>另外2台的配置只是需要修改broker.id即可，3台服务器保证broker.id不相同。</li></ul><h5 id="配置主机名对应IP的解析"><a href="#配置主机名对应IP的解析" class="headerlink" title="配置主机名对应IP的解析"></a>配置主机名对应IP的解析</h5><p><strong>3台配置相同</strong></p><pre><code>    vim /etc/hosts         10.11.1.11 server1    10.11.1.12 server2    10.11.1.13 server3</code></pre><h5 id="启动kafka环境"><a href="#启动kafka环境" class="headerlink" title="启动kafka环境"></a>启动kafka环境</h5><pre><code>    nohup ./kafka-server-start.sh ../config/server.properties &amp;</code></pre><p>kafka集群搭建OK</p><h3 id="3-部署logstash服务"><a href="#3-部署logstash服务" class="headerlink" title="3.部署logstash服务"></a>3.部署logstash服务</h3><p>在此架构中，logstash担任两种角色，也处于不同的层次</p><ul><li>对日志进行格式化等处理，对接转存到kafka集群中。</li><li>作为（消费者）从kafka集群中拉取日志消息。同步到ES集群。</li></ul><h4 id="部署日志处理层的logstash"><a href="#部署日志处理层的logstash" class="headerlink" title="部署日志处理层的logstash"></a>部署日志处理层的logstash</h4><p>这里用到了 <code>GeoLite</code>, 可用于转换IP，变成地理位置信息。</p><ul><li><a href="https://dev.maxmind.com/">GeoLite官网</a></li></ul><h5 id="从GeoLite官网下载-GeoLiteCity-dat-gz"><a href="#从GeoLite官网下载-GeoLiteCity-dat-gz" class="headerlink" title="从GeoLite官网下载 GeoLiteCity.dat.gz"></a>从GeoLite官网下载 <code>GeoLiteCity.dat.gz</code></h5><h5 id="从elastic官网下载-logstash-2-3-4-tar-gz"><a href="#从elastic官网下载-logstash-2-3-4-tar-gz" class="headerlink" title="从elastic官网下载 logstash-2.3.4.tar.gz"></a>从elastic官网下载 <code>logstash-2.3.4.tar.gz</code></h5><h5 id="解压logstash-2-3-4-tar-gz"><a href="#解压logstash-2-3-4-tar-gz" class="headerlink" title="解压logstash-2.3.4.tar.gz"></a>解压logstash-2.3.4.tar.gz</h5><pre><code>    cd /usr/local/logstash    tar -zxvf logstash-2.3.4.tar.gz</code></pre><h5 id="解压GeoLiteCity-dat-gz"><a href="#解压GeoLiteCity-dat-gz" class="headerlink" title="解压GeoLiteCity.dat.gz"></a>解压GeoLiteCity.dat.gz</h5><pre><code>    cd /usr/local/logstash    tar -zxvf GeoLiteCity.dat.gz</code></pre><h5 id="编辑获取日志并输出到kafka的配置文件"><a href="#编辑获取日志并输出到kafka的配置文件" class="headerlink" title="编辑获取日志并输出到kafka的配置文件"></a>编辑获取日志并输出到kafka的配置文件</h5><p><code>vim logstash_in_kafka.conf</code></p><pre><code>    # 用于接收Beats组件传送的日志信息    input &#123;        beats &#123;        port =&gt; 5044        codec =&gt; &quot;json&quot;    &#125;    &#125;        # 过滤日志内容，这里判断nginx日志时，增加ip转换的内容      filter &#123;        if [type] == &quot;nginxacclog&quot; &#123;             geoip &#123;            source =&gt; &quot;clientip&quot;            target =&gt; &quot;geoip&quot;            database =&gt; &quot;/usr/local/logstash/GeoLiteCity.dat&quot;            add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][longitude]&#125;&quot; ]            add_field =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;%&#123;[geoip][latitude]&#125;&quot; ]    &#125;            mutate &#123;            convert =&gt; [ &quot;[geoip][coordinates]&quot;,&quot;float&quot; ]         &#125;    &#125;    &#125;    # 输出到kafka中    output &#123;      kafka &#123;        workers =&gt; 2        bootstrap_servers =&gt; &quot;10.11.1.11:9092,10.11.1.12:9092,10.11.1.13:9092&quot;        topic_id =&gt; &quot;peiyinlog&quot;    &#125;    &#125;</code></pre><ul><li>workers：用于写入时的工作线程</li><li>bootstrap_servers：指定可用的kafka broker实例列表</li><li>topic_id：指定topic名称，可以在写入前手动在broker创建定义好分片数和副本数，也可以不提前创建，那么在logstash写入时会自动创建</li><li>topic，分片数和副本数则默认为broker配置文件中设置的。</li></ul><h5 id="启动logstash"><a href="#启动logstash" class="headerlink" title="启动logstash"></a>启动logstash</h5><pre><code>    nohup ./logstash agent -f logstash_in_kafka.conf &amp;</code></pre><h4 id="部署作为consumer的logstash"><a href="#部署作为consumer的logstash" class="headerlink" title="部署作为consumer的logstash"></a>部署作为consumer的logstash</h4><p>同样解压logstash-2.3.4.tar.gz，只是这里的配置文件不同</p><h5 id="编辑从kafka获取日志内容，传输到ES集群的配置文件"><a href="#编辑从kafka获取日志内容，传输到ES集群的配置文件" class="headerlink" title="编辑从kafka获取日志内容，传输到ES集群的配置文件"></a>编辑从kafka获取日志内容，传输到ES集群的配置文件</h5><p><code>vim kafka_to_es.conf</code></p><pre><code>    # 从kafka获取日志内容    input&#123;        kafka &#123;            zk_connect =&gt; &quot;10.11.1.11:2181,10.11.1.12:2181,10.11.1.13:2181&quot;            group_id =&gt; &quot;logstash&quot;            topic_id =&gt; &quot;peiyinlog&quot;            reset_beginning =&gt; false            consumer_threads =&gt; 50            decorate_events =&gt; true         &#125;         &#125;         # 删除一些不需要的字段      filter &#123;      if [type] == &quot;nginxacclog&quot; &#123;              mutate &#123;         remove_field =&gt; [&quot;slbip&quot;,&quot;kafka&quot;,&quot;domain&quot;,&quot;serverip&quot;,&quot;url&quot;,&quot;@version&quot;,&quot;offset&quot;,&quot;input_type&quot;,&quot;count&quot;,&quot;source&quot;,&quot;fields&quot;,&quot;beat.hostname&quot;,&quot;host&quot;,&quot;tags&quot;]        &#125;    &#125;         &#125;         # 输出日志到ES集群    output &#123;        if [type] == &quot;nginxacclog&quot; &#123;           # stdout &#123;codec =&gt; rubydebug &#125;            elasticsearch &#123;                hosts =&gt; [&quot;x.x.x.x:9200&quot;,&quot;x.x.x.x:9200&quot;]                index =&gt; &quot;logstash-nginxacclog-%&#123;+YYYY.MM.dd&#125;&quot;                manage_template =&gt; true                flush_size =&gt; 50000                idle_flush_time =&gt; 10                workers =&gt; 2    &#125;         &#125;        if [type] == &quot;messages&quot; &#123;            elasticsearch &#123;                hosts =&gt; [&quot;x.x.x.x:9200&quot;,&quot;x.x.x.x:9200&quot;]                index =&gt; &quot;logstash-messages-%&#123;+YYYY.MM.dd&#125;&quot;                manage_template =&gt; true                flush_size =&gt; 50000                idle_flush_time =&gt; 30                workers =&gt; 1    &#125;         &#125;         &#125;</code></pre><h5 id="启动logstash-1"><a href="#启动logstash-1" class="headerlink" title="启动logstash"></a>启动logstash</h5><pre><code>    nohup ./logstash agent -f kafka_to_es.conf &amp;</code></pre><h3 id="4-部署日志采集程序Filebeat"><a href="#4-部署日志采集程序Filebeat" class="headerlink" title="4.部署日志采集程序Filebeat"></a>4.部署日志采集程序Filebeat</h3><p>上述已说明使用beats组件作为日志采集程序，这里只使用了<code>filebeat</code>组件收集我们测试环境上的nginx日志centos操作系统日志，并传输到logstash中。</p><h4 id="从elastic官网下载-filebeat-1-2-3-x86-64-tar-gz"><a href="#从elastic官网下载-filebeat-1-2-3-x86-64-tar-gz" class="headerlink" title="从elastic官网下载 filebeat-1.2.3-x86_64.tar.gz"></a>从elastic官网下载 <code>filebeat-1.2.3-x86_64.tar.gz</code></h4><h4 id="解压logstash-2-3-4-tar-gz-1"><a href="#解压logstash-2-3-4-tar-gz-1" class="headerlink" title="解压logstash-2.3.4.tar.gz"></a>解压logstash-2.3.4.tar.gz</h4><pre><code>    cd /usr/local/filebeat    tar -zxvf ogstash-2.3.4.tar.gz</code></pre><h4 id="配置filebeat-yml-文件"><a href="#配置filebeat-yml-文件" class="headerlink" title="配置filebeat.yml 文件"></a>配置filebeat.yml 文件</h4><pre><code>    ################### Filebeat Configuration Example #########################         ############################# Filebeat ######################################         filebeat:      prospectors:        -          paths:            - /var/log/messages               input_type: log                     document_type: messages             -          paths:            - /var/log/nginx/access.log                     input_type: log               document_type: nginxacclog                        multiline:               pattern: &#39;^[[:space:]]&#39;              negate: true              match: after           registry_file: /var/lib/filebeat/registry                ############################# Output ##########################################           output:      logstash:         hosts: [&quot;x.x.x.x:5044&quot;,&quot;x.x.x.x:5044&quot;]                ############################# Shipper #########################################           shipper:       name: &quot;blu_test&quot;                  ############################# Logging #########################################            logging:        files:        rotateeverybytes: 10485760 # = 10MB</code></pre><h4 id="这里把nginx的access日志源改为json格式，方便后续处理"><a href="#这里把nginx的access日志源改为json格式，方便后续处理" class="headerlink" title="这里把nginx的access日志源改为json格式，方便后续处理"></a>这里把nginx的access日志源改为json格式，方便后续处理</h4><pre><code>    log_format json &#39;&#123; &quot;@timestamp&quot;:&quot;$time_local&quot;,&#39;             &#39;&quot;clientip&quot;:&quot;$remote_addr&quot;,&#39;             &#39;&quot;remote_user&quot;: &quot;$remote_user&quot;, &#39;             &#39;&quot;http_x_forwarded_for&quot;:&quot;$http_x_forwarded_for&quot;,&#39;             &#39;&quot;serverip&quot;:&quot;$server_addr&quot;,&#39;             &#39;&quot;size&quot;:$body_bytes_sent,&#39;             &#39;&quot;request_time&quot;:$request_time,&#39;             &#39;&quot;domain&quot;:&quot;$host&quot;,&#39;             &#39;&quot;request&quot;: &quot;$request&quot;, &#39;             &#39;&quot;method&quot;:&quot;$request_method&quot;,&#39;             &#39;&quot;requesturi&quot;:&quot;$request_uri&quot;,&#39;             &#39;&quot;url&quot;:&quot;$uri&quot;,&#39;             &#39;&quot;appversion&quot;:&quot;$HTTP_APP_VERSION&quot;,&#39;             &#39;&quot;referer&quot;:&quot;$http_referer&quot;,&#39;             &#39;&quot;agent&quot;:&quot;$http_user_agent&quot;,&#39;             &#39;&quot;status&quot;:&quot;$status&quot;&#125;&#39;;</code></pre><h4 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h4><pre><code>    nginx -s reload</code></pre><h4 id="启动-filebeat"><a href="#启动-filebeat" class="headerlink" title="启动 filebeat"></a>启动 filebeat</h4><pre><code>    cd /usr/local/filebeat/filebeat-1.2.3-x86_64    nohup ./filebeat start &amp;</code></pre><h3 id="5-安装配置kibana"><a href="#5-安装配置kibana" class="headerlink" title="5.安装配置kibana"></a>5.安装配置kibana</h3><h4 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h4><p>kibana最早是为了代替logstash-web 用来查看 ES 中的数据，用PHP编写的web</p><p>k2 是k1作者使用ruby重写</p><p>K3 是纯前端框架搭建，使用angularjs 编写</p><p>K4 是使用node.js编写</p><p>目前最新的版本已经是K5 </p><p>本次部署依然选用了比较成熟的k4,安装也相对比较简单</p><h5 id="从elastic官网下载-kibana-4-6-3-linux-x86-64-tar-gz"><a href="#从elastic官网下载-kibana-4-6-3-linux-x86-64-tar-gz" class="headerlink" title="从elastic官网下载 kibana-4.6.3-linux-x86_64.tar.gz"></a>从elastic官网下载 <code>kibana-4.6.3-linux-x86_64.tar.gz</code></h5><h5 id="解压kibana-4-6-3-linux-x86-64-tar-gz"><a href="#解压kibana-4-6-3-linux-x86-64-tar-gz" class="headerlink" title="解压kibana-4.6.3-linux-x86_64.tar.gz"></a>解压kibana-4.6.3-linux-x86_64.tar.gz</h5><pre><code>    cd /usr/local/kibana    tar -zxvf kibana-4.6.3-linux-x86_64.tar.gz</code></pre><h5 id="配置kibana-yml-文件"><a href="#配置kibana-yml-文件" class="headerlink" title="配置kibana.yml 文件"></a>配置kibana.yml 文件</h5><pre><code>    cd /usr/local/kibana/kibana-4.6.3-linux-x86_64/config    vim kibana.yml</code></pre><p>一堆参数，只需修改这3个，即可启动</p><pre><code>    # Kibana is served by a back end server. This controls which port to use.    server.port: 5601        # The host to bind the server to.    server.host: &quot;0.0.0.0&quot;        # The Elasticsearch instance to use for all your queries.    elasticsearch.url: &quot;http://IP:9200&quot;</code></pre><h5 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h5><pre><code>    nohup ./kibana &amp;</code></pre><h4 id="访问kibana，配置日志索引"><a href="#访问kibana，配置日志索引" class="headerlink" title="访问kibana，配置日志索引"></a>访问kibana，配置日志索引</h4><ul><li>访问地址： <code>http://IP:5601</code></li></ul><p>默认情况下，Kibana 认为你要访问的是通过 Logstash 导入 Elasticsearch 的数据。这时候你可以用默认的 logstash-* 作为你的 index pattern。通配符(*) 匹配索引名中零到多个字符。如果你的 Elasticsearch 索引有其他命名约定，输入合适的 pattern。pattern 也开始是最简单的单个索引的名字。</p><p><img src="https://ws1.sinaimg.cn/mw690/7108d6c2ly1fdlec8xlpfj210z0hbtae"></p><p>如果一个新索引是定期生成，而且索引名中带有时间戳，选择 <code>Use event times to create index names</code> 选项，然后再选择 <code>Index pattern interval</code>。这可以提高搜索性能，Kibana 会至搜索你指定的时间范围内的索引。在你用 Logstash 输出数据给 Elasticsearch 的情况下尤其有效。</p><p>点击 <code>Create</code> 添加 <code>index pattern</code>。第一个被添加的 pattern 会自动被设置为默认值。如果你有多个 index pattern 的时候，你可以在 Settings &gt; Indices 里设置具体哪个是默认值。</p><p><img src="https://ws1.sinaimg.cn/mw690/7108d6c2ly1fdleezdoyrj21070pgq78"></p><h4 id="kibana简单介绍"><a href="#kibana简单介绍" class="headerlink" title="kibana简单介绍"></a>kibana简单介绍</h4><p>简单介绍下kibana的三个模块</p><h5 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h5><p>可以从 <strong><code>Discover</code></strong> 页面以交互方式探索日志数据，可以过滤搜索结果以及查看文档数据。 还可以查看与搜索查询匹配的文档数，并获取字段值统计信息，可以配置时间字段，则日志随时间的分布将显示在页面顶部的直方图中。</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlh5o8arrj218m0ekwgf"></p><h5 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h5><p><strong><code>Visualize</code></strong> 用来构建显示相关可视化的仪表板.Kibana可视化基于Elasticsearch查询。 通过使用一系列Elasticsearch聚合来提取和处理数据</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlh5z4x7ej210p0k6tb6"></p><h5 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h5><p>Kibana仪表板显示已保存的可视化对象的集合。 可以根据需要安排和调整可视化对象，并保存仪表板，以便重新加载和共享。</p><p>我在Visualize中制作了一些简单的统计，绘制了一个Dashboard</p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdlhexd03kj21f30qzqfa"></p><p>目前对Kibana及ES尚未深入了解，后续有一定掌握之后再做总结分享。</p><h3 id="后续优化："><a href="#后续优化：" class="headerlink" title="后续优化："></a>后续优化：</h3><ul><li>部署的的相关应用统一管理等</li><li>ES 调优</li><li>kafka集群调优</li><li>kibana扩展</li><li>kibana接入到nginx中</li><li>等等</li></ul><p>参考资料：</p><ul><li><p><a href="https://www.gitbook.com/book/chenryn/elk-stack-guide-cn/details">elk-stack-guide-cn</a></p></li><li><p><a href="https://www.elastic.co/">elastic.co</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多说评论一篇文章被评论后，其他文章都添加了相同的评论</title>
      <link href="/2017/03/10/%E6%9D%82%E8%AE%B0/%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2017/03/10/%E6%9D%82%E8%AE%B0/%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端时间开博客开通了评论功能，使用的是<code>多说评论</code>duoshuo.com，今天在查找一些资料时，发现每一篇博客都有相同的评论，<span id="more"></span><br>自己当时没有测试该功能，居然有出现这种问题，看来还是凡事都得马虎不得，不能轻易想当然！</p></blockquote><p>简单梳理了下解决的思路，希望对遇到相同问题的朋友有所帮助</p><h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ul><li>查找原因</li></ul><p>每一篇文章都是相同的回复，测试了一下，回复一篇文章，其他文章都出现了自己的回复，<strong>认为是同一篇文章？</strong></p><p>先登录多说的管理后台，看到评论的文章名称都是乱码。</p><p>再查看自己的配置，检查哪里是否配置错，</p><p>评论模块的配置：comment.ejs</p><p>这里是copy的多说提供的通用配置</p><pre><code>    &lt;!-- 多说评论框 start --&gt;        &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;请将此处替换成文章在你的站点中的ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt;    &lt;!-- 多说评论框 end --&gt;    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;     。。。    &lt;!-- 多说公共JS代码 end --&gt;</code></pre><p>这里可以看出<code>data-thread-key</code> 是个关键字段，是用来区分文章的唯一ID，这里居然居然没改，问题肯定在这里，马上检查生成的html，果然<code>&lt;section id=&quot;comments&quot; class=&quot;comment&quot;&gt;</code>模块部分生成的代码data-thread-key&#x3D;内容都是乱码了，打开几篇文章查看，果然都是相同的乱码。因为comment.ejs默认的编码不是UTF-8。所以嵌入到文章里只有这部分是乱码</p><ul><li>问题解决</li></ul><p> 把comment.ejs中的中文注释全部删除，COPY 最新的 多说通用代码，修改data-thread-key， data-title，data-url的配置</p><pre><code>    &lt;section id=&quot;comments&quot; class=&quot;comment&quot;&gt;        &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%- page.path %&gt;&quot; data-title=&quot;&lt;%- page.title %&gt;&quot; data-url=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;/div&gt;      &lt;script type=&quot;text/javascript&quot;&gt;       var duoshuoQuery = &#123;short_name:&quot;zijide&quot;&#125;;        (function() &#123;            var ds = document.createElement(&#39;script&#39;);            ds.type = &#39;text/javascript&#39;;ds.async = true;            ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;            ds.charset = &#39;UTF-8&#39;;            (document.getElementsByTagName(&#39;head&#39;)[0]              || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);        &#125;)();        &lt;/script&gt;    &lt;/section&gt;</code></pre><p>再次发布，测试评论模块及回评，OK了。</p><ul><li><a href="https://dev.duoshuo.com/docs/5003ecd94cab3e7250000008">评论框调用代码参数说明</a></li></ul><blockquote><p>凡事须再细心，认真</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 15 Tomcat JRebel 6.4 实现热部署</title>
      <link href="/2017/03/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20IDEA%2015%20Tomcat%20JRebel%206.4%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/03/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20IDEA%2015%20Tomcat%20JRebel%206.4%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="idea-是个好东东"><a href="#idea-是个好东东" class="headerlink" title="idea 是个好东东"></a><strong>idea 是个好东东</strong></h3><blockquote><p>使用Intellij IDEA 一个月了，期间了解及感受到了其许多美妙之处，使用过程中遇到许多问题，既然博客已经搭建起来了，后面多记录，<span id="more"></span>多总结吧~</p></blockquote><h3 id="关于热部署"><a href="#关于热部署" class="headerlink" title="关于热部署"></a><strong>关于热部署</strong></h3><blockquote><p>刚开始玩idea，项目从eclipse导过来的，使用的maven构建，tomcat作为容器，每次修改类，文件等都需要使用maven重新编译，打包，重启tomcat，刚开始使用idea，不太熟络，而且编译打包速度也挺快，就当是熟悉过程，这样编译，重启，编译重启一段时间后，果然还是觉得影响效率，于是尝开始思考，尝试如何热部署环境。</p></blockquote><h3 id="关于JRebel"><a href="#关于JRebel" class="headerlink" title="关于JRebel"></a><strong>关于JRebel</strong></h3><blockquote><p>Jrebel 可快速实现热部署，节省了大量重启时间，提高了个人开发效率,JRebel是收费软件 ! 好东西果然收费</p></blockquote><blockquote><p>JRebel是一款JAVA虚拟机插件，它使得JAVA程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。JRebel使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个<br>变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程，每年可以省去部署用的时间花费高达5.25个星期。<br>-百度百科</p></blockquote><p> <strong>下载JRebel for Intellij插件</strong><br><img src="http://i.imgur.com/7RwOoRE.png"></p><h4 id="破解JRebel"><a href="#破解JRebel" class="headerlink" title="破解JRebel"></a><strong>破解JRebel</strong></h4><blockquote><p>好东西都收费，我只是本地使用，非商业用途，就不打算破费了，请大家支持正版，呼呼，我下载的JRebel版本是6.4.8 百度到了6.4左右的破解文件，可以通用，这里大概记录下破解过程，比较简单也</p></blockquote><ul><li><a href="http://pan.baidu.com/s/1qYJ7Kfy">破解文件下载地址</a></li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><blockquote><p>时间原因，这次没有描述部署tomcat的方法，后面有空的话再补上吧，今天只记录下jrebel的破解，及配置部署的，其实也很简单，有个重点的提示就是在部署工程的war时，要选 <strong>exploded</strong> 这样在<strong>Server页</strong>的”On Update action “才可以选择 <strong>update classes and resources</strong></p></blockquote><h5 id="1-关闭idea"><a href="#1-关闭idea" class="headerlink" title="1. 关闭idea"></a>1. 关闭idea</h5><h5 id="2-破解补丁"><a href="#2-破解补丁" class="headerlink" title="2. 破解补丁"></a>2. 破解补丁</h5><pre><code>     解压缩破解补丁，替换对应idea的JRebel插件的俩个jar包及放置jrebel.lic文件    ~\用户名\.IntelliJIdea15\config\plugins\jr-ide-idea\lib\jrebel6\jrebel.jar    ~\用户名\.IntelliJIdea15\config\plugins\jr-ide-idea\lib\jrebel\jrebel.jar    ~\用户名\.jrebel\jrebel.lic</code></pre><h5 id="3-替换后好，重启idea"><a href="#3-替换后好，重启idea" class="headerlink" title="3. 替换后好，重启idea"></a>3. 替换后好，重启idea</h5><h5 id="4-选择热部署的项目"><a href="#4-选择热部署的项目" class="headerlink" title="4. 选择热部署的项目"></a>4. 选择热部署的项目</h5><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fdfle6iltzj208c0edglr"></p><h5 id="5-TOMCAT-配置-这里有重点"><a href="#5-TOMCAT-配置-这里有重点" class="headerlink" title="5. TOMCAT 配置 这里有重点"></a>5. <strong>TOMCAT 配置</strong> 这里有重点</h5><p><img src="http://i.imgur.com/WgyWr8U.png"></p><p><img src="http://i.imgur.com/VSrk60c.png"></p><p><img src="http://i.imgur.com/wGFqdjS.png"></p><blockquote><p>本地试玩后，果然酸爽，后续使用过程遇到问题，或使用一段时间后，再做记录，及总结感受~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ngxtop-nginx监控</title>
      <link href="/2017/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ngxtop-nginx%E7%9B%91%E6%8E%A7/"/>
      <url>/2017/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ngxtop-nginx%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nginx的接入日志，是一份巨大的宝库，通过监控，分析日志，可以掌握系统的运载情况，甚至可以分析用户行为。</p></blockquote><p>想到日志的监控，分析，最容易想到tail，awk这样的命令，但实际操作中，刷刷流过的日志信息，似乎也不会让你有什么头绪。</p><h2 id="ngxtop-简介"><a href="#ngxtop-简介" class="headerlink" title="ngxtop 简介"></a>ngxtop 简介</h2><p>ngxtop 类似于linux的 top 命令，设计为在短时间内运行，作为服务器的故障排除和监控使用</p><p>ngxtop 使用python2编写和测试，但也可以支持python3，使用sqlite 数据库</p><h2 id="ngxtop-安装"><a href="#ngxtop-安装" class="headerlink" title="ngxtop 安装"></a>ngxtop 安装</h2><p>ngxtop使用python编写， 所以可以使用pip命令进行安装，确保机器上已经安装好了python环境和pip</p><pre><code>    sudo pip install ngxtop</code></pre><ul><li>注意：</li></ul><p>安装成功，但执行<code>ngxtop</code>时，报这种错误：</p><pre><code>ImportError: No module named _curses</code></pre><p>是因为 <code>ngxtop</code> 可执行命令未安装到 &#x2F;usr&#x2F;bin&#x2F;下，而是&#x2F;usr&#x2F;local&#x2F;bin&#x2F;，所以建议安装时，加上 sudo</p><h2 id="ngxtop-命令简介"><a href="#ngxtop-命令简介" class="headerlink" title="ngxtop 命令简介"></a>ngxtop 命令简介</h2><pre><code>用法:    ngxtop [options]    ngxtop [options] (print|top|avg|sum) &lt;var&gt; ...    ngxtop info    ngxtop [options] query &lt;query&gt; ...</code></pre><h3 id="参数选项说明"><a href="#参数选项说明" class="headerlink" title="参数选项说明"></a>参数选项说明</h3><ul><li>-l <file>或–access-log <file> 日志的路径</li><li>-f <format>或–log-format <format> 设置日志格式，默认格式combined，另外一种较常用格式为common</li><li>–no-follow 处理历史的日志</li><li>-t <seconds> 或 –interval <seconds> 刷新频率，默认2秒</li><li>-g <var>或 –group-by <var> 按变量分组，默认显示 request_path</li><li>-w <var>或 –having <expr> 筛选 [default: 1]</li><li>-o <var>或 –order-by <var> 输出的排序方式，默认: 访问数</li><li>-n <number>或 –limit <number> 显示top多条，默认前top 10条</li><li>-a <exp> …或 –a <exp> … 对输出字段做处理，可选 sum, avg, min, max</li><li>-v或 –verbose 详细输出</li><li>-d或 –debug debug模式，输出每行及记录</li><li>-h或 –help 显示帮助详细</li><li>–version 显示版本信息</li></ul><p><strong>高级选项</strong></p><ul><li>-c <file>或 –config <file> 指定nginx配置文件，自动分析日志格式</li><li>-i <filter-expression>或 –filter <filter-expression> 只处理符合规则的记录</li><li>-p <filter-expression>或 –pre-filter <filter-expression> in-filter expression to check in pre-parsing phase.<br>另外一些变量可以在分析时用到，名字含义同日志格式里的设置：remote_addr、remote_user、time_local、request、request_path、status、body_bytes_sent、http_referer、http_user_agent。</li></ul><p>使用示例：</p><ul><li><p>列出10个nginx服务器，按请求数量排序</p><pre><code>  ngxtop</code></pre></li><li><p>显示前20个最频繁的请求</p><pre><code>  ngxtop -n 20 </code></pre></li><li><p>获取nginx基本信息</p><pre><code>  ngxtop info  </code></pre></li><li><p>以自定义显示的变量，简单列出需要显示的变量。使用 “print” 命令显示自定义请求。</p><pre><code>  ngxtop print request http_user_agent remote_addr  </code></pre></li><li><p>显示请求最多的客户端IP地址</p><pre><code>  ngxtop top remote_addr  </code></pre></li><li><p>显示状态码是404的请求</p><pre><code>  ngxtop -i &#39;status == 404&#39; print request status</code></pre></li><li><p>统计访问次数最多的请求</p><pre><code>  ngxtop -l access.log --no-follow</code></pre></li><li><p>自定义排序的字段</p><pre><code>  ngxtop -l access.log --no-follow -o avg_bytes_sent</code></pre></li><li><p>自定义过滤条件</p><pre><code>  只统计成功  ngxtop -l access.log --no-follow -i &#39;status!=200&#39;</code></pre></li><li><p>输出400以上状态吗的请求以及请求来源</p><p>  ngxtop -i ‘status &gt;&#x3D; 400’ print request status http_referer</p></li><li><p>搜索客户端为 iPhone 的 log</p><pre><code>   ngxtop -l access.log --no-follow -i &#39;http_user_agent.find(&#39;iPhone&#39;)&#39;   条件里是可以嵌 python 语句的，这些语句被 eval() 动态翻译并执行。需要注意的是这些语句如果抛出异常会导致 ngxtop 异常退出。</code></pre></li><li><p>分组过滤</p><pre><code>   -g 相当于 group by,   -a 相当于 having。   ngxtop 已经默认提供了 avg_bytes_sent, 2xx, 3xx, 4xx, 5xx 这些聚合字段，一般这些字段已经足够了。   如果业务复杂了，想做出更多的查询，可以利用这两个参数自己组合条件。   访问量前十的ip地址      ngxtop --group-by remote_addr</code></pre></li><li><p>除了Nginx，ngtop 还可以处理其他的日志文件，比如还可以监控apache日志，如：</p></li></ul><p>使用普通格式从远程服务器解析apache日志</p><pre><code>ssh user@remote_server tail -f /var/log/apache2/access.log | ngxtop -f common</code></pre><p>更多内容请参见 ： </p><ul><li><a href="https://github.com/lebinh/ngxtop">ngxtop</a></li></ul><p>另外再推荐一个可以生成统计报表，输出为html，cvs等文件的分析统计 : </p><ul><li><a href="https://github.com/allinurl/goaccess/">goaccess</a></li></ul><blockquote><p>让人过于舒服的路，都是下坡路；最不费力气的行走，都是顺风走。然而，动物园里养不出千里马，水井里也生不出腾飞的巨龙。你最终变成什么样，很大程度上取决于你在人生道路上，是选择迎风奔跑，还是就坡下驴。努力这个词太平凡，但努力将使你的人生不平庸。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wrk 安装与使用</title>
      <link href="/2017/02/25/%E5%B7%A5%E5%85%B7/%20wrk%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/02/25/%E5%B7%A5%E5%85%B7/%20wrk%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>wrk 和 apache benchmark（ab）同属于性能测试工具，<!---more---> 但是比 ab 功能更加强大，还可以支持lua脚本来创建复杂的测试场景。</p></blockquote><blockquote><p>wrk 的一个很好的特性就是能用很少的线程压出很大的并发量， 原因是它使用了一些操作系统特定的高性能 I&#x2F;O 机制, 比如 select, epoll, kqueue 等。 其实它是复用了 redis 的 ae 异步事件驱动框架. 确切的说 ae 事件驱动框架并不是 redis 发明的, 而是来自于 Tcl的解释器 jim, 这个小巧高效的框架, 因为被 redis 采用而更多的被大家所熟知.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>准备条件</p></blockquote><ol><li>确保linux上已经安装了 make工具 (sudo apt-get install make)</li><li>GCC 编译环境（sudo apt-get install build-essential）</li></ol><ul><li><a href="https://github.com/wg/wrk.git">wrk Git 地址</a></li></ul><blockquote><p>安装</p></blockquote><ul><li><p>安装 luajit</p><pre><code>  sudo apt-get install build-essential libssl-dev git  git clone http://luajit.org/git/luajit-2.0.git  cd luajit  make &amp;&amp; sudo make install</code></pre></li><li><p>然后下载wrk的源码</p><pre><code>  git clone https://github.com/wg/wrk.git  cd wrk</code></pre></li><li><p>在上一步下载的 luajit 代码中，有一个 jit 文件夹，需要复制到 wrk 目录下</p></li><li><p>执行<code>make</code></p></li></ul><p>执行编译后，生成wrk文件</p><pre><code>    make    # move the executable to somewhere in your PATH    sudo cp wrk /usr/local/bin</code></pre><p><img src="http://i.imgur.com/9eJoM7q.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>执行简单的命令</p><pre><code>    ./wrk -t4 -c1000 -d10s -T30s --latency http://www.baidu.com</code></pre><p>执行结果：</p><p><img src="http://i.imgur.com/HM57lBt.png"></p><blockquote><p>简要说明下wrk的参数的含义</p></blockquote><ul><li>-t 线程数</li><li>-c 连接数</li><li>-d 测试持续时间</li><li>-T 超时时间</li><li>–latency 响应的分布时间</li></ul><blockquote><p>响应结果的参数含义:</p></blockquote><ul><li><p>Latency：响应时间</p></li><li><p>Req&#x2F;Sec：每秒请求数量，也就是并发能力</p></li><li><p>Avg：平均</p></li><li><p>Max：最大</p></li><li><p>Stdev：标准差</p></li><li><p>+&#x2F;- Stdev： 正负一个标准差占比</p></li><li><p>Latency: 响应的分布时间</p></li><li><p>注意：模拟测试的时候，一般线程数不宜过多，核数的2到4倍足够了。 多了反而因为线程切换过多造成效率降低， 因为 wrk 不是使用每个连接一个线程的模型， 而是通过异步网络 I&#x2F;O 提升并发量。 所以网络通信不会阻塞线程执行，这也是 wrk 可以用很少的线程模拟大量网路连接的原因。</p></li></ul><h2 id="支持lua脚本"><a href="#支持lua脚本" class="headerlink" title="支持lua脚本"></a>支持lua脚本</h2><blockquote><p>这块内容只是简单了解了下，还是很强大，等用到后，在做笔记吧~</p></blockquote><blockquote><ul><li>用人不在于如何减少人的短处, 而在于如何发挥人的长处。   –彼得.德鲁克 (管理学之父)</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置访问日志</title>
      <link href="/2017/02/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/"/>
      <url>/2017/02/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 对接调式排查问题时，查询日志是非常关键的，nginx作为负载&#x2F;反向代理，冲在第一线可以收集到很多访问&#x2F;接入信息。熟悉和了解nginx的日志模块，对排查，分析，统计都有帮助。</p></blockquote><h3 id="nginx的日志相关指令"><a href="#nginx的日志相关指令" class="headerlink" title="nginx的日志相关指令"></a>nginx的日志相关指令</h3><hr><h4 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h4><ul><li>用于设置日志的格式</li></ul><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><ul><li><p>log_format name string</p></li><li><p><code>name</code>:格式名称</p></li><li><p><code>string</code>:定义的格式</p></li></ul><p>举例：</p><pre><code>    log_format access  &#39;$http_x_forwarded_for $remote_addr [$time_local] &quot;$request&quot; &#39;               &#39;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$request_body&quot; &quot;$sent_http_last_modified&quot; &quot;$remote_user&quot; &#39;;</code></pre><ul><li><p>当日志文件中记录的值为”-“时，表示为空</p></li><li><p>access为自定义的日志格式的名称，使用时引用即可：</p><pre><code>access_log /var/log/nginx/access.log  access;</code></pre></li></ul><h5 id="具体设置的参数说明："><a href="#具体设置的参数说明：" class="headerlink" title="具体设置的参数说明："></a>具体设置的参数说明：</h5><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$args</td><td>#请求中的参数值</td><td></td></tr><tr><td>$query_string</td><td>#同 $args</td><td></td></tr><tr><td>$arg_NAME</td><td>#GET请求中NAME的值</td><td></td></tr><tr><td>$is_args</td><td>#如果请求中有参数，值为”?”，否则为空字符串</td><td></td></tr><tr><td>$uri</td><td>#请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”&#x2F;foo&#x2F;bar.html”。</td><td></td></tr><tr><td>$document_uri</td><td>#同 $uri</td><td></td></tr><tr><td>$document_root</td><td>#当前请求的文档根目录或别名</td><td></td></tr><tr><td>$host</td><td>#优先级：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名.请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称</td><td></td></tr><tr><td>$hostname</td><td>#主机名</td><td></td></tr><tr><td>$https</td><td>#如果开启了SSL安全模式，值为”on”，否则为空字符串。</td><td></td></tr><tr><td>$binary_remote_addr</td><td>#客户端地址的二进制形式，固定长度为4个字节</td><td></td></tr><tr><td>$body_bytes_sent</td><td>#传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的”%B”参数保持兼容</td><td></td></tr><tr><td>$bytes_sent</td><td>#传输给客户端的字节数</td><td></td></tr><tr><td>$connection</td><td>#TCP连接的序列号</td><td></td></tr><tr><td>$connection_requests</td><td>#TCP连接当前的请求数量</td><td></td></tr><tr><td>$content_length</td><td>#”Content-Length” 请求头字段</td><td></td></tr><tr><td>$content_type</td><td>#”Content-Type” 请求头字段</td><td></td></tr><tr><td>$cookie_name</td><td>#cookie名称</td><td></td></tr><tr><td>$limit_rate</td><td>#用于设置响应的速度限制</td><td></td></tr><tr><td>$msec</td><td>#当前的Unix时间戳</td><td></td></tr><tr><td>$nginx_version</td><td>#nginx版本</td><td></td></tr><tr><td>$pid</td><td>#工作进程的PID</td><td></td></tr><tr><td>$pipe</td><td>#如果请求来自管道通信，值为”p”，否则为”.”</td><td></td></tr><tr><td>$proxy_protocol_addr</td><td>#获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串</td><td></td></tr><tr><td>$realpath_root</td><td>#当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径</td><td></td></tr><tr><td>$remote_addr</td><td>#客户端地址</td><td></td></tr><tr><td>$remote_port</td><td>#客户端端口</td><td></td></tr><tr><td>$remote_user</td><td>#用于HTTP基础认证服务的用户名</td><td></td></tr><tr><td>$request</td><td>#代表客户端的请求地址</td><td></td></tr><tr><td>$request_body</td><td>#客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器</td><td></td></tr><tr><td>$request_body_file</td><td>#将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传 递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off</td><td></td></tr><tr><td>$request_completion</td><td>#如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空</td><td></td></tr><tr><td>$request_filename</td><td>#当前连接请求的文件路径，由root或alias指令与URI请求生成</td><td></td></tr><tr><td>$request_length</td><td>#请求的长度 (包括请求的地址，http请求头和请求主体)</td><td></td></tr><tr><td>$request_method</td><td>#HTTP请求方法，通常为”GET”或”POST”</td><td></td></tr><tr><td>$request_time</td><td>#处理客户端请求使用的时间,单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</td><td></td></tr><tr><td>$request_uri</td><td>#这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”&#x2F;cnphp&#x2F;test.php?arg&#x3D;freemouse”</td><td></td></tr><tr><td>$scheme</td><td>#请求使用的Web协议，”http” 或 “https”</td><td></td></tr><tr><td>$server_addr</td><td>#服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中</td><td></td></tr><tr><td>$server_name</td><td>#服务器名</td><td></td></tr><tr><td>$server_port</td><td>#服务器端口</td><td></td></tr><tr><td>$server_protocol</td><td>#服务器的HTTP版本，通常为 “HTTP&#x2F;1.0” 或 “HTTP&#x2F;1.1”</td><td></td></tr><tr><td>$status</td><td>#HTTP响应代码</td><td></td></tr><tr><td>$time_iso8601</td><td>#服务器时间的ISO 8610格式</td><td></td></tr><tr><td>$time_local</td><td>#服务器时间（LOG Format 格式）</td><td></td></tr><tr><td>$cookie_NAME</td><td>#客户端请求Header头中的cookie变量，前缀”$cookie_”加上cookie名称的变量，该变量的值即为cookie名称的值</td><td></td></tr><tr><td>$http_NAME</td><td>#匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：”Accept-Language”，$http_accept_language即可</td><td></td></tr><tr><td>$http_cookie</td><td></td><td></td></tr><tr><td>$http_host</td><td>#请求地址，即浏览器中你输入的地址（IP或域名）</td><td></td></tr><tr><td>$http_referer</td><td>#url跳转来源,用来记录从那个页面链接访问过来的</td><td></td></tr><tr><td>$http_user_agent</td><td>#用户终端浏览器等信息</td><td></td></tr><tr><td>$http_x_forwarded_for</td><td></td><td></td></tr><tr><td>$sent_http_NAME</td><td>#可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可</td><td></td></tr><tr><td>$sent_http_cache_control</td><td></td><td></td></tr><tr><td>$sent_http_connection</td><td></td><td></td></tr><tr><td>$sent_http_content_type</td><td></td><td></td></tr><tr><td>$sent_http_keep_alive</td><td></td><td></td></tr><tr><td>$sent_http_last_modified</td><td></td><td></td></tr><tr><td>$sent_http_location</td><td></td><td></td></tr><tr><td>$sent_http_transfer_encoding</td><td></td><td></td></tr></tbody></table><ul><li><p>常用的配置：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端地址</td><td>211.28.65.253</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>—</td></tr><tr><td>$time_local</td><td>访问时间和时区</td><td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求的URI和HTTP协议</td><td>“GET &#x2F;article-10000.html HTTP&#x2F;1.1”</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.it300.com/">www.it300.com</a> 192.168.100.100</td></tr><tr><td>$status</td><td>HTTP请求状态</td><td>200</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端文件内容大小</td><td>1547</td></tr><tr><td>$http_referer</td><td>url跳转来源</td><td><a href="https://www.baidu.com/">https://www.baidu.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户终端浏览器等信息</td><td>Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本TLSv1</td><td></td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.10.10.100:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.002</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr><tr><td>$request_body</td><td>post请求的参数</td><td>—</td></tr></tbody></table></li></ul><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ul><li>如何设置nginx中remote_addr和x_forwarded_for参数</li></ul><p><code>remote_addr</code> : remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP</p><p><code>x_forwarded_for</code>:通常web服务器放在反向代理的后面，当使用了代理时，web服务器就不知道你的真实IP了，为了避免这个情况，代理服务器通常会增加一个<code>x_forwarded_for</code>的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP.</p><ul><li><p>在server中设置x_forwarded_for</p><pre><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre></li></ul><h4 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h4><ul><li>用来指定日志文件的存放路径、格式</li></ul><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><ul><li>access_log path [format [buffer&#x3D;size [flush&#x3D;time]]];</li><li>access_log path format gzip[&#x3D;level] [buffer&#x3D;size] [flush&#x3D;time];</li><li>access_log syslog:server&#x3D;address[,parameter&#x3D;value] [format];</li><li>access_log off;</li></ul><p>默认值: access_log logs&#x2F;access.log combined;</p><p>配置段: http, server, location, if in location, limit_except</p><p>gzip压缩等级。</p><p>buffer设置内存缓存区大小。</p><p>flush保存在缓存区中的最长时间。</p><p>不记录日志：access_log off;</p><p>使用默认combined格式记录日志：access_log logs&#x2F;access.log 或 access_log logs&#x2F;access.log combined;</p><h4 id="open-log-file-cache"><a href="#open-log-file-cache" class="headerlink" title="open_log_file_cache"></a>open_log_file_cache</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h5><ul><li>open_log_file_cache max&#x3D;N [inactive&#x3D;time] [min_uses&#x3D;N] [valid&#x3D;time];</li><li>open_log_file_cache off;</li></ul><p>默认值: open_log_file_cache off;</p><p>配置段: http, server, location</p><p>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)，格式如下：</p><p>参数注释如下：</p><ul><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>off：禁用缓存</li></ul><p>实例：</p><pre><code>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</code></pre><h4 id="log-not-found"><a href="#log-not-found" class="headerlink" title="log_not_found"></a>log_not_found</h4><ul><li>是否在error_log中记录不存在的错误。默认是。</li></ul><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h5><ul><li>log_not_found on | off;</li></ul><p>默认值: log_not_found on;</p><p>配置段: http, server, location</p><h4 id="log-subrequest"><a href="#log-subrequest" class="headerlink" title="log_subrequest"></a>log_subrequest</h4><ul><li>是否在access_log中记录子请求的访问日志。默认不记录。</li></ul><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法:"></a>语法:</h5><ul><li>log_subrequest on | off;<br>默认值: log_subrequest off;<br>配置段: http, server, location</li></ul><h4 id="rewrite-log"><a href="#rewrite-log" class="headerlink" title="rewrite_log"></a>rewrite_log</h4><ul><li>启用时将在error log中记录notice级别的重写日志。</li></ul><p>由ngx_http_rewrite_module模块提供的。用来记录重写日志的。对于调试重写规则建议开启。 Nginx重写规则指南</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法:"></a>语法:</h5><p>rewrite_log on | off;</p><p>默认值: rewrite_log off;</p><p>配置段: http, server, location, if</p><h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h4><ul><li>配置错误日志。</li></ul><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法:"></a>语法:</h5><ul><li>error_log file | stderr | syslog:server&#x3D;address[,parameter&#x3D;value] [debug | info | notice | warn | error | crit | alert | emerg];</li></ul><p>默认值: error_log logs&#x2F;error.log error;</p><p>配置段: main, http, server, location</p><h3 id="日志统计分析"><a href="#日志统计分析" class="headerlink" title="日志统计分析"></a>日志统计分析</h3><p>＞　看到某大师分享的关于手动分析的日志的方式，方法不错，简单记录下</p><p><strong>Nginx 日志能够记录的变量还有很多没出现在默认配置中：</strong></p><p>比如：</p><p>请求数据大小：$request_length</p><p>返回数据大小：$bytes_sent</p><p>请求耗时：$request_time</p><p>所用连接序号：$connection</p><p>当前连接发生请求数：$connection_requests</p><p>Nginx 的默认格式不可计算统计，需要想办法转换成可统计计算的格式，比如用控制字符 ^A (Mac 下 ctrl+v ctrl+a 打出)分割每个字段。</p><p>log_format 的格式可以变成这样：</p><pre><code>    log_format new &#39;$remote_addr^A$http_x_forwarded_for^A$host^A$time_local^A$status^A&#39;    &#39;$request_time^A$request_length^A$bytes_sent^A$http_referer^A$request^A$http_user_agent&#39;;</code></pre><p>这样之后就通过常见的 Linux 命令行工具进行分析了：</p><ul><li><p>查找访问频率最高的 URL 和次数：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;print $10&#125;’ | sort | uniq -c</code></pre></li><li><p>查找当前日志文件 500 错误的访问：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5 == 500) print $0&#125;’</code></pre></li><li><p>查找当前日志文件 500 错误的数量：<br>cat access.log | awk -F ‘^A’ ‘{if($5 &#x3D;&#x3D; 500) print $0}’ | wc -l</p></li><li><p>查找某一分钟内 500 错误访问的数量:</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5 == 500) print $0&#125;’ | grep ’09:00’ | wc-l</code></pre></li><li><p>查找耗时超过 1s 的慢请求：</p><pre><code>tail -f access.log | awk -F ‘^A’ ‘&#123;if($6&gt;1) print $0&#125;’</code></pre></li><li><p>假如只想查看某些位：</p><pre><code>tail -f access.log | awk -F ‘^A’ ‘&#123;if($6&gt;1) print $3″|”$4&#125;’</code></pre></li><li><p>查找 502 错误最多的 URL：</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5==502) print $11&#125;’ | sort | uniq -c</code></pre></li><li><p>查找 200 空白页</p><pre><code>cat access.log | awk -F ‘^A’ ‘&#123;if($5==200 &amp;&amp; $8 &lt; 100) print $3″|”$4″|”$11″|”$6&#125;’</code></pre></li><li><p>查看实时日志数据流</p><pre><code>tail -f access.log | cat -e</code></pre></li><li><p>或者</p><pre><code>tail -f access.log | tr ‘^A’ ‘|’</code></pre></li></ul><p>按这个思路可以做很多其他分析，比如 UA 最多的访问；访问频率最高的 IP；请求耗时分析；请求返回包大小分析；等等。</p><h3 id="切割日志"><a href="#切割日志" class="headerlink" title="切割日志"></a>切割日志</h3><p>Nginx 的日志都是写在一个文件当中的，不会自动地进行切割，如果访问量很大的话，将导致日志文件容量非常大，不便于管理和造成Nginx 日志写入效率低下等问题。所以，往往需要要对access_log、error_log日志进行切割。</p><p>切割日志一般利用USR1信号让nginx产生新的日志。</p><ul><li>实例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">logdir=&quot;/data/logs/nginx&quot;</span><br><span class="line">pid=`cat $logdir/nginx.pid`</span><br><span class="line">DATE=`date -d &quot;1 hours ago&quot; +%Y%m%d%H`</span><br><span class="line">DATE_OLD=`date -d &quot;7 days ago&quot; +%Y%m%d`</span><br><span class="line">for i in `ls $logdir/*access.log`; do</span><br><span class="line">        mv $i $i.$DATE</span><br><span class="line">done</span><br><span class="line">for i in `ls $logdir/*error.log`; do</span><br><span class="line">        mv $i $i.$DATE</span><br><span class="line">done</span><br><span class="line">kill -s USR1 $pid</span><br><span class="line">rm -v $logdir&quot;/access.log.&quot;$DATE_OLD*</span><br><span class="line"></span><br><span class="line">rm -v $logdir&quot;/error.log.&quot;$DATE_OLD*</span><br></pre></td></tr></table></figure><p>1、分析：</p><p>将上面的脚本放到crontab中，每小时执行一次（0 ），这样每小时会把当前日志重命名成一个新文件；然后发送USR1这个信号让Nginx 重新生成一个新的日志。（相当于备份日志）<br>将前7天的日志删除；</p><p>2、说明：</p><p>在没有执行kill -USR1 $pid之前，即便已经对文件执行了mv命令而改变了文件名称，nginx还是会向新命名的文件”*access.log.2016032623”照常写入日志数据的。原因在于：linux系统中，内核是根据文件描述符来找文件的。</p><p>3、logrotates：</p><p>使用系统自带的logrotates，也可以实现nginx的日志分割，查看其bash源码，发现也是发送USR1这个信号。</p><p>nginx的日志相关总结先到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用图床及自建图床方法汇总</title>
      <link href="/2017/02/20/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%BA%8A%E5%8F%8A%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2017/02/20/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%BA%8A%E5%8F%8A%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客里的图片一直使用的是MarkdownPad 2提供图库，但是博客支持https后，之前图片都是引用的http，域名就失去小绿锁。</p></blockquote><p>是时候寻找新的图床啦。</p><p>于是乎，在网上这到这个哥们的博文，收藏之</p><ul><li>支持https了</li></ul><p><a href="https://eason-yang.com/2016/10/09/collection-of-image-hosting/">常用图床及自建图床方法汇总(转载)</a></p><p><img src="https://ws1.sinaimg.cn/large/7108d6c2ly1fcx6wfeyjuj20i406ugmo"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven 执行错误 Failed to clean project Failed to delete</title>
      <link href="/2017/02/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20maven%20%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%20Failed%20to%20clean%20project%20Failed%20to%20delete/"/>
      <url>/2017/02/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20maven%20%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%20Failed%20to%20clean%20project%20Failed%20to%20delete/</url>
      
        <content type="html"><![CDATA[<h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><blockquote><p>idea启动通过maven，启动tomcat时，执行clean命令也报错</p></blockquote><ul><li><p>报错信息：</p><pre><code>  Failed to clean project Failed to delete ... tomcat / log</code></pre></li></ul><blockquote><p>无法删除，想到tomcat可能没有关闭。想到昨天idea被我强杀的进程。tomcat没杀掉，查看进程，果然tomcat进程还在，杀掉进程后，重新执行<br>maven 命令，正常了~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级win10后，无法使用 MarkdownPad2的问题</title>
      <link href="/2017/02/08/%E5%B7%A5%E5%85%B7/%E5%8D%87%E7%BA%A7win10%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20MarkdownPad2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/02/08/%E5%B7%A5%E5%85%B7/%E5%8D%87%E7%BA%A7win10%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20MarkdownPad2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>最新的win10系统，自带了ubuntu子系统，诱惑很大，于是把win7换成了win10，<span id="more"></span><br>But 升级win10后，部分软件不兼容，安装好经常使用MarkdownPad2后，直接打开一个.md文件，就开始报错</p></blockquote><p><img src="http://i.imgur.com/6ADsHjh.png"></p><p>对文档进行编辑时，同样报错</p><p><img src="http://i.imgur.com/WGG07vD.png"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>不甘心好用的工具无法使用， 百度之，并顺利解决，这里做个记录：</p><p>下载该程序 <a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe"><code>awesomium_v1.6.6_sdk_win.exe</code></a>，安装后，即可正常使用</p><ul><li>注意： 低版本的win10，可能无法安装awesomium_v1.6.6_sdk_win，win10还是升级吧。希望win10能逐步稳定下来</li></ul><blockquote><p>我们活在各自的的心灵世界，我们有什么样的心，就决定我们看到什么样的世界</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo执行失败的2个问题解决方法</title>
      <link href="/2017/02/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20sudo%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%842%E4%B8%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2017/02/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20sudo%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E7%9A%842%E4%B8%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题一：sudo-unable-to-resolve-host-dev"><a href="#问题一：sudo-unable-to-resolve-host-dev" class="headerlink" title="问题一：sudo: unable to resolve host dev"></a>问题一：sudo: unable to resolve host dev</h2><ul><li><p>处理方式：</p><pre><code>  编辑 /etc/hosts  127.0.0.1       localhost 设备的hostname  # 或改成下面这两行   #127.0.0.1       localhost   #127.0.0.1       设备的hostname</code></pre></li></ul><h2 id="问题二：-sudo-no-tty-present-and-no-askpass-program-specified"><a href="#问题二：-sudo-no-tty-present-and-no-askpass-program-specified" class="headerlink" title="问题二： sudo: no tty present and no askpass program specified"></a>问题二： sudo: no tty present and no askpass program specified</h2><ul><li><p>处理方式：</p><pre><code>  这是由于帐号并没有开启免密码导致的  切换到root用户  1.vi /etc/sudoers  2.添加 用户名 ALL = NOPASSWD: ALL</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装 centOS 报错 No Caching mode page found</title>
      <link href="/2017/01/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AE%89%E8%A3%85%20centOS%20%E6%8A%A5%E9%94%99%20No%20Caching%20mode%20page%20found/"/>
      <url>/2017/01/18/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AE%89%E8%A3%85%20centOS%20%E6%8A%A5%E9%94%99%20No%20Caching%20mode%20page%20found/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>在阿里的<a href="http://mirrors.aliyun.com/centos/">镜像库</a>上下载了centos7.2的iso文件，制作好U盘引导盘，在PC上安装时，<!---more---> 报错</p></blockquote><pre><code>    No Caching mode page found Assuming drive cache:write through    省略一大堆。。。    /dev/root does not exist</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>重启后，在进入安装界面时，按 <code>e</code> 键</p><pre><code>  修改  vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</code></pre></li><li><p>将hd:后面的内容替换为挂在的U盘路径即可</p><pre><code>  如：  vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb1:/ quiet</code></pre></li><li><p>注意： sdb1 即为U盘的挂在名称。硬盘一般是sda</p></li><li><p>可以通过 <code>ls /dev/sd*</code> 查看</p></li></ul><p>修改好后，按下 <code>CTRL + X </code> 就OK了</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatais 总结</title>
      <link href="/2017/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatais%20%E6%80%BB%E7%BB%93/"/>
      <url>/2017/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatais%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>Mapper 配置：</strong> Mapper 配置可以使用基于 XML 的 Mapper 配置文件来实现，也可以使用基于 Java 注解的 MyBatis 注解来实现，甚至可以直接使用 MyBatis 提供的 API 来实现。</p><p><strong>Mapper 接口：</strong> Mapper 接口是指自行定义的一个数据操做接口，类似于通常所说的 DAO 接口。早期的 Mapper 接口需要自定义去实现，现在 MyBatis 会自动为 Mapper 接口创建动态代理对象。Mapper 接口的方法通常与 Mapper 配置文件中的 select、insert、update、delete 等 XML 结点存在一一对应关系。</p><p><strong>Executor：</strong> MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 进行的，Executor 是 MyBatis 的一个核心接口。</p><p><strong>SqlSession：</strong> SqlSession 是 MyBatis 的关键对象，是执行持久化操作的独享，类似于 JDBC 中的 Connection，SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法，它的底层封装了 JDBC 连接，可以用 SqlSession 实例来直接执行被映射的 SQL 语句。</p><p><strong>SqlSessionFactory：</strong> SqlSessionFactory 是 MyBatis 的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory 对象的实例可以通过 SqlSessionFactoryBuilder 对象类获得，而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出。</p><p>MyBatis 的工作流程如下：</p><p><img src="http://www.ityouknow.com/assets/images/2017/chat/mybat.png" alt="img"></p><ul><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话。根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession）。会话对象是一个接口，该接口中包含了对数据库操作的增删改查方法。</li><li>创建执行器。因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象。在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库。拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ul><p>在具体的使用过程中，按照上述的流程来执行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>collections 数据复制</title>
      <link href="/2017/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/collections%20%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/collections%20%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="collections-数据复制"><a href="#collections-数据复制" class="headerlink" title="collections 数据复制"></a>collections 数据复制</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><blockquote><p>起名真心好难，做了一个collection 用了一段时间后，想换个名字。。。之前测试的数据。想导入过去，搜罗了下，执行成功后，做个笔记</p></blockquote><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul><li><p>命令行执行</p><pre><code>  db.material.find().forEach(function(x)&#123;  db.unityassets.insert(x);  &#125;)</code></pre></li></ul><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ul><li>Mongo Express 中直接改名</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对一致性Hash算法，java实现的研究</title>
      <link href="/2016/12/17/java/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%EF%BC%8Cjava%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2016/12/17/java/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%EF%BC%8Cjava%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="http://www.cnblogs.com/xrq730/p/5186728.html">http://www.cnblogs.com/xrq730/p/5186728.html</a></p></blockquote><p><strong>一致性Hash算法</strong></p><p>关于一致性Hash算法，在我之前的博文中已经有多次提到了，<a href="http://www.cnblogs.com/xrq730/p/4948707.html">MemCache超详细解读</a>一文中”一致性Hash算法”部分，对于为什么要使用一致性Hash算法、一致性Hash算法的算法原理做了详细的解读。</p><p>算法的具体原理这里再次贴上：</p><p><strong>先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</strong></p><p>这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。</p><p>当然，万事不可能十全十美，一致性Hash算法比普通的余数Hash算法更具有伸缩性，但是同时其算法实现也更为复杂，本文就来研究一下，如何利用Java代码实现一致性Hash算法。在开始之前，先对一致性Hash算法中的几个核心问题进行一些探究。</p><p><strong>数据结构的选取</strong></p><p>一致性Hash算法最先要考虑的一个问题是：构造出一个长度为232的整数环，根据节点名称的Hash值将服务器节点放置在这个Hash环上。</p><p>那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：</p><p><strong>O(1) &lt; O(log2N) &lt; O(N) &lt; O(N * log2N) &lt; O(N2) &lt; O(N3)  &lt; O(N!)</strong></p><p>一般来说，前四个效率比较高，中间两个差强人意，最后一个后比较差（只要N比较大，这个算法就动不了了）。OK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。</p><p><strong>1、解决方案一：排序+List</strong></p><p>我想到的第一种思路是：算出所有待加入数据结构的节点名称的Hash值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，最后将排序后的数据放入List中，采用List而不是数组是为了结点的扩展考虑。</p><p><strong>之后，待路由的结点，只需要在List中找到第一个Hash值比它大的服务器节点就可以了</strong>，比如服务器节点的Hash值是[0,2,4,6,8,10]，带路由的结点是7，只需要找到第一个比7大的整数，也就是8，就是我们最终需要路由过去的服务器节点。</p><p>如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：</p><p>（1）最好的情况是第一次就找到，时间复杂度为O(1)</p><p>（2）最坏的情况是最后一次才找到，时间复杂度为O(N)</p><p>平均下来时间复杂度为O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为O(N)。</p><p>但是如果考虑到之前的排序，我在网上找了张图，提供了各种排序算法的时间复杂度：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212222344573-933837136.jpg" alt="img"></p><p>看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，看起来最好的归并排序法的时间复杂度仍然有O(N * logN)，稍微耗费性能了一些。</p><p><strong>2、解决方案二：遍历+List</strong></p><p>既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。</p><p>解决方案使用List不变，不过可以采用遍历的方式：</p><p>（1）服务器节点不排序，其Hash值全部直接放入一个List中</p><p>（2）带路由的节点，算出其Hash值，由于指明了”顺时针”，因此遍历List，比待路由的节点Hash值大的算出差值并记录，比待路由节点Hash值小的忽略</p><p>（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点</p><p>在这个算法中，看一下时间复杂度：</p><p>1、最好情况是只有一个服务器节点的Hash值大于带路由结点的Hash值，其时间复杂度是O(N)+O(1)&#x3D;O(N+1)，忽略常数项，即O(N)</p><p>2、最坏情况是所有服务器节点的Hash值都大于带路由结点的Hash值，其时间复杂度是O(N)+O(N)&#x3D;O(2N)，忽略首项系数，即O(N)</p><p>所以，总的时间复杂度就是O(N)。其实算法还能更改进一些：给一个位置变量X，如果新的差值比原差值小，X替换为新的位置，否则X不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为O(N)。</p><p>总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。</p><p><strong>3、解决方案三：二叉查找树</strong></p><p>抛开List这种数据结构，另一种数据结构则是使用<strong>二叉查找树</strong>。对于树不是很清楚的朋友可以简单看一下这篇文章<a href="http://www.cnblogs.com/xrq730/p/5187032.html">树形结构</a>。</p><p>当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有AVL树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：</p><p>1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高</p><p>2、JDK里面提供了红黑树的代码实现TreeMap和TreeSet</p><p>另外，以TreeMap为例，TreeMap本身提供了一个tailMap(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构。</p><p>使用红黑树，可以使得查找的时间复杂度降低为O(logN)，比上面两种解决方案，效率大大提升。</p><p>为了验证这个说法，我做了一次测试，从大量数据中查找第一个大于其中间值的那个数据，比如10000数据就找第一个大于5000的数据（模拟平均的情况）。看一下O(N)时间复杂度和O(logN)时间复杂度运行效率的对比：</p><table><thead><tr><th></th><th><strong>50000</strong></th><th><strong>100000</strong></th><th><strong>500000</strong></th><th><strong>1000000</strong></th><th><strong>4000000</strong></th></tr></thead><tbody><tr><td><strong>ArrayList</strong></td><td><strong>1ms</strong></td><td><strong>1ms</strong></td><td><strong>4ms</strong></td><td><strong>4ms</strong></td><td><strong>5ms</strong></td></tr><tr><td><strong>LinkedList</strong></td><td><strong>4ms</strong></td><td><strong>7ms</strong></td><td><strong>11ms</strong></td><td><strong>13ms</strong></td><td><strong>17ms</strong></td></tr><tr><td><strong>TreeMap</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td><td><strong>0ms</strong></td></tr></tbody></table><p>因为再大就内存溢出了，所以只测试到4000000数据。可以看到，数据查找的效率，TreeMap是完胜的，其实再增大数据测试也是一样的，红黑树的数据结构决定了任何一个大于N的最小数据，它都只需要几次至几十次查找就可以查到。</p><p>当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，<strong>为了维护红黑树，数据插入效率TreeMap在三种数据结构里面是最差的，且插入要慢上5~10倍</strong>。</p><p><strong>Hash值重新计算</strong></p><p>服务器节点我们肯定用字符串来表示，比如”192.168.1.1”、”192.168.1.2”，根据字符串得到其Hash值，那么另外一个重要的问题就是Hash值要重新计算，这个问题是我在测试String的hashCode()方法的时候发现的，不妨来看一下为什么要重新计算Hash值：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * String的hashCode()方法运算结果查看</span><br><span class="line"> * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StringHashCodeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;192.168.0.0:111的哈希值：&quot; + &quot;192.168.0.0:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.1:111的哈希值：&quot; + &quot;192.168.0.1:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.2:111的哈希值：&quot; + &quot;192.168.0.2:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.3:111的哈希值：&quot; + &quot;192.168.0.3:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.4:111的哈希值：&quot; + &quot;192.168.0.4:1111&quot;.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>我们在做集群的时候，集群点的IP以这种连续的形式存在是很正常的。看一下运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.0:111的哈希值：1845870087</span><br><span class="line">192.168.0.1:111的哈希值：1874499238</span><br><span class="line">192.168.0.2:111的哈希值：1903128389</span><br><span class="line">192.168.0.3:111的哈希值：1931757540</span><br><span class="line">192.168.0.4:111的哈希值：1960386691</span><br></pre></td></tr></table></figure><p>这个就问题大了，[0,232-1]的区间之中，5个HashCode值却只分布在这么小小的一个区间，什么概念？[0,232-1]中有4294967296个数字，而我们的区间只有114516604，从概率学上讲这将导致97%待路由的服务器都被路由到”192.168.0.0”这个集群点上，简直是糟糕透了！</p><p>另外还有一个不好的地方：规定的区间是非负数，String的hashCode()方法却会产生负数（不信用”192.168.1.0:1111”试试看就知道了）。不过这个问题好解决，取绝对值就是一种解决的办法。</p><p>综上，String重写的hashCode()方法在一致性Hash算法中没有任何实用价值，得找个算法重新计算HashCode。这种重新计算Hash值的算法有很多，比如CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等，其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法，用别的Hash算法也可以，比如FNV1_32_HASH算法的计算效率就会高一些。</p><p><strong>一致性Hash算法实现版本1：不带虚拟节点</strong></p><p>使用一致性Hash算法，尽管增强了系统的伸缩性，但是也有可能导致负载分布不均匀，解决办法就是使用<strong>虚拟节点代替真实节点</strong>，第一个代码版本，先来个简单的，不带虚拟节点。</p><p>下面来看一下不带虚拟节点的一致性Hash算法的Java代码实现：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 不带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  *</span><br><span class="line"> 5  */</span><br><span class="line"> 6 public class ConsistentHashingWithoutVirtualNode</span><br><span class="line"> 7 &#123;</span><br><span class="line"> 8     /**</span><br><span class="line"> 9      * 待添加入Hash环的服务器列表</span><br><span class="line">10      */</span><br><span class="line">11     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">12             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">13     </span><br><span class="line">14     /**</span><br><span class="line">15      * key表示服务器的hash值，value表示服务器的名称</span><br><span class="line">16      */</span><br><span class="line">17     private static SortedMap&lt;Integer, String&gt; sortedMap = </span><br><span class="line">18             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">19     </span><br><span class="line">20     /**</span><br><span class="line">21      * 程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">22      */</span><br><span class="line">23     static</span><br><span class="line">24     &#123;</span><br><span class="line">25         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">26         &#123;</span><br><span class="line">27             int hash = getHash(servers[i]);</span><br><span class="line">28             System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">29             sortedMap.put(hash, servers[i]);</span><br><span class="line">30         &#125;</span><br><span class="line">31         System.out.println();</span><br><span class="line">32     &#125;</span><br><span class="line">33     </span><br><span class="line">34     /**</span><br><span class="line">35      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">36      */</span><br><span class="line">37     private static int getHash(String str)</span><br><span class="line">38     &#123;</span><br><span class="line">39         final int p = 16777619;</span><br><span class="line">40         int hash = (int)2166136261L;</span><br><span class="line">41         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">42             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">43         hash += hash &lt;&lt; 13;</span><br><span class="line">44         hash ^= hash &gt;&gt; 7;</span><br><span class="line">45         hash += hash &lt;&lt; 3;</span><br><span class="line">46         hash ^= hash &gt;&gt; 17;</span><br><span class="line">47         hash += hash &lt;&lt; 5;</span><br><span class="line">48         </span><br><span class="line">49         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">50         if (hash &lt; 0)</span><br><span class="line">51             hash = Math.abs(hash);</span><br><span class="line">52         return hash;</span><br><span class="line">53     &#125;</span><br><span class="line">54     </span><br><span class="line">55     /**</span><br><span class="line">56      * 得到应当路由到的结点</span><br><span class="line">57      */</span><br><span class="line">58     private static String getServer(String node)</span><br><span class="line">59     &#123;</span><br><span class="line">60         // 得到带路由的结点的Hash值</span><br><span class="line">61         int hash = getHash(node);</span><br><span class="line">62         // 得到大于该Hash值的所有Map</span><br><span class="line">63         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">64                 sortedMap.tailMap(hash);</span><br><span class="line">65         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">66         Integer i = subMap.firstKey();</span><br><span class="line">67         // 返回对应的服务器名称</span><br><span class="line">68         return subMap.get(i);</span><br><span class="line">69     &#125;</span><br><span class="line">70     </span><br><span class="line">71     public static void main(String[] args)</span><br><span class="line">72     &#123;</span><br><span class="line">73         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">74         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">75             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">76                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">77     &#125;</span><br><span class="line">78 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>可以运行一下看一下结果：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.0:111]加入集合中, 其Hash值为575774686</span><br><span class="line">[192.168.0.1:111]加入集合中, 其Hash值为8518713</span><br><span class="line">[192.168.0.2:111]加入集合中, 其Hash值为1361847097</span><br><span class="line">[192.168.0.3:111]加入集合中, 其Hash值为1171828661</span><br><span class="line">[192.168.0.4:111]加入集合中, 其Hash值为1764547046</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.4:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.4:111]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>看到经过FNV1_32_HASH算法重新计算过后的Hash值，就比原来String的hashCode()方法好多了。从运行结果来看，也没有问题，三个点路由到的都是顺时针离他们Hash值最近的那台服务器上。</p><p><strong>使用虚拟节点来改善一致性Hash算法</strong></p><p>上面的一致性Hash算法实现，可以在很大程度上解决很多分布式环境下不好的路由算法导致系统伸缩性差的问题，但是会带来另外一个问题：负载不均。</p><p>比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。<strong>某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求</strong>。</p><p>解决这个问题的办法是引入虚拟节点，其工作原理是：<strong>将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上</strong>。采取这样的方式，就可以有效地解决增加或减少节点时候的负载不均衡的问题。</p><p>至于一个物理节点应该拆分为多少虚拟节点，下面可以先看一张图：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212234143027-642938706.png" alt="img"></p><p>横轴表示需要为每台福利服务器扩展的虚拟节点倍数，纵轴表示的是实际物理服务器数。可以看出，物理服务器很少，需要更大的虚拟节点；反之物理服务器比较多，虚拟节点就可以少一些。比如有10台物理服务器，那么差不多需要为每台服务器增加100~200个虚拟节点才可以达到真正的负载均衡。</p><p><strong>一致性Hash算法实现版本2：带虚拟节点</strong></p><p>在理解了使用虚拟节点来改善一致性Hash算法的理论基础之后，就可以尝试开发代码了。编程方面需要考虑的问题是：</p><p>1、一个真实结点如何对应成为多个虚拟节点？</p><p>2、虚拟节点找到后如何还原为真实结点？</p><p>这两个问题其实有很多解决办法，我这里使用了一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如”192.168.0.0:111”就把它变成”192.168.0.0:111&amp;&amp;VN0”到”192.168.0.0:111&amp;&amp;VN4”，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到”&amp;&amp;”的位置就可以了。</p><p>下面来看一下带虚拟节点的一致性Hash算法的Java代码实现：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  */</span><br><span class="line"> 5 public class ConsistentHashingWithVirtualNode</span><br><span class="line"> 6 &#123;</span><br><span class="line"> 7     /**</span><br><span class="line"> 8      * 待添加入Hash环的服务器列表</span><br><span class="line"> 9      */</span><br><span class="line">10     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">11             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">12     </span><br><span class="line">13     /**</span><br><span class="line">14      * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span><br><span class="line">15      */</span><br><span class="line">16     private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;();</span><br><span class="line">17     </span><br><span class="line">18     /**</span><br><span class="line">19      * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</span><br><span class="line">20      */</span><br><span class="line">21     private static SortedMap&lt;Integer, String&gt; virtualNodes = </span><br><span class="line">22             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">23     </span><br><span class="line">24     /**</span><br><span class="line">25      * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span><br><span class="line">26      */</span><br><span class="line">27     private static final int VIRTUAL_NODES = 5;</span><br><span class="line">28     </span><br><span class="line">29     static</span><br><span class="line">30     &#123;</span><br><span class="line">31         // 先把原始的服务器添加到真实结点列表中</span><br><span class="line">32         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">33             realNodes.add(servers[i]);</span><br><span class="line">34         </span><br><span class="line">35         // 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span><br><span class="line">36         for (String str : realNodes)</span><br><span class="line">37         &#123;</span><br><span class="line">38             for (int i = 0; i &lt; VIRTUAL_NODES; i++)</span><br><span class="line">39             &#123;</span><br><span class="line">40                 String virtualNodeName = str + &quot;&amp;&amp;VN&quot; + String.valueOf(i);</span><br><span class="line">41                 int hash = getHash(virtualNodeName);</span><br><span class="line">42                 System.out.println(&quot;虚拟节点[&quot; + virtualNodeName + &quot;]被添加, hash值为&quot; + hash);</span><br><span class="line">43                 virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">44             &#125;</span><br><span class="line">45         &#125;</span><br><span class="line">46         System.out.println();</span><br><span class="line">47     &#125;</span><br><span class="line">48     </span><br><span class="line">49     /**</span><br><span class="line">50      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">51      */</span><br><span class="line">52     private static int getHash(String str)</span><br><span class="line">53     &#123;</span><br><span class="line">54         final int p = 16777619;</span><br><span class="line">55         int hash = (int)2166136261L;</span><br><span class="line">56         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">57             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">58         hash += hash &lt;&lt; 13;</span><br><span class="line">59         hash ^= hash &gt;&gt; 7;</span><br><span class="line">60         hash += hash &lt;&lt; 3;</span><br><span class="line">61         hash ^= hash &gt;&gt; 17;</span><br><span class="line">62         hash += hash &lt;&lt; 5;</span><br><span class="line">63         </span><br><span class="line">64         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">65         if (hash &lt; 0)</span><br><span class="line">66             hash = Math.abs(hash);</span><br><span class="line">67         return hash;</span><br><span class="line">68     &#125;</span><br><span class="line">69     </span><br><span class="line">70     /**</span><br><span class="line">71      * 得到应当路由到的结点</span><br><span class="line">72      */</span><br><span class="line">73     private static String getServer(String node)</span><br><span class="line">74     &#123;</span><br><span class="line">75         // 得到带路由的结点的Hash值</span><br><span class="line">76         int hash = getHash(node);</span><br><span class="line">77         // 得到大于该Hash值的所有Map</span><br><span class="line">78         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">79                 virtualNodes.tailMap(hash);</span><br><span class="line">80         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">81         Integer i = subMap.firstKey();</span><br><span class="line">82         // 返回对应的虚拟节点名称，这里字符串稍微截取一下</span><br><span class="line">83         String virtualNode = subMap.get(i);</span><br><span class="line">84         return virtualNode.substring(0, virtualNode.indexOf(&quot;&amp;&amp;&quot;));</span><br><span class="line">85     &#125;</span><br><span class="line">86     </span><br><span class="line">87     public static void main(String[] args)</span><br><span class="line">88     &#123;</span><br><span class="line">89         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">90         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">91             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">92                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">93     &#125;</span><br><span class="line">94 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>关注一下运行结果：</p><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN0]被添加, hash值为1686427075</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN1]被添加, hash值为354859081</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN2]被添加, hash值为1306497370</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN3]被添加, hash值为817889914</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN4]被添加, hash值为396663629</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN0]被添加, hash值为1032739288</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN1]被添加, hash值为707592309</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN2]被添加, hash值为302114528</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN3]被添加, hash值为36526861</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN4]被添加, hash值为848442551</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN0]被添加, hash值为1452694222</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN1]被添加, hash值为2023612840</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN2]被添加, hash值为697907480</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN3]被添加, hash值为790847074</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN4]被添加, hash值为2010506136</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN0]被添加, hash值为891084251</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN1]被添加, hash值为1725031739</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN2]被添加, hash值为1127720370</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN3]被添加, hash值为676720500</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN4]被添加, hash值为2050578780</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN0]被添加, hash值为586921010</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN1]被添加, hash值为184078390</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN2]被添加, hash值为1331645117</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN3]被添加, hash值为918790803</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN4]被添加, hash值为1232193678</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.2:111]</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>从代码运行结果看，每个点路由到的服务器都是Hash值顺时针离它最近的那个服务器节点，没有任何问题。</p><p>通过采取虚拟节点的方法，一个真实结点不再固定在Hash换上的某个点，而是大量地分布在整个Hash环上，这样即使上线、下线服务器，也不会造成整体的负载不均衡。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置反向代理</title>
      <link href="/2016/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2016/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前项目中的前端页面还不是很多，打算进行前后端解耦，把页面拆出来放到nginx中，页面上通过异步请求接口获取数据，再进行页面渲染，使用nginx的反向代理机制可以解决跨域问题</p></blockquote><h3 id="WHAT-跨域问题"><a href="#WHAT-跨域问题" class="headerlink" title="WHAT ?跨域问题"></a>WHAT ?跨域问题</h3><blockquote><p>页面资源与API接口不在同一个IP,或域名，端口时，所进行的访问都是跨域的，而浏览器为了安全问题都是限制了跨域访问，不允许跨域请求资源</p></blockquote><h3 id="常见的跨域解决方案"><a href="#常见的跨域解决方案" class="headerlink" title="常见的跨域解决方案"></a>常见的跨域解决方案</h3><blockquote><p>目前来讲没有不依靠服务器端来跨域请求资源的技术</p></blockquote><ul><li><p>jsonp 需要目标服务器配合一个callback函数。</p></li><li><p>window.name+iframe 需要目标服务器响应window.name。</p></li><li><p>window.location.hash+iframe 同样需要目标服务器作处理。</p></li><li><p>html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。</p></li><li><p>CORS  需要服务器设置header ：Access-Control-Allow-Origin。</p></li><li><p>nginx反向代理，不需要目标服务器配合，只需要搭建一个nginx服务器，用于转发请求。</p></li></ul><h3 id="nginx反向代理解决跨域问题"><a href="#nginx反向代理解决跨域问题" class="headerlink" title="nginx反向代理解决跨域问题"></a>nginx反向代理解决跨域问题</h3><blockquote><p>nginx.conf</p></blockquote><pre><code>server &#123;    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / &#123; #所有以/开头的地址,实际上是所有请求        root   html; ＃去请求../html文件夹里的文件,其中..的路径在nginx里面有定义        index  index.html index.htm;  ＃首页响应地址    &#125;</code></pre><blockquote><p>server代表启动的一个服务，location 是一个定位规则。</p></blockquote><p>　location是nginx用来路由的入口，其实就是要在location里面实现反向代理。</p><blockquote><p>ajax 部分的代码片段:</p></blockquote><pre><code>    // 获取接口数据，并渲染    qrCode.shuffle = function () &#123;       var uid = getUrlParam(&quot;uid&quot;);    //var url = &quot;http://api.xxx/qr/profile?uid=&quot;;    var proxyurl = &quot;/proxy/html/qr/profile&quot;;    var allType = $(&quot;#allType&quot;).val();$.ajax(&#123;    url: proxyurl,    async: true,    type: &quot;GET&quot;,    data: &#123;        &quot;uid&quot;: uid,    &#125;,    dataType: &quot;json&quot;,    timeout: 1000,    success: function (data) &#123;        var userInfo = data;        // 用户昵称        $(&quot;#name&quot;).append(userInfo.nickName);        // 用户性别图片        $(&quot;#sex&quot;).attr(&quot;src&quot;, &quot;img/&quot; + userInfo.sex);        // BluId        $(&quot;#idnumber&quot;).append(userInfo.userNum);    &#125;,&#125;)&#125;;</code></pre><blockquote><p>如果通过 url &#x3D; “<a href="http://api.xxx/qr/profile?uid=XX&quot;">http://api.xxx/qr/profile?uid=XX&quot;</a> 访问接口，必然会        </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌开发者大会笔记</title>
      <link href="/2016/12/09/%E6%9D%82%E8%AE%B0/%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/12/09/%E6%9D%82%E8%AE%B0/%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="谷歌开发者大会笔记"><a href="#谷歌开发者大会笔记" class="headerlink" title="谷歌开发者大会笔记"></a>谷歌开发者大会笔记</h1><blockquote><p>很高兴参加了今年的google开发者大会，感觉收获颇丰，与会上做了一些笔记和拍照，简单整理记录下~ 做一次分享也是帮自己回顾及梳理下思路</p></blockquote><blockquote><p>google力推的创新和技术</p></blockquote><ul><li>Android</li><li>PWA、AMP</li><li>Angular</li><li>人工智能,深度学习</li><li>VR</li></ul><p>课题很多，自己主要参与了移动web相关的讲座:</p><blockquote><p>总结关键词:</p></blockquote><ul><li>渐进式，沉浸式，通知，用户体验，便捷</li><li>即时加载<blockquote><p>Service Worker（对离线和弱网络的情况下的支持）</p></blockquote></li><li>桌面icon（应用免安装）</li><li>快速</li><li>安全</li><li>灵活（适配各种分辨率，尺寸的）</li><li>未来无限可能(通过web控制一切)</li></ul><h2 id="大会主题："><a href="#大会主题：" class="headerlink" title="大会主题："></a>大会主题：</h2><hr><ul><li><p>android</p></li><li><p>firebase</p></li><li><p>angular</p></li><li><p>移动web</p></li><li><p>google play</p></li><li><p>ads</p></li><li><p>what’s Next</p></li></ul><hr><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><blockquote><p>在主会场听了简介，具体内容期待官方分享演讲PPT，或视频回放</p></blockquote><ul><li><p>Android新特性   </p><pre><code>  Doze省电模式“增强版”</code></pre></li><li><p>Android studio 新版本特性  </p><pre><code>  快速（版块设计）、智能（APK 分析 APK Analyzer 版块测试项Layout Inspector）、支持（多窗口、快速设置、通知、仿真模拟器）</code></pre></li><li><p>Android Support Library 新特性</p></li><li><p>Android Wear2.0</p></li><li><p>Android 兼容性（让应用更好的适应平台变化，设备类型差异和弱网络环境）</p></li><li><p>Android 开发中的电量和内存优化</p></li></ul><hr><h3 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h3><ul><li>Firebase 介绍（何时，何地使用）</li><li>Firebase 测试、崩溃报告</li><li>Firebase Analytics</li><li>Firebase 跨平台推送（Cloud Messaging）</li><li>Code Lab（TODO 待了解）</li></ul><hr><h3 id="Augular"><a href="#Augular" class="headerlink" title="Augular"></a>Augular</h3><ul><li>已经推出了2.0版本。</li><li>使用Angular可以开发PWA.<blockquote><p>Angular core</p></blockquote></li><li>申明式模板</li><li>变更检测</li><li>依赖注入</li><li>组件式架构</li><li>AOT静态编译</li><li>平台无关</li></ul><blockquote><p>Angular 无处不在</p></blockquote><pre><code>    PWA 移动duan端 桌面端    </code></pre><blockquote><p>服务端渲染<br>开发效率</p></blockquote><ul><li>javaScript 的超集</li><li>增强型</li><li>可读性</li><li>相似性</li><li>工具链</li></ul><hr><h3 id="移动web"><a href="#移动web" class="headerlink" title="移动web"></a>移动web</h3><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><blockquote><p>Progessive Web Apps(PWA)</p></blockquote><h5 id="渐进式网页应用程序特点"><a href="#渐进式网页应用程序特点" class="headerlink" title="渐进式网页应用程序特点"></a>渐进式网页应用程序特点</h5><ul><li>可靠的</li><li>快速的</li><li>引人入胜</li></ul><blockquote><p>引人入胜:</p></blockquote><ul><li>添加到主屏幕</li><li>沉浸式</li><li>通知</li><li>Web 通知</li></ul><blockquote><p>PWD 化的三种途径</p></blockquote><ul><li>自下而上</li><li>简单版本</li><li>单一功能</li></ul><blockquote><p>使用PWA达到的效果</p></blockquote><ul><li>交互缓存</li><li>后台通知</li><li>快速流畅，60fps交互体验</li><li>UI尺寸，动态调节</li><li>桌面图标，方便添加</li></ul><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><blockquote><p>原生App拥有Web应用通常所不具备的富离线体验，定时的静默更新，消息通知推送等功能。而新的Service workers标准让在Web App上拥有这些功能。</p></blockquote><ul><li><p>Service Worker 必须配置HTTPS</p></li><li><p>Service Worker 生命周期</p></li><li><p>缓存策略</p><pre><code>  网络优先，失败则读取缓存  先读取缓存，再从网络上更新内容  一般回退流程  同时读取网络与缓存内容，接受其中最快的返回结果</code></pre></li></ul><blockquote><p>测试过程可以通过 Chrome Dev Tools 观察和处理缓存     </p></blockquote><ul><li>github 源码分享：<br><a href="https://github.com/GoogleChrome/sw-toolbox">sw-toolbox</a></li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><blockquote><p>介绍为何如何使用HTTPS(推荐了 开源证书及价格优惠的证书网址 &#x2F; 搜索排行指南)</p></blockquote><blockquote><p>为什么选择 HTTPS</p></blockquote><ul><li>身份验证（你在与谁通信）</li><li>加密（谁能读取数据）</li><li>整合 （谁能修改数据）</li></ul><blockquote><p>HTTPS的成本</p></blockquote><ul><li>证书</li><li>搜索排行</li></ul><blockquote><p>推荐SSL 证书提供</p></blockquote><ul><li><p><a href="https://ssmate.com/pricing">sslmate</a> (Standard SSL $15.95 &#x2F; Multi-Host SSL $24.95)</p></li><li><p>开源 Let’s Encrypt</p></li><li><p><a href="https://developers.google.cn/web/fundamentals/security/encrpt-transit/migration-concerns">搜索排行指南</a></p></li></ul><blockquote><p>HTTPS Chrome 开发者工具中的安全面板</p></blockquote><ul><li>Chrome DevTools Security Panel</li></ul><blockquote><p>HTTP&#x2F;2 释放HTTPS的潜能</p></blockquote><blockquote><p>更多价值的参考信息</p></blockquote><ul><li><a href="https://developers.google.cn/web/fundamentals/security/encrypt-in-transit/">传输过程中的数据加密</a></li></ul><blockquote><p>待整理</p></blockquote><ul><li>使用内容安全策略 </li><li>避免出现混合内容</li></ul><h4 id="可安装应用与通知推送机制"><a href="#可安装应用与通知推送机制" class="headerlink" title="可安装应用与通知推送机制"></a>可安装应用与通知推送机制</h4><blockquote><p>通知剖析</p></blockquote><ul><li><p>时效性、要合时</p></li><li><p>通知内容：要精确</p></li><li><p>通知中的内容和人物：要切实相关</p></li><li><p>为用户提供<code>丰富的选项</code>（用户无需打开应用，即可轻松完成任务）</p><pre><code>  以信用卡还款通知为例，通知只显示本次需要还款的金额，还需要用户去跳转连接进行还款操作，不如直接在通知中增加是否马上还款的确认按钮，即通过通知服务增加与用户的互动性。</code></pre></li><li><p><a href="https://github.com/web-push-libs/web-push">WEB推送源码分享</a></p></li></ul><blockquote><p>更多分享待整理：</p></blockquote><ul><li><a href="g.cn/WebPushNotifications">网络推送通知入门指南</a></li><li><a href="">对数据有效负载进行加密</a></li><li><a href="">Chrome 中的VAPID</a></li></ul><h4 id="PWA-工具："><a href="#PWA-工具：" class="headerlink" title="PWA 工具："></a>PWA 工具：</h4><blockquote><p>使用 App Shell 和 动态内容模型</p></blockquote><ul><li>Lighthouse</li><li>the dev tools application panel</li></ul><p><strong>相关链接：</strong> </p><ul><li><a href="http://goo.gl/4EhFAC">客户代码样例</a></li><li><a href="http://goo.gl/A6pBhj">项目主页</a></li><li><a href="https://youtu.be/jCKZDTtUA2A">使用Service Workder 实现即时加载</a></li><li><a href="http://goo.gl/Bxdx99">PWA 代码实验室</a></li></ul><h4 id="使用Angular构建-PWA"><a href="#使用Angular构建-PWA" class="headerlink" title="使用Angular构建 PWA"></a>使用Angular构建 PWA</h4><blockquote><p>App Shell 生成<br>Service Worker<br>Push 推送<br>演讲者现场编程演示</p></blockquote><ul><li><a href="https://github.com/StephenFluin/2016-pwa-beijing">现场写的代码分享</a></li><li><a href="https://github.com/alxhub/ng2-weather-pwa">Full Angular PWA Sample</a></li></ul><h4 id="web-Apps-的未来"><a href="#web-Apps-的未来" class="headerlink" title="web Apps 的未来"></a>web Apps 的未来</h4><blockquote><p>今天的WEB &#x3D;&gt; 渐进式网页应用程序（PWA）</p></blockquote><ul><li>即时加载 （对离线和弱网络差的情况均适用）</li><li>把应用添加到主屏幕快捷方式</li><li>推送增加用户互动</li><li>快速 流畅的动画，滚屏和导航</li><li>安全（HTTPS）</li><li>灵敏（适应任意屏幕尺寸）</li></ul><blockquote><p>未来的WEB的讨论</p></blockquote><ul><li>了解用户是谁</li><li>凭证管理</li><li>支付WEB上的东西 （google主导支付协议规范（W3C PaymentRequest））</li></ul><blockquote><p>目前支付流程： <strong>手动  冗长 缓慢 N个按键</strong>  </p></blockquote><blockquote><p>PaymentRequest : <strong>跨浏览器  跨平台  开源生态</strong></p></blockquote><ul><li>硬件连接<blockquote><p>基础BLE术语 : </p></blockquote></li><li>“Central” device(my phone)</li><li>“Peripheral”device(candle)</li><li>GATT(Generic ATTribute profile)</li></ul><hr><ul><li><p>物理网</p><blockquote><p><a href="http://www.physical–web.org/">http://www.physical–web.org</a></p></blockquote></li><li><p>WebVR<br>明年就可以看到webVR的相关产品</p></li></ul><hr><h3 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h3><blockquote><p>主要介绍如何 通过Google Play，面向全球市场</p></blockquote><ul><li>google本次大会主题之一，也包含希望开发者看到国外的市场</li></ul><hr><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><blockquote><p>主要介绍google向企业用户提供的各种服务</p></blockquote><hr><h3 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next"></a>What’s Next</h3><h4 id="Blokly"><a href="#Blokly" class="headerlink" title="Blokly"></a>Blokly</h4><blockquote><p>Google的开源产品，用于构建图形化编程的网页和移动应用</p></blockquote><h4 id="使用Material-Design-走向成功"><a href="#使用Material-Design-走向成功" class="headerlink" title="使用Material Design 走向成功"></a>使用Material Design 走向成功</h4><blockquote><p>TODO 待了解</p></blockquote><h4 id="TensorFlow-简介"><a href="#TensorFlow-简介" class="headerlink" title="TensorFlow 简介"></a>TensorFlow 简介</h4><ul><li>Google开源的人工智能项目,机器学习库<blockquote><p>DeepMind也计划开源</p></blockquote></li></ul><h4 id="深度学习与艺术"><a href="#深度学习与艺术" class="headerlink" title="深度学习与艺术"></a>深度学习与艺术</h4><blockquote><p>主要介绍图像识别，归类技术（TODO 待了解）</p></blockquote><h4 id="DayDream-简介"><a href="#DayDream-简介" class="headerlink" title="DayDream 简介"></a>DayDream 简介</h4><blockquote><p>Google VR平台，明年会有很多DayDream Ready的设备出来。</p></blockquote><h4 id="Tango-简介"><a href="#Tango-简介" class="headerlink" title="Tango 简介"></a>Tango 简介</h4><blockquote><p>Google VR平台,新款的nexus手机上会看到相关应用功能</p></blockquote><hr><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><h2 id="Google-技术的中文网站"><a href="#Google-技术的中文网站" class="headerlink" title="Google 技术的中文网站"></a>Google 技术的中文网站</h2><ul><li><p><a href="https://developers.google.cn/">developers.google.cn</a>  整合的Google技术学习资源，包括分门别类的技术产品和开发指南。</p></li><li><p><a href="https://developer.android.google.cn/index.html">developer.android.google.cn</a> 特别为Android开发者推出的官网，有中文界面，不过目前官方文档还是英文的。</p></li><li><p><a href="https://developers.googleblog.cn/">Google开发者博客</a></p></li><li><p><a href="https://firebase.google.cn/">firebase.google.cn</a> Firebase中文官网，包括英文的官方文档，不过想要使用的话还是需要链接到国外主站。</p></li><li><p><a href="https://angular.cn/">angular</a></p></li></ul><hr><p> 马凯 2016&#x2F;12&#x2F;9</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew常用命令</title>
      <link href="/2016/12/09/%E5%B7%A5%E5%85%B7/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/12/09/%E5%B7%A5%E5%85%B7/brew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>mac上安装应用的命令，同apt-get，yum一样好使</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>Homebrew安装命令，mac下自带ruby，在终端输入以下命令，按提示安装即可  </p><pre><code>  ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;  </code></pre></li><li><p>参考 <a href="http://brew.sh/index_zh-cn.html">Homebrew</a></p></li></ul><h3 id="brew常用命令："><a href="#brew常用命令：" class="headerlink" title="brew常用命令："></a>brew常用命令：</h3><pre><code>    安装软件:  brew install  ＊（软件名 eg. brew install nginx）    卸载软件:  brew uninstall ＊    搜索软件:  brew search *    显示已经安装软件列表:  brew list    更新软件:  brew update    更新某具体软件: brew upgrade git</code></pre><h3 id="install-brew-cask-管理安装非终端的软件"><a href="#install-brew-cask-管理安装非终端的软件" class="headerlink" title="install brew cask 管理安装非终端的软件"></a>install brew cask 管理安装非终端的软件</h3><pre><code>brew install brew-cask-completion➜  ~ brew cask search qq==&gt; Exact Matchqq==&gt; Partial Matchesqqbrowser           qqinput             qqmacmgr            qqmusic</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置MySQL-Python报错问题</title>
      <link href="/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%85%8D%E7%BD%AEMySQL-Python%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
      <url>/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%85%8D%E7%BD%AEMySQL-Python%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习python时，配置MySQL-Python的时候系统报错，提示：</p></blockquote><pre><code>EnvironmentError: mysql_config not foundGoogle后得知mysql_config是属于MySQL开发用的文件，而使用apt-get安装的MySQL是没有这个文件的，于是在包安装器里面寻找</code></pre><ul><li><p>libmysqld-dev</p></li><li><p>libmysqlclient-dev</p></li></ul><p>这两个包安装后问题即可解决</p><pre><code>sudo apt-get -y install mysql-server mysql-client libmysqlclient-dev mytop</code></pre><ul><li>注意:import MySQLdb “y” 是小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios-apple-review被拒-app-server-完全适配-ipv6（转载）</title>
      <link href="/2016/11/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2016/11/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>原文出处 <a href="https://devthinking.com/ios-apple-review%E8%A2%AB%E6%8B%92-app-server-%E5%AE%8C%E5%85%A8%E9%80%82%E9%85%8D-ipv6/">ios-apple-review被拒-app-server-完全适配-ipv6</a></li></ul><p>感谢作者分享</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv6相关总结</title>
      <link href="/2016/11/16/%E7%BD%91%E7%BB%9C/%20IPv6%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2016/11/16/%E7%BD%91%E7%BB%9C/%20IPv6%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>ios上架AppStore时，被驳回，要求必须支持IPv6,在此总结一些IPv6相关的知识点</p></blockquote><h2 id="IPv6格式"><a href="#IPv6格式" class="headerlink" title="IPv6格式"></a>IPv6格式</h2><blockquote><p>IPv6是128bit</p></blockquote><h2 id="IPv6-DNS"><a href="#IPv6-DNS" class="headerlink" title="IPv6 DNS:"></a>IPv6 DNS:</h2><p>未知国家<br>2001:470:20::2</p><p>加拿大<br>2001:478:6:0:230:48ff:fe22:6a29</p><p>英国<br>2001:7fd::1</p><p>日本<br>2001:dc4::1</p><h2 id="Linux命令-ping-IPv6："><a href="#Linux命令-ping-IPv6：" class="headerlink" title="Linux命令 ping IPv6："></a>Linux命令 ping IPv6：</h2><p>Linux下ping IPv6需要使用ping6，如果使用ping，则会提示ping: unknown host。</p><p>ping6 ipv6.google.com</p><p>ping6 2001:470:20::2</p><p>PING 2001:470:20::2(2001:470:20::2) 56 data bytes</p><p>64 bytes from 2001:470:20::2: icmp_seq&#x3D;11 ttl&#x3D;60 time&#x3D;714 ms</p><p>64 bytes from 2001:470:20::2: icmp_seq&#x3D;12 ttl&#x3D;60 time&#x3D;4.65 ms</p><p>ping 2001:470:20::2</p><p>ping: unknown host 2001:470:20::2</p><h2 id="Windows命令-ping-IPv6："><a href="#Windows命令-ping-IPv6：" class="headerlink" title="Windows命令 ping IPv6："></a>Windows命令 ping IPv6：</h2><p>ping -6 ipv6.google.com</p><h2 id="Linux命令-wget-IPv6："><a href="#Linux命令-wget-IPv6：" class="headerlink" title="Linux命令 wget IPv6："></a>Linux命令 wget IPv6：</h2><p>wget -6 <a href="http://ipv6.google.com/">http://ipv6.google.com</a></p><h2 id="Linux和Windows命令查询域名AAAA记录，是否支持IPv6："><a href="#Linux和Windows命令查询域名AAAA记录，是否支持IPv6：" class="headerlink" title="Linux和Windows命令查询域名AAAA记录，是否支持IPv6："></a>Linux和Windows命令查询域名AAAA记录，是否支持IPv6：</h2><p>Linux和Windows都是使用nslookup程序查询dns。</p><pre><code>$ nslookup&gt;set querytype=aaaa&gt;ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.ipv6.l.google.comhas AAAA address 2404:6800:8005::6a</code></pre><p>由此可知，IPv4的DNS也能返回域名的IPv6记录，即AAAA记录。</p><pre><code>$ nslookup&gt; set querytype=aaaa&gt; google.comServer:2001:470:20::2Address:2001:470:20::2#53Non-authoritative answer:google.comhas AAAA address 2001:4860:800b::69</code></pre><p>配置域名同时支持IPv6和IPv4：</p><p>领先的域名注册商同时支持IPv6和IPv4，比如godaddy、namesilo，在注册商这里购买了域名之后，登录到域名管理界面，可以设置A记录和AAAA记录。</p><p>假设购买了example.com，希望example.com同时支持IPv6和IPv4，则添加一条A记录指向192.0.32.10，添加一条AAAA记录，指向2620:0:2d0:200::10，等待一段时间即可生效（等待时间与TTL有关）。结果如下：</p><pre><code>$ nslookup&gt; example.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:Name:example.comAddress: 192.0.32.10&gt; set querytype=aaaa&gt; example.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:example.comhas AAAA address 2620:0:2d0:200::10</code></pre><p>配置域名只支持IPv6：</p><p>假设购买了google.com，希望ipv6.google.com只支持IPv6，不支持IPv4，则不添加A记录，只添加一条AAAA记录，指向2404:6800:8005::68。结果如下：</p><pre><code>$ nslookup&gt; ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.&gt; ipv6.l.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:*** Can&#39;t find ipv6.l.google.com: No answer&gt; set querytype=aaaa&gt; ipv6.google.comServer:8.8.8.8Address:8.8.8.8#53Non-authoritative answer:ipv6.google.comcanonical name = ipv6.l.google.com.ipv6.l.google.comhas AAAA address 2404:6800:8005::68</code></pre><h2 id="Apache-httpd配置IPv6："><a href="#Apache-httpd配置IPv6：" class="headerlink" title="Apache httpd配置IPv6："></a>Apache httpd配置IPv6：</h2><p>Apache httpd配置支持IPv6，需要给IP带上方括号，参考：<a href="http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/core.html#virtualhost">http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/core.html#virtualhost</a></p><pre><code>&lt;VirtualHost [2404:6800:8005::68]:80&gt;ServerAdmin webmaster@ipv6.google.comDocumentRoot /var/www/html/ipv6.google.com/ServerName ipv6.google.com&lt;/VirtualHost&gt;IPv4内网用户如何使用IPv6：</code></pre><p>安装Teredo隧道即可。访问IPv6网站通过Teredo服务器转发，速度受影响。</p><ul><li>注意：</li></ul><p>Teredo隧道与PPPOE冲突，解决方法：使用路由拨号，本机只有一个本地连接即可。</p><p>Teredo隧道与多网卡冲突，比如virtualbox的虚拟网卡，解决办法：禁用别的网卡，只留一个本地连接。</p><ul><li><p>参考：</p></li><li><p>在IPv4网络下接入IPv6网络的方法：<a href="http://www.ipv6bbs.cn/thread-151-1-1.html">http://www.ipv6bbs.cn/thread-151-1-1.html</a></p></li><li><p>资料：<a href="http://felixcat.net/2010/04/install-teredo-ipv6/">http://felixcat.net/2010/04/install-teredo-ipv6/</a></p></li><li><p><a href="http://www.ipv6home.cn/html/63/t-17563.html">http://www.ipv6home.cn/html/63/t-17563.html</a></p></li><li><p>Win 7下用Teredo隧道接入IPv6后，操作系统默认还是直接走IPv4：<a href="http://social.technet.microsoft.com/Forums/zh-CN/window7betacn/thread/ae1f7d47-aa19-493d-a10d-f8032441a147/">http://social.technet.microsoft.com/Forums/zh-CN/window7betacn/thread/ae1f7d47-aa19-493d-a10d-f8032441a147/</a></p></li><li><p>teredo IPv6 配置hosts后无法使用gtalk客户端（解决办法：使用Pidgin）：<a href="http://www.google.com/support/forum/p/other/thread?tid=4f65f26a7da1785f&amp;hl=zh-CN">http://www.google.com/support/forum/p/other/thread?tid=4f65f26a7da1785f&amp;hl=zh-CN</a></p></li></ul><h2 id="IPv4外网用户如何使用IPv6："><a href="#IPv4外网用户如何使用IPv6：" class="headerlink" title="IPv4外网用户如何使用IPv6："></a>IPv4外网用户如何使用IPv6：</h2><p>安装isatap隧道即可。访问IPv6网站通过isatap网关转发，速度受影响。</p><p>如何设置浏览器默认使用IPv6：</p><p>1、真实IPv4 + 真实IPv6</p><p>操作系统会优先使用IPv6（未测试）。</p><p>2、真实IPv4内网+ IPv6 Teredo隧道</p><p>当域名同时有A和AAAA记录时，Windows 7、Ubuntu优先使用真实IPv4内网，所以需要修改hosts加入IPv6。</p><p>当域名只有AAAA记录时，Ubuntu可直接访问（比如ipv6.google.com），不用配hosts。</p><p>2、真实IPv4外网+ IPv6 isatap隧道</p><p>XP可以直接访问ipv6.google.com，不能直接访问docs.google.com，需要配hosts。</p><p>IPv6路由器：</p><p>D-Link一百元的家用路由器国外版本支持IPv6：<a href="http://www.dlink.com/ipv6%EF%BC%8C%E6%AF%94%E5%A6%82DIR-615%EF%BC%8C%E6%88%AA%E5%9B%BE%E5%9C%A8%E6%9C%80%E5%90%8E%E3%80%82%E4%BD%86%E5%9B%BD%E5%86%85%E7%89%88%E6%9C%AC%E4%B8%8D%E7%9F%A5%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81IPv6%EF%BC%8C%E4%BA%AC%E4%B8%9C%E5%AE%A2%E6%9C%8D%E8%AF%B4%E4%B8%8D%E6%94%AF%E6%8C%81%E3%80%82">http://www.dlink.com/ipv6，比如DIR-615，截图在最后。但国内版本不知是否支持IPv6，京东客服说不支持。</a></p><p>TP-Link家用路由器不支持IPv6。</p><p>是不是刷了dd-wrt完整版操作系统的路由器都支持IPv6，还待确认。</p><ul><li><p>参考资料：</p></li><li><p>google的工具 ： <a href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a></p></li><li><p>IPv6 隧道 ： <a href="https://tunnelbroker.net/">https://tunnelbroker.net/</a></p></li><li><p>测试浏览器是否支持IPv6：<a href="http://test-ipv6.com/">http://test-ipv6.com/</a></p></li><li><p>测试浏览器是否默认使用IPv6：<a href="http://www.kame.net/">http://www.kame.net/</a></p></li><li><p>火狐扩展，显示正在访问的网站IP，可以看出是否是IPv6：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/worldip-flag-and-datacenter-pi/">https://addons.mozilla.org/zh-CN/firefox/addon/worldip-flag-and-datacenter-pi/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Data Rest Service</title>
      <link href="/2016/11/04/java/%20Spring%20Boot%20Data%20Rest%20Service/"/>
      <url>/2016/11/04/java/%20Spring%20Boot%20Data%20Rest%20Service/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Spring Boot 可以通过spring-boot-starter-data-rest来对外提供REST API，可以免于编写对应的Controller，且具备分页和排序的功能。</p></blockquote><h2 id="pom文件中增加相关的依赖项"><a href="#pom文件中增加相关的依赖项" class="headerlink" title="pom文件中增加相关的依赖项"></a>pom文件中增加相关的依赖项</h2><pre><code>    &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                  &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 文章收藏</title>
      <link href="/2016/11/01/java/%20JAVA%20%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/"/>
      <url>/2016/11/01/java/%20JAVA%20%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<p>整理了一些不错的java文章，感谢作者们的贡献</p><ul><li><a href="http://www.importnew.com/15605.html#impl_equals">Java习惯用法总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 效率插件</title>
      <link href="/2016/11/01/%E5%B7%A5%E5%85%B7/Chrome%20%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/"/>
      <url>/2016/11/01/%E5%B7%A5%E5%85%B7/Chrome%20%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>整理收集一些Chrome的好用的插件</p><h3 id="RESTFUL"><a href="#RESTFUL" class="headerlink" title="RESTFUL"></a>RESTFUL</h3><ul><li><p>Postman</p><pre><code>  RESTFUL的客户端调式工具，可以分类保存</code></pre></li></ul><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><ul><li><p>Octotree</p><pre><code>  在github上 树形展示</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome 效率插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 删除乱码的文件</title>
      <link href="/2016/10/21/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%88%A0%E9%99%A4%E4%B9%B1%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2016/10/21/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20%E5%88%A0%E9%99%A4%E4%B9%B1%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Linux 使用过程中，产生了一些乱码的文件，使用rm 命令无法正常删除<span id="more"></span>，这种情况下，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ehcache mybatis 分布式</title>
      <link href="/2016/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/ehcache%20mybatis%20%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2016/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/ehcache%20mybatis%20%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> 单机上，为mybatis加上缓存框架ehcache，非常简单。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postman 使用简介</title>
      <link href="/2016/10/16/%E6%B5%8B%E8%AF%95/%20postman%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2016/10/16/%E6%B5%8B%E8%AF%95/%20postman%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介下"><a href="#简介下" class="headerlink" title="简介下"></a>简介下</h2><blockquote><p>postman是个不错的测试工具，感觉应该是目前最方便快捷的API测试工具，建议更新到最新的版本，因为越来越强大～</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>特点一大堆吧，部分功能收费，But免费版本已经足够Happy的玩耍了，就简单说几个比较重要的特色吧</p><ul><li>Mac，Win，都能玩</li><li>脚本语言为javascript</li><li>已经自带了常用的代码模版</li><li>支持环境变量配置，并且支持导入</li><li>支持用例的导入，导出</li><li>可以批量跑用例</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略吧，chrome插件，官方下载客户端安装包（基于 Electron），推荐从官方下载安装客户端版</p><h2 id="使用玩法"><a href="#使用玩法" class="headerlink" title="使用玩法"></a>使用玩法</h2><blockquote><p>建议先花点时间（个把小时也就），看下官方文档</p></blockquote><ul><li><a href="https://www.getpostman.com/docs/">postman 官方文档</a></li></ul><p>简单几个截图总结说明下</p><p>整体结构</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk7thc6k9j219z0r2n3g.jpg"></p><p>请求前脚本举例，比如用于预先初始化一些参数</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk7z6f7w9j21af0qxn1r.jpg"></p><p>测试脚本编写模块，有很多现成的code模版</p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk87g3herj219r0n0jwd.jpg"></p><p>批量跑用例  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8kftoxpj219j0qyq8c.jpg"></p><p>批量跑用例时的页面，展示每条的结果，及汇总  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8n17ge7j20wb0h4di9.jpg"></p><p>看下变量怎么玩滴  </p><p>  <img src="https://ws1.sinaimg.cn/large/7108d6c2ly1flk8rjfmgfj20x80nan00.jpg"></p><h2 id="常用脚本解释说明"><a href="#常用脚本解释说明" class="headerlink" title="常用脚本解释说明"></a>常用脚本解释说明</h2><blockquote><p>新版本脚本有所更新，但是大差不差哈，具体可以去官网看下在</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">1. 清除一个全局变量</span><br><span class="line">     Clear a global variable</span><br><span class="line">    对应脚本：</span><br><span class="line">    postman.clearGlobalVariable(&quot;variable_key&quot;);</span><br><span class="line">    参数：需要清除的变量的key</span><br><span class="line"></span><br><span class="line">  2.清除一个环境变量</span><br><span class="line">    Clear an environment variable</span><br><span class="line">    对应脚本：</span><br><span class="line">    postman.clearEnvironmentVariable(&quot;variable_key&quot;);</span><br><span class="line">    参数：需要清除的环境变量的key</span><br><span class="line"></span><br><span class="line">  3.response包含内容</span><br><span class="line">    Response body:Contains string</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Body matches string&quot;] =responseBody.has(&quot;string_you_want_to_search&quot;);</span><br><span class="line">    参数：预期内容</span><br><span class="line"></span><br><span class="line">  4.将xml格式的response转换成son格式</span><br><span class="line">    Response body:Convert XML body to a JSON Object</span><br><span class="line">    对应脚本：</span><br><span class="line">    var jsonObject = xml2Json(responseBody);</span><br><span class="line">    参数：（默认不需要设置参数,为接口的response）需要转换的xml</span><br><span class="line"></span><br><span class="line">  5.response等于预期内容</span><br><span class="line">    Response body:Is equal to a string</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Body is correct&quot;] = responseBody === &quot;response_body_string&quot;;</span><br><span class="line">    参数：预期response</span><br><span class="line"></span><br><span class="line">  6.json解析key的值进行校验</span><br><span class="line">    Response body:JSON value check</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Args key contains argument passed as url parameter&quot;] = &#x27;test&#x27; in responseJSON.args</span><br><span class="line">    参数：test替换被测的值，args替换被测的key</span><br><span class="line"></span><br><span class="line">  7.检查response的header信息是否有被测字段</span><br><span class="line">    Response headers:Content-Type header check</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Content-Type is present&quot;] = postman.getResponseHeader(&quot;Content-Type&quot;);</span><br><span class="line">    参数：预期header</span><br><span class="line"></span><br><span class="line">  8.响应时间判断</span><br><span class="line">    Response time is less than 200ms</span><br><span class="line">    对应脚本：</span><br><span class="line">    tests[&quot;Response time is less than 200ms&quot;] = responseTime &lt; 200;</span><br><span class="line">    参数：响应时间</span><br><span class="line"></span><br><span class="line">    9.设置全局变量</span><br><span class="line">      Set an global variable</span><br><span class="line">      对应脚本：</span><br><span class="line">      postman.setGlobalVariable(&quot;variable_key&quot;, &quot;variable_value&quot;);</span><br><span class="line">      参数：全局变量的键值</span><br><span class="line"></span><br><span class="line">    10.设置环境变量</span><br><span class="line">      Set an environment variable</span><br><span class="line">      对应脚本：</span><br><span class="line">      postman.setEnvironmentVariable(&quot;variable_key&quot;, &quot;variable_value&quot;);</span><br><span class="line">      参数：环境变量的键值</span><br><span class="line"></span><br><span class="line">    11.判断状态码</span><br><span class="line">      Status code:Code is 200</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Status code is 200&quot;] = responseCode.code != 400;</span><br><span class="line">      参数：状态码</span><br><span class="line"></span><br><span class="line">    12.检查code name 是否包含内容</span><br><span class="line">      Status code:Code name has string</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Status code name has string&quot;] = responseCode.name.has(&quot;Created&quot;);</span><br><span class="line">      参数：预期code name包含字符串</span><br><span class="line"></span><br><span class="line">    13.成功的post请求</span><br><span class="line">      Status code:Successful POST request</span><br><span class="line">      对应脚本：</span><br><span class="line">      tests[&quot;Successful POST request&quot;] = responseCode.code === 201 || responseCode.code === 202;</span><br><span class="line"></span><br><span class="line">     14.微小验证器</span><br><span class="line">       Use Tiny Validator for JSON data            </span><br><span class="line">       对应脚本： </span><br><span class="line">        var schema = &#123;</span><br><span class="line">         &quot;items&quot;: &#123;</span><br><span class="line">         &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">        var data1 = [true, false];</span><br><span class="line">        var data2 = [true, 123];</span><br><span class="line">        console.log(tv4.error);</span><br><span class="line">        tests[&quot;Valid Data1&quot;] = tv4.validate(data1, schema);</span><br><span class="line">        tests[&quot;Valid Data2&quot;] = tv4.validate(data2, schema);</span><br><span class="line">        参数：可以修改items里面的键值对来对应验证json的参数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>简单总结了下postman 的基本玩法，更高级的等有了更深的体会，在补充之，希望能给您带来帮助～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派模型</title>
      <link href="/2016/10/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/10/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看过几篇文章后，这篇总结的不错，转载之，方便学习及回顾</p></blockquote><blockquote><p>原文出处： <a href="https://www.jianshu.com/p/acc7595f1b9d">huachao1001</a></p></blockquote><p>其实，双亲委派模型并不复杂。自定义类加载器也不难！随便从网上搜一下就能搜出一大把结果，然后<code>copy</code>一下就能用。但是，如果每次想自定义类加载器就必须搜一遍别人的文章，然后复制，这样显然不行。可是自定义类加载器又不经常用，时间久了容易忘记。相信你经常会记不太清<code>loadClass</code>、<code>findClass</code>、<code>defineClass</code>这些函数我到底应该重写哪一个？它们主要是做什么的？本文大致分析了各个函数的流程，目的就是让你看完之后，难以忘记！或者说，延长你对自定义类加载器的记忆时间！随时随地想自定义就自定义！</p><h1 id="1-双亲委派模型"><a href="#1-双亲委派模型" class="headerlink" title="1. 双亲委派模型"></a>1. 双亲委派模型</h1><p>关于双亲委派模型，网上的资料有很多。我这里只简单的描述一下，就当是复习。</p><h2 id="1-1-什么是双亲委派模型？"><a href="#1-1-什么是双亲委派模型？" class="headerlink" title="1.1 什么是双亲委派模型？"></a>1.1 什么是双亲委派模型？</h2><p>首先，先要知道什么是类加载器。简单说，类加载器就是根据指定全限定名称将<code>class</code>文件加载到<code>JVM</code>内存，转为<code>Class</code>对象。如果站在<code>JVM</code>的角度来看，只存在两种类加载器:</p><blockquote><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录或<code>-Xbootclasspath</code>参数指定的路径中的类库加载到内存中。</li><li>其他类加载器：由<code>Java</code>语言实现，继承自抽象类<code>ClassLoader</code>。如：</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>应用程序类加载器（<code>Application ClassLoader</code>）。负责加载用户类路径（<code>classpath</code>）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul></blockquote><p>双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即<code>ClassNotFoundException</code>），子加载器才会尝试自己去加载。</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-d2f7f6206935de2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><p>类加载器的双亲委派模型</p><h2 id="1-2-为什么需要双亲委派模型？"><a href="#1-2-为什么需要双亲委派模型？" class="headerlink" title="1.2 为什么需要双亲委派模型？"></a>1.2 为什么需要双亲委派模型？</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个<code>java.lang.String</code>类，该<code>String</code>类具有系统的<code>String</code>类一样的功能，只是在某个函数稍作修改。比如<code>equals</code>函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到<code>JVM</code>中。此时，如果没有双亲委派模型，那么<code>JVM</code>就可能误以为黑客自定义的<code>java.lang.String</code>类是系统的<code>String</code>类，导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在<code>JVM</code>中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。</p><p>举个简单例子：</p><blockquote><p><code>ClassLoader1</code>、<code>ClassLoader2</code>都加载<code>java.lang.String</code>类，对应Class1、Class2对象。那么<code>Class1</code>对象不属于<code>ClassLoad2</code>对象加载的<code>java.lang.String</code>类型。</p></blockquote><h2 id="1-3-如何实现双亲委派模型？"><a href="#1-3-如何实现双亲委派模型？" class="headerlink" title="1.3 如何实现双亲委派模型？"></a>1.3 如何实现双亲委派模型？</h2><p>双亲委派模型的原理很简单，实现也简单。每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。其实<code>ClassLoader</code>类默认的<code>loadClass</code>方法已经帮我们写好了，我们无需去写。</p><h1 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h1><h1 id="2-1几个重要函数"><a href="#2-1几个重要函数" class="headerlink" title="2. 1几个重要函数"></a>2. 1几个重要函数</h1><h3 id="2-1-1-loadClass"><a href="#2-1-1-loadClass" class="headerlink" title="2.1.1 loadClass"></a>2.1.1 loadClass</h3><p><code>loadClass</code>默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看看<code>loadClass(String name, boolean resolve)</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码可以明显看出，<code>loadClass(String, boolean)</code>函数即实现了双亲委派模型！整个大致过程如下：</p><blockquote><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name, false);</code>）.或者是调用<code>bootstrap</code>类加载器来加载。</li><li>如果父加载器及<code>bootstrap</code>类加载器都没有找到指定的类，那么调用当前类加载器的<code>findClass</code>方法来完成类加载。</li></ol></blockquote><p><strong>话句话说，如果自定义类加载器，就必须重写findClass方法！</strong></p><h3 id="2-1-1-find-Class"><a href="#2-1-1-find-Class" class="headerlink" title="2.1.1 find Class"></a>2.1.1 find Class</h3><p><code>findClass</code>的默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，抽象类<code>ClassLoader</code>的<code>findClass</code>函数默认是抛出异常的。而前面我们知道，<code>loadClass</code>在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的<code>findeClass</code>函数，因此我们必须要在<code>loadClass</code>这个函数里面实现将一个指定类名称转换为<code>Class</code>对象.</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为<code>Class</code>对象呢？很简单，<code>Java</code>提供了<code>defineClass</code>方法，通过这个方法，就可以把一个字节数组转为Class对象啦~</p><h3 id="2-1-1-defineClass"><a href="#2-1-1-defineClass" class="headerlink" title="2.1.1 defineClass"></a>2.1.1 defineClass</h3><p><code>defineClass</code>主要的功能是：</p><blockquote><p>将一个字节数组转为<code>Class</code>对象，这个字节数组是<code>class</code>文件读取后最终的字节数组。如，假设<code>class</code>文件是加密过的，则需要解密后作为形参传入<code>defineClass</code>函数。</p></blockquote><p><code>defineClass</code>默认实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError  &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-函数调用过程"><a href="#2-2-函数调用过程" class="headerlink" title="2.2 函数调用过程"></a>2.2 函数调用过程</h2><p>上一节所提的函数调用过程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-d5859f8e79069128?imageMogr2/auto-orient/strip%7CimageView2/2/w/598" alt="img"></p><p>自定义函数调用过程</p><h2 id="2-3-简单示例"><a href="#2-3-简单示例" class="headerlink" title="2.3 简单示例"></a>2.3 简单示例</h2><p>首先，我们定义一个待加载的普通<code>Java</code>类:<code>Test.java</code>。放在<code>com.huachao.cl</code>包下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.huachao.cl;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;恩，是的，我是由 &quot; + getClass().getClassLoader().getClass()</span><br><span class="line">                + &quot; 加载进来的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>如果你是直接在当前项目里面创建，待<code>Test.java</code>编译后，请把<code>Test.class</code>文件拷贝走，再将<code>Test.java</code>删除。因为如果<code>Test.class</code>存放在当前项目中，根据双亲委派模型可知，会通过<code>sun.misc.Launcher$AppClassLoader</code> 类加载器加载。为了让我们自定义的类加载器加载，我们把Test.class文件放入到其他目录。</p></blockquote><p>在本例中，我们Test.class文件存放的目录如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2154124-fcf13f3f446a60f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/602" alt="img"></p><p>class文件目录</p><p>接下来就是自定义我们的类加载器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">        private String classPath;</span><br><span class="line"></span><br><span class="line">        public MyClassLoader(String classPath) &#123;</span><br><span class="line">            this.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] loadByte(String name) throws Exception &#123;</span><br><span class="line">            name = name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span><br><span class="line">            FileInputStream fis = new FileInputStream(classPath + &quot;/&quot; + name</span><br><span class="line">                    + &quot;.class&quot;);</span><br><span class="line">            int len = fis.available();</span><br><span class="line">            byte[] data = new byte[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            return data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] data = loadByte(name);</span><br><span class="line">                return defineClass(name, data, 0, data.length);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                throw new ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        MyClassLoader classLoader = new MyClassLoader(&quot;D:/test&quot;);</span><br><span class="line">        Class clazz = classLoader.loadClass(&quot;com.huachao.cl.Test&quot;);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method helloMethod = clazz.getDeclaredMethod(&quot;hello&quot;, null);</span><br><span class="line">        helloMethod.invoke(obj, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恩，是的，我是由 class Main$MyClassLoader 加载进来的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 启动时选择项目</title>
      <link href="/2016/09/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E5%90%AF%E5%8A%A8%E6%97%B6%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE/"/>
      <url>/2016/09/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E5%90%AF%E5%8A%A8%E6%97%B6%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="idea-启动时选择项目"><a href="#idea-启动时选择项目" class="headerlink" title="idea 启动时选择项目"></a>idea 启动时选择项目</h2><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>idea，（15.2）启动时，直接进入之前关闭的时的最后一个项目，在加载过程中点取消，才会出现选择项目的界面，想要启动时就进行选择，只要配置下即可，这里做下记录，以免后续忘记</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>File–&gt;Settings （Ctrl + Alt + S） –&gt; Appearance &amp; Behavior –&gt; System Setting</li></ul><p><img src="http://i.imgur.com/5X6FK1m.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful设计规范</title>
      <link href="/2016/09/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20RESTful%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2016/09/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20RESTful%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful设计规范"><a href="#RESTful设计规范" class="headerlink" title="RESTful设计规范"></a>RESTful设计规范</h2><h1 id="一、-摘要（Abstract）"><a href="#一、-摘要（Abstract）" class="headerlink" title="一、 摘要（Abstract）"></a>一、 摘要（Abstract）</h1><p>RESTful API 已经非常成熟，也得到了大家的认可。我们按照 <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> 对 REST 评价的模型，规范基于 level2 来设计</p><h1 id="二、版本（Versioning）"><a href="#二、版本（Versioning）" class="headerlink" title="二、版本（Versioning）"></a>二、版本（Versioning）</h1><p>API的版本号放入URL。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.jiuyescm.com/v1/</span><br><span class="line">https://api.jiuyescm.com/v1.2/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、资源、路径（Endpoint）"><a href="#三、资源、路径（Endpoint）" class="headerlink" title="三、资源、路径（Endpoint）"></a>三、资源、路径（Endpoint）</h1><p>路径，API的具体地址。在REST中，每个地址都代表一个具体的资源（<code>Resource</code>）约定如下：</p><ul><li><p>路径仅表示资源的路径（位置），尽量不要有actions操作（一些特殊的<code>actions</code>操作除外）</p></li><li><p>路径以 复数（名词） 进行命名资源，不管返回单个或者多个资源。</p></li><li><p>使用 小写字母、数字以及下划线（“_”） 。（下划线是为了区分多个单词，如user_name）</p></li><li><p>资源的路径从父到子依次如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&#123;resource&#125;/&#123;resource_id&#125;/&#123;sub_resource&#125;/&#123;sub_resource_id&#125;/&#123;sub_resource_property&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>?</code> 来进行资源的过滤、搜索以及分页等</p></li><li><p>使用版本号，且版本号在资源路径之前</p></li><li><p>优先使用内容协商来区分表述格式，而不是使用后缀来区分表述格式</p></li><li><p>应该放在一个专用的域名下，如：<code>http：//api.jiuyescm.com</code></p></li><li><p>使用SSL</p></li></ul><p>综上，一个API路径可能会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://api.domain.com/v1/&#123;resource&#125;/&#123;resource_id&#125;/&#123;sub_resource&#125;/&#123;sub_resource_id&#125;/&#123;sub_resource_property&#125;</span><br><span class="line">https://api.domain.com /v1/&#123;resource&#125;?page=1&amp;page_size=10</span><br><span class="line">https://api.domain.com /v1/&#123;resource&#125;?name=xx&amp;sortby=name&amp;order=asc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四、操作（HTTP-Actions）"><a href="#四、操作（HTTP-Actions）" class="headerlink" title="四、操作（HTTP Actions）"></a>四、操作（HTTP Actions）</h1><p>用<code>HTTP</code>动词（方法）表示对资源的具体操作。常用的<code>HTTP</code>动词有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）</span><br><span class="line">POST（CREATE）：在服务器新建一个资源</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）  </span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性） </span><br><span class="line">DELETE（DELETE）：从服务器删除资源</span><br><span class="line">还有两个不常用的HTTP动词</span><br><span class="line">HEAD：获取资源的元数据</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一些例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /users：列出所有用户  </span><br><span class="line">POST /users：新建一个用户  </span><br><span class="line">GET /users/&#123;user_id&#125;：获取某个指定用户的信息  </span><br><span class="line">PUT /users/&#123;user_id&#125;：更新某个指定用户的信息（提供该用户的全部信息）  </span><br><span class="line">PATCH /users/&#123;user_id&#125;：更新某个指定用户的信息（提供该用户的部分信息）  </span><br><span class="line">DELETE /users/&#123;user_id&#125;：删除某个用户  </span><br><span class="line">GET /users/&#123;user_id&#125;/resources：列出某个指定用户的所有权限资源  </span><br><span class="line">DELETE /users/&#123;user_id&#125;/resources/&#123;resources_id&#125;：删除某个指定用户的指定权限资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、数据（Data-Format）"><a href="#五、数据（Data-Format）" class="headerlink" title="五、数据（Data Format）"></a>五、数据（Data Format）</h1><p>数据是对资源的具体描述，分为请求数据和返回数据。约定如下：</p><ul><li>查询，过滤条件使用query string，例如user?name&#x3D;xxx</li><li>Content body 仅仅用来传输数据</li><li>通过Content-Type指定请求与返回的数据格式。其中请求数据还要指定Accept。（我们暂时只使用Json）</li><li>数据应该拿来就能用，不应该还要进行转换操作</li><li>使用字符串（YYYY-MM-dd hh:mm:ss）格式表达时间字段，例如: 2017-02-20 16:00:00</li><li>数据采用UTF-8编码</li><li>返回的数据应该尽量简单，响应状态应该包含在响应头中</li><li>使用 小写字母、数字以及下划线（“_”） 描述字段，不使用大写描述字段（这个由于使用了一些开源的jar所以这个不强求，比如说pageinfo我们无法修改属性名称）</li><li>建议资源中的唯一标识命名为id（这个不强求，有的唯一标识名称确实比较复杂）</li><li>属性和字符串值必须使用双引号””（这个json转换默认规则）</li><li>建议对每个字段设置默认值（数组型可设置为[],字符串型可设置为””，数值可设置为0，对象可设置为{}）,这一条是为了方便前端&#x2F;客户端进行判断字段存不存在操作（这样json转换会自动转成相应的字符）</li><li>POST操作应该返回新建的资源；PUT&#x2F;PATCH操作返回更新后的完整的资源；DELETE返回一个空文档；GET返回资源数组或当个资源</li><li>为了方便以后的扩展兼容，如果返回的是数组，强烈建议用一个包含如items属性的对象进行包裹，如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;items&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">POST https://api.domain.com/v1/users</span><br><span class="line">Request</span><br><span class="line">    headers:</span><br><span class="line">        Accept: application/json</span><br><span class="line">        Content-Type: application/json;charset=UTF-8</span><br><span class="line">    body:</span><br><span class="line">     &#123;</span><br><span class="line">            &quot;user_name&quot;: &quot;ZhangSan&quot;,</span><br><span class="line">            &quot;address&quot;: &quot;ujfhysdfsdf&quot;,</span><br><span class="line">             &quot;nick&quot;: &quot;ZS&quot;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">Response</span><br><span class="line">    status: 201 Created</span><br><span class="line">    headers:</span><br><span class="line">        Content-Type: application/json;charset=UTF-8</span><br><span class="line">    body:</span><br><span class="line">        &#123;</span><br><span class="line">           &quot;requestId&quot;: sdfsdflkjoiusdf,</span><br><span class="line">           &quot;code&quot;: &quot;&quot;,</span><br><span class="line">            &quot;message&quot;: &quot;&quot;,</span><br><span class="line">            &quot;items&quot;:</span><br><span class="line">                  &#123;</span><br><span class="line">                       &quot;id&quot;:&quot;111&quot;,</span><br><span class="line">                       &quot;user_name&quot;: &quot;HingKwan&quot;,</span><br><span class="line">                       &quot;address&quot;: &quot;ujfhysdfsdf&quot;,</span><br><span class="line">                        &quot;nick&quot;: &quot;ZS&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="六、安全（Security）"><a href="#六、安全（Security）" class="headerlink" title="六、安全（Security）"></a>六、安全（Security）</h1><h2 id="调用限制"><a href="#调用限制" class="headerlink" title="调用限制"></a>调用限制</h2><p>为了避免请求泛滥，给API设置速度限制很重要。入速度设置之后，可以在HTTP返回头上对返回的信息进行说明，下面是几个必须的返回头（依照twitter的命名规则）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X-Rate-Limit-Limit :当前时间段允许的并发请求数</span><br><span class="line">X-Rate-Limit-Remaining:当前时间段保留的请求数</span><br><span class="line">X-Rate-Limit-Reset:当前时间段剩余秒数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个我们一般会在getway中实现</strong></p><h2 id="授权校验"><a href="#授权校验" class="headerlink" title="授权校验"></a>授权校验</h2><p>RESTful API是无状态的也就是说用户请求的鉴权和cookie以及session无关，每一次请求都应该包含鉴权证明。 可以使用http请求头Authorization设置授权码; 必须使用User-Agent设置客户端信息, 无User-Agent请求头的请求应该被拒绝访问。具体的授权可以采用OAuth2，或者自己定义并实现相关的授权验证机制（基于token）。 <strong>这个我们一般会在getway中实现</strong></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>当API返回非2XX的HTTP响应时，应该采用统一的响应信息，格式如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:&quot;INVALID_ARGUMENT&quot;,</span><br><span class="line">    &quot;message&quot;:&quot;&#123;error message&#125;&quot;,</span><br><span class="line">    &quot;request_id&quot;:&quot;sdfsdfo8lkjsdf&quot;,</span><br><span class="line">    &quot;items&quot;:[],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>HTTP Header Code：符合HTTP响应的状态码。详细见以下的“状态码”节</li><li>code：用来表示某类错误不是具体错误，比如缺少参数等。是对HTTP Header Code的补充，开发团队可以根据自己的需要自己定义</li><li>message：错误信息的摘要，应该是对用户处理错误有用的信息</li><li>request_id：请求的id，方便开发定位发生错误的请求（可选）</li><li>code的定义约定：<ul><li>采用 大写字母命名，字母与字母之间用下划线（”_”） 隔开</li><li>code应该用来定义错误类别，而非定义具体的某个错误。</li><li>缺少参数使用：MISSING_X</li><li>无效参数使用：INVALID_X</li><li>逻辑验证错误使用：VALIDATION_X</li><li>不存在使用：NO_FOUND_X</li></ul></li></ul><h1 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h1><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">200 OK - [GET/PUT/PATCH/DELETE]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。  </span><br><span class="line">201 Created - [POST/PUT/PATCH]：用户新建或修改数据成功。  </span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）  </span><br><span class="line">204 No Content - [DELETE]：用户删除数据成功。  </span><br><span class="line">304 Not Modified   - HTTP缓存有效。</span><br><span class="line">400 Invalid Request - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。  </span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。  </span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。  </span><br><span class="line">404 Not Found - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">405 Method Not Allowed - [*]：该http方法不被允许。  </span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。  </span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。  </span><br><span class="line">415 Unsupported Media Type - [*]：请求类型错误。</span><br><span class="line">422 Unprocesable Entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。  </span><br><span class="line">429 Too Many Request - [*]：请求过多。</span><br><span class="line">500 Internal Server Error - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。  </span><br><span class="line">503 Service Unavailable - [*]：服务当前无法处理请求。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="八、异常规范（Exceptions）"><a href="#八、异常规范（Exceptions）" class="headerlink" title="八、异常规范（Exceptions）"></a>八、异常规范（Exceptions）</h1><ul><li>Controller中try catch住service的异常，再转换为restful中需要抛出的异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Long id = userService.save(vo);</span><br><span class="line">    vo.setId(id);</span><br><span class="line">&#125; catch(BizException e) &#123;</span><br><span class="line">    throw new UnprocesableEntityException(ErrorCode.USER_NAME_EXIST.getCode(), ErrorCode.USER_NAME_EXIST.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Controller中抛出的异常必须使用spring-mvc-rest包中的异常类，不允许自定义异常，选择需要返回的httpStatus对应的异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#403 [*]：表示得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.ForbiddenException</span><br><span class="line"></span><br><span class="line">#410 [GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.GoneException</span><br><span class="line"></span><br><span class="line">#400 [POST/PUT/PATCH]：用户发出的请求有错误（常用在请求必要的参数错误上），服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.InvalidRequestException</span><br><span class="line"></span><br><span class="line">#406 [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）或（请求参数需要数字，用户传入字符串）</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.NotAcceptableException</span><br><span class="line"></span><br><span class="line">#404 [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.NotFoundException</span><br><span class="line"></span><br><span class="line">#401 [*]：表示没有权限（令牌、用户名、密码错误，或任何资源没有权限）</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.UnauthorizedException</span><br><span class="line"></span><br><span class="line">#422 [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">com.jiuyescm.spring.mvc.rest.exception.UnprocesableEntityException</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>抛出的异常中需要传入异常编码和异常信息，异常编码定义遵循上面 《安全中错误编码规范》</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;MESSING_ID&quot;, &quot;缺少参数：id&quot;</span><br><span class="line">&quot;MESSING_NAME&quot;, &quot;缺少参数：name&quot;</span><br><span class="line">&quot;MESSING_ADDRESS&quot;, &quot;缺少参数：address&quot;</span><br><span class="line">&quot;USER_NAME_EXIST&quot;, &quot;用户名已存在&quot;</span><br><span class="line">&quot;USER_NOT_FOUND&quot;, &quot;用户名不存在&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常用的错误编码、异常、httpStatus对应关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;MESSING_ID&quot;, &quot;缺少参数：id&quot;、InvalidRequestException、400</span><br><span class="line">&quot;MESSING_NAME&quot;, &quot;缺少参数：name&quot;、InvalidRequestException、400</span><br><span class="line">&quot;MESSING_ADDRESS&quot;, &quot;缺少参数：address&quot;、InvalidRequestException、400</span><br><span class="line">&quot;USER_NAME_EXIST&quot;, &quot;用户名已存在&quot;、UnprocesableEntityException、422</span><br><span class="line">&quot;USER_NOT_FOUND&quot;, &quot;用户名不存在&quot;、NotFoundException、404</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="九、示例（Example）"><a href="#九、示例（Example）" class="headerlink" title="九、示例（Example）"></a>九、示例（Example）</h1><p>采用user提供的示例代码</p><h2 id="POST-x2F-users"><a href="#POST-x2F-users" class="headerlink" title="POST &#x2F;users"></a>POST &#x2F;users</h2><p>Resource <code>POST /v1/users</code></p><p>POST Parameters Endpoint requires：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>用户住址</td></tr></tbody></table><p>and accepts a few other parameters listed below.</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;:&quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;:&quot;sdfoiu&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 201 Created</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 27,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Objec</td><td>t 返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 400 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;MESSING_NAME&quot;,</span><br><span class="line">  &quot;message&quot;: “缺少参数：name”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_NAME</td><td>缺少参数：name</td></tr><tr><td>400</td><td>MESSING_ADDRESS</td><td>缺少参数：address</td></tr><tr><td>422</td><td>USER_NAME_EXIST</td><td>用户名已存在</td></tr><tr><td>500</td><td>INTERNAL_SERVER_ERROR</td><td>未知的错误</td></tr></tbody></table><h2 id="DELETE-x2F-users-x2F-user-id"><a href="#DELETE-x2F-users-x2F-user-id" class="headerlink" title="DELETE &#x2F;users&#x2F;{user_id}"></a>DELETE &#x2F;users&#x2F;{user_id}</h2><p>Resource <code>DELETE /v1/users/&#123;user_id&#125;</code></p><p>Path Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr></tbody></table><p>Query Parameters None</p><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl –H ‘Content-Type: application/json’\</span><br><span class="line">-X DELETE \</span><br><span class="line">‘https://api.jiuyescm.com/v1/users/111’ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 204 No Content</p><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>404</td><td>USER_NOT_FOUND</td><td>用户不存在</td></tr></tbody></table><h2 id="PUT-x2F-users"><a href="#PUT-x2F-users" class="headerlink" title="PUT &#x2F;users"></a>PUT &#x2F;users</h2><p>Resource <code>PUT /v1/users</code></p><p>PUT Body Parameters Endpoint requires：</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr><tr><td>user_name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>用户住址</td></tr></tbody></table><p>and accepts a few other parameters listed below..</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;user_id&quot;: 12,</span><br><span class="line">    &quot;name&quot;:&quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;:&quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;:&quot;sdfoiu&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 12,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 400 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;MESSING_NAME&quot;,</span><br><span class="line">  &quot;message&quot;: “缺少参数：name”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>400</td><td>MESSING_NAME</td><td>缺少参数：name</td></tr><tr><td>400</td><td>MESSING_ADDRESS</td><td>缺少参数：address</td></tr><tr><td>422</td><td>USER_NAME_EXIST</td><td>用户名已存在</td></tr><tr><td>500</td><td>INTERNAL_SERVER_ERROR</td><td>未知的错误</td></tr></tbody></table><h2 id="GET-x2F-users-x2F-user-id"><a href="#GET-x2F-users-x2F-user-id" class="headerlink" title="GET &#x2F;users&#x2F;{user_id}"></a>GET &#x2F;users&#x2F;{user_id}</h2><p>Resource <code>GET /v1/users/&#123;user_id&#125;</code></p><p>Path Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>user_id</td><td>Long</td><td>用户唯一标识</td></tr></tbody></table><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Curl –H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">&#x27;https://api.jiuyescm.com/v1/users/12&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: null,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 12,</span><br><span class="line">    &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">    &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>String</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table><p>Error response Status-Code: 404 Bad Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot; USER_NOT_FOUND&quot;,</span><br><span class="line">  &quot;message&quot;: “用户不存在”,</span><br><span class="line">  &quot;items&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr></tbody></table><p>HTTP Error Codes</p><table><thead><tr><th>HTTP Status</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>400</td><td>MESSING_ID</td><td>缺少参数：id</td></tr><tr><td>404</td><td>USER_NOT_FOUND</td><td>用户不存在</td></tr></tbody></table><h2 id="GET-x2F-users"><a href="#GET-x2F-users" class="headerlink" title="GET &#x2F;users"></a>GET &#x2F;users</h2><p>Resource <code>GET /v1/users</code></p><p>Query Parameters</p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>根据用户名称进行查询</td></tr><tr><td>page</td><td>int</td><td>第几页，不传入默认1</td></tr><tr><td>page_size</td><td>int</td><td>每页返回多少条结果，不传入默认20</td></tr></tbody></table><p>Example Request</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Curl –H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">&#x27;https://api.jiuyescm.com/v1/users?name=xxx&amp;page=1&amp;page_size=20&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Response Status-Code: 200 Success</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;&quot;,</span><br><span class="line">  &quot;items&quot;: &#123;</span><br><span class="line">    &quot;pageNum&quot;: 1,</span><br><span class="line">    &quot;pageSize&quot;: 20,</span><br><span class="line">    &quot;size&quot;: 17,</span><br><span class="line">    &quot;startRow&quot;: 1,</span><br><span class="line">    &quot;endRow&quot;: 17,</span><br><span class="line">    &quot;total&quot;: 17,</span><br><span class="line">    &quot;pages&quot;: 1,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 2,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu1&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 3,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu2&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 4,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu3&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 5,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu4&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 6,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu5&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 7,</span><br><span class="line">        &quot;name&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;8888&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 8,</span><br><span class="line">        &quot;name&quot;: &quot;444&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;444&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;444&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 9,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu7&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 12,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu9&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 13,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu10&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 17,</span><br><span class="line">        &quot;name&quot;: &quot;ningyu&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 20,</span><br><span class="line">        &quot;name&quot;: &quot;9999&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 23,</span><br><span class="line">        &quot;name&quot;: &quot;888&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 24,</span><br><span class="line">        &quot;name&quot;: &quot;222&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 25,</span><br><span class="line">        &quot;name&quot;: &quot;222444&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 26,</span><br><span class="line">        &quot;name&quot;: &quot;222444sdf&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: 27,</span><br><span class="line">        &quot;name&quot;: &quot;tuyir&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;sdflkjsdf&quot;,</span><br><span class="line">        &quot;remark&quot;: &quot;sdfoiu&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;firstPage&quot;: 1,</span><br><span class="line">    &quot;prePage&quot;: 0,</span><br><span class="line">    &quot;nextPage&quot;: 0,</span><br><span class="line">    &quot;lastPage&quot;: 1,</span><br><span class="line">    &quot;isFirstPage&quot;: true,</span><br><span class="line">    &quot;isLastPage&quot;: true,</span><br><span class="line">    &quot;hasPreviousPage&quot;: false,</span><br><span class="line">    &quot;hasNextPage&quot;: false,</span><br><span class="line">    &quot;navigatePages&quot;: 8,</span><br><span class="line">    &quot;navigatepageNums&quot;: [</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>code</td><td>String</td><td>错误编码</td></tr><tr><td>message</td><td>String</td><td>错误描述</td></tr><tr><td>Items</td><td>Object</td><td>返回结果</td></tr><tr><td>id</td><td>Long</td><td>唯一标识</td></tr><tr><td>name</td><td>String</td><td>用户名称</td></tr><tr><td>address</td><td>String</td><td>家庭住址</td></tr><tr><td>remark</td><td>String</td><td>描述信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 获得根目录</title>
      <link href="/2016/09/10/java/%20Spring%20%E8%8E%B7%E5%BE%97%E6%A0%B9%E7%9B%AE%E5%BD%95/"/>
      <url>/2016/09/10/java/%20Spring%20%E8%8E%B7%E5%BE%97%E6%A0%B9%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>项目过程中，有时需要在java中获取项目中静态资源，如图片资源的地址，可以通过System.getProperty(“webapp.root”)来动态获取项目的运行路径。</p></blockquote><ul><li><p>web.xml配置</p> <context-param>      <param-name>webAppRootKey</param-name>      <param-value>webapp.root</param-value>  </context-param><pre><code>&lt;!-- 根目录Listener  注意：此配置要配置在--&gt;</code></pre>  <listener>      <listener-class>org.springframework.web.util.WebAppRootListener</listener-class>  </listener>  <!-- Spring监听器 -->  <listener>      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  </listener></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins+Maven+Nexus+SVN+Tomcat+Sonar搭建持续集成环境</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins+Maven+Nexus+SVN+Tomcat+Sonar%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins+Maven+Nexus+SVN+Tomcat+Sonar%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daemon模式启动tomcat</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/daemon%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8tomcat/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/daemon%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="下载tomcat，过程略"><a href="#下载tomcat，过程略" class="headerlink" title="下载tomcat，过程略"></a>下载tomcat，过程略</h2><h2 id="安装Daemon-自启动"><a href="#安装Daemon-自启动" class="headerlink" title="安装Daemon 自启动"></a>安装Daemon 自启动</h2><pre><code>cd /usr/local/apache-tomcat-8.0.32/bintar -zxvf commons-daemon-native.tar.gzcd /usr/local/apache-tomcat-8.0.32/bin/commons-daemon-1.0.15-native-src/unix./configuremakecp jsvc ../..</code></pre><h2 id="新增tomcat用户并赋权限"><a href="#新增tomcat用户并赋权限" class="headerlink" title="新增tomcat用户并赋权限"></a>新增tomcat用户并赋权限</h2><pre><code>useradd -r tomcatchown -R tomcat: /usr/local/apache-tomcat-8.0.32</code></pre><h2 id="编写系统服务-关键"><a href="#编写系统服务-关键" class="headerlink" title="编写系统服务(关键)"></a>编写系统服务(关键)</h2><pre><code>vim /usr/lib/systemd/system/tomcatd.service</code></pre><h2 id="填入内容："><a href="#填入内容：" class="headerlink" title="填入内容："></a>填入内容：</h2><pre><code>Description=Apache Tomcat Web Application ContainerAfter=network.target syslog.target[Service]Type=forkingPIDFile=/var/run/tomcatd.pidEnvironment=CATALINA_PID=/var/run/tomcatd.pidEnvironment=JAVA_HOME=/usr/local/java/jdk1.8.0_74Environment=CATALINA_HOME=/usr/local/apache-tomcat-8.0.32ExecStart=/usr/local/apache-tomcat-8.0.32/bin/daemon.sh startExecStop=/usr/local/apache-tomcat-8.0.32/bin/daemon.sh stop[Install]WantedBy=multi-user.target</code></pre><h2 id="将tomcat加入系统自启动"><a href="#将tomcat加入系统自启动" class="headerlink" title="将tomcat加入系统自启动"></a>将tomcat加入系统自启动</h2><pre><code>systemctl enable tomcatd.service</code></pre><h2 id="测试是否能启动"><a href="#测试是否能启动" class="headerlink" title="测试是否能启动"></a>测试是否能启动</h2><pre><code>ps -aux| grep tomcat</code></pre><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><pre><code>systemctl stop tomcatd.servicesystemctl start tomcatd.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ideas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述nexus私服搭建及在idea中应用</title>
      <link href="/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%AE%80%E8%BF%B0nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9C%A8idea%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
      <url>/2016/09/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%AE%80%E8%BF%B0nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9C%A8idea%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简述nexus私服搭建及在idea中应用"><a href="#简述nexus私服搭建及在idea中应用" class="headerlink" title="简述nexus私服搭建及在idea中应用"></a>简述nexus私服搭建及在idea中应用</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Nexus是一个强大的Maven仓库管理器，它极大地简化了自己内部仓库的维护和外部仓库的访问。利用Nexus你可以只在一个地方就能够完全控制访问 和部署在你所维护仓库中的每个Artifact。Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。Nexus 使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过m2eclipse与Eclipse集成使用。Nexus支持WebDAV与LDAP安全身份认证。</p></blockquote><h2 id="下载安装-Nexus"><a href="#下载安装-Nexus" class="headerlink" title="下载安装 Nexus"></a>下载安装 Nexus</h2><ul><li>下载地址 <a href="http://www.sonatype.org/nexus/">Nexus官网</a></li></ul><p><strong>注意：</strong> 选择NEXUS OSS（开源版本）</p><h2 id="简述配置（win版本）"><a href="#简述配置（win版本）" class="headerlink" title="简述配置（win版本）"></a>简述配置（win版本）</h2><ul><li>将下载好的ZIP包进行解压</li><li>配置环境变量</li><li>启动</li></ul><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p> 访问<a href="http://localhost:8081/nexus/">http://localhost:8081/nexus/</a> 在右上角有个Log in 点击登录</p><ul><li>默认的用户名是 admin 密码是 admin123</li></ul><p> <img src="http://i.imgur.com/J7tH3Sl.png"></p><h2 id="Nexus中的仓库"><a href="#Nexus中的仓库" class="headerlink" title="Nexus中的仓库"></a>Nexus中的仓库</h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h3><blockquote><p>　登陆Nexus，在左边菜单栏里选择Repositories，然后会出现右边的画面，右边上半部分是列出来的repository，黑体字是类型为group的repository。　　　　</p></blockquote><p>简单介绍下几种repository的类型：</p><ul><li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li><li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li><li>group，仓库组，用来合并多个hosted&#x2F;proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li></ul><p><img src="http://i.imgur.com/gKlcHk0.png"></p><h3 id="管理本地仓库"><a href="#管理本地仓库" class="headerlink" title="管理本地仓库"></a>管理本地仓库</h3><p>　　　　</p><blockquote><p>hosted的为本地仓库，Nexus预定义了3个本地仓库，分别是Releases, Snapshots, 3rd Party.</p></blockquote><ul><li><p>Releases:</p><pre><code>  这里存放我们自己项目中发布的构建, 通常是Release版本的, 比如我们自己做了一个FTP Server的项目, 生成的构件为ftpserver.war, 我们就可以把这个构建发布到Nexus的Releases本地仓库. 关于符合发布后面会有介绍.</code></pre></li><li><p>Snapshots:</p><pre><code>  这个仓库非常的有用, 它的目的是让我们可以发布那些非release版本, 非稳定版本, 比如我们在trunk下开发一个项目,在正式release之前你可能需要临时发布一个版本给你的同伴使用, 因为你的同伴正在依赖你的模块开发, 那么这个时候我们就可以发布Snapshot版本到这个仓库, 你的同伴就可以通过简单的命令来获取和使用这个临时版本.</code></pre></li><li><p>3rd Party:</p><pre><code>  顾名思义, 第三方库, 你可能会问不是有中央仓库来管理第三方库嘛,没错, 这里的是指可以让你添加自己的第三方库, 比如有些构件在中央仓库是不存在的. 比如你在中央仓库找不到Oracle 的JDBC驱动, 这个时候我们就需要自己添加到3rdparty仓库。</code></pre></li></ul><blockquote><p>后续再补充一下配置自己的项目</p></blockquote><h2 id="IDEA-在项目中的配置"><a href="#IDEA-在项目中的配置" class="headerlink" title="IDEA 在项目中的配置"></a>IDEA 在项目中的配置</h2><h3 id="配置settings-xml文件"><a href="#配置settings-xml文件" class="headerlink" title="配置settings.xml文件"></a>配置settings.xml文件</h3><p>在 settings.xml 中添加：</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP/域名:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://IP/域名:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="IDEA-的maven配置"><a href="#IDEA-的maven配置" class="headerlink" title="IDEA 的maven配置"></a>IDEA 的maven配置</h3><p>选择配置好的settings.xml文件</p><p><img src="http://i.imgur.com/4D8JvUR.png"></p><h3 id="发布jar包"><a href="#发布jar包" class="headerlink" title="发布jar包"></a>发布jar包</h3><blockquote><p>  执行deploy按钮就可以将 打好的 jar 包或者 war包上传到 私服中  （install  是将jar包 拷贝到本地仓库）</p></blockquote><blockquote><p>在后续使用过程中，多多总结提高吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI 持续集成</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CD 持续发布</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CD%20%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CD%20%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于持续集成，持续交付（CI-x2F-CD）"><a href="#关于持续集成，持续交付（CI-x2F-CD）" class="headerlink" title="关于持续集成，持续交付（CI&#x2F;CD）"></a>关于持续集成，持续交付（CI&#x2F;CD）</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://bitnami.com/stack/jenkins">jenkins</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid 简述</title>
      <link href="/2016/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Druid%20%E7%AE%80%E8%BF%B0/"/>
      <url>/2016/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93/Druid%20%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h2><blockquote><p>Druid是什么? <span id="more"></span><br>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p></blockquote><ul><li>Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</li></ul><p>同时Druid不仅仅是一个数据库连接池</p><p><strong>它包括三部分：</strong> </p><ul><li>DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 </li><li>DruidDataSource 高效可管理的数据库连接池。 </li><li>SQLParser</li></ul><h2 id="Druid-的主要作用："><a href="#Druid-的主要作用：" class="headerlink" title="Druid 的主要作用："></a>Druid 的主要作用：</h2><ul><li><p>1.替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。</p></li><li><p>2.可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。</p></li><li><p>3.数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。</p></li><li><p>4.SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。</p></li><li><p>5.扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。</p></li></ul><h1 id="druid的项目路径及介绍"><a href="#druid的项目路径及介绍" class="headerlink" title="druid的项目路径及介绍"></a>druid的项目路径及介绍</h1><p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Druid github地址</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能测试相关</title>
      <link href="/2016/09/05/%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2016/09/05/%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>#简述</p><blockquote><p>…</p></blockquote><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><blockquote><p>一个系统的的吞吐量（承受压力）与请求对CPU的消耗、外部接口、IO等等紧密关联。<span id="more"></span>  单个请求对CPU消耗越高，外部系统接口、IO影响的速度越慢，系统吞吐能力越低，反之越高。  系统吞吐量几个重要参数： QPS(TPS),并发数，响应时间</p></blockquote><ul><li><p>QPS(TPS) : 每秒钟请求&#x2F;事务 数量</p></li><li><p>并发数： 系统同时处理的请求&#x2F;事务数</p></li><li><p>响应时间： 一般取的是平均响应时间</p></li></ul><p>他们之间的关系：</p><p>QPS(TPS) &#x3D; 并发数&#x2F;平均响应时间</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sz 与 rz 命令</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20sz%20%E4%B8%8E%20rz%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20Linux%20sz%20%E4%B8%8E%20rz%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>Linux 使用过程中，避免不了 上传，下载这样的操作，在没有FTP 工具时，通过 sz 、rz命令就可以实现上传，下载的需求。<span id="more"></span><br>但多数Linux系统默认未初始该命令，这里简单记录下sz、rz命令的安装与使用。</p></blockquote><h2 id="命令用途"><a href="#命令用途" class="headerlink" title="命令用途"></a>命令用途</h2><blockquote><p>已陈述sz 、rz可以完成上传，下载的这样的操作，具体对应为：</p></blockquote><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sz：（send） 将选定的文件发送（send）到本地机器</span><br><span class="line">rz：（receive）从本地选择文件上传到Linux服务器</span><br></pre></td></tr></table></figure></code></pre><h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><h3 id="1-编译安装"><a href="#1-编译安装" class="headerlink" title="1.编译安装"></a>1.编译安装</h3><p>root 账号登陆后，依次执行以下命令：</p><pre><code>cd /tmpwget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gztar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20./configure &amp;&amp; make &amp;&amp; make install</code></pre><ul><li><p>安装过程默认把lsz和lrz安装到了&#x2F;usr&#x2F;local&#x2F;bin&#x2F;目录下，现在我们并不能直接使用，下面创建软链接，并命名为rz&#x2F;sz：</p><p>  cd &#x2F;usr&#x2F;bin<br>  ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;lrz rz<br>  ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;lsz sz</p></li></ul><h3 id="2-yum安装"><a href="#2-yum安装" class="headerlink" title="2.yum安装"></a>2.yum安装</h3><p>root 账号登陆后执行以下命令：</p><pre><code>yum install -y lrzsz</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>sz将文件发送到本地：</p><pre><code>   # sz filename</code></pre></li><li><p>rz 将本地的文件上传至Linux环境上：</p><pre><code>  # rz</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 跳转到资源管理器的几种方式</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20idea%20%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>开发过程有时候会需要跳转到文件所在文件夹（资源管理器）中，之前使用eclipse时，有Open Explorer这样的插件，<span id="more"></span>在文件上右键就可以使用,学习使用idea后，有时候也需要这样的功能，这里整理下我了解到的三种方式~</p></blockquote><h2 id="idea-跳转到资源管理器的方式"><a href="#idea-跳转到资源管理器的方式" class="headerlink" title="idea 跳转到资源管理器的方式"></a>idea 跳转到资源管理器的方式</h2><h3 id="方式一：右键-Show-in-Explorer"><a href="#方式一：右键-Show-in-Explorer" class="headerlink" title="方式一：右键 Show in Explorer"></a>方式一：右键 Show in Explorer</h3><blockquote><ul><li>在project页面右键需要跳转的文件，选择右键菜单中的 <strong>Show in Explorer</strong></li></ul></blockquote><p><img src="http://i.imgur.com/G0dFyNd.png"></p><h3 id="方式二：-在工具栏上添加-Show-in-Explorer-按钮"><a href="#方式二：-在工具栏上添加-Show-in-Explorer-按钮" class="headerlink" title="方式二： 在工具栏上添加  Show in Explorer 按钮"></a>方式二： 在工具栏上添加  Show in Explorer 按钮</h3><blockquote><ul><li>在工具栏的空白处，右键选择 <strong>Customize Menus and Toolbars…</strong></li></ul></blockquote><p><img src="http://i.imgur.com/2Xr2Zbw.png"></p><blockquote><ul><li>在对话框中，展开 <strong>Main Toolbar</strong>  -&gt; <strong>TasksToolbar</strong> -&gt; 右侧的 <strong>Add After</strong></li></ul></blockquote><p><img src="http://i.imgur.com/lJD7sWl.png"></p><blockquote><ul><li>在对话框中，展开 <strong>Other</strong>  -&gt; <strong>Show in Explorer</strong> -&gt; 为其设置一个图标</li></ul></blockquote><ul><li><strong>注意：图标大小（建议<code>18 * 18</code> &#x2F; <code>16 * 16</code>）</strong> 太大了，idea会提示icon太大</li></ul><p><img src="http://i.imgur.com/6FzWD9l.png"></p><blockquote><ul><li>更改图标：添加过后，可以在 <strong>Main Toolbar</strong> 最下面找到<strong>Show in Explorer</strong> 右边菜单选择 <strong>Edit Action Icon</strong> 进行更换图标</li></ul></blockquote><p><img src="http://i.imgur.com/itRWLor.png"></p><blockquote><ul><li>这样比在project里右键文件省事一些~</li></ul></blockquote><h3 id="方式三：-快捷键-，idea强大的快捷键（推荐）"><a href="#方式三：-快捷键-，idea强大的快捷键（推荐）" class="headerlink" title="方式三： 快捷键 ，idea强大的快捷键（推荐）"></a>方式三： 快捷键 ，idea强大的快捷键（推荐）</h3><blockquote><ul><li>直接在当前编辑的文件中，按下快捷键 <strong>Ctrl + Alt + F12</strong> 会列出文件的所在的文件夹及上层目录，回车，跳转吧</li></ul></blockquote><hr><blockquote><p>每一个优秀的人，都不是与生俱来带着光环的，也不一定是比别人幸运。他们只是在任何一件小事上，都对自己有所要求，不因舒适而散漫放纵，不因辛苦而放弃追求。雕塑自己的过程，必定伴随着疼痛与辛苦，可那一锤一凿的自我敲打，终究能让我们收获一个更好的自己。九月来了，新的一天,加油！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS上安装JDK</title>
      <link href="/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E4%B8%8A%E5%AE%89%E8%A3%85JDK/"/>
      <url>/2016/09/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CentOS%E4%B8%8A%E5%AE%89%E8%A3%85JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>简单记录下Linux下安装JDK的方法，实际有很多种安装方式，这里只记录下解压缩包的方式，<span id="more"></span>其他如，yum，rpm等方式不再陈述</p></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><blockquote></blockquote><ul><li>CentOS 7.0 64</li><li>jdk-8u74-linux-x64.tar.gz</li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="1-在-x2F-usr-x2F-local-x2F-目录下创建java目录"><a href="#1-在-x2F-usr-x2F-local-x2F-目录下创建java目录" class="headerlink" title="1.在&#x2F;usr&#x2F;local&#x2F;目录下创建java目录"></a>1.在&#x2F;usr&#x2F;local&#x2F;目录下创建java目录</h3><pre><code># mkdir /usr/local/java# cd /usr/local/java</code></pre><h3 id="2-解压tar-gz-文件"><a href="#2-解压tar-gz-文件" class="headerlink" title="2.解压tar.gz 文件"></a>2.解压tar.gz 文件</h3><pre><code># tar -zxvf jdk-8u74-linux-x64.tar.gz</code></pre><h3 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h3><pre><code>#  vi /etc/profile</code></pre><ul><li><p>设置JAVA_HOME环境</p><pre><code>  export JAVA_HOME=/usr/local/java/jdk1.8.0_74  export JRE_HOME=/usr/local/java/jdk1.8.0_74/jre  export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH  export PATH=$JAVA_HOME/bin:$PATH</code></pre></li></ul><h3 id="4-引用文件，生效"><a href="#4-引用文件，生效" class="headerlink" title="4.引用文件，生效"></a>4.引用文件，生效</h3><pre><code># source /etc/profile</code></pre><h3 id="5-验证配置"><a href="#5-验证配置" class="headerlink" title="5.验证配置"></a>5.验证配置</h3><pre><code># java -versionjava version &quot;1.8.0_74&quot;Java(TM) SE Runtime Environment (build 1.8.0_74-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 排序</title>
      <link href="/2016/08/30/java/%20JAVA%20%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/30/java/%20JAVA%20%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Date 函数</title>
      <link href="/2016/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20Date%20%E5%87%BD%E6%95%B0/"/>
      <url>/2016/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20Date%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-Date-函数"><a href="#Mysql-Date-函数" class="headerlink" title="Mysql Date 函数"></a>Mysql Date 函数</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>工作中，经常会遇到日期处理相关业务场景，这里整理下mysql常用的时间相关函数，加深记忆，也方便之后查找<span id="more"></span></p></blockquote><h2 id="MySQL-Date-函数"><a href="#MySQL-Date-函数" class="headerlink" title="MySQL Date 函数"></a>MySQL Date 函数</h2><ul><li>MySQL 中几个重要的日期函数：</li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="#now">NOW()</a></td><td>返回当前的日期和时间</td></tr><tr><td><a href="#CURDATE">CURDATE()</a></td><td>返回当前的日期</td></tr><tr><td><a href="#CURTIME">CURTIME()</a></td><td>返回当前的时间</td></tr><tr><td><a href="#DATE">DATE()</a></td><td>提取日期或日期&#x2F;时间表达式的日期部分</td></tr><tr><td><a href="#EXTRACT">EXTRACT()</a></td><td>返回日期&#x2F;时间按的单独部分</td></tr><tr><td><a href="#DATE_ADD">DATE_ADD()</a></td><td>给日期添加指定的时间间隔</td></tr><tr><td><a href="#DATE_SUB">DATE_SUB()</a></td><td>从日期减去指定的时间间隔</td></tr><tr><td><a href="#DATEDIFF">DATEDIFF()</a></td><td>返回两个日期之间的天数</td></tr><tr><td><a href="#DATE_FORMAT">DATE_FORMAT()</a></td><td>用不同的格式显示日期&#x2F;时间</td></tr></tbody></table><h3 id="SQL-Date-数据类型"><a href="#SQL-Date-数据类型" class="headerlink" title="SQL Date 数据类型"></a>SQL Date 数据类型</h3><p>MySQL 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值</p><ul><li>DATE - 格式 YYYY-MM-DD</li><li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li><li>YEAR - 格式 YYYY 或 YY</li></ul><h2 id="date-函数用法"><a href="#date-函数用法" class="headerlink" title="date 函数用法"></a>date 函数用法</h2><h3 id="MySQL-NOW-函数"><a href="#MySQL-NOW-函数" class="headerlink" title="MySQL NOW() 函数"></a><span id="now">MySQL NOW() 函数</span></h3><hr><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>NOW() 函数返回当前的日期和时间。</li></ul><p><strong>语法</strong></p><pre><code>NOW()</code></pre><p><strong>举例</strong></p><pre><code>SELECT NOW(),CURDATE(),CURTIME();</code></pre><p>结果</p><table><thead><tr><th>NOW()</th><th>CURDATE()</th><th>CURTIME()</th></tr></thead><tbody><tr><td>2016-08-25 12:29:23</td><td>2016-08-25</td><td>12:29:23</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使Guava的插件实现equals, hashCode 和 toString方法（idea）</title>
      <link href="/2016/08/23/java/%E4%BD%BFGuava%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0equals,%20hashCode%20%E5%92%8C%20toString%E6%96%B9%E6%B3%95%EF%BC%88idea%EF%BC%89/"/>
      <url>/2016/08/23/java/%E4%BD%BFGuava%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0equals,%20hashCode%20%E5%92%8C%20toString%E6%96%B9%E6%B3%95%EF%BC%88idea%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><blockquote><p>POJO 类需要编写equals, hashCode 和 toString方法，通常只需要一个模板就能完成，目前我们已经可以让IDE使用插件来帮我们完成这些工作。但是<span id="more"></span>通常由IDE自动生成的这些代码都非常难看：</p></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddrInfo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1900570942803605101L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户uid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 市</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细地址( 领地一 / 领地二 )</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String addrDetail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// getters, setters if needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="通常做法"><a href="#通常做法" class="headerlink" title="通常做法"></a>通常做法</h1><p>目前的主流IDE都能够生成符合需求的方法的代码，但是生成的equals、hashCode和toString方法代码通常看起来就像下面这样：</p><ol><li><p><strong>equals</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserAddrInfo</span> <span class="variable">that</span> <span class="operator">=</span> (UserAddrInfo) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="literal">null</span> ? !uid.equals(that.uid) : that.uid != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (province != <span class="literal">null</span> ? !province.equals(that.province) : that.province != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (city != <span class="literal">null</span> ? !city.equals(that.city) : that.city != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (area != <span class="literal">null</span> ? !area.equals(that.area) : that.area != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> addrDetail != <span class="literal">null</span> ? addrDetail.equals(that.addrDetail) : that.addrDetail == <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>hashCode</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> uid != <span class="literal">null</span> ? uid.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + (province != <span class="literal">null</span> ? province.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (city != <span class="literal">null</span> ? city.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (area != <span class="literal">null</span> ? area.hashCode() : <span class="number">0</span>);</span><br><span class="line">    result = <span class="number">31</span> * result + (addrDetail != <span class="literal">null</span> ? addrDetail.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>toString</strong></p><pre><code>     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserAddrInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uid=&quot;</span> + uid +</span><br><span class="line">                <span class="string">&quot;, province=&#x27;&quot;</span> + province + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, city=&#x27;&quot;</span> + city + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, area=&#x27;&quot;</span> + area + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, addrDetail=&#x27;&quot;</span> + addrDetail + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="使用Guava库来解决"><a href="#使用Guava库来解决" class="headerlink" title="使用Guava库来解决"></a>使用Guava库来解决</h1><p>Google Guava是一个提供了很多非常使用Java工具的精巧的库。我们可以使用Google Guava来重写上面的三个方法来使得代码显得更好看：</p><ol><li><p><strong>equals</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">UserAddrInfo</span> <span class="variable">that</span> <span class="operator">=</span> (UserAddrInfo) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equal(uid, that.uid) &amp;&amp;</span><br><span class="line">            Objects.equal(province, that.province) &amp;&amp;</span><br><span class="line">            Objects.equal(city, that.city) &amp;&amp;</span><br><span class="line">            Objects.equal(area, that.area) &amp;&amp;</span><br><span class="line">            Objects.equal(addrDetail, that.addrDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>hashCode – 只需要一行</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(uid, province, city, area, addrDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>toString</strong></p><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.toStringHelper(<span class="built_in">this</span>)</span><br><span class="line">            .add(<span class="string">&quot;uid&quot;</span>, uid)</span><br><span class="line">            .add(<span class="string">&quot;province&quot;</span>, province)</span><br><span class="line">            .add(<span class="string">&quot;city&quot;</span>, city)</span><br><span class="line">            .add(<span class="string">&quot;area&quot;</span>, area)</span><br><span class="line">            .add(<span class="string">&quot;addrDetail&quot;</span>, addrDetail)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h1 id="安装Intellij-IDEA插件"><a href="#安装Intellij-IDEA插件" class="headerlink" title="安装Intellij IDEA插件"></a>安装Intellij IDEA插件</h1><p>使用idea不久，边已经非常喜欢这款智能，友善的帮手了，下面总结下使用idea安装guava equals，hashCode，和 toString 自动生成代码的插件</p><ol><li><p><strong>可以插件搜索页面查询 equals 边可以找到该插件，下载安装即可</strong><br><img src="http://i.imgur.com/GXPBFOa.png"></p></li><li><p><strong>打开一个POJO ，键入 ALT + INS 就可以为POJO 生成equals 和 hashCode，toString</strong></p></li></ol><p><img src="http://i.imgur.com/cTrrw7z.png"></p><p>3.<strong>模板 选择guava</strong></p><p><img src="http://i.imgur.com/vlVfrAs.png"></p><p>设置完成，以后只要在POJO 类中，键入 <strong>ALT + INS</strong> 就可以自动生成guava风格的equals，hashCode，toString 方法了</p><p>guava 库优雅高效，要准备花时间掌握下了~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中按照in中的条件进行排序</title>
      <link href="/2016/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-1/"/>
      <url>/2016/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-1/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>实现一个排序的场景，需要按照list的id顺序进行排序，并管理到id对应的 用户信息<span id="more"></span></p></blockquote><blockquote><p>因为使用了sql 的in 方法，默认的排序是按照id的大小进行排序，经过百度，及尝试已经实现</p></blockquote><h3 id="order-by-field-u-uid-id1-id2-id3-指定的字段顺序排序"><a href="#order-by-field-u-uid-id1-id2-id3-指定的字段顺序排序" class="headerlink" title="order by field(u.uid,id1,id2,id3) 指定的字段顺序排序"></a>order by field(u.uid,id1,id2,id3) 指定的字段顺序排序</h3><ul><li><p>样例sql：</p><p>  SELECT</p><ul><li>  FROM<br>  tmp_a u<br>  LEFT JOIN tmp_b ui ON u.uid &#x3D; ui.uid<br>  WHERE<br>  u.id IN (<br>  1017117800,<br>  1081555602,<br>  1081360502<br>  )<br>  ORDER BY<br>  field(<br>  u.id,<br>  1017117800,<br>  1081555602,<br>  1081360502<br>  )</li></ul></li></ul><p>在此标记一下~ </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP相关总结</title>
      <link href="/2016/08/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2016/08/14/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/CAP%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="CAP理论概述"><a href="#CAP理论概述" class="headerlink" title="CAP理论概述"></a>CAP理论概述</h2><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/cap.jpg"><img src="http://www.hollischuang.com/wp-content/uploads/2015/12/cap.jpg" alt="cap"></a></p><h2 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h2><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>一致性指“<code>all nodes see the same data at the same time</code>”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<a href="http://www.hollischuang.com/archives/663">分布式的一致性</a></p><p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p><p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p><h3 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h3><p>可用性指“<code>Reads and writes always succeed</code>”，即服务一直可用，而且是正常响应时间。</p><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p><h3 id="Partition-Tolerance分区容错性"><a href="#Partition-Tolerance分区容错性" class="headerlink" title="Partition Tolerance分区容错性"></a>Partition Tolerance分区容错性</h3><p>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><h2 id="CAP的证明"><a href="#CAP的证明" class="headerlink" title="CAP的证明"></a>CAP的证明</h2><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/intro_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/intro_thumb.png" alt="intro_thumb"></a></p><p>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p>在满足一致性的时候，N1和N2中的数据是一样的，V0&#x3D;V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario1_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario1_thumb.png" alt="scenario1_thumb"></a></p><p>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p><p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario2_thumb.png"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/scenario2_thumb.png" alt="scenario2_thumb"></a></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据V0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h2 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h2><p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><blockquote><p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p><p>CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p></blockquote><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p><p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p><h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p><p>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p><h2 id="基本可用（Basically-Available）"><a href="#基本可用（Basically-Available）" class="headerlink" title="基本可用（Basically Available）"></a>基本可用（Basically Available）</h2><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p><p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p><h2 id="软状态（-Soft-State）"><a href="#软状态（-Soft-State）" class="headerlink" title="软状态（ Soft State）"></a>软状态（ Soft State）</h2><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p><h2 id="最终一致性（-Eventual-Consistency）"><a href="#最终一致性（-Eventual-Consistency）" class="headerlink" title="最终一致性（ Eventual Consistency）"></a>最终一致性（ Eventual Consistency）</h2><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><h1 id="ACID和BASE的区别与联系"><a href="#ACID和BASE的区别与联系" class="headerlink" title="ACID和BASE的区别与联系"></a>ACID和BASE的区别与联系</h1><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p><p>ACID和BASE代表了两种截然相反的设计哲学</p><p>在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中按照in中的条件进行排序</title>
      <link href="/2016/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20%E4%B8%AD%E6%8C%89%E7%85%A7in%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>今天在整合定时任务时，想要把所有的定时任务的执行时间放到配置文件properties文件中，方便管理及修改</p></blockquote><pre><code>    在spring mvc中，在配置文件中的东西，可以在java代码中通过注解进行读取了：</code></pre><ul><li>@PropertySource  在spring 3.1中开始引入</li></ul><h4 id="新建一个jobs-properties-文件"><a href="#新建一个jobs-properties-文件" class="headerlink" title="新建一个jobs.properties 文件"></a>新建一个jobs.properties 文件</h4><p><img src="http://i.imgur.com/tvc9ry9.png"> </p><h4 id="代码中添加-PropertySource"><a href="#代码中添加-PropertySource" class="headerlink" title="代码中添加 @PropertySource"></a>代码中添加 @PropertySource</h4><p><img src="http://i.imgur.com/XCMhVz1.png"></p><ul><li><p>要注意的是，要使用 </p><pre><code>  @Bean   public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() &#123;   return new PropertySourcesPlaceholderConfigurer();   &#125;</code></pre></li></ul><p>才能让spring正确解析出${} 中的值;</p><p>在spring 3.2中，允许支持多个properties了</p><pre><code>@Configuration      @PropertySource(&#123;          &quot;classpath:config.properties&quot;,          &quot;classpath:db.properties&quot; //如果是相同的key，则最后一个起作用      &#125;)      public class AppConfig &#123;          @Autowired          Environment env;      &#125;  </code></pre><p>spring 4.1中，支持@PropertySources</p><pre><code>@Configuration  @PropertySources(&#123;      @PropertySource(&quot;classpath:config.properties&quot;),      @PropertySource(&quot;classpath:db.properties&quot;)  &#125;)  public class AppConfig &#123;      //...  &#125; </code></pre><p>在spring 4.2中，</p><pre><code>&lt;/pre&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;@Configuration  @PropertySource(&quot;classpath:missing.properties&quot;)  public class AppConfig &#123;      //...  &#125;  </code></pre><p>如果发现missing.properties不存在，则抛出异常<br>，也可以使用ignoreResourceNotFound&#x3D;true去忽略 </p><pre><code>view plain copy 在CODE上查看代码片派生到我的代码片    @Configuration       @PropertySource(value=&quot;classpath:missing.properties&quot;, ignoreResourceNotFound=true)       public class AppConfig &#123;       //...       &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命名、设计及使用规范</title>
      <link href="/2016/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%E5%91%BD%E5%90%8D%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2016/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%E5%91%BD%E5%90%8D%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>最近对MySQL相关的规范，进行了整理<span id="more"></span></p></blockquote><h3 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h3><ul><li>dev：开发环境，开发可读写，可修改表结构。开发人员可以修改表结构，可以随意修改其中的数据但是需要保证不影响其他开发同事。</li><li>qa：测试环境，开发可读写，开发人员可以通过工具修改表结构。</li><li>sim：模拟环境，开发可读写，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用。</li><li>real：生产数据库从库（准实时同步），只读环境，不允许修改数据，不允许修改表结构，供线上问题查找，数据查询等使用。</li><li>online：线上环境，开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找DBA进行操作并进行相应记录，禁止进行压力测试。</li></ul><p>这些环境的机器，一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_account，r_ account 分别代表读、写账号，account是读写账号。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><h4 id="基本命名原则"><a href="#基本命名原则" class="headerlink" title="基本命名原则"></a>基本命名原则</h4><ul><li>使用有意义的英文词汇，词汇中间以下划线分隔。（不要用拼音）</li><li>只能使用英文字母，数字，下划线，并以英文字母开头。</li><li>库、表、字段全部采用小写，不要使用驼峰式命名。</li><li>避免用ORACLE、MySQL的保留字，如desc，关键字如index。</li><li>命名禁止超过32个字符，须见名之意，建议使用名词不是动词</li><li>数据库，数据表一律使用前缀:<ul><li>临时库、表名必须以tmp为前缀，并以日期为后缀</li><li>备份库、表必须以bak为前缀，并以日期为后缀</li></ul></li></ul><p>为什么库、表、字段全部采用小写？</p><p>在 MySQL 中，数据库和表对就于那些目录下的目录和文件。因而，操作系统的敏感性决定数据库和表命名的大小写敏感。</p><ul><li>Windows下是不区分大小写的。</li><li>Linux下大小写规则：<ul><li>数据库名与表名是严格区分大小写的；</li><li>表的别名是严格区分大小写的；</li><li>列名与列的别名在所有的情况下均是忽略大小写的；</li><li>变量名也是严格区分大小写的；</li></ul></li></ul><p>如果已经设置了驼峰式的命名如何解决？需要在MySQL的配置文件my.ini中增加 lower_case_table_names &#x3D; 1即可。</p><ul><li>表命名</li></ul><p>同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。所有日志表均以 log_ 开头</p><h4 id="字段命名"><a href="#字段命名" class="headerlink" title="字段命名"></a>字段命名</h4><ul><li>表达其实际含义的英文单词或简写。布尔意义的字段以“is_”作为前缀，后接动词过去分词。</li><li>各表之间相同意义的字段应同名。各表之间相同意义的字段，以去掉模块前缀的表名_字段名命名。</li><li>外键字段用表名_字段名表示其关联关系。</li><li>表的主键一般都约定成为id，自增类型，是别的表的外键均使用xxx_id的方式来表明。</li></ul><h4 id="索引命名"><a href="#索引命名" class="headerlink" title="索引命名"></a>索引命名</h4><ul><li>非唯一索引必须按照“idx_字段名称_字段名称[_字段名]”进行命名</li><li>唯一索引必须按照“uniq_字段名称_字段名称[_字段名]”进行命名</li></ul><h4 id="约束命名"><a href="#约束命名" class="headerlink" title="约束命名"></a>约束命名</h4><ul><li>主键约束：pk_表名称。</li><li>唯一约束：uk_表名称_字段名。（应用中需要同时有唯一性检查逻辑。）</li></ul><h4 id="触发器命名"><a href="#触发器命名" class="headerlink" title="触发器命名"></a>触发器命名</h4><ul><li>trg_表名_操作。</li></ul><h4 id="函数过程命名"><a href="#函数过程命名" class="headerlink" title="函数过程命名"></a>函数过程命名</h4><ul><li>采用动词+名词的形式表达其含义。</li></ul><h4 id="序列命名"><a href="#序列命名" class="headerlink" title="序列命名"></a>序列命名</h4><ul><li>seq_表名</li></ul><h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><p>1、表引擎取决于实际应用场景；日志及报表类表建议用myisam，与交易，审核，金额相关的表建议用innodb引擎。如无说明，建表时一律采用innodb引擎。myisam与innodb的区别</p><p>2、默认使用utf8mb4字符集，数据库排序规则使用utf8mb4_general_ci，（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上）。</p><p>为什么字符集不选择utf8，排序规则不使用utf8_general_ci？<br>采用utf8编码的MySQL无法保存占位是4个字节的Emoji表情。为了使后端的项目，全面支持客户端输入的Emoji表情，升级编码为utf8mb4是最佳解决方案。对于JDBC连接串设置了characterEncoding为utf8或者做了上述配置仍旧无法正常插入emoji数据的情况，需要在代码中指定连接的字符集为utf8mb4。</p><p>3、所有表、字段均应用 comment 列属性来描述此表、字段所代表的真正含义，如枚举值则建议将该字段中使用的内容都定义出来。</p><p>4、如无说明，表中的第一个id字段一定是主键且为自动增长，禁止在非事务内作为上下文作为条件进行数据传递。禁止使用varchar类型作为主键语句设计。</p><p>5、如无说明，表必须包含create_time和modify_time字段，即表必须包含记录创建时间和修改时间的字段</p><p>6、如无说明，表必须包含is_del，用来标示数据是否被删除，原则上数据库数据不允许物理删除。</p><p>7、用尽量少的存储空间来存数一个字段的数据</p><ul><li>能用int的就不用char或者varchar</li><li>能用tinyint的就不用int</li><li>使用UNSIGNED存储非负数值。</li><li>不建议使用ENUM、SET类型，使用TINYINT来代替</li><li>使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED</li><li>存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE</li><li>时间字段，除特殊情况一律采用int来记录unix_timestamp</li><li>存储年使用YEAR类型。</li><li>存储日期使用DATE类型。</li><li>存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。</li><li>建议使用INT UNSIGNED存储IPV4。</li><li>尽可能不使用TEXT、BLOB类型</li><li>禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。建议使用其他方式存储（TFS&#x2F;SFS），MySQL只保存指针信息。</li><li>单条记录大小禁止超过8k（列长度(中文)*3(UTF8)+列长度(英文)*1）</li></ul><h4 id="datetime与timestamp有什么不同？"><a href="#datetime与timestamp有什么不同？" class="headerlink" title="datetime与timestamp有什么不同？"></a>datetime与timestamp有什么不同？</h4><p>相同点：TIMESTAMP列的显示格式与DATETIME列相同。显示宽度固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。<br>不同点：</p><ul><li><p>TIMESTAMP</p></li><li><p>4个字节储存，时间范围：1970-01-01 08:00:01 ~ 2038-01-19 11:14:07</p></li><li><p>值以UTC格式保存，涉及时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。</p></li><li><p>datetime  </p></li><li><p>8个字节储存，时间范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p></li><li><p>实际格式储存，与时区无关</p></li></ul><h4 id="如何使用TIMESTAMP的自动赋值属性？"><a href="#如何使用TIMESTAMP的自动赋值属性？" class="headerlink" title="如何使用TIMESTAMP的自动赋值属性？"></a>如何使用TIMESTAMP的自动赋值属性？</h4><ul><li>将当前时间作为ts的默认值：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP。</li><li>当行更新时，更新ts的值：ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP。</li><li>可以将1和2结合起来：ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP。</li></ul><h4 id="如何使用INT-UNSIGNED存储ip？"><a href="#如何使用INT-UNSIGNED存储ip？" class="headerlink" title="如何使用INT UNSIGNED存储ip？"></a>如何使用INT UNSIGNED存储ip？</h4><p>使用INT UNSIGNED而不是char(15)来存储ipv4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。</p><p>8、如无备注，所有字段都设置NOT NULL，并设置默认值；</p><p>9、禁止在数据库中存储明文密码</p><p>10、如无备注，所有的布尔值字段，如is_hot、is_deleted，都必须设置一个默<br>认值，并设为0；</p><p>11、如无备注，排序字段order_id在程序中默认使用降序排列；</p><p>12、整形定义中不添加长度，比如使用INT，而不是INT[4]</p><h4 id="INT-M-，M值代表什么含义？"><a href="#INT-M-，M值代表什么含义？" class="headerlink" title="INT[M]，M值代表什么含义？"></a>INT[M]，M值代表什么含义？</h4><p>注意数值类型括号后面的数字只是表示宽度而跟存储范围没有关系。很多人他们认为INT(4)和INT(10)其取值范围分别是 (-9999到9999)和(-9999999999到9999999999)，这种理解是错误的。其实对整型中的 M值与 ZEROFILL 属性结合使用时可以实现列值等宽。不管INT[M]中M值是多少，其取值范围还是 (-2147483648到2147483647 有符号时)，(0到4294967295无符号时)。<br>显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。当结合可选扩展属性ZEROFILL使用时默认补充的空格用零代替。例如：对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度，如果为一个数值列指定ZEROFILL, MySQL自动为该列添加UNSIGNED属性。</p><p>13、使用VARBINARY存储大小写敏感的变长字符串</p><h4 id="什么时候用CHAR，什么时候用VARCHAR？"><a href="#什么时候用CHAR，什么时候用VARCHAR？" class="headerlink" title="什么时候用CHAR，什么时候用VARCHAR？"></a>什么时候用CHAR，什么时候用VARCHAR？</h4><p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。例如，CHAR- (30)可以占用30个字符。</p><ul><li>CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索<br>过程中不进行大小写转换。</li><li>VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。</li></ul><p>同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。</p><p>char适合存储用户密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar,因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。char(1)字符串对于单字节字符集只会占用一个字节，但是varchar(1)则会占用2个字节，因为1个字节用来存储长度信息。</p><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><p>MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作），不合理的索引会降低速度。MySQL索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当MySQL查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的IO。索引的用途：去重、加速定位、避免排序、覆盖索引。</p><h4 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h4><p>InnoDB存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。比如SELECT email,uid FROM user_email WHERE uid&#x3D;xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升。</p><h4 id="索引的基本规范"><a href="#索引的基本规范" class="headerlink" title="索引的基本规范"></a>索引的基本规范</h4><p>1、索引数量控制，单张表中索引数量不超过5个，单个索引中的字段数不超过5个。</p><ul><li>综合评估数据密度和分布</li><li>考虑查询和更新比例</li></ul><h4 id="为什么一张表中不能存在过多的索引？"><a href="#为什么一张表中不能存在过多的索引？" class="headerlink" title="为什么一张表中不能存在过多的索引？"></a>为什么一张表中不能存在过多的索引？</h4><p>InnoDB的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。</p><p>2、对字符串使用前缀索引，前缀索引长度不超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引。</p><ul><li>不要索引blob&#x2F;text等字段,不要索引大型字段,这样做会让索引占用太多的存储空间</li></ul><h4 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h4><p>前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。</p><p>建立前缀索引的语法：ALTER TABLE table_name ADD KEY(column_name(prefix_length));</p><p>3、主键准则</p><ul><li>表必须有主键</li><li>不使用更新频繁的列</li><li>尽量不选择字符串列</li><li>不使用UUID MD5 HASH</li><li>默认使用非空的唯一键</li><li>建议选择自增或发号器</li></ul><p>4、 重要的SQL必须被索引，核心SQL优先考虑覆盖索索引</p><ul><li>UPDATE、DELETE语句的WHERE条件列</li><li>ORDER BY、GROUP BY、DISTINCT的字段</li><li>多表JOIN的字段</li></ul><p>5、区分度最大的字段放在前面</p><ul><li>选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面</li><li>索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引,(a,c)作为条件的时候只能使用到a列索引,所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理,(b,c)则不能走索引</li><li>合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)</li></ul><p>6、索引禁忌</p><ul><li>不在低基数列上建立索引，例如“性别”</li><li>不在索引列进行数学运算和函数运算</li><li>不要索引常用的小型表</li></ul><p>7、 尽量不使用外键</p><ul><li>外键用来保护参照完整性，可在业务端实现</li><li>对父表和子表的操作会相互影响，降低可用性</li><li>INNODB本身对online DDL的限制</li></ul><h4 id="MYSQL-中索引的限制"><a href="#MYSQL-中索引的限制" class="headerlink" title="MYSQL 中索引的限制"></a>MYSQL 中索引的限制</h4><ul><li>MYISAM 存储引擎索引长度的总和不能超过 1000 字节</li><li>BLOB 和 TEXT 类型的列只能创建前缀索引</li><li>MYSQL 目前不支持函数索引</li><li>使用不等于 (!&#x3D; 或者 &lt;&gt;) 的时候, MYSQL 无法使用索引。</li><li>过滤字段使用函数运算 (如 abs (column)) 后, MYSQL无法使用索引。</li><li>join语句中join条件字段类型不一致的时候MYSQL无法使用索引</li><li>使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引。</li><li>使用非等值查询的时候, MYSQL 无法使用 Hash 索引。</li></ul><h4 id="语句设计规范"><a href="#语句设计规范" class="headerlink" title="语句设计规范"></a>语句设计规范</h4><p>1、使用预编译语句</p><ul><li>只传参数，比传递SQL语句更高效</li><li>一次解析，多次使用</li><li>降低SQL注入概率</li></ul><p>2、避免隐式转换</p><ul><li>会导致索引失效</li></ul><p>3、充分利用前缀索引</p><ul><li>必须是最左前缀</li><li>不可能同时用到两个范围条件</li><li>不使用%前导的查询，如like “%ab”</li></ul><p>4、不使用负向查询，如not in&#x2F;like</p><ul><li>无法使用索引，导致全表扫描</li><li>全表扫描导致buffer pool利用率降低</li></ul><p>5、避免使用存储过程、触发器、UDF、events等</p><ul><li>让数据库做最擅长的事</li><li>降低业务耦合度，为sacle out、sharding留有余地</li><li>避开BUG</li></ul><p>6、避免使用大表的JOIN</p><ul><li>MySQL最擅长的是单表的主键&#x2F;二级索引查询</li><li>JOIN消耗较多内存，产生临时表</li></ul><p>7、避免在数据库中进行数学运算</p><ul><li>MySQL不擅长数学运算和逻辑判断</li><li>无法使用索引</li></ul><p>8、减少与数据库的交互次数</p><ul><li>INSERT … ON DUPLICATE KEY UPDATE</li><li>REPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),()</li><li>UPDATE … WHERE ID IN(10,20,50,…)</li></ul><p>9、合理的使用分页</p><ul><li>限制分页展示的页数</li><li>只能点击上一页、下一页</li><li>采用延迟关联</li></ul><h4 id="如何正确的使用分页？"><a href="#如何正确的使用分页？" class="headerlink" title="如何正确的使用分页？"></a>如何正确的使用分页？</h4><p>假如有类似下面分页语句：SELECT * FROM table  ORDER BY id LIMIT 10000, 10<br>由于MySQL里对LIMIT OFFSET的处理方式是取出OFFSET+LIMIT的所有数据，然后去掉OFFSET，返回底部的LIMIT。所以，在OFFSET数值较大时，MySQL的查询性能会非常低。可以使用id &gt; n 的方式进行解决：<br>使用id &gt; n 的方式有局限性，对于id不连续的问题，可以通过翻页的时候同时传入最后一个id方式来解决。</p><pre><code>    //输出时，找出当前结果集中的最大最小id       //下一页       http://example.com/page.php?last=100       select * from table where id&lt;100 order by id desc limit 10       //上一页       http://example.com/page.php?first=110       select * from table where id&gt;110 order by id desc limit 10</code></pre><p>这种方式比较大的缺点是，如果在浏览中有插入&#x2F;删除操作，翻页不会更新，而总页数可能仍然是根据新的count(*) 来计算，最终可能会产生某些记录访问不到。为了修补这个问题，可以继续引入当前页码以及在上次翻页以后是否有插入&#x2F;删除等影响总记录数的操作并进行缓存</p><pre><code>    select * from table where id &gt;= (select id from table order by id limit #offset#, 1)</code></pre><p>9、拒绝大SQL，拆分成小SQL</p><ul><li>充分利用QUERY CACHE</li><li>充分利用多核CPU</li></ul><p>10、使用in代替or，in的值不超过1000个</p><p>11、禁止使用order by rand()</p><p>12、使用EXPLAIN诊断，避免生成临时表</p><p>EXPLAIN语句（在MySQL客户端中执行）可以获得MySQL如何执行SELECT语句的信息。通过对SELECT语句执行EXPLAIN，可以知晓MySQL执行该SELECT语句时是否使用了索引、全表扫描、临时表、排序等信息。尽量避免MySQL进行全表扫描、使用临时表、排序等。详见官方文档。</p><p>13、用union all而不是union</p><h4 id="union-all与-union有什么区别？"><a href="#union-all与-union有什么区别？" class="headerlink" title="union all与 union有什么区别？"></a>union all与 union有什么区别？</h4><p>union和union all关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。</p><p>union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。如：</p><pre><code>    select * from test_union1        union        select * from test_union2</code></pre><p>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而union all只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。<br>从效率上说，union all要比union快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用union all，如下：</p><pre><code>    select * from test_union1        union all        select * from test_union2</code></pre><p>14、程序应有捕获SQL异常的处理机制</p><p>15、禁止单条SQL语句同时更新多个表</p><p>16、不使用select * ，SELECT语句只获取需要的字段</p><p>消耗CPU和IO、消耗网络带宽<br>无法使用覆盖索引<br>减少表结构变更带来的影响<br>因为大，select&#x2F;join 可能生成临时表</p><p>17、UPDATE、DELETE语句不使用LIMIT</p><p>18、INSERT语句必须显式的指明字段名称，不使用INSERT INTO table()</p><p>19、INSERT语句使用batch提交（INSERT INTO table VALUES(),(),()……），values的个数不超过500</p><p>20、统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1) 备注：仅针对Myisam</p><p>21、数据更新建议使用二级索引先查询出主键，再根据主键进行数据更新</p><p>22、禁止使用跨库查询</p><p>23、禁止使用子查询，建议将子查询转换成关联查询</p><p>24、针对varchar类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p><h3 id="分表规范"><a href="#分表规范" class="headerlink" title="分表规范"></a>分表规范</h3><p>单表一到两年内数据量超过500w或数据容量超过10G考虑分表，需提前考虑历史数据迁移或应用自行删除历史数据，采用等量均衡分表或根据业务规则分表均可。要分表的数据表必须与DBA商量分表策略</p><p>用HASH进行散表，表名后缀使用十进制数，下标从0开始<br>按日期时间分表需符合YYYY[MM][DD][HH]格式<br>采用合适的分库分表策略。例如千库十表、十库百表等<br>禁止使用分区表，分区表对分区键有严格要，分区表在表变大后执行DDL、SHARDING、单表恢复等都变得更加困难。<br>拆分大字段和访问频率低的字段，分离冷热数据</p><h3 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h3><ul><li>批量导入、导出数据必须提前通知DBA协助观察</li><li>禁止在线上从库执行后台管理和统计类查询</li><li>禁止有super权限的应用程序账号存在</li><li>产品出现非数据库导致的故障时及时通知DBA协助排查</li><li>推广活动或上线新功能必须提前通知DBA进行流量评估</li><li>数据库数据丢失，及时联系DBA进行恢复</li><li>对单表的多次alter操作必须合并为一次操作</li><li>不在MySQL数据库中存放业务逻辑</li><li>重大项目的数据库方案选型和设计必须提前通知DBA参与</li><li>对特别重要的库表，提前与DBA沟通确定维护和备份优先级</li><li>不在业务高峰期批量更新、查询数据库其他规范</li><li>提交线上建表改表需求，必须详细注明所有相关SQL语句</li><li>其他规范</li></ul><p>日志类数据不建议存储在MySQL上，优先考虑Hbase或OceanBase，如需要存储请找DBA评估使用压缩表存储。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·常用命令记录</title>
      <link href="/2016/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2016/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-笔记"><a href="#MongoDB-笔记" class="headerlink" title="MongoDB 笔记"></a>MongoDB 笔记</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1 查询所有存在的数据库</p><pre><code>show dbs</code></pre><p>2 进入数据库</p><pre><code>use admin</code></pre><p>3 查看所有的collection集合</p><pre><code>show collections    </code></pre><p>4 增加或修改密码</p><pre><code>db.addUser(&#39;userTest&#39;,&#39;123456&#39;)db.addUser(&quot;userTest&quot;,&quot;123456&quot;,true) 参数分别为 用户名、密码、是否只读</code></pre><p>5 查看用户列表</p><pre><code>db.system.users.find()</code></pre><p>6 用户认证</p><pre><code>db.auth(&#39;userTest&#39;,&#39;123456&#39;)</code></pre><p>7 删除用户</p><pre><code>db.removeUser(&#39;userTest&#39;)</code></pre><p>8 查看所有用户</p><pre><code>show users</code></pre><p>9 查看各个collection的状态</p><pre><code>db.printCollectionStats()</code></pre><p>10 查看主从复制状态</p><pre><code>db.printReplicationInfo()</code></pre><p>11 修复数据库</p><pre><code>db.repairDatabase()</code></pre><p>12 设置profiling,0:off 1:slow 2 all</p><pre><code>db.setProfilingLevel(1)</code></pre><p>13 查看profiling</p><pre><code>show profiling</code></pre><p>14 拷贝数据库</p><pre><code>db.copyDatabase(&#39;userTest&#39;,&#39;userTest1&#39;)db.copyDatabase(&quot;userTest&quot;,&quot;temp&quot;,&quot;127.0.0.1&quot;)</code></pre><p>15 删除集合collection</p><pre><code>db.userTest.drop()</code></pre><p>16 删除当前数据库</p><pre><code>db.dropDatabase()</code></pre><hr><h2 id="MongoDB增删改命令"><a href="#MongoDB增删改命令" class="headerlink" title="MongoDB增删改命令"></a>MongoDB增删改命令</h2><p>1 存储数据</p><pre><code>    db.collection.insert(&#123;&#39;name&#39;:&#39;userTest&#39;&#125;)        db.collection.save(&#123;&#39;age&#39;:18&#125;)</code></pre><p>1 存储嵌套的对象</p><pre><code>    db.foo.save(&#123;&#39;name&#39;:&#39;userTest&#39;,&#39;age&#39;:25,&#39;address&#39;:&#123;&#39;city&#39;:&#39;changchun&#39;,&#39;Province&#39;:&#39;Jilin&#39;&#125;&#125;)</code></pre><p>2 存储数组对象</p><pre><code>    db.foo.save(&#123;&#39;name&#39;:userTest,&#39;age&#39;:25,&#39;address&#39;:[&#39;Jilin Province&#39;,&#39;Liaoning Province&#39;]&#125;)</code></pre><p>3 根据query条件修改，如果不存在则插入，允许修改多条记录</p><pre><code>    db.foo.update(&#123;&#39;age&#39;:&#39;25&#39;&#125;,&#123;&#39;$set&#39;:&#123;&#39;name&#39;:&#39;userTest&#39;&#125;&#125;,upsert=true,multi=true)</code></pre><p>4 删除yy&#x3D;5的记录</p><pre><code>    db.foo.remove(&#123;&#39;name&#39;:&#39;userTest&#39;&#125;)</code></pre><p>5 删除所有的记录</p><pre><code>    db.foo.remove()    </code></pre><p>6 去掉某个字段 <code>$unset</code></p><pre><code>  db.users.update(&#123;&#125;,&#123;&#39;$unset&#39;:&#123;&#39;age&#39;:1&#125;&#125;,false,true);    </code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>1 增加索引:1 asc -1 desc</p><pre><code>db.foo.ensureIndex(&#123;firstname:1,lastname:-1&#125;,&#123;unieap:true&#125;)</code></pre><p>2 索引子对象</p><pre><code>db.foo.ensureIndex(&#123;&#39;Al.Em&#39;:!&#125;)</code></pre><p>3 查看索引信息</p><pre><code>db.foo.getIndexes()db.foo.getIndexKeys()</code></pre><p>4 根据索引名删除索引</p><pre><code>db.foo.dropIndex(&#39;Al.Em_1&#39;)</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code>$gt ---- &gt;$lt ---- &lt;$gte ---- &gt;=$lte ---- &lt;=$ne ---- != 、&lt;&gt;$in ---- in$nin ---- not in$all ---- all$or ---- or$not ---- 反匹配</code></pre><p>1 查询所有记录</p><pre><code>db.foo.find() ---- select * from foo</code></pre><p>2 查询某列非重复的记录</p><pre><code>db.foo.distinct(&quot;userTest&quot;) ---- select distinct name from foo</code></pre><p>3 查询age &#x3D; 22 的记录</p><pre><code>db.foo.find(&#123;&quot;age&quot;:22&#125;) ---- select * from foo where age = 22</code></pre><p>4 查询age &gt; 22 的记录</p><pre><code>db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;) ---- select * from foo where age &gt; 22</code></pre><p>5 查询age &lt; 22 的记录</p><pre><code>db.foo.find(&#123;age:&#123;$lt:22&#125;&#125;) ---- select * from foo where age &lt; 22</code></pre><p>6 查询age &lt;&#x3D; 25的记录</p><pre><code>db.foo.find(&#123;age:&#123;$lte:25&#125;&#125;)</code></pre><p>7 查询age &gt;&#x3D; 23 并且 age &lt;&#x3D;26的记录</p><pre><code>db.foo.find(&#123;age:&#123;gte:23,lte:26&#125;&#125;)</code></pre><p>8 查询name中包含userTest的数据</p><pre><code>db.foo.find(&#123;name:/userTest/&#125;) ---- select * from foo where name like &#39;%userTest%&#39;</code></pre><p>9 查询name中以userTest开头的数据</p><pre><code>db.foo.find(&#123;name:/^userTest/&#125;) ---- select * from foo where name like &#39;userTest%&#39;</code></pre><p>10 查询指定列name、age的数据</p><pre><code>db.foo.find(&#123;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo</code></pre><p>11 查询制定列name、age数据，并且age &gt; 22</p><pre><code>db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo where age &gt;22</code></pre><p>12 按照年龄排序</p><ul><li>升序：db.foo.find().sort({age:1})  降序：db.foo.find().sort({age:-1})</li></ul><p>13 查询name&#x3D;userTest.age&#x3D;25的数据</p><pre><code>db.foo.find(&#123;name:&#39;userTest&#39;,age:22&#125;) ---- select * from foo where name=&#39;userTest&#39; and age =&#39;25&#39;</code></pre><p>14 查询前5条数据</p><pre><code>db.foo.find().limit(5) ---- select top 5 * from foo</code></pre><p>15 查询10条以后的数据</p><pre><code>db.foo.find().skip(10) ---- select * from foo where id not in (select top 10 * from foo);</code></pre><p>16 查询在5-10之间的数据</p><pre><code>db.foo.find().limit(10).skip(5) </code></pre><p>17 or与查询</p><pre><code>db.foo.find(&#123;$or:[&#123;age:22&#125;,&#123;age:25&#125;]&#125;) ---- select * from foo where age=22 or age =25</code></pre><p>18 查询第一条数据</p><pre><code>db.foo.findOne() 、db.foo.find().limit(1)---- select top 1 * from foo</code></pre><p>19 查询某个结果集的记录条数</p><pre><code>db.foo.find(&#123;age:&#123;$gte:25&#125;&#125;).count() ---- select count(*) from foo where age &gt;= 20</code></pre><p>20 按照某列进行排序</p><pre><code>db.foo.find(&#123;sex:&#123;$exists:true&#125;&#125;).count() ---- select count(sex) from foo</code></pre><p>21 查询age取模10等于0的数据</p><pre><code>db.foo.find(&#39;this.age % 10 == 0&#39;)、db.foo.find(&#123;age:&#123;$mod:[10,0]&#125;&#125;)</code></pre><p>22 匹配所有</p><pre><code>db.foo.find(&#123;age:&#123;$all:[22,25]&#125;&#125;)</code></pre><p>23 查询不匹配name&#x3D;X*带头的记录</p><pre><code>db.foo.find(&#123;name:&#123;$not:/^X.*/&#125;&#125;)</code></pre><p>24 排除返回age字段</p><pre><code>db.foo.find(&#123;name:&#39;userTest&#39;&#125;,&#123;age:0&#125;)</code></pre><p>25 判断字段是否存在</p><pre><code>db.foo.find(&#123;name:&#123;$exists:true&#125;&#125;)    </code></pre><p>26 查询两个字段值相同的记录</p><pre><code>db.foo.find(&#123;$where:&quot;this.bluid==this.seqid&quot;&#125;).count();</code></pre><h3 id="MongoDB下根据数组大小进行查询的方法"><a href="#MongoDB下根据数组大小进行查询的方法" class="headerlink" title="MongoDB下根据数组大小进行查询的方法"></a>MongoDB下根据数组大小进行查询的方法</h3><p>1.测试数据</p><pre><code>db.array_test.insert(&#123;name:&#39;a&#39;, num:[11,22,33,44,55]&#125;);db.array_test.insert(&#123;name:&#39;b&#39;, num:[111,222]&#125;);db.array_test.insert(&#123;name:&#39;c&#39;, num:[1111]&#125;);db.array_test.insert(&#123;name:&#39;d&#39;, num:[2222]&#125;);</code></pre><ol><li><p><code>$size</code> 查询指定大小的数据</p><p> db.array_test.find({num:{$size:2}})</p></li></ol><ul><li><p>注意：$size 无法查询某个范围的大小，例如下面的语句是无法按照预期运行的：</p><p>  db.array_test.find({num:{$size:{$gt:3}}}); &#x2F;&#x2F;错误</p></li></ul><p>官方文档中建议，如果需要查询的数组大小在某个范围，可以另外为每个文档添加一个键来保存当前数组的大小。</p><p>2.其他思路：</p><p>   使用$where，例如如果要求数组大小小于3：</p><pre><code>db.array_test.find(&#123; $where: &quot;this.num.length &lt; 3&quot; &#125;).pretty()这种方法具有很大的灵活性，但是速度会慢一些。</code></pre><p>另外一个比较高效的方法是判断数组中的某个指定索引的元素是否存在，例如如果要求数组大小小于3：</p><pre><code>db.array_test.find(&#123; &quot;num.2&quot;: &#123;$exists:0&#125; &#125;)数组大小小于3，也就是num[2]不存在。db.array_test.find(&#123; &quot;num.3&quot;: &#123;$exists:1&#125; &#125;)数据大于等于 3</code></pre><h3 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h3><p>1 分组查询</p><pre><code>    db.users.aggregate([    &#123;$match : &#123;&#39;_created&#39;:&#123;&#39;$gte&#39;: ISODate(&#39;2017-04-01 0:0:0&#39;)&#125;&#125;&#125;,    &#123;$group : &#123;_id : &quot;$channel&quot;, channel_count:&#123;$sum:1&#125;&#125;&#125;,    &#123;$sort:&#123;channel_count:-1&#125;&#125;    ]);    </code></pre><p>2 多次分组查询</p><pre><code>    db.logins.aggregate([    &#123;&#39;$match&#39;: &#123;&#39;operate&#39;: &#39;get_token&#39;&#125;&#125;,     &#123;&#39;$group&#39;: &#123;&#39;_id&#39;: &#123;&#39;userId&#39;: &#39;$user_id&#39;, &#39;brand&#39;: &#39;$brand&#39;, &#39;deviceType&#39;: &#39;$src&#39;&#125;&#125;&#125;,     &#123;&#39;$group&#39;: &#123;&#39;_id&#39;: &#123;&#39;brand&#39;: &#39;$_id.brand&#39;, &#39;deviceType&#39;: &#39;$_id.deviceType&#39;&#125;, &#39;num&#39;: &#123;&#39;$sum&#39;: 1&#125;&#125;&#125;,     &#123;&#39;$sort&#39;: &#123;&#39;_id.deviceType&#39;: -1, &#39;num&#39;: -1&#125;&#125;,     &#123;&#39;$limit&#39;: 20&#125;]);</code></pre><h3 id="各种更新操作"><a href="#各种更新操作" class="headerlink" title="各种更新操作"></a>各种更新操作</h3><ul><li><p>更新语法</p><pre><code>  db.collection.update(criteria, objNew, upsert, multi )</code></pre></li><li><p>criteria:update的查询条件，类似sql update查询内where后面的</p></li><li><p>objNew:update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。</p></li><li><p>upsert : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</p></li><li><p>multi : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</p></li></ul><p>1 修改字段数据类型语法</p><ul><li><p><a href="https://docs.mongodb.com/manual/reference/operator/query/type/">MongoDB 数据类型</a></p><pre><code>  db.users.find(&#123;&quot;recv&quot;:&#123;$type:2&#125;&#125;).forEach(             function(x)&#123;                 x.recv=new NumberLong(x.recv);                 db.users.save(x);             &#125;        );</code></pre></li></ul><p>2 mongodb 更新一个字段的值为另外一个字段的值</p><pre><code>    db.users.find(&#123;&#39;client.src&#39;:2&#125;).forEach(       function(item)&#123;                            db.users.update(&#123;&quot;_id&quot;:item._id&#125;,&#123;&quot;$set&quot;:&#123;&quot;client.deviceName&quot;:item.client.sysDesc&#125;&#125;,false,true)         &#125;    )</code></pre><p>3 mongoDB 同步collection从一个数据库到另一个数据库中</p><ul><li><p>new_database是目的数据库</p><pre><code>  db.&lt;collection_name&gt;.find().forEach(function(d)&#123; db.getSiblingDB(&#39;&lt;new_database&gt;&#39;)[&#39;&lt;collection_name&gt;&#39;].insert(d); &#125;);</code></pre></li></ul><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>1 查看collection数据大小</p><pre><code>db.userTest.dataSize()</code></pre><p>2 查看collection状态</p><pre><code>db.userTest.stats()</code></pre><p>3 查询所有索引的大小</p><pre><code>db.userTest.totalIndexSize()</code></pre><h3 id="mongoDB关于数据库的操作"><a href="#mongoDB关于数据库的操作" class="headerlink" title="mongoDB关于数据库的操作"></a>mongoDB关于数据库的操作</h3><h4 id="User相关的基本操作："><a href="#User相关的基本操作：" class="headerlink" title="User相关的基本操作："></a>User相关的基本操作：</h4><pre><code>    &gt; show users　　　　　　　　　　　　　　　　　       ------查看所有用户    &gt; db.system.users.find()　　　　　　　　　　　　　　------查看用户列表    &gt; db.addUser(&#39;name&#39;,&#39;pwd&#39;)　　　　　　                     ------增加或修改用户密码    &gt; db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true)　　　　　 ------添加用户、设置密码、是否只读    &gt; db.auth(&quot;userName&quot;, &quot;123123&quot;)　　　　　　            ------数据库认证、安全模式    &gt; db.removeUser(&#39;name&#39;)　　　　　　                         ------根据用户名删除用户</code></pre><h4 id="Database相关的基本操作："><a href="#Database相关的基本操作：" class="headerlink" title="Database相关的基本操作："></a>Database相关的基本操作：</h4><pre><code>    &gt; show dbs                                                                           ------查看所有数据库    &gt; use [db-name]                                                                  ------当创建一个集合(table)的时候会自动创建当前数据库，这个指令相当于mysql的use [database-name]    &gt; db.dropDatabase()                                                          ------删除当前的数据库    &gt; db.repairDatabase()                                                        ------修复数据库    &gt; db.copyDatabase(&#39;mail_addr&#39;,&#39;mail_addr_tmp&#39;)         -----拷贝数据库    &gt; db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;)          ------将本机的mydb的数据复制到temp数据库中    &gt; db.cloneDatabase(“127.0.0.1”)                                     ------将指定机器上的数据库的数据克隆到当前数据库    </code></pre><h4 id="Collection相关的基本操作："><a href="#Collection相关的基本操作：" class="headerlink" title="Collection相关的基本操作："></a>Collection相关的基本操作：</h4><pre><code>    &gt; show collections                                                             ------查看所有的集合     &gt; db.printReplicationInfo()　                                            ------查看主从复制状态    &gt; db.mail_addr.drop()　                                                    ------删除collection(mail_addr 是collections的名字)    &gt; db.createCollection(“collectionName”, &#123;size: 20, capped: 5, max: 100&#125;)            ------创建一个聚集集合    &gt; db.getCollection(&quot;account&quot;)                                        ------得到指定名称的聚集集合    &gt; db.getCollectionNames()                                             ------得到当前db的所有聚集集合    &gt; db.printCollectionStats()                                              ------查看各collection的状态    其它：    &gt; db.getPrevError()                                                          ------查询之前的错误信息    &gt; db.resetError()                                                               ------清除错误记录        </code></pre><h4 id="查看聚集集合的基本信息"><a href="#查看聚集集合的基本信息" class="headerlink" title="查看聚集集合的基本信息"></a>查看聚集集合的基本信息</h4><pre><code>    &gt; db.test.count();     　　　　　　　　　　　　　------查询当前集合的数据条数    &gt; db.test.dataSIze();                                                   ------查询数据空间大小    &gt; db.test.getDB();                                                       ------得到当前聚集集合所在的database    &gt; db.test.stats();                                                          ------得到当前聚集的状态    &gt; db.test.totalSize();　                                               ------得到聚集集合总大小    &gt; db.test.storageSize();                                             ------得到聚集集合储存空间大小    &gt; db.test.getShardVersion();                                    ------Shard版本信息    &gt; db.test.renameCollection(&quot;users&quot;);                     ------将集合test重名为users    &gt; db.test.drop();                                                          ------删除当前聚集集合</code></pre><h4 id="mongoDB数据的导入和导出"><a href="#mongoDB数据的导入和导出" class="headerlink" title="mongoDB数据的导入和导出"></a>mongoDB数据的导入和导出</h4><pre><code>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。    　　    　　</code></pre><ul><li><p>命令选项说明:　</p><pre><code>  　　  -h:指明数据库宿主机的IP  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字  -f:指明要导出那些列  -o:指明到要导出的文件名  -q:指明导出数据的过滤条件</code></pre></li></ul><p>demo </p><pre><code>本地        mongoexport -d bludb -c resources -o resources.json --type json        远程mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库名 -c collections名称 -o resources.json --type json</code></pre><p>远程<br>mongoexport -h IP –port 端口 -u 用户名 -p 密码 -d 数据库名 -c collections名称 -o resources.json –type json</p><h4 id="Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据"><a href="#Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据" class="headerlink" title="Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据"></a>Mongodb中的mongoimport工具可以把一个特定格式文件中的内容导入到指定的collection中。该工具可以导入JSON格式数据，也可以导入CSV格式数据</h4><pre><code>　导入命令选项说明:　      -h:指明数据库宿主机的IP    -u:指明数据库的用户名    -p:指明数据库的密码    -d:指明数据库的名字    -c:指明collection的名字    -f:指明要导入那些列</code></pre><p>demo</p><pre><code>    mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库名 -c colelctions名称  resources.json --type json    </code></pre><h5 id="如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式-CSV-格式良好，主流数据库都支持导出为CSV-的格式，所以这种格式非常利于异构数据迁移"><a href="#如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式-CSV-格式良好，主流数据库都支持导出为CSV-的格式，所以这种格式非常利于异构数据迁移" class="headerlink" title="如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式(CSV 格式良好，主流数据库都支持导出为CSV 的格式，所以这种格式非常利于异构数据迁移)"></a>如果要导入CSV格式文件中的内容，则需要通过–type参数指定导入格式(CSV 格式良好，主流数据库都支持导出为CSV 的格式，所以这种格式非常利于异构数据迁移)</h5><ul><li><p>参数说明：</p><pre><code>  -type:指明要导入的文件格式  -headerline:指明第一行是列名，不需要导入  -file：指明要导入的文件</code></pre></li></ul><h4 id="MongoDB的数据备份和恢复"><a href="#MongoDB的数据备份和恢复" class="headerlink" title="MongoDB的数据备份和恢复"></a>MongoDB的数据备份和恢复</h4><p>用mongodump 来做MongoDB 的库或表级别的备份</p><ul><li><p>备份选项说明(sudo .&#x2F;mongodump  –help)：</p><pre><code>  -h:指明数据库宿主机的IP  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字  -o:输出目录  -q:json query(json查询)</code></pre></li></ul><h5 id="用mongorestore-来做MongoDB-的库或表级别的数据恢复"><a href="#用mongorestore-来做MongoDB-的库或表级别的数据恢复" class="headerlink" title="用mongorestore 来做MongoDB 的库或表级别的数据恢复"></a>用mongorestore 来做MongoDB 的库或表级别的数据恢复</h5><ul><li><p>恢复选项说明(sudo .&#x2F;mongorestore  –help):</p><pre><code>  -u:指明数据库的用户名  -p:指明数据库的密码  -d:指明数据库的名字  -c:指明collection的名字</code></pre></li></ul><p>　　　</p><h3 id="从阿里云备份的数据，导入本地"><a href="#从阿里云备份的数据，导入本地" class="headerlink" title="从阿里云备份的数据，导入本地"></a>从阿里云备份的数据，导入本地</h3><ul><li><p>阿里云建议的语法</p><pre><code>  cat xx.ar| mongorestore -h xxx --port xxx -u xxx -p xxx --drop --gzip --archive -vvvv --stopOnError</code></pre></li><li><p>我在windows上导入的语法</p><pre><code>  mongorestore -h 127.0.0.1 --port 27017  --drop --gzip --archive=hins1226667_data_2212.ar --stopOnError</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性详解</title>
      <link href="/2016/07/17/java/%20JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/07/17/java/%20JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK1-8新特性详解"><a href="#JDK1-8新特性详解" class="headerlink" title="JDK1.8新特性详解"></a>JDK1.8新特性详解</h2><p>Java 8 发行版2014年 3月 19日</p><p>将Java8的新特新逐一列出，并将使用简单的代码示例来指导你如何使用默认接口方法，lambda表达式，方法引用以及多重Annotation，之后你将会学到最新的API上的改进，比如流，函数式接口，Map以及全新的日期API</p><h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a>一、接口的默认方法</h2><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p>首先看看在老版本的Java中是如何排列字符串的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</span><br><span class="line">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b) &#123;</span><br><span class="line">        return b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a>四、方法与构造函数引用</h2><p>前一节中的代码还可以通过静态方法引用来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);   // 123</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(&quot;Java&quot;);</span><br><span class="line">System.out.println(converted);    // &quot;J&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p><h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a>五、Lambda 作用域</h2><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p><h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a>六、访问局部变量</h2><p>我们可以直接在lambda表达式中访问外层的局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(2);     // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在lambda表达式中试图修改num同样是不允许的。</p><h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">    static int outerStaticNum;</span><br><span class="line">    int outerNum;</span><br><span class="line">    void testScopes() &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = 23;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = 72;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * 100);</span><br><span class="line">Built-in Functional Interfaces</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line">predicate.test(&quot;foo&quot;);              // true</span><br><span class="line">predicate.negate().test(&quot;foo&quot;);     // false</span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br><span class="line">personSupplier.get();   // new Person</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p>Consumer 接口表示执行在单个参数上的操作。</p><p>Consumer greeter &#x3D; (p) -&gt; System.out.println(“Hello, ” + p.firstName); greeter.accept(new Person(“Luke”, “Skywalker”));</p><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</span><br><span class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a>Optional 接口</h3><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</span><br><span class="line">optional.isPresent();           // true</span><br><span class="line">optional.get();                 // &quot;bam&quot;</span><br><span class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(&quot;ddd2&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa2&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb1&quot;);</span><br><span class="line">stringCollection.add(&quot;aaa1&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb3&quot;);</span><br><span class="line">stringCollection.add(&quot;ccc&quot;);</span><br><span class="line">stringCollection.add(&quot;bbb2&quot;);</span><br><span class="line">stringCollection.add(&quot;ddd1&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;aaa2&quot;, &quot;aaa1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h3><p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;aaa1&quot;, &quot;aaa2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean anyStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line">System.out.println(anyStartsWithA);      // true</span><br><span class="line"></span><br><span class="line">boolean allStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      // false</span><br><span class="line"></span><br><span class="line">boolean noneStartsWithZ = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a>Count 计数</h3><p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long startsWithB = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(&quot;b&quot;))</span><br><span class="line">        .count();</span><br><span class="line">System.out.println(startsWithB);    // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce 规约"></a>Reduce 规约</h3><p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="并行Streams"><a href="#并行Streams" class="headerlink" title="并行Streams"></a>并行Streams</h3><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int max = 1000000;</span><br><span class="line">List&lt;String&gt; values = new ArrayList&lt;&gt;(max);</span><br><span class="line">for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们计算一下排序这个Stream要耗时多久， 串行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line">long count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 串行耗时: 899 ms 并行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line">long count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p><p>下面的例子展示了map上的其他有用的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line">map.computeIfPresent(9, (num, val) -&gt; null);</span><br><span class="line">map.containsKey(9);     // false</span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);</span><br><span class="line">map.containsKey(23);    // true</span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.remove(3, &quot;val3&quot;);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line">map.remove(3, &quot;val33&quot;);</span><br><span class="line">map.get(3);             // null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外一个有用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(42, &quot;not found&quot;);  // not found</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9</span><br><span class="line">map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9concat</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h2 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a>九、Date API</h2><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="Clock-时钟"><a href="#Clock-时钟" class="headerlink" title="Clock 时钟"></a>Clock 时钟</h3><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   // legacy java.util.Date</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</span><br><span class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime 本地时间"></a>LocalTime 本地时间</h3><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2));  // false</span><br><span class="line"></span><br><span class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       // -3</span><br><span class="line">System.out.println(minutesBetween);     // -239</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(23, 59, 59);</span><br><span class="line">System.out.println(late);       // 23:59:59</span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   // 13:37</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate 本地日期"></a>LocalDate 本地日期</h3><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天&#x2F;月&#x2F;年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(2);</span><br><span class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>System.out.println(dayOfWeek); &#x2F;&#x2F; FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line">LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);</span><br><span class="line">System.out.println(xmas);   // 2014-12-24</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime-本地日期时间"><a href="#LocalDateTime-本地日期时间" class="headerlink" title="LocalDateTime 本地日期时间"></a>LocalDateTime 本地日期时间</h3><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      // WEDNESDAY</span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          // DECEMBER</span><br><span class="line"></span><br><span class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    // 1439</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p><h2 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a>十、Annotation 注解</h2><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line">@Repeatable(Hints.class)</span><br><span class="line">@interface Hint &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例 2：使用多重注解（新方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Hint(&quot;hint1&quot;)</span><br><span class="line">@Hint(&quot;hint2&quot;)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.7新特性详解</title>
      <link href="/2016/07/16/java/%20JDK1.7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/07/16/java/%20JDK1.7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK1-7新特性详解"><a href="#JDK1-7新特性详解" class="headerlink" title="JDK1.7新特性详解"></a>JDK1.7新特性详解</h2><p>Java 7 发行版2011 年 7 月 28 日</p><p>JDK7对Java语法有少量更新，重点是在易用性和便捷性的改进。</p><h2 id="1-二进制字面量"><a href="#1-二进制字面量" class="headerlink" title="1.二进制字面量"></a>1.二进制字面量</h2><p>JDK7开始，终于可以用二进制来表示整数（byte,short,int和long）。使用二进制字面量的好处是，可以是代码更容易被理解。语法非常简单，只要在二进制数值前面加 0b或者0B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte nByte = (byte)0b0001;  </span><br><span class="line">short nShort = (short)0B0010;  </span><br><span class="line">int nInt = 0b0011;  </span><br><span class="line">long nLong = 0b0100L; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-数字字面量可以出现下划线"><a href="#2-数字字面量可以出现下划线" class="headerlink" title="2.数字字面量可以出现下划线"></a>2.数字字面量可以出现下划线</h2><p>对于一些比较大的数字，我们定义起来总是不方面，经常缺少或者增加位数。JDK7为我们提供了一种解决方案，下划线可以出现在数字字面量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10_0000_0000;  </span><br><span class="line">long b = 0xffff_ffff_ffff_ffffl;  </span><br><span class="line">byte c = 0b0001_1000;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：你只能将下划线置于数字之间，以下使用方法是错误的，</p><ol><li>数字的开头或者结尾</li><li>小数点的前后</li><li>‘F’或者‘f’的后缀</li><li>只能用数字的位置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nt err1 = _11,err2=11_;  </span><br><span class="line">float err3=3._4,err4=3_.4;  </span><br><span class="line">long err5=0x888_f;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-switch-语句可以用字符串了"><a href="#3-switch-语句可以用字符串了" class="headerlink" title="3.switch 语句可以用字符串了"></a>3.switch 语句可以用字符串了</h2><p>这个功能千呼万唤，终于出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void switchString(String str)&#123;  </span><br><span class="line">        switch(str)&#123;  </span><br><span class="line">            case &quot;one&quot;:  </span><br><span class="line">                System.err.println(&quot;1&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            case &quot;two&quot;:  </span><br><span class="line">                System.out.println(&quot;2&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            default :  </span><br><span class="line">                System.out.println(&quot;err&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-泛型实例的创建可以通过类型推断来简化"><a href="#4-泛型实例的创建可以通过类型推断来简化" class="headerlink" title="4.泛型实例的创建可以通过类型推断来简化"></a>4.泛型实例的创建可以通过类型推断来简化</h2><p>以后你创建一个泛型实例，不需要再详细说明类型，只需用&lt;&gt;,编译器会自动帮你匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//例如   </span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();  </span><br><span class="line">//可以简化为  </span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-在可变参数方法中传递非具体化参数（Non-Reifiable-Formal-Parameters）-改进编译警告和错误"><a href="#5-在可变参数方法中传递非具体化参数（Non-Reifiable-Formal-Parameters）-改进编译警告和错误" class="headerlink" title="5.在可变参数方法中传递非具体化参数（Non-Reifiable Formal Parameters）,改进编译警告和错误"></a>5.在可变参数方法中传递非具体化参数（Non-Reifiable Formal Parameters）,改进编译警告和错误</h2><p>有些参数类型，例如ArrayList 和 List,是非具体化的（non-reifiable）.在编译阶段，编译器会擦除该类型信息。</p><p>Heappollution 指一个变量被指向另外一个不是相同类型的变量。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List l = new ArrayList&lt;Number&gt;();  </span><br><span class="line">List&lt;String&gt; ls = l;       // unchecked warning  </span><br><span class="line">l.add(0, new Integer(42)); // another unchecked warning  </span><br><span class="line">String s = ls.get(0);      // ClassCastException is thrown  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到我们的主题，在jdk7中，当你定义下面的函数时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;  </span><br><span class="line">    for (T x : elements) &#123;  </span><br><span class="line">      listArg.add(x);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你会得到一个warning</p><p><code>warning: [varargs] Possible heap pollution from parameterized vararg type</code></p><p>在jdk7之前，当你调用一个含有非具体化参数的可变参数方法，你必须自行保证不会发生<code>heappollution</code>。这有一个问题，如果调用者对方法不熟悉，他根本无法判断。JDK7对此做了改进，在该方法被定义时久发出警告</p><p>要消除警告，可以有三种方式</p><ol><li>加 annotation @SafeVarargs</li><li>加 annotation @SuppressWarnings({“unchecked”, “varargs”})</li><li>使用编译器参数 –Xlint:varargs;</li></ol><h2 id="6-try-with-resources-语句"><a href="#6-try-with-resources-语句" class="headerlink" title="6.try-with-resources 语句"></a>6.try-with-resources 语句</h2><p>jdk7提供了try-with-resources,可以自动关闭相关的资源（只要该资源实现了AutoCloseable接口，jdk7为绝大部分资源对象都实现了这个接口）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFile(String path) throws IOException &#123;  </span><br><span class="line">  try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;  </span><br><span class="line">    return br.readLine();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try 语句块中还可以同时处理多个资源,可以跟普通的try语句一样catch异常，有finally语句块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (  </span><br><span class="line">      java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);  </span><br><span class="line">      java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)  </span><br><span class="line">    ) &#123;  </span><br><span class="line">&#125;catch(…)&#123;  </span><br><span class="line">&#125;finally&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-Catch多个Exception，rethrow-exception-改进了类型检测"><a href="#7-Catch多个Exception，rethrow-exception-改进了类型检测" class="headerlink" title="7.Catch多个Exception，rethrow exception 改进了类型检测"></a>7.Catch多个Exception，rethrow exception 改进了类型检测</h2><p>很多时候，我们捕获了多个异常，却做了相同的事情，比如记日志，包装成新的异常，然后rethrow。这时，代码就不那么优雅了，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException ex) &#123;  </span><br><span class="line">     logger.log(ex);  </span><br><span class="line">     throw ex;  </span><br><span class="line">catch (SQLException ex) &#123;  </span><br><span class="line">     logger.log(ex);  </span><br><span class="line">     throw ex;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Jdk7允许捕获多个异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException|SQLException ex) &#123;  </span><br><span class="line">    logger.log(ex);  </span><br><span class="line">    throw ex;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，catch后面的异常参数是final的，不能重新再复制</p><p><code>RethrowException</code>更具包容性的类型检测</p><p>当你重新抛出多个异常时，不再需要详细定义异常类型了，编译器已经知道你具体抛出的是哪个异常了。你只需在方法定义的时候声明需要抛出的异常即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void call() throws ReflectiveOperationException, IOException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">      callWithReflection(arg);  </span><br><span class="line">    &#125; catch (final Exception e) &#123;  </span><br><span class="line">      logger.trace(&quot;Exception in reflection&quot;, e);  </span><br><span class="line">      throw e;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考</p><ul><li>Jdk7官网 <a href="http://openjdk.java.net/projects/jdk7/">http://openjdk.java.net/projects/jdk7/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·安装与配置(win)</title>
      <link href="/2016/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE(win)/"/>
      <url>/2016/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE(win)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB·入门</title>
      <link href="/2016/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%85%A5%E9%97%A8/"/>
      <url>/2016/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MongoDB%C2%B7%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB·入门"><a href="#MongoDB·入门" class="headerlink" title="MongoDB·入门"></a>MongoDB·入门</h1><p>##何为 NoSql</p><blockquote><p>NoSQL(NoSQL &#x3D; Not Only SQL ) <span id="more"></span></p></blockquote><ul><li><p>为什么使用NoSQL 强项：</p><pre><code>  1.对数据库高并发读写。    2.对海量数据的高效率存储和访问。    3.对数据库的高可扩展性和高可用性。</code></pre></li><li><p>弱项：</p><pre><code>  1.数据库事务一致性需求    2.数据库的写实时性和读实时性需求    3.对复杂的SQL查询，特别是多表关联查询的需求</code></pre></li></ul><h2 id="NoSQL四大类"><a href="#NoSQL四大类" class="headerlink" title="NoSQL四大类"></a>NoSQL四大类</h2><h3 id="1-key-value存储"><a href="#1-key-value存储" class="headerlink" title="1.key-value存储"></a>1.key-value存储</h3><blockquote><table><thead><tr><th>Examples</th><th>Redis, Tokyo Cabinet&#x2F;Tyrant, Tair</th></tr></thead><tbody><tr><td>典型应用场景</td><td>内容缓存，主要用于处理大量数据的高访问负载。</td></tr><tr><td>数据模型</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td></tr><tr><td>强项</td><td>查找速度快</td></tr><tr><td>弱项</td><td>数据无结构化（或弱结构），通常只被当作字符串或者二进制数据</td></tr></tbody></table></blockquote><h3 id="2-列式数据库"><a href="#2-列式数据库" class="headerlink" title="2.列式数据库"></a>2.列式数据库</h3><blockquote><table><thead><tr><th>Examples</th><th align="left">Cassandra  HBase Riak  SybaseIQ</th></tr></thead><tbody><tr><td>典型应用场景</td><td align="left">分布式的文件系统、大数据分析。</td></tr><tr><td>数据模型</td><td align="left">以列簇式存储，将同一列数据存在一起</td></tr><tr><td>强项</td><td align="left">查找速度快，可扩展性强，更容易进行分布式扩展</td></tr><tr><td>弱项</td><td align="left">功能相对局限</td></tr></tbody></table></blockquote><h3 id="3-文档型数据库"><a href="#3-文档型数据库" class="headerlink" title="3.文档型数据库"></a>3.文档型数据库</h3><blockquote><table><thead><tr><th>Examples</th><th>MongoDb，CouchDB</th></tr></thead><tbody><tr><td>典型应用场景</td><td>Web应用(Value是结构化的，数据库能够了解Value的内容)</td></tr><tr><td>数据模型</td><td>Key-Value对应的键值对，Value为结构化文档数据</td></tr><tr><td>强项</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td></tr><tr><td>弱项</td><td>相比其他NoSql查询性能不高，而且缺乏统一的查询语法</td></tr></tbody></table></blockquote><h3 id="4-图结构数据库"><a href="#4-图结构数据库" class="headerlink" title="4.图结构数据库"></a>4.图结构数据库</h3><blockquote><table><thead><tr><th>Examples</th><th>Neo4J, InfoGrid, Infinite Graph</th></tr></thead><tbody><tr><td>典型应用场景</td><td>社交网络，推荐系统等。专注于构建关系图谱</td></tr><tr><td>数据模型</td><td>图结构</td></tr><tr><td>强项</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td></tr><tr><td>弱项</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td></tr></tbody></table></blockquote><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Mongo 是一个高性能，开源，无模式的文档型数据库，它在许多场景下可用于替代传统的关系型数据库或键&#x2F;值存储方式。MongoDB使用C++开发。不支持SQL，但有自己功能强大的查询语法。MongoDB使用BSON作为数据存储和传输的格式。BSON是一种类似JSON的二进制序列化文档。MongoDB很像MySQL，是最像关系型数据库的NoSql。</p></blockquote><ul><li>字段对应关系</li></ul><blockquote><table><thead><tr><th>MySQL term</th><th align="left">Mongo term&#x2F;conceptp</th></tr></thead><tbody><tr><td>database</td><td align="left">database</td></tr><tr><td>table</td><td align="left">collection</td></tr><tr><td>index</td><td align="left">index</td></tr><tr><td>row</td><td align="left">BSON document</td></tr><tr><td>column</td><td align="left">BSON field</td></tr><tr><td>join</td><td align="left">embedding and linking</td></tr><tr><td>primary key</td><td align="left">_id field</td></tr><tr><td>group by</td><td align="left">aggregation</td></tr></tbody></table></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><ul><li>高性能、易部署、易使用，存储数据非常方便。</li></ul></blockquote><ul><li>面向集合存储，易存储对象类型的数据</li><li>模式自由</li><li>支持动态查询</li><li>支持完全索引，包含内部对象。</li><li>支持复制和故障恢复。 </li><li>使用高效的二进制数据存储，包括大型对象（如视频等）</li><li>自动处理碎片，以支持云计算层次的扩展性</li><li>支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序</li><li>文件存储格式为BSON（一种JSON的扩展）</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><blockquote><ul><li>面向集合的存储：适合存储对象及JSON形式的数据。</li></ul></blockquote><ul><li>动态查询：MongoDB 支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>完整的索引支持：包括文档内嵌对象及数组。MongoDB的查询优化器会分析查询表达式，并生成一个高效的查询计划。</li><li>查询监视：MongoDB包含一系列监视工具用于分析数据库操作的性能。</li><li>复制及自动故障转移：MongoDB数据库支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。</li><li>高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）。</li><li>自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群。</li></ul><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><blockquote><ul><li>网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</li></ul></blockquote><ul><li>大数据量，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</li><li>高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。</li><li>用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Spring3 Schedule Task之注解实现 （两次起动Schedule Task 的解决方案）</title>
      <link href="/2016/06/30/java/%20Spring%20Spring3%20Schedule%20Task%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%A4%E6%AC%A1%E8%B5%B7%E5%8A%A8Schedule%20Task%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/"/>
      <url>/2016/06/30/java/%20Spring%20Spring3%20Schedule%20Task%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%A4%E6%AC%A1%E8%B5%B7%E5%8A%A8Schedule%20Task%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>目前项目中还未运用到 定时任务模块，考虑到好友生日提醒，后续的统计，日志收集等会需要做成定时任务执行，<br>   就目前情况，准备先使用Spring3的 Spring-Task 来实现，直接用注解即可，配置后，写了个测试方法，每隔一分钟 打印一句话。测试过程中发下每次会执行两遍~  解决后 mark 下，补充学习~。</p></blockquote><p><img src="http://i.imgur.com/OzJCeEx.png"></p><pre><code> Spring3 Schedule Task之注解实现 （两次启动Schedule Task 的解决方案）在spring3 中的新引入的task 命名空间。可以部分取代 quartz 功能，配置和API更加简单，并且支持注解方式。但是如果需要使用比较复杂的任务调度。还是建议使用quartz。</code></pre><h2 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h2><pre><code>在Spring的相关配置文件中（applicationContext.xml或者是&#123;project_name&#125;_servelt.xml或者是独立的配置文件如XXX_quartz.xml)中配置并开启Spring Schedule Task.注意其中高亮的部分是必须的。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;        xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd       http://www.springframework.org/schema/task       http://www.springframework.org/schema/task/spring-task-3.0.xsd       &quot;&gt;    &lt;mvc:annotation-driven /&gt;    &lt;context:component-scan base-package=&quot;com.mytools.validator.engine&quot; /&gt;        &lt;!-- 启动定时器 --&gt;    &lt;task:annotation-driven/&gt;     &lt;/beans&gt;</code></pre><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><pre><code>    可以在类中的需要定时执行的方法下指定如下Annotation@Scheduled(cron=&quot;0 33/3 * * * ?&quot;) //每小时的33分钟开始执行，每3分钟执行1次    public void start() throws ServletException &#123;                 validate();&#125;</code></pre><ul><li><p>备注：其实@Scheduled中可以指定如下3中时间表达式：</p></li><li><p>（1）fixedRate：每隔多少毫秒执行一次该方法。如：</p><pre><code>    @Scheduled(fixedRate=2000)  // 每隔2秒执行一次    public void scheduleMethod()&#123;                System.out.println(&quot;Hello world...&quot;);      &#125;  </code></pre><p>　 </p></li><li><p>（2）fixedDelay：当一次方法执行完毕之后，延迟多少毫秒再执行该方法。</p></li><li><p>（3）cron：详细配置了该方法在什么时候执行。cron值是一个cron表达式。如：</p><pre><code>          @Scheduled(cron=&quot;0 0 0 * * SAT&quot;)            public voidarchiveOldSpittles() &#123;             // ...            &#125;</code></pre></li></ul><p>到指定时间后，任务总是执行2次的解决方案：<br>这是因为我们很容易在一个基于Spring的Web工程中启动2个定时线程：</p><p> 第一次：web容器启动的时候，读取applicationContext.xml（或者别的Spring核心配置文件）文件时，会加载一次。</p><p> 第二次：Spring本身会加载applicationContext.xml（或者别的Spring核心配置文件）一次。</p><p>解决方案：将你的Task的相关配置独立出来并在web.xml中通过context-param加载。而不是通过spring加载。</p><p>1） 独立出Spring-Task，如新命名一个文件名叫cms_quartz.xml</p><ol start="2"><li>在web.xml中去加载该文件：</li></ol><pre><code>&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/cms-servlet.xml,classpath:cms-quartz.xml&lt;/param-value&gt;    &lt;/context-param&gt;</code></pre><hr><p>1.首先加入下载spring3.2 ，<a href="http://projects.spring.io/spring-framework/">http://projects.spring.io/spring-framework/</a></p><p>2.加入jar包，在applicationContext.xml加入声明</p><p>-xmlns加入</p><p>[java<br>xmlns:task&#x3D;”<a href="http://www.springframework.org/schema/task&quot;">http://www.springframework.org/schema/task&quot;</a><br>-xsi加入<br>[java]<br><a href="http://www.springframework.org/schema/task">http://www.springframework.org/schema/task</a>   </p><p>[java]<br><a href="http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;">http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;</a>  </p><p>[java]<br>            <!-- 使用Annotation自动注册Bean，解决事物失效问题：在主容器中不扫描@Controller注解，在SpringMvc中只扫描@Controller注解。  --><br>            &lt;context:component-scan base-package&#x3D;”com.zt49”&gt;<br>                &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller” &#x2F;&gt;<br>            </context:component-scan>  </p><ul><li>任务注解</li></ul><p>[java]<br>&lt;task:annotation-driven &#x2F;&gt;  </p><p>3.创建一个任务类（示例）<br>[java]<br>import org.springframework.context.annotation.Lazy;  </p><p>import org.springframework.scheduling.annotation.Scheduled;  </p><p>import org.springframework.stereotype.Component;  </p><pre><code>@Component  public class TestTask &#123;            @Scheduled(cron = &quot;0 0/1 * * * ?&quot;)      public void test()&#123;          System.out.println(&quot;test&quot;);      &#125;    &#125;  </code></pre><p>启动程序，定时任务就可以了。这个示例代表每分钟执行一次任务。</p><p>附：cron常用表示：</p><pre><code>CronTrigger配置格式:   格式: [秒] [分] [小时] [日] [月] [周] [年]序号 说明 是否必填 允许填写的值 允许的通配符1   秒    是      0-59 ,         - * /2    分    是      0-59 ,        - * /3    小时  是      0-23 ,       - * /4    日    是      1-31 ,      - * ? / L W5    月    是    1-12 or JAN-DEC , - * /6    周     是     1-7 or SUN-SAT , - * ? / L #7    年     否     empty 或 1970-2099 , - * /通配符说明:* 表示所有值. 例如:在分的字段上设置 &quot;*&quot;,表示每一分钟都会触发。? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为&quot;?&quot; 具体设置为 0 0 0 10 * ?- 表示区间。例如在小时上设置 &quot;10-12&quot;,表示 10,11,12点都会触发。, 表示指定多个值，例如在周字段上设置 &quot;MON,WED,FRI&quot; 表示周一，周三和周五触发/ 用于递增触发。如在秒上面设置&quot;5/15&quot; 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置&#39;1/3&#39;所示每月1号开始，每隔三天触发一次。L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于&quot;7&quot;或&quot;SAT&quot;。如果在&quot;L&quot;前加上数字，则表示该数据的最后一个。例如在周字段上设置&quot;6L&quot;这样的格式,则表示“本 月最后一个星期五&quot;W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置&quot;15W&quot;，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 &quot;1W&quot;,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，&quot;W&quot;前只能设置具体的数字,不允许区间&quot;-&quot;).小提示&#39;L&#39;和 &#39;W&#39;可以一组合使用。如果在日字段上设置&quot;LW&quot;,则表示在本月的最后一个工作日触发(一般指发工资 )# 序号(表示每月的第几个周几)，例如在周字段上设置&quot;6#3&quot;表示在每月的第三个周六.注意如果指定&quot;#5&quot;,正好第五周没有周六，则不会触发该配置(用 在母亲节和父亲节再合适不过了)小提示周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同.常用示例:0 0 12 * * ? 每天12点触发0 15 10 ? * * 每天10点15分触发0 15 10 * * ? 每天10点15分触发0 15 10 * * ? * 每天10点15分触发0 15 10 * * ? 2005 2005年每天10点15分触发0 * 14 * * ? 每天下午的 2点到2点59分每分触发0 0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)0 0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) 每天下午的 18点到18点59分(整点开始，每隔5分触发)0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发0 10,44 14 ? 3 WED 3月分每周三下午的 2点10分和2点44分触发0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发0 15 10 15 * ? 每月15号上午10点15分触发0 15 10 L * ? 每月最后一天的10点15分触发0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发0 15 10 ? * 6#3 每月的第三周的星期五开始触发0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次0 11 11 11 11 ? 每年的11月11号 11点11分触发</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh-keygen</title>
      <link href="/2016/06/16/%E5%B7%A5%E5%85%B7/%20ssh-keygen/"/>
      <url>/2016/06/16/%E5%B7%A5%E5%85%B7/%20ssh-keygen/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>ssh是一种安全的网络协议，主要用于登录linux<span id="more"></span>,可每次登录都需要输入密码，非常麻烦，ssh-keygen （公钥）认证是ssh认证方式的一种，通过公钥认证可实现免密码登录， 带来了不少便利。~ github也可以通过这种方式认证</p></blockquote><h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><blockquote><p>这里只简单记录下，如何通过ssh-keygen实现两台linux设备的相互登录</p></blockquote><ul><li>从本地免密码登录到目标机器</li></ul><ol><li><p>本地执行 <code>ssh-keygen -t rsa</code> 默认在 ~&#x2F;.ssh目录下生成将会生成密钥文件和私钥文件 id_rsa,id_rsa.pub</p><pre><code>    -t : [rsa|dsa] 加密方式    -f : 自定义文件的名字     -C : 注释（备注）</code></pre></li><li><p>把id_rsa.pub复制到目标机器的.ssh目录，并导入到<code>authorized_keys</code>中</p><pre><code>         cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre></li></ol><p>这样就可以通过SSH 目标IP，直接登录到目标机器了</p><ul><li>注意：.ssh的目录，及里面的文件权限请保持只能本地写的权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术小栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2016/06/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/06/11/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-学习笔记·入门"><a href="#Markdown-学习笔记·入门" class="headerlink" title="Markdown 学习笔记·入门"></a>Markdown 学习笔记·入门</h1><p>　　花一点点时间了解了下Markdown的语法，确实非常简单，这里做下总结，也算是对Markdown语法的熟悉，及模仿造轮子吧~ <span id="more"></span>  </p><h2 id="markdown-简介"><a href="#markdown-简介" class="headerlink" title="markdown 简介"></a>markdown 简介</h2><blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。–百度百科</p></blockquote><h2 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h2><blockquote></blockquote><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li><li>Markdown 的标记语法有极好的可读性。</li></ul><h2 id="Markdown-语法介绍"><a href="#Markdown-语法介绍" class="headerlink" title="Markdown 语法介绍"></a>Markdown 语法介绍</h2><h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ul><li>*,-,+ 3个符号 被称为Markdown符号</li><li>空白行表示另起一个段落</li><li>&#96;是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签</li></ul><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li><p><code>#</code> + 空格 后面的文字即表示为标题</p><pre><code>  # 表示一级标题，## 表示二级标题，依次表示 1-6 级标题</code></pre></li><li><p>注意： 符号后面要加一个 <strong>空格</strong> 和文本内容隔开</p></li><li><p>还可以在文字下行加&#x3D; 表示大标题 - 表示小标题 慎用吧</p><pre><code>  例如：  大标题  =  小标题  -</code></pre></li></ul><h3 id="字体：斜体-x2F-加粗"><a href="#字体：斜体-x2F-加粗" class="headerlink" title="字体：斜体 &#x2F; 加粗"></a>字体：斜体 &#x2F; 加粗</h3><pre><code>    *文本* 表示文本内容为斜体， **文本** 表示文本内容为加粗</code></pre><ul><li>效果： <em>斜体文本</em>  <strong>加粗文本</strong></li></ul><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>段落间加一个 <strong>空白行</strong> 分割 同html中的 <code>&lt;p&gt;</code></li><li>连续两个空格即为换行 同html中的 <code>&lt;br&gt;</code></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>使用*,+,-加上一个空格来表示</p></li><li><p>可以支持嵌套,如</p><pre><code>  *,+,-效果一样的  - 外层列表项目        + 内层列表项目       + 内层无序列表项目      + 内层列表项目  - 外层列表项目</code></pre></li><li><p>效果</p></li></ul><p> </p><hr><ul><li>外层列表项目<ul><li>内层列表项目</li><li>内层列表项目</li><li>内层列表项目</li></ul></li><li>外层列表项目</li></ul><hr><ul><li><p>有序列表用 数字+英文点+空格来表示</p><pre><code>  - 1. 这样会展示序号 </code></pre></li><li><p>效果：</p></li><li><ol><li>这样会展示序号</li></ol></li><li><p>注意：列表内容很长的，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><p>这其实是我第一个接触的markdown语法，第一篇资料收集时就用到了</p><pre><code>   直接使用 [文本](链接)</code></pre></li><li><p>效果：<a href="https://www.baidu.com/">百度</a></p><pre><code>   如果很多地方需要相同的url呢，可以预先定义url 这样玩：[ref_name]:URL     ref_name 一般使用数字表示，显得专业 然后在需要使用链接的地方 使用[文本][ref_name] 这种方式即可,酷炫</code></pre></li><li><p>效果<br>[1]:<a href="https://www.baidu.com/">https://www.baidu.com/</a></p><pre><code>    [ref_name]：url 如： [1]:https://www.baidu.com/ </code></pre></li><li><p>引用上面定义的url [百度][1]</p></li><li><p>如果想把URL展示出来，并可以作为链接使用  这样玩：<code>&lt;URL&gt;</code></p><pre><code>    &lt;url&gt; 如： &lt;https://www.baidu.com/&gt; </code></pre></li><li><p>效果：<a href="https://www.baidu.com/">https://www.baidu.com/</a></p></li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li><p>图片语法与链接类似</p><pre><code>  ![](图片地址) 如： ![](http://i.imgur.com/P7ACmyM.png)</code></pre></li></ul><p> <img src="http://i.imgur.com/P7ACmyM.png"></p><ul><li><p>同样可以使用引用的方式使用图片</p><pre><code>  这样定义：[id]:图片url  这样引用定义 ![][id]</code></pre></li><li><p>定义图片的大小或比例</p></li><li><p>方法一：嵌入HTML代码</p><pre><code>      &lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; 注意：要居中展示，外围加&lt;div&gt;即可</code></pre></li><li><p>方法二：使用支持图片大小更改操作的 Mou 编辑器 （mac可以玩）</p><pre><code>       ![](url =100x100) 注意: =前有个空格，可以只写宽度。         </code></pre></li><li><p>方法三： 阿里云的OSS，七牛云的图片服务器时，url上加上相关操字段即可实现图片大小，比例修改，具体见各自的产品文档~</p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>开篇关于Markdown的简介和特点就是引用的百度， 只要在第一行加上 “&gt;”和一个空格，表示代码引用，还可以嵌套</li></ul><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><ul><li><p>使用 \ 来转义，表示文本中的markdown符号</p><pre><code>  如： \[百度](https://www.baidu.com/)</code></pre></li><li><p>效果：[百度](<a href="https://www.baidu.com/">https://www.baidu.com/</a>)</p></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><p>表格代码</p><blockquote></blockquote><p>| Tables        | Are           | Cool  |<br>| ————- |:————-:| —–:|<br>| col 3 is      | right-aligned | $1600 |<br>| col 2 is      | centered      |   $12 |<br>| zebra stripes | are neat      |    $1 |  </p><p>   ————- 左对齐 :————-: 居中 —–:右对齐</p></li><li><p>效果：</p></li></ul><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li><p>按下Tab键 或4个空格即表示代码块</p></li><li><p>下面是一小段代码举例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里显示一些代码，使用```java```，进行代码染色，这是一段使用JAVA代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> Id </span><br><span class="line">  <span class="keyword">public</span> string Subject</span><br><span class="line">  省略 get() set() toString() ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样基本就可以玩起来了，还是需要多实践，多谢，多总结。</p><blockquote><p>我们活在各自的的心灵世界，我们有什么样的心，就决定我们看到什么样的世界</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习下Markdown</title>
      <link href="/2016/06/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AD%A6%E4%B9%A0%E4%B8%8BMarkdown/"/>
      <url>/2016/06/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%AD%A6%E4%B9%A0%E4%B8%8BMarkdown/</url>
      
        <content type="html"><![CDATA[<p>   利用闲暇时间搭建了这个人博客，希望以督促自己坚持多总结， 多写作，不断提高自己，现在都流行使用Markdown来编写blog，我对<br>Markdown 尚未了解，百度之，还好比较简单<span id="more"></span>,下载了MarkDownPad,收集了一些资料,准备学习之</p><p><a href="http://lutaf.com/markdown-simple-usage.htm">鲁塔弗 一分钟学会Markdown语法</a></p><p><a href="http://www.ituring.com.cn/article/23">图灵社区 Markdown语法入门</a></p><p><a href="http://www.jianshu.com/p/q81RER">简书 适合新手的Markdown语法</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录水果篮子</title>
      <link href="/2008/06/23/%E8%AF%AD%E5%BD%95/%E8%AF%AD%E5%BD%95-%E6%B0%B4%E6%9E%9C%E7%AF%AE%E5%AD%90/"/>
      <url>/2008/06/23/%E8%AF%AD%E5%BD%95/%E8%AF%AD%E5%BD%95-%E6%B0%B4%E6%9E%9C%E7%AF%AE%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很早喜欢收集看过的动漫，书记的语录，准备搞了一个专门的分类，来存放很久很久之前的文字，可能回味起来，有幼稚，有感动，也有怀念吧～</p></blockquote><h2 id="水果篮子￠名言"><a href="#水果篮子￠名言" class="headerlink" title="水果篮子￠名言"></a>水果篮子￠名言</h2><p>1.雪融化之后会变成什么呢？（草摩波鸟）<br>会变成春天吧……（本田透）<br>————《水果篮子》   </p><p>2、欲望是每个人天生就有的，所以容易了解。而良心则像是一个人<br>要用于创造出的东西。所以曾被理解，也很容易被当做是伪善。（今日子）<br>————《水果篮子》   </p><p>3、与别人交往，有时伤害人，有时被伤害。却不懂得学习别人的话，<br>在某种意义上，你是无法成为一个能体谅他人的人。（草摩紫吴）<br>————《水果篮子》   </p><p>4、我有想要的东西：凭想象画出的东西，能紧紧拥抱我的父母。<br>让我想回去的家。大家都欢笑的地方。希望大家都不会分开<br>的我，也能有暖暖的地方。温暖的人……这一切，是真的存在着。（草摩由希）<br>————《水果篮子》   </p><p>5、就算有一天，你们必须踏上各自不同的道路，也绝不会有什么<br>薄情或是寂寞的事。因为一定会有让你能……继续下去的事物。（今日子）<br>————《水果篮子》   </p><p>6、我想确定，从这双手，诞生出有形的东西。也许我是想知道，<br>是否有某样东西……没有我，就不会存在。（草摩绫女）<br>————《水果篮子》   </p><p>7、在珍惜着某个人时，有时候会很难过，有时候会感到寂寞。<br>但是，有时候也会觉得非常快乐。（花岛惠）<br>————《水果篮子》   </p><p>8、有时候，人就是要有点凄惨的经历，惹点麻烦，才会了解到……某些心情，<br>堕落到人生的深渊底部，才会了解的……反抗漂亮的东西。但是在最软弱<br>的时候，才会开始爱恋上漂亮的东西。痛需要温柔，黑暗需要显眼，就<br>需要阳光。两者都不可小看，两者都不会徒劳无功的，所以就算跌倒，<br>作错了，也都不会自责。（今日子）————《水果篮子》   </p><p>9、夜幕低垂的街道，傍晚的香气，着灯的房子，与朋友说拜拜，回到家里，<br>有人在等我回来，用笑脸迎接我的，温柔的人。（鱼谷卯绪）<br>————《水果篮子》   </p><p>10、也许根本没有人是从一开始，就带着“意义”出生的，大家<br>可能都必须自己去发现，寻找……也许所谓的意义，也许暧昧<br>而不确定，或许还很不安定。但是，只要活着，就会想要知道<br>那个意义……为了某个人而活着的自己。（本田透）<br>————《水果篮子》   </p><p>11、饭团和酸梅：这个世界上所有人的背后都有着各式个样，不同颜色，<br>不同味道的酸梅。可是因为都附在背后，所以就无法看到酸梅。当你羡慕他人，<br>只是因为你可以看到别人背后的酸梅而已吧了，自己会以为一无所有，<br>只是白米而已，其实不是这样的，你的背后也有属于自己的酸梅。（本田透）<br>————《水果篮子》   </p><p>小透:假设说 每个人身上的优点就像饭团上粘着的梅子,那样子那颗梅子可能就是粘在背后.全世界的每个人都粘着各种形状,各种颜色和各种味道的梅子,不过因为是粘在背后的关系,所以大家看不到这难得的梅子,而说:”其实我什麽也没有,只是一团白米而已” 但事实上并不是那样.其实每个人背后确实粘着梅子.当自己会去羡慕别人的时候,可能是因为看到别人背后的梅子吧   </p><p>小透:没关系或许现在正在羡慕着某人,也或许正向往着自己并没有发现的优点.一旦会那样想的就会开始有:只要,自己再努力一点点.的这种想法.   </p><p>红叶:不过我想我还是希望能够带着这个回忆活下去,就算只是悲伤的回忆,即使是让我痛苦的回忆,又或者是让我很想忘掉的回忆,如果我能够勇敢的去接受而不去逃避,总有一天,我一定能够变得坚强,而不再害怕这些回忆,我是这麽相信的,我想相信.因为我要自己这麽去想:没有任何回忆,即使遗忘也好的.所以我其实我也并不希望妈妈忘记,我真的希望,可是这只是我一个,一个任性的愿望而已.   </p><p>小透:我也相信,不管怎样的回忆,我也都铭记在心,我也相信,没有任何回忆即使遗忘也好的.总有一天,做个不在害怕那些记忆的我,然后总有一天超越一切,让回忆永远珍重的藏在心底,我相信.   </p><p>小透:可是其实真的必须了解的,不能忘记的,是孩提时的自己,第一次违抗父母的那一天,第一次被骂得很惨的那一天,如果孩提时的心情能够一直铭记在心,这样就算长大成人,变成父母,也是相互可以理解的,即使无法做到百分之百.但应该可以让彼此的心更加靠近.   </p><p>由希:我认为要勇敢面对,而面对最重要的就是敢于挑战胆怯的心.   </p><p>阿夹:如果不能真心爱我的话,那就别说了,我害怕这正是造成了逼着我看的结果,但妈妈只是嘴里说说,并没有看着我,我希望和她一起,伤心,害怕也没有关系,就算妈妈不喜欢我丑陋的外表,但我还是希望能跟她生活在一起.   </p><p>小透: 与其去怀疑别人,不如去相信别人.相信别人可以成为帮助别人的力量.   </p><p>小透: 真是一个人的时候,有时会很痛苦,会感到寂寞无奈,可是有时候也会很开心 </p><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> 语录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
