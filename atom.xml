<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-02-11T05:34:19.401Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wget报错处理无法解析主机</title>
    <link href="http://ai.mak.cn/2023/02/08/%E7%BD%91%E7%BB%9C/wget%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E4%B8%BB%E6%9C%BA/"/>
    <id>http://ai.mak.cn/2023/02/08/%E7%BD%91%E7%BB%9C/wget%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E4%B8%BB%E6%9C%BA/</id>
    <published>2023-02-07T16:00:00.000Z</published>
    <updated>2023-02-11T05:34:19.401Z</updated>
    
    <content type="html"><![CDATA[<p>centos上准备更新一下国内的yum镜像源，更新时报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">正在解析主机 mirrors.aliyun.com (mirrors.aliyun.com)... 失败：未知的名称或服务。</span><br><span class="line">wget: 无法解析主机地址 “mirrors.aliyun.com”</span><br><span class="line">使用wget命令显示无法解析主机地址</span><br></pre></td></tr></table></figure><ul><li>检查网络配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi /etc/sysconfig/network-scripts/ifcfg-ensWifi5</span></span><br></pre></td></tr></table></figure><ul><li>在网卡中查看DNS，如果没有8.8.8.8，就加一个DNS上去</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ensWifi5</span><br><span class="line">UUID=4f28ed1b-9cc1-4a2f-8c2a-b09435fff313</span><br><span class="line">DEVICE=ensWifi5</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.100.151</span><br><span class="line">DNS1=192.168.100.151</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">GATEWAY=192.168.100.1</span><br></pre></td></tr></table></figure><ul><li>退出重启网络</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemctl restart network</span></span><br></pre></td></tr></table></figure><p>再次执行wget命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;centos上准备更新一下国内的yum镜像源，更新时报错：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="linux" scheme="http://ai.mak.cn/categories/linux/"/>
    
    
    <category term="Linux" scheme="http://ai.mak.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浦口龙虎巷</title>
    <link href="http://ai.mak.cn/2023/02/05/%E6%9D%82%E8%AE%B0/%E6%B5%A6%E5%8F%A3%E9%BE%99%E8%99%8E%E5%B7%B7/"/>
    <id>http://ai.mak.cn/2023/02/05/%E6%9D%82%E8%AE%B0/%E6%B5%A6%E5%8F%A3%E9%BE%99%E8%99%8E%E5%B7%B7/</id>
    <published>2023-02-04T16:00:00.000Z</published>
    <updated>2023-02-07T12:38:40.378Z</updated>
    
    <content type="html"><![CDATA[<p>偶然路过这条街巷，很多建筑像北方的风格，游览一番，也了解了一段历史～龙虎巷，沿线是津派建筑，最早的建筑建于清光绪三十四年，清末民初时期随着浦镇车辆厂在南门建立，职工在此在原有明清建筑(徽派）的基础上改建后用于办公居住，逐步形成了北方津派建筑群，是近现代南京大工业初始期产业形成的重要证物，这里住民北方籍居多（天津、唐山人等），老南门话也夹杂了许多天津味，显得比较俏皮，历史的车轮缓缓前进，往日的喧闹已经回归平淡与平静，一座座老房子已经挂上了文保的标牌与简介，就像老房子里的一盆盆小花，一树树盆景，宁静而安详。</p><iframe height=498 width=510 src='' frameborder=0 'allowfullscreen'></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;偶然路过这条街巷，很多建筑像北方的风格，游览一番，也了解了一段历史～龙虎巷，沿线是津派建筑，最早的建筑建于清光绪三十四年，清末民初时期随着浦镇车辆厂在南门建立，职工在此在原有明清建筑(徽派）的基础上改建后用于办公居住，逐步形成了北方津派建筑群，是近现代南京大工业初始期产业形</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>走运，走运，不走出来，哪来的运气</title>
    <link href="http://ai.mak.cn/2023/02/04/%E6%9D%82%E8%AE%B0/%E8%B5%B0%E8%BF%90%EF%BC%8C%E8%B5%B0%E8%BF%90%EF%BC%8C%E4%B8%8D%E8%B5%B0%E5%87%BA%E6%9D%A5%EF%BC%8C%E5%93%AA%E6%9D%A5%E7%9A%84%E8%BF%90%E6%B0%94/"/>
    <id>http://ai.mak.cn/2023/02/04/%E6%9D%82%E8%AE%B0/%E8%B5%B0%E8%BF%90%EF%BC%8C%E8%B5%B0%E8%BF%90%EF%BC%8C%E4%B8%8D%E8%B5%B0%E5%87%BA%E6%9D%A5%EF%BC%8C%E5%93%AA%E6%9D%A5%E7%9A%84%E8%BF%90%E6%B0%94/</id>
    <published>2023-02-03T16:00:00.000Z</published>
    <updated>2023-02-05T14:42:54.360Z</updated>
    
    <content type="html"><![CDATA[<p>骑行路上遇到一个老兵问路，刚好方向一致，就一起聊了一会儿，疫情好转了，老战友们让他组织个团聚活动，就出来探探路了。<br>老兵今年72了，精神特别好，看上相当年轻，之前的工作涉及科研保密，75岁前不能使用网络，又不想麻烦儿女，就自己出门乘车问路，自己也是好久没来过江北，一路上聊到了浦口的变化，和自己曾工作地方的变化，感叹祖国的强大，说了自己好多经历，还曾救过3个人，脊柱有6次受伤，平时都要用束带，但自己走路多，心态也好，到这个岁数也没驼背。<br>临别送了我一句话，“走运，走运，不走出来，哪来的运气”。<br>– 身体，和心态都要能及时的调整</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;骑行路上遇到一个老兵问路，刚好方向一致，就一起聊了一会儿，疫情好转了，老战友们让他组织个团聚活动，就出来探探路了。&lt;br&gt;老兵今年72了，精神特别好，看上相当年轻，之前的工作涉及科研保密，75岁前不能使用网络，又不想麻烦儿女，就自己出门乘车问路，自己也是好久没来过江北，一路</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用图数据库 Nebula Graph 数据导入快速体验知识图谱 OwnThink</title>
    <link href="http://ai.mak.cn/2023/01/28/ai/%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%20Nebula%20Graph%20%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%20OwnThink/"/>
    <id>http://ai.mak.cn/2023/01/28/ai/%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%20Nebula%20Graph%20%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%20OwnThink/</id>
    <published>2023-01-27T16:00:00.000Z</published>
    <updated>2023-01-29T06:28:38.930Z</updated>
    
    <content type="html"><![CDATA[<p>本文由 Nebula Graph 实习生@王杰贡献。</p><p>最近 @Yener 开源了史上最大规模的中文知识图谱——OwnThink（链接：<a href="https://github.com/ownthink/KnowledgeGraphData">https://github.com/ownthink/KnowledgeGraphData</a> ），数据量为 1.4 亿条。</p><p>本文介绍如何将这份数据快速导入图数据库 Nebula Graph，全过程大约需要 30 分钟。</p><h2 id="中文知识图谱-OwnThink-简介"><a href="#中文知识图谱-OwnThink-简介" class="headerlink" title="中文知识图谱 OwnThink 简介"></a>中文知识图谱 OwnThink 简介</h2><h3 id="思知（OwnThink）"><a href="#思知（OwnThink）" class="headerlink" title="思知（OwnThink）"></a>思知（OwnThink）</h3><p>知识图谱是由 Google 在 2012 年提出来的一个概念。主要是用来<strong>描述真实世界中存在的各种实体和概念，以及他们之间的关系</strong>。在搜索引擎、问答机器人、知识抽取等多个领域有着诸多应用。</p><p>最近 Yener 开源了史上最大规模的中文知识图谱—— OwnThink（链接：<a href="https://github.com/ownthink/KnowledgeGraphData%EF%BC%89%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%BA">https://github.com/ownthink/KnowledgeGraphData），数据量为</a> 1.4 亿条。数据以 (实体, 属性, 值) 和 (实体, 关系, 实体) 混合的<strong>三元组</strong>形式存储，数据格式为 csv。</p><p>可以点击这里下载：<a href="https://nebula-graph.oss-accelerate.aliyuncs.com/ownthink/kg_v2.tar.gz">https://nebula-graph.oss-accelerate.aliyuncs.com/ownthink/kg_v2.tar.gz</a></p><h3 id="查看原始文件"><a href="#查看原始文件" class="headerlink" title="查看原始文件"></a>查看原始文件</h3><p>由于 ownthink_v2.csv 数据过多，摘录部分数据为例：</p><table><thead><tr><th>1 2 3 4 5 6 7 8 9 10</th><th>红色食品,描述,红色食品是指食品为红色、橙红色或棕红色的食品。 红色食品,是否含防腐剂,否 红色食品,主要食用功效,预防感冒，缓解疲劳 红色食品,用途,增强表皮细胞再生和防止皮肤衰老 大龙湫,描述,雁荡山景区分散，东起羊角洞，西至锯板岭；南起筋竹溪，北至六坪山。 大龙湫,中文名称,大龙湫 大龙湫,外文名称,big dragon autrum 大龙湫,门票价格,50元 大龙湫,著名景点,芙蓉峰 姚明[中国篮球协会主席、中职联公司董事长],妻子,叶莉</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里的 (红色食品,是否含防腐剂,否) 就是典型的 (实体, 属性, 值) 形式的三元组数据; 而 (姚明[中国篮球协会主席、中职联公司董事长],妻子,叶莉) 是典型的 (实体, 关系, 实体) 形式的三元组数据。</p><h2 id="Step-1-数据建模与清洗准备"><a href="#Step-1-数据建模与清洗准备" class="headerlink" title="Step 1. 数据建模与清洗准备"></a>Step 1. 数据建模与清洗准备</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>Nebula Graph 是一个开源的分布式图数据库（链接：<a href="https://github.com/vesoft-inc/nebula%EF%BC%89%EF%BC%8C%E7%9B%B8%E6%AF%94">https://github.com/vesoft-inc/nebula），相比</a> Neo4j 来说，它的主要特点是完全的分布式，因此<strong>图数据库 Nebula Graph 适合处理数据量超过单机的场景</strong>。</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69341543-b9d2ef00-0ca4-11ea-8615-bb9d0e33c74a.png" alt="GitHub 主页"></p><p>图数据库<strong>通常支持的数据模型为有向属性图（directed property graph）</strong>。图中的每个顶点（vertex）可以用标签（tag）来表示类型（Neo4j 叫做 Label），顶点和顶点之间的关系用边（edge）连接起来。每种 tag 和 edge 还可以带有属性。——然而，这些功能对于知识图谱的三元组数据没什么意义:</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324280-263cf680-0c83-11ea-8195-3facde5c0bcd.png" alt="image"></p><p>分析上图的三元组数据，发现无论是 (实体, 属性, 值) 形式的三元组数据，还是 (实体, 关系, 实体) 形式的三元组数据，每条三元组数据均可以建模成<strong>两个点</strong>和<strong>一条边</strong>的形式。前者三元组中的“<strong>实体</strong>”和“<strong>值</strong>”建模为<strong>两个点</strong>（起点、终点），“<strong>属性</strong>”建模为<strong>一条边</strong>，后者三元组中的两个“<strong>实体</strong>”也建模为<strong>两个点</strong>（起点、终点），“<strong>关系</strong>”建模为<strong>一条边</strong>.</p><p>而且，所有的点都是相同类型（取名叫entity ），只需要一个属性（叫 name )，所有的边也都是同一类型(取名叫 relation ），边上也只有一个属性（叫 name ）。</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324336-3bb22080-0c83-11ea-9672-a0eb3a355f97.png" alt="image"></p><p>比如 (大龙湫,著名景点,芙蓉峰) 可以表示成下图这个样子：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324347-3f45a780-0c83-11ea-94bb-a1dd0df6ebef.png" alt="image"></p><h3 id="数据清洗和预处理"><a href="#数据清洗和预处理" class="headerlink" title="数据清洗和预处理"></a>数据清洗和预处理</h3><p>按照前一节的分析，原始的每条<strong>三元组数据</strong>，还需要清洗<strong>转换为两个点和一条边</strong>才能变成属性图的模型。</p><h4 id="下载清洗工具"><a href="#下载清洗工具" class="headerlink" title="下载清洗工具"></a>下载清洗工具</h4><p>本文测试的时候，使用的操作系统是 CentOS 7.5，工具由 Golang 语言编写而成。</p><p>你可以在这里 (链接：<a href="https://github.com/jievince/rdf-converter">https://github.com/jievince/rdf-converter</a>) 下载这个简单的清洗工具源代码并编译使用。</p><p>该工具会把转换后的顶点的数据写入到 vertex.csv 文件、边数据写入到 edge.csv 文件。</p><p>说明：在测试过程中，发现有大量的重复点数据，所以工具里面也做了去重。完全去重后的点的数据大概是 4600 万条，完全去重后的边的数据大概是 1 亿 4000 万条。</p><p>清洗完的 vertex.csv 文件长这样：</p><table><thead><tr><th>1 2 3 4 5 6 7 8</th><th>-2469395383949115281,过度包装 -5567206714840433083,Over  Package 3836323934884101628,有的商品故意增加包装层数 1185893106173039861,很多采用实木、金属制品 3455734391170888430,非科学 9183164258636124946,教育 5258679239570815125,成熟市场 -8062106589304861485,”成熟市场是指低增长率,高占有率的市场。”</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>说明：每一行是一个顶点，第一列整型 -2469395383949115281 是顶点的 ID（叫做 VID），它是由第二列文字通过 hash 计算出来的，例如 -2469395383949115281 就是由 std::hash(“过度包装”) 计算出来的值。</p><p>清洗完的 edge.csv 文件:</p><table><thead><tr><th>1 2 3 4 5 6 7 8 9 10</th><th>3413383836870836248,-948987595135324087,含义 3413383836870836248,8037179844375033188,定义 3413383836870836248,-2559124418148243756,标签 3413383836870836248,8108596883039039864,标签 2587975790775251569,-4666568475926279810,描述 2587975790775251569,2587975790775251569,中文名称 2587975790775251569,3771551033890875715,外文名称 2587975790775251569,2900555761857775043,地理位置 2587975790775251569,-1913521037799946160,占地面积 2587975790775251569,-1374607753051283066,开放时间</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>说明：第一列是起点的 VID，第二列是终点的 VID，第三列是这条边的”<strong>属性</strong>“或者”<strong>描述</strong>“。</p><p>在本机完全去重的清洗程序运行时间大约是 6 分钟。</p><h2 id="Step-2-Nebula-Graph-启动准备"><a href="#Step-2-Nebula-Graph-启动准备" class="headerlink" title="Step 2. Nebula Graph 启动准备"></a>Step 2. Nebula Graph 启动准备</h2><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><p>登陆 GitHub 后，在这里 (链接：<a href="https://github.com/vesoft-inc/nebula/actions">https://github.com/vesoft-inc/nebula/actions</a>) 找到 Nebula 的安装包。</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69341796-3239b000-0ca5-11ea-8050-30d4d85c4e4d.png" alt="action"></p><p>找到你所用系统对应的下载链接：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69344341-32887a00-0caa-11ea-9065-b4a4ec6154ba.png" alt="package"></p><p>笔者系统是 CentOS 7.5，下载 CentOS 7.5 最新的压缩包，解压后能找到 rpm 安装包 nebula-5ace754.el7-5.x86_64.rpm，注意 5ace754 是 git commit 号，使用时可能会有所不同。下载好后解压，输入下面命令进行安装，记得替换成新的 git commit：</p><table><thead><tr><th>1</th><th>$ rpm -ivh nebula-5ace754.el7-5.x86_64.rpm</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="启动-Nebula-Graph-服务"><a href="#启动-Nebula-Graph-服务" class="headerlink" title="启动 Nebula Graph 服务"></a>启动 Nebula Graph 服务</h3><p>在 命令行 CLI 输入下面命令启动服务</p><table><thead><tr><th>1</th><th>$ &#x2F;usr&#x2F;local&#x2F;nebula&#x2F;scripts&#x2F;nebula.service start all</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>命令执行结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324527-99df0380-0c83-11ea-9887-148143c18641.png" alt="image"></p><p>可以执行以下命令检查服务是否成功启动</p><table><thead><tr><th>1</th><th>$ &#x2F;usr&#x2F;local&#x2F;nebula&#x2F;scripts&#x2F;nebula.service status all</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>命令执行结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324588-b24f1e00-0c83-11ea-9f58-30f205bce272.png" alt="image"></p><h3 id="连接-Nebula-Graph-服务"><a href="#连接-Nebula-Graph-服务" class="headerlink" title="连接 Nebula Graph 服务"></a>连接 Nebula Graph 服务</h3><p>输入下面命令连接 Nebula Graph：</p><table><thead><tr><th>1</th><th>$ &#x2F;usr&#x2F;local&#x2F;nebula&#x2F;bin&#x2F;nebula -u user -p password</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>命令执行结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324631-c72bb180-0c83-11ea-9c32-ac349f9e3c9f.png" alt="image"></p><h3 id="准备-schema-等元数据"><a href="#准备-schema-等元数据" class="headerlink" title="准备 schema 等元数据"></a>准备 schema 等元数据</h3><p>Nebula Graph 的使用风格有点接近 MySQL，需要先准备各种元信息。</p><h4 id="新建图空间-space"><a href="#新建图空间-space" class="headerlink" title="新建图空间 space"></a>新建图空间 space</h4><p>create space 的概念接近 MySQL 里面 create database。在 nebula console 里面输入下面这个命令。</p><table><thead><tr><th>1</th><th>nebula&gt; CREATE SPACE test;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="进入-test-space"><a href="#进入-test-space" class="headerlink" title="进入 test space"></a>进入 test space</h4><table><thead><tr><th>1</th><th>nebula&gt; USE test;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="创建点类型（entity）"><a href="#创建点类型（entity）" class="headerlink" title="创建点类型（entity）"></a>创建点类型（entity）</h4><table><thead><tr><th>1</th><th>nebula&gt; CREATE TAG entity(name string);</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="创建边类型-relation"><a href="#创建边类型-relation" class="headerlink" title="创建边类型 (relation)"></a>创建边类型 (relation)</h4><table><thead><tr><th>1</th><th>nebula&gt; CREATE EDGE relation(name string);</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>最后简单确认下元数据是不是正确。</p><p><strong>查看 entity 标签的属性</strong>：</p><table><thead><tr><th>1</th><th>nebula&gt; DESCRIBE TAG entity;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324705-e591ad00-0c83-11ea-9d5c-4172b146b762.png" alt="image"></p><p><strong>查看 relation 边类型的属性</strong>：</p><table><thead><tr><th>1</th><th>nebula&gt; DESCRIBE EDGE relation;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324702-e4f91680-0c83-11ea-80f8-293680b4a630.png" alt="image"></p><h2 id="Step-3-使用-nebula-importer-导入数据"><a href="#Step-3-使用-nebula-importer-导入数据" class="headerlink" title="Step 3. 使用 nebula-importer 导入数据"></a>Step 3. 使用 nebula-importer 导入数据</h2><p>登陆 GitHub 进入 <a href="https://github.com/vesoft-inc/nebula-importer">https://github.com/vesoft-inc/nebula-importer</a> ，nebula-importer 这个工具也是 Golang 语言写的，在这里下载并编译源代码。</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69342573-cb1cfb00-0ca6-11ea-8761-b5acbdcec5ae.png" alt="importer"></p><p>另外，准备一个 YAML 配置文件，告诉这个 importer 工具去哪里找 csv 文件。（可直接复制下面这段）</p><table><thead><tr><th>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42</th><th>version: v1rc1 description: example clientSettings:  concurrency: 10 # number of graph clients  channelBufferSize: 128  space: test  connection:   user: user   password: password   address: 127.0.0.1:3699 logPath: .&#x2F;err&#x2F;test.log files: - path: .&#x2F;vertex.csv   failDataPath: .&#x2F;err&#x2F;vertex.csv   batchSize: 100   type: csv   csv:    withHeader: false    withLabel: false   schema:    type: vertex    vertex:     tags:      - name: entity       props:        - name: name         type: string  - path: .&#x2F;edge.csv   failDataPath: .&#x2F;err&#x2F;edge.csv   batchSize: 100   type: csv   csv:    withHeader: false    withLabel: false   schema:    type: edge    edge:     name: relation     withRanking: false     props:      - name: name       type: string</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>说明：测试时候发现 csv 数据文件中有大量转义字符 () 和换行字符 (<br>)，nebula-importer 也做了处理。</p><p>最后：开始导入数据 ????</p><table><thead><tr><th>1</th><th>go run importer.go –config .&#x2F;config.yaml</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>执行过程如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324800-15d94b80-0c84-11ea-9d0e-6e1428c2de84.png" alt="image"></p><p>可以看到, 本次导入 QPS 大约在 40 w&#x2F;s。全部导入总耗时大约 15 min。</p><h2 id="Step-4-随便读点什么试试"><a href="#Step-4-随便读点什么试试" class="headerlink" title="Step 4. 随便读点什么试试"></a>Step 4. 随便读点什么试试</h2><p>导入完毕后，我们可以使用 Nebula Graph 服务做一些简单的查询。回到 Nebula Graph 的命令行 CLI ：</p><table><thead><tr><th>1</th><th>$ &#x2F;usr&#x2F;local&#x2F;nebula&#x2F;bin&#x2F;nebula -u user -p password</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>进入刚才导入的三元组数据的 test 空间：</p><table><thead><tr><th>1</th><th>nebula&gt; USE test;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>现在，我们可以做一些简单查询</p><ul><li>例 1：与姚明有直接关联的边的类型和点的属性</li></ul><table><thead><tr><th>1</th><th>(<a href="mailto:&#117;&#115;&#x65;&#114;&#x40;&#49;&#50;&#x37;&#x2e;&#x30;&#46;&#x30;&#46;&#x31;">&#117;&#115;&#x65;&#114;&#x40;&#49;&#50;&#x37;&#x2e;&#x30;&#46;&#x30;&#46;&#x31;</a>) [test]&gt; GO FROM hash(“姚明[中国篮球协会主席、中职联公司董事长]”) OVER relation  YIELD relation.name AS Name, $$.entity.name AS Value;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>执行结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69342925-834aa380-0ca7-11ea-8e71-1d7620320187.png" alt="result"></p><p>可以看到：本次查询返回 51 条数据，耗时 3 ms 左右；</p><ul><li>例2：查询姚明和其妻子叶莉在三跳之内的所有路径</li></ul><table><thead><tr><th>1</th><th>(<a href="mailto:&#117;&#x73;&#101;&#114;&#x40;&#49;&#x32;&#x37;&#x2e;&#48;&#x2e;&#48;&#x2e;&#x31;">&#117;&#x73;&#101;&#114;&#x40;&#49;&#x32;&#x37;&#x2e;&#48;&#x2e;&#48;&#x2e;&#x31;</a>) [test]&gt; FIND ALL PATH FROM hash(“姚明[中国篮球协会主席、中职联公司董事长]”)  TO hash(“叶莉”) OVER relation UPTO 3 STEPS;</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>执行结果如下：</p><p><img src="https://www.codenong.com/getimg.php?url=https://user-images.githubusercontent.com/56643819/69324938-520cac00-0c84-11ea-97e5-956f8c739f89.png" alt="image"></p><p>当数据量较大时，查找全路径&#x2F;最短经之类的操作会比较耗时。可以看到：本次查询返回 8 条数据，说明姚明和其妻子叶莉在三跳之内共有 8 条直接或间接的关系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章涉及到的一些概念和链接：</p><ul><li>OwnThink 的中文知识图谱数据：<a href="https://github.com/ownthink/KnowledgeGraphData%E3%80%82%E5%AE%83%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A5%E4%B8%89%E5%85%83%E7%BB%84%E5%BD%A2%E5%BC%8F%E4%BF%9D%E5%AD%98%E4%B8%BA">https://github.com/ownthink/KnowledgeGraphData。它的数据以三元组形式保存为</a> csv</li><li>Nebula Graph 是一个开源的图数据库，GitHub 地址：<a href="https://github.com/vesoft-inc/nebula%EF%BC%8C%E5%92%8C">https://github.com/vesoft-inc/nebula，和</a> Neo4j 相比，它是分布式的</li><li>数据清洗工具，GitHub 地址：<a href="https://github.com/jievince/rdf-converter%E3%80%82%E5%9B%A0%E4%B8%BA%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%9B%BE%E8%B0%B1">https://github.com/jievince/rdf-converter。因为原始的图谱</a> ownthink_v2.csv 数据以三元组形式保存，并和一般图数据库的属性图模型略微有些不同，所以写了一个 Go 语言工具将原始 ownthink_v2.csv 变成 vertex.csv 和 edge.csv</li><li>数据导入工具，GitHub 地址：<a href="https://github.com/vesoft-inc/nebula-importer%E3%80%82%E5%B0%86%E6%B8%85%E6%B4%97%E5%AE%8C%E7%9A%84">https://github.com/vesoft-inc/nebula-importer。将清洗完的</a> vertex.csv 和 edge.csv 批量写入到 Nebula Graph。</li></ul><h3 id="后面的工作"><a href="#后面的工作" class="headerlink" title="后面的工作"></a>后面的工作</h3><ul><li>调整 Nebula 的参数。似乎默认的日志级别和内存都不是很好，可以用下面这个命令关闭日志，这样导入性能可以好很多。</li></ul><table><thead><tr><th>1</th><th>curl “<a href="http://127.0.0.1:12000/set_flags?flag=minloglevel&amp;value=4&quot;">http://127.0.0.1:12000/set_flags?flag=minloglevel&amp;value=4&quot;</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><ul><li>写个对应的 Python 版本示例</li></ul><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>Nebula Graph GitHub 地址：<a href="https://github.com/vesoft-inc/nebula">https://github.com/vesoft-inc/nebula</a> ，加入 Nebula Graph 交流群，请联系 Nebula Graph 官方小助手微信号：NebulaGraphbot</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文由 Nebula Graph 实习生@王杰贡献。&lt;/p&gt;
&lt;p&gt;最近 @Yener 开源了史上最大规模的中文知识图谱——OwnThink（链接：&lt;a href=&quot;https://github.com/ownthink/KnowledgeGraphData&quot;&gt;https:</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="知识图谱" scheme="http://ai.mak.cn/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-02-03T07:54:03.371Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://aimak.cn/kg_editor/index.html">知识图谱编辑器链接</a></p><h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://aimak.cn/kg_editor/index.html&quot;&gt;知识图谱编辑器链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 </summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="知识图谱" scheme="http://ai.mak.cn/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>通俗易懂的知识图谱技术与应用指南</title>
    <link href="http://ai.mak.cn/2022/12/12/ai/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://ai.mak.cn/2022/12/12/ai/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2022-12-11T16:00:00.000Z</published>
    <updated>2023-02-03T01:41:09.755Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 机器之心</p><h1 id="这是一份通俗易懂的知识图谱技术与应用指南"><a href="#这是一份通俗易懂的知识图谱技术与应用指南" class="headerlink" title="这是一份通俗易懂的知识图谱技术与应用指南"></a>这是一份通俗易懂的知识图谱技术与应用指南</h1><blockquote><p>从一开始的Google搜索，到现在的聊天机器人、大数据风控、证券投资、智能医疗、自适应教育、推荐系统，无一不跟知识图谱相关。它在技术领域的热度也在逐年上升。 本文以通俗易懂的方式来讲解知识图谱相关的知识、尤其对从零开始搭建知识图谱过程当中需要经历的步骤以及每个阶段需要考虑的问题都给予了比较详细的解释。 对于读者，我们不要求有任何AI相关的背景知识。</p></blockquote><p><strong>目录：</strong></p><blockquote><ol><li>概论</li><li>什么是知识图谱</li><li>知识图谱的表示</li><li>知识抽取</li><li>知识图谱的存储</li><li>金融知识图谱的搭建</li><li><ol><li>定义具体的业务问题</li><li>数据收集 &amp; 预处理</li><li>知识图谱的设计</li><li>把数据存入知识图谱</li><li>上层应用的开发</li></ol></li><li>知识图谱在其他行业中的应用</li><li>实践上的几点建议</li><li>结语</li></ol></blockquote><p><strong>1. 概论</strong></p><p>随着移动互联网的发展，万物互联成为了可能，这种互联所产生的数据也在爆发式地增长，而且这些数据恰好可以作为分析关系的有效原料。如果说以往的智能分析专注在每一个个体上，在移动互联网时代则除了个体，这种个体之间的关系也必然成为我们需要深入分析的很重要一部分。 在一项任务中，只要有关系分析的需求，知识图谱就“有可能”派的上用场。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/44edd4e8-bce9-4222-a0e2-667a6247b566/1529464461120.png"></p><p><strong>2. 什么是知识图谱？</strong></p><p>知识图谱是由Google公司在2012年提出来的一个新的概念。从学术的角度，我们可以对知识图谱给一个这样的定义：<strong>“知识图谱本质上是语义网络（Semantic Network）的知识库”</strong>。但这有点抽象，所以换个角度，从实际应用的角度出发其实<strong>可以简单地把知识图谱理解成多关系图（Multi-relational Graph）。</strong> </p><p>那什么叫多关系图呢？ 学过数据结构的都应该知道什么是图（Graph）。图是由节点（Vertex）和边（Edge）来构成，但这些图通常只包含一种类型的节点和边。但相反，<strong>多关系图一般包含多种类型的节点和多种类型的边</strong>。比如左下图表示一个经典的图结构，右边的图则表示多关系图，因为图里包含了多种类型的节点和边。这些类型由不同的颜色来标记。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/6c48a6ae-d3da-45e7-9ae5-dff162b14259/1529464461356.png"></p><p>﻿在知识图谱里，我们通常用“实体（Entity）”来表达图里的节点、用“关系（Relation）”来表达图里的“边”。<strong>实体****指的是现实世界中的事物比如人、地名、概念、药物、公司等</strong>，<strong>关系<strong><strong>则用来</strong></strong>表达不同实体之间的某种联系，</strong>比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。</p><p>现实世界中的很多场景非常适合用知识图谱来表达。 比如一个社交网络图谱里，我们既可以有“人”的实体，也可以包含“公司”实体。人和人之间的关系可以是“朋友”，也可以是“同事”关系。人和公司之间的关系可以是“现任职”或者“曾任职”的关系。 类似的，一个风控知识图谱可以包含“电话”、“公司”的实体，电话和电话之间的关系可以是“通话”关系，而且每个公司它也会有固定的电话。 </p><p><img src="https://image.jiqizhixin.com/uploads/editor/37d26d3a-403f-46db-95ec-868807c40e72/1529464461243.png"></p><p><strong>3. 知识图谱的表示</strong></p><p><strong>知识图谱应用的前提是已经构建好了知识图谱</strong>，也可以把它认为是一个知识库。这也是为什么它可以用来回答一些搜索相关问题的原因，比如在Google搜索引擎里输入“Who is the wife of Bill Gates?”，我们直接可以得到答案-“Melinda Gates”。这是因为我们在系统层面上已经创建好了一个包含“Bill Gates”和“Melinda Gates”的实体以及他俩之间关系的知识库。所以，当我们执行搜索的时候，就可以通过关键词提取（”Bill Gates”, “Melinda Gates”, “wife”）以及知识库上的匹配可以直接获得最终的答案。这种搜索方式跟传统的搜索引擎是不一样的，一个传统的搜索引擎它返回的是网页、而不是最终的答案，所以就多了一层用户自己筛选并过滤信息的过程。  </p><p><img src="https://image.jiqizhixin.com/uploads/editor/feba145f-072a-4d3d-9a31-13fe3fd96d64/1529464461457.png"></p><p>﻿在现实世界中，实体和关系也会拥有各自的属性，比如人可以有“姓名”和“年龄”。<strong>当一个知识图谱拥有属性时，我们可以用属性图（Property Graph）来表示</strong>。下面的图表示一个简单的属性图。李明和李飞是父子关系，并且李明拥有一个138开头的电话号，这个电话号开通时间是2018年，其中2018年就可以作为关系的属性。类似的，李明本人也带有一些属性值比如年龄为25岁、职位是总经理等。 </p><p><img src="https://image.jiqizhixin.com/uploads/editor/37c1849a-26e6-4b37-8e77-e1d3190be1b9/1529464461565.png" alt="img"></p><p>﻿这种属性图的表达很贴近现实生活中的场景，也可以很好地描述业务中所包含的逻辑。除了属性图，知识图谱也可以用RDF来表示，它是由很多的三元组（Triples）来组成。RDF在设计上的主要特点是易于发布和分享数据，但不支持实体或关系拥有属性，如果非要加上属性，则在设计上需要做一些修改。目前来看，RDF主要还是用于学术的场景，在工业界我们更多的还是采用图数据库（比如用来存储属性图）的方式。感兴趣的读者可以参考RDF的相关文献，在文本里不多做解释。</p><p><strong>4. 知识抽取</strong></p><p>知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。对于垂直领域的知识图谱来说，<strong>它们的数据源主要来自两种渠道：一种是业务本身的数据，这部分数据通常包含在公司内的数据库表并以结构化的方式存储；另一种是网络上公开、抓取的数据，这些数据通常是以网页的形式存在所以是非结构化的数据。</strong></p><p>前者一般只需要简单预处理即可以作为后续AI系统的输入，但后者一般需要借助于自然语言处理等技术来提取出结构化信息。比如在上面的搜索例子里，Bill Gates和Malinda Gate的关系就可以从非结构化数据中提炼出来，比如维基百科等数据源。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/1b15c7ec-db91-4e83-9f3c-dd929aba4251/1529464461642.png" alt="img"></p><p>信息抽取的难点在于处理非结构化数据。在下面的图中，我们给出了一个实例。左边是一段非结构化的英文文本，右边是从这些文本中抽取出来的实体和关系。在构建类似的图谱过程当中，主要涉及以下几个方面的自然语言处理技术：  </p><blockquote><p>a. 实体命名识别（Name Entity Recognition）   </p><p>b. 关系抽取（Relation Extraction）   </p><p>c. 实体统一（Entity Resolution）   </p><p>d. 指代消解（Coreference Resolution）</p></blockquote><p>下面针对每一项技术解决的问题做简单的描述，以至于这些是具体怎么实现的，不在这里一一展开，感兴趣的读者可以查阅相关资料，或者学习我的课程。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/6fa7f018-818d-4b56-9707-e912e43380ea/1529464462113.png" alt="img"></p><p>﻿首先是实体命名识别，就是从文本里提取出实体并对每个实体做分类&#x2F;打标签：比如从上述文本里，我们可以提取出实体-“NYC”，并标记实体类型为 “Location”；我们也可以从中提取出“Virgil’s BBQ”，并标记实体类型为“Restarant”。这种过程称之为实体命名识别，这是一项相对比较成熟的技术，有一些现成的工具可以用来做这件事情。其次，我们可以通过关系抽取技术，把实体间的关系从文本中提取出来，比如实体“hotel”和“Hilton property”之间的关系为“in”；“hotel”和“Time Square”的关系为“near”等等。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/6a5b9af1-4ff8-48f0-a8d5-8160cac10749/1529464461751.png" alt="img"></p><p>﻿另外，在实体命名识别和关系抽取过程中，有两个比较棘手的问题：一个是实体统一，也就是说有些实体写法上不一样，但其实是指向同一个实体。比如“NYC”和“New York”表面上是不同的字符串，但其实指的都是纽约这个城市，需要合并。实体统一不仅可以减少实体的种类，也可以降低图谱的稀疏性（Sparsity）；另一个问题是指代消解，也是文本中出现的“it”, “he”, “she”这些词到底指向哪个实体，比如在本文里两个被标记出来的“it”都指向“hotel”这个实体。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/1aba276c-39c3-48af-9748-7b47d9555518/1529464462241.png" alt="img"></p><p>实体统一和指代消解问题相对于前两个问题更具有挑战性。</p><p><strong>5. 知识图谱的存储</strong></p><p><strong>知识图谱主要有两种存储方式：一种是基于RDF的存储；另一种是基于图数据库的存储。</strong>它们之间的区别如下图所示。RDF一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/6d23ee75-a606-46ac-9e00-3320a870c0e8/1529464461822.png" alt="img"></p><p>﻿根据最新的统计（2018年上半年），图数据库仍然是增长最快的存储系统。相反，关系型数据库的增长基本保持在一个稳定的水平。同时，我们也列出了常用的图数据库系统以及他们最新使用情况的排名。 其中Neo4j系统目前仍是使用率最高的图数据库，它拥有活跃的社区，而且系统本身的查询效率高，但唯一的不足就是不支持准分布式。相反，OrientDB和JanusGraph（原Titan）支持分布式，但这些系统相对较新，社区不如Neo4j活跃，这也就意味着使用过程当中不可避免地会遇到一些刺手的问题。如果选择使用RDF的存储系统，Jena或许一个比较不错的选择。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/c6767f42-c6cc-4ab2-a3d6-0f8c5b099e98/1529464462467.png" alt="img"></p><p><strong>6. 金融知识图谱的搭建</strong></p><p>接下来我们看一个实际的具体案例，讲解怎么一步步搭建可落地的金融风控领域的知识图谱系统。 首先需要说明的一点是，有可能不少人认为搭建一个知识图谱系统的重点在于算法和开发。但事实并不是想象中的那样，<strong>其实最重要的核心在于对业务的理解以及对知识图谱本身的设计</strong>，这就类似于对于一个业务系统，数据库表的设计尤其关键，而且这种设计绝对离不开对业务的深入理解以及对未来业务场景变化的预估。 当然，在这里我们先不讨论数据的重要性。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/904976bb-9e2e-42f6-b05e-bf6165da7599/1529464461970.png" alt="img"></p><p>一个完整的知识图谱的构建包含以下几个步骤：<strong>1. 定义具体的业务问题  2. 数据的收集 &amp; 预处理  3. 知识图谱的设计  4. 把数据存入知识图谱 5. 上层应用的开发，以及系统的评估。</strong>下面我们就按照这个流程来讲一下每个步骤所需要做的事情以及需要思考的问题。 </p><p><strong>6.1 定义具体的业务问题</strong></p><p>在P2P网贷环境下，最核心的问题是风控，也就是怎么去评估一个借款人的风险。在线上的环境下，欺诈风险尤其为严重，而且很多这种风险隐藏在复杂的关系网络之中，而且知识图谱正好是为这类问题所设计的，所以我们“有可能”期待它能在欺诈，这个问题上带来一些价值。 </p><p><img src="https://image.jiqizhixin.com/uploads/editor/1e5128bd-4184-42e9-8007-fcd81df3b7c2/1529464462563.png" alt="img"></p><p>在进入下一个话题的讨论之前，<strong>要明确的一点是，对于自身的业务问题到底需不需要知识图谱系统的支持</strong>。因为在很多的实际场景，即使对关系的分析有一定的需求，实际上也可以利用传统数据库来完成分析的。所以为了避免使用知识图谱而选择知识图谱，以及更好的技术选型，以下给出了几点总结，供参考。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/6eb56c75-30b2-44ac-9444-9ea328c17d44/1529464462653.png" alt="img"></p><p><strong>6.2 数据收集 &amp; 预处理</strong></p><p>下一步就是要确定数据源以及做必要的数据预处理。针对于数据源，我们需要考虑以下几点：1. 我们已经有哪些数据？ 2. 虽然现在没有，但有可能拿到哪些数据？ 3.  其中哪部分数据可以用来降低风险？ 4. 哪部分数据可以用来构建知识图谱？在这里需要说明的一点是，并不是所有跟反欺诈相关的数据都必须要进入知识图谱，对于这部分的一些决策原则在接下来的部分会有比较详细的介绍。</p><p>对于反欺诈，有几个数据源是我们很容易想得到的，包括用户的基本信息、行为数据、运营商数据、网络上的公开信息等等。假设我们已经有了一个数据源的列表清单，则下一步就要看哪些数据需要进一步的处理，比如对于非结构化数据我们或多或少都需要用到跟自然语言处理相关的技术。 用户填写的基本信息基本上会存储在业务表里，除了个别字段需要进一步处理，很多字段则直接可以用于建模或者添加到知识图谱系统里。对于行为数据来说，我们则需要通过一些简单的处理，并从中提取有效的信息比如“用户在某个页面停留时长”等等。 对于网络上公开的网页数据，则需要一些信息抽取相关的技术。</p><p>举个例子，对于用户的基本信息，我们很可能需要如下的操作。一方面，用户信息比如姓名、年龄、学历等字段可以直接从结构化数据库中提取并使用。但另一方面，对于填写的公司名来说，我们有可能需要做进一步的处理。比如部分用户填写“北京贪心科技有限公司”，另外一部分用户填写“北京望京贪心科技有限公司”，其实指向的都是同一家公司。所以，这时候我们需要做公司名的对齐，用到的技术细节可以参考前面讲到的实体对齐技术。﻿</p><p><img src="https://image.jiqizhixin.com/uploads/editor/8c99bd01-74e5-4368-b061-79a684ab18f6/1529464462813.png" alt="img"></p><p><strong>6.3 知识图谱的设计</strong></p><p>图谱的设计是一门艺术，不仅要对业务有很深的理解、也需要对未来业务可能的变化有一定预估，从而设计出最贴近现状并且性能高效的系统。在知识图谱设计的问题上，我们肯定会面临以下几个常见的问题：<strong>1. 需要哪些实体、关系和属性？ 2.  哪些属性可以做为实体，哪些实体可以作为属性？ 3. 哪些信息不需要放在知识图谱中？</strong> </p><p>基于这些常见的问题，我们从以往的设计经验中抽象出了一系列的设计原则。这些设计原则就类似于传统数据库设计中的范式，来引导相关人员设计出更合理的知识图谱系统，同时保证系统的高效性。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/96151c9c-e707-4913-83b9-897ea5ef75a7/1529464462717.png" alt="img"></p><p>接下来，我们举几个简单的例子来说明其中的一些原则。 首先是，业务原则（Business Principle），它的含义是 “<strong>一切要从业务逻辑出发，并且通过观察知识图谱的设计也很容易推测其背后业务的逻辑，而且设计时也要想好未来业务可能的变化</strong>”。</p><p>举个例子，可以观察一下下面这个图谱，并试问自己背后的业务逻辑是什么。通过一番观察，其实也很难看出到底业务流程是什么样的。做个简单的解释，这里的实体-“申请”意思就是application，如果对这个领域有所了解，其实就是进件实体。在下面的图中，申请和电话实体之间的“has_phone”，“parent phone”是什么意思呢？</p><p><img src="https://image.jiqizhixin.com/uploads/editor/4655bb9e-3bd0-4acf-bb81-f7d9825facc3/1529464462891.png" alt="img"></p><p>﻿接下来再看一下下面的图，跟之前的区别在于我们把申请人从原有的属性中抽取出来并设置成了一个单独的实体。在这种情况下，整个业务逻辑就变得很清晰，我们很容易看出张三申请了两个贷款，而且张三拥有两个手机号，在申请其中一个贷款的时候他填写了父母的电话号。总而言之，一个好的设计很容易让人看到业务本身的逻辑。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/f3fa7ea6-bf85-48fb-8583-4525e05d9074/1529464463668.png" alt="img"></p><p>﻿接下来再看一个原则叫做效率原则（Efficiency Principle）。 <strong>效率原则让知识图谱尽量轻量化、并决定哪些数据放在知识图谱，哪些数据不需要放在知识图谱</strong>。在这里举一个简单的类比，在经典的计算机存储系统中，我们经常会谈论到内存和硬盘，内存作为高效的访问载体，作为所有程序运行的关键。这种存储上的层次结构设计源于数据的局部性-“locality”，也就是说经常被访问到的数据集中在某一个区块上，所以这部分数据可以放到内存中来提升访问的效率。 类似的逻辑也可以应用到知识图谱的设计上：我们把常用的信息存放在知识图谱中，把那些访问频率不高，对关系分析无关紧要的信息放在传统的关系型数据库当中。 <strong>效率原则的核心在于把知识图谱设计成小而轻的存储载体。</strong></p><p><img src="https://image.jiqizhixin.com/uploads/editor/42886c3e-3217-4d6c-b936-1a954c3f487b/1529464463032.png" alt="img"></p><p>比如在下面的知识图谱中，我们完全可以把一些信息比如“年龄”，“家乡”放到传统的关系型数据库当中，因为这些数据对于：a. 分析关系来说没有太多作用  b.  访问频率低，放在知识图谱上反而影响效率</p><p><img src="https://image.jiqizhixin.com/uploads/editor/64b1545a-f4cc-492c-a519-f4b749576b26/1529464463095.png" alt="img"></p><p>另外，从分析原则（Analytics Principle）的角度，我们不需要把跟关系分析无关的实体放在图谱当中；从冗余原则（Redundancy Principle）的角度，有些重复性信息、高频信息可以放到传统数据库当中。</p><p><strong>6.4 把数据存入知识图谱</strong></p><p>存储上我们要面临存储系统的选择，但由于我们设计的知识图谱带有属性，图数据库可以作为首选。但至于选择哪个图数据库也要看业务量以及对效率的要求。如果数据量特别庞大，则Neo4j很可能满足不了业务的需求，这时候不得不去选择支持准分布式的系统比如OrientDB, JanusGraph等，或者通过效率、冗余原则把信息存放在传统数据库中，从而减少知识图谱所承载的信息量。 通常来讲，对于10亿节点以下规模的图谱来说Neo4j已经足够了。</p><p><strong>6.5 上层应用的开发</strong></p><p>等我们构建好知识图谱之后，接下来就要使用它来解决具体的问题。对于风控知识图谱来说，首要任务就是挖掘关系网络中隐藏的欺诈风险。<strong>从算法的角度来讲，有两种不同的场景：一种是基于规则的；另一种是基于概率的</strong>。鉴于目前AI技术的现状，基于规则的方法论还是在垂直领域的应用中占据主导地位，但随着数据量的增加以及方法论的提升，基于概率的模型也将会逐步带来更大的价值。</p><p><strong>6.5.1 基于规则的方法论</strong></p><p>首先，我们来看几个基于规则的应用，分别是不一致性验证、基于规则的特征提取、基于模式的判断。</p><p><strong>不一致性验证</strong></p><p>为了判断关系网络中存在的风险，一种简单的方法就是做不一致性验证，也就是通过一些规则去找出潜在的矛盾点。这些规则是以人为的方式提前定义好的，所以在设计规则这个事情上需要一些业务的知识。比如在下面的这个图中，李明和李飞两个人都注明了同样的公司电话，但实际上从数据库中判断这俩人其实在不同的公司上班，这就是一个矛盾点。 类似的规则其实可以有很多，不在这里一一列出。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/4048d065-a6b1-41e3-b5fa-87f198332f87/1529464463189.png" alt="img"></p><p><strong>基于规则提取特征</strong></p><p>我们也可以基于规则从知识图谱中提取一些特征，而且这些特征一般基于深度的搜索比如2度，3度甚至更高维度。比如我们可以问一个这样的问题：“申请人二度关系里有多少个实体触碰了黑名单？”，从图中我们很容观察到二度关系中有两个实体触碰了黑名单（黑名单由红色来标记）。等这些特征被提取之后，一般可以作为风险模型的输入。在此还是想说明一点，如果特征并不涉及深度的关系，其实传统的关系型数据库则足以满足需求。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/f70ba882-fe80-4adf-96c2-14839d40a6b2/1529464464276.png" alt="img"></p><p><strong>基于模式的判断</strong></p><p>这种方法比较适用于找出团体欺诈，它的核心在于通过一些模式来找到有可能存在风险的团体或者子图（sub-graph），然后对这部分子图做进一步的分析。 这种模式有很多种，在这里举几个简单的例子。 比如在下图中，三个实体共享了很多其他的信息，我们可以看做是一个团体，并对其做进一步的分析。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/8d3d1e12-22a9-4ed2-ac6f-99cbb255c1e0/1529464464353.png" alt="img"></p><p>﻿再比如，我们也可以从知识图谱中找出强连通图，并把它标记出来，然后做进一步风险分析。强连通图意味着每一个节点都可以通过某种路径达到其他的点，也就说明这些节点之间有很强的关系。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/b7cb2ec4-0963-4814-9357-2976c326c4e9/1529464464587.png" alt="img"></p><p><strong>6.5.2 基于概率的方法</strong></p><p>除了基于规则的方法，也可以使用概率统计的方法。 比如社区挖掘、标签传播、聚类等技术都属于这个范畴。 对于这类技术，在本文里不做详细的讲解，感兴趣的读者可以参考相关文献。</p><p>社区挖掘算法的目的在于从图中找出一些社区。对于社区，我们可以有多种定义，但直观上可以理解为社区内节点之间关系的密度要明显大于社区之间的关系密度。下面的图表示社区发现之后的结果，图中总共标记了三个不同的社区。一旦我们得到这些社区之后，就可以做进一步的风险分析。</p><p>由于社区挖掘是基于概率的方法论，好处在于不需要人为地去定义规则，特别是对于一个庞大的关系网络来说，定义规则这事情本身是一件很复杂的事情。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/68e693a4-dd50-4eea-8fac-2e2496a86198/1529464464702.png" alt="img"></p><p>﻿标签传播算法的核心思想在于节点之间信息的传递。这就类似于，跟优秀的人在一起自己也会逐渐地变优秀是一个道理。因为通过这种关系会不断地吸取高质量的信息，最后使得自己也会不知不觉中变得更加优秀。具体细节不在这里做更多解释。</p><p>相比规则的方法论，基于概率的方法的缺点在于：需要足够多的数据。如果数据量很少，而且整个图谱比较稀疏（Sparse），基于规则的方法可以成为我们的首选。尤其是对于金融领域来说，数据标签会比较少，这也是为什么基于规则的方法论还是更普遍地应用在金融领域中的主要原因。</p><p><strong>6.5.3 基于动态网络的分析</strong></p><p>以上所有的分析都是基于静态的关系图谱。所谓的静态关系图谱，意味着我们不考虑图谱结构本身随时间的变化，只是聚焦在当前知识图谱结构上。然而，我们也知道图谱的结构是随时间变化的，而且这些变化本身也可以跟风险有所关联。</p><p>在下面的图中，我们给出了一个知识图谱T时刻和T+1时刻的结构，我们很容易看出在这两个时刻中间，图谱结构（或者部分结构）发生了很明显的变化，这其实暗示着潜在的风险。那怎么去判断这些结构上的变化呢？ 感兴趣的读者可以查阅跟“dynamic network mining”相关的文献。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/234a79cb-4ad6-4fce-8cd2-9d1b116d09d1/1529464464458.png" alt="img"></p><p><strong>7. 知识图谱在其他行业中的应用</strong></p><p>除了金融领域，知识图谱的应用可以涉及到很多其他的行业，包括医疗、教育、证券投资、推荐等等。其实，只要有关系存在，则有知识图谱可发挥价值的地方。 在这里简单举几个垂直行业中的应用。</p><p>比如对于教育行业，我们经常谈论个性化教育、因材施教的理念。其核心在于理解学生当前的知识体系，而且这种知识体系依赖于我们所获取到的数据比如交互数据、评测数据、互动数据等等。为了分析学习路径以及知识结构，我们则需要针对于一个领域的概念知识图谱，简单来讲就是概念拓扑结构。在下面的图中，我们给出了一个非常简单的概念图谱：比如为了学习逻辑回归则需要先理解线性回归；为了学习CNN，得对神经网络有所理解等等。所有对学生的评测、互动分析都离不开概念图谱这个底层的数据。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/fd58f009-b075-487b-af57-5a67e64b281e/1529464464517.png" alt="img"></p><p>﻿在证券领域，我们经常会关心比如“一个事件发生了，对哪些公司产生什么样的影响？” 比如有一个负面消息是关于公司1的高管，而且我们知道公司1和公司2有种很密切的合作关系，公司2有个主营产品是由公司3提供的原料基础上做出来的。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/b1748709-0808-46df-b5e9-8efd413412ed/1529464465164.png" alt="img"></p><p>其实有了这样的一个知识图谱，我们很容易回答哪些公司有可能会被这次的负面事件所影响。当然，仅仅是“有可能”，具体会不会有强相关性必须由数据来验证。所以在这里，知识图谱的好处就是把我们所需要关注的范围很快给我们圈定。接下来的问题会更复杂一些，比如既然我们知道公司3有可能被这次事件所影响，那具体影响程度有多大？ 对于这个问题，光靠知识图谱是很难回答的，必须要有一个影响模型、以及需要一些历史数据才能在知识图谱中做进一步推理以及计算。</p><p><strong>8. 实践上的几点建议</strong></p><p>首先，知识图谱是一个比较新的工具，它的主要作用还是在于分析关系，尤其是深度的关系。所以在业务上，首先要确保它的必要性，其实很多问题可以用非知识图谱的方式来解决。</p><p>知识图谱领域一个最重要的话题是知识的推理。 而且知识的推理是走向强人工智能的必经之路。但很遗憾的，目前很多语义网络的角度讨论的推理技术（比如基于深度学习，概率统计）很难在实际的垂直应用中落地。其实目前最有效的方式还是基于一些规则的方法论，除非我们有非常庞大的数据集。</p><p>最后，还是要强调一点，<strong>知识图谱工程本身还是业务为重心，以数据为中心。不要低估业务和数据的重要性。</strong></p><p><strong>9. 结语</strong></p><p>知识图谱是一个既充满挑战而且非常有趣的领域。只要有正确的应用场景，对于知识图谱所能发挥的价值还是可以期待的。我相信在未来不到2，3年时间里，知识图谱技术会普及到各个领域当中。</p><p>很多细节性的内容很难在一篇文章里面面俱到、如果想对知识图谱领域有更全面的了解，并且快速开发出一款可落地的知识图谱产品，可以参考我近期推出的《知识图谱技术与应用》课程。在课程里，我会详细地给大家介绍怎么从零开始一步步搭建完整的知识图谱系统，并把每一个细节中遇到的问题以及坑给大家讲解。</p><p>对文章内容有任何疑问的读者可添加本文作者微信（liwenzhe595675）沟通交流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 机器之心&lt;/p&gt;
&lt;h1 id=&quot;这是一份通俗易懂的知识图谱技术与应用指南&quot;&gt;&lt;a href=&quot;#这是一份通俗易懂的知识图谱技术与应用指南&quot; class=&quot;headerlink&quot; title=&quot;这是一份通俗易懂的知识图谱技术与应用指南&quot;&gt;&lt;/a&gt;这是一份通俗易懂的知</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="知识图谱" scheme="http://ai.mak.cn/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>神经网络与深度学习参考</title>
    <link href="http://ai.mak.cn/2022/12/11/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF%E5%8F%82%E8%80%83/"/>
    <id>http://ai.mak.cn/2022/12/11/ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D%E4%BF%A1%E6%81%AF%E5%8F%82%E8%80%83/</id>
    <published>2022-12-10T16:00:00.000Z</published>
    <updated>2023-02-02T11:58:28.675Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://xpqiu.github.io/">邱锡鹏</a>  知乎：<a href="https://www.zhihu.com/people/xpqiu">@邱锡鹏</a></p><p>学习推荐</p><p><strong>神经网络与深度学习</strong></p><h2 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h2><p>近年来，以机器学习、知识图谱为代表的人工智能技术逐渐变得普及。从车牌识别、人脸识别、语音识别、智能助手、推荐系统到自动驾驶，人们在日常生活中都可能有意无意地用到了人工智能技术。这些技术的背后都离不开人工智能领域研究者的长期努力。特别是最近这几年，得益于数据的增多、计算能力的增强、学习算法的成熟以及应用场景的丰富，越来越多的人开始关注这个“崭新”的研究领域：深度学习。深度学习以神经网络为主要模型，一开始用来解决机器学习中的表示学习问题。但是由于其强大的能力，深度学习越来越多地用来解决一些通用人工智能问题，比如推理、决策等。目前，深度学习技术在学术界和工业界取得了广泛的成功，受到高度重视，并掀起新一轮的人工智能热潮。</p><p>主要特点：</p><p>系统性：系统地整理了神经网络和深度学习的知识体系。鉴于深度学习涉及的知识点较多，本书从机器学习的基本概念、神经网络模型以及概率图模型三个层面来串联深度学习所涉及的知识点，使读者对深度学习技术的理解更具系统性、条理性和全面性。</p><p>可读性：本书在编排上由浅入深，在语言表达上力求通俗易懂，并通过增加图例、示例以及必要的数学推导来理解抽象的概念。同时，附录简要介绍了本书所涉及的必要数学知识，便于读者查用。</p><p>实践性：本书在网站上配套了针对每章知识点的编程练习，使得读者在学习过程中可以将理论和实践密切结合，加深对知识点的理解，并具备分析问题和解决问题的能力。</p><p><img src="https://nndl.github.io/nndl2.jpg" alt="img"></p><h3 id="纸质书购买连接"><a href="#纸质书购买连接" class="headerlink" title="纸质书购买连接"></a>纸质书购买连接</h3><p><strong>蒲公英书</strong>：<a href="https://item.jd.com/12851292.html">京东</a> <a href="http://union.dangdang.com/transfer.php?from=P-340342&ad_type=10&sys_id=1&backurl=http://product.dangdang.com/28538371.html">当当</a>   <strong>蒲公英书实践篇</strong>：<a href="https://item.jd.com/13262435.html">京东</a> <a href="http://product.dangdang.com/29439138.html?_ddclickunion=P-295132-57139_64_0__1%7Cad_type=0%7Csys_id=1#dd_refer=https%3A%2F%2Fc.duomai.com%2Ftrack.php%3Fsite_id%3D57139%26aid%3D64%26euid%3D%26t%3Dhttp%3A%2F%2Fproduct.dangdang.com%2F29439138.html">当当</a> <strong>套装</strong>：<a href="https://item.jd.com/13345599.html">京东</a> <a href="http://product.dangdang.com/29449496.html">当当</a> </p><p>要获取更新提醒，请关注<a href="https://github.com/nndl/nndl.github.io">https://github.com/nndl/nndl.github.io</a></p><p>课后习题分享讨论：<a href="https://github.com/nndl/solutions">https://github.com/nndl/solutions</a></p><p><strong>配套实践</strong>（new）：<a href="https://github.com/nndl/practice-in-paddle/">https://github.com/nndl/practice-in-paddle/</a></p><p>豆瓣评分：<a href="https://book.douban.com/subject/33409947/">https://book.douban.com/subject/33409947/</a></p><p><em>蒲公英封面:希望这本教材能够帮助更多的学生进入深度学习以及人工智能领域，他们会为人工智能领域注入新的生机与活力。</em></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>全书内容</strong> <a href="https://nndl.github.io/nndl-book.pdf">pdf</a> (updated 2021-05-18) （推荐用iPad阅读）</p><p>更新说明：<a href="https://github.com/nndl/nndl.github.io">https://github.com/nndl/nndl.github.io</a></p><p>《神经网络与深度学习》印刷版 <a href="https://nndl.github.io/errata.html">勘误表</a> </p><p>《神经网络与深度学习》3小时课程概要  <a href="https://nndl.github.io/ppt/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3%E5%B0%8F%E6%97%B6.pptx">ppt</a>(72M)   <a href="https://nndl.github.io/ppt/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-3%E5%B0%8F%E6%97%B6.pdf">pdf</a> (12M) </p><h3 id="章节内容"><a href="#章节内容" class="headerlink" title="章节内容"></a>章节内容</h3><ol><li>绪论[<a href="https://nndl.github.io/ppt/chap-%E7%BB%AA%E8%AE%BA.pptx">ppt</a>] </li><li>机器学习概述  [<a href="https://nndl.github.io/ppt/chap-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0.pptx">ppt</a>] </li><li>线性模型 [<a href="https://nndl.github.io/ppt/chap-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B.pptx">ppt</a>]  </li><li>前馈神经网络 [<a href="https://nndl.github.io/ppt/chap-%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pptx">ppt</a>] </li><li>卷积神经网络 [<a href="https://nndl.github.io/ppt/chap-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pptx">ppt</a>]  </li><li>循环神经网络 [<a href="https://nndl.github.io/ppt/chap-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pptx">ppt</a>]   </li><li>网络优化与正则化  [<a href="https://nndl.github.io/ppt/chap-%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96.pptx">ppt</a>]  </li><li>注意力机制与外部记忆 [<a href="https://nndl.github.io/ppt/chap-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%96%E9%83%A8%E8%AE%B0%E5%BF%86.pptx">ppt</a>]  </li><li>无监督学习 [<a href="https://nndl.github.io/ppt/chap-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.pptx">ppt</a>] </li><li>模型独立的学习方式 [<a href="https://nndl.github.io/ppt/chap-%E6%A8%A1%E5%9E%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F.pptx">ppt</a>] </li><li>概率图模型 [<a href="https://nndl.github.io/ppt/chap-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B.pptx">ppt</a>] </li><li>深度信念网络 [<a href="https://nndl.github.io/ppt/chap-%E6%B7%B1%E5%BA%A6%E4%BF%A1%E5%BF%B5%E7%BD%91%E7%BB%9C.pptx">ppt</a>] </li><li>深度生成模型[<a href="https://nndl.github.io/ppt/chap-%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B.pptx">ppt</a>] </li><li>深度强化学习  [<a href="https://nndl.github.io/ppt/chap-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.pptx">ppt</a>] </li><li>序列生成模型 [<a href="https://nndl.github.io/ppt/chap-%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B.pptx">ppt</a>]     一个过时版本：<a href="https://nndl.github.io/old-chap/chap-%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AF%8D%E5%B5%8C%E5%85%A5.pdf">词嵌入与语言模型</a></li><li>数学基础</li></ol><h2 id="引用信息"><a href="#引用信息" class="headerlink" title="引用信息"></a>引用信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邱锡鹏，神经网络与深度学习，机械工业出版社，https://nndl.github.io/, 2020.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@book&#123;qiu2020nndl,</span><br><span class="line">title = &#123;神经网络与深度学习&#125;,</span><br><span class="line">publisher = &#123;机械工业出版社&#125;,</span><br><span class="line">year = &#123;2020&#125;,</span><br><span class="line">author = &#123;邱锡鹏&#125;,</span><br><span class="line">address = &#123;北京&#125;,</span><br><span class="line">isbn = &#123;9787111649687&#125;,</span><br><span class="line">url = &#123;https://nndl.github.io/&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反馈意见"><a href="#反馈意见" class="headerlink" title="反馈意见"></a>反馈意见</h2><p>如果您有任何意见、评论以及建议（先确认最新版本中是否已经修正），请通过GitHub的<a href="https://github.com/nndl/nndl.github.io/issues">Issues</a>页面进行反馈。如果错误比较重要，我会在本书中进行致谢。</p><p>反馈意见包括但不限于：（因为分开排版关系，页码错误请忽略。）</p><ul><li>打字错误</li><li>描述错误: 比如“感知器是非线性分类器”</li><li>评论</li><li>建议</li></ul><p>非常感谢！</p><p>致谢列表：感谢王利锋、林同茂、张钧瑞、李浩、胡可鑫、韦鹏辉、徐国海、侯宇蓬、任强、王少敬、肖耀、李鹏等同学指出书中的错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：&lt;a href=&quot;https://xpqiu.github.io/&quot;&gt;邱锡鹏&lt;/a&gt;  知乎：&lt;a href=&quot;https://www.zhihu.com/people/xpqiu&quot;&gt;@邱锡鹏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习推荐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;神经网络与深</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>运营商知识图谱的学习研究参考材料</title>
    <link href="http://ai.mak.cn/2022/12/10/ai/%E8%BF%90%E8%90%A5%E5%95%86%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99/"/>
    <id>http://ai.mak.cn/2022/12/10/ai/%E8%BF%90%E8%90%A5%E5%95%86%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99/</id>
    <published>2022-12-09T16:00:00.000Z</published>
    <updated>2023-02-02T11:50:07.760Z</updated>
    
    <content type="html"><![CDATA[<p>整理知识图谱相关的学习参考资料</p><ul><li><p><a href="https://image.c114.com.cn/file/ys202010-07.pdf">基于知识图谱的智能故障诊断研究</a></p></li><li><p><a href="https://www.doc88.com/p-62929791080827.html">电信运营商知识图谱技术体系研究及应用实践_赵东明</a></p></li><li><p><a href="http://www.c114.com.cn/news/118/a1132678.html">以知识图谱技术驱动场景化运营，提升存量运营和客户服务质量</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理知识图谱相关的学习参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://image.c114.com.cn/file/ys202010-07.pdf&quot;&gt;基于知识图谱的智能故障诊断研究&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="知识图谱" scheme="http://ai.mak.cn/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 注册攻略</title>
    <link href="http://ai.mak.cn/2022/12/08/ai/ChatGPT%20%E6%B3%A8%E5%86%8C%E6%94%BB%E7%95%A5/"/>
    <id>http://ai.mak.cn/2022/12/08/ai/ChatGPT%20%E6%B3%A8%E5%86%8C%E6%94%BB%E7%95%A5/</id>
    <published>2022-12-07T16:00:00.000Z</published>
    <updated>2023-02-08T08:34:57.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h1><p>首先，我们来了解下什么是ChatGPT，以及它的诞生背景。根据维基百科的官方解释：ChatGPT是由OpenAI开发的一个人工智能聊天机器人程序，于2022年11月30日推出。该程序使用基于GPT-3.5架构的大型语言模型并通过强化学习进行训练。ChatGPT 使用基于人类反馈的强化学习进行训练，这种方法通过人类干预以增强机器学习的效果，从而获得更为逼真的结果。其使用基于GPT-3.5架构的语言模型。在训练过程中，人类训练师扮演着用户与人工智能助手的角色。模型在Microsoft Azure的超级计算机上训练，并通过近端策略优化算法（proximal policy optimization）进行微调。这种策略优化算法比信任域策略优化（trust region policy optimization）算法更为高效。</p><h1 id="二、注册-ChatGPT"><a href="#二、注册-ChatGPT" class="headerlink" title="二、注册 ChatGPT"></a>二、注册 ChatGPT</h1><p>要注册使用 ChatGPT，我们需要准备以下内容：</p><ul><li>能够访问Google的全局代理，推荐美国节点；</li><li>一个邮箱用于注册，如Gmail, Outlook，163等 ；</li><li>一个国外手机号，如果没有可以使用sms-activate.org；</li></ul><h2 id="2-1-注册短信平台"><a href="#2-1-注册短信平台" class="headerlink" title="2.1 注册短信平台"></a>2.1 注册短信平台</h2><p>由于ChatGPT的注册需要用到国外的手机号接收验证码，如果没有的话可以开发sms-activate.org网站注册一个账号。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6643263b9a4c6697c1b8097f5fb12d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>由于每次接收验证码都要收取10.5卢布，大约1.2 人民币，如果你的账号没有钱，可以点击右上角余额进行充值。sms-activate支持的充值方式又很多，我们滑到支付宝选择支付宝充值。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9a506b454a4f398932b110435a0a68~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h2 id="2-2-注册OpenAI"><a href="#2-2-注册OpenAI" class="headerlink" title="2.2 注册OpenAI"></a>2.2 注册OpenAI</h2><p>回到主界面，然后在搜索框中输入OpenAI，如下图所示。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c309c1a2c9b645b98f079ed1b7c4276e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de63502db5a347e59659ca4a0829d557~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>然后，点击小黄车即可购买，购买成功后，我们需要将手机号复制出来供后面使用。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e85c427aca14c2883a7e704c14c05c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>有了手机号之后，我们就可以注册OpenAI账号了。打开<a href="https://link.juejin.cn/?target=https://beta.openai.com/signup">beta.openai.com&#x2F;signup</a>链接，然后开始注册。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ac97b695d74813a083e71b957d1d62~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>然后，我们选择选择刚刚注册的国家为印度，将刚刚注册的手机号复制过去，记得去掉国家号，此处是91。最近评论区有留言说选择印度可能会失败了，建议换成印尼🇮🇩&#x2F;巴西🇧🇷&#x2F;泰国🇹🇭试试。</p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582fb915e5284f898dcc09b8487770ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>回到之前获取手机号的界面，会出现短信，复制短信验证码即可。之后你就可以愉快的和ChatGPT聊天啦，快去试试吧。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68c80a0d5bc942bab3d1e826b40c5a0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h1 id="三、体验ChatGPT"><a href="#三、体验ChatGPT" class="headerlink" title="三、体验ChatGPT"></a>三、体验ChatGPT</h1><p>我们打开<a href="https://link.juejin.cn/?target=https://beta.openai.com/overview">beta.openai.com&#x2F;overview</a>官网链接。然后在顶部选择某个话题，点击的【 Try it】按钮，就可以开始与 ChatGPT 聊天啦！  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/641f5283a95a48d3b0ec672cc4073bd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2b5cf436934bb2b217211445cb4d82~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-背景&quot;&gt;&lt;a href=&quot;#一、-背景&quot; class=&quot;headerlink&quot; title=&quot;一、 背景&quot;&gt;&lt;/a&gt;一、 背景&lt;/h1&gt;&lt;p&gt;首先，我们来了解下什么是ChatGPT，以及它的诞生背景。根据维基百科的官方解释：ChatGPT是由OpenAI开发</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>腾讯和你想的不一样</title>
    <link href="http://ai.mak.cn/2022/12/05/%E6%9D%82%E8%AE%B0/%E8%85%BE%E8%AE%AF%E5%92%8C%E4%BD%A0%E6%83%B3%E7%9A%84%E4%B8%8D%E4%B8%80%E6%A0%B7/"/>
    <id>http://ai.mak.cn/2022/12/05/%E6%9D%82%E8%AE%B0/%E8%85%BE%E8%AE%AF%E5%92%8C%E4%BD%A0%E6%83%B3%E7%9A%84%E4%B8%8D%E4%B8%80%E6%A0%B7/</id>
    <published>2022-12-04T16:00:00.000Z</published>
    <updated>2023-01-29T05:52:58.527Z</updated>
    
    <content type="html"><![CDATA[<p>今天，很多人都在讨论数字化。</p><p>可我有一个感觉，很多人在说到数字化的时候，就像是在说一个“流行趋势”。只要提到数字化，就好像自己“跟上时代”了，“先进”了。</p><p>但这背后，也许没有太多的思考。</p><p>数字化，其实不是目的，只是手段。数字化的目的，是帮助企业更好地经营。</p><p><strong>我曾经和腾讯集团高级执行副总裁、云与智慧产业事业群CEO汤道生有过一些交流。Dowson对于数字化，有很深的洞察，我也很认可。</strong></p><p>他对于数字化的理解，很不一样。数字化，就是这三个词：连接、度量、激活。</p><p><strong>更具体来说，是用好用的工具，帮助这些企业，用连接创造价值，用度量洞察业务，用数字化重新激活产业。</strong></p><p>在最近的2022腾讯全球数字生态大会上，我也看到了Dowson最新的分享。腾讯云的同学，也给我讲了不少故事。我看完听完之后，很受启发。</p><p>这些故事，我想也能帮你对数字化有更深的理解。今天，也分享给你。</p><p>什么是连接？</p><p>你有没有听过这样一句话：想要富，先修路。</p><p><strong>修路的本质，就是“连接”。连接，能让更多节点，加入到商业世界巨大的网络中来，参与交易。</strong></p><p>交易，也会带来商业繁荣。</p><p>我举个例子。</p><p>在大城市边上，有家平庸的酒厂。说它平庸，是因为酒的口感，实在一般。但是，因为离大城市很近，附近也没有其他酒厂，所以生意还算不错。</p><p>但是，在一个偏远的小村庄里，也有一户人家。他家的酒，是真的好。只是，酒香只能飘方圆十里，再远飘不出去了。因此只有本村的人，才能喝到这么好的酒。</p><p><strong>直到有一天，“想要富，先修路”了。</strong></p><p>公路通到了乡村，小乡村这个偏远的生产节点，终于被连接进全国的交易网络，触达到更多的消费者。</p><p>很快，特别多的人认识了这户酿酒的人家。天啊！太好喝了吧！我要买！</p><p>然后，这户人家的酒越卖越好。而大城市边上那家平庸的酒厂，生意越来越差。</p><p><strong>这就是连接的价值。</strong></p><p>所以，连接越丰富，效率越高。连接越紧密，价值越大。</p><p>你一定听过，条条大路通罗马。</p><p>你也一定听过，武汉“九省通衢”的美称。</p><p>罗马和武汉，都是连接的超级节点。他们创造了更紧密的连接，也因为如此，他们的发展，变得更好。</p><p><strong>有不少公司，也深刻认识到了连接的价值。比如这家你一定知道的公司：太古可口可乐。</strong></p><p>太古可口可乐，是可口可乐全球装瓶系统销量第五大装瓶集团，在中国内地11个省份和上海市拥有18家工厂，23000多名员工，为7亿消费者提供产品和服务。</p><p>他们服务那么多消费者，又是处于竞争激烈的快消行业，特别需要和消费者保持连接。</p><p><strong>消费者的需求发生了什么变化？他们想要什么样的产品？快消行业，反应一定要快。市场的信息，要反馈到总部。总部的决策，要下达到一线。</strong></p><p>离客户越近，离成功就越近。</p><p>所以，太古可口可乐特别重视沟通，重视企业内部和外部的连接。每天都有大量的会议。</p><p><strong>但是，他们也面临了两个很大的问题：</strong></p><p>第一，前线团队面临的环境太复杂了。网络不好，远程沟通的质量就很差。在户外接入会议，有时噪音太大，对方根本听不清在说什么。</p><p>第二，假如要用新的云会议服务，公司又已经买了很多视频会议设备，如果不能兼容，那原来花的钱不都浪费了吗？</p><p>怎么办？</p><p><strong>太古可口可乐，选择了用腾讯会议企业版。</strong></p><p>腾讯会议企业版，你也一定很熟悉了，也许每天都还在用。非常好用。</p><p>腾讯会议企业版有很强大的音视频能力，能够做到智能语音降噪。即使是在嘈杂的户外，也能把声音清晰地传递出去。</p><p>超低延时和弱网通话，让员工哪怕是在信号不好的地方，也能保证音视频质量的稳定输出。</p><p>而且，腾讯会议企业版上手也容易。简单摸索摸索，都会用了。腾讯会议企业版也比太古可口可乐第二代会议工具节约成本达50%。不管是培训还是迁移，都几乎没有成本。</p><p>然后，腾讯会议企业版的会议室连接器（MRA）功能，也能让太古可口可乐实现公司内部旧设备的兼容和适配，充分保护过往投入购置的设备资产。</p><p><strong>这样，总部和一线，信息和决策，都能高效地上传下达。</strong></p><p><strong>再比如说：中交建。</strong></p><p>中交建，有很多很多的建设任务。但是这些任务和项目，实施起来非常复杂。往往需要桥梁、隧道、装备等各个领域团队合作。而这些团队，遍布全球各地。</p><p>因此，跨区域协作一直是个难题。</p><p>而疫情的反复，也让这个问题更加突出。</p><p>在竞争一个马来西亚的码头项目时，中交建在中国、巴西的水文、油气管道专家，没有办法与客户面对面交流，也没有办法勘查现场，给出针对性的方案。</p><p>怎么办？</p><p>同样，想办法提高连接的效率。</p><p>中交建，就通过腾讯会议，让后端专家也能远程看到现场实况。</p><p><strong>通过这样的连接方式，依靠着207次在线跨国会议，中交建拿出了高质量的解决方案，最终击败了9家对手，成功赢标。</strong></p><p>发现了吗？太古可口可乐的选择，中交建的选择，以及腾讯的努力，都是为了更好地连接。</p><p>用真正好用的工具，实现连接。</p><p><strong>用连接，创造价值。</strong></p><p>什么是度量？</p><p>你坐在汽车里，感觉很闷，想开窗透透气。</p><p>但是，车窗应该开多大呢？一半吧。能吹吹风，也能看看窗外的景色。</p><p>可是，你怎么知道，就刚刚好开了“一半”呢？你可能会说，这还要问，我看得呗。看到一半，就是一半。</p><p><strong>是啊。但如果你仔细思考过这个问题，就会发现，我们的眼睛，就是“度量器”。精确地“度量”出我们想要的位置。蒙上了眼睛，可能就要抓瞎了。</strong></p><p>所以，没有度量，很多事情就不精准，只能靠感觉，甚至就是瞎蒙瞎猜。</p><p>这时你就知道，商业世界里，为什么很多事情大家做得那么糟糕了。</p><p><strong>比如说，销售。</strong></p><p>很多公司的销售会议，经常会有“授旗仪式”。</p><p>在誓师大会上，专门制作了一把把大旗，让大家挨个上台，接过任务。</p><p>这么旗子，就交给你了！有没有信心完成！</p><p>有！</p><p>然后，就没有然后了。</p><p><strong>因为不管授旗仪式多么慷慨激昂，大家说的都只是一个充满感觉的“保证”，不是一个真正可以度量的“流程”。</strong></p><p>销售的流程，应该怎么度量？</p><p>调研客户、找到关键决策人、拜访、跟进、签单、售后服务……每一步，都应该足够清晰。而且这些度量，最好必须数字化。</p><p><strong>麦德龙，就做得很好。</strong></p><p>作为知名的零售商超，麦德龙一直很重视线下店的经营。</p><p><strong>但你也知道，现在消费者的购买流程发生了重大的变化，很多人都是“线下体验，线上消费”。这也对经营，提出了新的挑战。</strong></p><p>如何让消费者在线上就能直接购买，然后也能保证体验和效率呢？</p><p><strong>麦德龙借助腾讯云企点客服，搭建了一个基于企业微信的服务和营销平台。</strong></p><p>他们通过标签管理能力，把会员的兴趣偏好、消费习惯都进行个性化的管理，进行个性化的推送。</p><p>这样，可以帮助消费者降低决策成本，也可以为他们提供需要的商品。</p><p>而且，麦德龙还特意控制了推送的频率，不想要过度打扰用户。在线上购物，也能有好的体验。</p><p><strong>麦德龙，通过腾讯企点的能力，用工具度量出服务用户的流程，也用数据洞察消费者的偏好，增加了消费者对于品牌的信任与喜爱。</strong></p><p><strong>我再给你举个例子，名创优品。</strong></p><p>名创优品，是一个以“兴趣消费”为驱动的零售公司。像这样的公司，有一个明显的特点：需要不停上架新产品，拉动用户需求。</p><p>不停上架，有多“不停”呢？</p><p><strong>每周要从1万个创意里，挑出100个成为新产品。</strong></p><p>过去，名创优品是通过线下店铺试销来做出判断的。但是这样的方式，反馈周期太慢，卖得好的产品，补货速度跟不上；或者销量突然下滑，后端备货又来不及调整，造成大量库存。</p><p>总之，会有不小的挑战。</p><p>那怎么办？</p><p>能不能也“用度量来洞察业务”呢？</p><p>于是，他们借助企业微信的C2B能力，用在线预售的方式，解决了这个问题。</p><p>此前，名创优品跟迪士尼合作，推出一款有草莓味的草莓熊公仔。他们先是用企业微信链接用户群，孵化出100多个主题IP社群，日均互动量6千多次。</p><p>同时，联动到小程序，观察实时销售状况。</p><p>名创优品，就通过对用户消费行为的成功预判，最终，草莓熊产品成为当季爆款。</p><p>通过同样的方式，名创优品推出的大师香薰产品，也获得了成功，一上线就登上热销榜。</p><p><strong>在麦德龙和名创优品这两个例子背后，我们也可以得到很多关于“度量”的启发：</strong></p><p>1，度量，需要好用的工具。好用的工具，可以规范流程。</p><p>2，度量，得出有效的数据。在有效的数据中，挖掘需求。</p><p>3，度量，匹配产品和服务。用自己的产品和服务，满足用户的需求。</p><p>这，就是用度量洞察业务。</p><p>什么是激活？</p><p>我很喜欢在网上看到的这幅图：</p><p><img src="http://p0.itc.cn/q_70/images03/20221205/5e0402b6816440b2aa1e8c7ee4c33004.jpeg" alt="img"></p><p>从散乱的数据，到用这些数据找到一条最有效的路径，帮助我们做判断，提高效率。</p><p><strong>数字化的结果，就是激活。激活各行各业，找到新的解决问题的方式。</strong></p><p>我给你举个例子。比如说人工智能。</p><p>美国有一家叫Kensho的公司，已经开始利用人工智能，每天早上8:35，给高盛的雇员们，提供自动化的投资分析报告了。</p><p>显然，这能节省大量的人力成本，时间成本。效率不知道提高了多少。</p><p>在中国，也有类似的一家企业，在用数字化，激活自己的效率。中信建投证券。</p><p>中信建投证券，采用腾讯云智能的数智人技术联合打造了行业前沿的可交互“数智员工”。</p><p>有了“数智员工”，在客户自助操作过程中提供温馨引导，这样业务办理效率自然就提高了。</p><p>而且你知道吗，人与人之间的沟通，信息传递效率会随着沟通方式的变化而变化。</p><p><strong>面对面的沟通效率，100%。电话，可能80%。文字，可能只有60%了。数智人的出现，也增加了互动的感觉，不管是在线上，还是线下，沟通都能更有温度。</strong></p><p>数智人还精通用手语沟通的方式，在一些特殊场景下，也能帮助和服务有需要的人。</p><p>有意思。那除了数智人，还有哪些技术，用数字化重新激活了产业？</p><p><strong>我再给你举个例子，腾讯电子签。</strong></p><p>贝壳，你一定知道。腾讯电子签，集成到了贝壳的业务系统，实现海外新房购买协议、家装合同、购房合同的线上化签署，助力合同数字化管理。</p><p>用电子签，有两个显而易见的好处。</p><p><strong>第一，不用在线下跑来跑去了。</strong></p><p>风吹日晒雨淋，有时候特别耽误事儿，但如果能在线上直接签合同完成交易，就能大大提高效率。</p><p><strong>第二，也是更重要的，法务流程的确权。</strong></p><p>确权，不管是在个人的资产领域，还是在公司的经营领域，都是非常非常重要的事情。确权也是在交易的过程中流动完成的。</p><p>通过电子签，也能实现有效的界定。</p><p><strong>而用电子签的场景，还不仅于此。再比如说，四川师范大学。</strong></p><p>腾讯电子签, 用数字化技术在24小时内动态、精准、全覆盖地完成5万师生的健康申报，为四川师范大学的师生安全返校”保驾护航”。</p><p>之前需要辅导员、老师忙活一周的事情，通过数字化的签署场景，24小时就解决了，既高效，又可以实时查看管理。</p><p><strong>常有人问，什么是好用的产品，什么是有效的工具？</strong></p><p>看完这几个故事，你可能有更深的体会。</p><p>好用和有效，不是高大上的名词，不是花里胡哨的描述，而是真真正正能激活产业，解决实际的问题。</p><p><strong>最后的话</strong></p><p>数字化，不是来来去去的一阵风，不是流行趋势，而是效率革命。</p><p>数字化，也从来不是目的。数字化只是手段，目的是让企业能更好地经营。</p><p><strong>腾讯的洞察，和别人很不一样。腾讯云的同学和我说，在帮助企业数字化的过程中，企业会有自己的需求，会有自己的探索，而他们要做的，就是倾听、服务、改进。</strong></p><p>他们在推动我们，让我们变得更好。我们也应该加倍努力，提供更好的产品、更好用的工具，帮助他们。</p><p><strong>帮助他们，用连接创造价值，用度量洞察业务，用数字化重新激活产业。实现真正的数字化。</strong></p><p>最后，我也很想和你分享在这次2022腾讯全球数字生态大会上，汤道生Dowson说的一句话：</p><p><strong>时间是优秀企业的朋友，稳扎稳打、健康可持续的经营会带我们穿越周期，长期机会是留给有准备的人。</strong></p><p>真好。</p><p>祝福腾讯，祝福腾讯云，能够更加坚定务实地走下去。也祝福所有的企业，因为这些好用的产品，都能实现自己的数字化。</p><p><strong>我们都能一起，坚持长期主义，成为时间的朋友，变得更好。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，很多人都在讨论数字化。&lt;/p&gt;
&lt;p&gt;可我有一个感觉，很多人在说到数字化的时候，就像是在说一个“流行趋势”。只要提到数字化，就好像自己“跟上时代”了，“先进”了。&lt;/p&gt;
&lt;p&gt;但这背后，也许没有太多的思考。&lt;/p&gt;
&lt;p&gt;数字化，其实不是目的，只是手段。数字化的目的</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为什么说“SaaS的本质是续费”</title>
    <link href="http://ai.mak.cn/2022/12/02/%E6%9D%82%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E2%80%9CSaaS%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E7%BB%AD%E8%B4%B9%E2%80%9D%EF%BC%9F/"/>
    <id>http://ai.mak.cn/2022/12/02/%E6%9D%82%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E2%80%9CSaaS%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E7%BB%AD%E8%B4%B9%E2%80%9D%EF%BC%9F/</id>
    <published>2022-12-01T16:00:00.000Z</published>
    <updated>2023-01-25T05:32:30.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>节选自：得到头条 | 385期</p></blockquote><p>来看今天的第一条。11月30日，2022腾讯全球数字生态大会在深圳召开。在大会上，腾讯云总裁邱跃鹏指出，目前云计算发展呈现三大趋势：一是通过打造软硬件一体的算力底座，云计算全面进入“云原生”时代；二是通过可以快速调用的云上组件，实现数智融合、实时全真的效果；三是在企业数字化转型过程中，开箱即用的SaaS成为刚需，正在加速落地。</p><p>我注意到，这次大会还设置了数据库SaaS专场，传统上企业需要购买软硬件来自建的数据库系统，现在也可以通过直接购买SaaS服务来实现。腾讯表示，数据库SaaS不但能够解决传统数据库在安全性、扩展性和易用性上的痛点，而且能够帮助企业全面提升智能化、精细化运维的能力。</p><p>消息就是这样，来看看能学到什么知识。</p><p>可以看出，SaaS正在成为云计算的一个重要赛道。目前国内SaaS销售占云计算市场总规模的30%左右，而在欧美市场，这个比例将近60%。SaaS赛道的想象空间非常大，入局者也越来越多。2020年，在中国估值超2亿美元的SaaS公司有40家，到2021年就翻了一倍，有近80家。</p><p>国内SaaS玩家大概可以分成三类：</p><p>第一类是腾讯云、阿里云这样的大块头，它们正在布局各自的SaaS生态。</p><p>第二类是各个独立玩家，其中既包括做企业通用SaaS服务的公司，像做线上营销的有赞、做电子签名的法大大等；也包括做各种行业垂直领域的SaaS公司，像做家装的酷家乐、做建筑的广联达、做房地产营销的明源云等。</p><p>第三类是像用友、金蝶、东软等做传统企业软件的公司，它们正在做SaaS化转型。</p><p>说到这儿，我想问你一个问题：SaaS和ERP这种传统企业软件的区别是什么？你可能听过这样一种说法：表面的区别在于，传统软件是一次性购买而SaaS是订阅制收费。而更本质的区别在于，传统软件是本地构建的，而SaaS是云端构建的；传统软件的定制化更多，而SaaS的标准化程度更高；传统软件不能获得客户数据，而SaaS可以通过积累客户大数据来为客户提供数据增值服务，等等。</p><p>有意思的是，在《SaaS创业路线图》这本书里，作者吴昊老师提出了一个反常识的结论。他认为，大家以为的那些“更本质”的区别其实不重要，而大家觉得不太重要的收费方式的区别，才是要害。用吴昊老师的话来说，“SaaS的本质是续费”。正是“续费”这种商业模式，决定了SaaS企业的服务方式、公司估值都和传统软件企业完全不同。</p><p>比如，传统软件在实施部署后，经常出现客户使用效果差，导致项目失败的情况。业内通常把这种情况归因于客户的需求变化快，或者客户组织内部执行力差。而吴昊老师认为，问题的根子其实是传统软件的买断式销售模式。</p><p>因为是一锤子买卖，就不可避免地出现销售时给客户过度承诺，甚至不惜给实施部门“挖坑”，导致后面实施时一地鸡毛。实施完成后客户用得好不好，也没人真正关心，客户遇到问题客服部门也是被动响应。反正，销售业绩已经到手，后续顶多有每年15%的服务费，能拿就拿，拿不着就算了。你看，这是收费机制带来的问题，靠纪律或者个人责任心不能完全消除。</p><p>而SaaS的订阅制收费可以改变这个局面。一套卖30万元的传统企业软件，如果变成SaaS产品，可以报价每年收费10万元。在签完合同、实施部署之后，会由“客户成功部”来接手客户。客户成功部的业绩来自客户的续费。</p><p>所以，客户成功部的目标只有一个：想方设法让客户把软件用好、天天离不开，这样客户到明年才会续费。如果客户在使用中的问题比较大，客户成功部甚至会重做需求调研、进行二次实施，一切都是为了保住客户的使用体验。你看，这个服务的态度和积极性就和传统软件完全不同。</p><p>顺便说一句，在SaaS公司，客户成功部是非常重要的部门，重要程度不亚于销售部。假设平均每个客户会连续订阅5年服务，那么，只有第一年的业绩是由销售部门拿下的，剩下四年的业绩要靠客户成功部来实现。</p><p>收费机制的不同，让两类公司的估值标准也完全不同。传统软件上市公司的平均市盈率在20倍左右。如果按10%的净利润率算，传统软件公司估值大概为年销售额的2倍。而目前美国SaaS公司的估值，大概是年销售额的10倍，这可比传统软件公司高多了。这是因为，传统软件企业的每次成交都是“惊险一跃”；而SaaS公司的续费，只要你把客户服务好了，后面就是躺赚，收入的确定性要高很多。</p><p>目前，美国成熟SaaS公司的客户续费率可以达到90%，而中国SaaS公司还达不到这个水平。吴昊老师认为，续费率不足70%的SaaS公司不值钱，只能比照传统软件公司来估值，而不能按SaaS公司的10倍销售额来估值。如果一家SaaS公司的续费率低于60%，说明出了大问题，必须非常警惕。要么是产品本身有问题，要么是客户成功部的服务没做好，抑或是销售部门根本就找错了客户。总之，续费率是反映SaaS公司业务健康状况的最重要指标。</p><p>在这个逻辑下，吴昊老师强调SaaS公司不应该卖“多年单”。有时候，客户的采购部门为了省事，会要求一次支付3年甚至5年的费用。对一般公司来说，这肯定是好事，提前把收入落袋为安嘛。但对SaaS来说未必是好事。它会破坏前面说的用续费压力倒逼服务的机制，同时也会扭曲续费率这个重要指标，你三五年内都不知道客户到底满意还是不满意，产品也没办法持续打磨、迭代。</p><p>甚至，一年后再续费，这个反馈周期也太长。为了让反馈更敏捷，SaaS公司可以设置退款条件，也就是实施部署后一定时期内，客户不满意可以申请退款。如果没有退款机制，客户遇到问题没有解决也只能忍了，想着“大不了明年不续费”，也就是说，公司可能要等一年后才会发现问题的严重性。而退费机制能够立刻引起公司的高度重视，倒逼各个部门发现产品和服务的问题，立即改进。</p><p>正如吴昊老师说的：“一个好的商业机制，胜过一万遍日常管理。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;节选自：得到头条 | 385期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来看今天的第一条。11月30日，2022腾讯全球数字生态大会在深圳召开。在大会上，腾讯云总裁邱跃鹏指出，目前云计算发展呈现三大趋势：一是通过打造软硬件一体的算力底座，云计算全</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>为什么短视频要单列显示？</title>
    <link href="http://ai.mak.cn/2022/11/11/%E6%9D%82%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9F%AD%E8%A7%86%E9%A2%91%E8%A6%81%E5%8D%95%E5%88%97%E6%98%BE%E7%A4%BA%EF%BC%9F/"/>
    <id>http://ai.mak.cn/2022/11/11/%E6%9D%82%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9F%AD%E8%A7%86%E9%A2%91%E8%A6%81%E5%8D%95%E5%88%97%E6%98%BE%E7%A4%BA%EF%BC%9F/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2023-02-17T00:40:57.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>节选自：得到头条 | 302期</p></blockquote><p>今天我们从两个话题出发，为你提供知识服务。一是《2022年中国移动互联网半年大报告》发布，二是国产数据库“达梦数据”冲刺IPO。</p><p>7月底，第三方数据机构QuestMobile发布了《2022年中国移动互联网半年大报告》，盘点了上半年国内移动互联网发展的整体情况。</p><p>截至6月末，我国移动互联网的用户规模达到了11.9亿人，移动互联网普及率达到了84%，远超全球65%的水平。特别是今年上半年，移动互联网用户净增了903万人，2021年全年才增加了1226万人，可见，今年以来上网人数还在加速增长。</p><p>那么，大家上网主要在干什么呢？所有应用里，短视频力压群雄，盖过了社交媒体、电商、游戏，成为国民的第一大“时间杀手”。大家使用短视频的时长占上网总时长的28%；其次是社交媒体，占20%。而且，短视频的时长占比，比去年同期增长2.3%，也是所有应用中增长最快的。</p><p>消息就是这样，来看看能学到什么知识。</p><p>眼看着短视频一家独大，其他应用坐不住了，再不进场就晚了。做电商的拼多多，今年把“多多视频”放到了一级入口；做社区的B站，前不久推出了单独的竖屏短视频入口，就在首页左上角的头像那儿。还有更厉害的，背靠微信的视频号活跃用户规模突破了8亿，超过抖音的6.8亿和快手的3.9亿，下一步就要在留存时长、生态建造上追赶抖快。短视频江湖持续已久的“双雄模式”，很可能有迎来“三国杀”时代，甚至进入战国模式。</p><p>这些新入场的短视频玩家，页面设置清一色的“抖音化”：占满屏幕的竖屏，下方是发布者的名字，右侧有几个操作按钮。以至于有人调侃说，手机上显示着一个短视频页面，你根本不知道自己打开的是抖音、微信，还是拼多多。</p><p>你可能还记得，之前可不是这样的。在南抖音北快手的双雄时代，抖音是全屏式的单列页面，而快手是双列列表模式。大家觉得，抖音和快手就是两种不同调性的产品，抖音更像媒体，快手更像社区，抖音里网红层出不穷，快手上人人都是老铁。同样是做社区的B站和小红书，也选择了快手一样的双列列表模式。</p><p>但是，发展到今天，抖音的单列模式统一了短视频的江湖。不仅后来者有一个算一个都“抖音化”了，连快手都把打开APP的默认页面变成了和抖音一样的单列模式。</p><p>为什么单列模式会在短视频里一统江湖？单列双列，不就是页面的排布方式不同吗？你要是这么想，就把问题想简单了。事实上，单列双列，绝不仅仅是排布方式的差异，而是产品逻辑的根本不同。</p><p><strong>第一，对用户来说，单列比双列更容易上瘾。</strong></p><p>双列模式的逻辑是“你选想看的”，平台给出一个列表，我们需要去主动选择，在列表中找一个自己感兴趣的视频，点进去。一屏列表不行，就刷新一下换下一屏接着选，这时用户的心智跟逛电商差不多，主要在于“选”。好不容易选到一个满意的视频，看完了，还得回到列表，继续选。</p><p>而单列模式的逻辑是“猜你喜欢的”，内容完全由平台推荐，我们可以彻底躺平，平台推什么就看什么，不喜欢就下滑，看下一个推什么。这时，因为没有了“选”的负担，用户的全部心智都在于“看”这个动作。只要平台的算法足够精准，保证一直推荐用户喜欢看的内容，就可以让用户一直沉迷在内容当中不跳出。</p><p>所以单列模式有“抖音一天，地上一年”的称号，而双列列表只留下“吃饭5分钟，选下饭视频1小时”的段子。反映在数据上，抖音的用户月均使用时长达到32.7小时，大幅超过快手的27.9小时。</p><p><strong>第二，对创作者来说，单列更容易出爆款，而双列更容易出大V。</strong></p><p>单列模式是筛选逻辑，算法从每天上传的海量视频中找到有爆款潜质的，推荐给用户。一旦你的作品被算法青眼相中，就有很大概率成为爆款。不过，在单列模式下，用户也只会去看平台推荐的爆款视频，一般不太关注视频背后的创作者是谁。一旦创作者不能持续产出爆款视频，就会很快被用户遗忘。</p><p>而双列模式是培养逻辑，平台的主要工作是挑选、培养、扶持原创内容大V，以大V和用户之间的粉丝关系来增加用户黏性。</p><p>结果就是，抖音的流量最大限度地留在了公域，也就是掌握在平台手上，所谓“铁打的抖音，流水的网红”。而快手上大量的流量，沉淀在创作者的私域里，平台对流量的控制力可能并没有头部老铁高。</p><p><strong>第三，从商业模式来说，单列比双列变现能力更强。</strong></p><p>短视频商业变现主要靠广告。单列模式遵循展示逻辑，广告用信息流展示，直接推到播放层，用户不看也得看，广告的100万次展示就是100万次播放。</p><p>而双列模式的广告遵循点击逻辑，平台只能把广告视频放在列表当中，让用户看到感兴趣的广告自己点进去。为了让用户多点击，平台想尽了办法，比如把广告视频做得跟普通视频一模一样，目的就是提高用户的点击转化率。这种模式下，按照5%的点击率算，双列模式把广告分发给2000万用户，才能达到100万播放次数。在流量的分发控制上，单列处于完胜的状态。</p><p>B站最近透露，单列模式创造的单日收入，已经和原来每条视频框下的广告位创造的收入相当。同时，微信视频号也开启了信息流广告的内测。微信认为，短视频信息流广告将是视频号未来最大的收入来源。</p><p>总结一下，在用户使用时长、平台流量控制、商业变现能力上，单列模式都完胜双列模式。<strong>比起“主动选择”，我们更喜欢“被动投喂”，这是技术对人性的精准洞察。这让我想到一句话：“技术的本质，就是对现象的有目的的编程。”</strong></p><p>来看今天的第二条。</p><p>最近，国产数据库龙头“达梦数据”递交了招股说明书，申请登陆上交所科创板。如果上市成功，达梦数据将成为“国产数据库第一股”。</p><p>你知道，数据库是中国长期以来被严重“卡脖子”的关键技术。多年来，国内数据库市场一直是国外品牌的天下：甲骨文、IBM和微软，被称为数据库行业的三巨头。特别是对不差钱的客户来说，IT架构必选“IOE”组合，I是IBM的小型机，O是Oracle的数据库，E是EMC的集中式存储，“IOE”组合就是当年IT架构的黄金搭档，Oracle在国内数据库市场占据垄断地位。</p><p>国产数据库的发展，大概经历了这么几个阶段：</p><p>在2000年之前，是三巨头全面垄断时期，几乎没有国产数据库的声音。</p><p>2000—2009年，第一批国产数据库开始涌现。这次冲刺IPO的达梦数据库，就是创立于2000年，是由华中科技大学的一名退休教授创办的。创立22年之后，到今天，达梦数据库在国内关系型数据库市场的占有率，紧跟甲骨文和华为之后，排名第三。</p><p>2009—2014年，国内互联网大厂和IT巨头出于自身业务需要，掀起了一场去“IOE”组合的浪潮，“IOE”组合的稳定性好，但扩展性差，而且贵得要死。在IOE组合当中，Oracle数据库是最难替代的。于是，BAT和华为等巨头都纷纷下场，自行研发数据库。</p><p>2014年至今，国产数据库开始加速发展，政策层面有“国产替代”的倾斜，资本层面有各路风投基金捧场。特别是2020—2021年这两年间，数据库成为热门投资赛道，有40多家国产数据库公司获得了风险资本的投资。今年4月份，成立不足半年的国内数据库公司“飞轮科技”获得3亿元天使轮融资。截至目前，各种类型的国产数据库已经超过200种。</p><p>不过，“多”并不代表“强”，国产数据库是否有实力和三巨头一争高下，很多人是存疑的。比如，有人认为，目前国产数据库市场是虚假繁荣，有这么“四宗罪”：</p><p>1.国产数据库公司虽然多，但体量小、实力弱，超过60%的数据库厂商不足100人，还不及国外二、三流数据库公司的一个研发部。</p><p>2.专利少，所有国产关系型数据库的专利数加在一起不足4000件，而Oracle一家的专利就有1.4万件。</p><p>3.代码的自主化率不高，大多数国产数据库不是从头写代码，而是在现有的开源数据库基础上做修改。</p><p>4.国产数据库爱吹牛，动不动吊打Oracle，实际差得远，拍马都赶不上。</p><p>你看，这几宗罪，听起来确实有道理，我看完之后也挺沮丧的。不过，我后来又读到资深人士“破产码农”姜老师的分析，顿感柳暗花明。</p><p>姜老师认为，这“四宗罪”说的现象都对，但结论错了。这些现象恰恰说明，国产数据库迎来了弯道超车的最佳时机。</p><p>想想看，国产智能手机是怎么崛起的？一开始出来一堆杂牌子，没什么技术含量，硬件组装一下，操作系统就是基于开源的安卓系统改一下。实际上，把现在国产数据库的“四宗罪”放在那会儿的国产智能手机上，把Oracle变成iPhone，逻辑完全成立。</p><p>再来看，国产新能源车是怎么崛起的？一开始出来一堆杂牌子，没什么技术含量，硬件组装一下，软件系统在特斯拉的开源专利上改一下。实际上，把现在国产数据库的“四宗罪”放在那会儿的国产新能源车上，把Oracle变成特斯拉，逻辑依然成立。</p><p>这么一对比，我们可以合理推测，国产数据库正沿着国产智能手机和国产新能源车走过的路，处于由“多”变“强”的临界点上。国产数据库的崛起，不是风口，而是趋势。风口总会过去，而趋势是不可逆的。</p><p>来说说咱们得到的事儿。</p><p>可能很多同学已经注意到了，贾行家老师要做直播了。</p><p>这个秋天，贾行家老师计划在“行家茶坊”直播间与你定期见面，一共有6期，每期都是周五晚上九点半，在你忙碌了一周之后，晚上回到家坐在沙发上，点开直播，听贾老师聊聊这一周的感悟，来场深夜“心灵按摩”。第一场直播安排在了明晚九点半。</p><p>我从贾老师那里打听到了第一期直播的内容大纲，先来跟你剧透一下。</p><p>这场直播有“一句话”“一个人”“两本书”：</p><p>一句话，贾老师会先分享他近来听到的一句有意思的话，一个词语，或者是一个想法。</p><p>一个人，贾老师可能会聊聊他周末在青岛跟脱口秀演员呼兰聊天的一些收获。</p><p>两本书，是近期热门的历史书《喜》和《漫长的余生》。贾老师会带你看，两位历史学家不约而同地以“个人与世界的关系是什么，怎么从历史中寻找个人”的视角，重新考察历史，讲述来自秦、北魏的两个人的故事。</p><p>贾老师在直播过程中，也会穿插现场问答，你可以随时在直播间向贾老师提问。</p><p>另外，来看直播还有两个福利，一是从《文化参考2》的课程同学中抽取5位，送出贾老师的签名书；二是你可以加入贾老师的“文化交流群”，在群里分享自己观察到的文艺新动向，你的选题很可能会被贾老师写进课程。本周五晚上9:30，欢迎你光临“行家茶坊”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;节选自：得到头条 | 302期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们从两个话题出发，为你提供知识服务。一是《2022年中国移动互联网半年大报告》发布，二是国产数据库“达梦数据”冲刺IPO。&lt;/p&gt;
&lt;p&gt;7月底，第三方数据机构Ques</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023年中国数字化业务十大预测</title>
    <link href="http://ai.mak.cn/2022/11/10/%E6%9D%82%E8%AE%B0/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1%E5%8D%81%E5%A4%A7%E9%A2%84%E6%B5%8B/"/>
    <id>http://ai.mak.cn/2022/11/10/%E6%9D%82%E8%AE%B0/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1%E5%8D%81%E5%A4%A7%E9%A2%84%E6%B5%8B/</id>
    <published>2022-11-09T16:00:00.000Z</published>
    <updated>2023-01-25T02:46:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。</p><p>极不平凡的2022年即将过去，顺风、逆风、侧风的各类风浪演变成了颠覆风暴：疫情仍没有完全过去、俄乌冲突仍在继续、地缘政治风险有增无减、供应链约束仍然存在、人才鸿沟依然严峻、全球经济增长放缓甚至进入衰退。行业领导者为了应对这些风暴的影响，纷纷采用数字化优先策略，开发与运营数字化业务，2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。</p><p>即便有诸多颠覆风暴的挑战，未来5年仍将是数字化发展的黄金时期。</p><p>首先，全球数字化发展的临界点已经到来，数字经济占比、SaaS支出占比、数字化业务支出占比、数字化人才占比等已经或都将在未来5年内超过50%；其次，数字技术投资依然是全球和中国企业高管的核心聚焦点；第三，各国政府出台的政策都在鼓励数字经济发展，中国政府《“十四五”数字经济发展规划》和二十大报告都为数字经济持续高速发展擘划了蓝图；第四，过去的历史数据也展示了数字化转型对企业销售和利润的直接利好。因此，如何在数字化业务时代实现可持续发展是所有组织的诉求。</p><p>2023 IDC FutureScape 研究的重点是未来12到24个月内改变全球业务生态系统的外部驱动因素，以及技术和IT团队在定义、构建和治理数字优先时代蓬勃发展所需的技术时面临的问题。</p><p>基于中国市场的发展特点和趋势并结合IDC对全球数字化业务的预测，2023年中国数字化业务的10大预测如下：</p><p><img src="https://aimak.cn/blog_img/shuzihua/1-yuceshijian.webp"></p><p>预测1和2涵盖了数字化支出与收入，与企业未来的销售、成本与利润直接相关。</p><p>预测3和5涵盖了新生态与价值链，与未来基于生态的创新直接相关。</p><p>预测4、8和10涵盖了数字化技能与人才，与打造奔跑的数字化梦之队直接相关。</p><p>预测6、7和9涵盖了数字化价值与可持续发展，与未来环境、社会责任、治理与企业的市场价值直接相关。</p><p><img src="https://aimak.cn/blog_img/shuzihua/2-1-3.webp"></p><p><img src="https://aimak.cn/blog_img/shuzihua/3-3-7.webp"></p><p><img src="https://aimak.cn/blog_img/shuzihua/4-8-10.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。&lt;/p&gt;
&lt;p&gt;极不平凡的2022年即将过去，顺风、逆风、侧风的各类风浪演变成了颠覆风暴：疫情仍没有完全过去、俄乌冲突仍在继续、地缘政治风险有增无减、供应链约束仍然存在、人才鸿沟依然严峻、全球</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="报告分享" scheme="http://ai.mak.cn/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python 的一些日常高频写法总结！</title>
    <link href="http://ai.mak.cn/2022/10/17/python/Python%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E9%AB%98%E9%A2%91%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/10/17/python/Python%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E9%AB%98%E9%A2%91%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-16T16:00:00.000Z</published>
    <updated>2023-01-24T13:46:31.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：</p><p><a href="https://github.com/jackzhenguo/python-small-example">https://github.com/jackzhenguo/python-small-example</a></p></blockquote><h5 id="今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～"><a href="#今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～" class="headerlink" title="今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～"></a>今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一、-数字"><a href="#一、-数字" class="headerlink" title="一、 数字"></a>一、 数字</h2><h4 id="1-求绝对值"><a href="#1-求绝对值" class="headerlink" title="1 求绝对值"></a>1 求绝对值</h4><p>绝对值或复数的模</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: abs(-6)</span><br><span class="line">Out[1]: 6</span><br></pre></td></tr></table></figure><h4 id="2-进制转化"><a href="#2-进制转化" class="headerlink" title="2 进制转化"></a>2 进制转化</h4><p>十进制转换为二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [2]: bin(10)</span><br><span class="line">Out[2]: &#x27;0b1010&#x27;</span><br></pre></td></tr></table></figure><p>十进制转换为八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [3]: oct(9)</span><br><span class="line">Out[3]: &#x27;0o11&#x27;</span><br></pre></td></tr></table></figure><p>十进制转换为十六进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: hex(15)</span><br><span class="line">Out[4]: &#x27;0xf&#x27;</span><br></pre></td></tr></table></figure><h4 id="3-整数和ASCII互转"><a href="#3-整数和ASCII互转" class="headerlink" title="3 整数和ASCII互转"></a>3 整数和ASCII互转</h4><p>十进制整数对应的<code>ASCII字符</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: chr(65)</span><br><span class="line">Out[1]: &#x27;A&#x27;</span><br></pre></td></tr></table></figure><p>查看某个<code>ASCII字符</code>对应的十进制数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: ord(&#x27;A&#x27;)</span><br><span class="line">Out[1]: 65</span><br></pre></td></tr></table></figure><h4 id="4-元素都为真检查"><a href="#4-元素都为真检查" class="headerlink" title="4 元素都为真检查"></a>4 元素都为真检查</h4><p>所有元素都为真，返回 <code>True</code>，否则为<code>False</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [5]: all([1,0,3,6])</span><br><span class="line">Out[5]: False</span><br><span class="line">In [6]: all([1,2,3])</span><br><span class="line">Out[6]: True</span><br></pre></td></tr></table></figure><h4 id="5-元素至少一个为真检查"><a href="#5-元素至少一个为真检查" class="headerlink" title="5 元素至少一个为真检查"></a>5 元素至少一个为真检查</h4><p>至少有一个元素为真返回<code>True</code>，否则<code>False</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [7]: any([0,0,0,[]])</span><br><span class="line">Out[7]: False</span><br><span class="line">In [8]: any([0,0,1])</span><br><span class="line">Out[8]: True</span><br></pre></td></tr></table></figure><h4 id="6-判断是真是假"><a href="#6-判断是真是假" class="headerlink" title="6 判断是真是假"></a>6 判断是真是假</h4><p>测试一个对象是True, 还是False.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [9]: bool([0,0,0])</span><br><span class="line">Out[9]: True</span><br><span class="line"></span><br><span class="line">In [10]: bool([])</span><br><span class="line">Out[10]: False</span><br><span class="line"></span><br><span class="line">In [11]: bool([1,0,1])</span><br><span class="line">Out[11]: True</span><br></pre></td></tr></table></figure><h4 id="7-创建复数"><a href="#7-创建复数" class="headerlink" title="7 创建复数"></a>7 创建复数</h4><p>创建一个复数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: complex(1,2)</span><br><span class="line">Out[1]: (1+2j)</span><br></pre></td></tr></table></figure><h4 id="8-取商和余数"><a href="#8-取商和余数" class="headerlink" title="8 取商和余数"></a>8 取商和余数</h4><p>分别取商和余数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: divmod(10,3)</span><br><span class="line">Out[1]: (3, 1)</span><br></pre></td></tr></table></figure><h4 id="9-转为浮点类型"><a href="#9-转为浮点类型" class="headerlink" title="9 转为浮点类型"></a>9 转为浮点类型</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">将一个整数或数值型字符串转换为浮点数</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: float(3)</span><br><span class="line">Out[1]: 3.0</span><br></pre></td></tr></table></figure><p>如果不能转化为浮点数，则会报<code>ValueError</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [2]: float(&#x27;a&#x27;)</span><br><span class="line"># ValueError: could not convert string to float: &#x27;a&#x27;</span><br></pre></td></tr></table></figure><h4 id="10-转为整型"><a href="#10-转为整型" class="headerlink" title="10 转为整型"></a>10 转为整型</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">int(x, base &#x3D;10) , x可能为字符串或数值，将x 转换为一个普通整数。如果参数是字符串，那么它可能包含符号和小数点。如果超出了普通整数的表示范围，一个长整数被返回。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: int(&#x27;12&#x27;,16)</span><br><span class="line">Out[1]: 18</span><br></pre></td></tr></table></figure><h4 id="11-次幂"><a href="#11-次幂" class="headerlink" title="11 次幂"></a>11 次幂</h4><p>base为底的exp次幂，如果mod给出，取余</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: pow(3, 2, 4)</span><br><span class="line">Out[1]: 1</span><br></pre></td></tr></table></figure><h4 id="12-四舍五入"><a href="#12-四舍五入" class="headerlink" title="12 四舍五入"></a>12 四舍五入</h4><p>四舍五入，<code>ndigits</code>代表小数点后保留几位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [11]: round(10.0222222, 3)</span><br><span class="line">Out[11]: 10.022</span><br><span class="line"></span><br><span class="line">In [12]: round(10.05,1)</span><br><span class="line">Out[12]: 10.1</span><br></pre></td></tr></table></figure><h4 id="13-链式比较"><a href="#13-链式比较" class="headerlink" title="13 链式比较"></a>13 链式比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 3</span><br><span class="line">print(1 &lt; i &lt; 3)  # False</span><br><span class="line">print(1 &lt; i &lt;= 3)  # True</span><br></pre></td></tr></table></figure><h2 id="二、-字符串"><a href="#二、-字符串" class="headerlink" title="二、 字符串"></a>二、 字符串</h2><h4 id="14-字符串转字节"><a href="#14-字符串转字节" class="headerlink" title="14 字符串转字节"></a>14 字符串转字节</h4><p>字符串转换为字节类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [12]: s = &quot;apple&quot;                                                            </span><br><span class="line"></span><br><span class="line">In [13]: bytes(s,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">Out[13]: b&#x27;apple&#x27;</span><br></pre></td></tr></table></figure><h4 id="15-任意对象转为字符串"><a href="#15-任意对象转为字符串" class="headerlink" title="15 任意对象转为字符串"></a>15 任意对象转为字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [14]: i = 100                                                                </span><br><span class="line"></span><br><span class="line">In [15]: str(i)</span><br><span class="line">Out[15]: &#x27;100&#x27;</span><br><span class="line"></span><br><span class="line">In [16]: str([])</span><br><span class="line">Out[16]: &#x27;[]&#x27;</span><br><span class="line"></span><br><span class="line">In [17]: str(tuple())</span><br><span class="line">Out[17]: &#x27;()&#x27;</span><br></pre></td></tr></table></figure><h4 id="16-执行字符串表示的代码"><a href="#16-执行字符串表示的代码" class="headerlink" title="16 执行字符串表示的代码"></a>16 执行字符串表示的代码</h4><p>将字符串编译成python能识别或可执行的代码，也可以将文字读成字符串再编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s  = &quot;print(&#x27;helloworld&#x27;)&quot;</span><br><span class="line">    </span><br><span class="line">In [2]: r = compile(s,&quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br><span class="line">    </span><br><span class="line">In [3]: r</span><br><span class="line">Out[3]: &lt;code object &lt;module&gt; at 0x0000000005DE75D0, file &quot;&lt;string&gt;&quot;, line 1&gt;</span><br><span class="line">    </span><br><span class="line">In [4]: exec(r)</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h4 id="17-计算表达式"><a href="#17-计算表达式" class="headerlink" title="17 计算表达式"></a>17 计算表达式</h4><p>将字符串str 当成有效的表达式来求值并返回计算结果取出字符串中内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s = &quot;1 + 3 +5&quot;</span><br><span class="line">    ...: eval(s)</span><br><span class="line">    ...:</span><br><span class="line">Out[1]: 9</span><br></pre></td></tr></table></figure><h4 id="18-字符串格式化"><a href="#18-字符串格式化" class="headerlink" title="18 字符串格式化"></a>18 字符串格式化</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">格式化输出字符串，format(value, format_spec)实质上是调用了value的__format__(format_spec)方法。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [104]: print(&quot;i am &#123;0&#125;,age&#123;1&#125;&quot;.format(&quot;tom&quot;,18))</span><br><span class="line">i am tom,age18</span><br></pre></td></tr></table></figure><table><thead><tr><th>3.1415926</th><th>{:.2f}</th><th>3.14</th><th>保留小数点后两位</th></tr></thead><tbody><tr><td>3.1415926</td><td>{:+.2f}</td><td>+3.14</td><td>带符号保留小数点后两位</td></tr><tr><td>-1</td><td>{:+.2f}</td><td>-1.00</td><td>带符号保留小数点后两位</td></tr><tr><td>2.71828</td><td>{:.0f}</td><td>3</td><td>不带小数</td></tr><tr><td>5</td><td>{:0&gt;2d}</td><td>05</td><td>数字补零 (填充左边, 宽度为2)</td></tr><tr><td>5</td><td>{:x&lt;4d}</td><td>5xxx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>10</td><td>{:x&lt;4d}</td><td>10xx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>1000000</td><td>{:,}</td><td>1,000,000</td><td>以逗号分隔的数字格式</td></tr><tr><td>0.25</td><td>{:.2%}</td><td>25.00%</td><td>百分比格式</td></tr><tr><td>1000000000</td><td>{:.2e}</td><td>1.00e+09</td><td>指数记法</td></tr><tr><td>18</td><td>{:&gt;10d}</td><td>‘ 18’</td><td>右对齐 (默认, 宽度为10)</td></tr><tr><td>18</td><td>{:&lt;10d}</td><td>‘18 ‘</td><td>左对齐 (宽度为10)</td></tr><tr><td>18</td><td>{:^10d}</td><td>‘ 18 ‘</td><td>中间对齐 (宽度为10)</td></tr></tbody></table><h2 id="三、-函数"><a href="#三、-函数" class="headerlink" title="三、 函数"></a>三、 函数</h2><h4 id="19-拿来就用的排序函数"><a href="#19-拿来就用的排序函数" class="headerlink" title="19 拿来就用的排序函数"></a>19 拿来就用的排序函数</h4><p>排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [2]: sorted(a,reverse=True)</span><br><span class="line">Out[2]: [4, 3, 2, 1, 1]</span><br><span class="line"></span><br><span class="line">In [3]: a = [&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;male&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;</span><br><span class="line">     ...: xiaohong&#x27;,&#x27;age&#x27;:20,&#x27;gender&#x27;:&#x27;female&#x27;&#125;]</span><br><span class="line">In [4]: sorted(a,key=lambda x: x[&#x27;age&#x27;],reverse=False)</span><br><span class="line">Out[4]:</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;male&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;xiaohong&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;female&#x27;&#125;]</span><br></pre></td></tr></table></figure><h4 id="20-求和函数"><a href="#20-求和函数" class="headerlink" title="20 求和函数"></a>20 求和函数</h4><p>求和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [181]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [182]: sum(a)</span><br><span class="line">Out[182]: 11</span><br><span class="line"></span><br><span class="line">In [185]: sum(a,10) #求和的初始值为10</span><br><span class="line">Out[185]: 21</span><br></pre></td></tr></table></figure><h4 id="21-nonlocal用于内嵌函数中"><a href="#21-nonlocal用于内嵌函数中" class="headerlink" title="21 nonlocal用于内嵌函数中"></a>21 nonlocal用于内嵌函数中</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">关键词<code>nonlocal</code>常用于函数嵌套中，声明变量<code>i</code>为非局部变量；如果不声明，<code>i+=1</code>表明<code>i</code>为函数<code>wrapper</code>内的局部变量，因为在<code>i+=1</code>引用(reference)时,i未被声明，所以会报<code>unreferenced variable</code>的错误。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def excepter(f):</span><br><span class="line">    i = 0</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    def wrapper():</span><br><span class="line">        try:</span><br><span class="line">            f()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            nonlocal i</span><br><span class="line">            i += 1</span><br><span class="line">            print(f&#x27;&#123;e.args[0]&#125;: &#123;i&#125;&#x27;)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            if i == n:</span><br><span class="line">                print(f&#x27;spending time:&#123;round(t2-t1,2)&#125;&#x27;)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h4 id="22-global-声明全局变量"><a href="#22-global-声明全局变量" class="headerlink" title="22 global 声明全局变量"></a>22 global 声明全局变量</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">先回答为什么要有<code>global</code>，一个变量被多个函数引用，想让全局变量被所有函数共享。有的伙伴可能会想这还不简单，这样写：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = 5</span><br><span class="line">def f():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">def g():</span><br><span class="line">    print(i)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">g()</span><br></pre></td></tr></table></figure><p>f和g两个函数都能共享变量<code>i</code>，程序没有报错，所以他们依然不明白为什么要用<code>global</code>.</p><p>但是，如果我想要有个函数对<code>i</code>递增，这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">h()</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">此时执行程序，bang, 出错了！抛出异常：<code>UnboundLocalError</code>，原来编译器在解释<code>i+=1</code>时会把<code>i</code>解析为函数<code>h()</code>内的局部变量，很显然在此函数内，编译器找不到对变量<code>i</code>的定义，所以会报错。</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect"><code>global</code>就是为解决此问题而被提出，在函数h内，显式地告诉编译器<code>i</code>为全局变量，然后编译器会在函数外面寻找<code>i</code>的定义，执行完<code>i+=1</code>后，<code>i</code>还为全局变量，值加1：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">def h():</span><br><span class="line">    global i</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">h()</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><h4 id="23-交换两元素"><a href="#23-交换两元素" class="headerlink" title="23 交换两元素"></a>23 交换两元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def swap(a, b):</span><br><span class="line">    return b, a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(swap(1, 0))  # (0,1)</span><br></pre></td></tr></table></figure><h4 id="24-操作函数对象"><a href="#24-操作函数对象" class="headerlink" title="24 操作函数对象"></a>24 操作函数对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [31]: def f():</span><br><span class="line">    ...:     print(&#x27;i\&#x27;m f&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [32]: def g():</span><br><span class="line">    ...:     print(&#x27;i\&#x27;m g&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [33]: [f,g][1]()</span><br><span class="line">i&#x27;m g</span><br></pre></td></tr></table></figure><p>创建函数对象的list，根据想要调用的index，方便统一调用。</p><h4 id="25-生成逆序序列"><a href="#25-生成逆序序列" class="headerlink" title="25 生成逆序序列"></a>25 生成逆序序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(10,-1,-1)) # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>第三个参数为负时，表示从第一个参数开始递减，终止到第二个参数(不包括此边界)</p><h4 id="26-函数的五类参数使用例子"><a href="#26-函数的五类参数使用例子" class="headerlink" title="26 函数的五类参数使用例子"></a>26 函数的五类参数使用例子</h4><p>python五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(a,*b,c=10,**d):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;,c:&#123;c&#125;,d:&#123;d&#125;&#x27;)</span><br></pre></td></tr></table></figure><p><em>默认参数<code>c</code>不能位于可变关键字参数<code>d</code>后.</em></p><p>调用f:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [10]: f(1,2,5,width=10,height=20)</span><br><span class="line">a:1,b:(2, 5),c:10,d:&#123;&#x27;width&#x27;: 10, &#x27;height&#x27;: 20&#125;</span><br></pre></td></tr></table></figure><p>可变位置参数<code>b</code>实参后被解析为元组<code>(2,5)</code>;而c取得默认值10; d被解析为字典.</p><p>再次调用f:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [11]: f(a=1,c=12)</span><br><span class="line">a:1,b:(),c:12,d:&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">a&#x3D;1传入时a就是关键字参数，b,d都未传值，c被传入12，而非默认值。</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">注意观察参数<code>a</code>, 既可以<code>f(1)</code>,也可以<code>f(a=1)</code> 其可读性比第一种更好，建议使用f(a&#x3D;1)。如果要强制使用<code>f(a=1)</code>，需要在前面添加一个星号:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(*,a,**b):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>此时f(1)调用，将会报错：<code>TypeError: f() takes 0 positional arguments but 1 was given</code></p><p>只能<code>f(a=1)</code>才能OK.</p><p>说明前面的<code>*</code>发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的类型呢？借助python的<code>inspect</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [22]: for name,val in signature(f).parameters.items():</span><br><span class="line">    ...:     print(name,val.kind)</span><br><span class="line">    ...:</span><br><span class="line">a KEYWORD_ONLY</span><br><span class="line">b VAR_KEYWORD</span><br></pre></td></tr></table></figure><p>可看到参数<code>a</code>的类型为<code>KEYWORD_ONLY</code>，也就是仅仅为关键字参数。</p><p>但是，如果f定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(a,*b):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>查看参数类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [24]: for name,val in signature(f).parameters.items():</span><br><span class="line">    ...:     print(name,val.kind)</span><br><span class="line">    ...:</span><br><span class="line">a POSITIONAL_OR_KEYWORD</span><br><span class="line">b VAR_POSITIONAL</span><br></pre></td></tr></table></figure><p>可以看到参数<code>a</code>既可以是位置参数也可是关键字参数。</p><h4 id="27使用slice对象"><a href="#27使用slice对象" class="headerlink" title="27使用slice对象"></a>27使用slice对象</h4><p>生成关于蛋糕的序列cake1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: cake1 = list(range(5,0,-1))</span><br><span class="line"></span><br><span class="line">In [2]: b = cake1[1:10:2]</span><br><span class="line"></span><br><span class="line">In [3]: b</span><br><span class="line">Out[3]: [4, 2]</span><br><span class="line"></span><br><span class="line">In [4]: cake1</span><br><span class="line">Out[4]: [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><p>再生成一个序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [5]: from random import randint</span><br><span class="line">   ...: cake2 = [randint(1,100) for _ in range(100)]</span><br><span class="line">   ...: # 同样以间隔为2切前10个元素，得到切片d</span><br><span class="line">   ...: d = cake2[1:10:2]</span><br><span class="line">In [6]: d</span><br><span class="line">Out[6]: [75, 33, 63, 93, 15]</span><br></pre></td></tr></table></figure><p>你看，我们使用同一种切法，分别切开两个蛋糕cake1,cake2. 后来发现这种切法<code>极为经典</code>，又拿它去切更多的容器对象。</p><p>那么，为什么不把这种切法封装为一个对象呢？于是就有了slice对象。</p><p>定义slice对象极为简单，如把上面的切法定义成slice对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">perfect_cake_slice_way = slice(1,10,2)</span><br><span class="line">#去切cake1</span><br><span class="line">cake1_slice = cake1[perfect_cake_slice_way]</span><br><span class="line">cake2_slice = cake2[perfect_cake_slice_way]</span><br><span class="line"></span><br><span class="line">In [11]: cake1_slice</span><br><span class="line">Out[11]: [4, 2]</span><br><span class="line"></span><br><span class="line">In [12]: cake2_slice</span><br><span class="line">Out[12]: [75, 33, 63, 93, 15]</span><br></pre></td></tr></table></figure><p>与上面的结果一致。</p><p>对于逆向序列切片，<code>slice</code>对象一样可行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [1,3,5,7,9,0,3,5,7]</span><br><span class="line">a_ = a[5:1:-1]</span><br><span class="line"></span><br><span class="line">named_slice = slice(5,1,-1)</span><br><span class="line">a_slice = a[named_slice]</span><br><span class="line"></span><br><span class="line">In [14]: a_</span><br><span class="line">Out[14]: [0, 9, 7, 5]</span><br><span class="line"></span><br><span class="line">In [15]: a_slice</span><br><span class="line">Out[15]: [0, 9, 7, 5]</span><br></pre></td></tr></table></figure><p>频繁使用同一切片的操作可使用slice对象抽出来，复用的同时还能提高代码可读性。</p><h4 id="28-lambda-函数的动画演示"><a href="#28-lambda-函数的动画演示" class="headerlink" title="28 lambda 函数的动画演示"></a>28 lambda 函数的动画演示</h4><p>有些读者反映，<code>lambda</code>函数不太会用，问我能不能解释一下。</p><p>比如，下面求这个 <code>lambda</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def max_len(*lists):</span><br><span class="line">    return max(*lists, key=lambda v: len(v))</span><br></pre></td></tr></table></figure><p>有两点疑惑：</p><ul><li>参数<code>v</code>的取值？</li><li><code>lambda</code>函数有返回值吗？如果有，返回值是多少？</li></ul><p>调用上面函数，求出以下三个最长的列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = max_len([1, 2, 3], [4, 5, 6, 7], [8])</span><br><span class="line">print(f&#x27;更长的列表是&#123;r&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>程序完整运行过程，动画演示如下：</p><p><img src="https://aimak.cn/blog_img/python/python-lambda.gif"></p><p>结论：</p><ul><li>参数v的可能取值为<code>*lists</code>，也就是 <code>tuple</code> 的一个元素。</li><li><code>lambda</code>函数返回值，等于<code>lambda v</code>冒号后表达式的返回值。</li></ul><h2 id="四、-数据结构"><a href="#四、-数据结构" class="headerlink" title="四、 数据结构"></a>四、 数据结构</h2><h4 id="29-转为字典"><a href="#29-转为字典" class="headerlink" title="29 转为字典"></a>29 转为字典</h4><p>创建数据字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: dict()</span><br><span class="line">Out[1]: &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [2]: dict(a=&#x27;a&#x27;,b=&#x27;b&#x27;)</span><br><span class="line">Out[2]: &#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;&#125;</span><br><span class="line"></span><br><span class="line">In [3]: dict(zip([&#x27;a&#x27;,&#x27;b&#x27;],[1,2]))</span><br><span class="line">Out[3]: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span><br><span class="line"></span><br><span class="line">In [4]: dict([(&#x27;a&#x27;,1),(&#x27;b&#x27;,2)])</span><br><span class="line">Out[4]: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span><br></pre></td></tr></table></figure><h4 id="30-冻结集合"><a href="#30-冻结集合" class="headerlink" title="30 冻结集合"></a>30 冻结集合</h4><p>创建一个不可修改的集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: frozenset([1,1,3,2,3])</span><br><span class="line">Out[1]: frozenset(&#123;1, 2, 3&#125;)</span><br></pre></td></tr></table></figure><p>因为不可修改，所以没有像<code>set</code>那样的<code>add</code>和<code>pop</code>方法</p><h4 id="31-转为集合类型"><a href="#31-转为集合类型" class="headerlink" title="31 转为集合类型"></a>31 转为集合类型</h4><p>返回一个set对象，集合内不允许有重复元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [159]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [160]: set(a)</span><br><span class="line">Out[160]: &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h4 id="32-转为切片对象"><a href="#32-转为切片对象" class="headerlink" title="32 转为切片对象"></a>32 转为切片对象</h4><p><em>class</em> slice(<em>start</em>, <em>stop</em>[, <em>step</em>])</p><p>返回一个表示由 range(start, stop, step) 所指定索引集的 slice对象，它让代码可读性、可维护性变好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [2]: my_slice_meaning = slice(0,5,2)</span><br><span class="line"></span><br><span class="line">In [3]: a[my_slice_meaning]</span><br><span class="line">Out[3]: [1, 2, 1]</span><br></pre></td></tr></table></figure><h4 id="33-转元组"><a href="#33-转元组" class="headerlink" title="33 转元组"></a>33 转元组</h4><p><code>tuple()</code> 将对象转为一个不可变的序列类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [16]: i_am_list = [1,3,5]</span><br><span class="line">In [17]: i_am_tuple = tuple(i_am_list)</span><br><span class="line">In [18]: i_am_tuple</span><br><span class="line">Out[18]: (1, 3, 5)</span><br></pre></td></tr></table></figure><h2 id="五、-类和对象"><a href="#五、-类和对象" class="headerlink" title="五、 类和对象"></a>五、 类和对象</h2><h4 id="34-是否可调用"><a href="#34-是否可调用" class="headerlink" title="34 是否可调用"></a>34 是否可调用</h4><p>检查对象是否可被调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [1]: callable(str)</span><br><span class="line">Out[1]: True</span><br><span class="line"></span><br><span class="line">In [2]: callable(int)</span><br><span class="line">Out[2]: True</span><br><span class="line">In [18]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">In [19]: xiaoming = Student(&#x27;001&#x27;,&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [20]: callable(xiaoming)</span><br><span class="line">Out[20]: False</span><br></pre></td></tr></table></figure><p>如果能调用<code>xiaoming()</code>, 需要重写<code>Student</code>类的<code>__call__</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...:     def __call__(self):</span><br><span class="line">    ...:         print(&#x27;I can be called&#x27;)</span><br><span class="line">    ...:         print(f&#x27;my name is &#123;self.name&#125;&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [2]: t = Student(&#x27;001&#x27;,&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [3]: t()</span><br><span class="line">I can be called</span><br><span class="line">my name is xiaoming</span><br></pre></td></tr></table></figure><h4 id="35-ascii-展示对象"><a href="#35-ascii-展示对象" class="headerlink" title="35 ascii 展示对象"></a>35 ascii 展示对象</h4><p>调用对象的 <code>__repr__</code> 方法，获得该方法的返回值，如下例子返回值为字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student():</span><br><span class="line">    def __init__(self,id,name):</span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; xiaoming = Student(id=&#x27;1&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">&gt;&gt;&gt; xiaoming</span><br><span class="line">id = 1, name = xiaoming</span><br><span class="line">&gt;&gt;&gt; ascii(xiaoming)</span><br><span class="line">&#x27;id = 1, name = xiaoming&#x27;</span><br></pre></td></tr></table></figure><h4 id="36-类方法"><a href="#36-类方法" class="headerlink" title="36 类方法"></a>36 类方法</h4><p><code>classmethod</code> 装饰器对应的函数不需要实例化，不需要 <code>self </code>参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...:     @classmethod</span><br><span class="line">    ...:     def f(cls):</span><br><span class="line">    ...:         print(cls)</span><br></pre></td></tr></table></figure><h4 id="37-动态删除属性"><a href="#37-动态删除属性" class="headerlink" title="37 动态删除属性"></a>37 动态删除属性</h4><p>删除对象的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: delattr(xiaoming,&#x27;id&#x27;)</span><br><span class="line"></span><br><span class="line">In [2]: hasattr(xiaoming,&#x27;id&#x27;)</span><br><span class="line">Out[2]: False</span><br></pre></td></tr></table></figure><h4 id="38-一键查看对象所有方法"><a href="#38-一键查看对象所有方法" class="headerlink" title="38 一键查看对象所有方法"></a>38 一键查看对象所有方法</h4><p>不带参数时返回<code>当前范围</code>内的变量、方法和定义的类型列表；带参数时返回<code>参数</code>的属性，方法列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [96]: dir(xiaoming)</span><br><span class="line">Out[96]:</span><br><span class="line">[&#x27;__class__&#x27;,</span><br><span class="line"> &#x27;__delattr__&#x27;,</span><br><span class="line"> &#x27;__dict__&#x27;,</span><br><span class="line"> &#x27;__dir__&#x27;,</span><br><span class="line"> &#x27;__doc__&#x27;,</span><br><span class="line"> &#x27;__eq__&#x27;,</span><br><span class="line"> &#x27;__format__&#x27;,</span><br><span class="line"> &#x27;__ge__&#x27;,</span><br><span class="line"> &#x27;__getattribute__&#x27;,</span><br><span class="line"> &#x27;__gt__&#x27;,</span><br><span class="line"> &#x27;__hash__&#x27;,</span><br><span class="line"> &#x27;__init__&#x27;,</span><br><span class="line"> &#x27;__init_subclass__&#x27;,</span><br><span class="line"> &#x27;__le__&#x27;,</span><br><span class="line"> &#x27;__lt__&#x27;,</span><br><span class="line"> &#x27;__module__&#x27;,</span><br><span class="line"> &#x27;__ne__&#x27;,</span><br><span class="line"> &#x27;__new__&#x27;,</span><br><span class="line"> &#x27;__reduce__&#x27;,</span><br><span class="line"> &#x27;__reduce_ex__&#x27;,</span><br><span class="line"> &#x27;__repr__&#x27;,</span><br><span class="line"> &#x27;__setattr__&#x27;,</span><br><span class="line"> &#x27;__sizeof__&#x27;,</span><br><span class="line"> &#x27;__str__&#x27;,</span><br><span class="line"> &#x27;__subclasshook__&#x27;,</span><br><span class="line"> &#x27;__weakref__&#x27;,</span><br><span class="line"> </span><br><span class="line"> &#x27;name&#x27;]</span><br></pre></td></tr></table></figure><h4 id="39-动态获取对象属性"><a href="#39-动态获取对象属性" class="headerlink" title="39 动态获取对象属性"></a>39 动态获取对象属性</h4><p>获取对象的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: getattr(xiaoming,&#x27;name&#x27;) # 获取xiaoming这个实例的name属性值</span><br><span class="line">Out[3]: &#x27;xiaoming&#x27;</span><br></pre></td></tr></table></figure><h4 id="40-对象是否有这个属性"><a href="#40-对象是否有这个属性" class="headerlink" title="40 对象是否有这个属性"></a>40 对象是否有这个属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: hasattr(xiaoming,&#x27;name&#x27;)</span><br><span class="line">Out[3]: True</span><br><span class="line"></span><br><span class="line">In [4]: hasattr(xiaoming,&#x27;address&#x27;)</span><br><span class="line">Out[4]: False</span><br></pre></td></tr></table></figure><h4 id="41-对象门牌号"><a href="#41-对象门牌号" class="headerlink" title="41 对象门牌号"></a>41 对象门牌号</h4><p>返回对象的内存地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: id(xiaoming)</span><br><span class="line">Out[1]: 98234208</span><br></pre></td></tr></table></figure><h4 id="42-isinstance"><a href="#42-isinstance" class="headerlink" title="42 isinstance"></a>42 isinstance</h4><p>判断<em>object</em>是否为类<em>classinfo</em>的实例，是返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [3]: isinstance(xiaoming,Student)</span><br><span class="line">Out[3]: True</span><br></pre></td></tr></table></figure><h4 id="43-父子关系鉴定"><a href="#43-父子关系鉴定" class="headerlink" title="43 父子关系鉴定"></a>43 父子关系鉴定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class undergraduate(Student):</span><br><span class="line">    ...:     def studyClass(self):</span><br><span class="line">    ...:         pass</span><br><span class="line">    ...:     def attendActivity(self):</span><br><span class="line">    ...:         pass</span><br><span class="line"></span><br><span class="line">In [2]: issubclass(undergraduate,Student)</span><br><span class="line">Out[2]: True</span><br><span class="line"></span><br><span class="line">In [3]: issubclass(object,Student)</span><br><span class="line">Out[3]: False</span><br><span class="line"></span><br><span class="line">In [4]: issubclass(Student,object)</span><br><span class="line">Out[4]: True</span><br></pre></td></tr></table></figure><p>如果class是classinfo元组中某个元素的子类，也会返回True</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: issubclass(int,(int,float))</span><br><span class="line">Out[1]: True</span><br></pre></td></tr></table></figure><h4 id="44-所有对象之根"><a href="#44-所有对象之根" class="headerlink" title="44 所有对象之根"></a>44 所有对象之根</h4><p>object 是所有类的基类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: o = object()</span><br><span class="line"></span><br><span class="line">In [2]: type(o)</span><br><span class="line">Out[2]: object</span><br></pre></td></tr></table></figure><h4 id="45-创建属性的两种方式"><a href="#45-创建属性的两种方式" class="headerlink" title="45 创建属性的两种方式"></a>45 创建属性的两种方式</h4><p>返回 property 属性，典型的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"></span><br><span class="line">    def getx(self):</span><br><span class="line">        return self._x</span><br><span class="line"></span><br><span class="line">    def setx(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    def delx(self):</span><br><span class="line">        del self._x</span><br><span class="line">    # 使用property类创建 property 属性</span><br><span class="line">    x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span><br></pre></td></tr></table></figure><p>使用python装饰器，实现与上完全一样的效果代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def x(self):</span><br><span class="line">        return self._x</span><br><span class="line"></span><br><span class="line">    @x.setter</span><br><span class="line">    def x(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    @x.deleter</span><br><span class="line">    def x(self):</span><br><span class="line">        del self._x</span><br></pre></td></tr></table></figure><h4 id="46-查看对象类型"><a href="#46-查看对象类型" class="headerlink" title="46 查看对象类型"></a>46 查看对象类型</h4><p><em>class</em> <code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>)</p><p>传入一个参数时，返回 <em>object</em> 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: type(xiaoming)</span><br><span class="line">Out[3]: __main__.Student</span><br><span class="line"></span><br><span class="line">In [4]: type(tuple())</span><br><span class="line">Out[4]: tuple</span><br></pre></td></tr></table></figure><h4 id="47-元类"><a href="#47-元类" class="headerlink" title="47 元类"></a>47 元类</h4><p><code>xiaoming</code>, <code>xiaohong</code>, <code>xiaozhang</code> 都是学生，这类群体叫做 <code>Student</code>.</p><p>Python 定义类的常见方法，使用关键字 <code>class</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [36]: class Student(object):</span><br><span class="line">    ...:     pass</span><br></pre></td></tr></table></figure><p><code>xiaoming</code>, <code>xiaohong</code>, <code>xiaozhang</code> 是类的实例，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Student()</span><br><span class="line">xiaohong = Student()</span><br><span class="line">xiaozhang = Student()</span><br></pre></td></tr></table></figure><p>创建后，xiaoming 的 <code>__class__</code> 属性，返回的便是 <code>Student</code>类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [38]: xiaoming.__class__</span><br><span class="line">Out[38]: __main__.Student</span><br></pre></td></tr></table></figure><p>问题在于，<code>Student</code> 类有 <code>__class__</code>属性，如果有，返回的又是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [39]: xiaoming.__class__.__class__</span><br><span class="line">Out[39]: type</span><br></pre></td></tr></table></figure><p>哇，程序没报错，返回 <code>type</code></p><p>那么，我们不妨猜测：<code>Student</code> 类，类型就是 <code>type</code>，换句话说，<code>Student</code>类就是一个对象，它的类型就是 <code>type</code>，所以，Python 中一切皆对象，类也是对象</p><p>Python 中，将描述 <code>Student</code> 类的类被称为：元类。</p><p>按照此逻辑延伸，描述元类的类被称为：<em>元元类</em>，开玩笑了~ 描述元类的类也被称为元类。</p><p>聪明的朋友会问了，既然 <code>Student</code> 类可创建实例，那么 <code>type</code> 类可创建实例吗？如果能，它创建的实例就叫：类 了。你们真聪明！</p><p>说对了，<code>type</code> 类一定能创建实例，比如 <code>Student</code> 类了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [40]: Student = type(&#x27;Student&#x27;,(),&#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [41]: Student</span><br><span class="line">Out[41]: __main__.Student</span><br></pre></td></tr></table></figure><p>它与使用 <code>class</code> 关键字创建的 <code>Student</code> 类一模一样。</p><p>Python 的类，因为又是对象，所以和 <code>xiaoming</code>，<code>xiaohong</code> 对象操作相似。支持：</p><ul><li>赋值</li><li>拷贝</li><li>添加属性</li><li>作为函数参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [43]: StudentMirror = Student # 类直接赋值 # 类直接赋值</span><br><span class="line">In [44]: Student.class_property = &#x27;class_property&#x27; # 添加类属性</span><br><span class="line">In [46]: hasattr(Student, &#x27;class_property&#x27;)</span><br><span class="line">Out[46]: True</span><br></pre></td></tr></table></figure><p>元类，确实使用不是那么多，也许先了解这些，就能应付一些场合。就连 Python 界的领袖 <code>Tim Peters</code> 都说：</p><p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。</p><h2 id="六、工具"><a href="#六、工具" class="headerlink" title="六、工具"></a>六、工具</h2><h4 id="48-枚举对象"><a href="#48-枚举对象" class="headerlink" title="48 枚举对象"></a>48 枚举对象</h4><p>返回一个可以枚举的对象，该对象的next()方法将返回一个元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">    ...: for i ,v in enumerate(s,1):</span><br><span class="line">    ...:     print(i,v)</span><br><span class="line">    ...:</span><br><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 c</span><br></pre></td></tr></table></figure><h4 id="49-查看变量所占字节数"><a href="#49-查看变量所占字节数" class="headerlink" title="49 查看变量所占字节数"></a>49 查看变量所占字节数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import sys</span><br><span class="line"></span><br><span class="line">In [2]: a = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2.0&#125;</span><br><span class="line"></span><br><span class="line">In [3]: sys.getsizeof(a) # 占用240个字节</span><br><span class="line">Out[3]: 240</span><br></pre></td></tr></table></figure><h4 id="50-过滤器"><a href="#50-过滤器" class="headerlink" title="50 过滤器"></a>50 过滤器</h4><p>在函数中设定过滤条件，迭代元素，保留返回值为<code>True</code>的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: fil = filter(lambda x: x&gt;10,[1,11,2,45,7,6,13])</span><br><span class="line"></span><br><span class="line">In [2]: list(fil)</span><br><span class="line">Out[2]: [11, 45, 13]</span><br></pre></td></tr></table></figure><h4 id="51-返回对象的哈希值"><a href="#51-返回对象的哈希值" class="headerlink" title="51 返回对象的哈希值"></a>51 返回对象的哈希值</h4><p>返回对象的哈希值，值得注意的是自定义的实例都是可哈希的，<code>list</code>, <code>dict</code>, <code>set</code>等可变对象都是不可哈希的(unhashable)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hash(xiaoming)</span><br><span class="line">Out[1]: 6139638</span><br><span class="line"></span><br><span class="line">In [2]: hash([1,2,3])</span><br><span class="line"># TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure><h4 id="52-一键帮助"><a href="#52-一键帮助" class="headerlink" title="52 一键帮助"></a>52 一键帮助</h4><p>返回对象的帮助文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [1]: help(xiaoming)</span><br><span class="line">Help on Student in module __main__ object:</span><br><span class="line"></span><br><span class="line">class Student(builtins.object)</span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __init__(self, id, name)</span><br><span class="line"> |</span><br><span class="line"> |  __repr__(self)</span><br><span class="line"> |</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br></pre></td></tr></table></figure><h3 id="53-获取用户输入"><a href="#53-获取用户输入" class="headerlink" title="53 获取用户输入"></a>53 获取用户输入</h3><p>获取用户输入内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [1]: input()</span><br><span class="line">aa</span><br><span class="line">Out[1]: &#x27;aa&#x27;</span><br></pre></td></tr></table></figure><h4 id="54-创建迭代器类型"><a href="#54-创建迭代器类型" class="headerlink" title="54 创建迭代器类型"></a>54 创建迭代器类型</h4><p>使用<code>iter(obj, sentinel)</code>, 返回一个可迭代对象, sentinel可省略(一旦迭代到此元素，立即终止)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [1]: lst = [1,3,5]</span><br><span class="line"></span><br><span class="line">In [2]: for i in iter(lst):</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">In [1]: class TestIter(object):</span><br><span class="line">    ...:     def __init__(self):</span><br><span class="line">    ...:         self.l=[1,3,2,3,4,5]</span><br><span class="line">    ...:         self.i=iter(self.l)</span><br><span class="line">    ...:     def __call__(self):  #定义了__call__方法的类的实例是可调用的</span><br><span class="line">    ...:         item = next(self.i)</span><br><span class="line">    ...:         print (&quot;__call__ is called,fowhich would return&quot;,item)</span><br><span class="line">    ...:         return item</span><br><span class="line">    ...:     def __iter__(self): #支持迭代协议(即定义有__iter__()函数)</span><br><span class="line">    ...:         print (&quot;__iter__ is called!!&quot;)</span><br><span class="line">    ...:         return iter(self.l)</span><br><span class="line">In [2]: t = TestIter()</span><br><span class="line">In [3]: t() # 因为实现了__call__，所以t实例能被调用</span><br><span class="line">__call__ is called,which would return 1</span><br><span class="line">Out[3]: 1</span><br><span class="line"></span><br><span class="line">In [4]: for e in TestIter(): # 因为实现了__iter__方法，所以t能被迭代</span><br><span class="line">    ...:     print(e)</span><br><span class="line">    ...:</span><br><span class="line">__iter__ is called!!</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="55-打开文件"><a href="#55-打开文件" class="headerlink" title="55 打开文件"></a>55 打开文件</h4><p>返回文件对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: fo = open(&#x27;D:/a.txt&#x27;,mode=&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">In [2]: fo.read()</span><br><span class="line">Out[2]: &#x27;\ufefflife is not so long,\nI use Python to play.&#x27;</span><br></pre></td></tr></table></figure><p>mode取值表：</p><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td><code>&#39;r&#39;</code></td><td>读取（默认）</td></tr><tr><td><code>&#39;w&#39;</code></td><td>写入，并先截断文件</td></tr><tr><td><code>&#39;x&#39;</code></td><td>排它性创建，如果文件已存在则失败</td></tr><tr><td><code>&#39;a&#39;</code></td><td>写入，如果文件存在则在末尾追加</td></tr><tr><td><code>&#39;b&#39;</code></td><td>二进制模式</td></tr><tr><td><code>&#39;t&#39;</code></td><td>文本模式（默认）</td></tr><tr><td><code>&#39;+&#39;</code></td><td>打开用于更新（读取与写入）</td></tr></tbody></table><h4 id="56-创建range序列"><a href="#56-创建range序列" class="headerlink" title="56 创建range序列"></a>56 创建range序列</h4><ol><li>range(stop)</li><li>range(start, stop[,step])</li></ol><p>生成一个不可变序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: range(11)</span><br><span class="line">Out[1]: range(0, 11)</span><br><span class="line"></span><br><span class="line">In [2]: range(0,11,1)</span><br><span class="line">Out[2]: range(0, 11)</span><br></pre></td></tr></table></figure><h4 id="57-反向迭代器"><a href="#57-反向迭代器" class="headerlink" title="57 反向迭代器"></a>57 反向迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: rev = reversed([1,4,2,3,1])</span><br><span class="line"></span><br><span class="line">In [2]: for i in rev:</span><br><span class="line">     ...:     print(i)</span><br><span class="line">     ...:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="58-聚合迭代器"><a href="#58-聚合迭代器" class="headerlink" title="58 聚合迭代器"></a>58 聚合迭代器</h4><p>创建一个聚合了来自每个可迭代对象中的元素的迭代器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: x = [3,2,1]</span><br><span class="line">In [2]: y = [4,5,6]</span><br><span class="line">In [3]: list(zip(y,x))</span><br><span class="line">Out[3]: [(4, 3), (5, 2), (6, 1)]</span><br><span class="line"></span><br><span class="line">In [4]: a = range(5)</span><br><span class="line">In [5]: b = list(&#x27;abcde&#x27;)</span><br><span class="line">In [6]: b</span><br><span class="line">Out[6]: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line">In [7]: [str(y) + str(x) for x,y in zip(a,b)]</span><br><span class="line">Out[7]: [&#x27;a0&#x27;, &#x27;b1&#x27;, &#x27;c2&#x27;, &#x27;d3&#x27;, &#x27;e4&#x27;]</span><br></pre></td></tr></table></figure><h4 id="59-链式操作"><a href="#59-链式操作" class="headerlink" title="59 链式操作"></a>59 链式操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from operator import (add, sub)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_or_sub(a, b, oper):</span><br><span class="line">    return (add if oper == &#x27;+&#x27; else sub)(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_or_sub(1, 2, &#x27;-&#x27;)  # -1</span><br></pre></td></tr></table></figure><h4 id="60-对象序列化"><a href="#60-对象序列化" class="headerlink" title="60 对象序列化"></a>60 对象序列化</h4><p>对象序列化，是指将内存中的对象转化为可存储或传输的过程。很多场景，直接一个类对象，传输不方便。</p><p>但是，当对象序列化后，就会更加方便，因为约定俗成的，接口间的调用或者发起的 web 请求，一般使用 json 串传输。</p><p>实际使用中，一般对类对象序列化。先创建一个 Student 类型，并创建两个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student():</span><br><span class="line">    def __init__(self,**args):</span><br><span class="line">        self.ids = args[&#x27;ids&#x27;]</span><br><span class="line">        self.name = args[&#x27;name&#x27;]</span><br><span class="line">        self.address = args[&#x27;address&#x27;]</span><br><span class="line">xiaoming = Student(ids = 1,name = &#x27;xiaoming&#x27;,address = &#x27;北京&#x27;)</span><br><span class="line">xiaohong = Student(ids = 2,name = &#x27;xiaohong&#x27;,address = &#x27;南京&#x27;)</span><br></pre></td></tr></table></figure><p>导入 json 模块，调用 dump 方法，就会将列表对象 [xiaoming,xiaohong]，序列化到文件 json.txt 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&#x27;json.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    json.dump([xiaoming,xiaohong], f, default=lambda obj: obj.__dict__, ensure_ascii=False, indent=2, sort_keys=True)</span><br></pre></td></tr></table></figure><p>生成的文件内容，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;address&quot;:&quot;北京&quot;,</span><br><span class="line">        &quot;ids&quot;:1,</span><br><span class="line">        &quot;name&quot;:&quot;xiaoming&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;address&quot;:&quot;南京&quot;,</span><br><span class="line">        &quot;ids&quot;:2,</span><br><span class="line">        &quot;name&quot;:&quot;xiaohong&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em><strong>*<br>*</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jackzhenguo/python-small-example&quot;&gt;https://github.com/jackzhenguo/python-small-example</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="python" scheme="http://ai.mak.cn/tags/python/"/>
    
  </entry>
  
</feed>
