<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>云端研发新基建：Serverless 与持续架构服务落地实践</title>
    <link href="http://ai.mak.cn/2020/06/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%91%E7%AB%AF%E7%A0%94%E5%8F%91%E6%96%B0%E5%9F%BA%E5%BB%BA%EF%BC%9AServerless%20%E4%B8%8E%E6%8C%81%E7%BB%AD%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2020/06/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%91%E7%AB%AF%E7%A0%94%E5%8F%91%E6%96%B0%E5%9F%BA%E5%BB%BA%EF%BC%9AServerless%20%E4%B8%8E%E6%8C%81%E7%BB%AD%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2023-01-10T15:12:26.117Z</updated>
    
    <content type="html"><![CDATA[<p><strong>云时代创新核心要素</strong></p><p>首先，让我们快速将视野放大到社会商业爆炸式增长的云时代，无论是创业公司还是发展中的公司，都希望能有一个低成本、可持续支撑的架构服务，帮助自己的业务持续发展，用户流量从小到大，无需变更架构，更不用中断业务。</p><p>这种架构服务诉求背后的核心痛点体现在业务快速试错与流量快速增长之间的矛盾。如果从传统的架构方式去思考，这个问题很难调和：</p><ul><li>如果要快速奔跑，就没有时间好好思考设计架构。</li><li>如果架构设计不好，就无法支撑未来巨大的流量。</li><li>而如果花时间把架构设计好再动手，就没办法快速奔跑，很可能错过一个商业创新的时间窗口。</li><li>另外，还有一个未知的疑问，这个设计好的架构真的够好么？</li></ul><p>结合我们之前的探索实践，我们知道，借助云原生 Serverless 的能力：实时弹性、按量付费，正好可以帮助我们把上述问题提升到一个新的维度去解决：业务完全可以放飞自我快速奔跑，架构服务由云原生 Serverless 矩阵来提供，保证流量再大也不怕。</p><p><strong>中小研发生态现状</strong></p><p>基于上述的一个判断，我们认为，现代商业社会的启动过程：从一个 idea 的诞生，到快速试错，再到上线服务用户的过程，有了一个很好的方案去支撑。但是，就像布道师们经常讲的一句话，人人都在谈云原生 Serverless，实际上并不是人人都知道怎么落地 Serverless。我们不妨来看几个真实的创业公司案例。</p><p><strong>案例一 天猫精灵技能业务</strong></p><p>天猫精灵的技能应用开发本身与天猫精灵开发者平台之前的连接较为松散，技能应用的开发对于一个中小开发者而言，启动成本较高。开发技能应用过程中的技术栈和方案也因人而异，因团队而异，也由于广大的开发者对技能应用背后的大流量没有一个一致的高水位保障，使得天猫精灵平台在做推广的时候也经常遇到阻力，担心在推广之后，很多技能无法承载大量涌入的活动流量，反而影响活动效果。</p><p><strong>案例二 某直播互动健身创业公司</strong></p><p>Y 公司是一家面对面直播互动健身的创业公司，研发团队的构成有 2 个前端、2 个后端、1 个架构师、1 个 iOS、1 个产品经理、1 个设计师，产品的构成有微信小程序、iOS APP、Android APP、PC 端 WEB 应用。</p><p>当前的核心痛点及诉求：</p><ul><li><p>研发成本、架构人员的浪费（这已经算是幸福的烦恼了，很多公司是找不到合格的架构师的）。</p></li><li><p>新人落地的成本（每个新人都有 3 个月的熟悉环境、流程、业务的成本）。</p></li><li><p>自研自建业务架构的成本，要等业务架构确定后才能动手。</p></li><li><p>业务线切换的沉默成本比较高，如新业务启动到上线：技术架构的选型、服务的复用等等都是损耗。</p></li><li><p>运维成本，如：承接推活动来的高峰流量以及平时流量的平均成本。</p></li></ul><p><strong>案例三 某软件外包服务商</strong></p><p>O 公司是一家 base 杭州的软件外包服务商，他们的研发团队构成为：5 个 Java、4 个前端、1 个 iOS、1 个 Android、1 个产品经理、2 个测试、5 个商务、6 个品牌、2 个 UI 设计；</p><p>当前的核心痛点及诉求：</p><ul><li><p>10 人以下规模来什么做什么，没有沉淀，没有办法复用，没有高的盈利回报，人都铺在业务上，没时间学习架构，进入了一个恶性循环，需要一个很低的成本去采用一个先进的技术架构方案，确保不落伍，同时可以继续聚焦业务开发；有了可复用的空间（如架构、组件、服务）才有盈利的空间。10 人以下的外包公司，CTO 是不太可能去招的，40 万一年的话，公司一半的利润就没了。</p></li><li><p>想依托于云，不过每家云厂商都产品众多，围绕自己的业务怎么知道有哪些产品适合，要一个个去挑选、学习，整体成本太高。</p></li></ul><p><strong>核心要解决的问题以及产品化思考</strong></p><p>我们将上述调研的客户反馈诉求进行梳理，可以归纳出以下几点诉求：</p><ul><li><p>人员、业务尽可能做到快速启动，低成本启动。开发人员能够快速进入业务开发，架构师能省就省，业务能够基于行业现有解决方案、基本业务架构、业务模块尽快启动。</p></li><li><p>开发人员的时间尽可能投入到业务开发中，但同时要保证业务所用技术架构的先进性：一个人的时间是恒定的，如何帮助中小企业把人员投入业务的时间从 60% 提高到 99%，同时还能确保业务背后所用的技术栈及技术架构是行业内广受认可的。</p></li><li><p>线上业务能够做到按量付费：1、业务的流量高峰不会成为业务增长的瓶颈；2、类似于外包服务商&#x2F;ISV，可以为他们的客户灵活制定弹性的服务体系。</p></li></ul><p>基于以上三点，我们进一步抽象用户群体以及场景和服务策略：</p><p><strong>主要用户群体</strong></p><ol><li>中小体量研发团队及创业公司研发团队</li><li>要做开发生态的业务或平台</li><li>行业软件&#x2F;解决方案 ISV&#x2F;服务商</li></ol><p><strong>场景和服务策略</strong></p><p>在快速商业化试错的创新创业场景下，通过集成设计以阿里云 Serverless 产品线为矩阵的业务架构，帮助用户快速迭代业务，同时保证业务上线后无需变更架构就可以持续支撑不断增长的流量，确保业务不中断，提高试错效率，降低试错成本。</p><p>在研发人员需要支持多业务线切换调度的场景下，通过集成云效研发协同底座的能力构建在线研发团队，通过设计解决方案实例化的能力构建统一应用开发环境，降低开发者在业务切换中的沉默成本，让开发者可以快速且专注地进入业务逻辑的开发，提高研发效率。</p><p>在需要快速启动业务的场景下，通过构建三套业务环境，帮助用户实现环境在线，降低环境准备的时间成本与投入成本。</p><p>为研发团队提供一种将应用开发方法和结果抽象成标准的格式化的解决方案的能力，用该解决方案统一快速地教育开发者。</p><p>定义了用户群体、问题、场景以及服务策略之后，我们开始尝试去定义这个产品：我们要去打造一个全云端研发工作的平台，以业务、研发任务为用户界面，用户对云产品的感知尽量保持并限制在必要的情况之下，但是平台要在背后为他们提供一系列先进的云原生 Serverless 架构服务，同时，具备让用户的团队、环境、代码、协同等等实现在线的能力，帮助目标用户群体省钱、省时、可持续发展。</p><p><strong>核心技术方案</strong></p><p>作为一个面向用户业务视角而非云产品或任何单项研发能力视角的设计，背后就必不可少的要跟非常多的系统、产品、能力进行集成；并且，要达成与用户业务视角的关联，又需要额外设计一套核心应用模型去支撑。这里，我们通过两个架构设计，向大家阐述我们的实现思路与方式。</p><p>系统集成架构</p><p><img src="https://aimak.cn/blog_img/sys/system_jicheng.png"></p><p>认同在线协同是大趋势。我们把自己定义为大协同领域的一环，最好能够依托于一个更具全局性的团队在线协同底座去建设，我们与云效合作共建，基于一个共同的团队模型以及数据去设计实现不同的领域能力。</p><p>原子研发能力分布广泛，以代码为主线进行串联设计，在开发者用户路径中，我们与 Codeup、Flow 等产品进行集成，与经济体共建 IDE 集成，共同推出 CloudIDE，为开发者提供从云上代码托管到云上研发，再到云上 CICD 的一站式服务。</p><p>解决方案实例化架构</p><p>用技术语言来描述的话，可以把解决方案实例化架构核心要解决的问题理解成将一个行业应用的开发经验进行 “序列化” 与 “反序列化” 的过程。</p><p>我们与 OAM 团队合作，以 OAM 为规范，对构成一个行业应用的研发环境以及依赖资源进行格式化、规范化的描述，生成一个云开发平台所能理解和认识的解决方案，这是“序列化”的过程。</p><p>当云开发平台去解析一个解决方案，核心会做两件事情，一是分析和生成一个基于阿里云产品矩阵构成的云原生 Serverless 架构，另一件事情是将依赖的资源做打包上传等预处理；然后开始生成任务，逐一进行生产、创建、安装，直至一个行业应用被初始化完成，这是“反序列化”的过程。</p><p>通过这种设计，我们实现了云开发平台最为核心的能力：</p><ol><li>帮助行业开发生态格式化、规范化地沉淀经验。</li><li>帮助行业开发生态快速分发、复制行业应用开发经验。</li><li>帮助行业开发生态无缝升级至先进的云原生 Serverless 架构。</li></ol><p><strong>阿里云云开发平台正式上线服务</strong></p><p>2020 年 4 月 23 日，阿里云云开发平台联合天猫精灵智能应用平台共同发布，上线云开发服务功能；2020 年 4 月 28 日，阿里云云开发平台联合阿里前端委员会 Serverless 小组，共同发布基于 Ali Midway FaaS 框架的前后端一体通用 NodeJS 解决方案。2020年5月28日，与阿里巴巴云原生团队合作推出基于 SpringCloud、MSE 的微服务应用开发解决方案，轻松将微服务开发并部署在 Serverless 平台之上，帮助开发者以 0 启动成本、基于云原生 Serverless 架构服务，3 分钟极致效率，完成一个标准技能应用的创建和部署。</p><p>在 Roadmap 中，还有微服务、小程序、大数据等场景解决方案将陆续上线。</p><p>感受云开发平台的极致特性</p><p><strong>1 个开发界面</strong></p><ul><li>打开浏览器就能开发</li><li>不管你用什么设备，电脑、手机、平板</li><li>不管是什么操作系统，Windows、MacOS、Linux、Android、iOS</li></ul><p><strong>1 套统一的业务环境</strong></p><ul><li>统一的云上开发和业务环境（支持 NodeJS，Java，PhP，Python, C# 等主流语言）</li><li>登录即完成配置，无需等待，专注业务创新</li><li>远程协同开发、所测即所得、测完即上线</li></ul><p><strong>1 个领先的架构</strong></p><ul><li>基于业界领先的 Serverless 架构</li><li>最快 1 秒钟部署</li><li>按量付费不浪费，自动扩容不宕机</li></ul><p><strong>N 个行业应用场景</strong></p><ul><li>解决方案模版化</li><li>最快 3 分钟上线一个行业应用（通用 WEB 应用，AIoT 应用，微服务应用等等）</li><li>99% 时间聚焦在业务，开发更专注</li></ul><p>了解云开发平台的运作方式</p><p>云开发平台是一个可以满足开发者、研发团队完全基于「云+浏览器」就能完成日常开发工作的环境。它的设计理念是使自己成为团队大协同中的一环，它会跟阿里云诸多研发能力和工具进行集成，比如：云效企业协同底座、CloudIDE、Codeup、Flow 等等，籍由强大的阿里研发生态，为用户提供更大的协同研发可能，用户可以在使用云开发平台的时候，根据业务的需要，主动选择去开通使用更多类似于项目管理、需求管理、文档管理等其他服务。</p><p>同时，为了帮助用户提供一个无缝应用阿里云服务的环境，云开发平台会跟阿里云的诸多云产品进行集成，随时为用户的使用而准备；用户可以在云开发平台创建基于各种场景解决方案的应用，并为每个应用选用不同的云服务，这些云服务会开通在用户的阿里云主账号之下，用户主动开通的各种云资源会按照用户的使用，正常地计量计费。</p><p>云开发平台鼓励所有的场景解决方案尽可能多的基于阿里云的 Serverless 类型产品去提供服务。Serverless 类型的产品都具有实时弹性以及按量付费的特征，这可以帮助到商业化研发团队，以尽可能低的成本去实现自己的商业价值。</p><p><strong>云开发平台具体如何真实地帮到目标用户群体</strong></p><p>云开发平台如何帮助用户实现线上轻量化团队协同？</p><p>我们联合云效，共同构建了一个在线研发团队的能力，团队规模从 1-10 人 到 1000 人以上，全都免费提供，助力企业快速成长！</p><p>1 分钟完成研发团队的在线化：在云开发平台，团队管理者创建好自己的企业，然后创建一批子账号分配给每一个团队成员，团队即完成了在线化。</p><p>如果用户企业内已经有一套域账号系统，那么通过对接阿里云 SP 的 SAML 配置之后，能够方便实现用域账号的 SSO。</p><p>如果团队并非组织关系型怎么办呢？在云开发平台，团队管理者创建好自己的企业，然后复制邀请链接，发送给那些并非组织关系里的成员，收到邀请的成员确认加入团队即完成团队的在线化。</p><p>云开发平台如何帮助用户实现业务的快速启动呢？</p><p>团队在线之后就要开始启动业务。</p><p><strong>新业务秒级启动</strong></p><p>在云开发平台，团队管理员可以从应用场景中，选择一个成熟的行业应用解决方案，秒级完成应用的创建。</p><p><strong>业务开发人员直接进入业务开发，100% focus 在业务的开发交付</strong></p><p>在云工作台，我们优化了以往传统线下研发模式中人人需要配置开发环境的弊端，将人人要做的事情，交由应用管理员一人执行，业务开发者登录云开发平台即开始业务开发。</p><p>云开发平台如何帮助用户实现研发环境的升级呢？</p><p>团队在线了，应用在线了，还剩下的环节就是代码和研发过程。</p><p><strong>安全可靠且免费的代码托管服务</strong></p><p>云开发平台联合阿里云 Codeup，在云开发平台创建的每一个应用，都会自动分配一个免费的代码仓库，为用户提供安全可靠且免费的代码托管服务，帮助用户实现代码在线。</p><p><strong>功能强大的云端开发环境</strong></p><p>云开发平台联合阿里经济体共建团队推出自研 CloudIDE，为用户提供功能强大，兼容 VS Code 插件生态的云端开发环境，内置 NodeJS，Java，PhP，Python，C# 等主流语言开发环境，开箱即用，体验媲美本地；当然，开发者也可以选择将代码克隆到本地，继续以个人偏好的开发习惯进行开发，之后随时将代码同步到云端，做到云端与本地的实时同步。</p><p><strong>业界领先的 Serverless 架构</strong></p><p>在每一个应用的背后，都有强大的阿里云 Serverless 产品矩阵构成的架构服务在支撑，API Gateway+Function Compute 组合、VPC+ECI+EIP 组合等等，保障每一个应用上线，都能稳稳地支撑，轻松助力用户不断攀登新的业绩高峰。</p><p><strong>0 成本启动</strong></p><p>基于强大的云开发平台服务以及阿里云 Serverless 架构矩阵，我们帮用户把 Serverless 如丝般顺滑落地到他们的业务之中，大胆开发，放心试错，无需为云开发平台支付任何费用。</p><p><strong>回顾</strong></p><p>在这次突如其来的疫情期间，所有人都隔离在家，也许千人规模的企业能够有内部的强大 IT 系统做支撑，整个企业仍然可以进行远程异地运转，但是对于广大的初创及成长中的企业，这种能力无疑是稀缺的，而在线，可能是未来的一个趋势和常态。今天，随着阿里云云开发平台服务的上线，我们可以真正帮助到这些企业，通过用户业务视角、用户研发界面、提供云计算的开箱即用，去释放云上研发，Serverless 架构的技术红利，推动云计算的普惠价值！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;云时代创新核心要素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，让我们快速将视野放大到社会商业爆炸式增长的云时代，无论是创业公司还是发展中的公司，都希望能有一个低成本、可持续支撑的架构服务，帮助自己的业务持续发展，用户流量从小到大，无需变更架构，更不用中断业务。&lt;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 是真的香</title>
    <link href="http://ai.mak.cn/2020/06/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/GraphQL%20%E6%98%AF%E7%9C%9F%E7%9A%84%E9%A6%99/"/>
    <id>http://ai.mak.cn/2020/06/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/GraphQL%20%E6%98%AF%E7%9C%9F%E7%9A%84%E9%A6%99/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2023-01-10T15:40:34.985Z</updated>
    
    <content type="html"><![CDATA[<p>转自：toutiao.com&#x2F;i6833818331884028419</p><ul><li>GraphQL简介</li><li>GraphQL 对比 REST API 有什么好处？</li><li>GraphQL 思考模式</li><li>GraphQL执行逻辑</li><li>GraphQL应用的基本架构</li><li>GraphQL特点总结</li><li>GraphQL支持的数据操作</li><li>GraphQL的核心概念：图表模式（Schema）</li><li>标量类型（Scalar Type）</li><li>对象类型（Object Type）</li><li>类型修饰符（Type Modifier）</li><li>其他类型</li><li>Graphql 技术接入架构</li><li>服务端实现</li><li>客户端实现</li><li></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>REST作为一种现代网络应用非常流行的软件架构风格，自从Roy Fielding博士在2000年他的博士论文中提出来到现在已经有了20年的历史。它的简单易用性，可扩展性，伸缩性受到广大Web开发者的喜爱。</p><p>REST 的 API 配合JSON格式的数据交换，使得前后端分离、数据交互变得非常容易，而且也已经成为了目前Web领域最受欢迎的软件架构设计模式。</p><p>但随着REST API的流行和发展，它的缺点也暴露了出来：</p><ul><li><strong>滥用REST接口</strong>，导致大量相似度很高（具有重复性）的API越来越冗余。</li><li>对于前端而言：<strong>REST API粒度较粗</strong>，难以一次性符合前端的数据要求，前端需要分多次请求接口数据。增加了前端人员的工作量。</li><li>对于后端而言：<strong>前端需要的数据往往在不同的地方具有相似性，但却又不同</strong>，比如针对同样的用户信息，有的地方只需要用户简要信息（比如头像、昵称），有些地方需要详细的信息，这就需要开发不同的接口来满足这些需求。当这样的相似但又不同的地方多的时候，就需要开发更多的接口来满足前端的需要。增加了后端开发人员的工作量和重复度。</li></ul><p>那我们来分析一下，<strong>当前端需求变化，涉及到改动旧需求时</strong>，会有以下这些情况：</p><p><strong>做加法</strong>：</p><p>产品需求增加，页面需要增加功能，数据也就相应的要增加显示，那么REST接口也需要做增加，这种无可厚非。</p><p><strong>做减法</strong>：</p><p>产品需求减少，页面需要减少功能，或者减少某些信息显示，那么数据就要做减法。</p><p><strong>一种通常懒惰的做法是，前端不与后端沟通，仅在前端对数据选择性显示。</strong></p><p>因为后端接口能够满足数据需要，仅仅是在做显示的时候对数据进行了选择性显示，但接口的数据是存在冗余的，这种情况一个是存在数据泄露风险，另外就是数据量过大时造成网络流量过大，页面加载缓慢，用户流量费白白消耗，用户体验就会下降。</p><p><strong>另外一种做法就是告知后端，要么开发新的接口，要么，修改旧接口，删掉冗余字段。</strong></p><p>但一般来说，开发新接口往往是后端开发人员会选择的方案，因为这个方案对现有系统的影响最低，不会有额外的风险。</p><p>修改旧接口删除冗余数据的方案往往开发人员不会选择，这是为什么呢？</p><p>这就涉及到了系统的稳定性问题了，旧接口往往不止是一个地方在用，很有可能很多页面、设置不同客户端、不同服务都调用了这个接口获取数据，不做详细的调查，是不可能知道到底旧接口被调用了多少次，一旦改动旧接口，涉及范围可能非常大，往往会引起其他地方出现崩溃。改动旧接口成本太高，所以往往不会被采取。</p><p><strong>同时做加减法：</strong></p><p>既有加法，又有减法，其实这种就跟新需求没啥区别，前端需要重做页面，后端需要新写接口满足前端需要，但是旧接口还是不能轻举妄动（除非确定只有这一处调用才可以删除）。</p><p>往往这个时候，其实用到的数据大多都是来自于同一个DO或者DTO，不过是在REST接口组装数据时，用不同的VO来封装不同字段，或者，使用同样的VO，组装数据时做删减。</p><p>看到这些问题是不是觉得令人头大？</p><p>所以<strong>需求频繁改动是万恶之源</strong>，当产品小哥哥改动需求时，程序员小哥哥可能正提着铁锹赶来……</p><p>那么有没有一种方案或者框架，可以使得在用到同一个领域模型（DO或者DTO）的数据时，前端对于这个模型的数据字段需求的改动，后端可以根据前端的改动和需要，自动适配，自动组装需要的字段，返回给前端呢？如果能这样做的话，那么后端程序猿小哥可能要开心死了，前端妹子也不用那么苦口婆心地劝说后端小哥哥了。</p><p>所以<strong>GraphQL</strong>隆重出世了！那么问题来了！</p><hr><p>Part 1 What is GraphQL</p><h1 id="GraphQL简介"><a href="#GraphQL简介" class="headerlink" title="GraphQL简介"></a>GraphQL简介</h1><ul><li>GraphQL是一种新的API标准，它提供了一种比REST更有效、更强大和更灵活的替代方案。</li><li>它是由Facebook开发并开源的，现在由来自世界各地的公司和个人组成的大型社区维护。</li><li>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</li><li>它是数据库无关的，而且可以在使用API的任何环境中有效使用，我们可以理解为GraphQL是基于API之上的一层封装，目的是为了更好，更灵活的适用于业务的需求变化。</li></ul><p>简单的来说，它</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235702/1000"></p><p>它的工作模式是这样子的：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235703/1000"></p><h1 id="GraphQL-对比-REST-API-有什么好处？"><a href="#GraphQL-对比-REST-API-有什么好处？" class="headerlink" title="GraphQL 对比 REST API 有什么好处？"></a>GraphQL 对比 REST API 有什么好处？</h1><p><strong>REST API 的接口灵活性差、接口操作流程繁琐，GraphQL 的声明式数据获取，使得接口数据精确返回，数据查询流程简洁，照顾了客户端的灵活性。</strong></p><p><strong>客户端拓展功能时要不断编写新接口（依赖于服务端），GraphQL 中一个服务仅暴露一个 GraphQL 层，消除了服务器对数据格式的硬性规定，客户端按需请求数据，可进行单独维护和改进。</strong></p><p><strong>REST API 基于HTTP协议，不能灵活选择网络协议，而传输层无关、数据库技术无关使得 GraphQL 有更加灵活的技术栈选择，能够实现在网络协议层面优化应用。</strong></p><p>举个经典的例子：前端向后端请求一个book对象的数据及其作者信息。</p><p>我用动图来分别演示下REST和GraphQL是怎么样的一个过程。</p><p>先看REST API的做法：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235704/0"></p><p>REST API获取数据</p><p>再来看GraphQL是怎么做的：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235705/0"></p><p>GraphQL获取数据</p><p>可以看出其中的区别：</p><ul><li>与REST多个endpoint不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235706/1000"></p><p>Endpoints对比</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235707/1000"></p><p>REST API’s Endpoints</p><ul><li>GraphQL 实际上将多个 HTTP 请求聚合成了一个请求，将多个 restful 请求的资源变成了一个从根资源 POST 访问其他资源的 Comment 和 Author 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，因此GraphQL又可以被看成是图数据库的形式。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235710/1000"></p><p>图数据库模式的数据查询</p><p>那我们已经能看到GraphQL的先进性，接下来看看它是怎么做的。</p><h1 id="GraphQL-思考模式"><a href="#GraphQL-思考模式" class="headerlink" title="GraphQL 思考模式"></a>GraphQL 思考模式</h1><p>使用GraphQL接口设计获取数据需要三步：</p><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235711/0"></p><p>GraphQL获取数据三步骤</p><ol><li>首先要设计数据模型，用来描述数据对象，它的作用可以看做是VO，用于告知GraphQL如何来描述定义的数据，为下一步查询返回做准备；</li><li>前端使用模式查询语言（Schema）来描述需要请求的数据对象类型和具体需要的字段（称之为声明式数据获取）；</li><li>后端GraphQL通过前端传过来的请求，根据需要，自动组装数据字段，返回给前端。</li></ol><p>GraphQL的这种思考模式是不是完美解决了之前遇到的问题呢？！</p><p>总结它的好处：</p><p>在它的设计思想中，GraphQL 以图的形式将整个 Web 服务中的资源展示出来，客户端可以按照其需求自行调用，类似添加字段的需求其实就不再需要后端多次修改了。</p><p>创建GraphQL服务器的最终目标是：</p><p><strong>允许查询通过图和节点的形式去获取数据。</strong></p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235712/1000"></p><h1 id="GraphQL执行逻辑"><a href="#GraphQL执行逻辑" class="headerlink" title="GraphQL执行逻辑"></a>GraphQL执行逻辑</h1><p>有人会问：</p><ul><li>使用了GraphQL就要完全抛弃REST了吗？</li><li>GraphQL需要直接对接数据库吗？</li><li>使用GraphQL需要对现有的后端服务进行大刀阔斧的修改吗？</li></ul><p>答案是：NO！不需要！</p><p>它完全可以以一种不侵入的方式来部署，将它作为前后端的中间服务，也就是，现在开始逐渐流行的 <strong>前端 —— 中端 —— 后端</strong> 的三层结构模式来部署！</p><p>那就来看一下这样的部署模式图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235713/1000"></p><p>GraphQL执行逻辑</p><p>也就是说，完全可以搭建一个GraphQL服务器，专门来处理前端请求，并处理后端服务获取的数据，重新进行组装、筛选、过滤，将完美符合前端需要的数据返回。</p><p>新的开发需求可以直接就使用GraphQL服务来获取数据了，以前已经上线的功能无需改动，还是使用原有请求调用REST接口的方式，最低程度的降低更换GraphQL带来的技术成本问题！</p><p>如果没有那么多成本来支撑改造，那么就不需要改造！</p><p>只有当原有需求发生变化，需要对原功能进行修改时，就可以换成GraphQL了。</p><h1 id="GraphQL应用的基本架构"><a href="#GraphQL应用的基本架构" class="headerlink" title="GraphQL应用的基本架构"></a>GraphQL应用的基本架构</h1><p>下图是一个 GraphQL 应用的基本架构，其中客户端只和 GraphQL 层进行 API 交互，而 GraphQL 层再往后接入各种数据源。这样一来，只要是数据源有的数据， GraphQL 层都可以让客户端按需获取，不必专门再去定接口了。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235714/1000"></p><p>GraphQL应用基本架构</p><p><strong>一个GraphQL服务仅暴露一个 GraphQL Endpoint，可以按照业务来进行区分，部署多个GraphQL服务，分管不同的业务数据，这样就可以避免单服务器压力过大的问题了。</strong></p><h1 id="GraphQL特点总结"><a href="#GraphQL特点总结" class="headerlink" title="GraphQL特点总结"></a>GraphQL特点总结</h1><ul><li><strong>声明式数据获取（可以对API进行查询）:</strong> 声明式的数据查询带来了接口的精确返回，服务器会按数据查询的格式返回同样结构的 JSON 数据、真正照顾了客户端的灵活性。</li><li><strong>一个微服务仅暴露一个 GraphQL 层：</strong>一个微服务只需暴露一个GraphQL endpoint，客户端请求相应数据只通过该端点按需获取，不需要再额外定义其他接口。</li><li><strong>传输层无关、数据库技术无关：</strong>带来了更灵活的技术栈选择，比如我们可以选择对移动设备友好的协议，将网络传输数据量最小化，实现在网络协议层面优化应用。</li></ul><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235716/1000"></p><p>Part 2 Schema &amp; Type</p><h1 id="GraphQL支持的数据操作"><a href="#GraphQL支持的数据操作" class="headerlink" title="GraphQL支持的数据操作"></a>GraphQL支持的数据操作</h1><p>GraphQL对数据支持的操作有：</p><ul><li><strong>查询（Query）：</strong>获取数据的基本查询。</li><li><strong>变更（Mutation）：</strong>支持对数据的增删改等操作。</li><li><strong>订阅（Subscription）：</strong>用于监听数据变动、并靠websocket等协议推送变动的消息给对方。</li></ul><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235717/0"></p><p>GraphQL支持的操作</p><h1 id="GraphQL的核心概念：图表模式（Schema）"><a href="#GraphQL的核心概念：图表模式（Schema）" class="headerlink" title="GraphQL的核心概念：图表模式（Schema）"></a>GraphQL的核心概念：图表模式（Schema）</h1><p>要想要设计GraphQL的数据模型，用来描述你的业务数据，那么就必须要有一套Schema语法来做支撑。</p><p>想要描述数据，就必须离不开数据类型的定义。所以GraphQL设计了一套Schema模式（可以理解为语法），其中最重要的就是数据类型的定义和支持。</p><p>那么类型（Type）就是模式（Schema）最核心的东西了。</p><p><strong>什么是类型？</strong></p><ul><li>对于数据模型的抽象是通过类型（Type）来描述的，每一个类型有若干字段（Field）组成，每个字段又分别指向某个类型（Type）。这很像Java、C#中的类（Class）。</li><li>GraphQL的Type简单可以分为两种，一种叫做Scalar Type(标量类型)，另一种叫做Object Type(对象类型)。</li></ul><p>那么就分别来介绍下两种类型。</p><h1 id="标量类型（Scalar-Type）"><a href="#标量类型（Scalar-Type）" class="headerlink" title="标量类型（Scalar Type）"></a>标量类型（Scalar Type）</h1><p>标量是GraphQL类型系统中最小的颗粒。类似于Java、C#中的基本类型。</p><p>其中内建标量主要有：</p><ul><li><strong>String</strong></li><li><strong>Int</strong></li><li><strong>Float</strong></li><li><strong>Boolean</strong></li><li><strong>Enum</strong></li><li><strong>ID</strong></li></ul><p><img src="https://inews.gtimg.com/newsapp_match/0/13022235718/0"></p><p>Scalar Type</p><p>上面的类型仅仅是GraphQL默认内置的类型，当然，为了保证最大的灵活性，GraphQL还可以很灵活的自行创建标量类型。</p><h1 id="对象类型（Object-Type）"><a href="#对象类型（Object-Type）" class="headerlink" title="对象类型（Object Type）"></a>对象类型（Object Type）</h1><p>仅有标量类型是不能满足复杂抽象数据模型的需要，这时候我们可以使用对象类型。</p><p>通过对象模型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多、一对一或多对多）。</p><p>对象类型的定义可以参考下图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235720/1000"></p><p>对象模型引入关联关系</p><p>是不是很方便呢？我们可以像设计类图一样来设计GraphQL的对象模型。</p><h1 id="类型修饰符（Type-Modifier）"><a href="#类型修饰符（Type-Modifier）" class="headerlink" title="类型修饰符（Type Modifier）"></a>类型修饰符（Type Modifier）</h1><p>那么，类型系统仅仅只有类型定义是不够的，我们还需要对类型进行更广泛性的描述。</p><p>类型修饰符就是用来修饰类型，以达到额外的数据类型要求控制。</p><p>比如：</p><ul><li>列表：[Type]</li><li>非空：Type!</li><li>列表非空：[Type]!</li><li>非空列表，列表内容类型非空：[Type!]!</li></ul><p>在描述数据模型（模式Schema）时，就可以对字段施加限制条件。</p><p>例如定义了一个名为User的对象类型，并对其字段进行定义和施加限制条件：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235721/1000"></p><p>User字段控制</p><p>那么，返回数据时，像下面这种情况就是不允许的：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235722/1000"></p><p>错误的表示</p><p>Graphql会根据Schema Type来自动返回正确的数据：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235723/1000"></p><p>正确的表示</p><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>除了上面的，Graphql还有一些其他类型来更好的引入面向对象的设计思想：</p><ul><li><strong>接口类型（Interfaces）：</strong>其他对象类型实现接口必须包含接口所有的字段，并具有相同的类型修饰符，才算实现接口。</li></ul><p>比如定义了一个接口类型：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235724/1000"></p><p>那么就可以实现该接口：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022235725/1000"></p><ul><li><strong>联合类型（Union Types）：</strong>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。几个对象类型共用一个联合类型。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237705/1000"></p><ul><li><strong>输入类型（Input Types）：</strong>更新数据时有用，与常规对象只有关键字修饰不一样，常规对象时 <strong>type</strong> 修饰，输入类型是 <strong>input</strong> 修饰。</li></ul><p>比如定义了一个输入类型：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237706/1000"></p><p>前端发送变更请求时就可以使用（通过参数来指定输入的类型）：</p><p><img src="/"></p><p>所以，这样面向对象的设计方式，真的对后端开发人员特别友好！而且前端MVVM框架流行以来，面向对象的设计思想也越来越流行，前端使用Graphql也会得心应手。</p><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237707/1000"></p><p>Part 3 GraphQL技术接入架构</p><h1 id="Graphql-技术接入架构"><a href="#Graphql-技术接入架构" class="headerlink" title="Graphql 技术接入架构"></a>Graphql 技术接入架构</h1><p>那么，该怎么设计来接入我们现有的系统中呢？</p><ul><li><strong>将Graphql服务直连数据库的方式：</strong>最简洁的配置，直接操作数据库能减少中间环节的性能消耗。</li></ul><p>直连数据库的接入</p><ul><li><strong>集成现有服务的GraphQL层：</strong>这种配置适合于旧服务的改造，尤其是在涉及第三方服务时、依然可以通过原有接口进行交互。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237708/1000"></p><p>集成现有服务的GraphQL层</p><ul><li><strong>直连数据库和集成服务的混合模式：</strong>前两种方式的混合。</li></ul><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237709/1000"></p><p>混合接入方式</p><p>可以说是非常灵活了！你都不用担心会给你带来任何的麻烦。</p><hr><p><img src="https://inews.gtimg.com/newsapp_bt/0/13022237710/1000"></p><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>在服务端， GraphQL 服务器可用任何可构建 Web 服务器的语言实现。有以下语言的实现供参考：</p><p>C# &#x2F; .NET</p><p>Clojure</p><p>Elixir</p><p>Erlang</p><p>Go</p><p>Groovy</p><p>Java</p><p>JavaScript</p><p>Julia</p><p>Kotlin</p><p>Perl</p><p>PHP</p><p>Python</p><p>R</p><p>Ruby</p><p>Rust</p><p>Scala</p><p>Swift</p><p>种类繁多，几乎流行的语言都有支持。</p><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>在客户端，Graphql Client目前有下面的语言支持：</p><p>C# &#x2F; .NET</p><p>Clojurescript</p><p>Elm</p><p>Flutter</p><p>Go</p><p>Java &#x2F; Android</p><p>JavaScript</p><p>Julia</p><p>Swift &#x2F; Objective-C iOS</p><p>Python</p><p>R</p><p>覆盖了众多客户端设计语言，而其他语言的支持也在推进中。</p><h1 id="Graphql的一些服务"><a href="#Graphql的一些服务" class="headerlink" title="Graphql的一些服务"></a>Graphql的一些服务</h1><p>整理了下目前比较流行的服务框架：</p><ul><li>Apollo Engine:一个用于监视 GraphQL 后端的性能和使用的服务。</li><li>Graphcool (github): 一个 BaaS（后端即服务），它为你的应用程序提供了一个 GraphQL 后端，且具有用于管理数据库和存储数据的强大的 web ui。</li><li>Tipe (github): 一个 SaaS（软件即服务）内容管理系统，允许你使用强大的编辑工具创建你 的内容，并通过 GraphQL 或 REST API 从任何地方访问它。</li><li>AWS AppSync：完全托管的 GraphQL 服务，包含实时订阅、离线编程和同步、企业级安全特性以及细粒度的授权控制。</li><li>Hasura：一个 BaaS（后端即服务），允许你在 Postgres 上创建数据表、定义权限并使用 GraphQL 接口查询和操作。</li></ul><h1 id="Graphql的一些工具"><a href="#Graphql的一些工具" class="headerlink" title="Graphql的一些工具"></a>Graphql的一些工具</h1><ul><li>graphiql (npm): 一个交互式的运行于浏览器中的 GraphQL IDE。</li><li>Graphql Language Service: 一个用于构建 IDE 的 GraphQL 语言服务（诊断、自动完成等） 的接口。</li><li>quicktype (github): 在 TypeScript、Swift、golang、C#、C++ 等语言中为 GraphQL 查 询生成类型。</li></ul><p>想要获取更多关于Graphql的一些框架、工具，可以去awesome-graphql：一个神奇的社区，维护一系列库、资源等，地址是</p><p><a href="https://github.com/chentsulin/awesome-graphql%E3%80%82">https://github.com/chentsulin/awesome-graphql。</a></p><p>想要学习更多Graphql的知识，可以去<strong>GraphQL.cn。</strong></p><hr><p>好了，一个入门级的Graphql介绍篇就这样完结了（尽管篇幅也很大哈哈）。</p><ul><li>不知道你懂得它的原理和优点了吗？</li><li>你对它感兴趣吗？</li><li>看完这篇介绍，有没有想动手尝试一下呢？</li><li>你会在你下一个项目中引入Graphql并使用它吗？</li><li>你对Graphql还有什么疑惑的问题呢？</li></ul><p>或者你有其他问题，都可以在评论区留言或者私信我，大家一起共同探讨。</p><p>Graphql还有更多需要介绍的东西，没有写出来，这仅仅是一个入门介绍哈，后面我会再写一篇文章来详细介绍Graphql在具体的使用方面的总结和在项目中使用的实际感受，如果你也对Graphql感兴趣，可以关注我 @IT研究僧大师兄 下一次的文章介绍。关注我后可以私信我，发送关键字“Graphql PPT”，获取我自己制作的Graphql PPT。</p><p>当然，如果你也和我一样，热衷于技术，热衷于科技、互联网，不妨点个关注吧，我会持续分享干货知识、经验和观点总结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转自：toutiao.com&amp;#x2F;i6833818331884028419&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GraphQL简介&lt;/li&gt;
&lt;li&gt;GraphQL 对比 REST API 有什么好处？&lt;/li&gt;
&lt;li&gt;GraphQL 思考模式&lt;/li&gt;
&lt;li&gt;GraphQ</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何选择分布式事务解决方案</title>
    <link href="http://ai.mak.cn/2020/05/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://ai.mak.cn/2020/05/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-27T16:00:00.000Z</published>
    <updated>2023-01-10T15:00:06.643Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong></p><p>事务是一组不可分组的操作集合，这些操作要么都成功执行，要么都取消执行。最典型的需要事务的场景是银行账户间的转账：假如 A 账户要给 B 账户转账 100 元，那么 A 账户要扣减 100 元，B 账户要增加 100 元，这两个账户的数据变更都成功才可算作转账成功。更严格来说，可以用 ACID 四个特性表述事务：</p><p>Atomicity：原子性，事务中的所有操作要么都成功执行，要么都取消执行，不能存在部分执行，部分不执行的状态。</p><p>Consistency：一致性，举个例子简单的理解就是，A、B 两个账户各有 100 元，无论两个账户并发相互转账多少次，两个账户的资金总额依然是 200 元。</p><p>Isolation：隔离性，并发事务之间的相互影响程度，隔离性也是分级别的：读未提交、读已提交、可重复读等。</p><p>Durability：持久性，事务完成后对数据的更改不会丢失。</p><p>单体数据库不涉及网络交互，所以在多表之间实现事务是比较简单的，这种事务我们称之为本地事务。</p><p>但是单体数据库的性能达到瓶颈的时候，就需要分库(分物理实例)，就会出现跨库(数据库实例)的事务需求；随着企业应用的规模越来越大，企业会进一步进行服务化改造，以满足业务增长的需求；当前微服务架构越来越流行，跨服务的事务场景也会越来越多。</p><p>这些都是分布式事务的需求。分布式事务是指是指事务的发起者、参与者、数据资源服务器以及事务管理器分别位于分布式系统的不同节点之上。</p><p>概括起来，分布式事务有三种场景：</p><p>跨数据库分布式事务跨服务分布式事务混合式分布式事务</p><p><img src="https://pics3.baidu.com/feed/2f738bd4b31c87018a7b2245af2325290608ff23.png@f_auto?token=904aaf97b1a13069a99c892c610fa9b2" alt="img"></p><p>分布式事务中涉及的参与者分布在异步网络中，参与者通过网络通信来达到分布式一致性，网络通信不可避免出现失败、超时的情况，因此分布式事务的实现比本地事务面临更多的困难。下面介绍几种常见的分布式事务解决方案。</p><p><strong>分布式事务模式</strong></p><p>XA Specification</p><p>最早的分布式事务产品可能是 AT&amp;T 在 20 世纪 80 年代推出的 Tuxedo (Transactions for Unix, Extended for Distributed Operations)，Tuxedo 最早是为了电信领域的 OLTP 系统研发的分布式事务中间件，后来标准化组织 X&#x2F;Open 吸收采纳了 Tuxedo 的设计思想和一些接口，推出了分布式事务规范：XA Specification。</p><p>XA 规范中定义了分布式事务处理模型，这个模型中包含四个核心角色：</p><p>RM (Resource Managers)：资源管理器，提供数据资源的操作、管理接口，保证数据的一致性和完整性。最有代表性的就是数据库管理系统，当然有的文件系统、MQ 系统也可以看作 RM。</p><p>TM (Transaction Managers)：事务管理器，是一个协调者的角色，协调跨库事务关联的所有 RM 的行为。</p><p>AP (Application Program)：应用程序，按照业务规则调用 RM 接口来完成对业务模型数据的变更，当数据的变更涉及多个 RM 且要保证事务时，AP 就会通过 TM 来定义事务的边界，TM 负责协调参与事务的各个 RM 一同完成一个全局事务。</p><p>CRMs (Communication Resource Managers)：主要用来进行跨服务的事务的传播。</p><p>下图是 XA 规范中定义的事务模型图，其中：发起分布式事务的 TM 实例称之为 root 节点，其他的 TM 实例可以统称为事务的参与者。事务发起者负责开启整个全局事务，事务参与者各自负责执行自己的事务分支。如果TM实例发起了对其他 TM 实例的服务调用，那么发起者就被成为 Superior，被调用这就被称之为 Subordinate 节点。</p><p><img src="https://pics5.baidu.com/feed/d833c895d143ad4bb21a35d70a5ee1a9a40f0657.png@f_auto?token=2673237f259be7f9fba5ab5fb2c8333b" alt="img"></p><p>图源：《Distributed Transaction Processing:Reference Model, Version 3》 Page 32,Figure 3-2</p><p>XA 规范中分布式事务是构建在 RM 本地事务（此时本地事务被看作分支事务）的基础上的，TM 负责协调这些分支事务要么都成功提交、要么都回滚。XA 规范把分布式事务处理过程划分为两个阶段，所以又叫两阶段提交协议（two phrase commit）：</p><p>1）预备阶段</p><p>TM 记录事务开始日志，并询问各个 RM 是否可以执行提交准备操作。</p><p>RM 收到指令后，评估自己的状态，尝试执行本地事务的预备操作：预留资源，为资源加锁、执行操作等，但是并不提交事务，并等待 TM 的后续指令。如果尝试失败则告知 TM 本阶段执行失败并且回滚自己的操作，然后不再参与本次事务（以 MySQL 为例，这个阶段会完成资源的加锁，redo log 和 undo log 的写入）。</p><p>TM 收集 RM 的响应，记录事务准备完成日志。</p><p>2）提交&#x2F;回滚阶段</p><p>这个阶段根据上个阶段的协调结果发起事务的提交或者回滚操作。</p><p>如果所有 RM 在上一个步骤都返回执行成功，那么：</p><p>TM 记录事务 commit 日志，并向所有 RM 发起事务提交指令。</p><p>RM 收到指令后，提交事务，释放资源，并向 TM 响应“提交完成”。</p><p>如果 TM 收到所有 RM 的响应，则记录事务结束日志。</p><p>如果有 RM 在上一个步骤中返回执行失败或者超时没有应答，则 TM 按照执行失败处理，那么：</p><p>记录事务 abort 日志，向所有 RM 发送事务回滚指令。</p><p>RM 收到指令后，回滚事务，释放资源，并向 TM 响应回滚完成。</p><p>如果 TM 收到所有 RM 的响应，则记录事务结束日志。</p><p><img src="https://pics1.baidu.com/feed/29381f30e924b89975a8b7ace45aa6930b7bf676.png@f_auto?token=cfa018d07898f65ba2fc2f8959899151" alt="img"></p><p>针对部分场景，XA 规范还定义了如下优化措施：</p><p>如果 TM 发现整个事务只涉及到一个 RM，那么就会将整个过程退化为一阶段提交。</p><p>如果 RM 收到的 AP 的数据操作是只读操作，那么它可以在阶段 1 就将事务完成并告知 TM 其不再参与阶段 2 的过程。会有脏读的风险。</p><p>如果 RM 在阶段1完成后，长时间等不到阶段 2 的指令，那么其可以自动提交或者回滚本地事务。这叫做 Heuristic Completion，注意这种场景有可能会破坏事务的一致性，产生异常。</p><p>XA 规范中详细定义了各个核心组件之间的交互接口，以 TM 和 RM 的交互接口为例，如下图，一次完整的全局事务，TM 和 RM 之间的交互还是比较频繁的：</p><p><img src="https://pics5.baidu.com/feed/35a85edf8db1cb13f3eda8c85408ed4890584bcc.png@f_auto?token=5c1ed2fed03a01c866feace204203996" alt="img"></p><p>事务的执行过程中，宕机和网络超时都有可能发生，针对这些异常场景，不同 XA 规范的实现，对异常处理做法可能不同，可参考如下：</p><p>TM 在阶段 1 中询问 RM 前宕机，恢复后无需做任何操作。</p><p>TM 在阶段 1 中询问 RM 后宕机，可能只有部分 RM 收到了阶段 1 的请求，因此此时需要向 RM 发起回滚请求。</p><p>TM 在阶段 1 中询问 RM 完毕，但是在就准备完成日志时宕机，因不清楚宕机前的事务协商的结果，因此恢复后需要向 RM 发起回滚请求。</p><p>TM 在阶段 1 中记录完毕事务准备完成日志后宕机，恢复后可以根据日志发起提交或者回滚的指令。</p><p>TM 在阶段 2 中记录 commit&#x2F;abort 日志前宕机，恢复后可以根据日志发起提交或者回滚指令。</p><p>TM 在阶段 2 中记录事务结束日志前宕机，恢复后可以根据日志发起提交或者回滚指令。</p><p>TM 在阶段 2 中记录事务结束日志后宕机，恢复后无需做任何操作。</p><p>阶段 1 中，RM 有超时情况时，TM 按失败处理，给所有 RM 发送回滚指令。</p><p>阶段 2 中，RM 有超时情况是，TM 需要对超时的 RM 持续重复发送指令。</p><p><strong>特点剖析</strong></p><p>XA 两阶段提交协议设计上是要像本地事务一样实现事务的 ACID 四个特性：</p><p>原子性：在 prepare 和 commit 阶段保证事务是原子性的。</p><p>一致性：XA 协议实现的是强一致性。</p><p>隔离性：XA 事务在完成之前一直持有资源的锁，所以可以做到写隔离。</p><p>持久性：基于本地事务实现，所以这一点没有问题。</p><p>XA 是出现最早的分布式事务规范，主流数据库 Oracle、MySQL、SQLServer 等都支持 XA 规范，J2EE 中的 JTA 规范也是参照 XA 规范编写的，与 XA 规范兼容。</p><p>XA 是在资源管理层面实现的分布式事务模型，对业务的入侵度较低。</p><p>XA 两阶段提交协议可以覆盖分布式事务的三种场景，但是全局事务的执行过程中，RM 一直持有资源的锁，如果参与的 RM 过多，尤其是跨服务的场景下，网络通信的次数和时间会急剧变多，所以阻塞的时间更长，系统的吞吐能力变得很差，事务死锁出现的概率也会变大，所以并不适合微服务架构场景中的跨服务的分布式事务模式。</p><p>每一个 TM 域来说，由于 TM 是单点，存在单点故障风险，如果 TM 在阶段1之后挂掉，会导致参与的 RM 长时间收不到阶段 2 的请求而长期持有资源的锁，影响业务的吞吐能力。同时一次完整的全局事务，TM 和 RM 之间的交互多达 8 次，太繁琐，非常影响系统的处理性能。</p><p>XA 两阶段协议可能会造成脑裂的异常，假如 TM 在阶段 2 通知 RM 提交事务时，如果指令发出后就宕机了，而只有部分 RM 收到了提交请求，那么当 TM 恢复的时候，就无法协调本次事务所有的 RM 本地事务的一致性了。</p><p>XA 要处理的异常场景非常多，对框架的实现有一定的挑战，开源的实现，可以参考：Atomikos，Bitronix。</p><p>针对 XA 两阶段提交中的问题，有人提出了三阶段提交的改进方案，三阶段提交方案主要解决了单点故障问题，并在 RM 侧也引入了超时机制，以避免资源的长时间锁定。但是三阶段提交方案依然无法避免脑裂的异常情况出现，实际应用案例很少，感兴趣的同学可以自行找相关资料了解。</p><p>TCC</p><p>TCC (Try、Commit、Cancel) 是一种补偿型事务，该模型要求应用的每个服务提供 try、confirm、cancel 三个接口，它的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。</p><p>TCC 也是一种两阶段提交协议，可以看作 2PC&#x2F;XA 的一种变种，但是不会长时间持有资源锁。</p><p>TCC 模型将事务的提交划分为两个阶段：</p><p>1）阶段 1</p><p>完成业务检查（一致性）、预留业务资源（准隔离性），即 TCC 中的 try。</p><p>2）阶段 2</p><p>如果 try 阶段所有业务资源都预留成功，则执行 confirm 操作，否则执行 cancel 操作：</p><p>confirm：不做任何业务检查，仅仅使用预留的资源执行业务操作，如果失败会一直重试。</p><p>cancel：取消执行业务操作，释放预留的资源，如果失败会一直重试。</p><p><img src="https://pics3.baidu.com/feed/91529822720e0cf31238492e841a4919bc09aaff.png@f_auto?token=f84c1f561dc9fce0c0c1a91266fcde68" alt="img"></p><p>TCC 模式中，事务的发起者和参与者都需要记录事务日志，事务的发起者需要记录全局事务和各个分支事务的状态和信息；事务的参与者需要记录分支事务的状态。</p><p>TCC 事务在执行过程中的任意环节，均可能发生宕机、重启、网络中断等异常情况，此时事务处于非原子状态和非最终一致状态，此时就需要根据主事务记录和分支事务记录的日志，去完成剩余分支事务的提交或者回滚，使整个分布式事务内所有参展达到最终一致的状态，实现事务的原子性。</p><p><strong>举例</strong></p><p>我们以一个简单的电商系统为例，小明在淘宝上花 100 元买了一本书，获赠 10 个积分，产品上有如下几个操作：</p><p>订单系统创建商品订单支付系统接受小明的支付库存系统扣减产品库存会员系统给小明账户增加会员积分</p><p>这几个动作需要作为一个事务执行，要同时成功或者同时撤销。</p><p>如果采用 TCC 事务模式，那么各个系统需要改造为如下状态：</p><p>1）订单系统</p><p>try：创建一个订单，状态显示为“待支付”confirm：更新订单的状态为“已完成”cancel：更新订单的状态为“已取消”</p><p>2）支付系统</p><p>try：假设小明账户中有 1000 元，冻结小明账户中的 100 元，此时小明看到的余额依然是 1000 元。confirm：将账户余额变为 900 元，并清除冻结记录。concel：清除冻结记录。</p><p>3）库存系统</p><p>try：假设库存中还生 10 本书，冻结其中的一本书，现实库存依然有 10 本书。confirm：将剩余库存更新为 9 本书，并清除冻结记录。cancel：清除冻结记录。</p><p>4）会员系统</p><p>try：假设小明原因积分 3000 分，给小明账户预增加 10 积分，账户显示的积分依然是 3000 分。confirm：将账户积分更新为 3010，并清除预增加记录。cancel：清除预增加记录。</p><p><strong>特点剖析</strong></p><p>TCC 事务具备事务的四个特性：</p><p>原子性：事务发起方协调各个分支事务全部提交或者全部回滚。一致性：TCC 事务提供最终一致性。隔离型：通过 try 预分配资源的方式来实现数据的隔离。持久性：交由各个分支事务来实现。</p><p>TCC 事务模型对业务方侵入较大，需要业务方把功能的实现上由一个接口拆分为三个，开发成本较高。</p><p>同时 TCC 事务为了解决异步网络中的通信失败或超时带来的异常情况，要求业务方在设计实现上要遵循三个策略：</p><p>允许空回滚：原因是异常发生在阶段 1 时，部分参与方没有收到 try 请求从而触发整个事务的 cancel 操作，try 失败或者没有执行 try 操作的参与方收到 cancel 请求时，要进行空回滚操作。</p><p>保持幂等性：原因是异常发生在阶段 2 时，比如网络超时，则会重复调用参与方的 confirm&#x2F;cancel 方法，因此需要这两个方法实现上保证幂等性。</p><p>防止资源悬挂：原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 try 请求比 cancel 请求更晚到达的情况，cancel 会执行空回滚而确保事务的正确性，但是此时 try 方法也不可以再被执行。</p><p>TCC 事务将分布式事务从资源层提到业务层来实现，可以让业务灵活选择资源的锁定粒度，并且全局事务执行过程中不会一直持有锁，所以系统的吞吐量比 2PC&#x2F;XA 模式要高很多。</p><p>支持 TCC 事务的开源框架有：ByteTCC、Himly、TCC-transaction。</p><p>Saga</p><p>Saga 并不是一个新概念，其相关论文在 1987 年就发布了，和 XA 两阶段提交规范出现的时间差不多。</p><p>Saga 和 TCC 一样，也是一种补偿事务，但是它没有 try 阶段，而是把分布式事务看作一组本地事务构成的事务链。</p><p>事务链中的每一个正向事务操作，都对应一个可逆的事务操作。Saga 事务协调器负责按照顺序执行事务链中的分支事务，分支事务执行完毕，即释放资源。如果某个分支事务失败了，则按照反方向执行事务补偿操作。</p><p>假如一个 Saga 的分布式事务链有 n 个分支事务构成，[T1,T2,…,Tn]，那么该分布式事务的执行情况有三种：</p><p>T1,T2,…,Tn：n 个事务全部执行成功了。</p><p>T1,T2,…,Ti,Ci,…,C2,C1：执行到第 i (i&lt;&#x3D;n) 个事务的时候失败了，则按照 i-&gt;1 的顺序依次调用补偿操作。如果补偿失败了，就一直重试。补偿操作可以优化为并行执行。</p><p>T1,T2,…,Ti (失败),Ti (重试),Ti (重试),…,Tn：适用于事务必须成功的场景，如果发生失败了就一直重试，不会执行补偿操作。</p><p><img src="https://pics7.baidu.com/feed/3bf33a87e950352ac93f1c4cda1f40f4b3118bfe.jpeg@f_auto?token=c55f6111c8fe54054b09acff243df47c" alt="img"></p><p><strong>举例</strong></p><p>假如国庆节小明要出去玩，从北京出发，先去伦敦，在伦敦游玩三天，再去巴黎，在巴黎游玩三天，然后再返回北京。整个行程中涉及不同航空公司的机票预订以及伦敦和巴黎当地的酒店预订，小明的计划是如果任何一张机票或酒店预订不上，就取消本次出行计划。假如综合旅游出行服务平台提供这种一键下单的功能，那么这就是一个长事务，用 Saga 模式编排服务的话，就如下图所示：任何一个环节失败的话，就通过补偿操作取消前面的行程预订。</p><p><img src="https://pics7.baidu.com/feed/8326cffc1e178a82ab09e1367c5fc88ba877e8d6.png@f_auto?token=8fd901e793f623020986ea6b01064abe" alt="img"></p><p><strong>特点剖析</strong></p><p>Saga 事务是可以保障事务的三个特性：</p><p>原子性：Saga 协调器可以协调事务链中的本地事务要么全部提交，要么全部回滚。</p><p>一致性：Saga 事务可以实现最终一致性。</p><p>持久性：基于本地事务，所以这个特性可以很好实现。</p><p>但是 Saga 不保证事务隔离性的，本地事务提交后变更就对其他事务可见了。其他事务如果更改了已经提交成功的数据，可能会导致补偿操作失败。比如扣款失败，但是钱已经花掉了，业务设计上需要考虑这种场景并从业务设计上规避这种问题。</p><p>Saga 事务和 TCC 事务一样，对业务实现要求高，要求业务设计实现上遵循三个策略：</p><p>允许空补偿：网络异常导致事务的参与方只收到了补偿操作指令，因为没有执行过正常操作，因此要进行空补偿。</p><p>保持幂等性：事务的正向操作和补偿操作都可能被重复触发，因此要保证操作的幂等性。</p><p>防止资源悬挂：网络异常导致事务的正向操作指令晚于补偿操作指令到达，则要丢弃本次正常操作，否则会出现资源悬挂问题。</p><p>虽然 Saga 和 TCC 都是补偿事务，但是由于提交阶段不同，所以两者也是有不同的：</p><p>Saga 是不完美补偿，补偿操作会留下之前原始事务操作的痕迹，需要考虑对业务上的影响。</p><p>TCC 是完美补偿，补偿操作会彻底清理之前的原始事务操作，用户是感知不到事务取消之前的状态信息的。</p><p>TCC 的事务可以更好的支持异步化，但是 Saga 模式一般在补偿阶段比较适合异步化。</p><p>Saga 模式非常适合于业务流程长的长事务的场景，实现上对业务侵入低，所以非常适合微服务架构的场景。同时 Saga 采用的是一阶段提交模式，不会对资源长时间加锁，不存在“木桶效应”，所以采用这种模式架构的系统性能高、吞吐高。</p><p>阿里巴巴的 Seata 开源项目和华为的 ServiceComb 开源项目都支持 Saga 模式。</p><p>基于消息的分布式事务</p><p>基于消息的分布式事务模式核心思想是通过消息系统来通知其他事务参与方自己事务的执行状态。</p><p>消息系统的引入更有效的将事务参与方解耦，各个参与方可以异步执行。</p><p>该种模式的难点在于解决本地事务执行和消息发送的一致性：两者要同时执行成功或者同时取消执行。</p><p>实现上主要有两种方式：</p><p>基于事务消息的方案基于本地消息的方案</p><p><strong>基于事务消息的分布式事务</strong></p><p>普通消息是无法解决本地事务执行和消息发送的一致性问题的。因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现。</p><p>解决这个问题，需要引入事务消息，事务消息和普通消息的区别在于事务消息发送成功后，处于 prepared 状态，不能被订阅者消费，等到事务消息的状态更改为可消费状态后，下游订阅者才可以监听到次消息。</p><p>本地事务和事务消息的发送的处理流程如下：</p><p>事务发起者预先发送一个事务消息。</p><p>MQ 系统收到事务消息后，将消息持久化，消息的状态是“待发送”，并给发送者一个 ACK 消息。</p><p>事务发起者如果没有收到 ACK 消息，则取消本地事务的执行；如果收到了 ACK 消息，则执行本地事务，并给 MQ 系统再发送一个消息，通知本地事务的执行情况。</p><p>MQ 系统收到消息通知后，根据本地事务的执行情况更改事务消息的状态，如果成功执行，则将消息更改为“可消费”并择机下发给订阅者；如果事务执行失败，则删除该事务消息。</p><p>本地事务执行完毕后，发给 MQ 的通知消息有可能丢失了。所以支持事务消息的 MQ 系统有一个定时扫描逻辑，扫描出状态仍然是“待发送”状态的消息，并向消息的发送方发起询问，询问这条事务消息的最终状态如何并根据结果更新事务消息的状态。因此事务的发起方需要给 MQ 系统提供一个事务消息状态查询接口。</p><p>如果事务消息的状态是“可发送”，则 MQ 系统向下游参与者推送消息，推送失败会不停重试。</p><p>下游参与者收到消息后，执行本地事务，本地事务如果执行成功，则给 MQ 系统发送 ACK 消息；如果执行失败，则不发送 ACK 消息，MQ 系统会持续推送给消息。</p><p><img src="https://pics1.baidu.com/feed/dc54564e9258d109f97984e6590477b96d814daa.png@f_auto?token=7e70a5f432da006c05678ecc2f8b191d" alt="img"></p><p><strong>基于本地消息的分布式事务</strong></p><p>基于事务消息的模式对 MQ 系统要求较高，并不是所有 MQ 系统都支持事务消息的，RocketMQ 是目前为数不多的支持事务小的 MQ 系统。如果所依赖的 MQ 系统不支持事务消息，那么可以采用本地消息的分布式模式。</p><p>该种模式的核心思想是事务的发起方维护一个本地消息表，业务执行和本地消息表的执行处在同一个本地事务中。业务执行成功，则同时记录一条“待发送”状态的消息到本地消息表中。系统中启动一个定时任务定时扫描本地消息表中状态为“待发送”的记录，并将其发送到 MQ 系统中，如果发送失败或者超时，则一直发送，知道发送成功后，从本地消息表中删除该记录。后续的消费订阅流程则与基于事务消息的模式雷同。</p><p><img src="https://pics0.baidu.com/feed/a50f4bfbfbedab64e165b6807e6a14c579311e3a.png@f_auto?token=5116c02293edada2fe357d8960adb6c6" alt="img"></p><p><strong>特点剖析</strong></p><p>基于消息的分布式事务模式对 ACID 特性的支持如下：</p><p>原子性：最终可以实现分支事务都执行或者都不执行。一致性：提供最终一致性。隔离性：不保障隔离性。持久性：由本地事务来保证。</p><p>基于消息的分布式事务可以将分布式系统之间更有效的解耦，各个事务参与方之间的调用不再是同步调用。</p><p>对 MQ 系统的要求较高，对业务实现也有一定的侵入性，要么提供事务消息状态查询接口，要么需要维护本地消息表。并且原则上只接受下游分支事务的成功，不接受事务的回滚，如果失败就要一直重试，适用于对最终一致性敏感度较低的业务场景，例如跨企业的系统间的调用，适用的场景有限。</p><p>最大努力通知型分布式事务</p><p>最大努力通知型的分布式事务解决方案，也是基于 MQ 系统的一种解决方案，但是不要求 MQ 消息可靠。</p><p><strong>举例</strong></p><p>假设小明通过联通的网上营业厅为手机充话费，充值方式选择支付宝支付。整个操作的流程如下：</p><p>小明选择充值金额“50 元”，支付方式“支付宝”。</p><p>联通网上营业厅创建一个充值订单，状态为“支付中”，并跳转到支付宝的支付页面（此时进入了支付宝的系统中）。</p><p>支付宝验明确认小明的支付后，从小明的账户中扣除 50 元，并向联通的账户中增加 50 元。执行完毕后向 MQ 系统发送一条消息，消息的内容标识支付是否成功，消息发送允许失败。</p><p>如果消息发送成功，那么支付宝的通知服务会订阅到该消息，并调用联通的接口通知本次支付的结果。如果此时联通的服务挂掉了，导致通知失败了，则会按照 5min、10min、30min、1h、…、24h 等递增的时间间隔，间隔性重复调用联通的接口，直到调用成功或者达到预订的时间窗口上限后，则不再通知。这就是尽最大努力通知的含义。</p><p>如果联通服务恢复正常，收到了支付宝的通知，如果支付成功，则给账户充值；如果支付失败，则取消充值。执行完毕后给支付宝通知服务确认响应，确认响应允许失败，支付宝系统会继续重试。所以联通的充值接口需要保持幂等性。</p><p>如果联通服务故障时间很久，恢复正常后，已超出支付宝通知服务的时间窗口，则联通扫描“支付中”的订单，主动向支付宝发起请求，核验订单的支付结果。</p><p><strong>特点剖析</strong></p><p>最大努力通知型方案本质是通过引入定期校验机制来对最终一致性做兜底，对业务侵入性较低、对 MQ 系统要求较低，实现比较简单，适合于对最终一致性敏感度比较低、业务链路较短的场景，比如跨平台、跨企业的系统间的业务交互。</p><p><strong>分布式事务中间件</strong></p><p>阿里巴巴有两个分布式事务中间件可选择：</p><p>蚂蚁金服团队开发的 XTS，金融云产品名称为 DTX。阿里巴巴中间件团队开发的 TXC。</p><p>XTS 和 TXC 的功能差不多，都支持 TCC 事务模式，也都提供了对业务入侵度较低的分布式事务方案，目前这两个团队应该是在共建开源版的分布式事务中间件 Seata。此处我们介绍一下 Seata。</p><p>Seata</p><p>简单说一下 Seata (Simple Extensible Autonomous Transaction Architecture) 的历史：</p><p>2014 年阿里巴巴就已经推出了分布式事务中间件产品 TXC (Taobao Transaction Constructor)。</p><p>2016 年，TXC 进行了云产品化改造，提供了阿里云的云版本，名字叫做 GTS (Global Transaction Service) 。</p><p>2019 年，GTS 宣布开源，开源项目的名字叫做 Seata。</p><p>Seata 支持 TCC 模式、Saga 模式。但是 Seata 对 TCC 模式的支持提供了一种对业务入侵度为0的解决方案，这种方案叫做 AT (Automatic Transaction) 模式。下面我们重点说一下 AT 模式的运行机制：</p><p>全局事务依然是基于各个分支事务来完成。Seata Server 协调各个分支事务要么一起提交，要么一起回滚。</p><p>各个分支事务在运行时，Seata Client 通过对 SQL 执行的代理和拦截，通过解析 SQL 定位到行记录，记录下 SQL 执行前后的行数据快照，beforeImage 和 afterImage 共同构成了回滚日志，回滚日志记录在独立的表中。回滚日志的写入和业务数据的更改在在同一个本地事务中提交。</p><p>分支事务完成后，立即释放对本地资源的锁，然后给 Seata 协调器上报事务执行的结果。</p><p>Seata 协调器汇总各个分支事务的完成情况，生成事务提交或者回滚的决议，将决议下发给 Seata Client。</p><p>如果决议是提交事务，则 Seata Client 异步清理回滚日志；如果决议是回滚事务，则 Seata Client 根据回滚日志进行补偿操作，补偿前会对比当前数据快照和 afterImage 是否一致，如果不一致则回滚失败，需要人工介入。</p><p><img src="https://pics1.baidu.com/feed/b2de9c82d158ccbf7f89cf1495840738b135414d.png@f_auto?token=360fae75e5fc68c31b60e6bb68f9051b" alt="img"></p><p>AT 模式通过自动生成回滚日志的方式，使得业务方接入成本低，对业务入侵度很低，但是应用 AT 模式也有一些限制：</p><p>AT 模式只支持基于 ACID 事务的关系数据库。</p><p>AT 模式是通过对 SQL 解析来完成的，对 SQL 语法的支持有限，使用复杂 SQL 时需要考虑兼容性。</p><p>目前不支持复合主键，业务表在设计时注意添加自增主键。</p><p>全局事务默认的隔离级别是读未提交，但是通过 SELECT…FOR UPDATE 等语句，可以实现读已提交的隔离级别。通过全局排它写锁，可以做到的隔离级别介于读未提交和读已提交之间。</p><p><strong>总结</strong></p><p>单体数据库事务很容易满足事务的 ACID 四个特性，提供强一致性保证，但是分布式事务要完全遵循 ACID 特性会比较困难。为了追求分布式系统的高可用和高吞吐，分布式事务的解决方案一般提供的是最终一致性。</p><p>我们把提供强一致性的事务称之为刚性事务，把提供最终一致性的事务称之为柔性事务。刚性事务可以完全满足 ACID 四个特性，柔性事务对事务的 ACID 特性的支持情况如下：</p><p>原子性：完全支持。一致性：只提供最终一致性支持。隔离性：不完全保证，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求。持久性：完全支持。</p><p>柔性事务一般遵循的是分布式领域中的 BASE 理论：</p><p>BA：Basic Availability，基本业务可用性。S：Soft state，柔性状态。E：Eventual consistency，最终一致性。</p><p>BASE 理论，是对 CAP 理论的延伸，是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p>CAP 理论告诉我们一个分布式系统无法同时满足一致性, 可用性, 分区容错性，所以在设计上对这三点做取舍。刚性事务追求强一致性，所以牺牲了高可用性；柔性事务通过牺牲一致性换来了系统的高可用性。</p><p>在系统选择分布式方案时，可以根据对一致性的要求进行选择，业务上有强一致性要求的场景时，优先考虑 XA 规范的两阶段提交；业务上只需要最终一致性的场景时，可以在根据具体场景在柔性事务方案中进行选择。</p><p>参考[1]分布式事务中间件TXC（<a href="http://mw.alibaba-inc.com/product-txc.html%EF%BC%89[2]%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1%EF%BC%88https://www.jianshu.com/p/8095001d79bb%EF%BC%89[3]%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6ServiceComb%EF%BC%88http://servicecomb.apache.org/cn/docs/distributed-transactions-saga-implementation/%EF%BC%89[4]%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%88https://sq.163yun.com/blog/article/165554812476866560%EF%BC%89[5]Seata%EF%BC%88https://seata.io/zh-cn/%EF%BC%89[6]TCC%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%EF%BC%88https://www.cnblogs.com/jajian/p/10014145.html%EF%BC%89[7]TCC%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF%EF%BC%88https://blog.csdn.net/dm_vincent/article/details/92432059[8]Compensating">http://mw.alibaba-inc.com/product-txc.html）[2]弹力设计之补偿事务（https://www.jianshu.com/p/8095001d79bb）[3]分布式事务中间件ServiceComb（http://servicecomb.apache.org/cn/docs/distributed-transactions-saga-implementation/）[4]深入理解两阶段提交（https://sq.163yun.com/blog/article/165554812476866560）[5]Seata（https://seata.io/zh-cn/）[6]TCC事务原理（https://www.cnblogs.com/jajian/p/10014145.html）[7]TCC事务异常场景（https://blog.csdn.net/dm_vincent/article/details/92432059[8]Compensating</a> Transaction Pattern（<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction%EF%BC%89[9]%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88https://www.jianshu.com/p/04bad986a4a2%EF%BC%89[10]%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0%EF%BC%88http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383%EF%BC%89[11]%E5%88%9D%E8%AF%86Open/X">https://docs.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction）[9]基于消息的分布式事务（https://www.jianshu.com/p/04bad986a4a2）[10]分布式事务概述（http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383）[11]初识Open/X</a> XA（<a href="https://www.jianshu.com/p/6c1fd2420274%EF%BC%89[12]DTP">https://www.jianshu.com/p/6c1fd2420274）[12]DTP</a>: XA Specification（<a href="https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf%EF%BC%89[13]DTP">https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf）[13]DTP</a> Model（<a href="https://pubs.opengroup.org/onlinepubs/009249599/toc.pdf">https://pubs.opengroup.org/onlinepubs/009249599/toc.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务是一组不可分组的操作集合，这些操作要么都成功执行，要么都取消执行。最典型的需要事务的场景是银行账户间的转账：假如 A 账户要给 B 账户转账 100 元，那么 A 账户要扣减 100 元，B 账户要增加 100 元，</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>新人如何快速上手项目管理</title>
    <link href="http://ai.mak.cn/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://ai.mak.cn/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2023-01-10T10:08:05.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>互联网公司除了业务迭代快，大型战役活动也不少，比如阿里巴巴的双11、阿里影业的春节档、优酷的世界杯等等。这些大型战役，不仅考验技术人的代码功底，更考验在超大型项目中团队协作能力、快速应变能力。</p><p>本文将从PMO的专业能力+技术人的实践视角，详解大型项目及战役的运作流程，将复杂项目做模块化拆解，教你站在项目全局看技术实践，同时例举团队高效沟通的技巧，希望为当下SOHO的互联网人带来启发。</p><h1 id="二、做好大型项目的五个关键"><a href="#二、做好大型项目的五个关键" class="headerlink" title="二、做好大型项目的五个关键"></a>二、做好大型项目的五个关键</h1><p>几百人、上千人组成的大型项目&#x2F;战役有很多挑战，乍一看让人望而却步，但仔细梳理下来好像也没有那么复杂，只需要厘清以下的关键：</p><p>拿什么结果 -&gt; 项目的目标<br>谁是我战友 -&gt; 项目的成员<br>啥时候吹号 -&gt; 项目的计划<br>怎么来协同 -&gt; 项目的机制<br>战后做点啥 -&gt; 复盘和沉淀</p><p>思路就是: 明确事-&gt;找对人-&gt;排计划-&gt;定机制-&gt;收好尾。不过，从项目特质上来说，信息是渐明渐细的，梳理和澄清是一件持续的工作。</p><h1 id="三、问题厘清"><a href="#三、问题厘清" class="headerlink" title="三、问题厘清"></a>三、问题厘清</h1><p>有了整体的思路,心里也就有了底气，但也不能眉毛胡子一把抓。不同的阶段重点不同，按照常见的项目阶段来看，可以分为启动期、规划期、执行期、监控期及收尾期。每个阶段需要明确关键目标，锁定核心问题。</p><p>启动期：明确方向，确认人员，厘清目标，明确机制，制定里程碑计划；</p><p>规划期：明确目标、确认方案，制定执行计划；</p><p>执行期：紧盯目标、管控计划、保障落地；</p><p>监控期：基于目标、运用机制、核查计划、发掘风险，制定预案，管控变更。理论上从规划期到收尾期都属于监控期，但项目的差异，着力点和力度有不同。常见的互联网项目，执行期监控力度最大，所以一些流程上把执行和监控揉和在一起了；</p><p>收尾期；有序收尾、深度复盘、有效沉淀。</p><p>这里已经明确了各节点的重点，那如何抓住这些节点值得探讨。作为项目PM或团队管理者，需要把控三点：</p><p>驱动管理节点，紧盯目标，这个目标是宏观的目标，包括业务目标、进度目标、人员的目标；</p><p>保障沟通通道，保障信息的上传下达，步调一致，协同各团队有效参与；</p><p>运用管理机制，包括目标负责制、沟通机制、需求管理机制等；</p><h1 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h1><p><strong>1. 驱动管理节点</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/27ff29481551406899e004d6fbca3eb0.jpeg"></p><p>管理节点一方面要拉齐信息，另一方面要发掘风险和问题，及时做出应对。关键点上核心信息的确认和决策以及同步，当面的会议沟通是非常有效的手段，但保障会议有效是其中的关键。</p><p>会议前；做好议题收集和准备，特别是会议的前置输入材料和关键信息提前准备好；</p><p>会议中；聚焦议题和发言顺序，控制会议时间，保障会议有效；</p><p>会议后；要有结论输出并同步参会人及关联方；</p><p>SOHO模式下，IM、音视频及共享屏幕工具尤为重要，尽量选择团队日常使用、通用性好、使用复杂度低的工具并分享使用TIPS。整体会议安排上做好协同，避免过度的会议影响正常工作；</p><p>方向对焦会: 基于项目价值、核心1号位及关键同学，通过会议确认并输出：方向、初步策略、里程碑及运行机制；</p><p>方案review会: 会议前基于方向对焦会结论，已产出核心方案草案，且在该草案基础上拉通关联团队输出联动业务方案；</p><p>需求评审会：基于业务方案和平台能力明确当前业务需求，通过需求评审会确认各负责人及落地计划；</p><p>复盘会：基于目标、方案结合当前完成情况进行复盘，重点是可复用能力的沉淀和发现问题的后续跟进。</p><p><strong>2. 保障沟通通道</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/54286eb66b854a88bf99f554b169678e.jpeg"></p><p>日会：通过项目例会对焦核心信息，同时进行关键工作进度同步、成果验收和快速决策。根据项目所处的阶段和工作的颗粒度，可以调整会议的频率，但不适宜频繁调整节奏和会议室；</p><p>日报：围绕核心目标、策略、进展、风险等核心信息有效记录和同步，重要信息需和对接人确认并反馈；</p><p>文档库：提升信息管理效率，降低PM和关键人员沟通瓶颈；促使团队自主联动，有效同步和纪录核心信息，持续沉淀关键信息给后续复盘和项目做好沉淀。</p><p><strong>3. 建立和运用机制</strong></p><p>持续和聚焦目标、策略（方案）、进度（计划）促成高效执行；发掘和同步风险，准备预案消除和降低风险危害。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/1faec555f23d4b7eb11b9a28a14d2e2f.jpeg"></p><h1 id="五、关键点"><a href="#五、关键点" class="headerlink" title="五、关键点"></a>五、关键点</h1><p><strong>1. K.O.（启动会）</strong>:</p><p>目的：启动会能够让各个业务部门的人员清楚知道项目的概况，目标、策略、落地计划，懂得如何配合，确保后续各部门人员配合到位，沟通协调效率高，有利于推动整个项目的推进。</p><p>操作：</p><p>1）会前准备</p><p>明确参会人员：确定他们的时间，并据此确定会议地点。SOHO模式下，选择好协同工具，比如视频会议、视频直播，提前试用告知参会者准备参会设备；</p><p>划分讲话内容：为发言者圈定讲话范围和时限，让参会者要求准备发言内容；线上沟通，需要比现场沟通更精炼；</p><p>准备相关资料：包括宣传资料、现场摆设、座位分布、相关配套服务等等。</p><p>2）会议通知</p><p>召开项目启动会通常提前3天发布通知，紧急情况下适当调整，同时要提前与参会的核心人员进行沟通，让参会人员事先了解自己在项目中需要负责的工作和担任的角色。项目团队的所有成员都要参加项目启动会议，即使有人当时不在办公室，也尽可能通过电话参与会议。</p><p>3）会议议程</p><ol><li>由项目负责人介绍项目背景、目标、范围，奠定整个项目的基础；</li><li>由各业务负责人介绍产品方案；</li><li>由项目经理介绍项目管理机制，包括安全机制、奖惩机制、沟通机制（日会、周会、日报、周报等）、变更管理等；</li><li>由项目负责人为各团队负责人颁发委任状或立军令状，并全团队大合影，在SOHO模式下可以选择工作照拼图。</li></ol><p>4）会议原则</p><p>高层的领导尽量邀请到，这样各负责人可以提高重视度，更积极的组织个参与工作。启动会一定要按时开始、按时结束。这代表着项目管理的基调和规则，有利于形成守时、高效的项目管理风格。<br>启动会必须要正式，会议的议程和时间可以缩短，但是会议的规格和对参会人员的重视程度一定要达到标准，要让参会人员觉得会议很重要，老大讲话投屏、横幅、座位牌、水等尽量要有保证。</p><p>5）会议总结</p><p>项目启动会是一种关键信息对焦和拉通形式，所以，需要总结会议的重点内容和后续计划，并把会上领导关键讲话作为项目过程中的指导方针，把团队的合影、军令状、项目的K.O.文件等在会后一并发给大家，推进项目展开。</p><p><strong>2. 风险管理</strong></p><p>风险在各个项目里长期存在，识别、反馈及处理风险是持续工作。在项目里一方面要建立全员风险管理的意识，鼓励风险的及时识别和上报。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/ae6b0977ab224917a766e454727e1762.jpeg"></p><p><strong>3. 相关方管理</strong></p><p>项目经理需要识别项目相关方，分析其对项目的要求或需求，并且管理好这些要求和需求，满足不同的相关方，从而以确保项目的成功。识别和管理相关方是项目中持续要做的工作，且需要明确反对项目的人或组织同样属于相关方。</p><p>1）识别相关方:</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/d89ddefefd304a9d93b84e35ac336fe5.jpeg"></p><p>2）管理相关方：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/7dfe083ddf55453a952cca8564f35a63.jpeg"></p><p><strong>4. 复盘</strong></p><p>目的：基于目标、方案结合当前完成情况进行复盘，沉淀可服用能力，发掘系统缺陷和无效策略，在结束后修复完善漏洞并记录为下一个项目提供支撑和规避；</p><p>时机：</p><p>不同的项目复盘契机存在差异，但复盘的目标需要明确，一定要杜绝无效的复盘；</p><ol><li>时限型项目达到预定时间；例如：3月底完成APP DAU提升XX的目标；</li><li>目标型项目达到预定目标；例如：Q3完成APP客诉量下降一半的目标；</li><li>项目出现严重问题；</li></ol><p>操作：</p><p>1）复盘原则：</p><p>多目标以目标纬度复盘，确保链条完整性；<br>子项目复盘在组内进行，保障复盘有效性；<br>鼓励畅所欲言，警惕自我吹捧、禁止互相攻击。</p><p>2）会前准备:</p><p>明确需要参与人、时间、地点；划分讲话内容，为发言者圈定讲话范围和时限，让发言者要求准备<br>准备相关资料，包括前期方案及过程数据。</p><h1 id="六、结束语"><a href="#六、结束语" class="headerlink" title="六、结束语"></a>六、结束语</h1><p>以上是组织一个项目的简要流程。从阿里文娱PMO团队的经验出发，项目过程中会有很多复杂的问题出现，但发挥项目的团队能力，最终都能顺利解决。此外，还可以寻求专业的项目管理团队作为教练赋能，最终实现：</p><ol><li>目标可预测；</li><li>资源可调度；</li><li>变化可控制；</li><li>问题可见和追溯，使得战役有序打响并取得预期的胜利。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;互联网公司除了业务迭代快，大型战役活动也不少，比如阿里巴巴的双11、阿里影业的春节档、优酷的世界杯等等。这些大型战役，不仅考</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>Servicemesh和API Gateway关系深度探讨</title>
    <link href="http://ai.mak.cn/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/"/>
    <id>http://ai.mak.cn/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2023-01-10T02:43:43.607Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://skyao.io/post/202004-servicemesh-and-api-gateway/">https://skyao.io/post/202004-servicemesh-and-api-gateway/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Service Mesh和API Gateway之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在Service Mesh和API Gateway融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。</p><blockquote><p>备注1：为了节约篇幅，我们将直奔主题，假定读者对Servicemesh和API Gateway已有基本的了解。</p><p>备注2: 这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。</p></blockquote><h2 id="原本清晰的界限：定位和职责"><a href="#原本清晰的界限：定位和职责" class="headerlink" title="原本清晰的界限：定位和职责"></a>原本清晰的界限：定位和职责</h2><p>首先，Service Mesh和API Gateway在功能定位和承担的职责上有非常清晰的界限：</p><ul><li>Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯</li><li>API Gateway： 负责将服务以API的形式暴露（给系统外部），以实现业务功能</li></ul><p>如上图所示：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>从功能和职责上说：</p><ul><li>位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力</li><li>在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务</li><li>原子微服务和组合服务部署于 <strong>系统内部</strong>，在采用servicemesh的情况下，由servicemesh提供服务间通讯的能力</li><li>API Gateway用于将系统内部的这些服务暴露给 <strong>系统外部</strong>，以API的形式接受外部请求。</li></ul><p>从部署上说：</p><ul><li>Servicemesh部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统</li><li>API Gateway部署在系统的边缘：一方面暴露在系统之外，对外提供API供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。</li></ul><p>在这里引入两个使用非常广泛的术语：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_407b3c3a252215b00281feebff74034e.png" alt="img"></p><ul><li><strong>东西向</strong>通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部</li><li><strong>南北向</strong>通讯：指服务对外部提供访问，通常是通过API Gateway提供的API对外部保罗，其通讯流量是从系统外部进入系统内部。</li></ul><blockquote><p>解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左西右东”的原则。</p></blockquote><p>总结：Service Mesh和API Gateway在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现Service Mesh和API Gateway关系的讨论了，自然也不会有本文。</p><p>问题的根源在哪里？</p><blockquote><p>强烈推荐阅读：附录中 Christian Posta 的文章 “Do I Need an API Gateway if I Use a Service Mesh?“对此有深度分析和讲解。</p></blockquote><h2 id="哲学问题：网关访问内部服务，算东西向还是南北向？"><a href="#哲学问题：网关访问内部服务，算东西向还是南北向？" class="headerlink" title="哲学问题：网关访问内部服务，算东西向还是南北向？"></a>哲学问题：网关访问内部服务，算东西向还是南北向？</h2><p>如下图所示，图中黄色的线条表示的是API Gateway访问内部服务：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看 API Gateway 访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_3639b8345d877d10b889d082af357bb8.png" alt="img"></p><p>所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway ，是作为一个整体，还是逻辑上分拆为对内对外两个部分。</p><p>这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现 “API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：</p><ol><li>泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway访问内部服务的通讯机制自行实现，独立于服务间通讯的机制</li><li>兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。</li></ol><p>而最终决策通常也和产品的定位有关：如果希望维持 API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如springcloud生态下的zuul和springcloud gateway。</p><p>但无论选择哪个流派，都改变不了一个事实，当 “API Gateway 作为一个客户端访问内部服务” 时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证…… 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。</p><p>这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。</p><p>这里又是一个类似的哲学问题：当 “API Gateway 作为一个客户端访问内部服务” 时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？</p><p>答案不重要。</p><h2 id="Sidecar：真正的重合点"><a href="#Sidecar：真正的重合点" class="headerlink" title="Sidecar：真正的重合点"></a>Sidecar：真正的重合点</h2><p>在进入servicemesh时代之后，Servicemesh和API gateway 的关系开始是这样：</p><ol><li>功能和职责清晰划分</li><li>客户端访问服务的功能高度重叠</li></ol><p>此时两者的关系很清晰，而且由于当时Servicemesh和API Gateway是不同的产品，两者的重合点只是在功能上。</p><p>而随着时间的推移，当 Servicemesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。</p><p>在Servicemesh出现之后，如何为基于Servicemesh的服务选择合适的API Gateway方案，就慢慢开始提上日程，而其中选择重用Servicemesh的能力也自然成为一个探索的方向，并逐步出现新式API Gateway产品，其想法很直接：</p><p><strong>如何融合东西向和南北向的通讯方案？</strong></p><p>其中的一个做法就是基于Servicemesh的Sidecar来实现API Gateway，从而在南北向通讯中引入Servicemesh这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片(鸣谢赵化冰同学)来解释这个方案的思路：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_b3dce2008e0a698c0a2c0b94fa11cd72.png" alt="img"></p><p>这个时候servicemesh和API Gateway的关系就变得有意思了，因为servicemesh中sidecar的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：</p><ol><li>API Gateway本体：实现API Gateway除了访问内部服务之外的功能</li><li>Sidecar：按照servicemesh的标准做法， 我们视API Gateway为一个部署于servicemesh中的普通服务，为这个服务1:1的部署sidecar</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_7f2933075826470040bdc993f499a41f.png" alt="img"></p><p>在这个方案中，原来用于servicemesh的sidecar，被用在了API Gateway中，替代了API Gateway中原有的客户端访问的各种功能。这个方案让API Gateway的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway可以更专注于 “API Management” 的核心功能。</p><p>此时 servicemesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。</p><p>而采用这个方案的公司，通常都是先有servicemesh产品，再基于servicemesh产品规划（或者重新规划）API Gateway方案，典型如蚂蚁金服的SOFA Gateway产品是基于MOSN，而社区开源产品Ambassador和Gloo都是基于Envoy。</p><p>上述方案的优势在于API Gateway和Sidecar独立部署，职责明确，架构清晰。但是，和servicemesh使用sidecar被质疑多一跳会造成性能开销影响效率一样，API Gateway使用Sidecar也被同样的质疑：多了一跳……</p><p>解决“多一跳”问题的方法简单而粗暴，基于sidecar，将API Gateway的功能加进来。这样API Gateway本体和Sidecar再次合二为一：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_9c29254ffd88f10a2d87f5207d0cd98f.png" alt="img"></p><p>至于走到这一步之后，Servicemesh和API Gateway是什么关系：这到底算是Servicemesh&#x2F;sidecar融合了API Gateway，还是API Gateway融合了Servicemesh&#x2F;Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。</p><h2 id="BFF：把融合进行到底"><a href="#BFF：把融合进行到底" class="headerlink" title="BFF：把融合进行到底"></a>BFF：把融合进行到底</h2><p>BFF(Backend For Frontend)的引入会让Servicemesh和API Gateway走到一个更加亲密的地步。</p><p>先来看看常规的BFF的玩法：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_e140284a158e9b4b6564033a00470096.png" alt="img"></p><p>在这里，多增加了一个 BFF 层，介于API Gateway和内部服务（包括组合服务和原子微服务）之间。注意BFF的工作模式和组合服务很类似，都是组合多个服务。但差别在于：</p><ol><li>组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务</li><li>BFF不同，BFF如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问</li><li>对我们今天的话题而言，最关键的一点：BFF完全收口了从外部进入的流量，而组合服务没有，API Gateway是可以直接访问原子微服务的</li></ol><p>“BFF完全收口外部流量”，这一点在API Gateway和Sidecar融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有BFF的情况下，API Gateway和Sidecar融合后的情景：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_651c59dccf7914428f283feed4dbd00c.png" alt="img"></p><p>放大一点，单独看API Gateway和BFF：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_f9c39a8b510c458355adaf5a268ca4e7.png" alt="img"></p><p>注意到，流量从被API Gateway接收，到进入BFF在这个流程中，这个请求路径中有两个sidecar：</p><ol><li>和BFF部署在一起的，是没有API Gateway功能的普通Sidecar</li><li>API Gateway和Sidecar融合之后，这就是一个“有API Gateway功能的大Sidecar”（或者是“有Sidecar功能的特殊API Gateway”）：虽然扮演了API Gateway的角色，但本质上依然包含一个完整功能的sidecar，和BFF自带的Sidecar是等同的</li></ol><p>所以，问题来了：为什么要放两个sidecar在流程中，缩减到一个会怎么样？我们尝试将两个Sidecar合二为一，去掉BFF自带的Sidecar，直接把扮演API Gateway的sidecar给BFF用：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_a41f2181acde4f58b132873302a99e57.png" alt="img"></p><p>此时的场景是这样：</p><ol><li>流量直接打到BFF上（BFF前面可能会挂其他的网络组件提供负载均衡等功能）</li><li>BFF的sidecar接收流量，完成API Gateway的功能，然后将流量转给BFF</li><li>BFF通过sidecar调用内部服务（和没有合并时一致）</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_65454a16542646a5a9751b76bd5d8927.png" alt="img"></p><p>注意这里有一个关键点，在前面时特意注明的：“<strong>BFF完全收口外部流量</strong>”。这是前提条件，因为原有的API Gateway集群已经不再存在，如果BFF没能收口全部流量，则这些未能收口的流量会找不到API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带API Gateway功能的Sidecar，也是可行的，只是管理上会比BFF模式要复杂一些。</p><p>另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的API Gateway的集群，常规的中心化的网关在这个方案中被融合到每一个BFF的实例中，从而实现另外一个重要特性：去中心化。</p><p>上述Servicemesh 和 API Gateway融合的方案，并未停留在纸面上。</p><p>在蚂蚁金服内部，我们基于Servicemesh 和 API Gateway融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化&#x2F;Sidecar化，最终演变成了这样一个方案：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_0d19f1a6e1e5aee915cd771adc2553b2.png" alt="img"></p><blockquote><p>强烈推荐阅读：附录中我的同事 贾岛 的文章 “蚂蚁金服 API Gateway Mesh 思考与实践” 对此有深入介绍和详细描述。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了 Servicemesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是API Gateway和Sidecar 合二为一。</p><p>后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。</p><p>补充介绍一下文中多次提到的“MOSN”：</p><p>MOSN 是 MOSN 是 Modular Open Smart Network 的简称， 是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。 MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。 MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。</p><ul><li>GitHub：<a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a></li><li>官网：<a href="https://mosn.io/">https://mosn.io</a></li></ul><h2 id="附录：参考资料和推荐阅读"><a href="#附录：参考资料和推荐阅读" class="headerlink" title="附录：参考资料和推荐阅读"></a>附录：参考资料和推荐阅读</h2><p>意犹未尽的同学，欢迎继续阅读以下内容。</p><p>按文章发表的时间排序：</p><ul><li><a href="https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/">The Difference Between API Gateways and Service Mesh</a>： 2020-02，指导架构师确定何时使用API网关以及何时使用服务网格，作者Marco Palladino，来自kong。</li><li><a href="https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">Do I Need an API Gateway if I Use a Service Mesh?</a>：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 <a href="https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">使用了 Service Mesh 后我还需要 API 网关吗</a>，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。</li><li><a href="https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN">蚂蚁金服 API Gateway Mesh 思考与实践</a>: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和API Gateway Mesh的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在Servicemesh和API Gateway融合方面的实践。</li><li><a href="https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/">API Gateway的身份认同危机</a>: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述API Gateway的基本理念如API的定义，API Management的含义，API Gateway模式，以及服务网格和API Gateway的关系。</li><li><a href="https://skyao.io/talk/201810-ant-finance-service-mesh-practice/">长路漫漫踏歌而行：蚂蚁金服Service Mesh实践探索</a>: 2018-10，我在QCon的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于Sidecar的SOFA Gateway产品刚开始开发。</li><li><a href="https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784">API Gateway vs Service Mesh</a>: 2018-09，作者Richard Li，Datawire的CEO ，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的API Gateway开源产品，文章阐述了对服务网格和API Gateway的看法，差异，以及对两者集成的看法。</li><li><a href="https://skyao.io/post/201803-dreammesh-brainstorm-gateway/">DreamMesh抛砖引玉(9)-API Gateway</a>: 2018-03，这个文章也是我写的，2018年初我和servicemesh社区的一些朋友深入探讨之后，在DreamMesh系列博客文章中记录下了当时构想的方案，尤其对 API gateway和sidecar是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！</li><li><a href="https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56">Service Mesh vs API Gateway</a>: 2017-10，原文作者 <a href="https://medium.com/@kasunindrasiri">Kasun Indrasiri</a>，以及 <a href="https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/">赵化冰同学翻译的中文版本</a>，文章不长，主要对比了服务网格和API Gateway的产品功能，提出了两者融合的方式——在API Gateway中通过服务网格来调用下游服务。</li><li><a href="https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/">Application Network Functions With ESBs, API Management, and Now.. Service Mesh?</a>：2017-08，作者 Christian Posta，讲述服务网格与ESB，消息代理和API管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://skyao.io/post/202004-servicemesh-and-api-gateway/&quot;&gt;https://skyao.io/post/202004-servicemesh-and-api-gateway/&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
