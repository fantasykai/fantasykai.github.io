<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Qunar 酒店基础数据重构DDD落地实践</title>
    <link href="http://ai.mak.cn/2022/09/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Qunar%20%E9%85%92%E5%BA%97%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84DDD%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2022/09/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Qunar%20%E9%85%92%E5%BA%97%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84DDD%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2023-01-14T15:32:30.330Z</updated>
    
    <content type="html"><![CDATA[<p>本文作者 ：<strong>李全党</strong></p><blockquote><p> 2021年6月入职去哪儿网，酒店供应链高级技术经理、业务架构SIG成员、公司级内训师，目前负责酒店基础信息业务。主导搭建并落地多个DDD项目，并对高并发、分布式服务高可用，有建设优化经验，2021年落地公司“大主站+微服务”战略，并获得公司“金项奖”技术类三等奖，曾在QCon做过技术分享。</p></blockquote><p><strong>一、案例简述</strong></p><p>随着集团战略方向调整与业务重组，酒店供应链也面临全新的调整。酒店基础数据业务系统是从国际团队接手，属于10年前系统架构，涉及20多个微服务，架构老旧、系统耦合严重及业务边界模糊，加上业务的快速发展，导致系统灵活性不足及无法快速承接产品需求，产研合作出现效率问题。因此，酒店供应链技术侧结合酒店BU及公司相关成功案例，在2022年初主动发起基于DDD思想的技术架构调整，完整落地战略、战术设计及系统实现，本次重点介绍重构落地过程、设计原则及总结，另外阅读本文需要对DDD的基本概念及流程有一定基础，基本概念可以参考往期技术沙龙（链接见文末）。</p><p><strong>二、问题分析</strong></p><p><strong>（一）业务需求复杂</strong></p><p>酒店基础信息业务系统最初是为去哪儿独立业务设计，主要包括酒店聚合、房型聚合、图片及城市等相关信息（见下图），最初业务划分比较清晰。2015年携程战略收购去哪儿网后，业务战略也随之发生变化，但当时并未对系统进行隔离和重构，随着需求迭代的不断演化，业务逻辑变得越来越复杂，加上产品经理的流动性较大，酒店基础数据PM、DEV、QA团队缺少业务专家，大家对于原始需求缺少理解，部分业务不确定能否下线等等。</p><p><img src="https://p3.itc.cn/q_70/images03/20220928/8601c2b3e9b94577875d9ae3b50198ca.png" alt="img"></p><p><strong>（二）系统过度耦合</strong></p><p>酒店基础数据涉及微服务20多个，系统之间耦合严重，模块彼此关联，我们的系统越来越冗杂。有时修改一个很小的产品需求，光回溯该需求涉及需要修改的系统及功能点就需要达到“天”级别，更别提修改带来的不可预知的影响面，无论还是产品、技术需求还是工单问题排查等，都给组内同学带来较高学习成本和开发成本。</p><p>下图是我们酒店基础信息日常开发中的一个常见的系统耦合案例。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/4185d98603e34be7817e07e261b183f8.png" alt="img"></p><p>这个案列是要完成的业务功能是支持运营人员手工添加酒店图片，当时预估工时时长8pd，实际工时11pd。上图看出从运营开始上传到我们最终将图片外网展示，整体流程涉及到了4个系统。</p><p>以下这段话是当时开发这个产品需求的同学的“真情告白”：</p><p>1、需求及系统设计阶段。接到TL的排期并阅读产品PRD，发现涉及4个业务系统，深入系统内部发现业务逻辑复杂及系统耦合严重，熟悉系统及编写设计方案花费3pd；</p><p>2、系统开发阶段。按照设计进行功能开发发现，除正常多业务系统调用外，业务系统内部存在兜底定时任务，需要进一步熟悉其作用、数据存储及影响范围，花费6pd；</p><p>3、系统自测阶段。系统自测涉及多个系统间的耦合及不同的数据库版本，自测花费2pd。</p><p>如果我们的系统经过精心设计，这个案例是不需要8pd，更别说最终上线花费11pd。我们可以看出系统过度耦合，不但降低我们的开发效率，而且对于开发人员不够友好，这种情况对于人员的稳定性也造成很不好的影响，所以我们必须要做出改变。</p><p><strong>三、为什么选择DDD</strong></p><p>DDD有很多优势，我们站在EA角度，可以绑定业务架构和系统架构，作为中间层，将问题域与应用架构相剥离；我们站在软件复杂度角度，可以有效解决业务复杂度和软件复杂度问题；还比如DDD可以有效的从业务视角对软件系统进行拆解，是微服务划分最好的实践等等，作为基础数据重构，结合我们上面提到的业务需求复杂和业务过度耦合问题，我们主要从解决软件复杂度和微服务拆分角度考虑，最终选择DDD作为我们项目落地的指导原则。</p><p><strong>（一）软件复杂****度应对</strong></p><p>Eric Evans 认为“应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务”。因而，领域驱动设计关注的焦点在于领域和领域逻辑，因为软件系统的本质其实是给客户（用户）提供具有业务价值的领域功能。那么DDD是如何应对软件复杂度的呢？我们可以粗略的归为三类，分别是分而治之、关注点分离和统一语言。</p><p>1、分而治之。比起单体架构将所有功能都糅合在一起，DDD通过在其战略设计层面对限界上下文、上下文地图的划分来做到这一点。各个业务领域内关注自身业务能力的内聚，明确分工，不被其他领域业务侵蚀，这不仅符合“高内聚、低耦合”的架构思路，更是与微服务拆分的思想不谋而合；</p><p>2、关注点分离。DDD使得领域模型与存储模型分离，业务复杂度与技术复杂度分离；</p><p>3、统一语言。我们大部分需求是横跨多个团队，需求传递低效，需要反复沟通，方案产出效率低，而统一语言使得产研在业务概念、理解等方面达成一致，降低沟通和理解成本。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/c635686e27384b8ca34b597eb0004c85.png" alt="img"></p><p><strong>（二）微服务架构模式的最佳实践</strong></p><p>微服务有9大特征，我们这里不赘述。由于DDD可以有效的从业务视角对软件系统进行拆解，并且DDD特别契合微服务的一个特征：围绕业务能力构建。所以用DDD拆分出来的微服务是比较合理的而且能够实现高内聚低耦合。我们之前会因为微服务不知如何拆分讨论上好几天，其实根本原因是不知道边界在什么地方，而使用DDD对业务分析的时候：</p><p>1、使用聚合把关联性强的业务概念划分在同一个限界上下文，并限定聚合和聚合之间只能通过聚合根来访问</p><p>2、聚合基础之上根据业务相关性，业务变化频率，组织结构等等约束条件来定义限界上下文。</p><p>DDD的聚合和限界上下文，使得拆分微服务不再困难。</p><p><strong>四、演化式技术改造</strong></p><p>在我们确定使用DDD作为指导进行项目落地，一个难题是我们如何推进多业务系统重构上线，如果采用完全重做的方式，摒弃原有的系统重新开发，虽然可以快速有效摆脱原有系统的历史技术债，但是也会丢失那些细小而繁杂的业务逻辑，为整个系统的改造带来巨大的项目风险，特别是像酒店聚合、房型聚合等涉及多种算法的业务，严重时会导致高额赔付。</p><p>最终我们采用的是 <strong>演化式技术改造</strong>，即利用重构在原有的系统上逐步改造。即在原有系统的基础上，通过一步一步演进式的代码调整，逐步达到技术改造的目标。每一步重构，对于核心业务功能保持外部功能不变，重点调整程序内部结构，通过内部程序结构的优化，业务代码逐渐与各个层次、各种技术解耦。可以看出，演化式技术改造的目标是实现业务代码与技术框架的解耦，通过重构将长周期的改造过程，通过业务域、重要程度等划分成一个短周期的重构，保障每次重构的正确性。</p><p>酒店基础数据重构包含酒店业务、房型业务及图片业务，我们采用分阶段上线，优先上线酒店业务。那么对于酒店业务，其又包含了酒店聚合、酒店静态信息、酒店抓取等多个子业务，为保障重构业务输出正确性及阶段成果，我们将酒店业务又划分两阶段上线和功能验证，正是这样的过程，保障了在改造过程中，虽然修改了既有代码，但没有影响既有功能，使得改造更加平稳的进行下去。经过这一系列改造，系统的业务代码与技术框架解耦了，接口层建立起来，就可以从容地开展真正的技术改造。</p><p><img src="https://p3.itc.cn/q_70/images03/20220928/4215424b2499447e926e741d1cc4ccc1.png" alt="img"></p><p><strong>五、DDD实践及设计原则</strong></p><p><strong>（一）完整的DDD落地流程框架</strong></p><p><img src="https://p3.itc.cn/q_70/images03/20220928/4912980c96ce4d02b5844bd23544b3e2.png" alt="img"></p><p>上图为整体DDD落地流程框架，也是thought works强力推荐的流程，那么我们本篇文章并不打算去讲解流程的每个细节，而是重点介绍我们在酒店基础信息重构过程中，所积累的落地时间经验和原则，希望通过这些经过抽象和总结的经验，能够给各位带来一些收获和思考，具体内容请接着往下看。</p><p><strong>（二）DDD落地实践原则</strong></p><ul><li><strong>产研沟通，定位愿景</strong></li></ul><p>定位愿景的主要目的是对产品的顶层价值设计，对产品目标用户、核心价值、差异化竞争点、痛点等策略层信息在团队层面达成共识，这也是我们做这个事情的根本。而对于部分的DDD分享文章或者我们真正在做项目落地时，缺少关注我们的项目定位、愿景是什么，项目前期没有关注，会导致我们在划分子域时，不清楚如何确定是核心域、支撑域还是通用域等，以及资源安排没有侧重点，愿景的定位非常重要，尤其在我们新项目落地。</p><p>我们常用的定位愿景所使用的方法叫“电梯演讲”， 领域专家与项目团队一起思考，我们做的项目业务范围、目标用户、核心价值和愿景，我们与同类产品的差异和优势在哪里？整个过程是统一项目建设方向和团队思想的过程，当然如果我们的项目是一个纯粹的后端业务系统，并不是所有点都涉及，也可以跳过，比如下图所示的“关键的优点，难以抗拒的使用理由”，对于酒店静态信息而言，我们的使用用户更多是我们公司内部，那么就没有难以抗拒的使用理由了。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/bc5f7d9b34db4a47b016ec295f267deb.png" alt="img"></p><ul><li><strong>产研融合，提炼问题域</strong></li></ul><p>理解一个复杂问题域以便创造简单且有用的模型，需要深入详尽的知识以及深刻的见解，这些需要产、运、研、测共同协作得到。只有通过协作及共享对问题域的理解，才能有效设计领域模型以应对业务的挑战，这样也能具备足够的灵活性应对新出现的需求。初期我们与产运一起，通过线上画板工具（初期推荐使用BeeArt，也可使用ProcessOn）及公司白板，开展事件及命令风暴，一起探讨应用程序的应用场景。这一过程是所有参与者进行花火碰撞，获得领域的深刻见解的催化剂，通过风暴我们提炼出领域知识，重新梳理业务流程，并形成通用语言（可以包括显示的业务规则、领域名词解释等，形成统一的思维地图），达成共识。</p><p>下图右半部分为“酒店静态信息业务流程”，我们本次重构重新对原有“蜘蛛网”式的业务流程进行梳理，明确业务流阶段、价值及相应显式规则，与产运沟通确认20次（微信、邮件、线下会议、腾讯会议等）。通过产研融合，提炼问题域后，确认线上低价值或无用业务占比线上总业务用例的41.9%（原始业务用例：222个，重构后保留业务用例：129个，共下掉93个业务）。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/0173d7d2f63e4cea96b9a9c6612fe713.png" alt="img"></p><ul><li><strong>集中精力，专注核心域</strong></li></ul><p>酒店基础数据涵盖酒店、房型、图片及位置区域等多个问题域，我们需要将问题域分而治之来降低复杂性，因为较小的模型可以在子域的上下文中更容易被理解。并通过划分核心域、通用域及支撑域来决定研发策略（比如：视频、图片及城市等通用域业务简单且需求相对稳定，并未进行重构，保持现状）及资源配备。相信大家在进行项目开发的时候，一定会觉得时间紧、任务重及资源不足等等，那么这个时候我们更要关注要做的项目，他的核心价值是什么（可以参考领域愿景），因为他代表团队或组织的价值所在，所以我们要专注核心领域，安排核心开发人员及做好跟踪，确保核心领域按照预期推进。</p><p><img src="https://p6.itc.cn/q_70/images03/20220928/c205a5c3458e49e49809e1691f3f680a.png" alt="img"></p><ul><li><strong>使用限界上下文保护领域模型完整</strong></li></ul><p>限界上下文拥有从展现层到领域逻辑层，再到持久化，甚至到数据存储功能的垂直切片，那么产品的概念可以存在每个限界上下文中，并且包含仅对该上下文普遍存在的特性和逻辑。任何限界上下文中的变化不再具有对其他有界上下文的影响，因为限界上下文或子域是隔离的。限界上下文具备概念上的独立性，一个限界上下文内的子概念的解释和目的都不应该超出上下文的边界，若出现以下依赖关系，需要思考是否存在未澄清的问题：</p><p>a. 双向依赖:上下文之间缺少一层未被澄清的上下文，或者两个上下文其实可被合为一个；</p><p>b. 循环依赖:任何一个上下文发生变更，依赖链条上的上下文均需要改变；</p><p>c. 过长的依赖:自身依赖的信息不能直接从依赖者获取到，需要通过依赖者从其依赖的上下文获取并传递，依赖链 路过长，依赖链条上的任何一个上下文发生变更，其链条后的任何一个上下文均可能需要改变。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/140bf7f5550b4a4c87124d09fddf3c2d.png" alt="img"></p><p>另外我们要把握好领域职责，领域之外的事不要管，同时领域之间的数据交互，需要通过“防腐层”将领域外的对象转换为领域内对象。举个例子：下图是我们酒店的抓取解析流程，重构前不仅做了抓取和解析，还做了特殊属性处理、视频处理等非自己领域的事情，所以我们重构后，将这两个事情让给了“酒店静态信息上下文”去处理，并形成抓取解析上下文，只做一件事情：从外部抓取数据，并将数据转换为Qunar内部对象。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/0ed35e9def3248b1afefc34f73466e29.png" alt="img"></p><ul><li><strong>应用程序架构落地COLA</strong></li></ul><p>目前比较流行的应用架构，都会遵循一些共同模式，不管是六边形架构、洋葱圈架构、整洁架构、还是COLA架构，都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。我们最终选择了COLA架构，有几点原因：</p><ul><li><strong>明确的分层架构</strong></li></ul><p>所有的复杂系统都会呈现出层级结构，应用系统处理复杂业务逻辑也应该是分层的，下层对上层屏蔽处理细节，每一层各司其职，分离关注点</p><p>1、适配层：针对不同端、协议的适配，包括酒店基础信息命令执行、查询及适配返回等；</p><p>2、应用服务层：酒店基础信息业务用例识别，并负责调用领域层能力，对用例进行组装、编排及返回结果；</p><p>3、领域服务层：提供酒店基础信息相关业务能力，并针对复杂或跨聚合业务提供领域服务能力，供应用服务层调用；</p><p>4、基础设施层：主要处理技术细节问题的处理，包括领域外部服务访问防腐层实现，数据库DB、缓存等持久化。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/245c4dd7146a402a894e4a8b61ea4796.png" alt="img"></p><p><img src="https://p2.itc.cn/q_70/images03/20220928/f4bd55b428f6409cbdb9d1859d30f6c9.png" alt="img"></p><p>扩展：我们在整个战术设计的过程中，利用奥卡姆剃刀原理（是指如无必要，勿增实体，即“简单有效原理”）的思想，引入DP（Domain Primitive 是 Value Object 的进阶版，在原始 VO 的基础上要求每个DP拥有概念的整体，而不仅仅是值对象）并把实体属性归类，为 VO 的 Immutable 基础上增加了 Validity 和无状态行为，防止将过多的属性拍平到实体。</p><p><img src="https://p6.itc.cn/q_70/images03/20220928/39e4803f7e174a698cbef7217a93c7fe.png" alt="img"></p><ul><li><strong>符合演进式架构设计</strong></li></ul><p>分层是属于大粒度的职责划分，我们有必要往下再down一层，细化到包结构的粒度，才能更好的指导我们的工作。COLA架构除了有分层规范以外，对每一层内部的包结构也有明确规范，即“聚合分包，功能分类”，这样的设计可以更好的应对未来需求变化的不确定性，符合演进式架构（演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化。那如何判断微服务设计是否合理呢？随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的）。</p><p><img src="https://p9.itc.cn/q_70/images03/20220928/d945717a316e4c04a5d0ed72e8f7a10c.png" alt="img"></p><p><img src="https://p1.itc.cn/q_70/images03/20220928/da0b0cf8a0a44142b0b8169c6a349ce7.png" alt="img"></p><p>COLA架构，本质上没有什么严格的约束，对于业务代码，还是有非常好的指导建议，不一定非要严格的按照框架的要求来执行，但一定要有规范的思想，这才是核心的。实际开发中，我们并没有完全按照CLOA架构的指导要求来，比如扩展组件并没有使用，适合自己的才最重要。相信只要我们做好分模块，分层次，做好命名规范+一定的充血模型，代码就能做到简洁易懂。</p><p><strong>六、案例成果总结</strong></p><p><strong>（一）案例重构成果</strong></p><p>1、业务复杂度方面，我们共梳理222个业务用例，重构后保留129个，共下掉93个，业务平均下掉41.9%，对于降低产运研业务学习带来较大帮助；</p><p>2、瘦身服务及减链路方面，酒店基础信息业务涉及21个应用微服务，通过DDD领域划分后下降到13个，微服务减少33%，对应代码下降情况统计，平均代码下掉58.3%，大大降低研发学习及硬件成本；</p><p>3、业务专家方面，通过事件、命令风暴，对于项目成员对酒店基础信息业务更加有全局观，与产研形成统一语言和知识，减少产、运、测、研沟通成本，在业务专家方面增加2名研发业务专家，让我们更多站在业务视角去思考和解决问题，而不是来了需求首先想到的是工时问题；</p><p>4、效率提升方面，问题处理，工单处理下降50%。</p><p><img src="https://p1.itc.cn/q_70/images03/20220928/a6f39e20892441759c9a1cd7ff3c4f3f.png" alt="img"></p><p><strong>（二）项目重构常见问题</strong></p><ul><li><strong>没有领域专家怎么办？</strong></li></ul><p>我们都知道，业务领域专家和开发团队之间的协作是DDD必不可少的部分，特别是战略、战术设计阶段。不过，寻找到当前业务领域中是专家以及能够为问题域提供深刻见解的人，可谓是少之又少。那么如果没有领域专家怎么办呢？作为替代，可以寻找对于我们当前工作领域具备多年经验和理解的产品所有者、用户、研发或其他任何人，不必在意他们是不是权威，是不是管理者等等。</p><p>以我们当前的重构项目为例，酒店基础信息产品流动率高，没有对应的产品业务专家，最终我们寻找到具有多年工作经验的资深研发和业务QA作为我们的领域专家，最终取得的效果也是非常不错的。我们推荐的业务领域专家顺序为：业务产品团队-&gt;技术负责人-&gt;业务开发负责人-&gt;业务QA。</p><ul><li><strong>简单问题复杂化</strong></li></ul><p>1、DDD的价值在于帮助管理显著优势的复杂问题域，请不要轻视MVC模式，因为并非系统所有的部分都要被精心设计</p><p>我们的酒店基础信息重构项目，有酒店、房型、图片等多个问题子域，以房型子域为例，有房型抓取、落地及房型聚合等多个限界上下文，其中房型聚合业务逻辑简单，清晰明了，所以我们并没有采用DDD分层架构模式进行实现，而是使用MVC模式，不仅缩短工期，且可以快速上线验证效果，所以我们要避免将领域模型应用到每个限界上下文。</p><p>2、解决方案并不总是技术层面</p><p>当遇到项目问题时，我们大部分人的思维是从实现上进行解决，比如技术实现考虑高并发、高可用及高性能，但是真的有必须要吗？这让我想起一句话：业务架构是灵魂，技术架构是容器，脱离灵魂得容器是没有意义的！以我们的重构项目为例，我们在进行事件风暴前的业务用例梳理时，我们把业务进行归类，对于非核心业务我们会找相关业务使用方进行沟通确认，是否可以下线，是否可以合并，是否可以简化操作等等，最终我们在业务复杂度方面下降43%，节省大量的产研沟通和研发成本。</p><ul><li><strong>非核心领域占用大量精力</strong></li></ul><p>我们可能因为没有使用领域愿景来描述我们项目的核心竞争力，导致我们缺乏对项目成败核心是什么的关注，而我们的资源是有限的，时间是有限的，我们只有把有限的资源投入到最重要的区域-核心领域，才能更好的服务于企业战略，实现商业价值。以我们重构项目为例，我们项目开始则高亮我们的愿景，明确核心领域，把资深人员安排在核心的位置，保障核心领域的研发和交付质量。在项目最重要的区域分摊太少的资源就是反模式。</p><ul><li><strong>产品不关注是否使用DDD，只关注需求是否如期上线</strong></li></ul><p>对于产品只关注自己的需求是否如期上线，这种情况非常常见，所以需要我们要付出一些努力来达成我们做DDD重构的目标，我认为可以从以下几个方面入手：</p><p>1、讲清楚系统现状，以及使用DDD重构后所带来的价值，达成价值共识（与产品，必要可能需要跟产品的上级）；</p><p>2、资源紧张情况下，重要需求正常排期，非重要与产品沟通延迟上线；</p><p>3、优先解决系统核心价值域问题，分阶段成果发布；</p><p>4、研发资源闭环和共享模式共存。关于闭环和共享解释如下（摘自“人人都是产品经理”）：</p><p>闭环：就是和业务需求方绑定，专门做此类变化快的需求开发，其他的都不做；而共享则相反，将研发资源共享成一个池，所有的业务需求也汇总在一个或多个优先级队列里，排队开发。</p><p>共享：有利于充分利用研发资源，规模化、专业化，提升吞吐，但可能也降低了平均响应时间，更适合于进入成熟期，稳定渐进发展的业务。闭环，优先考虑专属业务需要的响应，但也失去了规模与专业化效应，更适合快速发展期的创新业务，而过了业务高速期，专属的研发就会形成资源浪费，对个体的成长也有不利因素。</p><p><strong>七、总结</strong></p><p>本文以酒店基础信息DDD重构实践为案例，介绍了我们为什么选择DDD，完整的DDD落地流程框架，以及利用大量篇幅和例子介绍我们项目落地实践的原则，最后介绍了案例成果和项目重构过程中常见的问题及解决方案，相信大家对DDD有了更加清晰的认识，同时在项目落地时也有了一些明确的指导原则，避免踩坑。但是DDD不是灵丹妙药，更不是“银弹”，最后有几点建议送给大家：</p><p>1、DDD是思想，是一种业务领域建模方法论、业务架构设计方法论，是指导开发过程的方法论</p><p>2、DDD是业务+技术的共同深度参与，开发人员需要有思考方式的转变，所以实践能否成功，不仅仅是技术的问题，更是贯彻实施的问题</p><p>3、战略设计阶段属于整个DDD核心阶段，领域边界划分对于团队的抽象能力有一定挑战，请不要为了“省事”，最后做成了“精简版”的DDD</p><p>好了，就写到这里，期待大家都能够有机会利用DDD作为项目指导和落地的方法论，并获得DDD所带来的价值体验~</p><p># 国内酒店交易DDD应用与实践——理论篇</p><p>#</p><p>国内酒店交易DDD应用与实践——代码篇</p><p>#</p><p>基于DDD思想的技术架构战略调整</p><p>#</p><p>坚定推动DDD一年后，去哪儿网如今怎么样了</p><p>#</p><p>听“侃王”讲基于DDD思想的酒店报价引擎重构</p><p>#</p><p>去哪儿网领域驱动设计（DDD）的实践之路</p><p><strong>END</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文作者 ：&lt;strong&gt;李全党&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 2021年6月入职去哪儿网，酒店供应链高级技术经理、业务架构SIG成员、公司级内训师，目前负责酒店基础信息业务。主导搭建并落地多个DDD项目，并对高并发、分布式服务高可用，有建设</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>老山骑行路线规划</title>
    <link href="http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/"/>
    <id>http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/</id>
    <published>2022-09-07T16:00:00.000Z</published>
    <updated>2023-01-14T14:30:15.326Z</updated>
    
    <content type="html"><![CDATA[<p>老山骑行路线，骑行群规划的路线，收藏，随时查看</p><p><img src="https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老山骑行路线，骑行群规划的路线，收藏，随时查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Lombok原理总结</title>
    <link href="http://ai.mak.cn/2022/08/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Lombok%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/12/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Lombok%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-11T16:00:00.000Z</published>
    <updated>2023-01-14T15:54:26.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者 | 王再军(曦峰)<br> 来源 | 阿里开发者公众号</p></blockquote><p>原文链接：<a href="https://link.juejin.cn/?target=https://click.aliyun.com/m/1000353148/">click.aliyun.com&#x2F;m&#x2F;100035314…</a></p><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>在写Java代码的时候，最烦写setter&#x2F;getter方法，自从有了Lombok插件不用再写那些方法之后，感觉再也回不去了，那你们是否好奇过Lombok是怎么把setter&#x2F;getter方法给你加上去的呢？有的同学说我们Java引入Lombok之后会污染依赖包，那我们可不可以自己写一个工具来代替Lombok呢？</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>Java编译过程</li><li>了解Lombok原理</li><li>了解插入式注解处理器</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>序言提到的问题其实都是同一个问题，就是如何去获取和修改Java源代码？</p><p>要回答这个问题，我们需要回答这几个问题：</p><ol><li>Java编译器是如何解析Java源代码的？</li><li>编译器编译源代码都有哪些步骤？</li><li>我们在编译器工作的时候，怎么才能去增加内容或者是进行代码分析？</li></ol><p>希望大家看完本文能够自己写一个简易的Lombok工具。</p><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><h4 id="如何解析源代码"><a href="#如何解析源代码" class="headerlink" title="如何解析源代码"></a>如何解析源代码</h4><p>其实从我们的代码到被编译，中间隔了一个数据结构，叫做AST（抽象树）。具体的形式，可以查看下面的图片。右边的便是AST的数据结构了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7f896d6010443395c8e02142a68fc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h4 id="代码编译都有哪些步骤"><a href="#代码编译都有哪些步骤" class="headerlink" title="代码编译都有哪些步骤"></a>代码编译都有哪些步骤</h4><p>整个编译过程大致如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b973503e6874077b61ae01780a5d7f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>图片来自openjdk</p><p>1、初始化插入注解处理器</p><p>2、解析与填充符号表过程</p><p>a.词法分析、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。</p><p>b.填充符号表。产生符号地址和符号信息。</p><p>3、插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。后面我会给大家带来两个此方面的实用实战例子。</p><p>4、分析与字节码生成过程</p><p>a.标注检查。对语法的静态信息检查。</p><p>b.数据流及控制流分析。对程序动态运行过程进行检查。</p><p>c.解语法糖。将简化代码编写的语法糖还原为原有的形式。</p><p>d.字节码生成。将前面各个步骤所生成的信息转化成为字节码。</p><p>我们知道了上面的理论之后，接下来我们进行实战。带着大家一起去修改AST（抽象树）。添加自己的代码。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="如何自己实现一个自动添加Setter-x2F-Getter的工具"><a href="#如何自己实现一个自动添加Setter-x2F-Getter的工具" class="headerlink" title="如何自己实现一个自动添加Setter&#x2F;Getter的工具"></a>如何自己实现一个自动添加Setter&#x2F;Getter的工具</h4><p>首先，我们创建一个自己的注解。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE) <span class="comment">// 注解只在源码中保留</span></span><br><span class="line"><span class="variable">@Target</span>(ElementType.TYPE) <span class="comment">// 用于修饰类</span></span><br><span class="line">public <span class="variable">@interface</span> MySetterGetter &#123;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>创建一个需要生成setter&#x2F;getter方法的实体类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MySetterGetter</span>  <span class="comment">// 打上我们的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> wzj;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接下来就来看一看如何来生成我们想要的字符串。</p><p>整体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@SupportedAnnotationTypes</span>(<span class="string">&quot;com.study.practice.nameChecker.MySetterGetter&quot;</span>)</span><br><span class="line"><span class="keyword">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line">public class MySetterGetterProcessor extends AbstractProcessor &#123;</span><br><span class="line">    <span class="comment">// 主要是输出信息</span></span><br><span class="line">    private Messager messager;</span><br><span class="line">    private JavacTrees javacTrees;</span><br><span class="line"></span><br><span class="line">    private TreeMaker treeMaker;</span><br><span class="line">    private Names names;</span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super<span class="selector-class">.init</span>(processingEnv);</span><br><span class="line">        this<span class="selector-class">.messager</span> = processingEnv<span class="selector-class">.getMessager</span>();</span><br><span class="line">        this<span class="selector-class">.javacTrees</span> = JavacTrees<span class="selector-class">.instance</span>(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment)processingEnv)<span class="selector-class">.getContext</span>();</span><br><span class="line">        this<span class="selector-class">.treeMaker</span> = TreeMaker<span class="selector-class">.instance</span>(context);</span><br><span class="line">        this<span class="selector-class">.names</span> = Names<span class="selector-class">.instance</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        <span class="comment">// 拿到被注解标注的所有的类</span></span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnv<span class="selector-class">.getElementsAnnotatedWith</span>(MySetterGetter.class);</span><br><span class="line">        elementsAnnotatedWith<span class="selector-class">.forEach</span>(element -&gt; &#123;</span><br><span class="line">            // 得到类的抽象树结构</span><br><span class="line">            JCTree tree = javacTrees.getTree(element);</span><br><span class="line">            <span class="comment">// 遍历类，对类进行修改</span></span><br><span class="line">            tree<span class="selector-class">.accept</span>(new TreeTranslator()&#123;</span><br><span class="line">                <span class="keyword">@Override</span></span><br><span class="line">                public void visitClassDef(JCTree.JCClassDecl jcClassDecl) &#123;</span><br><span class="line">                    List&lt;JCTree<span class="selector-class">.JCVariableDecl</span>&gt; jcVariableDeclList = List<span class="selector-class">.nil</span>();</span><br><span class="line">                    <span class="comment">// 在抽象树中找出所有的变量</span></span><br><span class="line">                    <span class="built_in">for</span>(JCTree jcTree: jcClassDecl.defs)&#123;</span><br><span class="line">                        if (jcTree.getKind()<span class="selector-class">.equals</span>(Tree.Kind.VARIABLE))&#123;</span><br><span class="line">                            JCTree<span class="selector-class">.JCVariableDecl</span> jcVariableDecl = (JCTree.JCVariableDecl)jcTree;</span><br><span class="line">                            jcVariableDeclList = jcVariableDeclList<span class="selector-class">.append</span>(jcVariableDecl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 对于变量进行生成方法的操作</span></span><br><span class="line">                    for (JCTree.JCVariableDecl jcVariableDecl : jcVariableDeclList) &#123;</span><br><span class="line">                        messager<span class="selector-class">.printMessage</span>(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);</span><br><span class="line">                        jcClassDecl<span class="selector-class">.defs</span> = jcClassDecl<span class="selector-class">.defs</span><span class="selector-class">.prepend</span>(makeSetterMethodDecl(jcVariableDecl));</span><br><span class="line"></span><br><span class="line">                        jcClassDecl<span class="selector-class">.defs</span> = jcClassDecl<span class="selector-class">.defs</span><span class="selector-class">.prepend</span>(makeGetterMethodDecl(jcVariableDecl));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成返回对象</span></span><br><span class="line">        JCTree<span class="selector-class">.JCExpression</span> methodType = treeMaker<span class="selector-class">.Type</span>(new Type.JCVoidType());</span><br><span class="line"></span><br><span class="line">        return treeMaker<span class="selector-class">.MethodDef</span>(treeMaker.Modifiers(Flags.PUBLIC), <span class="built_in">getNewSetterMethodName</span>(jcVariableDecl.getName()), methodType, List<span class="selector-class">.nil</span>(), parameters, List<span class="selector-class">.nil</span>(), block, null);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 getter 方法</span></span><br><span class="line"><span class="comment">     * @param jcVariableDecl</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private JCTree<span class="selector-class">.JCMethodDecl</span> <span class="built_in">makeGetterMethodDecl</span>(JCTree.JCVariableDecl jcVariableDecl)&#123;</span><br><span class="line">        ListBuffer&lt;JCTree<span class="selector-class">.JCStatement</span>&gt; statements = new ListBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生成表达式</span></span><br><span class="line">        JCTree<span class="selector-class">.JCReturn</span> aReturn = treeMaker<span class="selector-class">.Return</span>(treeMaker.Ident(jcVariableDecl.getName()));</span><br><span class="line">        statements<span class="selector-class">.append</span>(aReturn);</span><br><span class="line">        JCTree<span class="selector-class">.JCBlock</span> block = treeMaker<span class="selector-class">.Block</span>(<span class="number">0</span>, statements.toList());</span><br><span class="line">        <span class="comment">// 无入参</span></span><br><span class="line">        <span class="comment">// 生成返回对象</span></span><br><span class="line">        JCTree<span class="selector-class">.JCExpression</span> returnType = treeMaker<span class="selector-class">.Type</span>(jcVariableDecl.getType()<span class="selector-class">.type</span>);</span><br><span class="line">        return treeMaker<span class="selector-class">.MethodDef</span>(treeMaker.Modifiers(Flags.PUBLIC), <span class="built_in">getNewGetterMethodName</span>(jcVariableDecl.getName()), returnType, List<span class="selector-class">.nil</span>(), List<span class="selector-class">.nil</span>(), List<span class="selector-class">.nil</span>(), block, null);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼装Setter方法名称字符串</span></span><br><span class="line"><span class="comment">     * @param name</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Name <span class="built_in">getNewSetterMethodName</span>(Name name) &#123;</span><br><span class="line">        String s = name<span class="selector-class">.toString</span>();</span><br><span class="line">        return names<span class="selector-class">.fromString</span>(&quot;set&quot; + s.substring(<span class="number">0</span>,<span class="number">1</span>)<span class="selector-class">.toUpperCase</span>() + s<span class="selector-class">.substring</span>(<span class="number">1</span>, name.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼装 Getter 方法名称的字符串</span></span><br><span class="line"><span class="comment">     * @param name</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Name <span class="built_in">getNewGetterMethodName</span>(Name name) &#123;</span><br><span class="line">        String s = name<span class="selector-class">.toString</span>();</span><br><span class="line">        return names<span class="selector-class">.fromString</span>(&quot;get&quot; + s.substring(<span class="number">0</span>,<span class="number">1</span>)<span class="selector-class">.toUpperCase</span>() + s<span class="selector-class">.substring</span>(<span class="number">1</span>, name.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成表达式</span></span><br><span class="line"><span class="comment">     * @param lhs</span></span><br><span class="line"><span class="comment">     * @param rhs</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private JCTree<span class="selector-class">.JCExpressionStatement</span> <span class="built_in">makeAssignment</span>(JCTree.JCExpression lhs, JCTree.JCExpression rhs) &#123;</span><br><span class="line">        return treeMaker<span class="selector-class">.Exec</span>(</span><br><span class="line">                treeMaker.Assign(lhs, rhs)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码有点多，我们逐一拆解说明：</p><p>下面这是整个代码结构的脑图，后面的讲解会基于这个顺序。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebcfef28fc894028b21995cb53cea4f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>a. 注解</p><p>@SupportedAnnotationTypes 表示我们需要监听的注解，比如我们之前定义的 @MySetterGetter。</p><p>@SupportedSourceVersion 表示我们想要对什么版本的Java源代码进行处理。</p><p>b. 父类</p><p>AbstractProcessor是本次的核心类，编译器在编译的时候会扫描此类的子类。其中有一个子类必须实现的核心方法 public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)，此方法如果是返回为true就说明编译的那个类抽象树的结构又变化，需要重新进行词法分析和语法分析（可以查看上面提到的那个编译流程图）。如果返回的是false就说明没有变化。</p><p>c. process方法</p><p>主要的操作逻辑是：</p><p>1、拿到所有被我们MySetterGetter标注的类。</p><p>2、遍历所有的类，生成类的抽象树结构。</p><p>3、对类进行操作：</p><p>a.找到类中所有的变量。</p><p>b.对变量进行生成Set和Get方法。</p><p>4、返回 true，说明类结构变了，需要重新解析。如果是false说明没有变，不用重新解析。</p><p>d. 操作JCTree树</p><p>主要是在操作抽象树，可以查看文末附件中的文章进行学习。</p><p>e. 方法名称拼接</p><p>这一块儿和字符串拼接没啥区别，用过反射的同学应该也都清楚这个操作了。</p><p>到此为止，我们就已经介绍完了Lombok的原理。怎么样是不是很简单。接下来，就让我们把它运行起来，投入到实战之中。</p><p>f. 运行</p><p>最后来看一下如何正确的运行这个我们写的工具。</p><p>1.环境</p><p>我的系统环境是 macOs Monterey；</p><p>java版本是</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;<span class="number">1.8</span><span class="selector-class">.0_302</span>&quot;</span><br><span class="line">OpenJDK Runtime Environment (Temurin)(build <span class="number">1.8</span>.<span class="number">0</span>_302-b08)</span><br><span class="line">OpenJDK <span class="number">64</span>-Bit Server VM (Temurin)(build <span class="number">25.302</span>-b08, mixed mode)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2.编译processor</p><p>在你存放 MySetterGetter 和 MySetterGetterProcessor 两个类的目录下进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -<span class="built_in">cp</span> <span class="variable">$JAVA_HOME</span>/lib/tools.jar MySetterGetter.java MySetterGetterProcessor.java</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行成功后会出现这三个class文件。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/828a95350a7a45399b067d62df7e8b7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>3.声明插入式注解处理器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/922d03e7e18f45aa92e80ee659203e49~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><ul><li>在你的工程的resources下面创建一个包，名称为：META-INFO.services</li><li>然后创建一个文件，名称为：javax.annotation.processing.Processor</li><li>将你的注解处理器的地址填入，我的配置是这样的：</li></ul><p>com.study.practice.nameChecker.MySetterGetterProcessor</p><p>4.用我们的工具去编译目标类</p><p>比如我们本次是要编译那个test.java。</p><p>它的内容再回顾一下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MySetterGetter</span>  <span class="comment">// 打上我们的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> wzj;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后我们就去编译它（注意类前面的路径。这个你们得换成自己的工程目录。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -processor com.study.practice.nameChecker.MySetterGetterProcessor com/study/practice/nameChecker/Test.java</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行之后如果没有修改我的代码的话会打印这几个字符串：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process <span class="number">1</span></span><br><span class="line">process <span class="number">2</span></span><br><span class="line">注: wzj has been processed</span><br><span class="line">process <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最后会生成Test.class文件。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4518747116a34143ab5a67dda3efe2cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>5.成果</p><p>最后的class文件解析出来就是这个样子的。如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6ff077d8d2420c844b5622fb28255c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>看到Setter&#x2F;Getter方法就说明我们已经大功告成了！是不是很简单。</p><p>到此为止，我们就学会了如何自己写一个属于自己的简易Lombok的插件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者 | 王再军(曦峰)&lt;br&gt; 来源 | 阿里开发者公众号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://link.juejin.cn/?target=https://click.aliyun.com/m/</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如果要存 IP 地址，用什么数据类型比较好</title>
    <link href="http://ai.mak.cn/2022/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AD%98%20IP%20%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%A5%BD/"/>
    <id>http://ai.mak.cn/2022/08/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AD%98%20IP%20%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%A5%BD/</id>
    <published>2022-08-05T16:00:00.000Z</published>
    <updated>2023-01-14T15:18:31.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如果要存-IP-地址，用什么数据类型比较好？"><a href="#如果要存-IP-地址，用什么数据类型比较好？" class="headerlink" title="如果要存 IP 地址，用什么数据类型比较好？"></a>如果要存 IP 地址，用什么数据类型比较好？</h1><p>高性能MySQL第3版（4.1.7节）时，作者建议<strong>当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP地址，而不是使用字符串。</strong> 但是没有给出具体原因。为了搞清楚这个原因，查了一些资料，记录下来。</p><p>相对字符串存储，使用无符号整数来存储有如下的好处：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间</li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>通常，在保存IPv4地址时，一个IPv4最小需要7个字符，最大需要15个字符，所以，使用<code>VARCHAR(15)</code>即可。MySQL在保存变长的字符串时，还需要额外的一个字节来保存此字符串的长度。而如果使用无符号整数来存储，只需要4个字节即可。</p><p>另外还可以使用4个字段分别存储IPv4中的各部分，但是通常这不管是存储空间和查询效率应该都不是很高（可能有的场景适合使用这种方式存储）。</p><p>使用字符串和无符号整数来存储IP的具体性能分析及benchmark，可以看这篇文章。</p><blockquote><p><a href="https://bafford.com/2009/03/09/mysql-performance-benefits-of-storing-integer-ip-addresses/">https://bafford.com/2009/03/09/mysql-performance-benefits-of-storing-integer-ip-addresses/</a></p></blockquote><p>使用无符号整数来存储也有缺点：</p><ul><li>不便于阅读</li><li>需要手动转换</li></ul><p>对于转换来说，MySQL提供了相应的函数来把字符串格式的IP转换成整数<code>INET_ATON</code>，以及把整数格式的IP转换成字符串的<code>INET_NTOA</code>。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select inet_aton(&#x27;192.168.0.1&#x27;);</span><br><span class="line">+--------------------------+</span><br><span class="line">| inet_aton(&#x27;192.168.0.1&#x27;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">|               3232235521 |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select inet_ntoa(3232235521);</span><br><span class="line">+-----------------------+</span><br><span class="line">| inet_ntoa(3232235521) |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 192.168.0.1           |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于IPv6来说，使用<code>VARBINARY</code>同样可获得相同的好处，同时MySQL也提供了相应的转换函数，即<code>INET6_ATON</code>和<code>INET6_NTOA</code>。</p><p>对于转换字符串IPv4和数值类型，可以放在应用层，下面是使用java代码来对二者转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mikan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mikan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpLongUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把字符串IP转换成long</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipStr 字符串IP</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> IP对应的long值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ip2Long</span><span class="params">(String ipStr)</span> &#123;</span><br><span class="line">        String[] ip = ipStr.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Long.valueOf(ip[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>) + (Long.valueOf(ip[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                + (Long.valueOf(ip[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + Long.valueOf(ip[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把IP的long值转换成字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipLong IP的long值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long值对应的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">long2Ip</span><span class="params">(<span class="type">long</span> ipLong)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        ip.append(ipLong &gt;&gt;&gt; <span class="number">24</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        ip.append((ipLong &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        ip.append((ipLong &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        ip.append(ipLong &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> ip.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ip2Long(<span class="string">&quot;192.168.0.1&quot;</span>));</span><br><span class="line">        System.out.println(long2Ip(<span class="number">3232235521L</span>));</span><br><span class="line">        System.out.println(ip2Long(<span class="string">&quot;10.0.0.1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3232235521</span><br><span class="line">192.168.0.1</span><br><span class="line">167772161</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如果要存-IP-地址，用什么数据类型比较好？&quot;&gt;&lt;a href=&quot;#如果要存-IP-地址，用什么数据类型比较好？&quot; class=&quot;headerlink&quot; title=&quot;如果要存 IP 地址，用什么数据类型比较好？&quot;&gt;&lt;/a&gt;如果要存 IP 地址，用什么数据类型比较</summary>
      
    
    
    
    <category term="数据库" scheme="http://ai.mak.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="http://ai.mak.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 使用简介</title>
    <link href="http://ai.mak.cn/2022/08/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/arthas%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://ai.mak.cn/2022/08/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/arthas%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2023-01-14T14:22:18.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas 是Alibaba开源的Java诊断工具，动态跟踪Java代码；实时监控JVM状态，可以在不中断程序执行的情况下轻松完成JVM相关问题排查工作 。支持JDK 6+，支持Linux&#x2F;Mac&#x2F;Windows。这个工具真的很好用，而且入门超简单，十分推荐。</p><blockquote><p>基于 Spring Boot + MyBatis Plus + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p><ul><li>项目地址：<a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro">https://gitee.com/zhijiantianya/ruoyi-vue-pro</a></li><li>视频教程：<a href="https://doc.iocoder.cn/video/">https://doc.iocoder.cn/video/</a></li></ul></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li></ol><p>接下来，围绕这6个问题，学习下Arthas的基本用法。</p><blockquote><p>基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p><ul><li>项目地址：<a href="https://gitee.com/zhijiantianya/yudao-cloud">https://gitee.com/zhijiantianya/yudao-cloud</a></li><li>视频教程：<a href="https://doc.iocoder.cn/video/">https://doc.iocoder.cn/video/</a></li></ul></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行下面命令下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure><p>用java -jar的方式启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br><span class="line"></span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 79952 cn.test.MobileApplication</span><br><span class="line">  [2]: 93872 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure><p>然后输入数字，选择你想要监听的应用，回车即可</p><p>也可点此下载arthas相关jar：<code>http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=com.taobao.arthas&amp;a=arthas-packaging&amp;e=zip&amp;c=bin&amp;v=LATEST</code></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="当前版本v3-1-4"><a href="#当前版本v3-1-4" class="headerlink" title="当前版本v3.1.4"></a>当前版本v3.1.4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[arthas@79952]$ version</span><br><span class="line">3.1.4</span><br></pre></td></tr></table></figure><h4 id="1、stack"><a href="#1、stack" class="headerlink" title="1、stack"></a>1、stack</h4><p>输出当前方法被调用的调用路径</p><p>很多时候我们都知道一个方法被执行，但是有很多地方调用了它，你并不知道是谁调用了它，此时你需要的是 stack 命令。</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[arthas@79952]$ stack com.baomidou.mybatisplus.extension.service.IService getOne</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:202 , method-cnt:209) cost in 10761 ms.</span><br><span class="line">ts=2019-11-13 11:49:13;thread_name=http-nio-8801-exec-6;id=2d;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    @com.baomidou.mybatisplus.extension.service.impl.ServiceImpl.getOne()</span><br><span class="line">        at com.baomidou.mybatisplus.extension.service.IService.getOne(IService.java:230)</span><br><span class="line">        ...... ......</span><br><span class="line">        at cn.test.mobile.controller.order.OrderController.getOrderInfo(OrderController.java:500)</span><br></pre></td></tr></table></figure><p>可以看到OrderController.java的第500行调用了这个getOne接口。</p><p><em>注意这个命令需要调用后才会触发日志，相似的还有watch、trace等</em></p><h4 id="2、jad"><a href="#2、jad" class="headerlink" title="2、jad"></a>2、jad</h4><p>反编译指定已加载类的源码</p><p>有时候，版本发布后，代码竟然没有执行，代码是最新的吗，这时可以使用jad反编译相应的class。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad cn.test.mobile.controller.order.OrderController</span><br></pre></td></tr></table></figure><p>仅编译指定的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jad cn.test.mobile.controller.order.OrderController getOrderInfo</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">@RequestMapping(value=&#123;&quot;getOrderInfo&quot;&#125;, method=&#123;RequestMethod.POST&#125;)</span><br><span class="line">public Object getOrderInfo(HttpServletRequest request, @RequestBody Map map) &#123;</span><br><span class="line">    ResponseVo responseVo = new ResponseVo();</span><br><span class="line">    ... ... ...  ...</span><br></pre></td></tr></table></figure><h4 id="3、sc"><a href="#3、sc" class="headerlink" title="3、sc"></a>3、sc</h4><p>“Search-Class” 的简写 ，查看JVM已加载的类信息 有的时候，你只记得类的部分关键词，你可以用sc获取完整名称 当你碰到这个错的时候“ClassNotFoundException”或者“ClassDefNotFoundException”，你可以用这个命令验证下</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left">[d]</td><td align="left">输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。如果一个类被多个ClassLoader所加载，则会出现多次</td></tr></tbody></table><p>模糊搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc *OrderController*</span><br><span class="line">cn.test.mobile.controller.order.OrderController</span><br></pre></td></tr></table></figure><p>打印类的详细信息 sc -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sc -d cn.test.mobile.controller.order.OrderController</span><br><span class="line"></span><br><span class="line"> class-info        cn.test.mobile.controller.order.OrderController</span><br><span class="line"> code-source       /F:/IDEA-WORKSPACE-TEST-qyb/trunk/BE/mobile/target/classes/</span><br><span class="line"> name              cn.test.mobile.controller.order.OrderController</span><br><span class="line"> isInterface       false</span><br><span class="line"> isAnnotation      false</span><br><span class="line"> isEnum            false</span><br><span class="line"> isAnonymousClass  false</span><br><span class="line"> isArray           false</span><br><span class="line"> isLocalClass      false</span><br><span class="line"> isMemberClass     false</span><br><span class="line"> isPrimitive       false</span><br><span class="line"> isSynthetic       false</span><br><span class="line"> simple-name       OrderController</span><br><span class="line"> modifier          public</span><br><span class="line"> annotation        org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.Requ</span><br><span class="line">                   estMapping</span><br><span class="line"> interfaces</span><br><span class="line"> super-class       +-cn.test.mobile.controller.BaseController</span><br><span class="line">                     +-java.lang.Object</span><br><span class="line"> class-loader      +-sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">                     +-sun.misc.Launcher$ExtClassLoader@480bdb19</span><br><span class="line"> classLoaderHash   18b4aac2</span><br></pre></td></tr></table></figure><h4 id="与之相应的还有sm-“Search-Method”-，查看已加载类的方法信息"><a href="#与之相应的还有sm-“Search-Method”-，查看已加载类的方法信息" class="headerlink" title="与之相应的还有sm( “Search-Method” )，查看已加载类的方法信息"></a>与之相应的还有sm( “Search-Method” )，查看已加载类的方法信息</h4><p>查看String里的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sm java.lang.String</span><br><span class="line">java.lang.String &lt;init&gt;([BII)V</span><br><span class="line">java.lang.String &lt;init&gt;([BLjava/nio/charset/Charset;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BLjava/lang/String;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BIILjava/nio/charset/Charset;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BIILjava/lang/String;)V</span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure><p>查看String中toString的详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.lang.String toString</span><br><span class="line">declaring-class  java.lang.String</span><br><span class="line"> method-name      toString</span><br><span class="line"> modifier         public</span><br><span class="line"> annotation</span><br><span class="line"> parameters</span><br><span class="line"> return           java.lang.String</span><br><span class="line"> exceptions</span><br><span class="line"> classLoaderHash  null</span><br></pre></td></tr></table></figure><h4 id="4、watch"><a href="#4、watch" class="headerlink" title="4、watch"></a>4、watch</h4><p>可以监测一个方法的入参和返回值</p><p>有些问题线上会出现，本地重现不了，这时这个命令就有用了</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left"><em>express</em></td><td align="left">观察表达式</td></tr><tr><td align="left"><em>condition-express</em></td><td align="left">条件表达式</td></tr><tr><td align="left">[b]</td><td align="left">在<strong>「方法调用之前」</strong> 观察</td></tr><tr><td align="left">[e]</td><td align="left">在<strong>「方法异常之后」</strong> 观察</td></tr><tr><td align="left">[s]</td><td align="left">在<strong>「方法返回之后」</strong> 观察</td></tr><tr><td align="left">[f]</td><td align="left">在<strong>「方法结束之后」</strong> (正常返回和异常返回)观察，<strong>「默认选项」</strong></td></tr><tr><td align="left">[E]</td><td align="left">开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td align="left">[x:]</td><td align="left">指定输出结果的属性遍历深度，默认为 1</td></tr></tbody></table><p>观察getOrderInfo的出参和返回值，出参就是方法结束后的入参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">watch cn.test.mobile.controller.order.OrderController getOrderInfo &quot;&#123;params,returnObj&#125;&quot; -x 2</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 456 ms.</span><br><span class="line">ts=2019-11-13 15:30:18; [cost=18.48307ms] result=@ArrayList[</span><br><span class="line">    @Object[][  # 这个就是出参，params</span><br><span class="line">        @RequestFacade[org.apache.catalina.connector.RequestFacade@1d81dbd7],</span><br><span class="line">        @LinkedHashMap[isEmpty=false;size=2], # 把遍历深度x改为3就可以查看map里的值了</span><br><span class="line">    ],</span><br><span class="line">    @ResponseVo[ # 这个就是返回值 returnObj</span><br><span class="line">        log=@Logger[Logger[cn.test.db.common.vo.ResponseVo]],</span><br><span class="line">        success=@Boolean[true],</span><br><span class="line">        message=@String[Ok],</span><br><span class="line">        count=@Integer[0],</span><br><span class="line">        code=@Integer[1000],</span><br><span class="line">        data=@HashMap[isEmpty=false;size=1],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>观察getOrderInfo的入参和返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch cn.test.mobile.controller.order.OrderController getOrderInfo &quot;&#123;params,returnObj&#125;&quot; -x 3 -b</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 93 ms.</span><br><span class="line">ts=2019-11-13 15:37:38; [cost=0.012479ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @RequestFacade[</span><br><span class="line">            request=@Request[org.apache.catalina.connector.Request@d04e652],</span><br><span class="line">            sm=@StringManager[org.apache.tomcat.util.res.StringManager@7ae7a97b],</span><br><span class="line">        ],</span><br><span class="line">        @LinkedHashMap[</span><br><span class="line">            @String[payNo]:@String[190911173713755288],</span><br><span class="line">            @String[catalogId]:@String[6],</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">    null,# -b是方法调用之前观察，所以还没有返回值</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果需要捕捉异常的话，使用throwExp，如{params,returnObj,throwExp}</p><h4 id="5、trace"><a href="#5、trace" class="headerlink" title="5、trace"></a>5、trace</h4><p>输出方法内部调用路径，和路径上每个节点的耗时</p><p>可以通过这个命令，查看哪些方法耗性能，从而找出导致性能缺陷的代码，这个耗时还包含了arthas执行的时间哦。</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left"><em>condition-express</em></td><td align="left">条件表达式</td></tr><tr><td align="left">[E]</td><td align="left">开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td align="left"><code>[n:]</code></td><td align="left">命令执行次数</td></tr><tr><td align="left"><code>#cost</code></td><td align="left">方法执行耗时</td></tr></tbody></table><p>输出getOrderInfo的调用路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 92 ms.</span><br><span class="line">---ts=2019-11-13 15:46:59;thread_name=http-nio-8801-exec-4;id=2b;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    ---[15.509011ms] cn.test.mobile.controller.order.OrderController:getOrderInfo()</span><br><span class="line">        +---[0.03584ms] cn.test.db.common.vo.ResponseVo:&lt;init&gt;() #472</span><br><span class="line">        +---[0.00992ms] java.util.HashMap:&lt;init&gt;() #473</span><br><span class="line">        +---[0.02176ms] cn.test.mobile.controller.order.OrderController:getUserInfo() #478</span><br><span class="line">        +---[0.024ms] java.util.Map:get() #483</span><br><span class="line">        +---[0.00896ms] java.lang.Object:toString() #483</span><br><span class="line">        +---[0.00864ms] java.lang.Integer:parseInt() #483</span><br><span class="line">        +---[0.019199ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:&lt;init&gt;() #500</span><br><span class="line">        +---[0.135679ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:allEq() #500</span><br><span class="line">        +---[12.476072ms] cn.test.db.service.IOrderMediaService:getOne() #500</span><br><span class="line">        +---[0.0128ms] java.util.HashMap:put() #501</span><br><span class="line">        +---[0.443517ms] cn.test.db.common.vo.ResponseVo:setSuccess() #503</span><br><span class="line">        `---[0.03488ms] java.util.Map:put() #504</span><br></pre></td></tr></table></figure><p>输出getOrderInfo的调用路径，且cost大于10ms，-j是指过滤掉jdk中的方法，可以看到输出少了很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &#x27;#cost &gt; 10&#x27;</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 96 ms.</span><br><span class="line">---ts=2019-11-13 15:53:42;thread_name=http-nio-8801-exec-2;id=29;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    ---[13.803743ms] cn.test.mobile.controller.order.OrderController:getOrderInfo()</span><br><span class="line">        +---[0.01312ms] cn.test.db.common.vo.ResponseVo:&lt;init&gt;() #472</span><br><span class="line">        +---[0.01408ms] cn.test.mobile.controller.order.OrderController:getUserInfo() #478</span><br><span class="line">        +---[0.0128ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:&lt;init&gt;() #500</span><br><span class="line">        +---[0.303998ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:allEq() #500</span><br><span class="line">        +---[12.675431ms] cn.test.db.service.IOrderMediaService:getOne() #500</span><br><span class="line">        `---[0.409917ms] cn.test.db.common.vo.ResponseVo:setSuccess() #503</span><br></pre></td></tr></table></figure><h4 id="6、jobs"><a href="#6、jobs" class="headerlink" title="6、jobs"></a>6、jobs</h4><p>执行后台异步任务</p><p>线上有些问题是偶然发生的，这时就需要使用异步任务，把信息写入文件。</p><p>使用 &amp; 指定命令去后台运行，使用 &gt; 将结果重写到日志文件，以trace为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &gt; test.out &amp;</span><br></pre></td></tr></table></figure><p>jobs——列出所有job</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> jobs</span><br><span class="line">[76]*  </span><br><span class="line">       Running           trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &gt;&gt; test.out &amp;</span><br><span class="line">       execution count : 0</span><br><span class="line">       start time      : Wed Nov 13 16:13:23 CST 2019</span><br><span class="line">       timeout date    : Thu Nov 14 16:13:23 CST 2019</span><br><span class="line">       session         : f4fba846-e90b-4234-959e-e78ad0a5db8c (current)</span><br></pre></td></tr></table></figure><p>job id是76, * 表示此job是当前session创建，状态是Running，execution count是执行次数，timeout date是超时时间</p><p>异步执行时间，默认为1天，如果要修改，使用options命令,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options job-timeout 2d</span><br></pre></td></tr></table></figure><p>options可选参数 1d, 2h, 3m, 25s，分别代表天、小时、分、秒</p><p>kill——强制终止任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill 76</span><br><span class="line">kill job 76 success</span><br></pre></td></tr></table></figure><p>最多同时支持8个命令使用重定向将结果写日志</p><p>请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响</p><h4 id="7、logger"><a href="#7、logger" class="headerlink" title="7、logger"></a>7、logger</h4><p>查看logger信息，更新logger level</p><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logger</span><br><span class="line"> name                ROOT</span><br><span class="line"> class               ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader         sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"> classLoaderHash     18b4aac2 #改日志级别时要用到它</span><br><span class="line"> level               INFO</span><br><span class="line"> effectiveLevel      INFO</span><br><span class="line"> ... ... ... ...</span><br></pre></td></tr></table></figure><p>更新日志级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><p>如果执行这个命令时出错：update logger level fail.</p><p>指定classLoaderHash重试一下试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger -c 18b4aac2 --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><h4 id="8、dashboard"><a href="#8、dashboard" class="headerlink" title="8、dashboard"></a>8、dashboard</h4><p>查看当前系统的实时数据面板 这个命令可以全局的查看jvm运行状态，比如内存和cpu占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br><span class="line">ID        NAME                          GROUP               PRIORITY STATE     %CPU      TIME      INTERRUPT DAEMON</span><br><span class="line">17        Abandoned connection cleanup  main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">1009      AsyncAppender-Worker-arthas-c system              5        WAITING   0         0:0       false     true</span><br><span class="line">5         Attach Listener               system              5        RUNNABLE  0         0:0       false     true</span><br><span class="line">23        ContainerBackgroundProcessor[ main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">55        DestroyJavaVM                 main                5        RUNNABLE  0         0:11      false     false</span><br><span class="line">3         Finalizer                     system              8        WAITING   0         0:0       false     true</span><br><span class="line">18        HikariPool-1 housekeeper      main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">39        NioBlockingSelector.BlockPoll main                5        RUNNABLE  0         0:0       false     true</span><br><span class="line">2         Reference Handler             system              10       WAITING   0         0:0       false     true</span><br><span class="line">4         Signal Dispatcher             system              9        RUNNABLE  0         0:0       false     true</span><br><span class="line">69        System Clock                  main                5        TIMED_WAI 0         0:34      false     true</span><br><span class="line">25        Thread-2                      main                5        TIMED_WAI 0         0:0       false     false</span><br><span class="line">37        Timer-0                       main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">Memory                    used    total    max     usage    GC</span><br><span class="line">heap                      216M    415M     3614M   5.99%    gc.ps_scavenge.count          96</span><br><span class="line">ps_eden_space             36M     78M      1276M   2.90%    gc.ps_scavenge.time(ms)       3054</span><br><span class="line">ps_survivor_space         17M     38M      38M     46.53%   gc.ps_marksweep.count         4</span><br><span class="line">ps_old_gen                161M    298M     2711M   5.97%    gc.ps_marksweep.time(ms)      804</span><br><span class="line">nonheap                   175M    180M     -1      97.09%</span><br><span class="line">code_cache                35M     35M      240M    14.85%</span><br></pre></td></tr></table></figure><p>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应 我们可以通过 thread id 查看线程的堆栈 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread 2</span><br><span class="line">&quot;Reference Handler&quot; Id=2 WAITING on java.lang.ref.Reference$Lock@66ad4272</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    -  waiting on java.lang.ref.Reference$Lock@66ad4272</span><br><span class="line">    at java.lang.Object.wait(Object.java:502)</span><br><span class="line">    at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br></pre></td></tr></table></figure><p>NAME: 线程名</p><p>GROUP: 线程组名</p><p>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</p><p>STATE: 线程的状态</p><p>CPU%: 线程消耗的cpu占比，采样100ms，将所有线程在这100ms内的cpu使用量求和，再算出每个线程的cpu使用占比。</p><p>TIME: 线程运行总时间，数据格式为分：秒</p><p>INTERRUPTED: 线程当前的中断位状态</p><p>DAEMON: 是否是daemon线程</p><h4 id="9、redefine"><a href="#9、redefine" class="headerlink" title="9、redefine"></a>9、redefine</h4><p>redefine jvm已加载的类 ，可以在不重启项目的情况下，热更新类。</p><p>这个功能真的很强大，但是命令不一定会成功</p><p>下面我们来模拟：假设我想修改OrderController里的某几行代码，然后热更新至jvm：</p><p>a. 反编译OrderController，默认情况下，反编译结果里会带有ClassLoader信息，通过–source-only选项，可以只打印源代码。方便和mc&#x2F;redefine命令结合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only cn.test.mobile.controller.order.OrderController &gt; OrderController.java</span><br></pre></td></tr></table></figure><p>生成的OrderController.java在哪呢，执行pwd就知道在哪个目录了</p><p>b. 查找加载OrderController的ClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc -d cn.test.mobile.controller.order.OrderController | grep classLoaderHash</span><br><span class="line">classLoaderHash   18b4aac2</span><br></pre></td></tr></table></figure><p>c. 修改保存好OrderController.java之后，使用mc(Memory Compiler)命令来编译成字节码，并且通过-c参数指定ClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc -c 18b4aac2 OrderController.java -d ./</span><br></pre></td></tr></table></figure><p>d. 热更新刚才修改后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redefine -c 18b4aac2 OrderController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><p>然后代码就更新成功了。</p><p>redefine 我参考了这篇文档<code>https://github.com/alibaba/arthas/issues/537</code>。</p><p>更多高级的功能请移步Arthas官网文档<code>https://alibaba.github.io/arthas/quick-start.html</code>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果java -jar选择启动某个应用的时候，报下面的错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: 3.1.4</span><br><span class="line">[INFO] Process 11544 already using port 3658</span><br><span class="line">[INFO] Process 11544 already using port 8563</span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 11544</span><br><span class="line">  [2]: 119504 cn.test.MobileApplication</span><br><span class="line">  [3]: 136340 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">  [4]: 3068</span><br><span class="line">2 #选择第2个启动</span><br><span class="line">[ERROR] Target process 119504 is not the process using port 3658, you will connect to an unexpected process.</span><br><span class="line">[ERROR] 1. Try to restart arthas-boot, select process 11544, shutdown it first with running the &#x27;shutdown&#x27; command.</span><br><span class="line">[ERROR] 2. Or try to use different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1</span><br></pre></td></tr></table></figure><p>注意提示<code>[ERROR] 1</code>，只需要进入11544这个应用，然后执行shutdown关闭这个应用就可以启动了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas 是Alibaba开源的Java诊断工具，动态跟踪Java代码；实时监控JVM状态，可以在不中断程序执行的情况下轻松完成JVM相</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统知识点总结</title>
    <link href="http://ai.mak.cn/2022/07/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/07/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-28T16:00:00.000Z</published>
    <updated>2023-01-14T15:49:42.015Z</updated>
    
    <content type="html"><![CDATA[<p>分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？</p><h2 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1.架构设计"></a>1.架构设计</h2><p>这一节将从一些经典的开源系统架构设计出发，来看一下，如何设计一个高质量的分布式系统；</p><p>而一般的设计出发点，无外乎</p><ul><li>冗余：简单理解为找个备胎，现任挂掉之后，备胎顶上</li><li>拆分：不能让一个人承担所有的重任，拆分下，每个人负担一部分，压力均摊</li></ul><h3 id="1-1-主备架构"><a href="#1-1-主备架构" class="headerlink" title="1.1 主备架构"></a>1.1 主备架构</h3><p>给现有的服务搭建一个备用的服务，两者功能完全一致，区别在于平时只有主应用对外提供服务能力；而备应用则只需要保证与主应用能力一致，随时待机即可，并不用对外提供服务；当主应用出现故障之后，将备应用切换为主应用，原主应用下线；迅速的主备切换可以有效的缩短故障时间</p><p>基于上面的描述，主备架构特点比较清晰</p><ul><li>采用冗余的方案，加一台备用服务</li><li>缺点就是资源浪费</li></ul><p>其次就是这个架构模型最需要考虑的则是如何实现主备切换？</p><ul><li>人工</li><li>VIP(虚拟ip) + keepalived 机制</li></ul><h3 id="1-2-主从架构"><a href="#1-2-主从架构" class="headerlink" title="1.2 主从架构"></a>1.2 主从架构</h3><p>主从一般又叫做读写分离，主提供读写能力，而从则只提供读能力</p><p>鉴于当下的互联网应用，绝大多数都是读多写少的场景；读更容易成为性能瓶颈，所以采用读写分离，可以有效的提高整个集群的响应能力</p><p>主从架构可以区分为：一主多从 + 一主一从再多从，以mysql的主从架构模型为例进行说明</p><p><img src="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/imgs/220708/mysql03.jpg" alt="MySql主从"></p><p>主从模式的主要特点在于</p><ul><li>添加从，源头依然是数据冗余的思想</li><li>读写分离：主负责读写，从只负责读，可以视为负载均衡策略</li><li>从需要向主同步数据，所若有的从都同步与主，对主的压力依然可能很大；所以就有了主从从的模式</li></ul><p>关键问题则在于</p><ul><li>主从延迟</li><li>主的写瓶颈</li><li>主挂之后如何选主</li></ul><h3 id="1-3-多主多从架构"><a href="#1-3-多主多从架构" class="headerlink" title="1.3 多主多从架构"></a>1.3 多主多从架构</h3><p>一主多从面临单主节点的瓶颈问题，那就考虑多主多从的策略，同样是主负责提供读写，从提供读；</p><p>但是这里有一个核心点在于多主之间的数据同步，如何保证数据的一致性是这个架构模型的重点</p><p>如MySql的双主双从可以说是一个典型的应用场景，在实际使用的时候除了上面的一致性之外，还需要考虑主键id冲突的问题</p><h3 id="1-4-普通集群模式"><a href="#1-4-普通集群模式" class="headerlink" title="1.4 普通集群模式"></a>1.4 普通集群模式</h3><p>无主节点，集群中所有的应用职能对等，没有主次之分（当下绝大多数的业务服务都属于这种），一个请求可以被集群中任意一个服务响应；</p><p>这种也可以叫做去中心化的设计模式，如redis的集群模式，eureka注册中心，以可用性为首要目标</p><p>对于普通集群模式而言，重点需要考虑的点在于</p><ul><li>资源竞争：如何确保一个资源在同一时刻只能被一个业务操作<ul><li>如现在同时来了申请退款和货物出库的请求，如果不对这个订单进行加锁，两个请求同时响应，将会导致发货又退款了，导致财货两失</li></ul></li><li>数据一致性：如何确保所有的实例数据都是一致的，或者最终是一致的<ul><li>如应用服务使用jvm缓存，那么如何确保所有实例的jvm缓存一致？</li><li>如Eureka的分区导致不同的分区的注册信息表不一致</li></ul></li></ul><h3 id="1-5-数据分片架构"><a href="#1-5-数据分片架构" class="headerlink" title="1.5 数据分片架构"></a>1.5 数据分片架构</h3><blockquote><p>这个分片模型的描述可能并不准确，大家看的时候重点理解一下这个思想</p></blockquote><p>前面几个的架构中，采用的是数据冗余的方式，即所有的实例都有一个全量的数据，而这里的数据分片，则从数据拆分的思路来处理，将全量的数据，通过一定规则拆分到多个系统中，每个系统包含部分的数据，减小单个节点的压力，主要用于解决数据量大的场景</p><p>比如redis的集群方式，通过hash槽的方式进行分区</p><p>如es的索引分片存储</p><h3 id="1-6-一灰灰的小结"><a href="#1-6-一灰灰的小结" class="headerlink" title="1.6 一灰灰的小结"></a>1.6 一灰灰的小结</h3><p>这一节主要从架构设计层面对当前的分布式系统所采用的方案进行了一个简单的归类与小结，并不一定全面，欢迎各位大佬留言指正</p><p>基于冗余的思想：</p><ul><li>主备</li><li>主从</li><li>多主多从</li><li>无中心集群</li></ul><p>基于拆分的思想：</p><ul><li>数据分片</li></ul><blockquote><p>对于拆分这一块，我们常说的分库分表也体现的是这一思想</p></blockquote><h2 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2.理论基础"></a>2.理论基础</h2><p>这一小节将介绍分布式系统中的经典理论，如广为流程的CAP&#x2F;BASE理论，一致性理论基础paxios,raft，信息交换的Gossip协议，两阶段、三阶段等</p><p>本节主要内容参考自</p><ul><li><a href="https://link.juejin.cn/?target=https://cloud.tencent.com/developer/article/1662426">一致性算法-Gossip协议详解 - 腾讯云开发者社区-腾讯云</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议 - 知乎</a></li><li><a href="https://link.juejin.cn/?target=https://blog.51cto.com/u_15060467/2678779">从Paxos到Raft，分布式一致性算法解析_mb5fdb0a87e2fa1的技术博客_51CTO博客</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/338628717">【理论篇】浅析分布式中的 CAP、BASE、2PC、3PC、Paxos、Raft、ZAB - 知乎</a></li></ul><h3 id="2-1-CAP定理"><a href="#2-1-CAP定理" class="headerlink" title="2.1 CAP定理"></a>2.1 CAP定理</h3><p>CAP 定理指出，分布式系统 <strong>不可能</strong> 同时提供下面三个要求：</p><ul><li>Consistency：一致性<ul><li>操作更新完成并返回客户端之后，所有节点数据完全一致</li></ul></li><li>Availability：可用性<ul><li>服务一直可用</li></ul></li><li>Partition tolerance：分区容错性<ul><li>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足<strong>一致性</strong>和<strong>可用性</strong>的服务</li></ul></li></ul><p>通常来讲P很难不保证，当服务部署到多台实例上时，节点异常、网络故障属于常态，根据不同业务场景进行选择</p><p>对于服务有限的应用而言，首选AP，保证高可用，即使部分机器异常，也不会导致整个服务不可用；如绝大多数的前台应用都是这种</p><p>对于数据一致性要求高的场景，如涉及到钱的支付结算，CP可能更重要了</p><p>对于CAP的三种组合说明如下</p><table><thead><tr><th>选择</th><th>说明</th></tr></thead><tbody><tr><td>CA</td><td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机场景</td></tr><tr><td>AP</td><td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td></tr><tr><td>CP</td><td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td></tr></tbody></table><h3 id="2-2-BASE理论"><a href="#2-2-BASE理论" class="headerlink" title="2.2 BASE理论"></a>2.2 BASE理论</h3><p>base理论作为cap的延伸，其核心特点在于放弃强一致性，追求最终一致性</p><ul><li>Basically Available: 基本可用<ul><li>指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用</li><li>如大促时降级策略</li></ul></li><li>Soft State：软状态<ul><li>允许系统存在中间状态，而该中间状态不会影响系统整体可用性</li><li>MySql异步方式的主从同步，可能导致的主从数据不一致</li></ul></li><li>Eventual Consistency：最终一致性<ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</li></ul></li></ul><p>基于上面的描述，可以看到BASE理论适用于大型高可用可扩展的分布式系统</p><p>注意其不同于ACID的强一致性模型，而是通过牺牲强一致性 来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</p><h3 id="2-3-PACELEC-定理"><a href="#2-3-PACELEC-定理" class="headerlink" title="2.3 PACELEC 定理"></a>2.3 PACELEC 定理</h3><blockquote><p>这个真没听说过，以下内容来自:</p><ul><li><a href="https://link.juejin.cn/?target=https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc">Distributed System Design Patterns | by Nishant | Medium</a></li></ul></blockquote><ul><li>如果有一个分区（’P’），分布式系统可以在可用性和一致性（即’A’和’C’）之间进行权衡;</li><li>否则（’E’），当系统在没有分区的情况下正常运行时，系统可以在延迟（’L’）和一致性（’C’）之间进行权衡。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16517061349545d088a9d0ce85307a4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。</p><h3 id="2-4-Paxos共识算法"><a href="#2-4-Paxos共识算法" class="headerlink" title="2.4 Paxos共识算法"></a>2.4 Paxos共识算法</h3><blockquote><p>Paxos算法解决的问题是分布式共识性问题，即一个分布式系统中的各个进程如何就某个值（决议）通过共识达成一致</p></blockquote><p>基于上面这个描述，可以看出它非常适用于选举；其工作流程</p><ul><li>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，</li><li>Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。 系统中的多数派同时认可该提案，即达成了一致</li></ul><p>角色划分:</p><ul><li>Proposer: 提出提案Proposal，包含编号 + value</li><li>Acceptor: 参与决策，回应Proposers的提案；当一个提案，被半数以上的Acceptor接受，则该提案被批准<ul><li>每个acceptor只能批准一个提案</li></ul></li><li>Learner: 不参与决策，获取最新的提案value</li></ul><h3 id="2-5-Raft算法"><a href="#2-5-Raft算法" class="headerlink" title="2.5 Raft算法"></a>2.5 Raft算法</h3><blockquote><p>推荐有兴趣的小伙伴，查看</p><ul><li><a href="https://link.juejin.cn/?target=http://thesecretlivesofdata.com/raft/">Raft 算法动画演示</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/32052223">Raft算法详解 - 知乎</a></li></ul></blockquote><p>为了解决paxos的复杂性，raft算法提供了一套更易理解的算法基础，其核心流程在于：</p><p>leader接受请求，并转发给follow，当大部分follow响应之后，leader通知所有的follow提交请求、同时自己也提交请求并告诉调用方ok</p><p>角色划分：</p><ul><li>Leader：领导者，接受客户端请求，并向Follower同步请求，当数据同步到大多数节点上后告诉Follower提交日志</li><li>Follow: 接受并持久化Leader同步的数据，在Leader告之日志可以提交之后，提交</li><li>Candidate：Leader选举过程中的临时角色，向其他节点拉选票，得到多数的晋升为leader，选举完成之后不存在这个角色</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7aead55073e4b69a0e30fb6c656a947~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="raft共识流程"></p><h3 id="2-6-ZAB协议"><a href="#2-6-ZAB协议" class="headerlink" title="2.6 ZAB协议"></a>2.6 ZAB协议</h3><blockquote><p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议，基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p><ul><li><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000037550497">zookeeper核心之ZAB协议就这么简单！</a></li></ul></blockquote><p>主要用于zk的数据一致性场景，其核心思想是Leader再接受到事务请求之后，通过给Follower，当半数以上的Follower返回ACK之后，Leader提交提案，并向Follower发送commit信息</p><p><strong>角色划分</strong></p><ul><li>Leader: 负责整个Zookeeper 集群工作机制中的核心<ul><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务器的调度者</li></ul></li><li>Follower：Leader的追随者<ul><li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li><li>参与事务请求 Proposal 的投票</li><li>参与 Leader 选举投票</li></ul></li><li>Observer：是 zookeeper 自 3.3.0 开始引入的一个角色，<ul><li>它不参与事务请求 Proposal 的投票，</li><li>也不参与 Leader 选举投票</li><li>只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdfc191d4c0d43df8b05481bb089206c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="ZAB消息广播"></p><h3 id="2-7-2PC协议"><a href="#2-7-2PC协议" class="headerlink" title="2.7 2PC协议"></a>2.7 2PC协议</h3><blockquote><p>two-phase commit protocol，两阶段提交协议，主要是为了解决强一致性，中心化的强一致性协议</p></blockquote><p><strong>角色划分</strong></p><ul><li>协调节点(coordinator)：中心化</li><li>参与者节点(partcipant)：多个</li></ul><p><strong>执行流程</strong></p><p>协调节点接收请求，然后向参与者节点提交 <code>precommit</code>，当所有的参与者都回复ok之后，协调节点再给所有的参与者节点提交<code>commit</code>，所有的都返回ok之后，才表明这个数据确认提交</p><p>当第一个阶段，有一个参与者失败，则所有的参与者节点都回滚</p><p><img src="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/imgs/220708/2pc00.jpg" alt="2pc流程"></p><p><strong>特点</strong></p><p>优点在于实现简单</p><p>缺点也很明显</p><ul><li>协调节点的单点故障</li><li>第一阶段全部ack正常，第二阶段存在部分参与者节点异常时，可能出现不一致问题</li></ul><h3 id="2-8-3PC协议"><a href="#2-8-3PC协议" class="headerlink" title="2.8 3PC协议"></a>2.8 3PC协议</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000012534071">分布式事务：两阶段提交与三阶段提交 - SegmentFault 思否</a></p></blockquote><p>在两阶段的基础上进行扩展，将第一阶段划分两部，cancommit + precommit，第三阶段则为 docommit</p><p><strong>第一阶段 cancommit</strong></p><p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的</p><p><strong>第二阶段 precommit</strong></p><p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，若所有参与者都返回ok，则协调者向参与者提交事务执行(单不提交)通知；否则通知参与者abort回滚</p><p><strong>第三阶段 docommit</strong></p><p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，若所有参与者正常执行，则提交；否则协调者+参与者回滚</p><p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致</p><p><strong>特点</strong></p><ul><li>降低了阻塞与单点故障：<ul><li>参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若等待超时&#x2F;协调者宕机，则自动 abort，降低了阻塞；</li><li>参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若等待超时&#x2F;协调者宕机，则自动 commit 事务，也降低了阻塞；</li></ul></li><li>数据不一致问题依然存在<ul><li>比如第三阶段协调者发出了 abort 请求，然后有些参与者没有收到 abort，那么就会自动 commit，造成数据不一致</li></ul></li></ul><h3 id="2-9-Gossip协议"><a href="#2-9-Gossip协议" class="headerlink" title="2.9 Gossip协议"></a>2.9 Gossip协议</h3><blockquote><p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。Gossip 协议通过上面的特性，可以保证系统能在极端情况下（比如集群中只有一个节点在运行）也能运行</p><ul><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议 - 知乎</a></li></ul></blockquote><p>主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络</p><p><strong>工作流程</strong></p><ul><li>周期性的传播消息，通常周期时间为1s</li><li>被感染的节点，随机选择n个相邻节点，传播消息</li><li>每次传播消息都选择还没有发送过的节点进行传播</li><li>收单消息的节点，不会传播给向它发送消息的节点</li></ul><p><img src="https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/imgs/220708/gossip.gif" alt="Gossip传播示意图"></p><p><strong>特点</strong></p><ul><li>扩展性：允许节点动态增加、减少，新增的节点状态最终会与其他节点一致</li><li>容错：网络中任意一个节点宕机重启都不会影响消息传播</li><li>去中心化：不要求中心节点，所有节点对等，任何一个节点无需知道整个网络状况，只要网络连通，则一个节点的消息最终会散播到整个网络</li><li>一致性收敛：协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN</li><li>简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性</li></ul><p><strong>缺点</strong></p><ul><li>消息延迟：节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟</li><li>消息冗余：节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，导致消息的冗余</li></ul><h3 id="2-10-一灰灰的小结"><a href="#2-10-一灰灰的小结" class="headerlink" title="2.10 一灰灰的小结"></a>2.10 一灰灰的小结</h3><p>本节主要介绍的是分布式系统设计中的一些常见的理论基石，如分布式中如何保障一致性，如何对一个提案达成共识</p><ul><li>BASE，CAP，PACELEC理论：构建稳定的分布式系统应该考虑的方向</li><li>paxos,raft共识算法</li><li>zab一致性协议</li><li>gossip消息同步协议</li></ul><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>这一节将主要介绍下分布式系统中的经典的算法，比如常用于分区的一致性hash算法，适用于一致性的Quorum NWR算法，PBFT拜占庭容错算法，区块链中大量使用的工作量证明PoW算法等</p><h3 id="3-1-一致性hash算法"><a href="#3-1-一致性hash算法" class="headerlink" title="3.1 一致性hash算法"></a>3.1 一致性hash算法</h3><p>一致性hash算法，主要应用于数据分片场景下，有效降低服务的新增、删除对数据复制的影响</p><p>通过对数据项的键进行哈希处理映射其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据分配给hash环中的一个节点</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/477a974c71a541a39b098106d5a865f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="一致性hash算法"></p><p>一致散列的主要优点是增量稳定性; 节点添加删除，对整个集群而言，仅影响其直接邻居，其他节点不受影响。</p><p><strong>注意：</strong></p><ul><li>redis集群实现了一套hash槽机制，其核心思想与一致性hash比较相似</li></ul><h3 id="3-2-Quorum-NWR算法"><a href="#3-2-Quorum-NWR算法" class="headerlink" title="3.2 Quorum NWR算法"></a>3.2 Quorum NWR算法</h3><blockquote><p>用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.aliyun.com/article/53498">分布式系统之Quorum （NRW）算法-阿里云开发者社区</a></li></ul></blockquote><ul><li>N 表示副本数，又叫做复制因子（Replication Factor）。也就是说，N 表示集群中同一份数据有多少个副本</li><li>W，又称写一致性级别（Write Consistency Level），表示成功完成 W 个副本更新写入，才会视为本次写操作成功</li><li>R 又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读 R 个副本, 才会视为本次读操作成功</li></ul><p>Quorum NWR算法要求每个数据拷贝对象 都可以投1票，而每一个操作的执行则需要获取最小的读票数，写票数；通常来讲写票数W一般需要超过N&#x2F;2，即我们通常说的得到半数以上的票才表示数据写入成功</p><p>事实上当W&#x3D;N、R&#x3D;1时，即所谓的WARO(Write All Read One)。就是CAP理论中CP模型的场景</p><h3 id="3-3-PBFT拜占庭算法"><a href="#3-3-PBFT拜占庭算法" class="headerlink" title="3.3 PBFT拜占庭算法"></a>3.3 PBFT拜占庭算法</h3><p>拜占庭算法主要针对的是分布式场景下无响应，或者响应不可信的情况下的容错问题，其核心分三段流程，如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef605d5dfacf449994f0953fd72e572f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="拜占庭算法"></p><p>假设集群节点数为 N，f个故障节点(无响应)和f个问题节点(无响应或错误响应),f+1个正常节点，即 3f+1&#x3D;n</p><ul><li>客户端向主节点发起请求，主节点接受请求之后，向其他节点广播 pre-prepare 消息</li><li>节点接受pre-prepare消息之后，若同意请求，则向其他节点广播 prepare 消息；</li><li>当一个节点接受到2f+1个prepare新消息，则进入commit阶段，并广播commit消息</li><li>当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据</li></ul><p>相比 Raft 算法完全不适应有人作恶的场景，PBFT 算法能容忍 (n 1)&#x2F;3 个恶意节点 (也可以是故障节点)。另外，相比 PoW 算法，PBFT 的优点是不消耗算 力。PBFT 算法是O(n ^ 2) 的消息复杂度的算法，所以以及随着消息数 的增加，网络时延对系统运行的影响也会越大，这些都限制了运行 PBFT 算法的分布式系统 的规模，也决定了 PBFT 算法适用于中小型分布式系统</p><h3 id="3-4-PoW算法"><a href="#3-4-PoW算法" class="headerlink" title="3.4 PoW算法"></a>3.4 PoW算法</h3><p>工作量证明 (Proof Of Work，简称 PoW)，同样应用于分布式下的一致性场景，区别于前面的raft, pbft, paxos采用投票机制达成共识方案，pow采用工作量证明</p><p>客户端需要做一定难度的工作才能得出一个结果，验证方却很容易通过结果来检查出客户端是不是做了相应的工作，通过消耗一定工作浪，增加消息伪造的成本，PoW以区块链中广泛应用而广为人知，下面以区块链来简单说一下PoW的算法应用场景</p><p>以BTC的转账为例，A转n个btc给B，如何保证不会同时将这n个币转给C？</p><ul><li>A转账给B，交易信息记录在一个区块1中</li><li>A转账给C，交易信息被记录在另一个区块2中</li><li>当区块1被矿工成功提交到链上，并被大多数认可（通过校验区块链上的hash值验证是否准确，而这个hash值体现的是矿工的工作量），此时尚未提交的区块2则会被抛弃</li><li>若区块1被提交，区块2也被提交，各自有部分人认可，就会导致分叉，区块链中采用的是优选最长的链作为主链，丢弃分叉的部分（这就属于区块链的知识点了，有兴趣的小伙伴可以扩展下相关知识点，这里就不展开了）</li></ul><p>PoW的算法，主要应用在上面的区块提交验证，通过hash值计算来消耗算力，以此证明矿工确实有付出，得到多数认可的可以达成共识</p><h3 id="3-5-一灰灰的小结"><a href="#3-5-一灰灰的小结" class="headerlink" title="3.5 一灰灰的小结"></a>3.5 一灰灰的小结</h3><p>本节主要介绍了下当前分布式下常见的算法，</p><ul><li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li><li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li><li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li><li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li></ul><h2 id="4-技术思想"><a href="#4-技术思想" class="headerlink" title="4.技术思想"></a>4.技术思想</h2><p>这一节的内容相对前面几个而言，并不太容易进行清晰的分类；主要包含一些高质量的分布式系统的实践中，值得推荐的设计思想、技术细节</p><h3 id="4-1-CQRS"><a href="#4-1-CQRS" class="headerlink" title="4.1 CQRS"></a>4.1 CQRS</h3><blockquote><ul><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/115685384">DDD 中的那些模式 — CQRS - 知乎</a></li><li><a href="https://link.juejin.cn/?target=https://www.infoq.cn/article/wdlpjosudoga34jutys9">详解CQRS架构模式_架构_Kislay Verma_InfoQ精选文章</a></li></ul></blockquote><p>Command Query Responsibility Segregation 即我们通俗理解的读写分离，其核心思想在于将两类不同操作进行分离，在独立的服务中实现</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dbe6ae5668344e6bc108d59cc118ee9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="cqrs"></p><p>用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离了不同的数据存储结构，让开发者按照查询的功能与要求更加自由的选择数据存储引擎</p><h3 id="4-2-复制负载平衡服务"><a href="#4-2-复制负载平衡服务" class="headerlink" title="4.2 复制负载平衡服务"></a>4.2 复制负载平衡服务</h3><blockquote><ul><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/34191846">分布式系统设计:服务模式之复制负载平衡服务 - 知乎</a></li><li><a href="https://link.juejin.cn/?target=https://www.runoob.com/w3cnote/balanced-algorithm.html">负载均衡调度算法大全 | 菜鸟教程</a></li></ul></blockquote><p>复制负载平衡服务(Replication Load Balancing Service, RLBS)，可以简单理解为我们常说的负载均衡，多个相同的服务实例构建一个集群，每个服务都可以响应请求，负载均衡器负责请求的分发到不同的实例上，常见的负载算法</p><table><thead><tr><th>算法</th><th>说明</th><th>特点</th></tr></thead><tbody><tr><td>轮询</td><td>请求按照顺序依次分发给对应的服务器</td><td>优点简单，缺点在于未考虑不同服务器的实际性能情况</td></tr><tr><td>加权轮询</td><td>权重高的被分发更多的请求</td><td>优点：充分利用机器的性能</td></tr><tr><td>最少连接数</td><td>找连接数最少的服务器进行请求分发,若所有服务器相同的连接数，则找第一个选择的</td><td>目的是让优先让空闲的机器响应请求</td></tr><tr><td>少连接数慢启动时间</td><td>刚启动的服务器，在一个时间段内，连接数是有限制且缓慢增加</td><td>避免刚上线导致大量的请求分发过来而超载</td></tr><tr><td>加权最少连接</td><td>平衡服务性能 + 最少连接数</td><td></td></tr><tr><td>基于代理的自适应负载均衡</td><td>载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重</td><td></td></tr><tr><td>源地址哈希法</td><td>获取客户端的IP地址，通过哈希函映射到对应的服务器</td><td>相同的来源请求都转发到相同的服务器上</td></tr><tr><td>随机</td><td>随机算法选择一台服务器</td><td></td></tr><tr><td>固定权重</td><td>最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务</td><td>每个真实服务器的权重需要基于服务器优先级来配置</td></tr><tr><td>加权响应</td><td>服务器响应越小其权重越高，通常是基于心跳来判断机器的快慢</td><td>心跳的响应并不一定非常准确反应服务情况</td></tr></tbody></table><h3 id="4-3-心跳机制"><a href="#4-3-心跳机制" class="headerlink" title="4.3 心跳机制"></a>4.3 心跳机制</h3><p>在分布式环境里中，如何判断一个服务是否存活，当下最常见的方案就是心跳</p><p>比如raft算法中的leader向所有的follow发送心跳，表示自己还健在，避免发生新的选举；</p><p>比如redis的哨兵机制，也是通过ping&#x2F;pong的心跳来判断节点是否下线，是否需要选新的主节点；</p><p>再比如我们日常的业务应用得健康监测，判断服务是否正常</p><h3 id="4-4-租约机制"><a href="#4-4-租约机制" class="headerlink" title="4.4 租约机制"></a>4.4 租约机制</h3><p>租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。</p><p>租约主要是了避免一个资源长久被某个对象持有，一旦对方挂了且不会主动释放的问题；在实际的场景中，有两个典型的应用</p><p><strong>case1 分布式锁</strong></p><p>业务获取的分布式锁一般都有一个有效期，若有效期内没有主动释放，这个锁依然会被释放掉，其他业务也可以抢占到这把锁；因此对于持有锁的业务方而言，若发现在到期前，业务逻辑还没有处理完，则可以续约，让自己继续持有这把锁</p><p>典型的实现方式是redisson的看门狗机制</p><p><strong>case2 raft算法的任期</strong></p><p>在raft算法中，每个leader都有一个任期，任期过后会重新选举，而Leader为了避免重新选举，一般会定时发送心跳到Follower进行续约</p><h3 id="4-5-Leader-amp-Follow"><a href="#4-5-Leader-amp-Follow" class="headerlink" title="4.5 Leader &amp; Follow"></a>4.5 Leader &amp; Follow</h3><p>这个比较好理解，上面很多系统都采用了这种方案，特别是在共识算法中，由领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器</p><p>领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求</p><h3 id="4-6-Fencing"><a href="#4-6-Fencing" class="headerlink" title="4.6 Fencing"></a>4.6 Fencing</h3><p>在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作，如慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者</p><p>Fencint是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读&#x2F;写请求提供服务</p><ul><li>资源屏蔽：系统会阻止以前处于活动状态的领导者访问执行基本任务所需的资源。</li><li>节点屏蔽：系统会阻止以前处于活动状态的领导者访问所有资源。执行此操作的常见方法是关闭节点电源或重置节点。</li></ul><h3 id="4-7-Quorum法定人数"><a href="#4-7-Quorum法定人数" class="headerlink" title="4.7 Quorum法定人数"></a>4.7 Quorum法定人数</h3><p>法定人数，常见于选举、共识算法中，当超过Quorum的节点数确认之后，才表示这个提案通过(数据更新成功)，通常这个法定人数为 &#x3D; 半数节点 + 1</p><h3 id="4-8-High-Water-mark高水位线"><a href="#4-8-High-Water-mark高水位线" class="headerlink" title="4.8 High-Water mark高水位线"></a>4.8 High-Water mark高水位线</h3><p>高水位线，跟踪Leader（领导者）上的最后一个日志条目，且该条目已成功复制到&gt;quorum（法定人数）的Follow（跟谁者），即表示这个日志被整个集群接受</p><p>日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。</p><p>如Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。</p><h3 id="4-9-Phi-累计故障检测"><a href="#4-9-Phi-累计故障检测" class="headerlink" title="4.9 Phi 累计故障检测"></a>4.9 Phi 累计故障检测</h3><p>Phi Accrual Failure Detection,使用历史检测信号信息使阈值自适应</p><p>通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。</p><p>如Cassandra（Facebook开源的分布式NoSql数据库）使用 Phi 应计故障检测器算法来确定群集中节点的状态</p><h3 id="4-10-Write-ahead-Log预写日志"><a href="#4-10-Write-ahead-Log预写日志" class="headerlink" title="4.10 Write-ahead Log预写日志"></a>4.10 Write-ahead Log预写日志</h3><p>预写日志记录是解决操作系统中文件系统不一致的问题的高级解决方案，当我们提交写到操作系统的文件缓存，此时业务会认为已经提交成功；但是在文件缓存与实际写盘之间会有一个时间差，若此时机器宕机，会导致缓存中的数据丢失，从而导致完整性缺失</p><p>为了解决这个问题，如mysql，es等都采用了预写日志的机制来避免这个问题</p><p>MySql：</p><ul><li>事务提交的流程中，先写redolog precommit， 然后写binlog，最后再redolog commit；当redolog记录成功之后，才表示事务执行成功；</li><li>因此当出现上面的宕机恢复时，则会加载redologo，然后重放对应的命令，来恢复未持久化的数据</li></ul><p>ElasticSearch:</p><ul><li>在内存中数据生成段写到操作系统文件缓存前，会先写事务日志，出现异常时，也是从事务日志进行恢复</li></ul><h3 id="4-11-分段日志"><a href="#4-11-分段日志" class="headerlink" title="4.11 分段日志"></a>4.11 分段日志</h3><p>将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。</p><p>单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。</p><p>单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。</p><p>这个其实也非常常见，比如我们实际业务应用配置的log，一般都是按天、固定大小进行拆分，并不会把所有的日志都放在一个日志文件中</p><p>再比如es的分段存储，一个段就是一个小的存储文件</p><h3 id="4-12-checksum校验"><a href="#4-12-checksum校验" class="headerlink" title="4.12 checksum校验"></a>4.12 checksum校验</h3><p>在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。</p><p>计算校验和并将其与数据一起存储。</p><p>要计算校验和，请使用 MD5、SHA-1、SHA-256 或 SHA-512 等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）;此字符串称为校验和。</p><p>当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。</p><p>HDFS和Chubby将每个文件的校验和与数据一起存储。</p><h3 id="4-13-一灰灰的小结"><a href="#4-13-一灰灰的小结" class="headerlink" title="4.13 一灰灰的小结"></a>4.13 一灰灰的小结</h3><p>这一节很多内容来自下面这篇博文，推荐有兴趣的小伙伴查看原文</p><ul><li><a href="https://link.juejin.cn/?target=https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc">Distributed System Design Patterns | by Nishant | Medium</a></li></ul><p>这一节主要简单的介绍了下分布式系统中应用到的一些技术方案，如有对其中某个技术有兴趣的小伙伴可以留言，后续会逐一进行补全</p><h2 id="5-分布式系统解决方案"><a href="#5-分布式系统解决方案" class="headerlink" title="5.分布式系统解决方案"></a>5.分布式系统解决方案</h2><p>最后再介绍一些常见的分布式业务场景及对应的解决方案，比如全局唯一的递增ID-雪花算法，分布式系统的资源抢占-分布式锁，分布式事务-2pc&#x2F;3pc&#x2F;tcc ，分布式缓存等</p><h3 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h3><p>缓存实际上并不是分布式独有的，这里把它加进来，主要是因为实在是应用得太广了，无论是应用服务、基础软件工具还是操作系统，大量都可以见到缓存的身影</p><p>缓存的核心思想在于： 借助更高效的IO方式，来替代代价昂贵的IO方式</p><p>如：</p><ul><li>redis的性能高于mysql</li><li>如内存的读写，远高于磁盘IO，文件IO</li><li>磁盘顺序读写 &gt; 随机读写</li></ul><p>用好缓存可以有效提高应用性能，下面以一个普通的java前台应用为例说明</p><ul><li>JVM缓存 -&gt; 分布式缓存(redis&#x2F;memcache) -&gt; mysql缓存 -&gt; 操作系统文件缓存 -&gt; 磁盘文件</li></ul><p>缓存面临的核心问题，则在于</p><ul><li>一致性问题：缓存与db的一致性如何保障（相信大家都听说过或者实际处理过这种问题）</li><li>数据完整性：比如常见的先写缓存，异步刷新到磁盘，那么缓存到磁盘刷新这段时间内，若宕机导致数据丢失怎么办？<ul><li>TIP: 上面这个问题可以参考mysql的redolog</li></ul></li></ul><h3 id="5-2-全局唯一ID"><a href="#5-2-全局唯一ID" class="headerlink" title="5.2 全局唯一ID"></a>5.2 全局唯一ID</h3><p>在传统的单体架构中，业务id基本上是依赖于数据库的自增id来处理；当我们进入分布式场景时，如我们常说的分库分表时，就需要我们来考虑如何实现全局唯一的业务id了，避免出现在分表中出现冲突</p><p>全局唯一ID解决方案：</p><ul><li>uuid</li><li>数据库自增id表</li><li>redis原子自增命令</li><li>雪花算法 (原生的，扩展的百度UidGenerator, 美团Leaf等)</li><li>Mist 薄雾算法</li></ul><h3 id="5-3-分布式锁"><a href="#5-3-分布式锁" class="headerlink" title="5.3 分布式锁"></a>5.3 分布式锁</h3><p>常用于分布式系统中资源控制，只有持有锁的才能继续操作，确保同一时刻只会有一个实例访问这个资源</p><p>常见的分布式锁有</p><ul><li>基于数据库实现分布式锁</li><li><a href="https://link.juejin.cn/?target=https://hhui.top/spring-db/09.%E5%AE%9E%E4%BE%8B/20.201030-springboot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E7%AF%87/">Redis实现分布式锁（应用篇） | 一灰灰Learning</a></li><li><a href="https://link.juejin.cn/?target=https://hhui.top/spring-middle/03.zookeeper/02.210415-springboot%E6%95%B4%E5%90%88zookeeper%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">从0到1实现一个分布式锁 | 一灰灰Learning</a></li><li>etcd实现分布式锁</li><li>基于consul实现分布式锁</li></ul><h3 id="5-4-分布式事务"><a href="#5-4-分布式事务" class="headerlink" title="5.4 分布式事务"></a>5.4 分布式事务</h3><p>事务表示一组操作，要么全部成功，要么全部不成功；单机事务通常说的是数据库的事务；而分布式事务，则可以简单理解为多个数据库的操作，要么同时成功，要么全部不成功</p><p>更确切一点的说法，分布式事务主要是要求事务的参与方，可能涉及到多个系统、多个数据资源，要求它们的操作要么都成功，要么都回滚；</p><p>一个简单的例子描述下分布式事务场景：</p><p><strong>下单扣库存</strong></p><ul><li>用户下单，付钱</li><li>此时订单服务，会生成订单信息</li><li>支付网关，会记录付款信息，成功or失败</li><li>库存服务，扣减对应的库存</li></ul><p>一个下单支付操作，涉及到三个系统，而分布式事务则是要求，若支付成功，则上面三个系统都应该更新成功；若有一个操作失败，如支付失败，则已经扣了库存的要回滚（还库存），生成的订单信息回滚（删掉–注：现实中并不会去删除订单信息，这里只是用于说明分布式事务，请勿带入实际的实现方案）</p><p>分布式事务实现方案：</p><ul><li>2PC: 前面说的两阶段提交，就是实现分布式事务的一个经典解决方案</li><li>3PC: 三阶段提交</li><li>TCC：补偿事务，简单理解为应用层面的2PC</li><li>SAGA事务</li><li>本地消息表</li><li>MQ事务方案</li></ul><h3 id="5-5-分布式任务"><a href="#5-5-分布式任务" class="headerlink" title="5.5 分布式任务"></a>5.5 分布式任务</h3><p>分布式任务相比于我们常说单机的定时任务而言，可以简单的理解为多台实例上的定时任务，从应用场景来说，可以区分两种</p><ul><li>互斥性的分布式任务<ul><li>即同一时刻，集群内只能有一个实例执行这个任务</li></ul></li><li>并存式的分布式任务<ul><li>同一时刻，所有的实例都可以执行这个任务</li><li>续考虑如何避免多个任务操作相同的资源</li></ul></li></ul><p>分布式任务实现方案：</p><ul><li>Quartz Cluster</li><li>XXL-Job</li><li>Elastic-Job</li><li>自研：<ul><li>资源分片策略</li><li>分布式锁控制的唯一任务执行策略</li></ul></li></ul><h3 id="5-6-分布式Session"><a href="#5-6-分布式Session" class="headerlink" title="5.6 分布式Session"></a>5.6 分布式Session</h3><blockquote><p>Session一般叫做会话，Session技术是http状态保持在服务端的解决方案，它是通过服务器来保持状态的。我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。</p></blockquote><p>单机基于session&#x2F;cookie来实现用户认证，那么在分布式系统的多实例之间，如何验证用户身份呢？这个就是我们说的分布式session</p><p>分布式session实现方案：</p><ul><li>session stick：客户端每次请求都转发到同一台服务器(如基于ip的hash路由转发策略）</li><li>session复制: session生成之后，主动同步给其他服务器</li><li>session集中保存：用户信息统一存储，每次需要时统一从这里取(也就是常说的redis实现分布式session方案)</li><li>cookie: 使用客户端cookie存储session数据，每次请求时携带这个</li></ul><h3 id="5-7-分布式链路追踪"><a href="#5-7-分布式链路追踪" class="headerlink" title="5.7 分布式链路追踪"></a>5.7 分布式链路追踪</h3><p>分布式链路追踪也可以叫做全链路追中，而它可以说是每个开发者的福音，通常指的是一次前端的请求，将这个请求过程中，所有涉及到的系统、链路都串联起来，可以清晰的知道这一次请求中，调用了哪些服务，有哪些IO交互，瓶颈点在哪里，什么地方抛出了异常</p><p>当前主流的全链路方案大多是基于google的<code>Dapper</code> 论文实现的</p><p>全链路实现方案</p><ul><li>zipkin</li><li>pinpoint</li><li>SkyWalking</li><li>CAT</li><li>jaeger</li></ul><h3 id="5-8-布隆过滤器"><a href="#5-8-布隆过滤器" class="headerlink" title="5.8 布隆过滤器"></a>5.8 布隆过滤器</h3><p>Bloom过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。</p><p>布隆过滤器由一个长度为 m 比特的位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。</p><p>原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。</p><p>检索时，我们只要看看这些点是不是都是 1 就大约知道集合中有没有它了，也就是说，如果这些点有任何一个 0 ，则被检元素一定不在；如果都是 1 ，则被检元素很可能在。</p><p>关于布隆过滤器，请牢记一点</p><ul><li>判定命中的，不一定真的命中</li><li>判定没有命中的，则一定不在里面</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9216004b053f4830801dbb529b4cd132~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="布隆过滤器"></p><p>常见的应用场景，如</p><ul><li>防止缓存穿透</li><li>爬虫时重复检测</li></ul><h3 id="5-9-一灰灰的小结"><a href="#5-9-一灰灰的小结" class="headerlink" title="5.9 一灰灰的小结"></a>5.9 一灰灰的小结</h3><p>分布式系统的解决方案当然不局限于上面几种，比如分布式存储、分布式计算等也属于常见的场景，当然在我们实际的业务支持过程中，不太可能需要让我们自己来支撑这种大活；而上面提到的几个点，基本上或多或少会与我们日常工作相关，这里列出来当然是好为了后续的详情做铺垫</p><h2 id="6-一灰灰的总结"><a href="#6-一灰灰的总结" class="headerlink" title="6.一灰灰的总结"></a>6.一灰灰的总结</h2><h3 id="6-1-综述"><a href="#6-1-综述" class="headerlink" title="6.1 综述"></a>6.1 综述</h3><p>这是一篇概括性的综述类文章，可能并没有很多的干货，当然也限于“一灰灰”我个人的能力，上面的总结可能并不准确，如有发现，请不吝赐教</p><p>全文总结如下</p><p>常见的分布式架构设计方案：</p><ul><li>主备，主从，多主多从，普通无中心集群，数据分片架构</li></ul><p>分布式系统中的理论基石：</p><ul><li>CAP， BASE, PACELEC</li><li>共识算法：paxos, raft, zab</li><li>一致性协议：2pc, 3pc</li><li>数据同步：gossip</li></ul><p>分布式系统中的算法：</p><ul><li>分区的一致性hash算法: 基于hash环，减少节点动态增加减少对整个集群的影响；适用于数据分片的场景</li><li>适用于一致性的Quorum NWR算法: 投票算法，定义如何就一个提案达成共识</li><li>PBFT拜占庭容错算法: 适用于集群中节点故障、或者不可信的场景</li><li>区块链中大量使用的工作量证明PoW算法: 通过工作量证明，认可节点的提交</li></ul><p>分布式系统解决方案：</p><ul><li>分布式缓存</li><li>全局唯一ID</li><li>分布式锁</li><li>分布式事务</li><li>分布式任务</li><li>分布式会话</li><li>分布式链路追踪</li><li>布隆过滤器</li></ul><p>作者：一灰灰<br>链接：<a href="https://juejin.cn/post/7125383856651239432">https://juejin.cn/post/7125383856651239432</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式会遇到什么问题，有哪些理论支撑，有哪些经典的应对方案，业界是如何设计并保证分布式系统的高可用呢？&lt;/p&gt;
&lt;h2 id=&quot;1-架构设计&quot;&gt;&lt;a href=&quot;#1-架构设计&quot; class=&quot;headerlink&quot; title=&quot;1.架构设计&quot;&gt;&lt;/a&gt;1.架构设计&lt;/h</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>一个优秀的 Controller 层逻辑</title>
    <link href="http://ai.mak.cn/2022/07/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84Controller%E5%B1%82%E9%80%BB%E8%BE%91/"/>
    <id>http://ai.mak.cn/2022/07/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84Controller%E5%B1%82%E9%80%BB%E8%BE%91/</id>
    <published>2022-07-22T16:00:00.000Z</published>
    <updated>2023-01-14T14:45:07.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个优秀的-Controller-层逻辑"><a href="#一个优秀的-Controller-层逻辑" class="headerlink" title="一个优秀的 Controller 层逻辑"></a><strong>一个优秀的 Controller 层逻辑</strong></h2><blockquote><p>说到 Controller，相信大家都不陌生，它可以很方便地对外提供数据接口。它的定位，我认为是「不可或缺的配角」。<br>说它不可或缺是因为无论是传统的三层架构还是现在的 COLA 架构，Controller 层依旧有一席之地，说明他的必要性。<br>说它是配角是因为 Controller 层的代码一般是不负责具体的逻辑业务逻辑实现，但是它负责接收和响应请求。</p></blockquote><p><strong>从现状看问题</strong></p><p>Controller 主要的工作有以下几项：</p><ul><li>接收请求并解析参数</li><li>调用 Service 执行具体的业务代码（可能包含参数校验）</li><li>捕获业务逻辑异常做出反馈</li><li>业务逻辑执行成功做出响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Service</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">service</span><span class="params">(TestDTO testDTO)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getNum() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;输入的数字需要大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getType().equals(<span class="string">&quot;square&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(testDTO.getNum(), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getType().equals(<span class="string">&quot;factorial&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> testDTO.getNum();</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                result = result * num;</span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;未识别的算法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> TestDTO testDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.testService.service(testDTO);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> DTOid <span class="title function_">setTestService</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果真的按照上面所列的工作项来开发 Controller 代码会有几个问题：</p><ul><li>参数校验过多地耦合了业务代码，违背单一职责原则</li><li>可能在多个业务中都抛出同一个异常，导致代码重复</li><li>各种异常反馈和成功响应格式不统一，接口对接不友好</li></ul><h2 id="改造-Controller-层逻辑"><a href="#改造-Controller-层逻辑" class="headerlink" title="改造 Controller 层逻辑"></a><strong>改造 Controller 层逻辑</strong></h2><h4 id="统一返回结构"><a href="#统一返回结构" class="headerlink" title="统一返回结构"></a>统一返回结构</h4><p>统一返回值类型无论项目前后端是否分离都是非常必要的，方便对接接口的开发人员更加清晰地知道这个接口的调用是否成功（不能仅仅简单地看返回值是否为 null 就判断成功与否，因为有些接口的设计就是如此）。</p><p>使用一个状态码、状态信息就能清楚地了解接口调用情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义返回数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line">    Integer <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用结果的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultEnum</span> <span class="keyword">implements</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line">    SUCCESS(<span class="number">2001</span>, <span class="string">&quot;接口调用成功&quot;</span>),</span><br><span class="line">    VALIDATE_FAILED(<span class="number">2002</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line">    COMMON_FAILED(<span class="number">2003</span>, <span class="string">&quot;接口调用失败&quot;</span>),</span><br><span class="line">    FORBIDDEN(<span class="number">2004</span>, <span class="string">&quot;没有权限访问资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set方法和构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一返回数据结构</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(String message, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), message, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.COMMON_FAILED.getCode(), ResultEnum.COMMON_FAILED.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(String message) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.COMMON_FAILED.getCode(), message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(IResult errorResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(errorResult.getCode(), errorResult.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">instance</span><span class="params">(Integer code, String message, T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一返回结构后，在 Controller 中就可以使用了，但是每一个 Controller 都写这么一段最终封装的逻辑，这些都是很重复的工作，所以还要继续想办法进一步处理统一返回结构。</p><h4 id="统一包装处理"><a href="#统一包装处理" class="headerlink" title="统一包装处理"></a>统一包装处理</h4><p>Spring 中提供了一个类 ResponseBodyAdvice ，能帮助我们实现上述需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> T body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResponseBodyAdvice 是对 Controller 返回的内容在 HttpMessageConverter 进行类型转换之前拦截，进行相应的处理操作后，再将结果返回给客户端。</p><p>那这样就可以把统一包装的工作放到这个类里面：</p><ul><li><strong>supports：</strong> 判断是否要交给 beforeBodyWrite 方法执行，ture：需要；false：不需要</li><li><strong>beforeBodyWrite：</strong> 对 response 进行具体的处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果引入了swagger或knife4j的文档生成组件，这里需要仅扫描自己项目的包，否则文档无法正常生成</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.example.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要进行封装的，可以添加一些校验手段，比如添加标记排除的注解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供一定的灵活度，如果body已经被包装了，就不进行包装</span></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Result) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样改造，既能实现对 Controller 返回的数据进行统一包装，又不需要对原有代码进行大量的改动。</p><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>Java API 的规范 JSR303 定义了校验的标准 validation-api ，其中一个比较出名的实现是 hibernate validation。</p><p>spring validation 是对其的二次封装，常用于 SpringMVC 的参数自动校验，参数校验的代码就不需要再与业务逻辑代码进行耦合了。</p><h4 id="①-PathVariable-和-RequestParam-参数校验"><a href="#①-PathVariable-和-RequestParam-参数校验" class="headerlink" title="①@PathVariable 和 @RequestParam 参数校验"></a><strong>①@PathVariable 和 @RequestParam 参数校验</strong></h4><p>Get 请求的参数接收一般依赖这两个注解，但是处于 url 有长度限制和代码的可维护性，超过 5 个参数尽量用实体来传参。</p><p>对 @PathVariable 和 @RequestParam 参数进行校验需要在入参声明约束的注解。</p><p>如果校验失败，会抛出 MethodArgumentNotValidException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(value = &quot;prettyTestController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pretty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;num&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable(&quot;num&quot;)</span> <span class="meta">@Min(1)</span> <span class="meta">@Max(20)</span> Integer num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getByEmail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestDTO <span class="title function_">getByAccount</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@NotBlank</span> <span class="meta">@Email</span> String email)</span> &#123;</span><br><span class="line">        <span class="type">TestDTO</span> <span class="variable">testDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestDTO</span>();</span><br><span class="line">        testDTO.setEmail(email);</span><br><span class="line">        <span class="keyword">return</span> testDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestService</span><span class="params">(TestService prettyTestService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = prettyTestService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a><strong>校验原理</strong></h4><p>在 SpringMVC 中，有一个类是 RequestResponseBodyMethodProcessor，这个类有两个作用（实际上可以从名字上得到一点启发）</p><ul><li>用于解析 @RequestBody 标注的参数</li><li>处理 @ResponseBody 标注方法的返回值</li></ul><p>解析 @RequestBoyd 标注参数的方法是 resolveArgument。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment">     * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment">     * converter to read the content with.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">      parameter = parameter.nestedIfOptional();</span><br><span class="line">      <span class="comment">//把请求数据封装成标注的DTO对象</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">        <span class="keyword">if</span> (arg != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//执行数据校验</span></span><br><span class="line">          validateIfApplicable(binder, parameter);</span><br><span class="line">          <span class="comment">//如果校验不通过，就抛出MethodArgumentNotValidException异常</span></span><br><span class="line">          <span class="comment">//如果我们不自己捕获，那么最终会由DefaultHandlerExceptionResolver捕获处理</span></span><br><span class="line">          <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentNotValidException</span>(parameter, binder.getBindingResult());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mavContainer != <span class="literal">null</span>) &#123;</span><br><span class="line">          mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessageConverterMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Validate the binding target if applicable.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation checks for &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.validation.Valid&#125;,</span></span><br><span class="line"><span class="comment">    * Spring&#x27;s &#123;<span class="doctag">@link</span> org.springframework.validation.annotation.Validated&#125;,</span></span><br><span class="line"><span class="comment">    * and custom annotations whose name starts with &quot;Valid&quot;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> binder the DataBinder to be used</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parameter the method parameter descriptor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1.5</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isBindExceptionRequired</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数上的所有注解</span></span><br><span class="line">      Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">      <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">      <span class="comment">//如果注解中包含了@Valid、@Validated或者是名字以Valid开头的注解就进行参数校验</span></span><br><span class="line">         Object[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);</span><br><span class="line">         <span class="keyword">if</span> (validationHints != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//实际校验逻辑，最终会调用Hibernate Validator执行真正的校验</span></span><br><span class="line">        <span class="comment">//所以Spring Validation是对Hibernate Validation的二次封装</span></span><br><span class="line">            binder.validate(validationHints);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-RequestBody-参数校验"><a href="#②-RequestBody-参数校验" class="headerlink" title="②@RequestBody 参数校验"></a><strong>②@RequestBody 参数校验</strong></h4><p>Post、Put 请求的参数推荐使用 @RequestBody 请求体参数。</p><p>对 @RequestBody 参数进行校验需要在 DTO 对象中加入校验条件后，再搭配 @Validated 即可完成自动校验。</p><p>如果校验失败，会抛出 ConstraintViolationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Controller</span></span><br><span class="line"><span class="meta">@RestController(value = &quot;prettyTestController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pretty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test-validation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testValidation</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> TestDTO testDTO)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService.save(testDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestService</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="校验原理-1"><a href="#校验原理-1" class="headerlink" title="校验原理"></a><strong>校验原理</strong></h4><p>声明约束的方式，注解加到了参数上面，可以比较容易猜测到是使用了 AOP 对方法进行增强。</p><p>而实际上 Spring 也是通过 MethodValidationPostProcessor 动态注册 AOP 切面，然后使用 MethodValidationInterceptor 对切点方法进行织入增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定了创建切面的Bean的注解</span></span><br><span class="line">   <span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; validatedAnnotationType = Validated.class;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//为所有@Validated标注的Bean创建切面</span></span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(<span class="built_in">this</span>.validatedAnnotationType, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建Advisor进行增强</span></span><br><span class="line">        <span class="built_in">this</span>.advisor = <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, createMethodValidationAdvice(<span class="built_in">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Advice，本质就是一个方法拦截器</span></span><br><span class="line">    <span class="keyword">protected</span> Advice <span class="title function_">createMethodValidationAdvice</span><span class="params">(<span class="meta">@Nullable</span> Validator validator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">MethodValidationInterceptor</span>(validator) : <span class="keyword">new</span> <span class="title class_">MethodValidationInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//无需增强的方法，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] groups = determineValidationGroups(invocation);</span><br><span class="line">        <span class="type">ExecutableValidator</span> <span class="variable">execVal</span> <span class="operator">=</span> <span class="built_in">this</span>.validator.forExecutables();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodToValidate</span> <span class="operator">=</span> invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//方法入参校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">             <span class="comment">//所以Spring Validation是对Hibernate Validation的二次封装</span></span><br><span class="line">            result = execVal.validateParameters(</span><br><span class="line">                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验不通过抛出ConstraintViolationException异常</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Controller方法调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="comment">//下面是对返回值做校验，流程和上面大概一样</span></span><br><span class="line">        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③自定义校验规则"><a href="#③自定义校验规则" class="headerlink" title="③自定义校验规则"></a><strong>③自定义校验规则</strong></h4><p>有些时候 JSR303 标准中提供的校验规则不满足复杂的业务需求，也可以自定义校验规则。</p><p>自定义校验规则需要做两件事情：</p><ul><li>自定义注解类，定义错误信息和一些其他需要的内容</li><li>注解校验器，定义判定规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义注解类</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = MobileValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Mobile &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验不通过返回的提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;不是一个手机号码格式&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constraint要求的属性，用于分组校验和扩展，留空就好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解校验器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Mobile, CharSequence&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[34578][0-9]&#123;9&#125;$&quot;</span>); <span class="comment">// 验证手机号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在验证开始前调用注解里的方法，从而获取到一些注解里的参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constraintAnnotation annotation instance for a given constraint declaration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Mobile constraintAnnotation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.required = constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断参数是否合法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   object to validate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(CharSequence value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.required) &#123;</span><br><span class="line">            <span class="comment">// 验证</span></span><br><span class="line">            <span class="keyword">return</span> isMobile(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line">            <span class="comment">// 验证</span></span><br><span class="line">            <span class="keyword">return</span> isMobile(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMobile</span><span class="params">(<span class="keyword">final</span> CharSequence str)</span> &#123;</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> pattern.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动校验参数真的是一项非常必要、非常有意义的工作。JSR303 提供了丰富的参数校验规则，再加上复杂业务的自定义校验规则，完全把参数校验和业务逻辑解耦开，代码更加简洁，符合单一职责原则。</p><h4 id="自定义异常与统一拦截异常"><a href="#自定义异常与统一拦截异常" class="headerlink" title="自定义异常与统一拦截异常"></a><strong>自定义异常与统一拦截异常</strong></h4><p>原来的代码中可以看到有几个问题：</p><ul><li>抛出的异常不够具体，只是简单地把错误信息放到了 Exception 中</li><li>抛出异常后，Controller 不能具体地根据异常做出反馈</li><li>虽然做了参数自动校验，但是异常返回结构和正常返回结构不一致</li></ul><p>自定义异常是为了后面统一拦截异常时，对业务中的异常有更加细颗粒度的区分，拦截时针对不同的异常作出不同的响应。</p><p>而统一拦截异常的目的一个是为了可以与前面定义下来的统一包装返回结构能对应上，另一个是我们希望无论系统发生什么异常，Http 的状态码都要是 200 ，尽可能由业务来区分系统的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForbiddenException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForbiddenException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一拦截异常</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.example.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获 &#123;<span class="doctag">@code</span> BusinessException&#125; 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;BusinessException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleBusinessException(BusinessException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获 &#123;<span class="doctag">@code</span> ForbiddenException&#125; 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ForbiddenException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleForbiddenException(ForbiddenException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.FORBIDDEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; 参数校验不通过时抛出的异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> ex.getBindingResult();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;校验失败:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            sb.append(fieldError.getField()).append(<span class="string">&quot;：&quot;</span>).append(fieldError.getDefaultMessage()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(msg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@PathVariable</span>&#125; 和 &#123;<span class="doctag">@code</span> <span class="doctag">@RequestParam</span>&#125; 参数校验不通过时抛出的异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleConstraintViolationException(ConstraintViolationException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(ex.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶级异常捕获并统一处理，当其他异常无法处理时候选择使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handle(Exception ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>做好了这一切改动后，可以发现 Controller 的代码变得非常简洁，可以很清楚地知道每一个参数、每一个 DTO 的校验规则，可以很明确地看到每一个 Controller 方法返回的是什么数据，也可以方便每一个异常应该如何进行反馈。</p><p>这一套操作下来后，我们能更加专注于业务逻辑的开发，代码简介、功能完善，何乐而不为呢？</p><blockquote><p>转自：gelald</p><p>链接：<a href="https://juejin.cn/post/7123091045071454238">https://juejin.cn/post/7123091045071454238</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个优秀的-Controller-层逻辑&quot;&gt;&lt;a href=&quot;#一个优秀的-Controller-层逻辑&quot; class=&quot;headerlink&quot; title=&quot;一个优秀的 Controller 层逻辑&quot;&gt;&lt;/a&gt;&lt;strong&gt;一个优秀的 Controller 层</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
