<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 的 16 条实践解读</title>
    <link href="http://ai.mak.cn/2020/02/28/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/"/>
    <id>http://ai.mak.cn/2020/02/28/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2023-01-09T08:49:55.231Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我将重点介绍 Spring Boot 特有的实践（大多数时候，也适用于 Spring 项目）。以下依次列出了最佳实践，排名不分先后。</p><h3 id="1、使用自定义-BOM-来维护第三方依赖"><a href="#1、使用自定义-BOM-来维护第三方依赖" class="headerlink" title="1、使用自定义 BOM 来维护第三方依赖"></a>1、使用自定义 BOM 来维护第三方依赖</h3><p>这条实践是我根据实际项目中的经历总结出的。</p><p>Spring Boot 项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。</p><p>怎么办呢？事实上，Spring IO Platform 就是做的这个事情，它本身就是 Spring Boot 的子项目，同时维护了其他第三方开源库。我们可以借鉴 Spring IO Platform 来编写自己的基础项目 platform-bom，所有的业务模块项目应该以 BOM 的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.spring.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>platform-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Cairo-SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、使用自动配置"><a href="#2、使用自动配置" class="headerlink" title="2、使用自动配置"></a>2、使用自动配置</h3><p>Spring Boot 的一个主要特性是使用自动配置。这是 Spring Boot 的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的 jar 文件时，自动配置就会被激活。</p><p>使用它的最简单方法是依赖 Spring Boot Starters。因此，如果你想与 Redis 进行集成，你可以首先包括：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想与 MongoDB 进行集成，需要这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助于这些 starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的 Jar 地狱。</p><blockquote><p><a href="https://dzone.com/articles/what-is-jar-hell">https://dzone.com/articles/what-is-jar-hell</a></p></blockquote><p>通过使用以下注解属性，可以从自动配置中排除某些配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>（exclude = &#123;ClassNotToAutoconfigure.class&#125;）</span><br></pre></td></tr></table></figure><p>但只有在绝对必要时才应该这样做。</p><p>有关自动配置的官方文档可在此处找到：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html%E3%80%82">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。</a></p></blockquote><h3 id="3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目"><a href="#3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目" class="headerlink" title="3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目"></a>3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目</h3><blockquote><p>这一条最佳实践来自 Josh Long （Spring Advocate，@starbuxman）。</p></blockquote><p>Spring Initializr 提供了一个超级简单的方法来创建一个新的 Spring Boot 项目，并根据你的需要来加载可能使用到的依赖。</p><blockquote><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p>使用 Initializr 创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于 Spring 自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。</p><h3 id="4、考虑为常见的组织问题创建自己的自动配置"><a href="#4、考虑为常见的组织问题创建自己的自动配置" class="headerlink" title="4、考虑为常见的组织问题创建自己的自动配置"></a>4、考虑为常见的组织问题创建自己的自动配置</h3><p>这一条也来自 Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。</p><p>如果你在一个严重依赖 Spring Boot 的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。</p><p>这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。</p><p>如果将这个提供 Spring Boot 配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。</p><h3 id="5、正确设计代码目录结构"><a href="#5、正确设计代码目录结构" class="headerlink" title="5、正确设计代码目录结构"></a>5、正确设计代码目录结构</h3><p>尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。</p><p>避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；</p><p>将 Application.java（应用的入口类）保留在顶级源代码目录中；</p><p>我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！</p><h3 id="6、保持-Controller-的简洁和专注"><a href="#6、保持-Controller-的简洁和专注" class="headerlink" title="6、保持 @Controller 的简洁和专注"></a>6、保持 @Controller 的简洁和专注</h3><p>Controller 应该非常简单。你可以在此处阅读有关 GRASP 中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller">https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller</a></p></blockquote><ul><li>控制器应该是无状态的！默认情况下，控制器是单例，并且任何状态都可能导致大量问题；</li><li>控制器不应该执行业务逻辑，而是依赖委托；</li><li>控制器应该处理应用程序的 HTTP 层，这不应该传递给服务；</li><li>控制器应该围绕用例 &#x2F; 业务能力来设计。</li></ul><p>要深入这个内容，需要进一步地了解设计 REST API 的最佳实践。无论你是否想要使用 Spring Boot，都是值得学习的。</p><h3 id="7、围绕业务功能构建-Service"><a href="#7、围绕业务功能构建-Service" class="headerlink" title="7、围绕业务功能构建 @Service"></a>7、围绕业务功能构建 @Service</h3><p>Service 是 Spring Boot 的另一个核心概念。我发现最好围绕业务功能 &#x2F; 领域 &#x2F; 用例（无论你怎么称呼都行）来构建服务。</p><p>在应用中设计名称类似<code>AccountService</code>, <code>UserService</code>, <code>PaymentService</code>这样的服务，比起像<code>DatabaseService</code>、<code>ValidationService</code>、<code>CalculationService</code>这样的会更合适一些。</p><p>你可以决定使用 Controler 和 Service 之间的一对一映射，那将是理想的情况。但这并不意味着，Service 之间不能互相调用！</p><h3 id="8、使数据库独立于核心业务逻辑之外"><a href="#8、使数据库独立于核心业务逻辑之外" class="headerlink" title="8、使数据库独立于核心业务逻辑之外"></a>8、使数据库独立于核心业务逻辑之外</h3><p>我之前还不确定如何在 Spring Boot 中最好地处理数据库交互。在阅读了罗伯特 ·C· 马丁的 “Clear Architecture” 之后，对我来说就清晰多了。</p><p>你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。</p><blockquote><p>罗伯特 C. 马丁强烈地说明，你的数据库是一个 “细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用 Spring Boot 和现代微服务开发会让事情变得更快。</p></blockquote><h3 id="9、保持业务逻辑不受-Spring-Boot-代码的影响"><a href="#9、保持业务逻辑不受-Spring-Boot-代码的影响" class="headerlink" title="9、保持业务逻辑不受 Spring Boot 代码的影响"></a>9、保持业务逻辑不受 Spring Boot 代码的影响</h3><p>考虑到 “Clear Architecture” 的教训，你还应该保护你的业务逻辑。将各种 Spring Boot 代码混合在一起是非常诱人的…… 不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。</p><p>部分服务通常成为库。如果不从代码中删除大量 Spring 注解，则更容易创建。</p><h3 id="10、推荐使用构造函数注入"><a href="#10、推荐使用构造函数注入" class="headerlink" title="10、推荐使用构造函数注入"></a>10、推荐使用构造函数注入</h3><p>这一条实践来自 Phil Webb（Spring Boot 的项目负责人, @phillip_webb）。</p><p>保持业务逻辑免受 Spring Boot 代码侵入的一种方法是使用构造函数注入。不仅是因为<code>@Autowired</code>注解在构造函数上是可选的，而且还可以在没有 Spring 的情况下轻松实例化 bean。</p><h3 id="11、熟悉并发模型"><a href="#11、熟悉并发模型" class="headerlink" title="11、熟悉并发模型"></a>11、熟悉并发模型</h3><p>我写过的最受欢迎的文章之一是 “介绍 Spring Boot 中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。</p><blockquote><p><a href="https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/">https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/</a></p></blockquote><p>在 Spring Boot 中，Controller 和 Service 是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。</p><p>如果你正在使用新的 WebFlux 风格的 Spring Boot 应用程序，我已经解释了它在 “Spring’s WebFlux&#x2F;Reactor Parallelism and Backpressure” 中是如何工作的。</p><h3 id="12、加强配置管理的外部化"><a href="#12、加强配置管理的外部化" class="headerlink" title="12、加强配置管理的外部化"></a>12、加强配置管理的外部化</h3><p>这一点超出了 Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……</p><p>你可以手动处理 Spring 应用程序的配置。如果你正在处理多个 Spring Boot 应用程序，则需要使配置管理能力更加强大。</p><p>我推荐两种主要方法：</p><ul><li>使用配置服务器，例如 Spring Cloud Config；</li><li>将所有配置存储在环境变量中（可以基于 git 仓库进行配置）。</li></ul><p>这些选项中的任何一个（第二个选项多一些）都要求你在 DevOps 更少工作量，但这在微服务领域是很常见的。</p><h3 id="13、提供全局异常处理"><a href="#13、提供全局异常处理" class="headerlink" title="13、提供全局异常处理"></a>13、提供全局异常处理</h3><p>你真的需要一种处理异常的一致方法。Spring Boot 提供了两种主要方法：</p><ul><li>你应该使用 HandlerExceptionResolver 定义全局异常处理策略；</li><li>你也可以在控制器上添加 @ExceptionHandler 注解，这在某些特定场景下使用可能会很有用。</li></ul><p>这与 Spring 中的几乎相同，并且 Baeldung 有一篇关于 REST 与 Spring 的错误处理的详细文章，非常值得一读。</p><blockquote><p><a href="https://www.baeldung.com/exception-handling-for-rest-with-spring">https://www.baeldung.com/exception-handling-for-rest-with-spring</a></p></blockquote><h3 id="14、使用日志框架"><a href="#14、使用日志框架" class="headerlink" title="14、使用日志框架"></a>14、使用日志框架</h3><p>你可能已经意识到这一点，但你应该使用 Logger 进行日志记录，而不是使用 System.out.println() 手动执行。这很容易在 Spring Boot 中完成，几乎没有配置。只需获取该类的记录器实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(MyClass.class);</span><br></pre></td></tr></table></figure><p>这很重要，因为它可以让你根据需要设置不同的日志记录级别。</p><h3 id="15、测试你的代码"><a href="#15、测试你的代码" class="headerlink" title="15、测试你的代码"></a>15、测试你的代码</h3><p>这不是 Spring Boot 特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。</p><p>如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。</p><p>由于存在 Spring Boot 最佳实践，因此你应该考虑将 Spring Cloud Contract 用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。</p><h3 id="16、使用测试切片让测试更容易，并且更专注"><a href="#16、使用测试切片让测试更容易，并且更专注" class="headerlink" title="16、使用测试切片让测试更容易，并且更专注"></a>16、使用测试切片让测试更容易，并且更专注</h3><p>这一条实践来自 Madhura Bhave（Spring 开发者, @madhurabhave23）。</p><p>使用 Spring Boot 测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物…… 实际上并不是那么难！答案是使用测试切片。</p><p>使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自 spring.io 的一篇名为 Custom test slice with Spring test 1.4 的博客文章解释了这种技术。</p><blockquote><p><a href="https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4">https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感谢 Spring Boot，编写基于 Spring 的微服务正变得前所未有的简单。我希望通过这些最佳实践，你的实施过程不仅会变得很快，而且从长远来看也会更加强大和成功。祝你好运！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本文中，我将重点介绍 Spring Boot 特有的实践（大多数时候，也适用于 Spring 项目）。以下依次列出了最佳实践，排名不分先后。&lt;/p&gt;
&lt;h3 id=&quot;1、使用自定义-BOM-来维护第三方依赖&quot;&gt;&lt;a href=&quot;#1、使用自定义-BOM-来维护第三方依赖&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微服务核心架构梳理</title>
    <link href="http://ai.mak.cn/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/"/>
    <id>http://ai.mak.cn/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2023-01-09T07:58:34.824Z</updated>
    
    <content type="html"><![CDATA[<p>作业总结的不错，转载一下～</p><p>作者：tengshe789</p><p>链接：<a href="https://urlify.cn/zYJzee">https://urlify.cn/zYJzee</a></p><p>下文，你将看到业界主流微服务框架的核心原理，包括服务发现，网关，配置中心，监控等组件，功能和架构原理的简单介绍。感谢阅读！</p><h1 id="Hello，Microservices"><a href="#Hello，Microservices" class="headerlink" title="Hello，Microservices"></a>Hello，Microservices</h1><p><strong>什么是微服务</strong></p><p>微服务Microservices之父，马丁.福勒，对微服务大概的概述如下：</p><blockquote><p>就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。但通在其常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p></blockquote><p>根据马丁.福勒的描述，我总结了一下几点：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/724387762baa49dabc8fae5f36edade1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ser3itD8NC19CaClz4hTVfpAGkA=" alt="img"></p><p><strong>小服务</strong></p><p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p><p><strong>进程独立</strong></p><p>每一组服务都是独立运行的，可能我这个服务运行在tomcat容器，而另一个服务运行在jetty上。可以通过进程方式，不断的横向扩展整个服务。</p><p><strong>通信</strong></p><p>过去的协议都是很重的，就像ESB，就像SOAP，轻通信，着意味着相比过去更智能更轻量的服务相互调用，就所谓smart endpoints and dumb pipes，这些endpoint都是解耦的，完成一个业务通信调用串起这些micro service就像是linux系统中通过管道串起一系列命令业务。</p><p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p><p><strong>部署</strong></p><p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维指责</p><p><strong>管理</strong></p><p>传统的企业级SOA服务往往很大，不易于管理，耦合性高，团队开发成本比较大。微服务，可以让团队各思其政的选择技术实现，不同的service可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p><h1 id="微服务的利与弊"><a href="#微服务的利与弊" class="headerlink" title="微服务的利与弊"></a><strong>微服务的利与弊</strong></h1><p>为什么用微服务呢？因为好玩？</p><p>不是的。下面是我从网络上找到说的比较全的优点：</p><blockquote><p>优点每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求<br>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。<br>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。<br>微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。<br>微服务能使用不同的语言开发。<br>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins,Hudson,bamboo。<br>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需- - 通过合作才能体现价值。微服务允许你利用融合最新技术。<br>微服务只是业务逻辑的代码，不会和 HTML,CSS或其他界面组件混合。<br>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</p></blockquote><p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p><p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p><h1 id="什么组织适合使用微服务？"><a href="#什么组织适合使用微服务？" class="headerlink" title="什么组织适合使用微服务？"></a><strong>什么组织适合使用微服务？</strong></h1><p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务？</p><p><strong>墨菲定律（设计系统）和康威定律（系统划分）</strong></p><p>康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/9e4d43792c37454aab148326328dcead~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=Fy0R5j/IHPDuxHSy/55w+RiOGBc=" alt="img"></p><p>感兴趣的各位可以研究一下</p><h1 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a><strong>架构演化</strong></h1><p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/c1e94e85a2c842e69cc79b5968dfdbb4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=lknzFU4sJ2RpxE25224WUSlSECA=" alt="img"></p><p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/b8127c777e884c4e8c4fdfabca298d1d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=UwJFqfOgqTedDW253kdV7CIcBiw=" alt="img"></p><p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用API方式发布他们的功能，而平台使用他们的功能发布产品</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/7c64a067343943759a1418e0dccd7f5d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=YXJpXxB/aiO3D4MC5L84bOjJv6U=" alt="img"></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/429bf7c0a7a84099894e9b7cdfda1fe1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aMnhFdwrd+teQLj2ZUPbDZJtJYs=" alt="img"></p><h1 id="微服务技术架构体系"><a href="#微服务技术架构体系" class="headerlink" title="微服务技术架构体系"></a><strong>微服务技术架构体系</strong></h1><p>下面我分享一下大部分公司都使用的微服务技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/1a3105e8d32d46379189e66a232c5f5a~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ij1N/fUpKJzAvGEZlC5KBiLQyaY=" alt="img"></p><p><strong>服务发现</strong></p><p>主流的服务发现，分为三种</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/54bed4ea976241cdbf877ea00744b3ce~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cdJ1FzkKqJmQGQvYq/HY9r9kn4Y=" alt="img"></p><p>第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过dns就能找到我们对应的服务</p><p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/d899c1e6e46142498850771ecaff515f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=VDVwjxxbVq+BMeEc0YiYWvoHfQY=" alt="img"></p><p>第二种，是目前普遍的做法。可以参考我上篇博客分析的zuul网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p><p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在spring cloud上的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/dfa8e250379c48ebae7ca4e035afe9f3~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SEkNf7rkzF306T7LFZtnVqoV6gY=" alt="img"></p><p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p><p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p><p><strong>网关</strong></p><p>\1. 微服务的网关是什么？</p><p>我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p><p>将生活实际联系到微服务上，就不难理解网关的意思了。</p><p>\2. 网关有什么用</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/68c66bd974f0477d887ce55aefdbcc44~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cZR+tSGtIE2FDJLjo7kgOUpwT7M=" alt="img"></p><ul><li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务条用</li><li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li><li>限流熔断：参考我学好分布式zookepper的博客，当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题</li><li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息</li><li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</li></ul><p>\3. 开源网关Zuul架构</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/6924461c3b584f178a6c1c71eb27dd63~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aG4q8LZQ37wxOjllgVJsWlmADYc=" alt="img"></p><p>zuul网关核心其实是一个servlet，所有请求都会经过zuul servlet传到zuulFilter Runner，然后分发到三种过滤器。</p><p>先说说架构图左半部分，分别是使用Groovy实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p><p>一般请求都会先经过前置路由过滤器处理，一般的自定义java封装逻辑也会在这里实现。</p><p>路由过滤器，实现的是找到对应的微服务进行调用。</p><p>调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p><p>可以说zuul网关最大的特色就是它三层过滤器。</p><p>架构图右半部分，是zuul网关设计的自定义过滤器加载机制。网关内部会有生产者消费者模型，自动的将过滤器脚本发布到zuul网关读取加载运行。</p><p><strong>配置中心</strong></p><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p><p>因此就有配置中心这个喽~</p><p>现在的开源中心有百度配置中心 Disconf，spring cloud config，Apollo，今天重点说说现在应用质量不错的配置中心阿波罗。</p><h1 id="携程开源的Apollo："><a href="#携程开源的Apollo：" class="headerlink" title="携程开源的Apollo："></a>携程开源的Apollo：</h1><p>开源地址：<br><a href="http://github.com/ctripcorp/a%E2%80%A6">http://github.com/ctripcorp/a…</a></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/491e23c2faf6474591de5c6315747bf4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=25CNEBPSxaikMdxrij2U3KeXce0=" alt="img"></p><p>apollo的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。</p><p><strong>通讯方式</strong></p><p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/ed64b2a43bce4d0ba8ad9d098b6d0471~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=OIlCDdABP9f+xZvHYmwNyNHHg7E=" alt="img"></p><p><strong>监控预警</strong></p><p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。一般监控分为如下层次：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/10bde5726cbf454cabb768571febb1c2~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=P1vOxOdm3N1HsbgQ9XtWN1zDRWY=" alt="img"></p><p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。总体来说，微服务可分5个监控点：日志监控，Metrics监控，健康检查，调用链检查，告警系统</p><p><strong>监控架构</strong></p><p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个agent，agent收集到关键信息，会传到一些MQ中，为了解耦。同时将日志传入ELK，将Metrics传入InfluxDB时间序列库。而像nagios，可以定期向agent发起信息检查微服务。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/3b101e363c9c4ec487a25ba97bdaff98~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=sEFV5fgBICGW5MenbusWvbH83B8=" alt="img"></p><p><strong>调用链监控APM</strong></p><p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的Cat，大部分调用链监控（没错，我指的Zipkin）架构是这样的</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/aee3fd28e0cd42299b83486a608251c8~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=4kZFphBO9qDIRp1Oj3YKNb61Bgw=" alt="img"></p><p>当请求进入Web容器的时候，会经过创建Tracer，连接spans（模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过http headers）。Spans有一个上下文，其中包含tracer标识符，将其放在表示分布式操作的树的正确位置。当我们把图中的各种span放到后端的时候，我们的服务调用链会动态的生成调用链。</p><p>下面是一些市场上用的比较多的调用链监控：</p><p>1、Pinpointgithub地址：GitHub - naver&#x2F;pinpoint: Pinpoint is an open source APM (Application Performance Management) tool for large-scale distributed systems written in Java.对java领域的性能分析有兴趣的朋友都应该看看这个开源项目，这个是一个韩国团队开源出来的，通过JavaAgent的机制来做字节码代码植入，实现加入traceid和抓取性能数据的目的。NewRelic、Oneapm之类的工具在java平台上的性能分析也是类似的机制。</p><p>2、SkyWalkinggithub地址：wu-sheng&#x2F;sky-walking这是国内一位叫吴晟的兄弟开源的，也是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统，在github上也有400多颗星了。功能相对pinpoint还是稍弱一些，插件还没那么丰富，不过也很难得了。</p><p>3、Zipkin官网：OpenZipkin · A distributed tracing systemgithub地址：GitHub - openzipkin&#x2F;zipkin: Zipkin is a distributed tracing system这个是twitter开源出来的，也是参考Dapper的体系来做的。</p><p>Zipkin的java应用端是通过一个叫Brave的组件来实现对应用内部的性能分析数据采集。Brave的github地址：<br><a href="http://github.com/openzipkin/%E2%80%A6%E8%BF%99%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84java%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E6%9D%A5%E5%81%9A%E5%88%B0%E5%AF%B9http/servlet%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E8%B7%9F%E8%B8%AA%E3%80%82%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E5%9C%A8spring%E4%B9%8B%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8C%E5%8A%A0%E5%85%A5%E8%BF%99%E4%BA%9B%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E5%AE%8C%E6%88%90%E5%AF%B9java%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%82">http://github.com/openzipkin/…这个组件通过实现一系列的java拦截器，来做到对http/servlet请求、数据库访问的调用过程跟踪。然后通过在spring之类的配置文件里加入这些拦截器，完成对java应用的性能数据采集。</a></p><p>4、CATgithub地址：GitHub - dianping&#x2F;cat: Central Application Tracking这个是大众点评开源出来的，实现的功能也还是蛮丰富的，国内也有一些公司在用了。不过他实现跟踪的手段，是要在代码里硬编码写一些“埋点”，也就是侵入式的。这样做有利有弊，好处是可以在自己需要的地方加埋点，比较有针对性；坏处是必须改动现有系统，很多开发团队不愿意。</p><p>5、Xhprof&#x2F;Xhgui这两个工具的组合，是针对PHP应用提供APM能力的工具，也是非侵入式的。Xhprof github地址：GitHub - preinheimer&#x2F;xhprof: XHGUI is a GUI for the XHProf PHP extension, using a database backend, and pretty graphs to make it easy to use and interpret.Xhgui github地址：GitHub - perftools&#x2F;xhgui: A graphical interface for XHProf data built on MongoDB我对PHP不熟，不过网上介绍这两个工具的资料还是蛮多的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/4507d426ed7146688375580da41906ff~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=rypjolffor+bucyFBSFu7Oh2mZY=" alt="img"></p><p><strong>熔断、隔离、限流、降级</strong></p><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用）措施。</p><p>下面介绍一下hystrix的运行流程（没找到架构图不好意思）：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/159090c7e4cb48c3b028fbd031bcc1e7~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SaFR9FsnPR98f8EH08yjHM83Y+Y=" alt="img"></p><p>每一个微服务调用时，都会使用hystrix的command方式（上图的左上角那个），然后使用command同步的，或者是响应式的，或者是异步的，判断电路是否熔断（顺着图从左往右看），</p><p>如果断路则走降级fallback；</p><p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施（看图的第5步）；</p><p>如果走完了，执行成功了，则走run()方法，获取response，但是这个过程如果出错了，则继续走降级fallback.</p><p>同时，看图最上面有一个后缀是health的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p><p><strong>容器与服务编排引擎</strong></p><p>从物理机到虚拟机，从虚拟机到容器；从物理集群到open stack，open stack到kubernetes；科技不断的变化，我们的认知也没刷新。</p><p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。 虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。虚拟机依赖于hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致hypervisor在某些方面被认为是一种操作系统。</p><p>一旦 hypervisor安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层Runtime，然后供应用程序运行。</p><p>对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如LXC或libcontainer)安装在主机操作系统(通常是Linux变种)之上。在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p><p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味相比于虚拟机，单个操作系统能够承载更多的容器。云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p><p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p><p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。正因为如此，容器才拥有极为出色的轻量化特性。</p><p>我们最常用的容器是daocker，网址如下<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>容器编排：</p><p>过去虚拟机可以通过云平台open stack管理虚拟化，容器时代如何管理容器呢？这就要看看容器编排引擎了。</p><p><strong>Apache mesos</strong></p><p>mesos是基于master，slave架构，框架决定如何利用资源，master负责管理机器，slave会定期的将机器情况报告给master，master再将信息给框架。master是高可用的，因为zk，也有leader的存在。下面是架构图</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/39a21281f9334b1b853f04a48107336b~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=WPM760vVO3zapa972giTo+2WRLY=" alt="img"></p><p><strong>kubernetes</strong></p><p>kubernetes是最近十分火热的开源容器编排引擎，具体可以参考kubernetes中文文档</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/596e958431f54c18a22592150ca8c103~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=yG+jZsDug8lqC7rMQSawQEqBlQI=" alt="img"></p><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，先说说每一个Kubernetes节点内部，kubelet管理全局全局pod，而每一个pod承载着一个或多个容器，kube-proxy负责网络代理和负载均衡 。</p><p>Kubernetes节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p><p><strong>服务网格化</strong></p><p>待更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作业总结的不错，转载一下～&lt;/p&gt;
&lt;p&gt;作者：tengshe789&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://urlify.cn/zYJzee&quot;&gt;https://urlify.cn/zYJzee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下文，你将看到业界主流微服务框架的核心原理</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM 内存布局及细节分析</title>
    <link href="http://ai.mak.cn/2020/02/12/java/JVM%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"/>
    <id>http://ai.mak.cn/2020/02/12/java/JVM%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2023-01-09T07:30:20.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本JVM系列属于本人学习过程当中总结的一些知识点，目的是想让读者更快地掌握JVM相关的知识要点，难免会有所侧重，若想要更加系统更加详细的学习JVM知识，还是需要去阅读专业的书籍和文档。</p><p>本文主题内容：</p><ul><li>JVM 内存区域概览</li><li><strong>堆区的空间分配是怎么样？堆溢出的演示</strong></li><li><strong>创建一个新对象内存是怎么分配的？</strong></li><li><strong>方法区 到 Metaspace 元空间</strong></li><li><strong>栈帧是什么？栈帧里有什么？怎么理解？</strong></li><li>本地方法栈</li><li>程序计数器</li><li><strong>Code Cache 是什么？</strong></li></ul><blockquote><p><strong>注：请 区分 JVM内存结构（内存布局） 和 JMM（Java内存模型）这两个不同的概念！</strong></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略 ，保证了 JVM 的高效稳定运行。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750982daa7b6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>上图描述了当前比较经典的Java内存布局。（堆区画小了2333，按理来说应该是最大的区域）</p><p>如果按照线程是否共享来分类的话，如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f47509829e2b5b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><blockquote><p>PS：线程是否共享这点，实际上理解了每块区域的实际用处之后，就很自然而然的就记住了。不需要死记硬背。</p></blockquote><p>下面让我们来了解下各个区域。</p><h2 id="一、Heap-堆区）"><a href="#一、Heap-堆区）" class="headerlink" title="一、Heap (堆区）"></a>一、Heap (堆区）</h2><h3 id="1-1-堆区的介绍"><a href="#1-1-堆区的介绍" class="headerlink" title="1.1 堆区的介绍"></a>1.1 堆区的介绍</h3><p>我们先来说堆。堆是 OOM故障最主要的发生区域。它是内存区域中最大的一块区域，被所有<strong>线程共享</strong>，存储着<strong>几乎所有</strong>的实例对象、数组。<strong>所有的对象实例以及数组都要在堆上分配</strong>，但是随着JIT编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，<strong>所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</strong>。</p><blockquote><p>延伸知识点：JIT编译优化中的一部分内容 - <strong>逃逸分析</strong>。</p><p>推荐阅读：<a href="https://link.juejin.cn/?target=https://www.hollischuang.com/archives/2583">深入理解Java中的逃逸分析</a></p></blockquote><p>Java堆是垃圾收集器管理的主要区域，因此<strong>很多时候也被称做“GC堆”</strong>。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代</strong>。再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor空间</strong>等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><h3 id="1-2-堆区的调整"><a href="#1-2-堆区的调整" class="headerlink" title="1.2 堆区的调整"></a>1.2 堆区的调整</h3><p>根据Java虚拟机规范的规定，<strong>Java堆可以处于物理上不连续的内存空间中</strong>，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以在运行时动态地调整。</p><p><strong>如何调整呢？</strong></p><p>通过设置如下参数，可以设定堆区的初始值和最大值，比如 <code>-Xms256M -Xmx 1024M</code>，其中 <code>-X</code>这个字母代表它是JVM运行时参数，<code>ms</code>是<code>memory start</code>的简称，中文意思就是内存初始值，<code>mx</code> 是 <code>memory max</code>的简称，意思就是最大内存。</p><p><strong>值得注意的是，在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力 所以在线上生产环境中 JVM的<code>Xms</code>和 <code>Xmx</code>会设置成同样大小，避免在GC 后调整堆大小时带来的额外压力。</strong></p><h3 id="1-3-堆的默认空间分配"><a href="#1-3-堆的默认空间分配" class="headerlink" title="1.3 堆的默认空间分配"></a>1.3 堆的默认空间分配</h3><p>另外，再强调一下堆空间内存分配的大体情况。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750983bf3620~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>这里可能就会有人来问了，你从哪里知道的呢？如果我想配置这个比例，要怎么修改呢？</p><p>我先来告诉你怎么看虚拟机的默认配置。命令行上执行如下命令，就可以查看当前JDK版本所有默认的JVM参数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="variable constant_">XX</span><span class="symbol">:+PrintFlagsFinal</span> -version</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对应的输出应该有几百行，我们这里去看和堆内存分配相关的两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">[Global flags]</span><br><span class="line">...</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">InitialSurvivorRatio</span>                      <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">    <span class="type">uintx</span> <span class="variable">NewRatio</span>                                  <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">java version <span class="string">&quot;1.8.0_131&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_131</span>-b11)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.131</span>-b11, mixed mode)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:InitialSurvivorRatio</td><td>新生代Eden&#x2F;Survivor空间的初始比例</td></tr><tr><td>-XX:NewRatio</td><td>Old区&#x2F;Young区的内存比例</td></tr></tbody></table><p>因为新生代是由Eden + S0 + S1组成的，所以按照上述默认比例，如果eden区内存大小是40M，那么两个survivor区就是5M，整个young区就是50M，然后可以算出Old区内存大小是100M，堆区总大小就是150M。</p><h3 id="1-4-堆溢出-演示"><a href="#1-4-堆溢出-演示" class="headerlink" title="1.4 堆溢出 演示"></a>1.4 堆溢出 演示</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * @author Richard_Yi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">            byteList.<span class="built_in">add</span>(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Java</span> <span class="selector-tag">heap</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">Dumping</span> <span class="selector-tag">heap</span> <span class="selector-tag">to</span> <span class="selector-tag">java_pid32372</span><span class="selector-class">.hprof</span> ...</span><br><span class="line"><span class="selector-tag">Heap</span> <span class="selector-tag">dump</span> <span class="selector-tag">file</span> <span class="selector-tag">created</span> <span class="selector-attr">[7774077 bytes in 0.009 secs]</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> &quot;<span class="selector-tag">main</span>&quot; <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Java</span> <span class="selector-tag">heap</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">jvm</span><span class="selector-class">.HeapOOMTest</span><span class="selector-class">.main</span>(HeapOOMTest.<span class="attribute">java</span>:<span class="number">18</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>-XX:+HeapDumpOnOutOfMemoryError</code> 可以让JVM在遇到OOM异常时，输出堆内信息，特别是对相隔数月才出现的OOM异常尤为重要。</p><h2 id="创建一个新对象-内存分配流程"><a href="#创建一个新对象-内存分配流程" class="headerlink" title="创建一个新对象 内存分配流程"></a>创建一个新对象 内存分配流程</h2><p>看完上面对堆的介绍，我们趁热打铁再学习一下JVM创建一个新对象的内存分配流程。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750983d600e5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发<code>Young Garbage Collection</code>，即<code>YGC</code>。垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区。Survivor区分为so和s1两块内存空间。每次<code>YGC</code>的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果<code>YGC</code>要移送的对象大于Survivor区容量的上限，则直接移交给老年代。一个对象也不可能永远呆在新生代，就像人到了18岁就会成年一样，在JVM中<code>－XX:MaxTenuringThreshold</code>参数就是来配置一个对象从新生代晋升到老年代的阈值。默认值是<strong>15</strong>， 可以在Survivor区交换14次之后，晋升至老年代。</p><blockquote><p>上述涉及到一部分垃圾回收的名词，不熟悉的读者可以查阅资料或者看下本系列的垃圾回收章节。</p></blockquote><h2 id="二、Metaspace-元空间"><a href="#二、Metaspace-元空间" class="headerlink" title="二、Metaspace 元空间"></a>二、Metaspace 元空间</h2><p>在 HotSpot JVM 中，**永久代（ ≈ 方法区）**中用于**存放类和方法的元数据以及常量池**，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code>，为此我们不得不对虚拟机做调优。</p><p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？（详见：<a href="https://link.juejin.cn/?target=http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation</a>）：</p><ol><li>由于 PermGen 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li><li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li></ol><p>根据上面的各种原因，PermGen 最终被移除，<strong>方法区移至 Metaspace，字符串常量池移至堆区</strong>。</p><p>准确来说，Perm 区中的<strong>字符串常量池被移到了堆内存</strong>中是在Java7 之后，Java 8 时，PermGen 被元空间代替，<strong>其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区</strong>。比如<code>java/lang/Object</code>类元信息、静态属性<code>System.out</code>、整形常量 <code>100000</code>等。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。（和后面提到的直接内存一样，都是使用本地内存）</p><blockquote><p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p></blockquote><p><strong>对应的JVM调参：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:MetaspaceSize</td><td>分配给Metaspace（以字节计）的初始大小</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td></tr><tr><td>-XX:MinMetaspaceFreeRatio</td><td>在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td></tr><tr><td>-XX:MaxMetaspaceFreeRatio</td><td>在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td></tr></tbody></table><blockquote><p>延伸阅读：关于Metaspace比较好的两篇文章。</p><blockquote><ol><li><a href="https://link.juejin.cn/?target=http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html">Metaspace in Java 8</a></li><li><a href="https://link.juejin.cn/?target=http://lovestblog.cn/blog/2016/10/29/metaspace/">lovestblog.cn&#x2F;blog&#x2F;2016&#x2F;1…</a></li></ol></blockquote></blockquote><h2 id="三、-Java-虚拟机栈"><a href="#三、-Java-虚拟机栈" class="headerlink" title="三、 Java 虚拟机栈"></a>三、 Java 虚拟机栈</h2><p>对于每一个线程，JVM 都会在线程被创建的时候，创建一个单独的栈。也就是说虚拟机栈的生命周期和线程是一致，并且是线程私有的。除了Native方法以外，Java方法都是通过Java 虚拟机栈来实现调用和执行过程的（需要程序技术器、堆、元空间内数据的配合）。所以Java虚拟机栈是虚拟机执行引擎的核心之一。而Java虚拟机栈中出栈入栈的元素就称为「栈帧」。</p><p><strong>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</strong></p><blockquote><p>栈对应线程，栈帧对应方法</p></blockquote><p>在活动线程中， 只有位于栈顶的帧才是有效的， 称为<strong>当前栈帧</strong>。正在执行的方法称为<strong>当前方法</strong>。在执行引擎运行时， 所有指令都只能针对当前栈帧进行操作。而<code>StackOverflowError</code> 表示请求的<strong>栈溢出</strong>， 导致内存耗尽， 通常出现在递归方法中。</p><p>虚拟机栈通过pop和push的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现了异常，会进行异常回溯，返回地址通过异常处理表确定。</p><p>可以看出栈帧在整个JVM 体系中的地位颇高。下面也具体介绍一下栈帧中的存储信息。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750984563c2a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h3 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h3><blockquote><p>局部变量表就是<strong>存放方法参数和方法内部定义的局部变量的区域</strong>。</p></blockquote><p><strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</strong>。</p><p>这里直接上代码，更好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果局部变量是Java的8种基本基本数据类型，则存在局部变量表中，如果是引用类型。如new出来的String，局部变量表中存的是引用，而实例在堆中。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/27/16f4750984f45f1e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h3 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2. 操作栈"></a>2. 操作栈</h3><p><strong>操作数栈（Operand Stack）**看名字可以知道是一个栈结构。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当JVM为方法创建栈帧的时候，在**栈帧**中为方法创建一个</strong>操作数栈**，保证方法内指令可以完成工作。</p><p>还是用实操理解一下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author Richard_yyf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperandStackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>编译生成<code>.class</code>文件之后，再反汇编查看汇编指令</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; javac OperandStackTest.java</span></span><br><span class="line"><span class="quote">&gt; javap -v OperandStackTest.class &gt; 1.txt</span></span><br><span class="line">复制代码</span><br><span class="line">  public int sum(int, int);</span><br><span class="line"><span class="code">    descriptor: (II)I</span></span><br><span class="line"><span class="code">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="code">    Code:</span></span><br><span class="line"><span class="code">      stack=2, locals=3, args_size=3 // 最大栈深度为2 局部变量个数为3</span></span><br><span class="line"><span class="code">         0: iload_1 // 局部变量1 压栈</span></span><br><span class="line"><span class="code">         1: iload_2 // 局部变量2 压栈</span></span><br><span class="line"><span class="code">         2: iadd    // 栈顶两个元素相加，计算结果压栈</span></span><br><span class="line"><span class="code">         3: ireturn</span></span><br><span class="line"><span class="code">      LineNumberTable:</span></span><br><span class="line"><span class="code">        line 10: 0</span></span><br><span class="line"><span class="code">复制代码</span></span><br></pre></td></tr></table></figure><h3 id="3-动态连接"><a href="#3-动态连接" class="headerlink" title="3. 动态连接"></a>3. 动态连接</h3><p>每个栈帧中包含一个在常量池中<strong>对当前方法的引用</strong>， 目的是<strong>支持方法调用过程的动态连接</strong>。</p><h3 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h3><p>方法执行时有两种退出情况：</p><ul><li>正常退出，即正常执行到任何方法的返回字节码指令，如 <code>RETURN</code>、<code>IRETURN</code>、<code>ARETURN</code>等</li><li>异常退出</li></ul><p>无论何种退出情况，都将返回至方法当前<strong>被</strong>调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给<strong>能够处理</strong>的栈帧</li><li>PC 计数器指向方法调用后的下一条指令</li></ul><blockquote><p>延伸阅读：<a href="https://link.juejin.cn/?target=https://louluan.blog.csdn.net/article/details/50412126">JVM机器指令集图解</a></p></blockquote><h2 id="四、本地方法栈"><a href="#四、本地方法栈" class="headerlink" title="四、本地方法栈"></a>四、本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，<strong>它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong>。</p><h2 id="五、程序计数器"><a href="#五、程序计数器" class="headerlink" title="五、程序计数器"></a>五、程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间。是线程私有的。<strong>它可以看作是当前线程所执行的字节码的行号指示器</strong>。什么意思呢？</p><blockquote><p><strong>白话版本：因为代码是在线程中运行的，线程有可能被挂起。即CPU一会执行线程A，线程A还没有执行完被挂起了，接着执行线程B，最后又来执行线程A了，CPU得知道执行线程A的哪一部分指令，线程计数器会告诉CPU。</strong></p></blockquote><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换并分配处理器执行时间的方式来实现</strong>的，CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于CPU 时间片轮限制，众多线程在并发执行过程中，<strong>任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</strong>。</p><p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。此区域也不会发生内存溢出异常。</p><h2 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以<strong>使用Native函数库直接分配堆外内存</strong>，然后通过一个<strong>存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作</strong>。这样能在一些场景中显著提高性能，因为<strong>避免了在Java堆和Native堆中来回复制数据</strong>。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。如果内存区域总和大于物理内存的限制，也会出现OOM。</p><h2 id="Code-Cache"><a href="#Code-Cache" class="headerlink" title="Code Cache"></a>Code Cache</h2><p>简而言之， <strong>JVM代码缓存是JVM将其字节码存储为本机代码的区域</strong> 。我们将可执行本机代码的每个块称为 <code>nmethod</code> 。该  <code>nmethod</code>可能是一个完整的或内联Java方法。</p><p>实时（JIT）编译器是代码缓存区域的最大消费者。这就是为什么一些开发人员将此内存称为JIT代码缓存的原因。</p><p>这部分代码所占用的内存空间成为CodeCache区域。一般情况下我们是不会关心这部分区域的且大部分开发人员对这块区域也不熟悉。如果这块区域OOM了，在日志里面就会看到 <code>java.lang.OutOfMemoryError code cache</code>。</p><h3 id="诊断选项"><a href="#诊断选项" class="headerlink" title="诊断选项"></a>诊断选项</h3><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>PrintCodeCache</td><td>false</td><td>是否在JVM退出前打印CodeCache的使用情况</td></tr><tr><td>PrintCodeCacheOnCompilation</td><td>false</td><td>是否在每个方法被JIT编译后打印CodeCache区域的使用情况</td></tr></tbody></table><blockquote><p>延伸阅读 <a href="https://link.juejin.cn/?target=https://www.baeldung.com/jvm-code-cache">Introduction to JVM Code Cache</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《深入理解Java虚拟机》 - 周志明</li><li>《码出高效》</li><li><a href="https://link.juejin.cn/?target=http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html">Metaspace in Java 8</a></li><li><a href="https://link.juejin.cn/?target=https://louluan.blog.csdn.net/article/details/50412126">JVM机器指令集图解</a></li><li><a href="https://link.juejin.cn/?target=https://www.baeldung.com/jvm-code-cache">Introduction to JVM Code Cache</a></li></ol><p>作者：Richard_Yi<br>链接：<a href="https://juejin.cn/post/6844904033396719624">https://juejin.cn/post/6844904033396719624</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本JVM系列属于本人学习过程当中总结的一些知识点，目的是想让读者更快地掌握JVM相关的知识要点，难免会有所侧重，若想要更加系统更加详细的学习</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DDD架构思想的旧瓶新酒</title>
    <link href="http://ai.mak.cn/2020/01/31/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/DDD%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%A7%E7%93%B6%E6%96%B0%E9%85%92/"/>
    <id>http://ai.mak.cn/2020/01/31/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/DDD%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%A7%E7%93%B6%E6%96%B0%E9%85%92/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2023-01-09T07:06:19.610Z</updated>
    
    <content type="html"><![CDATA[<p>DDD 和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 DDD-China 2019 上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。</p><p>DDD、DSL 和 DCI</p><p>DDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：</p><ol><li>首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。</li><li>第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；</li><li>第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；</li><li>第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；</li><li>第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。</li></ol><p>张晓龙此前曾在 DDD-China 峰会和 ArchSummit 全球架构师峰会上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。</p><p>DDD 和 DSL 的融合有三点：</p><ol><li>面向领域；</li><li>模型的组装方式；</li><li>分层架构演进。</li></ol><p>DSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。</p><p>DCI 的作用主要体现在两方面：</p><p>首先，DCI 助力 DDD 战术设计：</p><ol><li>显式的对 ROLE 建模，解决了贫血模型与充血模型之争；</li><li>一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；</li><li>当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；</li></ol><p>其次，DCI 助力 DDD 代码落地：</p><ol><li>对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。</li><li>根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；</li><li>小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。</li></ol><p>张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。</p><p>开发团队真的需要 DDD</p><p>DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。</p><p>对于开发团队而言，需要关注以下几点：</p><ul><li>首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；</li><li>其次是团队中各个角色都围绕领域模型开展工作；</li><li>第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？</li></ul><p>更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。</p><p>在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：</p><ol><li>嵌入式软件；</li><li>兼业务复杂性和技术复杂性；</li><li>软件规模大，功能复杂，特性交叉；</li><li>高质量，高性能，高可靠等要求。</li></ol><p>张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：领域专家下团队，和团队一起交流和协作；教练指导，开展战训营，定期 review；架构、设计、编码和工程实践：</p><p>（1）DCI，DSL，正交设计，组合式设计；</p><p>（2）编码规范和纪律；</p><p>（3）嵌入式 C&#x2F;C++ 最佳实践；软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。</p><p>DDD 与微服务</p><p>DDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是微服务的热风让人们才重新发现了领域驱动设计的价值。</p><p>微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。</p><p>“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。</p><p>对于业界目前流行的中台概念，张晓龙同样也有自己的看法：</p><p>中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。</p><p>中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。</p><p>DDD 的困局</p><p>最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？</p><p>张晓龙总结了 DDD 目前面临的几大困局：</p><ul><li>首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；</li><li>第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C# 写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；</li><li>第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；</li><li>第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；</li><li>第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。</li></ul><p>针对以上几大困局，张晓龙也给出了自己的解决方案：</p><ol><li>培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；</li><li>领域专家和团队一起工作，确保大家头脑中的画面是一致的；</li><li>DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。</li></ol><p>软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DDD 和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 DDD-China 2019 上，InfoQ 记者带着这</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何做好团队的目标和技术规划</title>
    <link href="http://ai.mak.cn/2020/01/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BD%AC%E5%9E%8B%E5%81%9A%E7%AE%A1%E7%90%86%EF%BC%9F%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E4%B8%93%E5%AE%B6%E5%85%AC%E5%BC%8010%E5%A4%A7%E6%80%9D%E8%80%83/"/>
    <id>http://ai.mak.cn/2020/01/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E8%BD%AC%E5%9E%8B%E5%81%9A%E7%AE%A1%E7%90%86%EF%BC%9F%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E4%B8%93%E5%AE%B6%E5%85%AC%E5%BC%8010%E5%A4%A7%E6%80%9D%E8%80%83/</id>
    <published>2020-01-16T16:00:00.000Z</published>
    <updated>2023-01-09T07:03:51.112Z</updated>
    
    <content type="html"><![CDATA[<p>作者 | 威视</p><p>因为信任，所以简单。</p><h1 id="团队的定位是什么？——做正确的事"><a href="#团队的定位是什么？——做正确的事" class="headerlink" title="团队的定位是什么？——做正确的事"></a>团队的定位是什么？——做正确的事</h1><p><strong>定位</strong></p><p>团队的定位是重要的事情之一，一旦有了偏差，后续做得越多错得越多。确定团队的定位花了我很长时间，中间还发生了一次组织变化，和两任主管有多次讨论。</p><p>首先，这个团队配置在 CRO 线，肯定要为风险管理业务服务；同时，这又是一支能力团队，还要考虑和业务团队的协同关系。最终，我确定了3点：</p><p>1、能力建设为主，同时也需要有业务抓手；2、不做业务团队已经做得好的事情；3、立志高远，勇攀高峰，要做就做到最好。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/6528ff77be034b029dbe2e1ed7ff8146~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=UJX5UP/jxYYQSTbCJYF2HvpHAGo=" alt="img"></p><p><strong>壁垒与价值</strong></p><p>不夸张地说，现在是NLP领域的大航海时代，新算法层出不穷，日新月异，后浪各种把前浪碾死在沙滩上。尤其是 BERT 横空出世之后，整个 NLP 的研究范式都发生了变化，从原来的 task-specific 的模型结构设计转变到语言模型 pretrain+ 下游任务 finetuning 的模式，预训练模型是含金量高的工作。研究一下预训练模型，你会发现这是个需要海量金钱+数据+技术才能玩的游戏。</p><p>这就陷入两难：如果搞预训练模型，没那么多资源；如果不搞，用开源模型做下游任务，实际上很难有什么技术壁垒。其实就算你真的搞出什么新算法可以充当技术壁垒，可能两三个月之后就又有人做出了更强的结果。</p><p>困境的根源在于，目前 NLP 算法这个领域发展速度太快了，在高速变化的领域是很难形成壁垒的。所以，我们需要结合自身所处的环境，寻找变化不那么快的东西。</p><p>我经过好多天的考虑之后，认为沉淀风险管控知识可以作为壁垒。原因：1）风险知识随时间有变化，但速度明显比算法慢很多；2）CRO 线在这方面有一定积累，也需要用于实际业务管控，并沉淀到产品。</p><p>所以，团队的宗旨我定义为：基于知识驱动的 NLP 算法团队。为 CRO 线乃至集团沉淀风险知识，并提供不同层次的服务：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/77ba2392806e46beaf003babdf868140~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=1gDXVXOSBrMTRtF5fHUCxqMWuiE=" alt="img"></p><p>图：4层服务体系</p><p>最近，CRO 线在清华举办了 AI 与安全研讨会，会上张钹院士谈到了第三代人工智能，尤其强调了其中知识的核心作用；我们走访中科院信工所，对方的宗旨也是建设基于知识驱动的算法，和业界发生的共鸣，更坚定了我们走这条道路的决心和信心。</p><h1 id="团队需要什么能力？"><a href="#团队需要什么能力？" class="headerlink" title="团队需要什么能力？"></a>团队需要什么能力？</h1><p>先要搞清楚团队所处的环境。</p><p>阿里是一个什么结构的组织？</p><p>有人说是矩阵式的，有人说是树+网状的，我不知道确切的答案。不过，如果把每个小团队看作节点的话，有 2 点是确定的：</p><p>1、体量巨大，各种节点（业务、产品、工程、算法）种类繁多数量大。2、单元节点之间比较容易发生跨大团队甚至跨 BU 的联系，条件合适可以发生协同关系。</p><p>继续观察，你会发现：</p><p>1、你所需要的一切资源几乎都能找到提供者，而且往往不止一个。2、你也可以给各种需求节点提供服务，只要还在你的能力范围内。3、由于规模巨大，需求节点和资源节点相互之间往往不知道对方在哪。</p><p>基于以上，我认为一个身处中台的算法团队，需要具备 4 项能力：连接-生产-传播-服务。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/5ba28acdb6fa409bbc0a468898b1eec1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=DbacGSV92U2N2e4JBRUy/441ogg=" alt="img"></p><p>图：能力中台的算法团队需要具备的能力</p><p><strong>四项能力</strong>连接：就是寻找到自己所需要的资源，筛选出其中最优的，建立长期稳定的合作关系。比如算法团队需要的爬虫、标注工具、分布式模型训练工具、模型的评测工具等，都能在公司范围内获取，就没必要刀耕火种从头开始自己建设了。</p><p>生产：这是传统意义上算法工程师的工作，指获取数据后产出效果和效率达标的算法模型，并上线。</p><p>对算法的要求，主管的主管早有论述：算法要全！算法要强！算法要快！算法要便宜！精炼简洁，振聋发聩，细化一下就有：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/fdd2e8385819434bb0aa1d9edef2157a~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=E6c2yAC2gawzxlFw+jrT6NYp0zA=" alt="img"></p><p>图：对算法的要求</p><p>传播：针对中台的算法团队提的要求，因为你需要让目标业务节点知道你的存在，知道你的能力项，以及细节。</p><p>服务：如果是专属某业务的算法团队，只需要考虑该业务下的 SLA 即可；如果是中台的算法团队，还需要考虑如何满足不同业务节点的需求，同时又不至于做开发和维护成本很高的个性化定制，避免随着接入业务的增长各种资源的开销也随着线性增长。</p><p>能力雷达图</p><p>团队的能力雷达图是由成员的个人能力长板组成的。（话越短意思越长）</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/2488b35deb6f443bb572c4fea605b4c6~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=+NWpUO+WUW9X6VW33cg2ZCZdIrg=" alt="img"></p><p>图：团队能力雷达图</p><h1 id="组织与个人的关系"><a href="#组织与个人的关系" class="headerlink" title="组织与个人的关系"></a>组织与个人的关系</h1><p><strong>为什么需要一个组织呢？</strong></p><p>先从一个现象出发：在小区业主和物业公司的纠纷斗争中，业主获胜的概率很低。从人数、个体的教育背景和素质来看，业主都占据绝对优势，可是为什么会输？</p><p>粗略分析，大体有三个原因：</p><p>1、共同利益，目标明确。物业的目标非常清晰，就是为了从业主那里赚钱，这也是物业人员的共同利益。业主人多，情况各有不同，各自的利益诉求差异大，容易被分化。2、组织严密，相互协同。物业内部有明确的分工，平时也长期一起工作，相互间有信任感，能够进行配合。业主彼此之间往往是陌生人，缺乏信任感，难以统一行动，是原子化的散点。3、局部相对优势。相对单个业主，物业具有明显力量优势。比如，物业有资金，而业主因为缺乏信任很难筹措资金。</p><p>好，看出来了，小规模组织的力量可以超过大规模原子化散点存在的个体集合的力量。</p><p><strong>组织为个人提供什么？</strong></p><p>1、组织能使资源增效组织能把各种资源组合成有机的整体，使各种分散的力量形成合力，从而产生大于这些资源和力量机械总和的效能。这个原理 2000 多年前亚里斯多德就论述过了，后来马克思又更严密地论述过一次。</p><p>2、组织是实现目标的依托：个人可以依托组织的能力和资源去做事，而组织的能力和资源远大于个人，所以依托组织的时候，个人能够实现比单打独斗模式大得多的目标。</p><p>举个例子，我们团队做了 UGC 场景效果超越开源模型的预训练模型，每个同学都可以在这个预训练模型的基础上去做下游的有监督学习任务，起点就比别人高。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/6ef40045a7c24c8484f6cc5c51a67d06~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=PXw9uWM/F9pOr2Iwy6RaXXnEF2E=" alt="img"></p><p>个人为组织提供什么？</p><p>是否有短板不是那么重要，关键是要有长板，能够对组织的能力雷达图做贡献。</p><p>这一节留一个思考题：公司设置主管这个职位的目的是什么？是为了像幼儿园阿姨那样，保障每一个小朋友都有自己喜欢的玩具，高高兴兴上学来，平平安安回家去？</p><h1 id="招聘团队需要的人才"><a href="#招聘团队需要的人才" class="headerlink" title="招聘团队需要的人才"></a>招聘团队需要的人才</h1><p><strong>招聘为什么特别重要？</strong></p><p>世界有个普遍规律：在前序阶段做严格的控制会大大降低后序阶段的实现难度，比如数据标注、写代码、模型中的预处理等等。人招进来之后是要用要管的，招聘的时候高标准严要求，后续管理会轻松很多；如果降低标准甚至放水，后续管理付出的代价远远高于招聘时偷懒省的功夫。</p><p>所以，我花了至少 1&#x2F;3 的时间在招聘上。对的，至少 1&#x2F;3 ，你没有看错。从 2019 年 2 月到现在，社招弄了 300+ 份简历；校招 100+ 份简历。从统计数据看，每 100 份简历产生 2-3 个offer，入职 1-2 个人。从 100 份简历中招来的人绝对比 10 份简历中招来的省心很多。</p><p>我给算法团队找来过不少人，both 社招 and 校招，具体的展开讨论见彩蛋部分的【招聘】。</p><p><strong>招聘要考察哪些能力？</strong></p><p>招聘，首先要确定 job model 。限于篇幅，这里只讨论“生产”环节所需要的能力。所处的时代背景：快速变化，新算法层出不穷。</p><p>不变的是什么：数学基础、计算机基础、动手能力。</p><p>我们很难预测新技术的具体实现，但是当新技术出现的时候，需要能够快速地分析、学习、掌握。而且，我们经常要解决从来没有遇到过的新问题，这就要求候选人在面对没见过的问题时具备分析判断，在具体约束条件下找完整解决方案的能力。另外，在复杂的业务场景里，问题经常没有确定性的答案，我们往往通过对过程的合理性来判断整个方案是否合乎要求。寻找答案的过程很少有一帆风顺的，大概率会遭遇挫折，非常需要候选人不断尝试不断修正去抵达终点。</p><p>至于教育背景、之前从业经历，反而不怎么重要。我不赞成对于毕业好几年的社招候选人还要参考毕业学校、最高学位，甚至本科学校是否 985 ——如果一个人能力强，是不需要靠学校学位来旁证的，直接用行动证明就行了。</p><p>对于候选人的考察，我往往从基础的硬技能、创新性&#x2F;开放性思维、精神素质三方面考察。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/7e71712194ee4d0ba0df6e8c1d3b2007~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=FYB76YS/UogTIGQJUWZuAyfRitM=" alt="img"></p><p><strong>硬技能</strong></p><p>数学：概率论与数理统计、矩阵论、随机过程。计算机基础：操作系统、组成原理、数据结构。算法能力：领域内主流模型的演进，优缺点对比；在具体设定的场景下选择合适的方案。动手：C++&#x2F;python&#x2F;Java （什么？你说matlab？工业界里这个不算编程语言）。</p><p>有人说，面试过程中要求做代码测试，就像相亲时要求看存款证明一样残暴。我赞同这个说法，因为不少候选人听到要写代码就高傲地拒绝了。我给大家推荐一个在线代码测试工具：<a href="http://collabedit.com/">http://collabedit.com</a></p><p>从我长期的观察情况看，发展得好的算法同学，动手能力都比较强。毕竟，算法工程师，首先是一个工程师。</p><p><strong>创新性&#x2F;开放性思维</strong></p><p>其实我还经常干比代码测试更令人发指的事情——做智力题。这个不是我的创新，是学来的，甚至是直接找网上流传的面试题换个马甲来用。</p><p>前面的硬技能，看的往往是结果；这里对思考能力的考察，看的是过程：是否有方法论，思路是否清晰，是否言之有据。所以，这种问题的面试方式往往是讨论式。</p><p>如果候选人能够完成，最后再请TA做个总结，观察归纳要点的能力，视线的高度。</p><p>有些候选人结束面试后仍然会继续思考，给出更好的回答。</p><p><strong>精神素质</strong></p><p>公司对人才的要求是：乐观、皮实、聪明、自省。</p><p>你看，四个词里面有两个都在强调坚韧不拔。在面试过程中，我会看候选人在解题不顺时的表现，有时甚至故意小刺激一下观察候选人的反应，偶尔还会故意中途改变限制条件。阿里内部竞争激烈，经常需要拥抱变化，如果心理承受力脆弱，是不适合当同路人的。</p><p>还有一点很重要：自我驱动力。这是从降低对内管理成本来要求的，后面会具体说。</p><p>在我看来，硬技能、创新性&#x2F;开放性思维和精神素质缺一不可。即使这三方面我都满意了，如果主管，主管的主管， HR 对候选人明确提出疑虑，我一般不申辩直接放弃掉。因为，他们比我 level 高，阅人无数，往往不会错。</p><p>有的同学会问：这样子做，会不会错失优秀人才？是的，我的方式几乎可以确保招进来的同学肯定是好的，但会漏掉一些优秀的候选人，不过这不会造成严重的后果。相比之下，招进来不合格的人才会有大麻烦。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/404549e33ce94da594413db49f862ef6~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=JA/uQn3ZWHKn1ama/8Fd6/nq6JI=" alt="img"></p><h1 id="用人"><a href="#用人" class="headerlink" title="用人"></a>用人</h1><p><strong>主管的角色是什么？</strong></p><p>以前有句话，叫做“火车跑得快，全靠车头带”，这说的是前动车时代。动车和高铁为什么比传统的火车速度更快？根本原因是：大多数车厢都能提供动力。</p><p>同样的，如果一个团队完全靠主管来驱动，来提供动力，主管很容易成为团队的瓶颈。我的团队成员，很多都是自己领域的高手，专业能力在我之上，我就应该顺应实际情况，不要拿自己的愚见去束缚同学们的发挥。因此，我的角色更多的是眺望远方，掌握方向盘，有时踩一下刹车；团队大多数同学一起构成动力引擎。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/757fb421954440359d6d6692c03e3e02~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=RrYuEbGNxS+AEqN+gS5HlhmTfGM=" alt="img"></p><p>图：动车&#x2F;高铁跑得快，是因为大多数车厢都提供动力</p><p><strong>对内管理模式</strong>一个不恰当的比喻：放羊。</p><p>这么做，堂而皇之的理由是“因为信任，所以简单”。技术层面的原因，对算法类同学做过程管理性价比太低。</p><p>算法类工作，创造性在其中占据重要地位，而创造性很难在过程中量化度量，也很难从外部观测现象来判断。比如：身边的同学坐在工位直视屏幕目不转睛，我不知道他到底是在思考论文中的公式还是在回味昨天晚上看的电影。再比如，我base在杭州，没办法知道团队内base北京的同学是不是在工作时间打游戏。</p><p>所以，我选择信任我的同学，只在一些必须监管的事项上把关，比如数据安全、安全生产等，其他事项一般不做过程管理，只做结果管理。得益于招聘时把关严格，绝大多数同学的自我驱动力都比较强，我并不用操心偷懒的事情；相反，偶尔需要操心一下少部分同学拼过了头的问题。关于这一点，更多的内容见彩蛋中的【认真生活，快乐工作】。</p><p>肯定有同学问：上面说的是不担心出工不出力，那么，怎么解释出力的问题呢？你难道不指导同学做项目吗？</p><p>我一般只给出项目的目标，有时给一个粗略的方案设想，有时不给。公司对于P6同学已经有“独当一面拿结果” 的要求，大家都应该具备独立作战的能力。而且，按照前面说的，团队内大部分同学都应该是提供动力的车厢，没必要依赖我。人是否有自我意志？这个问题我不知道答案。但我知道，如果一个人认为主意是自己想出来的，决定是自己做的，会更有动力去实现。尝试做决策，尝试完成不确定的任务，都有利于自己的成长。</p><p>思考题：管理有很多种style。有的主管喜欢自己做需求分析，然后拆解细化到原子级的技术问题，让下属做执行。这种模式，和“放羊”模式相比，从主管视角，以及下属视角看，各有什么优缺点？</p><p>综合以上两点，我觉得放羊是可行的。而且，放羊这件事，羊倌也是要做很多工作的：选择合适的天气，找到草地，把羊群带到草地，放哨保护羊群，是不是？如果还要把青草割好喂给羊吃，那成什么了？</p><p>羊倌应该把更多的精力花在寻找丰美的草地，购买强壮的羊，与其他羊倌交流这些事情上，要是成天忙于喂羊，督促偷懒的羊快点吃草，拉开打架的羊这些内部事务，羊群怎么发展壮大？</p><p>鼓舞团队信心，最好的方式是什么？</p><p>痛痛快快地赢一次。如果不够，就两次。</p><p>接手团队的时候，在商业化方向上局势是很差的：去年三次PK竞品都输了，稳定性问题频发以至于新版本都无法发布……团队好几个人都扑在这一个阵地上干得很苦但就是拿不到结果。</p><p>这个时候我要是去发表个类似《至暗时刻》里丘吉尔那样让人热血沸腾的演讲是否可以解决问题？可能有短暂的强心剂作用，但是不长久，因为实际困难没解决。何况，我也肯定不具备丘吉尔的演说能力。最有用的办法，还是分析失败的原因，制定正确的打法，指导同学们获得一次成功。鼓舞信心最好的方式还是靠实实在在的成功。</p><p>结果大家都看到了，今年我们PK竞品的战绩是N：0，付费调用量上涨25倍以上。大家肯定好奇：正确的打法是什么样的呢？我放在后面“正确地做事”那一节讲。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/70b616e63c5b406e9b5702683079be59~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=cYh4Zy7LoedjxDz81O7VftfRNWY=" alt="img"></p><p><strong>做有吸引力的事情</strong></p><p>目标要定得高一些，有挑战性，达成的时候内心的成就感会更高一些。这个很容易理解，就好比你打游戏，虐了个菜，没多少快感；如果能赢下之前屡战屡败的对手，一定会兴奋很久。</p><p>目标定得太低，不仅不能逼出自己的潜力，还容易让自己关注于一些鸡毛蒜皮的小问题。</p><p>前几天，我的主管在一个项目 kick off 会上说，当你回首往事时，要有一件做过的事情能够拿出来吹牛逼，人生才有意义。深以为然。</p><p><strong>过程即享受</strong></p><p>在阿里的工作肯定是辛苦的，我没看到过谁能随随便便就成功。如果只是冲着收入来做工作，难免在过程中会感觉到很多痛苦。物质的刺激是短暂的，不管是加薪、年终奖，或者 option ，兴奋高兴个几天就过去了。如果喜欢自己做的事情，专注于工作本身，从中源源不断地获得成就感，就能做到虽然辛苦但是不痛苦。我家做饭的阿姨是拆迁户，坐拥 N 套房，每天仍然跑几家做饭，我问她为什么？她说，以前是开苍蝇馆子的，拆迁后没得开了，但是自己就是喜欢做饭。理想状况下就是要招聘这种人。</p><h1 id="采取什么工作模式？——正确地做事"><a href="#采取什么工作模式？——正确地做事" class="headerlink" title="采取什么工作模式？——正确地做事"></a>采取什么工作模式？——正确地做事</h1><p><strong>四个在线化</strong></p><p>互联网的本质是连接，最大价值也是连接。</p><p>这句话不知道是谁说的，第一次听说是在《计算机网络》课程上。互联网连接的可以是人和人，人和文档，人和数据，人和代码，人和……和一切你工作中需要的东西。</p><p>接手团队之后，我发现同学们的工作模式真的是自耕农一般：各做各的模型，各用各的数据，各读各的 paper ，完全是原子化的散点存在。说得不客气一点，除了聚餐的时候，平时感觉不到这是一个组织。也就是说，身处中国顶级互联网公司，大家却像农业社会时期一样在进行生产，当着不折不扣的“码农”。</p><p>团队里一个同学说得很好：相互间建立信任关系的最好办法是发生工作上的协同。我觉得，要发生工作上的协同，前提就是把工作相关的资源都在线化，与组织成员发生连接，于是，我设想做4个在线化。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/1350462efaad426fa60bc19fc7da8e48~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=GgMmbkiILV2QiUh+39RVJFBebOg=" alt="img"></p><p>图：文档、数据、代码、评测在线化</p><p>1、文档在线化：春节期间我建了个团队语雀，自己做顶层设计，写好框架，然后让同学们把业务、技术、资源、技术影响力等等和工作相关的内容都填写其中。这样子，每个同学都可以看到团队的各种信息和资源，以及其他人的工作。目前团队的语雀还对部分关联紧密的兄弟团队完全开放。</p><p>2、数据在线化：如果同学们各自管理自己的数据，形成数据孤岛不说，发生机器重装，或者转岗、离职，往往数据就丢了。接手的时候，能清理出来的有标签数据远远低于应有的数量，就是因为一直没有做数据的在线化管理。团队里的言奇同学做了样本大表项目，已经完成了将整个智能认知团队的全面标签数据在线化。这一点非常重要，后续在开发各种新模型，以及做预训练模型时，就拥有不同业务不同场景不同风险的大量数据，在短时间内取得了良好的效果。</p><p>3、代码在线化：这个正在进行中，预期 S2 结束时完成，出发点是：</p><p>a.代码是团队重要的技术资产，应该统一管理，提高安全性。b.在线化后方便团队协作，共享优秀代码c.基础性模块代码统一，降低维护成本</p><p>4、评测在线化：也在进行中，设想是在一些特定任务上做几种经典模型和确认无误的主流模型，能够一键实现自己的模型和前者的自动化比对，提升工作效率。除此之外还有个作用：经典模型的结果可以作为baseline，帮助验证深度模型的正确性。因为，你做了一个深度模型，效果好也就罢了，效果不好的时候都搞不清楚是模型不适用，还是自己的代码写错了。</p><p><strong>找对前进的方向</strong></p><p>主管最重要的职责之一是当同学们迷茫的时候明确前进的方向。</p><p>接着前面商业化的例子，详细情况是这样的：我们通过阿里云对外输出文本风险识别的算法能力做商业化，比如涉政、色情低俗、广告、辱骂等。我接手的时候，有 3-4 个同学全职投入这项工作，他们工作非常努力，干得也很辛苦，但是效果并不好， PK 竞品的时候并无胜算。出了什么问题呢？</p><p>分析之后，我发现以下问题：</p><p>1、确实是一个内容维度的问题，但只使用了分类模型一种方式。</p><p>分类模型适合解决静态标准的问题，并不适合及时响应业务上的快速变化。模型迭代更新的速度做到极限也只能是 T+1 或者 T+2 天，且人力消耗高。之前的主管为了解决这个问题，在分类模型中塞了一个风险词包，由算法同学维护更新，接到运营反馈的 badcase 之后手动添加到风险词包，然后定时推送到分类模型应用中。这个复杂的机制带来了词典的频繁构建，结果导致应用的稳定性问题频发，甚至已经无法更新。</p><p>2、缺乏顶层设计，同学们各自为战。</p><p>几个风险各自单独做模型，技术选型高度自由，百花齐放，starspace、SVM、CRF、kenlm、textCNN 都有，难以统一提升能力，维护的难度大。</p><p>3、做了过多的个性化定制，导致后续维护和升级的成本非常高。</p><p>几乎为每一个稍微大一点的用户都单独做了模型，付费调用量不大，模型倒是有了好几十个。同学们频繁地做模型的迭代更新（每周都至少有 1-2 次），占用大量人力。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/65f550d8f0c44a63994eb5bb1968cc76~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=5Oxtg8xrz23c28RLY+NT/mtTUiY=" alt="img"></p><p>怎么办呢？</p><p>建设技术体系去解决某一类问题，而不是某个技术点去解决某一个问题；结合安全业务的特点，设计可以强化通用算法效果的基础能力或处理框架。</p><p>——上面两句话不是我说的，来源于前主管。（插一句：本文还有一些内容来源于前主管和主管，向主管学习是提升自己的一个重要途径。）</p><p>具体来说，解法有几点：</p><p>明确风险词包、相似性检索、分类模型、风险知识图谱 4种手段适合完成的任务，且相互配合。</p><p>把风险词包从分类模型中拆出来，降低应用的复杂度，以及模型迭代的频率，解决稳定性问题。</p><p>分类模型的结构尽可能统一，标准尽可能不变，持续把效果做强。</p><p>自从 BERT 提出以来，NLP 问题的基本范式从原来的 task-specific 的模型结构设计转变到语言模型 pretrain+ 下游任务 finetuning 的模式。工作重点应该转向预训练模型与知识蒸馏。</p><p>由于目前对内的内容交互风险管控业务也在我的团队内，我就贴一张全局视角的问题分析与解决方案。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/473e250560c7490fa597f8a22f7a9318~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=5Ftnn1uwiA9QQh/kaeJYPcgqnPg=" alt="img"></p><p>图：全局视角的UGC风险管控思路</p><p>明确解法之后，同学们快速做了实践，到 4 月份就基本扭转了被动的局面，随后打了翻身仗，付费调用量增长 25 倍。现在模型的更新周期降低到以月为周期，稳定性大幅度提升，同学们也不再疲于奔命；而且，投入的人力也明显下降了。</p><h1 id="绩效的考核"><a href="#绩效的考核" class="headerlink" title="绩效的考核"></a>绩效的考核</h1><p>绩效考核决定了收益的分配，也是团队最重要的事情之一。</p><p>如果把团队比作一个模型，考核的标准就是 loss function。loss function 一旦确定，模型的优化方向也就定了，团队成员会按照利益最大化原则沿着这个方向调整自己的 action 。</p><p>所以，考核标准的设计需要体现团队的定位、价值和需求；在执行的过程中需要满足平等性。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/2aff117f76484ba69ddfb1ecb95366a0~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=UMK9wZNmd5f8qXwMqgVpxBlliGA=" alt="img"></p><p>图：绩效考核的3个维度</p><p><strong>业务结果</strong></p><p>阿里有个文雅的说法是：为过程鼓掌，为结果付酬。</p><p>还有个话糙理不糙的说法是：没有过程的结果是垃圾，没有结果的过程是放屁。</p><p>你觉得哪一句对你的胃口就看哪一句。</p><p>配置在业务BU的算法团队，帮助业务目标达成肯定是首要任务。今年以来，AI 行业也都渐渐挤出泡沫，回归本质，开始强调创造业务价值了。</p><p>能力进步</p><p>从价值观上讲，今天的最好表现是明天的最低要求。</p><p>从业务需求讲，量级越来越大，业务形态越来越复杂，老算法是解决不了新问题的。</p><p>从团队利益讲，成员的能力进步可以扩展团队的能力雷达图。</p><p>参加百阿的时候，一位讲师的发言我到现在都记得：在座的各位最终都是要离开阿里的，离开的时候无非两种情况：1，公司不要你了；2，你不要公司了。怎么离开，取决于是你的能力提高快，还是公司对能力的要求提高快。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/f3bf4c3b91084677866b01ca8c5452ed~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673852176&x-signature=z+zLEm/MRmazluGTuUVxuDycBAs=" alt="img"></p><h1 id="技术影响力"><a href="#技术影响力" class="headerlink" title="技术影响力"></a>技术影响力</h1><p><strong>什么是技术影响力？</strong></p><p>有形物：Paper 、竞赛成绩、著作、专利、 ATA 文章等。</p><p>无形物：对内对外合作、对外 PR 、对内分享、组织机构任职、参会做报告等。</p><p>为什么要建设技术影响力？</p><p>团队的四项基本能力：连接、生产、传播、服务，其中“传播”就需要技术影响力。</p><p>CRO 线的使命“四心”中，有一条叫“让监管单位放心”。技术影响力是让监管放心的有效方式之一。</p><p>商业化需要资质：搞过投标的同学都知道。</p><p>招聘需要名气：对候选人讲解我们的技术水平时，如果用内部业务举例，不容易产生共鸣；但是如果直接亮出顶会论文、刷榜名次之类的，对方马上就懂了。</p><p>个人的市场价值需要证明：这些东西都可以作为个人技术品牌，到哪都能带着。</p><p>假定一个场景，有人问：“你说这个业务做得好，说明你的算法水平高。会不会换一个人能够做得更好？”你打算怎么回答这个问题？</p><p>再假定一个场景，你打算给自己团队的算法能力定性为“xx领先”或者“xx第一梯队”，如果没有硬核的技术影响力做支撑，是否还能理直气壮？</p><p><strong>平等性</strong></p><p>团队协作的基础是团结，团结的基础是平等。</p><p>平等性最重要的体现，就是在考核过程中尽可能只衡量以上三项，不去考虑地域、教育背景、从业经历、之前表现、颜值、性别、个人动向等等其他因素。我认为：结果体现的就是能力，直截了当，最能服众。</p><p>当然，这个世界上是否有完全客观的判断？或者，完全客观的判断如果存在，是不是就是最合适的？我不知道答案。不过，我觉得不能因为做不到完全的平等而放弃追求平等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者 | 威视&lt;/p&gt;
&lt;p&gt;因为信任，所以简单。&lt;/p&gt;
&lt;h1 id=&quot;团队的定位是什么？——做正确的事&quot;&gt;&lt;a href=&quot;#团队的定位是什么？——做正确的事&quot; class=&quot;headerlink&quot; title=&quot;团队的定位是什么？——做正确的事&quot;&gt;&lt;/a&gt;团队的定位</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
