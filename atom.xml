<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2022-11-14T03:31:10.728Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java  50+ Spring 常用注解</title>
    <link href="http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-12-10T16:00:00.000Z</published>
    <updated>2022-12-01T07:47:37.199Z</updated>
    
    <content type="html"><![CDATA[<p>使用注解的优势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.采用纯java代码，不在需要配置繁杂的xml文件</span><br><span class="line"></span><br><span class="line">2.在配置中也可享受面向对象带来的好处</span><br><span class="line"></span><br><span class="line">3.类型安全对重构可以提供良好的支持</span><br><span class="line"></span><br><span class="line">4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</span><br></pre></td></tr></table></figure><p><strong>Spring部分</strong></p><p><strong>1、声明bean的注解</strong></p><p>@Component 组件，没有明确的角色</p><p>@Service 在业务逻辑层使用（service层）</p><p>@Repository 在数据访问层使用（dao层）</p><p>@Controller 在展现层使用，控制器的声明（C）</p><p><strong>2、注入bean的注解</strong></p><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><p><strong>3、java配置类相关注解</strong></p><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><p><strong>4、切面（AOP）相关注解</strong></p><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><p><strong>5、@Bean的属性支持</strong></p><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</p><p>Protetype （每次调用新建一个bean）</p><p>Request （web项目中，给每个http request新建一个bean）</p><p>Session （web项目中，给每个http session新建一个bean）</p><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><p><strong>6、@Value注解</strong></p><p>@Value 为属性注入值（属性上）</p><p>支持如下方式的注入：</p><p>》注入普通字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;Michael Jackson&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入操作系统属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;systemPropreties[&#x27;os.name&#x27;]&#125;&quot;)</span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure><p>》注入表达式结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;@&#123; T(java.lang.Math).radom() * 100 &#125;&quot;)</span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><p>》注入其它bean属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入文件资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)</span><br><span class="line">Resource file</span><br></pre></td></tr></table></figure><p>》注入网站资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;http://www.baidu.com&quot;)</span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><p>》注入配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;book.name&#125;&quot;)</span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure><p>注入配置使用方法：</p><p>① 编写配置文件（test.properties）</p><p>book.name&#x3D;《三体》</p><p>② @PropertySource 加载配置文件(类上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</span><br></pre></td></tr></table></figure><p>③ 还需配置一个</p><p>PropertySourcesPlaceholderConfigurer的bean。</p><p><strong>7、环境切换</strong></p><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p><strong>8、异步相关</strong></p><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><p><strong>9、定时任务相关</strong></p><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><p><strong>10、@Enable*注解说明</strong></p><p>这些注解主要用来开启对xxx的支持。</p><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p><p>@EnableAsync 开启异步方法的支持</p><p>@EnableScheduling 开启计划任务的支持</p><p>@EnableWebMvc 开启Web MVC的配置支持</p><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableCaching 开启注解式的缓存支持</p><p><strong>11、测试相关注解</strong></p><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(&quot;SpringJUnit4ClassRunner.classs&quot;)</span><br></pre></td></tr></table></figure><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(&quot;classes=&#123;TestConfig.class&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>SpringMVC部分</strong></p><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>@RequestMapping：@RequestMapping(“&#x2F;path”)表示该控制器处理所有“&#x2F;path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>value:指定请求的实际地址，指定的地址可以是URI</p><p>Template 模式</p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等</p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application&#x2F;json,text&#x2F;html;</p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：用在方法的参数前面。</p><p>@RequestParam</p><p>String a &#x3D;request.getParameter(“a”)。</p><p>@PathVariable:路径变量。如 参数与大括号里的名字一样要相同。</p><p><strong>SpringBoot部分</strong></p><p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：</p><p>@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p><p>@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p><p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p><p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><p>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p><p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>@Import：用来导入其他配置类。</p><p>@ImportResource：用来加载xml配置文件。</p><p>@Autowired：自动导入依赖的bean</p><p>@Service：一般用于修饰service层的组件</p><p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>@Bean：用@Bean标注方法等价于XML中配置的bean。</p><p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p><p>@Inject：等价于默认的@Autowired，只是没有required属性；</p><p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。</p><p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><p>@Resource(name&#x3D;”name”,type&#x3D;”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>二、注解列表如下</p><p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p><p>@ComponentScan：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>@Configuration ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p><p>@EnableAutoConfiguration ：自动配置。</p><p>@ComponentScan ：组件扫描，可自动发现和装配一些Bean。</p><p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p><p>@RestController：注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p><p>@Autowired：自动导入。</p><p>@PathVariable：获取参数。</p><p>@JsonBackReference：解决嵌套外链问题。</p><p>@RepositoryRestResourcepublic：配合spring-boot-starter-data-rest使用。</p><p>三、JPA注解</p><p>@Entity：@Table(name&#x3D;”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p><p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p><p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p><p>@Column：如果字段名与列名相同，则可以省略。</p><p>@Id：表示该属性为主键。</p><p>@GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE,generator &#x3D; “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p><p>@SequenceGeneretor(name &#x3D; “repair_seq”, sequenceName &#x3D; “seq_repair”, allocationSize &#x3D; 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p><p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch&#x3D;FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>@JoinColumn（name&#x3D;”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p><p>五、全局异常处理</p><p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p><p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p><p>六、项目中具体配置解析和使用环境</p><p>@MappedSuperclass： 1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</p><p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p><p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p><p>@Column：</p><p>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p><p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。具体如下：</p><p> 1 name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</p><p> 2 unique属性：unique属性表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table注解中的@UniqueConstraint</p><p> 3 nullable属性：nullable属性表示该字段是否可以为null值，默认为true</p><p> 4 insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</p><p> 5 updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</p><p> 6 insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</p><p> 7 columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</p><p> 8 table属性：table属性定义了包含当前字段的表名</p><p> 9 length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</p><p> 10 precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</p><p>  具体如下：   1.double类型将在数据库中映射为double类型，precision和scale属性无效</p><p>  2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准</p><p>  3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效</p><p>  4.precision和scale属性只在BigDecimal类型中有效</p><p>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p><p>4.@Column标注也可置于属性的getter方法之前</p><p>@Getter和@Setter（Lombok）</p><p>@Setter：注解在属性上；为属性提供 setting 方法</p><p>@Getter：注解在属性上；为属性提供 getting 方法</p><p>@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法  @Setter：注解在属性上；为属性提供 setting 方法  @Getter：注解在属性上；为属性提供 getting 方法  @Log4j2 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似  @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法  @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法</p><p>@EqualsAndHashCode:默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p><p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p><p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，只能自己手写了  @NonNull：注解在属性上，如果注解了，就必须不能为Null  @val:注解在属性上，如果注解了，就是设置为final类型，可查看源码的注释知道</p><p>当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</p><p>@javax.persistence.PostLoad：加载后。</p><p>@javax.persistence.PrePersist：持久化前。</p><p>@javax.persistence.PostPersist：持久化后。</p><p>@javax.persistence.PreUpdate：更新前。</p><p>@javax.persistence.PostUpdate：更新后。</p><p>@javax.persistence.PreRemove：删除前。</p><p>@javax.persistence.PostRemove：删除后。</p><p>1）数据库查询</p><p>@PostLoad事件在下列情况下触发：</p><p>执行EntityManager.find()或getreference()方法载入一个实体后。</p><p>执行JPQL查询后。</p><p>EntityManager.refresh()方法被调用后。</p><p>2）数据库插入</p><p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p><p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p><p>@PostPersist事件在数据已经插入进数据库后发生。</p><p>3）数据库更新</p><p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p><p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p><p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p><p>4）数据库删除</p><p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p><p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p><p>@PostRemove事件在实体从数据库中删除后触发。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40753536/article/details/81285046">https://blog.csdn.net/weixin_40753536/article/details/81285046</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用注解的优势：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>思考错误的工作方式</title>
    <link href="http://ai.mak.cn/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    <id>http://ai.mak.cn/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</id>
    <published>2019-12-01T16:00:00.000Z</published>
    <updated>2022-12-01T05:48:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>《浪潮之巅》的作者吴军，在《得到》专栏里，提及了Google刚进中国时候的一件事。</p><p>刚开始，Google总部对中国研发团队的评价非常低，因为“出工不出活儿”，北京的三四个工程师都抵不上Google总部的一个工程师。</p><p>后来吴军帮忙分析了原因，他发现，那些工程师都不善于找到最重要的工作并优先完成它们。</p><blockquote><p>中国研发团队里，所有的工程师都是新人，没有人告诉他们该如何工作；</p><p>而在Google总部，新员工只是一小部分，所以很容易在有经验的员工带动下快速掌握工作技能。</p></blockquote><p>之后两年，Google总部的工程师陆续来中国帮助团队梳理工作方式，而中国团队也会去Google总部交流，这种情况就得到了改善，中国研发团队也最终得到了总部的认可。</p><p>Google工程师这么聪明的一群人，尚且需要学习正确的工作方式，才能有效产出，何况大多数人？</p><p>我们一直都认为，如果一个人智商情商正常、学习和工作意愿高，就一定能出成绩。</p><p>然而，我带过很多人，也招过很多人，却发现一个奇怪的现象：</p><blockquote><p>有一些人，十分有意愿学习，非常努力，智商情商也都正常，然而工作产出却非常低，甚至不如很多资质低于他们的人。</p></blockquote><p>我一直百思不得其解，一度怀疑自己看人不准。直到前阵子看到吴军的这段叙述，才幡然醒悟。</p><p>我仔细回想了这些人的工作方式，将他们与产出高的人相比，发现他们无一例外都存在三个问题。</p><p><strong>一、只关注任务，不关注目标</strong></p><p>假如你的老板正在飞机上，还有1小时落地，下来之后需要给客户做一个重要汇报，而你需要给他做一份PPT。</p><p>但因为你错估了时间，导致PPT草草做完，而且发现其中一些数据没有，你怎么办？</p><p><strong>低效人士</strong>的做法是：疯狂地找数据，最后可能数据有了，然而PPT没有来得及做完，或者质量不高。</p><p><strong>一般人</strong>的做法是：找人帮自己一起找数据。</p><p>而<strong>最高效</strong>的那些人，会根据老板此次汇报的目的，判断这些数据在其中的作用大小：</p><p>如果作用不大，那么就把时间花在完善重要页数、而不是找数据上，如果很关键，那么就找其他人帮忙，或者找一些替代数据。</p><p>这三类人之间的差距，其实就是<strong>任务导向与目标导向的差距</strong>。</p><p>我此前的咨询公司，在做高潜人才研究的时候，有个发现：</p><p>高潜力的人才是有共性的，具备这些共性的人，几乎做什么都能做好，而不具备的，几乎做任何工作都会障碍重重。</p><p>这其中，有一项共性就是<strong>Result-driven</strong>（结果驱动）。</p><p>那些高产出的人，未必动作更快，而是更善于判断，什么事情对结果是最有效的，然后，用尽一切办法保证结果达成，而不是死守着原有的工作任务。</p><p>实际上，<strong>结果驱动不仅仅是一种工作习惯，更是一种思维方式</strong>。</p><p>这种以终为始的思维模式，是我自己刻意训练的最有用的思维模式之一。</p><p>比如思维训练营里，有学员问我：“如何让自己对一个行业有真知灼见？ ”</p><p>想想看，如果是你，会如何回答？ </p><p>我的回答方式，是反问她：“ 具备真知灼见的目的是什么呢？是想让客户更加信任你、还是想让老板看到你的进步？”</p><p>假设你是希望客户信任你，觉得你懂他，那你要做的，就是看这个行业里的客户有什么痛点，然后针对这几个痛点，下功夫研究和分析，有更多洞见，然后借机沟通出去。</p><p>了解一个行业，是一个太大的话题，没有目标，根本无从下手。</p><p>所以，<strong>没有结果驱动的思维，而仅仅死守着工作任务，最终就是，出工不出活儿</strong>。</p><p><strong>二、应激式工作，而非统筹式工作</strong></p><p>如果你观察周围的同事，会发现，整天风风火火、急得上蹿下跳、各种任务来回切换的人，有时候产出并不高。</p><p>看他们工作，就好像打地鼠一样，打完一个，另一个又冒上来，连看的人都跟着焦虑起来。</p><p>而另一类人，他们做事专注、条理清晰、看起来很淡定，但最后，多困难的事儿都默默搞定了。</p><p>两者的差别就在于，第一类人总<strong>是应激式</strong>工作。</p><p>他们每天起来的第一件事，不是规划当天的工作，而是马上投入工作，以至于到了下班之后，发现还有很多事情没做完，而没做完的，可能又是最重要的。</p><p>另外，领导临时给个任务、客户临时有个要求、同事临时要个数据，他们都会停下手里的事情，去忙这些，最终，在任务的切换上花费了巨大的精力。</p><p>我跟公司的运营打过一个比方：</p><blockquote><p>假设你每项工作任务平均半小时可以做完，而任务之间的切换通常也要半小时，如果你经常一项不做完就切换到下一项，就算每个任务中途切换一次吧。</p><p>那就意味着，8小时的工作时间，你至少有4小时都花在任务切换上了。</p></blockquote><p>这种应激式工作方式无疑是低效的。</p><p>那什么才是高效的呢？统筹式工作。</p><p>真正的统筹式工作，有几个特征：</p><p><strong>1.有计划地工作</strong></p><p>我通常周日晚上就会排好下周每天的工作，而每天早上会排好当天的工作。</p><p>而且，任务清单在工作的时候一直开着、实时更新，完成一项删掉一项，临时增加一项就插入相应的时间段，当天完不成的、非紧急的任务，我就改成第二天的日期。</p><p>这种方式，会让自己很有掌控感，多少事情来了，都不会乱了阵脚。</p><p>当然，在做计划的时候，你需要为高价值问题分配最多专门的时间。</p><p>因为，大部分人在80%的时间里都是做无用功，根本原因就是没搞清楚真正要解决的问题。</p><p><strong>2.形成自己固定的时间习惯</strong></p><p>比如我的习惯是：</p><blockquote><p>在上午做需要烧脑的事情、在交通工具上听书、在饭后效率不高的时候集中回复微信消息和留言、在等人的时候构思下篇文章主题、在疲劳的时候刷一下公众号、在傍晚的时候跟团队开会、在晚上做一个简单总结。</p></blockquote><p>这种习惯，一方面把不同难度的工作跟自己的效率波峰波谷相匹配，达到效率最大化；</p><p>另一方面，我会清楚地知道，5分钟、10分钟、30分钟，对我来说分别可以干什么，这样就不会一有碎片时间，就习惯性地刷朋友圈了。</p><p><strong>3.及时记录、每天总结</strong></p><p>当你正在工作的时候，老板布置了一个任务、客户又来了一个问题，你会如何呢？</p><p>很多人就直接扑到临时任务上去了，但真正好的做法是：</p><p>如果不是十万火急，你可以快速用关键词记在笔记本上，不需要任何思考，然后马上回到刚才的任务，做完再看笔记本。</p><p>另外，你在一天当中，学到了什么、犯了什么错误，当时也要记下来，因为过了那个时候，你很快就会忘，然后继续犯这个错误。</p><p>当然，这些记录，晚上都需要进行整理。</p><p>我曾说过，此前8年多的顾问生涯里，成长最快的那半年，我每天都坚持写工作日记。</p><p>另外，记录还有一个好处，就是可以减轻大脑负担。</p><p>每天的例行工作、自己常犯的错误，这些都可以列清单。</p><p><strong>你的大脑是用来思考的，是很宝贵的，别把一支笔就可以做的事情，强加给你的大脑来做。</strong></p><p><strong>三、几乎从不“偷懒”</strong></p><p>“懒癌”是第一生产力。仔细盘点一下，我们哪样创新不是因为懒呢？</p><blockquote><p>不想走路，有了汽车；不想爬楼，有了电梯；不想打扫，有了扫地机器人……</p></blockquote><p>工作中的大部分事情，并不是一次性的，而是持续的，那么就可以在第一次做的时候，搭好框架。</p><p>比如，我让运营每周做一次数据分析，这个事情是重复性的，所以高效的做法是：</p><p>建一张excel表格，把固定需要分析的参数都做好公式，每周只需要把导出来的源数据贴进去，刷新之后参数就出来，然后只需要看参数来得出结论。</p><p>当然，这里所说的“偷懒”，不仅是善用工具，还包括善用他人。</p><blockquote><p>比如，你从来没做过数据分析，那么就先去找找前人怎么做的；</p><p>比如，你有自己的团队或者实习生，那就不要做任何他们就可以做的事情；</p><p>再比如，去运营社群，摸索出一套群主激励机制，比你自己去做群主，要高效得多。</p></blockquote><p>所以，这三个让你Work Smart的工作方式，听起来难吗？一点也不，而且你很可能也听说过。</p><p>但是，为什么很多人做不到呢？我观察下来，有几个障碍：</p><p><strong>1.工作环境所限</strong></p><p>很多人的工作性质，就不是结果导向型的，而是任务导向型的。</p><p>他的工作岗位要求他做的，就是完成任务，至于背后的出发点，不需要知道。而且，领导有可能就是考核努力、考核苦劳，而不是考核产出。</p><p>实际上，工作性质对一个人的思维方式、行为习惯的影响，大到超乎想象。</p><p>你去看，刚毕业的时候，一个学校一个专业的同学，看起来差不多。</p><p>但过了几年，你会发现，只要接触一个人几分钟，听他说几句话，就能大致判断出他的职业。</p><p>再极端一些的，多年前我曾经因为要帮客户设计流程，去他们的产线观察生产过程。</p><p>在噪音极大、灯光昏暗的厂房里，我看着流水线工人机械地盯着机器、等待换箱，几个小时下来，我自己也开始反应迟钝、敏锐度下降了。</p><p><strong>2.没有资深的人辅导</strong></p><p>从开头的案例可以看出，Google工程师那么优秀的一群人，在从校园进入公司之后，也需要有经验的人辅导。</p><p>但很多公司并不像Google那样，重视对新人工作方式的培养，将Work Smart提到非常高的位置。</p><p>他们往往只重视教员工What（需要做哪些事情、用什么工具等等），却没有How（如何聪明地做这些事情）和Why（这些事情对公司、对客户有什么帮助、要达到何种目的），导致员工的聪明才干发挥不出来，没有成就感。</p><p><strong>3.思维方式固化</strong></p><p>一部分人，会在工作多年之后，发现工作性质和工作环境的负面影响，醒悟过来想要改变。</p><p>然而，从学校踏入社会的这几年，是思维和工作方式形成的关键几年，如果任务导向、应激式努力、闷头蛮干的工作方式在大脑中固化了，形成了下意识思维，是很难扭转过来的。</p><p>我带过几个人，此前的工作经历都是任务式、应激式的，在跟他们合作的时候，的确能够感受到他们与自己固有思维作斗争的痛苦与挣扎。</p><p>然而，并不是每个人最终都能挣扎出来、突破自我的。</p><p>所以，<strong>年轻时候的工作选择，你选择的不只是一份工作，而是一种思维习惯、工作方式、价值观甚至生活方式</strong>。</p><p>在初入职场的几年，处于何种工作环境、跟谁一起工作、被谁辅导工作，足以影响你的下半辈子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《浪潮之巅》的作者吴军，在《得到》专栏里，提及了Google刚进中国时候的一件事。&lt;/p&gt;
&lt;p&gt;刚开始，Google总部对中国研发团队的评价非常低，因为“出工不出活儿”，北京的三四个工程师都抵不上Google总部的一个工程师。&lt;/p&gt;
&lt;p&gt;后来吴军帮忙分析了原因，他发现</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>7条高效能的“黄金定律”</title>
    <link href="http://ai.mak.cn/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/"/>
    <id>http://ai.mak.cn/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2022-12-01T04:42:28.683Z</updated>
    
    <content type="html"><![CDATA[<p>作者：洞见Neo</p><p>来源：洞见（ID：DJ00123987）</p><hr><p>听过一个笑话。</p><p>有个人跑去问上司：我都有10年工作经验了，为什么你还是不给我涨工资？</p><p>上司说：你不是有10年工作经验，你是把一年工作经验用了10年。</p><p>我认识一个人就是如此，他经常向人吐槽：“我兢兢业业干了6年，老板交代的事我连一句抱怨都没有，加班加点地做完，到头来还不如刚来一两年的新人。”</p><p>他说得悲愤，我只替他难过。</p><p>他的努力，除了证明自己的低效之外，没有任何用处。</p><p><strong>让人成功的，从不是“work hard”，而是“work smart”。</strong></p><p>掌握高效的方法，远胜过低效的苦熬。</p><p>真正厉害的人，其实都赢在了思维上。</p><p><strong>我接触过许多行业精英，这些人无一例外都掌握了一些高效能的黄金定律。</strong></p><p><strong>总结起来，有7条。</strong></p><p>现在看到还不算晚，学会它，像成功者一样思考。</p><p><strong>01</strong></p><p><strong>蘑菇定律</strong></p><p>我们都想在工作上大展拳脚、一战成名，但实际情况却是，默默坐在座位上，不被关注，只能做点杂事。</p><p><strong>得不到指导和提携，偶尔还会被指责、批评，就像长在阴暗角落里的蘑菇，自生自灭。</strong></p><p><strong>这种现象有个专业名词，叫做蘑菇定律。</strong></p><p>得不到阳光又没有肥料的蘑菇，只有长到足够高、足够壮的时候，才会被人关注。</p><p>而那段在黑暗中结茧的时光，是最最难熬的。</p><p>放弃谁都会，只有懂得蛰伏的人，才会羽化成蝶。</p><p>惠普公司前CEO卡莉·费奥丽娜从斯坦福毕业之后，第一份工作是一家地产公司的电话接线员。</p><p>她每天的任务，是打字、复印、收发文件、整理文件。</p><p>虽都是些杂货，但她穿梭于公司的每个角落，观察学习，渐渐对大部分业务都熟练于心。</p><p>蛰伏很久之后，她终于等来了自己的机会。</p><p>公司经纪人问她是否还愿意干点别的什么，于是她得到了一次撰写文稿的机会。</p><p>也就是这次撰文，改变了她的一生。当你被看作是“蘑菇”时，再怎么拼命强调自己是“灵芝”都没用。</p><p><strong>只有利用环境，尽快成长，从蘑菇堆里脱颖而出，人们才会看见你的价值。</strong></p><p><strong>02</strong></p><p><strong>备份定律</strong></p><p>程序员编程的时候，一定会有一个备份。</p><p>万一硬盘故障、代码丢失，没有备份，损失就会相当惨重。</p><p>备份，就是另一手准备。</p><p>人生也是如此。</p><p><strong>当你只给自己留了一种选择，一旦那扇门被关上，便只能作困兽之斗。</strong></p><p>备份，就是另一种可能。</p><p>西方一位哲人说过：“学习用左手剪指甲，因为你的右手未必永远管用。”</p><p><strong>这就是备份定律：思路清晰的人，凡事都有两手准备，从来不是一根筋走到底。</strong></p><p>早年间，我认识一个人，那时他在一家报社做记者。</p><p>别人都羡慕他稳定，但他不相信什么“铁饭碗”，选择自己出去创业。</p><p>三年下来，买了两套房子。</p><p>大家又羡慕他有钱有闲，下半生可以躺平，但他又决定去找一份正式工作。</p><p>几百人的竞争中，被录取为上市公司高级总监。</p><p>如今，他一边工作，一边做自己的项目。</p><p>他说，我不会再担心自己被淘汰。</p><p>人人都希望岁月静好，可现实往往是大江奔流。</p><p>可怕的不是突然的变故，而是遭遇变故之后，连选择的余地都没有。</p><p>给自己多一份备份，就是给人生多一种可能。</p><p><strong>03</strong></p><p><strong>奥卡姆剃刀定律</strong></p><p>你知道自己一周内，处于高效工作状态的时间有多长吗？</p><p>研究数据表明：人平均每周工作45小时，其中有17个小时是根本没有效率的。</p><p><strong>很多人习惯以“多”取胜，但想做的事越多，能完成的就越少。</strong></p><p><strong>于是，我们每日身心疲惫，又成果寥寥。</strong></p><p>想改变现状，首先要学会简化你的工作。</p><p>14世纪，逻辑学家奥卡姆提出一条“剃刀定律”，拉丁文为lex parsimoniae，意思就是简约法则：</p><p><strong>像拿起剃刀一样，把多余的步骤剃掉，把复杂的事情简单化。</strong></p><p><strong>两步可以做成，就不要三步。</strong></p><p>刘慈欣的科幻小说《三体》中有一段故事让我印象非常深刻。</p><p>来自各国的军事家聚在一起，讨论对付敌方游轮“审判日”号的方案，要消灭所有敌人，又不能毁掉船上的硬盘信息。</p><p>有人说用间谍潜伏，有人说用中子弹，有说用化学毒气，甚至还有说用次声波武器……极尽复杂之能事，却没一个可行方案。</p><p>只有一位办事直接果断的警官，说了一句非常简单的话：“两岸立两根柱子，中间拉上纳米丝，船一经过，就会被切割。”</p><p>在场人无不惊叹。</p><p>高手总喜欢一招制敌，击中要害，决不会啰啰嗦嗦大战300回合再结束。</p><p>能化繁为简的人，都抄“近道”走向了成功。</p><p><strong>04</strong></p><p><strong>沃尔森定律</strong></p><p>我们努力提升专业技能，却常忽略了另一件重要的事情：信息。</p><p><strong>很多人比你厉害，并不是能力比你强，而是知道的比你多。</strong></p><p>美国企业家S·M·沃尔森提出过一条定律：把信息和情报放在第一位，金钱就会滚滚而来。</p><p>终身学习的时代，聪明人都知道什么才是让自己变得重要的“加分项”。</p><p>美国弗洛伦萨州有两个年轻人，一个叫约翰，一个叫哈里，同时应聘进入一家蔬菜贸易公司。</p><p>3个月后，约翰直升组长，工资翻倍，哈里还在原地踏步。</p><p>哈里不满，质问老板，老板没有正面解答他的疑惑，而是说：现在公司准备订一批土豆，你去打听看看。</p><p>半小时后，哈里急匆匆跑回来汇报，“集农蔬菜批发中心”有土豆卖。</p><p>老板问，多少钱一斤？有几家在卖？</p><p>哈里愣了一下，转身跑出去问。</p><p>又过了半小时，他回来向老板一一汇报。</p><p>这次老板问他，库存有多少？质量怎么样？能给多少折扣？</p><p>哈里还是不知道，准备再回去问。</p><p>老板叫住了他，把约翰喊了过来。</p><p>约翰有条不紊地说：“20公里外的‘集农蔬菜批发中心’有3家卖土豆的，其中两家是0.9美元一斤，一家是0.8美元一斤。</p><p>对比发现，0.8美元的不但便宜，质量还要更好。</p><p>我跟他们谈了一下，最低0.7美元可以拿到，他们库存有500吨，有货车，可以免费送货……”</p><p>一个不用临时出门打听，就知道市场的实时动态，把握着咨询和信息的人，无需竞争，就已经赢了。</p><p><strong>想要抓住机会，就先学会发现机会。</strong></p><p><strong>比别人先获得情报，并迅速采取行动，这样的你，想不成功都难。</strong></p><p><strong>05</strong></p><p><strong>苹果定律</strong></p><p>如果一堆苹果，有好有坏，你先吃哪个？</p><p>最明智的答案是，先吃好的，把坏的扔掉。</p><p>因为，如果你先吃坏的，好的也会慢慢变坏，于是你永远也吃不到甘甜的好苹果。</p><p>这条“苹果定律”，在工作中也同样适用。</p><p>有时候，让我们晕头转向的，并不是因为多大的工作量，而是我们分不清轻重缓急，不知道该先做什么。</p><p>其实，<strong>先做哪件事，比做了多少事，更为重要。</strong></p><p>戴尔·卡耐基曾说过一个故事：</p><p>著名的心理治疗专家山德尔博士，用非常简单的方法治愈了一位病人。</p><p>这位病人是芝加哥一家大公司的高级主管。</p><p>当他初次来到山德尔的诊所，整个人都处于紧张、不安的状态，时刻都有崩溃的危险。</p><p>他说，他的办公室有3大张写字台，堆满了报表和文件，事情似乎永远都干不完，快把他逼疯了。</p><p>山德尔听过之后只给了一点建议：回去之后，把办公室全部清理干净，只留下最重要的文件。</p><p>病人照他说的办，清理干净写字台，又把留下的重要文件一一处理完。</p><p>之后，事情一到，立马办完。</p><p>再也没有堆积如山的工作威胁着他，他的身体也渐渐恢复了健康。</p><p>这也是时间管理的第一要义：<strong>永远先做最重要的事。</strong></p><p><strong>否则，空把精力耽误在不甚重要的事上，真正要紧的事只会被拖延到时间的死角，无暇也无力处理。</strong></p><p><strong>06</strong></p><p><strong>标杆定律</strong></p><p>上世纪70年代末80年代初，日本成为世界企业界学习的榜样。</p><p>在美国学习日本的运动中，施乐公司提出了名为“标杆定律”的管理方式：竞争对手的水平，就是改进自己的标杆。</p><p>放在今天，这条定律依然是帮我们接近成功的不二法则：<strong>你憎恶的那些对手，都是你最好的老师，最精准的标杆。</strong></p><p>挪威著名剧作家亨利·易卜生写作的时候，总把与他名气相当的剧作家斯特林堡的画像放在桌上，一边写作，一边看看画像。</p><p>有人不解，他说：“斯特林堡是我的死对头，但我不去伤害他，把他放在桌上，让他激励我写作。”</p><p>正是在斯特林堡“目光”的注视下，易卜生完成了《玩偶之家》《社会支柱》等经典之作。</p><p>哪有那么多“丧”，不过是在面对竞争时，你满嘴都是吐槽、挑刺和嫉妒。</p><p>但不与对手过招，你又如何进步？</p><p>瞄准你身边最优秀的人，把他们当做免费的拔高班。</p><p>正是因为对手的存在，你才会持续不断地变强。</p><p>**07<br>**</p><p><strong>卡贝定律</strong></p><p><strong>有时候，成功需要一点格局，这个格局名叫“放弃”。</strong></p><p>美国电话电报公司前总裁卡贝就给员工提出过一条建议：放弃有时比争取更有意义，它是创新的钥匙。</p><p>这就是后来被奉为经典的“卡贝定律”。</p><p>巴菲特有个私人飞行员叫Mike Flint，曾为美国四任总统开过飞机，但他想在事业上做出更大的成就。</p><p>他去请教巴菲特，巴菲特让他写下想要达成的25个目标。</p><p>写完之后，巴菲特又让他圈出其中最重要的5个。</p><p>巴菲特问：你现在知道该怎么做了吧？</p><p>Flint说：知道了，我马上开始着手于这5个目标，另外20个放在闲暇时间再做。</p><p>巴菲特摇摇头：不，你错了，那些你没有圈出来的目标，正是你应该全力避免的事，不要花任何时间和精力在它们上面。</p><p>如果你空有一腔热血，却始终在无足轻重的事情上摸爬滚打、费尽心思，那不是执着，而是愚蠢。</p><p><strong>当方向错了的时候，停下来也是一种进步。</strong></p><p>弄清自己的擅长，了解自己的力量，只有选对了方向，才有可能看见希望。</p><p>当你紧握双手，里面什么也没有；当你打开双手，世界就在你手中。</p><p>爱因斯坦曾说：“如果给我一个小时，去解答一道关于我生死的问题，我会先花55分钟弄清楚这道题到底在问什么。</p><p>一旦清楚了它到底在问什么，剩下的5分钟足以解答这个问题。”</p><p>你看，想法决定做法，做法决定活法。</p><p>你与高手之间，差的只是思维方式的不同。</p><p>了解并掌握这7条黄金定律，让你懂得在最关键的环节用力。</p><p>高效能，才能事半功倍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：洞见Neo&lt;/p&gt;
&lt;p&gt;来源：洞见（ID：DJ00123987）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;听过一个笑话。&lt;/p&gt;
&lt;p&gt;有个人跑去问上司：我都有10年工作经验了，为什么你还是不给我涨工资？&lt;/p&gt;
&lt;p&gt;上司说：你不是有10年工作经验，你是把一年工作经验用了10年。</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构的缓存、限流、分布式锁、幂等的使用方式</title>
    <link href="http://ai.mak.cn/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://ai.mak.cn/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2022-12-01T04:33:31.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong></p><hr><p>互联网应用发展到今天，从单体应用架构到 SOA 以及今天的微服务，随着微服务化的不断升级进化，服务和服务之间的稳定性变得越来越重要，分布式系统之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠，微服务很重要的一个特质就是需要保证服务幂等，保证幂等性很重要的前提需要分布式锁控制并发，同时缓存、降级和限流是保护微服务系统运行稳定性的三大利器。</p><p>随着业务不断的发展，按业务域的划分子系统越来越多，每个业务系统都需要缓存、限流、分布式锁、幂等工具组件， distributed-tools 组件(暂未开源)正式包含了上述分布式系统所需要的基础功能组件。</p><p>distributed-tools 组件基于 tair、redis 分别提供了 2 个 springboot starter ，使用起来非常简单。</p><p>以使用缓存使用 redis 为例， application.properties 添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis.extend.hostName=127.0.0.1</span><br><span class="line">redis.extend.port=6379</span><br><span class="line">redis.extend.password=pwdcode</span><br><span class="line">redis.extend.timeout=10000</span><br><span class="line"></span><br><span class="line">redis.idempotent.enabled=true</span><br></pre></td></tr></table></figure><p>接下来的篇幅，重点会介绍一下缓存、限流、分布式锁、幂等的使用方式。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><hr><p>缓存的使用可以说无处不在，从应用请求的访问路径来看，用户 user -&gt; 浏览器缓存 -&gt; 反向代理缓存-&gt; WEB服务器缓存 -&gt; 应用程序缓存 -&gt; 数据库缓存等，几乎每条链路都充斥着缓存的使用，缓存最直白的解释就是“用空间换时间”的算法。缓存就是把一些数据暂时存放于某些地方，可能是内存，也有可能硬盘。总之，目的就是为了避免某些耗时的操作。我们常见的耗时的操作，比如数据库的查询、一些数据的计算结果，或者是为了减轻服务器的压力。其实减轻压力也是因查询或计算，虽然短耗时，但操作很频繁，累加起来也很长，造成严重排队等情况，服务器抗不住。</p><p>distributed-tools 组件提供了一个 CacheEngine 接口，基于 Tair、Redis 分别有不同的实现，具体 CacheEngine 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public String get(String key);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取指定的key对应的对象,异常也会返回null</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param clazz</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T get(String key, Class&lt;T&gt; clz);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据,忽略过期时间</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @param expiredTime</span><br><span class="line"> * @param unit</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value, int expiredTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于key删除缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">publicbooleaninvalid(String key);</span><br></pre></td></tr></table></figure><p>get 方法针对 key 进行查询， put 存储缓存数据， invalid 删除缓存数据。</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a><strong>限流</strong></h1><hr><p>在分布式系统中，尤其面对一些秒杀、瞬时高并发场景，都需要进行一些限流措施，保证系统的高可用。通常来说限流的目的是通过对并发访问&#x2F;请求进行限速，或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以 拒绝服务（定向到错误页或告知资源没有了）、排队 或 等待（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。</p><p>常见的一些限流算法包括固定窗口、滑动窗口、漏桶、令牌桶，distributed-tools 组件目前基于计数器只实现了固定窗口算法，具体使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 指定过期时间自增计数器，默认每次+1，非滑动窗口</span><br><span class="line">    *</span><br><span class="line">    * @param key 计数器自增key</span><br><span class="line">    * @param expireTime 过期时间</span><br><span class="line">    * @param unit  时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publiclongincrCount(String key, int expireTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 指定过期时间自增计数器,单位时间内超过最大值rateThreshold返回true，否则返回false</span><br><span class="line">    *</span><br><span class="line">    * @param key 限流key</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param expireTime 固定窗口时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publicbooleanrateLimit(final String key, finalint rateThreshold, int expireTime, TimeUnit unit);</span><br></pre></td></tr></table></figure><p>基于 CacheEngine 的 rateLimit 方法可以实现限流， expireTime 只能设定固定窗口时间，非滑动窗口时间。</p><p>另外 distributed-tools 组件提供了模板 RateLimitTemplate 可以简化限流的易用性，可以直接调用 RateLimitTemplate 的 execute 方法处理限流问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @param limitKey 限流KEY</span><br><span class="line">    * @param resultSupplier 回调方法</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param limitTime 限制时间段</span><br><span class="line">    * @param blockDuration 阻塞时间段</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定限流错误码</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public &lt;T&gt; T execute(String limitKey, Supplier&lt;T&gt; resultSupplier, long rateThreshold, long limitTime,</span><br><span class="line">                        long blockDuration, TimeUnit unit, ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       boolean blocked = tryAcquire(limitKey, rateThreshold, limitTime, blockDuration, unit);</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return resultSupplier.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外 distributed-tools 组件还提供了注解 @RateLimit 的使用方式，具体注解 RateLimit 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RateLimit &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流KEY</span><br><span class="line">     */</span><br><span class="line">    String limitKey();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许访问的次数，默认值MAX_VALUE</span><br><span class="line">     */</span><br><span class="line">    longlimitCount()default Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间段</span><br><span class="line">     */</span><br><span class="line">    longtimeRange();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞时间段</span><br><span class="line">     */</span><br><span class="line">    longblockDuration();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位，默认为秒</span><br><span class="line">     */</span><br><span class="line">    TimeUnit timeUnit()default TimeUnit.SECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于注解的方式限流使用代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RateLimit(limitKey = &quot;#key&quot;, limitCount = 5, timeRange = 2, blockDuration = 3, timeUnit = TimeUnit.MINUTES)</span><br><span class="line">public String testLimit2(String key)&#123;</span><br><span class="line">    ..........</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何方法添加上述注解具备了一定的限流能力(具体方法需要在 spring aop 指定拦截范围内)，如上代码表示以参数 key 作为限流 key ，每 2 分钟请求次数不超过 5 次，超过限制后阻塞 3 分钟。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h1><hr><p>在 Java 单一进程中通过 synchronized 关键字和 ReentrantLock 可重入锁可以实现在多线程环境中控制对资源的并发访问，通常本地的加锁往往不能满足我们的需要，我们更多的面对场景是分布式系统跨进程的锁，简称为分布式锁。分布式锁实现手段通常是将锁标记存在内存中，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Tair ，至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。分布式锁相对单机进程的锁之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠。</p><p> distributed-tools 组件提供的分布式锁要具备如下特性：</p><ul><li>互斥性:同本地锁一样具有互斥性，但是分布式锁需要保证在不同节点进程的不同线程的互斥。</li><li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li><li>锁超时:和本地锁一样支持锁超时，防止死锁，通过异步心跳 demon 线程刷新过期时间，防止特殊场景(如 FGC 死锁超时)下死锁。</li><li>高性能、高可用:加锁和解锁需要高性能，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li><li>支持阻塞和非阻塞:同 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock ( long timeOut )。</li><li>公平锁和非公平锁(不支持):公平锁是按照请求加锁的顺序获得锁，非公平锁就相反是无序的，目前 distributed-tools 组件提供的分布式锁不支持该特性。</li></ul><p>distributed-tools 组件提供的分布式锁，使用起来非常简单，提供了一个分布式锁模板：DistributedLockTemplate ，可以直接调用模板提供的静态方法(如下)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 分布式锁处理模板执行器</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey 分布式锁key</span><br><span class="line">    * @param resultSupplier 分布式锁处理回调</span><br><span class="line">    * @param waitTime 锁等待时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定特殊错误码返回</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static &lt;T&gt; T execute(String lockKey, Supplier&lt;T&gt; resultSupplier, long waitTime, TimeUnit unit,</span><br><span class="line">                               ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       AssertUtils.assertTrue(StringUtils.isNotBlank(lockKey), ExceptionEnumType.PARAMETER_ILLEGALL);</span><br><span class="line">       boolean locked = false;</span><br><span class="line">       Lock lock = DistributedReentrantLock.newLock(lockKey);</span><br><span class="line">       try &#123;</span><br><span class="line">           locked = waitTime &gt; 0 ? lock.tryLock(waitTime, unit) : lock.tryLock();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           throw new RuntimeException(String.format(&quot;lock error,lockResource:%s&quot;, lockKey), e);</span><br><span class="line">       &#125;</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           return resultSupplier.get();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a><strong>幂等</strong></h1><hr><p> 在分布式系统设计中幂等性设计中十分重要的，尤其在复杂的微服务中一套系统中包含了多个子系统服务，而一个子系统服务往往会去调用另一个服务，而服务调用服务无非就是使用 RPC 通信或者 restful ，分布式系统中的网络延时或中断是避免不了的，通常会导致服务的调用层触发重试。具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。</p><p>幂等通常会有两个维度：</p><ol><li>空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易。</li><li>时间维度上的幂等，即幂等的保证时间，是几个小时、几天还是永久性的。</li></ol><p>在实际系统中有很多操作，不管操作多少次，都应该产生一样的效果或返回相同的结果。以下这些应用场景也是通常比较常见的应用场景：</p><ol><li>前端重复提交请求，且请求数据相同时，后台需要返回对应这个请求的相同结果。</li><li>发起一次支付请求，支付中心应该只扣用户账户一次钱，当遇到网络中断或系统异常时，也应该只扣一次钱。</li><li>发送消息，同样内容的短信发给用户只发一次。</li><li>创建业务订单，一次业务请求只能创建一个，重试请求创建多个就会出大问题。</li><li>基于 msgId 的消息幂等处理。</li></ol><p>在正式使用 distributed-tools 组件提供的幂等之前，我们先看下 distributed-tools 幂等组件的设计。</p><p><img src="https://aimak.cn/blog_img/tools/midengliucheng.jpeg"></p><p><strong>幂等 key 提取能力：获取唯一幂等 key</strong></p><p>幂等 key 的提取支持 2 中注解：IdempotentTxId、IdempotentTxIdGetter，任意方法添加以上 2 注解，即可提取到相关幂等 key ，前提条件是需要将 Idempotent 注解添加相关需要幂等的方法上。</p><p>如果单纯使用幂等模板进行业务处理，需要自己设置相关幂等key，且要保证其唯一性。</p><p><strong>分布式锁服务能力：提供全局加锁、解锁的能力</strong></p><p>distributed-tools 幂等组件需要使用自身提供的分布式锁功能，保证其并发唯一性， distributed-tools 提供的分布式锁能够提供其可靠、稳定的加锁、解锁能力。</p><p><strong>高性能的写入、查询能力：针对幂等结果查询与存储</strong></p><p>distributed-tools 幂等组件提供了基于 tair 、 redis 的存储实现，同时支持自定义一级、二级存储通过 spring 依赖注入到 IdempotentService ，建议 distributed-tools 幂等存储结果一级存储 tair mdb ，二级存储ldb或者 tablestore ，一级存储保证其高性能，二级存储保证其可靠性。</p><p>二级存储并行查询会返回查询最快的幂等结果。</p><p>二级存储并行异步写入，进一步提高性能。</p><p><strong>高可用的幂等写入、查询能力：****幂等存储出现异常，不影响业务正常流程，增加容错</strong></p><p>distributed-tools 幂等组件支持二级存储，为了保证其高可用，毕竟二级存储出现故障的概率太低，不会导致业务上不可用，如果二级存储同时出现故障，业务上做了一定的容错，针对不确定性的异常采取重试策略，会执行具体幂等方法。</p><p>一级存储与二级存储的写入与查询处理进行隔离，任何一级存储的异常不会影响整体业务执行。</p><p>在了解了 distributed-tools 组件幂等之后，接下来我们来看下如何去使用幂等组件，首先了解下 common-api 提供的幂等注解,具体幂等注解使用方式如下：</p><p><img src="https://aimak.cn/blog_img/tools/common-api-duibi.png"></p><p>幂等拦截器获取幂等 ID 的优先级：</p><ol><li>首先判断 Idempotent 的 spelKey 的属性是否为空，如果不为空会根据 spelKey 定义的 spring 表达式生成幂等 ID 。</li><li>其次判断参数是否包含 IdempotentTxId 注解，如果有 IdempotentTxId ，会直接获取参数值生成幂等 ID 。</li><li>再次通过反射获取参数对象属性是否包含 IdempotentTxId 注解，如果对象属性包含 IdempotentTxId 注解会获取该参数对象属性生成幂等 ID 。</li><li>最后以上三种情况仍未获取到幂等 ID ，会进一步通过反射获取参数对象的 Method 是否定义 IdempotentTxIdGetter 注解，如果包含该注解则通过反射生成幂等 ID 。</li></ol><p>代码使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Idempotent(spelKey = &quot;#request.requestId&quot;, firstLevelExpireDate = 7，secondLevelExpireDate = 30)</span><br><span class="line">publicvoidexecute(BizFlowRequest request)&#123;</span><br><span class="line">   ..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码表示从 request 获取 requestId 作为幂等 key ，一级存储有效期 7 天，二级存储有效期 30 天。</p><p>distributed-tools 除了可以使用幂等注解外，幂等组件还提供了一个通用幂等模板 IdempotentTemplate ，使用幂等模板的前提必须设置 tair.idempotent.enabled&#x3D;true或者redis.idempotent.enabled&#x3D;true ，默认为 false ，同时需要指定幂等结果一级存储，幂等结果存储为可选项配置。</p><p>具体使用幂等模板 IdempotentTemplate 的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 幂等模板处理器</span><br><span class="line">     *</span><br><span class="line">     * @param request 幂等Request信息</span><br><span class="line">     * @param executeSupplier 幂等处理回调function</span><br><span class="line">     * @param resultPreprocessConsumer 幂等结果回调function 可以对结果做些预处理</span><br><span class="line">     * @param ifResultNeedIdempotence 除了根据异常还需要根据结果判定是否需要幂等性的场景可以提供此参数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public R execute(IdempotentRequest&lt;P&gt; request, Supplier&lt;R&gt; executeSupplier,</span><br><span class="line">                     Consumer&lt;IdempotentResult&lt;P, R&gt;&gt; resultPreprocessConsumer, Predicate&lt;R&gt; ifResultNeedIdempotence)&#123;</span><br><span class="line"></span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>request：</strong><br>幂等参数 IdempotentRequest 组装，可以设置幂等参数和幂等唯一 ID 。</p><p><strong>executeSupplier：</strong><br>具体幂等的方法逻辑，比如针对支付、下单接口，可以通过 JDK8 函数式接口 Supplier Callback 进行处理。</p><p><strong>resultBiConsumer：</strong><br>幂等返回结果的处理，该参数可以为空，如果为空采取默认的处理，根据幂等结果，如果成功、不可重试的异常错误码，直接返回结果，如果失败可重试异常错误码，会进行重试处理。</p><p>如果该参数值不为空，可以针对返回幂等结果进行特殊逻辑处理设置 ResultStatus(ResultStatus 包含三种状态包括成功、失败可重试、失败不可重试)。</p><p><em><strong>作者信息：</strong></em></p><p>孔凡勇，花名云狄，阿里云-开放平台高级技术家，对高并发、高性能、高可用、可伸缩的分布式系统架构设计有丰富经验，Cloud Native坚定拥护者，坚守开发一线打磨匠艺的架构师。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;互联网应用发展到今天，从单体应用架构到 SOA 以及今天的微服务，随着微服务化的不断升级进化，服务和服务之间的稳定性变得越来越重要，分布式系统之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠，微服务</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>美团在全链路压测自动化方面的实践</title>
    <link href="http://ai.mak.cn/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2022-11-26T12:17:18.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美团在全链路压测自动化方面的实践"><a href="#美团在全链路压测自动化方面的实践" class="headerlink" title="美团在全链路压测自动化方面的实践"></a>美团在全链路压测自动化方面的实践</h1><p>境内度假是一个低频、与节假日典型相关的业务，流量在节假日较平日会上涨五到十几倍，会给生产系统带来非常大的风险。因此，在 2018 年春节前，基于美团基础的压测平台 Quake，我们把整个境内度假业务接入了全链路压测，来系统性地评估容量和发现隐患，最终确保了春节期间系统的稳定。</p><p>在整个过程中，我们意识到，全链路压测在整个系统稳定性建设中占有核心重要的位置，也是最有效的方案。结合实际业务节假日的频率（基本平均一个月一次），如果能够把它作为稳定性保障的常规手段，我们的系统质量也能够得到很好的保障。同时，为了解决周期常态化压测过程中人力成本高、多个团队重复工作、压测安全不可控，风险高等痛点，我们提出了全链路压测自动化的设想。</p><p>通过对压测实施的具体动作做统一的梳理，在压测各个阶段推进标准化和自动化，尽力提升全流程的执行效率，最终达到常态化的目标，如图 1 所示：</p><p><img src="https://static001.infoq.cn/resource/image/d1/22/d132f820e00ae26e629b9ac725721c22.jpg" alt="img"></p><p>图 1 自动化落地整体思路</p><p>另外，在全链路压测的整个周期中，压测安全和压测有效性也是需要一直关注的质量属性。基于这些思考，如图 2 所示，我们把压测自动化需要解决的关键问题进行了归类和分解：</p><ul><li>基础流程如何自动化，提高人效；</li><li>如何自动做好压测验证，保障压测安全；</li><li>压测置信度量化如何计算，保证压测有效。</li></ul><p><img src="https://static001.infoq.cn/resource/image/38/c1/386f0c0cbd05a802f916ec0abc9e39c1.png" alt="img"></p><p>图 2 问题分析</p><p>最终，基于美团基础的压测平台 Quake（在整个系统，主要提供流量录制、回放、施压的功能），设计并实现了全链路自动化压测系统，为不同业务实施全链路压测提效，并确保压测安全。该系统：</p><ul><li>提供链路梳理工具，能够自动构建压测入口链路完整的依赖信息，辅助链路梳理；</li><li>支持链路标注和配置功能，对于无需压测触达的依赖接口，可以通过配置化手段，完成相关接口的 Mock 配置，不用在业务代码中嵌入压测判断逻辑；</li><li>提供抽象的数据构造接口，通过平台，用户可以配置任意的数据构造逻辑和流程；</li><li>在压测前&#x2F;压测中，自动对压测服务和流量做多项校验，保障压测安全性；</li><li>在平日，基于压测计划提供周期性小流量的压测校验，使得业务迭代变更带来的压测安全风险被尽早发现；</li><li>提供压测计划管理功能，通过系统自动调度和控制施压过程，解放人力；同时强制前置预压测，也提高了安全性；</li><li>一键压测，自动生成报告，收集链路入口和告警信息，提供问题记录和跟进功能。</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="系统总体设计"><a href="#系统总体设计" class="headerlink" title="系统总体设计"></a>系统总体设计</h3><p><img src="https://static001.infoq.cn/resource/image/93/cb/93f34b102890c1809d6dd8fc507ee0cb.jpg" alt="img"></p><p>图 3 系统总体逻辑架构</p><p>系统的总体逻辑架构，如图 3 所示，主要包括链路构建&#x2F;比对、事件&#x2F;指标收集、链路治理、压测配置管理、压测验证检查、数据构造、压测计划管理、报告输出等功能模块。通过这些模块，为全链路压测的整个流程提供支持，尽力降低业务部门使用全链路压测的门槛和成本。</p><p>链路构建&#x2F;比对：负责服务接口方法调用链路的构建、更新、存储。</p><p>链路治理：基于构建的链路关系，提供链路中核心依赖、出口 Mock 接口等标注、上下游分析、展示，以及出口 Mock 的配置等功能。</p><p>压测配置管理：自动发现注册服务的 Mafka（美团基于 Kafka 开发的一个分布式消息中间件综合解决方案）&#x2F;Cellar（基于 Tair 开发的分布式 KV 存储服务）&#x2F;Squirrel（基于 Redis-Cluster 模式进行二次开发的分布式缓存系统）&#x2F;Zebra（美团数据库访问层中间件）的压测配置，辅助压测方核查和配置相关配置项。</p><p>压测验证检查：确保系统可压测，通过多种校验手段和机制设计，来保证压测的安全性。</p><p>数据构造：为不同业务压测实施准备基础和流量数据。</p><p>压测计划管理：设定压测执行计划，并依赖“压测控制”模块，自动调度整个压测执行过程。</p><p>故障诊断：依据收集的关键业务&#x2F;服务指标、报警等信息，判断分析服务是否异常，以及是否终止压测。</p><p>置信度评估：从数据覆盖、链路覆盖、技术指标等维度评估压测结果的置信度，即与真实流量情况下各评估维度的相似性。</p><p>非功能性需求说明：</p><ul><li>可扩展性</li><li>能够兼容不同业务线数据构造逻辑的差异性。</li><li>能够支持不同的流量录制方式。</li><li>安全性</li><li>集成 SSO，按用户所属团队分组，展示所属的压测服务信息。对关键操作留存操作日志。</li><li>压测验证检查，是确保压测安全的关键。支持周期性压测验证，能发现待压测服务可压测性随时间的退化。</li><li>可重用性</li><li>长远看，链路构建、事件&#x2F;指标收集&#x2F;故障诊断等模块，在稳定性领域是可重用的基础设施，按独立通用模块建设。</li></ul><p>约束说明：</p><ul><li>基于 Quake 搭建，流量的录制、回放、施压等依赖 Quake。</li><li>以下对部分关键模块设计做详细介绍。</li></ul><h2 id="链路治理模块设计"><a href="#链路治理模块设计" class="headerlink" title="链路治理模块设计"></a>链路治理模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/60/89/6060c68e8ee1eb2d6856a59c5b484c89.png" alt="img"></p><p>图 4 链路治理示意图</p><p>链路治理模块是基于链路构建模块实现的。链路构建模块，底层是以闭包表的方式存储两个维度（服务和接口）的链路关系的，会周期自动地构建或更新。</p><p>链路治理模块主要提供链路入口选取、链路标注、服务出口分析、出口 Mock 配置等功能。如图 4 所示，注册压测的服务构成了压测服务的范围，也就确定了各个链路的边界。通过系统自动构建的树结构方式的链路关系，可以辅助压测方对整个链路的梳理，它解决了以往链路梳理靠翻代码等低效手段，缺少全链路视角无法做到完备梳理等问题。</p><p><img src="https://static001.infoq.cn/resource/image/d0/7a/d08f41a776cbe9a9f6141bda4798067a.png" alt="img"></p><p>图 5 出口 Mock 配置化</p><p>同时，针对整个压测范围，依赖接口可以做人工标注。哪些需要 Mock，哪些不需要 Mock，如此压测特有的链路信息能够得到持续的维护。</p><p>对于需要 Mock 的外部接口（如图 4 中的接口 C），待压测系统通过引入专有 SDK 的方式，获得出口配置化 Mock 的能力。如图 5 所示，这里使用了美团酒旅 Mock 平台的基础能力，采用 JVM-Sandbox 作为 AOP 工具，对配置的需要 Mock 的外部接口做动态能力增强。在接口调用时，判断是否是压测流量，是的话走 Mock 逻辑，做模拟时延处理，返回提前配置的响应数据。这样的话，第一，简化了出口 Mock 的操作，业务代码里 Mock 逻辑 0 侵入；第二，把之前本地 Mock 与借助 Mockserver 的两种解决方案用一种方案替代，便于统一管理；第三，在实际压测时，平台还可以通过 SDK 收集 Mock 逻辑执行的数据，自动与后台标注的 Mock 数据对比，来确保应该被 Mock 的出口确实被 Mock 掉。</p><h2 id="数据构造模块设计"><a href="#数据构造模块设计" class="headerlink" title="数据构造模块设计"></a>数据构造模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/f9/20/f9a2e1b507526e109982ecac0359b620.png" alt="img"></p><p>图 6 数据构造</p><p>数据构造模块是为了解决不同业务对于基础数据和流量数据的差异化构造流程。提出了两个关键的概念：数据构造逻辑和数据构造流程。数据构造逻辑，是数据构造的细粒度可复用的基本单元，由一段 Java 代码表示。平台提供统一抽象的数据构造接口，基于 Java 动态编译技术，开发了一个 Java 版的脚本引擎，支持构造逻辑的在线编辑与更新。同时，基于美团 RPC 中间件泛化调用能力，构建了泛化调用工具，帮助用户把外部基础数据构造接口的调用集成到一个数据构造逻辑中。</p><p>数据构造流程，定义了压测基础数据和流量数据生成的整个流程。通过与 Quake 的交互，获取原始真实的线上数据；构建了一个简版的流程引擎，在统一设定的流程中，如图 6 所示，通过在标准扩展槽中，配置不同类型的数据构造逻辑和执行顺序，来定义整个数据构造执行的流程；最后，把构造的流量数据与 Quake 压测场景绑定，作为后续 Quake 压测施压中，场景回放流量的来源。</p><p>通过这样的设计，能够支持任意数据构造逻辑，通用灵活。同时集成了 Quake 已有的流量录制功能，一键执行数据构造流程，大大地提升了效率。</p><h2 id="压测验证模块设计"><a href="#压测验证模块设计" class="headerlink" title="压测验证模块设计"></a>压测验证模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/65/6b/65ba4cd007740cf35772e7ea4633a56b.jpg" alt="img"></p><p>图 7 美团服务压测验证示意</p><p>对于压测安全性的保障，一直是自动化的难点。之前的经验多是在非生产环境压测或预压测过程中，依靠不同服务相关负责人的人工确认。这里针对压测验证，提供两条新的思考角度：一个是从待压测服务系统可压测性的角度看；一个是从压测流量特征的角度看。对于第一个角度，一个服务支持压测需要满足压测数据和流量的隔离。对于不同的系统生态，需要满足的点是不同的，对于美团生态下的服务，可压测的条件包括组件版本支持压测、影子存储配置符合预期等等。</p><p>从这些条件出发，就可以得到下面这些静态的校验项：</p><ul><li>服务依赖中间件版本要求校验；</li><li>Zebra 压测配置校验；</li><li>Cellar&#x2F;Squirrel 压测配置校验；</li><li>Mafka 压测开关同步及校验；</li><li>服务 Mock 逻辑存在性校验。</li></ul><p>而从第二个角度来看，就是关注压测流量下会产生哪些特有的流量特征数据，通过这些特有的数据来确保压测的安全性。这里主要有三类数据：美团分布式追踪系统（MTrace）中调用链路的压测标记数据（正常的压测链路应该是一直带有压测标记，直到压测范围的边界节点，可参考图 4）；标记 Mock 的外部接口被调用时，上报的运行数据；基于监控系统得到的压测流量特有的监控数据。利用这些数据，我们设计了三种动态的校验项，发现压测标记丢失、Mock 出口被调用等异常情况：</p><ul><li>MTrace 链路标记校验，从压测链路入口出发，收集压测链路信息，校验压测标记信息传递是否符合预期。</li></ul><p><img src="https://static001.infoq.cn/resource/image/07/11/07d0100434cec699bfbd7b823d369611.png" alt="img"></p><p>图 8 MTrace 链路标记校验示意</p><ul><li>服务 Mock 逻辑压测标记校验，通过增强的校验逻辑，把执行信息上报到平台，与 Mock 配置时的标注数据对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/42/f4/424b9e7782e721f1524796dbd117a5f4.png" alt="img"></p><p>图 9 服务 Mock 压测校验示意</p><ul><li>压测与真实链路比对校验，利用链路治理模块构建链路的能力，采集压测监控数据重构链路，与真实链路对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/31/91/31d13eba73a566e5075e674ff8661691.png" alt="img"></p><p>图 10 压测与真实链路对比示意</p><p>除了明确静态和动态两类压测校验规则，在具体流程安排上，在压测时和平日两个时期执行这些规则。既能把压测校验的压力分散到平时，也能尽快地发现服务因代码迭代引入的新风险。</p><p>在压测时，通过强制前置预压测的流程设计以及静态&#x2F;动态压测校验项的自动执行，保障安全这个事情。校验不通过，给出告警，甚至在允许的情况下直接终止设定的压测计划。</p><p>在平日，通过执行周期性小流量压测校验，在施压过程中对 QPS 做个位数的精细控制，以尽量小的代价快速发现压测范围内压测安全性的退化。</p><h2 id="压测计划管理模块设计"><a href="#压测计划管理模块设计" class="headerlink" title="压测计划管理模块设计"></a>压测计划管理模块设计</h2><p>压测计划管理模块，提供压测计划的提前设定，然后模块能够自动调度和控制整个施压过程。如图 11 所示，这里的压测计划是多个压测场景的组合，包含 QPS 的增长计划等信息，主要分为预压测和正式压测两个阶段。压测计划的自动实施，能够解决尤其多场景组合压测，操作耗时多、多场景压测 QPS 无法同步变更、压测方无法兼顾操作和观测等问题，提升了效率。同时，在压测计划执行状态机里，预压测正常执行完成，状态才能迁移到正式压测的开始状态，提高了压测安全性。</p><p><img src="https://static001.infoq.cn/resource/image/76/3f/76fd6115851f9b4d5503e7995b4e4d3f.png" alt="img"></p><p>图 11 压测计划执行</p><p>从图 11 可以看到，压测计划模块，是整个自动化压测的核心，协同起了各个模块。通过具体的计划任务执行产生的事件，触发了压测验证检查、压测进展播报、收集压测监控&#x2F;告警等数据，来检测服务是否异常，并根据配置来终止压测，能够故障时及时止损。最后，报告生成模块收到压测终止事件，汇总各种信息，自动生成包括压测基本信息等多维度信息的压测报告，节省了一些压测后分析的时间。</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>以下以实际压测的过程来做个案例分享。</p><p><strong>团队&#x2F;服务注册</strong></p><ul><li>设定实施压测的虚拟团队和压测覆盖范围的应用服务。</li></ul><p><img src="https://static001.infoq.cn/resource/image/9b/ea/9b5572017d1fb136366b80241713adea.jpg" alt="img"></p><p><strong>链路治理</strong></p><ul><li>选定压测链路入口，可以得到入口以下的接口链路关系树，便于梳理。</li><li>明确需要 Mock 的外部接口，并做配置，参考“链路治理模块设计”一节。</li></ul><p><img src="https://static001.infoq.cn/resource/image/f4/e4/f4a172982f91243b0cb410c603536ce4.jpg" alt="img"></p><p><strong>应用改造与压测配置</strong></p><ul><li>对待接入压测应用改造，满足“服务的可压测条件”，参考图 7。</li><li>压测应用依赖中间件配置，系统依据构建的链路信息，能够自动发现。提供统一配置和核对的页面功能。</li><li><img src="https://static001.infoq.cn/resource/image/a4/85/a442826c7c90692248e423c781f5e985.png" alt="img"></li></ul><p><strong>Quake 准备</strong></p><ul><li>压测自动化系统是基于 Quake 构建的，流量录制、回放、施压等依赖于此。因此需要到 Quake 上配置流量录制的“流量任务”和压测执行的“压测场景”。</li></ul><p><img src="https://static001.infoq.cn/resource/image/4a/7e/4a7e7fe8a1d2f3aa98661c3779ef977e.png" alt="img"></p><p><strong>数据构造</strong></p><p>配置数据构造逻辑，当然已有的逻辑都是可复用的单元，可以先查看已有逻辑是否能满足自己的需要。</p><p><img src="https://static001.infoq.cn/resource/image/8c/37/8c44afa725c533ddf446e446d3d84537.jpg" alt="img"></p><ul><li>配置数据构造流程。</li></ul><p><strong>压测实施</strong></p><ul><li>设定压测计划，到启动时间，系统会自动启动压测。</li></ul><p><img src="https://static001.infoq.cn/resource/image/7d/1b/7db495027bea72fc8cd1b7ad0d8f651b.png" alt="img"></p><p>压测中，注意关注压测验证校验的告警信息，及时处理。</p><p><img src="https://static001.infoq.cn/resource/image/29/f7/29c96d574b217c5bca4b50cfe99015f7.png" alt="img"></p><ul><li>压测后，可查看压测报告。记录和跟进发现的问题。</li><li><img src="https://static001.infoq.cn/resource/image/a9/39/a986012a95836b5b44ab064c775d3939.png" alt="img"></li></ul><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>目前，压测自动化系统已经投入使用，美团酒店和境内度假的全部团队已经接入，有效地提升了压测效率。后续会在两个大方向上持续建设升级，一个是把全链路压测放到“容量评估与优化”领域来看，不仅关注整体系统的稳定性，同时也期望兼顾成本的平衡；另一个是与稳定性其他子领域的生态集成，比如故障演练、弹性伸缩等等，在更多场景发挥压测的作用。最后，通过这些努力，使得线上系统的稳定性成为一个确定性的事情。</p><p><strong>作者简介：</strong></p><p>欧龙，美团研发工程师，2013 年加入美团，目前主要负责境内度假交易稳定性建设等工作。</p><p><strong>本文转载自技术琐话公众号。</strong></p><p><strong>原文链接：</strong><a href="https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w">https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;美团在全链路压测自动化方面的实践&quot;&gt;&lt;a href=&quot;#美团在全链路压测自动化方面的实践&quot; class=&quot;headerlink&quot; title=&quot;美团在全链路压测自动化方面的实践&quot;&gt;&lt;/a&gt;美团在全链路压测自动化方面的实践&lt;/h1&gt;&lt;p&gt;境内度假是一个低频、与节假日</summary>
      
    
    
    
    <category term="测试" scheme="http://ai.mak.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://ai.mak.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>管理的4C模型</title>
    <link href="http://ai.mak.cn/2019/10/28/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E7%9A%844C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://ai.mak.cn/2019/10/28/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E7%9A%844C%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2022-11-26T11:59:21.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管理的4C模型"><a href="#管理的4C模型" class="headerlink" title="管理的4C模型"></a>管理的4C模型</h2><p>提升团队的综合执行力是每一个管理者的核心工作，在企业中的执行力绝非是军队命令式的管理，而是建立在尊重，共赢的基础上，高品质，高效率地完成相关工作，如何实现这一目的呢？管理的4C模型是一个非常有效的方法。</p><p><img src="https://p9.itc.cn/q_70/images03/20210810/2853f61d7ad149129faf20876669d052.jpeg"></p><p><strong>C:CLARITY(澄清):</strong> 这里需要提醒管理者是管理者讲清楚了并不等于员工理解了，如何确保员工100%地理解工作任务是确保执行的前提，在我们过去的培训项目调查中，员工的工作偏差有45%是由于双方对工作的理解不一致导致的。在澄清任务过程中，管理者需要做到：</p><p><img src="https://p0.itc.cn/q_70/images03/20210810/e246215bef104e5fb3080f85fa6b4474.jpeg"></p><p>如何做到、简洁、完整、清晰</p><p>如何根据员工的不同情况选择不同的沟通风格及策略</p><p>如何确认员工已经理解了任务</p><p>常见错误及注意事项是什么？</p><p><img src="https://p4.itc.cn/q_70/images03/20210810/5441bd99088c4f8ba1dd2c2cd0f5448a.jpeg"></p><p><strong>C:COMPETENCE(胜任)：</strong>这里是管理者用人与辅导下属的问题，胜任不仅仅是能力上的胜任，还指态度上的胜任，也是提升团队执行力的重要因素，为了提升团队的胜任度，管理者可以：</p><p><img src="https://p5.itc.cn/q_70/images03/20210810/ea34ec20469c472ebbb3ce54de8b27a8.jpeg"></p><p>选对人吸引与留住优秀人才是一个重要的管理职责</p><p>通过优化工作流程及方法，降低员工完成工作的难度，也降低工作对能力的要求</p><p>分解工作，通过团队合作完成复杂任务</p><p>持续地辅导员工</p><p><strong>C:COMMITMENT(承诺)：</strong>员工胜任工作，也有能力完成任务，但这并不是意味着员工就能高效地执行任务，员工高效地完成任务还需要另外一个条件就是员工发自内心地承诺100%地完成任务，从管理的角度去看，很多时候不是员工不愿意做出承诺，而是面对任务，员工缺乏承诺所需要的条件，包括：</p><p>员工是否有意愿与热情想完成任务</p><p>是否具备了完成任务的条件与资源</p><p>不能完成任务带来的风险与完成任务带来收益的权衡</p><p><strong>C:CONTROL(控制)：</strong>当员工明白了任务、也有能力完成任务，并且也100%的发自内心地承诺完成任务，那么是否就意味着管理者就可以高枕无忧了呢？很显然，有经验的管理者还是会担心出现各种状况，有意思的是越担心的事情则越容易发生，因此100%地保证完成任务，从管理者的角度去看，管理者还需要做好事前、事中（最重要）以及事后的控制：</p><p><img src="https://p5.itc.cn/q_70/images03/20210810/05154139b17c4445a49bbc34b32ee5ed.jpeg"></p><p><strong>在事前：</strong>主要做好计划、澄清与确保胜任即可</p><p><strong>在事中：</strong>管理者需要做好及时获得任务状态并纠正员工的工作偏差</p><p><strong>在事后：</strong>做好总结与复盘</p><p>那么在强调执行的同时，如何通过有效的沟通改善执行带来的压力并激发员工创造性地解决问题呢？以下的沟通循环将是有效地提升团队执行力的好帮手……</p><p><img src="https://p8.itc.cn/q_70/images03/20210810/cc48300c5ac1435ba9fc6060776666c1.jpeg"></p><p>团队有效沟通是项目类管理执行的前提，团队组员之间能够创造出和谐的氛围与环境，沟通中清晰表达每个人的意愿与信息，促进想法的交换，最终形成双方的接受，这是团队每个人都需要知道团队共创的几个主要问题：</p><p><strong>准备：</strong>事前准备好主题信息、参会者资料、主持人等</p><p><strong>创造良好的氛围：</strong>即便遇到冲突也不要上来就指责对方，沟通多了你会发现，对方在沟通中的情绪有很多时候比沟通的内容更重要</p><p><strong>信息交换：</strong>在这个步骤项目成员需要具备2个核心的能力：结构化讲解+逻辑聆听的能力</p><p><strong>达成一致：</strong>就达成一致的部分形成清晰的行动指南，对未达成一致的部分，搁置再谈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;管理的4C模型&quot;&gt;&lt;a href=&quot;#管理的4C模型&quot; class=&quot;headerlink&quot; title=&quot;管理的4C模型&quot;&gt;&lt;/a&gt;管理的4C模型&lt;/h2&gt;&lt;p&gt;提升团队的综合执行力是每一个管理者的核心工作，在企业中的执行力绝非是军队命令式的管理，而是建立在尊重</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化高阶总结</title>
    <link href="http://ai.mak.cn/2019/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%AA%A8%E7%81%B0%E7%BA%A7%EF%BC%8C%E9%AB%98%E9%98%B6%E7%A5%9E%E6%8A%80/"/>
    <id>http://ai.mak.cn/2019/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%AA%A8%E7%81%B0%E7%BA%A7%EF%BC%8C%E9%AB%98%E9%98%B6%E7%A5%9E%E6%8A%80/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2022-11-26T11:51:10.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：崔皓 转载于 <a href="https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg">https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg</a></p></blockquote><h2 id="MySQL性能优化之骨灰级，高阶神技"><a href="#MySQL性能优化之骨灰级，高阶神技" class="headerlink" title="MySQL性能优化之骨灰级，高阶神技"></a>MySQL性能优化之骨灰级，高阶神技</h2><hr><p>大量信息的存储和查询都会用到 MySQL，因此它的优化就对系统性能提升就尤为重要了。<br>由于 MySQL 的优化范围较广，从软件到硬件，从配置到应用，无法一一道来。<br>今天就从开发者的角度介绍一下 MySQL 应用优化。包括数据类型，数据表查询&#x2F;修改，索引和查询等几个方面。</p><h2 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h2><hr><p>字段是用来存放数据的单元，设计好字段是设计数据库的第一步，同样会影响到系统的性能。<br>设计字段有一个基本的原则，保小不保大，也就是能够用字节少的字段就不用字节数大的字段，目的是为了节省空间，提高查询效率。<br>更小的字段，占用更小的磁盘空间，内存空间，更小的 IO 消耗。下面针对使用场景，说一些字段类型选取的经验，供大家参考。</p><ul><li><p>数值类型</p><ul><li>手机号：通常我们在存储手机号的时候，喜欢用 Varchar 类型。</li><li>如果是 11 位的手机号，假设我们用 utf8 的编码，每位字节就需要 3 个字节，那么就需要 11*33&#x3D;33 个字节来存放；如果我们使用 bigint，只需要 8 个字节就可以存放。</li><li>IP 地址：同上，IP 地址也可以通过 int（4 字节）在存放，可以通过 INET_ATON() 函数把 IP 地址转成数字。这里需要注意溢出的问题，需要用无符号的 int。</li><li>年龄，枚举类型：可以用 tinyint 来存放，它只占用 1 个字节，无符号的 tinyint 可以表示 0-255 的范围，基本够用了。</li></ul></li><li><p>字符类型</p><ul><li>Char 和 Varchar 是我们常用的字符类型。char(N) 用来记录固定长度的字符，如果长度不足 N 的，用空格补齐。</li><li>varchar(N) 用来保存可变长度的字符，它会额外增加 1-2 字节来保存字符串的长度。</li><li>Char 和 Varchar 占用的字节数，根据数据库的编码格式不同而不同。Latin1 占用 1 个字节，gbk 占用 2 个字节，utf8 占用 3 个字节。</li><li><strong><strong>用法方面，如果存储的内容是可变长度的，例如：家庭住址，用户描述就可以用 Varchar。</strong></strong></li><li><em><strong><strong>如果内容是固定长度的，例如：UUID（36 位），或者是 MD5 加密串（32 位），就可以使用 Char 存放。</strong></strong></em></li></ul></li><li><p>时间类型</p><ul><li><p><em>Datetime 和 Timestamp 都是可以精确到秒的时间类型，但是 Datetime 占用 8 个字节，而 Timestamp 占用 4 个字节。</em></p></li><li><p><strong>所以在日常建表的时候可以有限选择 Timestamp。不过他们有下面几个小区别，需要注意的。</strong></p></li><li><p><strong>区别一：存储数据方式不一样。</strong></p></li><li><ul><li><strong>Timestamp 是转化成 utc 时间进行存储，查询时，转化为客户端时间返回的。</strong></li></ul></li><li><p>区别二：两者存储时间的范围不一样。</p><ul><li><em>Timestamp 为’1970-01-01 00:00:01.000000’ 到’2038-01-19 03:14:07.999999’。</em></li><li><strong>Datetime为’1000-01-01 00:00:00.000000’到’9999-12-31 23:59:59.999999’。</strong></li></ul></li></ul></li></ul><h2 id="数据表查询-x2F-修改优化"><a href="#数据表查询-x2F-修改优化" class="headerlink" title="数据表查询&#x2F;修改优化"></a>数据表查询&#x2F;修改优化</h2><hr><p>说了如何高效地选择存储数据的类型以后，再来看看如何高效地读取数据。MySQL 作为关系型数据库，在处理复杂业务的时候多会选择表与表之间的关联。<br>这会导致我们在查询数据的时候，会关联其他的表，特别是一些多维度数据查询的时候，这种关联就尤为突出。<br>此时，为了提高查询的效率，我们会对某些字段做冗余处理，让这些字段同时存在于多张表中。<br>但是，这又会带来其他的问题，例如：如果针对冗余字段进行修改的时候，就需要对多张表进行修改，并且需要让这个修改保持在一个事物中。<br>如果处理不当，会导致数据的不一致性。这里需要根据具体情况采取查询策略，例如：需要跨多张表查询公司销售额信息。<br>由于，销售信息需要连接多张表，并且对销售量和金额做求和操作，直接查询显然是不妥当的。<br>可以生成后台服务，定时从相关表中取出信息，计算出结果放入一张汇总表中。<br>将汇总表中需要查询的条件字段加上索引信息，提高查询的效率。这种做法，限于查询数据实时性不强的情况。<br>在高速迭代开发过程中，业务变化快，数据库会根据业务的变化进行迭代。所以，在开发新产品初期，表结构会面临频繁地修改。<br>MySQL 的 ALTERTABLE 操作性能对大表来说是个问题。MySQL 执行修改表结构操作的方法是，用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。<br>这一操作需要花费大量时间，如果内存不足而表数据很大，并且索引较多的情况，会造成长时间的锁表。<br>有极端的情况，有些 ALTERTABLE 操作需要花费数个小时甚至数天才能完成。</p><h3 id="这里推荐两种小技巧："><a href="#这里推荐两种小技巧：" class="headerlink" title="这里推荐两种小技巧："></a>这里推荐两种小技巧：</h3><hr><ul><li>先把数据库拷贝到一台非生产服务器上，在上面做修改表操作，此时的修改不会影响生产库。<ul><li>　　修改完毕以后在做数据库的切换，把非生产数据库切换成生产库。不过需要注意的时候，在做表结构修改的时候，生产库会生成一些数据。这里需要通过脚本根据时间区间导入这部分数据。</li></ul></li><li>“影子拷贝”，即生成一张表结构相同的不同名新数据表（更改数据结构以后的表）。<ul><li>　<em>然后导入原表的数据到新表，导入成功以后停止数据库，修改原表和新表的名字，最终将数据访问指向新表。</em></li><li><strong>在运行正常以后，将原表删除。这里有现成的工具可以协助完成上述操作，“online schema change”,”openark toolkit”</strong></li></ul></li></ul><p>　　如果只是删除或者更改某一列的默认值，那么直接可以使用 Alert table modify column 和 Alert table alert column 来实现。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><hr><p>说了字段和表再来聊聊索引。对于索引的优化网上有很多的说法，都是在实际工作中总结出来的，这里没有一定的标准。<br>针对我们使用比较多的 InnoDB 的存储引擎（使用的 B-Tree 索引），推荐几个方法给大家。</p><ul><li><p>索引独立</p><ul><li>“索引独立”是指索引列不能是表达式的一部分，也不能是函数的参数。例如：假设 User 表中分别把 create_date 和 userId 设置为索引。</li><li><code>select</code> <code>*``from</code> <code>user</code> <code>where</code> <code>date``(create_date)=curdate()``selectuserId ``from</code> <code>user</code> <code>where</code> <code>userId+1=5</code></li><li><em>类似上面的语句就是将索引作为了函数中的参数和表达式的一部分，是不推荐这样使用的。</em></li></ul></li><li><p>前缀索引</p><ul><li>有时候索引字段长度较大，例如：VarChar，Blob，Text。当搜索的时候，这会让索引变得大且慢。<br>通常的做法是，可以索引开始的部分字符，这样可以节约索引空间，提高索引效率。<br>既然索引全部字符行不通，那么索引多少字符就是我们要讨论的问题了<br>这里需要引入一个概念，索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数的比值。<br>索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</li><li>例如：有一张 user 表，其中有一个字段是 FirstName，如何计算这个字段的选择性，如下：</li><li><code>Select1.0*``count``(``distinct</code> <code>FirstName)/``count``(*) ``from</code> <code>user</code></li><li>假设这个结果是 0.75 再用 left 函数对该字段取部分字符，例如取从左开始的 3，4，5 个字段。</li><li>分别查看其选择性，目的是看当选择多少字符的时候，选择性最接近 0.75。</li><li><code>从左取3个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,3))/``count``(*) ``from</code> <code>user``结果为0.58</code>“__mceDel”<code> </code>style&#x3D;<code>&quot;background-color: rgba(255, 255, 255, 1); font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px&quot;</code>&gt;　&#96;</li><li><code>从左取4个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,4))/``count``(*) ``from</code> <code>user``结果为0.67</code></li><li><code>从左取5个字段的时候，``Select</code> <code>1.0*``count``(``distinct</code> <code>left``(FirstName,5))/``count``(*) ``from</code> <code>user``结果为0.74</code></li></ul><p>　　从上面尝试发现，字段 FirstName 取左边字符，从 3-5 的获取可以看出，当从左边取第 5 个字符的时候，选择性 0.74 最接近 0.75。</p></li></ul><p> 　　因此，可以将 FirstName 的前面 5 个字符作为前缀索引，这样建立索引的效果基本和 FirstName 全部字符建立索引的效果一致。而又不用将 FirstName 整个字段都当成索引。</p><p>　　　于是可以用下面语句修改索引信息：　　　</p><p>　　　　Alter tableuser add key(FirstName(5))</p><h2 id="多列索引及其顺序"><a href="#多列索引及其顺序" class="headerlink" title="多列索引及其顺序"></a>多列索引及其顺序</h2><hr><p>多列索引，顾名思义就是将多列字段作为索引。假设在 user 表中通过搜索 LastName 和 FirstName 条件来查找数据。</p><p>可能出现以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `*``from` `user` `where` `LastName = ‘Green’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName = ‘Jack’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `(FirstName = ‘Jack’ ``or` `FirstName =‘Michael’``Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName &gt;=‘M’ ``and` `FirstName&lt;‘N’</span><br></pre></td></tr></table></figure><p>如果分别在 LastName 和 FirstName 上面建立索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `*``from` `user` `where` `LastName = ‘Green’ ``and` `FirstName = ‘Jack’</span><br></pre></td></tr></table></figure><p>当运行上面这段代码的时候，系统会让选择性高的 SQL 的索引生效，另外一个索引是用不上的。因此我们就需要建立多列索引（合并索引）。</p><p> 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter` `table` `user` `add` `key``(LastName, FirstName)</span><br></pre></td></tr></table></figure><p>既然定义了多列索引，那么其中的索引顺序是否也需要考虑呢？在一个多列 B-Tree 索引中，索引列的顺序意味着，索引首先按照最左列进行排序，其次是第二列。<br>索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的 ORDERBY、GROUPBY 和 DISTINCT 等子句的查询需求。<br>所以，多列索引的顺序是需要考虑的。这里给出的建议是，将选择性最高的索引列放在前面。<br>接上面的例子，还是 LastName 和 FirstName 作为多列索引。看谁应该放前面。</p><p>通过按照选择性规则，写如下 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先计算LastName的选择性``Selectcount(disctinc LastName)/``count``(*) ``from` `user``结果为0.02</span><br></pre></td></tr></table></figure><p>　　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再计算FirstName的选择性``Selectcount(disctinc FirstName)/``count``(*) ``from` `user``结果0.05</span><br></pre></td></tr></table></figure><p>　　</p><p>FirstName 的选择性要高于 LastName 的选择性。因此调整多列索引的顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter` `tableuser ``add` `key``(FirstName ，LastName)</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h2><hr><p>当使用 Select 的数据列只用从索引中取得，而不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</p><p>例如：User 表中将 LastName 作为索引。如果写以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `LastName ``from` `user</span><br></pre></td></tr></table></figure><p>LastName 及作为索引，又在查询内容中显示出来，那么 LastName 就是覆盖索引。<br>覆盖索引是高效查找行方法，通过索引就可以读取数据，就不需要再到数据表中读取数据了。</p><p><em>而且覆盖索引会以 Usingindex 作为标示，可以通过 Explain 语句查看。</em></p><p><em><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184646933-1864623193.png" alt="img"></em></p><p> 覆盖索引主要应用在 Count 等一些聚合操作上，提升查询的效率。例如上面提到的 Selectcount(LastName) from user 就可以把 LastName 设置为索引。</p><p> <em>还有可以进行列查询的回表优化，如下：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `LastName, FirstName ``from` `user` `where` `LastName=‘Jack’</span><br></pre></td></tr></table></figure><p>如果此时 LastName 设置为索引，可以将 LastName 和 FirstName 设置为多列索引（联合索引）。<br>避免回表行为的发生。这里的回表是指二级索引搜索到以后，再找到聚合索引，然后在查找 PK 的过程。</p><p>这里需要通过两次搜索完成。简单点说就是使用了覆盖索引以后，一次就可以查到想要的记录，不用在查第二次了。</p><p><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184741370-1321441480.png" alt="img"></p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>作为程序开发人员来说，使用得最多的就是 SQL 语句了，最多的操作就是查询了。<br>我们一起来看看，哪些因素会影响查询记录，查询基本原理是什么，以及如何发现和优化 SQL 语句。</p><h2 id="影响查询效率的因素"><a href="#影响查询效率的因素" class="headerlink" title="影响查询效率的因素"></a><strong>影响查询效率的因素</strong></h2><hr><h2 id="一般来说，影响查询的因素有三部分组成，如下："><a href="#一般来说，影响查询的因素有三部分组成，如下：" class="headerlink" title="一般来说，影响查询的因素有三部分组成，如下："></a><strong>一般来说，影响查询的因素有三部分组成，如下：</strong></h2><ul><li><p><strong>响应时间，</strong>由两部分组成，他们分别是，服务时间和排队时间。服务时间是指数据库处理查询花费的时间。</p><p>排队时间是指服务器因为等待某些资源花费的时间。例如：I&#x2F;O 操作，等待其他事务释放锁的时间。</p></li><li><p><strong>扫描记录行数，</strong>在查询过程中数据库锁扫描的行记录。理想情况下扫描的行数和返回的行数是相同的。不过通常来说，扫描的行数都会大于返回记录的行数。</p></li><li><p><strong>返回记录行数，</strong>返回实际要查询的结果。</p></li></ul><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a><strong>查询基础</strong></h2><hr><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184843459-995983551.png" alt="img"></h2><p> 说了影响查询效率的因素以后，来看看查询这件事情在 MySQL 中是如何运作的，可以帮助我理解，查询优化工作是在哪里进行的：</p><ul><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。</li><li>解析器对 SQL 进行解析，它通过关键字将 SQL 语句进行解析，并生成一棵对应的“解析树”。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。</li><li>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，并且验证权限。例如，检查数据表和数据列是否存在，解析名字和别名看是否有歧义。</li><li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端。</li></ul><h2 id="如何发现查询慢的-SQL"><a href="#如何发现查询慢的-SQL" class="headerlink" title="如何发现查询慢的 SQL"></a><strong>如何发现查询慢的 SQL</strong></h2><hr><p>说了影响查询缓慢的因素以及查询的基本流程以后，再来看看如何发现查询慢的 SQL。这里 MySQL 提供了日志，其中可以查询执行比较慢的 SQL。</p><p><strong>①查看慢查询日志是否开启</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOWVARIABLESLIKE``&#x27;%slow_query_log%&#x27;``;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028184941956-1039646703.png" alt="img"></p><p><strong>②如果没有开启，通过命令开启慢查询日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGLOBAL slow_query_log=1;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185011545-561623481.png" alt="img"></p><p> ③设置慢查询日志的时间，这里的单位是秒，意思是只要是执行时间超过 X 秒的查询语句被记录到这个日志中。这里的 X 就是你要设置的。（下面的例子设置的是 3 秒）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGLOBAL long_query_time=3;</span><br></pre></td></tr></table></figure><p>　　<img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185031869-815149857.png" alt="img"></p><p> ④查看多少 SQL 语句是超过查询阀值的（3 秒）</p><p> <img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185101608-213106289.png" alt="img"></p><h2 id="Explain-分析-SQL-查询"><a href="#Explain-分析-SQL-查询" class="headerlink" title="Explain 分析 SQL 查询"></a><strong>Explain 分析 SQL 查询</strong></h2><hr><p>**通过上面的方法可以知道哪些 SQL 花费了较多的时间，那么如何对这些 SQL 语句进行分析呢。毕竟，我们的目的是通过分析以后，优化 SQL 从而提高其性能。<br>**</p><p>将 Explain 关键字放在要执行的 SQL 语句前面，可以模拟优化器执行 SQL 语句，从而知道 MySQL 是如何处理你的 SQL 语句的。</p><p><img src="https://img2018.cnblogs.com/blog/1175403/201910/1175403-20191028185115583-1996317626.png" alt="img"></p><p> 上面每个字段的含义，在这里不展开描述。</p><h2 id="SQL-优化建议"><a href="#SQL-优化建议" class="headerlink" title="SQL 优化建议"></a><strong>SQL 优化建议</strong></h2><hr><p><strong>如果发现慢查询的 SQL，我们就需要针对其问题进行优化。这里针对几个常见的 SQL 给出一些优化建议。<br>类似 SQL 优化的文章和例子在网上种类繁多，千奇百怪。建议在优化之前，先查看慢查询日志和 Explain 的语句，再进行优化，做到有的放矢。</strong></p><p><strong><strong>①Count 优化</strong></strong></p><p>从 user 表中搜索 id 大于 7 的所有用户。如果是 InnoDB 存储引擎会进行逐行扫描，如果表中记录比较多，性能就是问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(*) ``from` `user` `where` `id&gt;7</span><br></pre></td></tr></table></figure><p>如果先将所有的行数 Count 出来，再减去 id&lt;&#x3D;7 的记录，这样速度就会快一些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `(``select` `count``(*) - (``select` `count``(*) ``from` `user` `where` `id &lt;=7) ``from` `user``)</span><br></pre></td></tr></table></figure><p>如果有一个货物表 items，其中有一个 color 字段来表示货物的颜色，如果需要知道颜色是蓝色或者红色的货物的数量，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(color=‘blue’ ``or` `color=‘red’) ``from` `items``Select` `count``(*) ``from` `items ``where` `color=‘blue’ ``and` `color=‘red’</span><br></pre></td></tr></table></figure><p>不过颜色本身是除斥的字段，所以可以优化成下面的 SQL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `count``(color=‘blue’ ``or` `null``) ``as` `blue, ``count``(color=‘red’ ``or` `null``) ``as` `red ``from` `items</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="②GROUPBY-优化"><a href="#②GROUPBY-优化" class="headerlink" title="②GROUPBY 优化"></a><strong>②GROUPBY 优化</strong></h3><p>MySQL 通过索引来优化 GROUPBY 查询。在无法使用索引的时候，会使用两种策略优化：临时表和文件排序分组。<br>可以通过两个参数 SQL_BIG_RESULT 和 SQL_SMALL_RESULT 提升其性能。<br>这两个参数只对 Select 语句有效。它们告诉优化器对 GROUPBY 查询使用临时表及排序。<br>SQL_SMALL_RESULT 告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。<br>如果是 SQL_BIG_RESULT，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectSQL_BUFFER_RESULTfield1, ``count``(*) ``from` `table1 groupby field1</span><br></pre></td></tr></table></figure><p>　　</p><p>假设两个表做关联查询，选择查询表中的标识列（主键）分组效率会高。<br>例如 actor 表和 film 表通过 actorId 做关联，查询如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `actor.FirstName, actor.LastName,``count``(*) ``from` `film ``inner` `join` `actor using(actorId)``Group` `by` `actor.FirstName,actor.LastName</span><br></pre></td></tr></table></figure><p>就可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `actor.FirstName, actor.LastName, ``count``(*) ``from` `film ``inner` `join` `actor using(actorId)``Group` `by` `film.actorId</span><br></pre></td></tr></table></figure><p>　　</p><p>③Limit<br>Limit 对我们再熟悉也不过了，特别是在做分页操作的时候，经常会用到它。但在偏移量非常的时候问题就来了。<br>例如，Limit 1000，20 就需要偏移 1000 条数据以后，再返回后面的 20 条记录，前面的 1000 条数据是被抛弃掉的。<br>按照上例 SQL 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `name` `from` `user` `order` `by` `id limit1000,20</span><br></pre></td></tr></table></figure><p>这里通过 id 索引到第 1001 条记录，然后取 20 条记录。这里利用 id 的索引的优势直接跳过了前面 1000 条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select` `name` `from` `user` `where` `id&gt;=1001order ``by` `id limit 20</span><br></pre></td></tr></table></figure><p>　　</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>从开发者的角度了解 MySQL 的应用优化。从数据类型的选择开始，针对数值类型，字符类型，时间类型进行了举例说明。<br>接下来谈到，作为数据表的查询，修改的优化，我们应该注意哪些细节。然后，聊了索引独立，前缀索引，多列索引，覆盖索引的优化方法。<br>最后，针对使用最多的查询优化进行了探讨。从影响查询的因素到查询基础，再到如何发现慢查询，用几个 SQL 优化的建议结束了我们的 MySQL 应用优化之旅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：崔皓 转载于 &lt;a href=&quot;https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg&quot;&gt;https://mp.weixin.qq.com/s/FCrsFHaJ0HGjV5We1h5Ogg&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://ai.mak.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="http://ai.mak.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>工作中常用Git 命令总结</title>
    <link href="http://ai.mak.cn/2019/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2019/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-06T16:00:00.000Z</published>
    <updated>2022-11-26T11:41:33.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作中常用Git-命令总结"><a href="#工作中常用Git-命令总结" class="headerlink" title="工作中常用Git 命令总结"></a>工作中常用Git 命令总结</h1><blockquote><p>git整理的有好几篇了，不过确实比较重要，又收集一些比较实用的</p></blockquote><ul><li><p>分支操作</p></li><li><p>暂存操作</p></li><li><p>回退操作</p></li><li><p>标签操作</p></li><li><p>常规操作</p></li><li><ul><li>git创建项目仓库</li><li>忽略已加入到版本库中的文件</li><li>取消忽略文件</li><li>拉取、上传免密码</li></ul></li></ul><hr><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ol><li>git branch 创建分支</li><li>git branch -b 创建并切换到新建的分支上</li><li>git checkout 切换分支</li><li>git branch 查看分支列表</li><li>git branch -v 查看所有分支的最后一次操作</li><li>git branch -vv 查看当前分支</li><li>git brabch -b 分支名 origin&#x2F;分支名 创建远程分支到本地</li><li>git branch –merged 查看别的分支和当前分支合并过的分支</li><li>git branch –no-merged 查看未与当前分支合并的分支</li><li>git branch -d 分支名 删除本地分支</li><li>git branch -D 分支名 强行删除分支</li><li>git branch origin :分支名 删除远处仓库分支</li><li>git merge 分支名 合并分支到当前分支上</li></ol><h1 id="暂存操作"><a href="#暂存操作" class="headerlink" title="暂存操作"></a>暂存操作</h1><ol><li>git stash 暂存当前修改</li><li>git stash apply 恢复最近的一次暂存</li><li>git stash pop 恢复暂存并删除暂存记录</li><li>git stash list 查看暂存列表</li><li>git stash drop 暂存名(例：stash@{0}) 移除某次暂存</li><li>git stash clear 清除暂存</li></ol><h1 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h1><ol><li>git reset –hard HEAD^ 回退到上一个版本</li><li>git reset –hard ahdhs1(commit_id) 回退到某个版本</li><li>git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)</li><li>git reset HEAD file 撤回暂存区的文件修改到工作区</li></ol><h1 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h1><ol><li>git tag 标签名 添加标签(默认对当前版本)</li><li>git tag 标签名 commit_id 对某一提交记录打标签</li><li>git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注</li><li>git tag 列出所有标签列表</li><li>git show 标签名 查看标签信息</li><li>git tag -d 标签名 删除本地标签</li><li>git push origin 标签名 推送标签到远程仓库</li><li>git push origin –tags 推送所有标签到远程仓库</li><li>git push origin :refs&#x2F;tags&#x2F;标签名 从远程仓库中删除标签</li></ol><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><ol><li>git push origin test 推送本地分支到远程仓库</li><li>git rm -r –cached 文件&#x2F;文件夹名字 取消文件被版本控制</li><li>git reflog 获取执行过的命令</li><li>git log –graph 查看分支合并图</li><li>git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录</li><li>git check-ignore -v 文件名 查看忽略规则</li><li>git add -f 文件名 强制将文件提交</li></ol><h2 id="git创建项目仓库"><a href="#git创建项目仓库" class="headerlink" title="git创建项目仓库"></a>git创建项目仓库</h2><ol><li>git init 初始化</li><li>git remote add origin url 关联远程仓库</li><li>git pull</li><li>git fetch 获取远程仓库中所有的分支到本地</li></ol><h2 id="忽略已加入到版本库中的文件"><a href="#忽略已加入到版本库中的文件" class="headerlink" title="忽略已加入到版本库中的文件"></a>忽略已加入到版本库中的文件</h2><ol><li>git update-index –assume-unchanged file 忽略单个文件</li><li>git rm -r –cached 文件&#x2F;文件夹名字 (. 忽略全部文件)</li></ol><h2 id="取消忽略文件"><a href="#取消忽略文件" class="headerlink" title="取消忽略文件"></a>取消忽略文件</h2><ol><li>git update-index –no-assume-unchanged file</li></ol><h2 id="拉取、上传免密码"><a href="#拉取、上传免密码" class="headerlink" title="拉取、上传免密码"></a>拉取、上传免密码</h2><ol><li>git config –global credential.helper store</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作中常用Git-命令总结&quot;&gt;&lt;a href=&quot;#工作中常用Git-命令总结&quot; class=&quot;headerlink&quot; title=&quot;工作中常用Git 命令总结&quot;&gt;&lt;/a&gt;工作中常用Git 命令总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;git整理的有好几篇了，不</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="http://ai.mak.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>技术管理者应该管些什么？</title>
    <link href="http://ai.mak.cn/2019/10/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E5%BA%94%E8%AF%A5%E7%AE%A1%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>http://ai.mak.cn/2019/10/03/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E5%BA%94%E8%AF%A5%E7%AE%A1%E4%BA%9B%E4%BB%80%E4%B9%88/</id>
    <published>2019-10-02T16:00:00.000Z</published>
    <updated>2022-11-26T11:23:14.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术管理者应该管些什么"><a href="#技术管理者应该管些什么" class="headerlink" title="技术管理者应该管些什么"></a>技术管理者应该管些什么</h1><p><strong>作者介绍</strong></p><blockquote><p><strong>韩锋</strong>，**CCIA（中国计算机行业协会）常务理事、Oracle ACE、宜信技术研发中心主任工程师。精通多种关系型数据库，曾任职于当当网、TOM在线等公司，曾任多家公司首席DBA、数据库架构师等职，多年一线数据库架构、设计、开发经验。著有《SQL优化最佳实践》一书。</p></blockquote><p>在讲清楚技术管理者需要做哪些工作之前，我们通过一个驾马车的比喻类比描述下。</p><p>在驾驶马车之前，我们首先要看看马车的定位是什么(拉人?运货?等);其次，要看看目的地在哪里，该走哪条路，朝哪个方向行进;再次是当前马匹的情况怎么样(满员?伤病?等)。这些对应到管理中，就是得弄清楚团队的基本职能、工作目标、团队情况及可选路径，它们代表这方向性的东西，可简称为“管理规划”。</p><p>当我们开始驾驶马车时，至少需要做两件事：一边抓住马缰，关照好马的状态和组织分工;一边挥舞马鞭，协调好整个马队的前进方向和节奏，让马匹一起用力把车拉到一个个里程碑和目的地，完成一段一段的旅程。前者对应到管理中，很像是在做人和组织相关的工作，我们称为“带人”，或者“团队建设”;后者对应到管理中，很像是在完成一个个项目或一项项任务，我们称为“做事”，或者叫“任务管理”。</p><p>综合上面的比喻示例，可抽象概括下技术管理者需完成的工作如下，下面将展开说明。</p><p>(以下内容部分来自果见-刘建国系列文章)。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/8e40627a69be4ed088835ab666f1ebfe.jpeg" alt="img"></p><p><strong>一、管理规划：“敢问路在何方?”</strong></p><p>管理规划对于技术管理者来说，非常之重要。在日常工作中，技术管理者往往需面对大量纷繁复杂的事情，特别是有很多救火类的工作。但在忙乱之余，是不是有一个“全盘规划”的指引，清不清楚把团队带往何方，这才是不同leader领导水平的差距所在。出现问题就解决问题，是一种“问题驱动型思维”。而今天我们所谈论的”管理规划”，就是要回答”把团队带往何方”的这个方向性问题。通过理清未来的发展来理顺当前问题的带团队思路，称之为“规划驱动型思维”。</p><p><strong>1、职能</strong></p><p>在我们开始管理规划之初，首先要弄清楚就是“这是一支背负着什么样职责和使命的团队”。在明确之后，才能决定了你需要设定什么样的工作目标，并通过哪些要素来衡量你的目标;决定了你需要什么样的人加入你的团队，以及需要多少;还决定了你选择什么样手段，投入什么样的资源来完成工作。这个问题是如此重要，可将其作为管理规划的第一个要素，称之为团队“职能”;这是管理工作的起点。</p><p><strong>1)职能层次</strong></p><p>团队职能可分为两个层次：基本的职责和升华的使命。前者解决的是团队生存问题，后者解决的是团队发展问题。</p><p>职责。是团队职能的下限，即至少要完成的工作。如果这些职责都搞不定，意味着团队的基本价值都不能体现。一般来说，团队的基本职责，是由上级给定的，上级在把这个团队交给你负责的时候，已经给你提了期待，只不过有的上级会明确交代，而有的上级默认你很清楚。所以，你无论如何都需要弄清楚团队的基本职责，否则肯定会失职。</p><p>使命。是团队职能的上限，即，如果我们团队做得好，就能承担更大的职责，体现出更大的价值。使命达成后的愿景，常常是令人期待和憧憬的。使命愿景常常是团队leader自己的规划和设想。上级一般不会作出这样的要求，最多就是提一下期待，团队做不到也不会认为是团队失职。</p><p><strong>2)设定职能方法</strong></p><p><strong>①收集信息。</strong>可从多角度收集方方面面的信息，包括上级、同级和下级。对上级而言，需关注上级对团队的期待和要求，特别是用什么维度来衡量团队工作。团队的初始定位和基本职责，一般都是上级直接给定的。同级，则需关注与兄弟部门的职能边界，做好无缝衔接、共同发展。下级则可与大家讨论对团队工作的看法，以及对未来发展的期待。这也可为后续的沟通做好铺垫。当然最为重要的是管理者本身对工作的理解、期许。</p><p><strong>②提炼和升华。</strong>团队的职责和使命，不能只停留在leader的脑海中，为了方便记忆和传播，则必须从上述信息中进行提炼和升华。提炼和升华有三个要点：</p><p>职责的提炼。基于上级的期待和要求，以及你对业务核心价值的理解，最好用上级和团队成员、兄弟部门都易于理解的语言，对职责进行简短化提炼，并尽可能长时间稳定下来。</p><p>使命的升华。基于基本职责，寻找团队对于部门和公司的独特价值，并和行业发展趋势结合，设定自己的期待。要注意使用基于“结果”的描述，而非基于“过程”的描述，基于结果的描述会更有使命感。</p><p>确定衡量维度。一般来说，团队的职责和使命决定了衡量的维度，但是如果有明确的关于衡量维度的说法，会让员工对职责和使命有更深刻的理解。需要根据自己团队的职能，向员工明确传递，什么指标维度对团队是最重要的。</p><p><strong>③确认和主张。</strong>提炼完成之后，接下来就是确认和主张。确认主要是和自己的上级确认，得到上级的认同和支持后，就可以向团队内外进行主张了。主张的过程，就是一个长期宣贯的过程，不可能一蹴而就。这也是团队的文化建设的重要组成部分。</p><p><strong>2、目标</strong></p><p>在明确了团队职能后，下一步就是确定目标。类别前面的比喻，就是需要明确要去的目的地在哪里，才能评估需要什么样的马、多少匹，以及有哪些路线可以选择。这个关于”目的地在哪里”的问题，是管理规划的第二个要素，称为“目标”。</p><p><strong>1)设定目标意义</strong></p><p>问题明确的目标，对于技术团队管理非常具有意义。</p><p>目标设定，可以实现资源的有效配置。明确的目标可以让你把资源投注在有效的方向上，从“该做什么”去调配资源，而不是“能干什么”。</p><p>清晰明确的目标可以凝聚团队成员的力量，让大家劲往一处使，提升团队凝聚力。大家因为相同的目标而并肩作战，在一起取得成就的过程中建立起深厚的“革命友情”，这对凝聚力有莫大帮助。</p><p>清晰的目标，还是执行力的必要要素。回想一下，有多少工作是因为目标不够清晰，而最终有始无终。</p><p>清晰的目标还能提升判断力。当面对某个突发状况快速决策，你非常清晰想要的是什么。</p><p>清晰的目标本身就是激励，当员工很清楚自己的工作目标，方向感很清晰的时候，他们更容易进入一种投入度非常高，沉浸其中、物我两忘的工作状态。</p><p><strong>2)目标设定原则</strong></p><p>目标的设定，可遵从SMART原则。</p><p>Specific - 明确性。把目标设定到可以衡量的程度，就叫做明确了。常见的误区是，只做过程化描述，而没有结果。因此，面对这类问题和挑战的钥匙叫做“结果导向的描述”。</p><p>Measurable - 可衡量性。跟明确性紧密相关。在具体实施上，可参考有量化指标的KPI，或者目标导向的OKR形式。</p><p>Attainable - 可达性。标准上，不能定一个完全实现不了的很高的目标，也不能定一个不需要努力就能实现的很低的目标。定义一个有挑战且努力能达到的目标，才是恰当的。</p><p>Relevant - 相关性。对于技术团队来说很难跑偏，因为技术这个角色决定了其工作内容必定是和上、下游及上级目标相关联的。</p><p>Time-bound - 时限性。所有的目标都是基于一定时限的，缺少时间限制的目标没有意义。</p><p><strong>误区：以资源定目标</strong></p><p>常见的一类问题是基于现有资源做目标，而不是基于远方的目标往前推。常见的说法就是，“我们团队只能做到个程度”、“这些项目能做完就不错了”等。其实，更为合理的做法是，从上级的角度来讲，你的团队需要保证哪几项重要的结果，然后再看看如何调配和补充资源。简言之，破解之道就是“以终为始”。</p><p><strong>误区：目标变来变去</strong></p><p>定义的目标，有时不得不面临一些调整。有些是因为业务的原因，有些是因为上级领导变更的缘故等等。应对此类问题的方法就是“设定专业目标”，用专业目标来增强团队的内在定力。简言之，就是“做正确的事”。</p><p><strong>误区：事情太多忙不过来</strong></p><p>这是一个优先级的问题，可遵循“重要&#x2F;紧急象限法”进行分析。具体可参考下图，原则就是将“重要紧急”转换为“重要不紧急”，尽量减少“不重要紧急”类工作;以上措施就可以减少上述问题。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/443c8da203e440be8308cfd473819e46.jpeg" alt="img"></p><p><strong>3、团队</strong></p><p>针对团队，可以从多个视角来看待。</p><p><strong>1)根据团队目标去梳理团队</strong></p><p>作为管理规划的一部分，团队规划是管理者必须重点考量问题。这里需要去设定”团队目标”，即在某个时间点，团队发展成什么状态。有如下衡量指标：</p><p>团队的规模。也就是你团队有多少人，这其中要理清楚有多少人是现有的，有多少人是接下来要新增的，即实际人数和预算人数，加起来就是你规划的团队总规模。</p><p>团队的分工。即，你的团队都负责哪些业务，每个业务配置了多少人力，以及这些人员都如何分工，人力分布和业务目标是否匹配等。</p><p>团队的梯队。一个团队的梯队情况代表了团队的成熟度和复原力。梯队成熟的团队，不会因为一些偶然的因素(例如核心人员离职)就随便垮掉。复原力强的团队只是短暂影响部分业务进展，但是不会伤筋动骨、元气大伤，很快就会恢复正常。</p><p><strong>2)从资源角度来审视团队</strong></p><p>在很多互联网公司里，技术团队往往是最昂贵的资源和成本。作为一个管理者，在盘点自己当前人力和预算人力的时候，需要有成本意识，要考虑投入这么多资源和成本是否值得，是否合理。其实，即便你不考虑这个问题，你的上级也会考虑，所以，你预算人力的时候，最好能给出十分充分的理由。</p><p><strong>3)从人才培养角度看梯队规划</strong></p><p>对团队的盘点，还需要从人才培养角度来看。即，到下一个时间节点，你需要重点培养出哪些人，给他们什么样的平台和空间，以及你有能力提供给他们什么指导和支持，期待他们能够胜任什么职能和角色。</p><p><strong>4、路径</strong></p><p>在选择路径之前，需先考虑一个重要因素-资源。脱离资源评估的路径选择是没有意义的。</p><p><strong>1)资源评估</strong></p><p>这里所提到的资源，不仅仅包括通常意义上的“人、才、物”，还包括其他一些容易忽略的因素。</p><p>人。最为常见的资源，为参与到项目的人员。</p><p>财&#x2F;物。一般也是围绕着团队的人员来说的。</p><p>时间。最容易忽视的一类资源，时间长短直接影响人的投入。这里需要参考上级的预期，及你个人的客观分析，需要综合你对紧急重要程度的理解做出判断。</p><p>信息。是另外一个常被忽视的资源。有的时候，你需要更多的公司内外的信息，你的工作如果需要特殊的信息和数据，需要提前和上级沟通，寻求必要的支持。</p><p>权限。是否需要获得某些权限，作为资源投入。比如获得绩效评估的权限，以此来掌握人员激励的手段等。</p><p><strong>2)路径评估</strong></p><p>站在管理者视角上，就需要评估一段时间内的产出效率。完成一项工作，原来还有很多的手段可以选择。对于你来说，不同的方案意味着着多大程度的成本呢，可以尝试使用如下评估表。把你认为的“大”“中”“小”填入下表中。这个表格最大的意义不在于让你去评估每一种方案的成本大小，而在于扩展你的管理思路，看到解决问题手段的多样性，避免思路过于单一，就达到目的了。在不同的公司、不同的期待之下，不同的管理者会做出不同的选择。这不同的选择会带来不同的效果，同时也意味着不同的成本。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/26b48f944acd47ccaeb6b84cb7e4f50a.jpeg" alt="img"></p><p>对于自研来说，由于靠自己团队的力量，资金开销比较低，维护成本也可控;而由于需要边学边做，时间成本会比较高。</p><p>对于招聘来说，不确定性比较高，招聘顺利固然好，但招聘不顺则时间完全不可预期，整体上时间成本比较高。</p><p>对于借调来说，如果能借调到合适的人，各方面的成本是最低的，但是需要这个事情足够重要才能获得支持。</p><p>对于跨部门合作来说，项目推进的可控性取决于合作情况，这里最大的风险就是合作成本能否控制住。</p><p>对于外包来说，时间和资金成本一般都可控，用来做尝试性项目或者demo是比较合理的。但如果是长期的任务，你会发现外包的解决方案可维护性比较差，迁移和替换的成本会比较高。</p><p>采购云服务，对于中小公司来说，其实是很好的解决方案，对人才成本、维护成本、时间成本，都可以降得很低，特别适合初创公司，所以你看业内的云服务层出不穷，确实有价值。</p><p>商业方案，是时间成本很低，资金成本略高的一种方案。在应急的情况下，或者是公司非核心业务的场景下，这倒不失为一种好的解决方案。</p><p><strong>二、团队建设：“众人拾柴火焰高”</strong></p><p>团队建设的核心，在于提高“效率”。参照之前的”工作目标达成分解图”，可将其划分为个体、个体间和团队三个层次。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/e42773433d1e4b21a19d2db36dc7097f.jpeg" alt="img"></p><p>针对个体而言，重点在于提升能力和个人意愿。</p><p>针对个体间而言，在于加强分工和协作。</p><p>针对团队，在于构建梯队和文化认同。</p><p><strong>1、能力</strong></p><p><strong>1)能力分层</strong></p><p>员工的工作能力是由三个方面共同决定的，下图可见。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/855cebce2af34c7fb9f145873bc041b3.jpeg" alt="img"></p><p>人格力量。通常是指一个人在面对某一情形时稳定的态度和表现，比如迎难而上、坚持不懈、积极正向、主动担当等等。这些人格力量对于个人能否搞定一件事情有时至关重要，但是培养起来却不是一朝一夕的，关键在于平时。</p><p>通用能力。没有一个统一的标准，比如我会把沟通表达能力、团队协作能力、快速学习能力等作为重要的通用能力，并和我的团队达成共识。这些能力是可以迁移的，会伴随员工受益终身。</p><p>专业能力。对于技术人来说，一般是指技术能力。很多公司都有技术能力衡量标准和体系，用于评估工程师的技术水平。所以，工程师专业能力的评价维度和标准相对于通用能力更加有据可循。</p><p><strong>2)鼓励学习</strong></p><p>可以组织多种形式，鼓励员工学习。</p><p>第一类：帮助员工自学。可组织内外部培训、购买书籍等形式。</p><p>第二类：相互交流讨论。可通过定期复盘、技术交流、代码审核等手段进行。</p><p>第三类：工作实践。给员工独立负责重要工作的机会，并给予辅导和反馈。</p><p>对于提升员工个人能力来说，最关键的往往不是学习的方法，而是学习的意愿。对于很多团队来说，并不缺少学习的机制，而是没有能够有效激发员工的学习动力。主动学习的员工总会是少数派，不只是公司的员工如此，社会生活中的人们亦是如此，所以有人说，“学习是反人性的事情!”。可通过下面多种手段，激发很多员工的学习动力了，你甚至可以把学习和成长放入团队文化建设当中。当然，如果你要把学习作为团队文化的一部分，那就需要你自己首先有学习的“基因”。</p><p>推 - 给予压力，推动他们学。比如提出明确的学习机制、工作要求，必要时与绩效、晋升机会、调薪挂钩。</p><p>拉 - 指明方向，引导他们学。通过树立榜样、配备导师、辅导方式，引导大家学习。</p><p>放 - 给予空间，让他们自主学。在可控情况下，给予员工空间、机会及耐心，让员工充分施展。</p><p><strong>2、激励</strong></p><p>1)理论 - 马斯洛的需求层次模型</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/14a18dc853b74ff4822d35e980eee4a6.jpeg" alt="img"></p><p>最原始的驱动力主要来源于对生存和安全的渴望，需求层次处于“马斯洛需求模型”的最底层。这类驱动力是人们为了寻求生存下去的基本要素而努力。</p><p>第二类驱动，就是“奖励好的行为、惩罚坏的行为”，也就是人们经常念叨的“胡萝卜加大棒”。这是被广泛认同的激励方式，也是当前大部分管理者最常用的激励手段。</p><p>第三类驱动，更加强调自驱力。随着中国经济和文化发展，物质奖惩和别人的评价变得不如从前那么令人关注。很多 90 后职场人有着自己笃定的价值观。此外，在这样一个信息时代，员工的创造力更能为公司创造价值，而创造力需要更多的自主和差异。</p><p>2)如何激励</p><p>第一，激励要立体。你需要从单一的激励维度，升级为更加立体的激励体系，从而适应新职场环境的要求。</p><p>第二，激励在平时。不能指望一些临时性刺激方案来做好激励，激励体系的搭建应在平时。当员工跟你提离职的时候，它就已经不再是一个激励问题了。</p><p>第三，激励要设计。由于每个人的业务特点不同、团队性质不同、管理风格不同、员工特征不同、问题挑战不同，所以不要迷信别人给你的激励建议，我更建议你充分考虑自己面临的实际情况，结合自己的特质和激励框架，来设计适用于自己的激励体系。</p><p><strong>3、分工</strong></p><p>不能简单地认为分工一定是件好事。分工是不是好事取决于协作水平，协作水平又受限于管理者的管理水平。通常分工的目的是为了实现规模化(多人干大事)或实现专业化分工(用人之长、避人之短)。</p><p><strong>组织结构</strong></p><p>从一个业务所涉及的各个角色的分工情况来看，互联网领域最常见的组织结构有两类，一类是矩阵式的，一类是BU式的。</p><p>矩阵式结构。员工按照角色被划分到不同的团队，每个团队都有自己的负责人。要做项目的时候，会有专门的项目经理来向各个角色的leader协调人力，然后把申请到的各个角色的人组织在一起去完成这个特定项目。一旦项目完成之后，人员将回归各自团队去迎接新的项目。人力资源是按照角色“横向”来组织的，而项目执行是按照任务“纵向”来推动的，就形成了一个纵横交错的矩阵式结构，所以叫矩阵式组织结构。这类组织架构的好处是各个角色团队的专业度都会很高，而且角色归属感比较强，资源调配灵活;但不足之处是项目执行起来较为低效，因为每次都要重新申请人力，而且每次的项目团队都需要重新磨合。</p><p>BU式结构。就是“业务单元”式，也叫事业部制，是指做某项业务所有的人员和资源都统一调配，无论这个事业部是大是小，都角色齐全。这样做的好处是团队长期合作磨合充分，协作效率高，执行速度快;不足是各种角色自己都要有，资源冗余和浪费比较多。另外，由于某些角色不在业务主干上，团队规模比较小，能力要求也不高，所以其角色专业度很难提升。</p><p><strong>4、协作</strong></p><p>“就是只要一句话，甚至是一个动作、一个眼神，对方就知道是什么意思。”显然，协作水平很高的团队，就好像一部良好运转的机器一样，既有分工，又彼此紧密连接，形成一个有机整体。其核心在于：</p><p>一是建立协作机制，通过机制来约定协作的动作，以此来保证大家“动作协调”;</p><p>二是提升团队凝聚力，通过提升团队成员间的信任度、认同度和默契度来降低协作成本，提高协作效率。</p><p>可以说，“硬件”靠机制，而“软件”靠凝聚力。</p><p><strong>1)提升凝聚力</strong></p><p>设立共同愿景。想提升团队凝聚力的时候，总是希望大家“心往一处想，劲往一处使。这就要求团队首先要有一个使命和愿景，有一个共同的长远目标，供大家“往一处想”。如果团队有着自己的使命，又能得到团队成员的普遍认同，大家会更容易朝着一个方向共同努力，也更容易肩并肩地一起迎接挑战，即所谓的“志同道合”。</p><p>提升员工归属，让员工从心里就认为自己是团队的一份子。你要分给他一份职责，人的内心深处是渴望承担适当的责任的。有当员工清楚自己能为团队做出什么贡献的时候，才会心安，才会感受到自己是团队的一份子。要让员工清楚他肩负的职责对于团队的意义，让他觉得自己做的事有价值，这就是所谓的“事对”。</p><p>要营造良好的团队人际关系，让彼此间形成紧密的连接。团队成员间良好的关系，和团队凝聚力的提升是互为因果的，所以不要小看能促进员工间关系的一些小事，恰恰是这些小事，能够促使员工间的合作关系走上正向循环的轨道，员工会因为喜欢和团队的人相处而觉得有归属感。这就是所谓的“人对”。</p><p>明确亮出团队的文化价值观。团队的文化和价值观是否是员工认同和欣赏的，决定了他能否长期留在团队。价值观方面的冲突是很难调和的，好的团队文化本身就是一个筛选器，最终留在团队发挥核心作用的都会是认同团队价值观的人。因喜欢一个团队的文化和氛围而产生归属感，这就是所谓的“味对”。</p><p>加强相互了解。团队成员间需要不断深入地相互了解和认同。可以通过一些方式增加员工间了解，例如团建活动。这里是需要花点心思去设计的，对增进大家的了解和信任做必要的设计。</p><p>共同面对挑战。一起面对挑战的时候，特别能够让大家拧成一股绳。显然一起扛过枪的兄弟，感情是很铁的，毕竟是经历过不离不弃的并肩作战。可以通过攻关项目、紧急故障等，甚至是一些组队的对抗性游戏，都可以得到提升。</p><p><strong>5、梯队</strong></p><p>一个团队的梯队，就好像一个团队的“骨架子”，这“骨架子”是否健康良好，决定了团队是否健壮。其重点在于梯队的规划和建设方面。规划在前文已谈到，建设就是需要选拨人，并培养成核心骨干的过程。</p><p><strong>1)选拔人才</strong></p><p>对骨干人员的选择要遵从你团队建设的理念。除了基本的个体能力要强，有成长潜质之外。更重要的是强调其协作能力，因为这些骨干未来不是一个人工作，而是要带领团队的。要强调其行为风格和价值观与团队整体文化相匹配。例如团队强调“勇于创新”，那么一个墨守成规的人员显然不适合成为骨干去培养。</p><p><strong>2)培养人才</strong></p><p>对齐期待，达成共识。常用方式是IDP，即个人发展计划。可以将IDP与绩效结合起来，就是说培养人才也是要以做出绩效为依托，而不只是为了培养而培养。通过IDP可以对齐你和培养对象彼此的期待，让他清楚你关注的是什么，在这个事情上形成共识，从而形成良好的互动和有效的反馈。但在这过程中需要注意，不要以晋升等作为承诺。一方面，晋升等是需要靠员工表现来获得，而不是靠承诺;另一方面也要留有培养失败的退路，避免不必要的人才流失。</p><p>提供机会，做好授权。培养的过程是需要在做事上体现的，你需要给培养对象足够的发挥空间，也就不可避免地要做工作授权。</p><p><strong>工作授权三段法</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/e837205563b04f07bc00595b7b82d7d7.jpeg" alt="img"></p><p>授权整个过程可划分为事前、事中、事后三个阶段。其重点在于事前的安排和事后的反馈。因为既然是授权，事中最好不要干涉太多，只做约定好的check和支持就好。</p><p>事前阶段。管理者首先要明确此次授权的初衷是什么。如果是有多重目标，那么主次关系如何。进而让培养对象明确你的期待是什么。此处可沿用目标管理的SMART原则，双方需要明确要求、口径等。在完成授权任务后，需听取其对工作的看法和思路，进而大致判断是否可行，规避风险。最后约定一个沟通机制，为事中做铺垫。</p><p>事中阶段。需要管理者定期了解工作进度、评估风险，必要时给予支持，而不是放任自流。在支持方面可遵循“授人以渔”的原则。</p><p>事后阶段。对于授权后的工作结果进行评估，并与培养对象充分沟通反馈。注意你的授权目标本身不仅仅只有事情，还有培养目标的。对于培养对象在工作中好的表现，要给予充分肯定，特别是要其优势所在;针对不足之处提供1~2条修改建议，以利后续改进。</p><p><strong>6、文化</strong></p><p>团队文化就好像是团队的气质和调性，它会吸引“气味相投”的人持续加入，而把不符合团队气质的人筛选出去，越来越鲜明的团队价值观让大家紧密地聚拢在一起，从而让团队越来越“结实”，越来越“经得起折腾”，不断增强团队的耐力和韧劲。关于团队文化部分，我之前有文章专门说明，这里就不展开了。</p><p><strong>三、任务管理：“不以规矩，不成方圆”</strong></p><p>我们研究任务管理，就是为了把事情做出来，产出实实在在的业绩和成果。作为结果导向的管理者，这才是管理工作的落脚点。同时，也是验证管理规划是否合理、团队建设是否有效的最重要的标准和依据。对任务执行，可划分为三个阶段：</p><p>在做事之前，我们需要回答的问题是：要做哪些事?先做哪件，后做哪件?也就是分清楚轻重缓急，也叫优先级梳理。</p><p>在做事过程中，我们要确保事情的进展按照计划推进，尽在掌握之中，也就是有效执行。</p><p>在做事之后，我们要复盘做事的整个过程，并从过去的经验之中抽取一些流程机制，以便以后在类似的场景下也可以做得更好、更顺畅。</p><p><strong>1、轻重缓急</strong></p><p>对于每个团队来说，当下能做的工作是有限的，增加并发并不会让大家的产出更高效，所以，多任务并行问题归根结底还是优先级问题，即，你要优先保证哪项工作的顺利进行。</p><p><strong>1)重要紧急四象限</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/c00a9160cdc3483392b0cf12c933fa4c.jpeg" alt="img"></p><p><strong>2)判断标准</strong></p><p>如果做，收益是否很大?收益越大，这个事情就越重要。</p><p>如果不做，损失是否很大?损失越大，这个事情就越紧急。</p><p><strong>3)应对策略</strong></p><p>对于“计划内的工作”，关注它在一个规划周期内的价值和收益有多大。收益越大就越重要，也就越需要给予相匹配的优先级、资源和关注度;收益相对不大，就放入“To do list”，作为待办任务处理。</p><p>对于“计划外的工作”，看损失是否足够大，这里包括自身损失和因中断正常工作带来的损失。损失够大，就按照紧急任务安排，以止损为核心目的;如果损失可控，就放入“计划内工作”列表。</p><p><strong>4)持续改进</strong></p><p>原则上，管理者的中心应该在那些“重要不紧急”的工作上，这些是对团队长期受益的，应该作为主要目标。</p><p>“重要且紧急”的工作，要分析其紧急原因，将其流程化、自动化，逐步过渡到不紧急的状态。</p><p>“不重要紧急”的工作，往往是事务类的，可交由下属处理，长期可通过自动化改进其紧急状态。</p><p>“不重要不紧急”的工作，要反思其价值，是否仍然作为核心工作之一。</p><p><strong>2、有效执行</strong></p><p>在项目执行中，是否能有效执行，取决于多个因素。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190929/4ce8392efb0d4422a8ce5ed43d98bc8c.jpeg" alt="img"></p><p>目标清晰。在执行之初，就需要对目标有明确且具体的定义，具体到可执行层面;而且要确保上下级对其理解是一致，没有偏差。当目标出现变化时，要做到及时同步。如果目标不清晰，必然会引起员工在紧急程度、质量水平和效果取舍上的偏差，最后也就引发了执行上的偏离预期。</p><p>责任明确。明确工作的“唯一”负责人，避免出现无人负责、多人负责等情况。负责人要起到对应的责任，有关项目中所有涉及项目执行和协调的问题都要负责。</p><p>机制健全。不要沉迷于依靠个人完成项目，需要有完善的流程和机制，让员工做事有依据。同时对应还需要必要的监督机制，不要将“流程机制”束之高阁。</p><p>沟通到位。在执行中，强调主动沟通意识，要做到沟通闭环，而不要想当然。</p><p><strong>3、流程机制</strong></p><p>在任务执行之后，针对任务中可抽象出来的部分，可制订必要的流程机制。在指定过程中，可明确几个原则：明确目标、责任到人、检查复核、降低成本、全员共识。避免出现为了流程而制定流程的情况，要做到尽量简化，能解决具体问题。</p><p><strong>观点：人靠谱 OR 机制靠谱?</strong></p><p>人的靠谱度的方差比机制大，即，人靠谱的时候比机制靠谱，人不靠谱的时候会比机制更加不靠谱。即便是最靠谱的员工，也会由于身体状态、精神状态、情绪状态以及外部干扰变得偶尔不靠谱;而机制的意义就在于，当人不靠谱时，事情也不至于变得很差。所以，机制是为了保证做事的“下限”的。同时，机制有很好的迁移性和传承性，不会随着某个人的缺位而产生大的影响。因此，必要的机制是不可或缺的。</p><p><strong>番外篇：“如何做好技术判断?”</strong></p><p>作为技术管理者，和普通管理者最大的区别，就是”技术”二字，这也是技术管理者最鲜明的标签和最大的竞争力。从技术工程师到技术管理者的转型，有很多做事的思路和方法都需要转变，其中一个重要的转变就是你和技术的关系。其核心在于从技术实现者到技术应用者的转变，不断提升的是技术的使用能力，而技术实现能力由于投入的时间越来越少，会逐渐减弱。从技术管理者自身来说，既然你选择了做更大的事情，就不得不适当放弃一些细节，放弃一些技术实现能力，不断提升你的技术判断力，让团队行走在正确的方向上。</p><p><strong>1、角色转换</strong></p><p>技术管理者，对待技术与技术人员会有所区别，是有个角色的转换。</p><p>技术实现者：程序设计能力、编码实现能力、技术攻坚能力和技术评估能力，都是需要具备的，主要关心的是”怎么做”，属于”how”的范畴。</p><p>技术应用者：技术评估能力变得尤其重要，因为技术管理者主要关心的是”要不要做”、”做什么”，属于”why”和”what”的范畴，是要在综合评估之后，做出决策和判断的</p><p><strong>2、评估维度</strong></p><p><strong>1)结果评估</strong></p><p>要回答”要不要做”，希望拿到什么结果，你要从哪几个维度去衡量结果，从哪几个技术指标去验收成果。事关每项工作的效果和业绩，对结果的评估能力最为关键。虽然结果验收都是放在项目完成后，但是在事先就要明确如何验收，这样才能让大家有的放矢，以终为始。</p><p><strong>2)可行性评估</strong></p><p>可行性有两层含义：一是”能不能做”，二是”值不值得”。作为技术管理者需要做好角色转换，更多从”值不值得”着手，就是成本收益问题。收益，往往是显而易见的;而成本，就有很多方面需要考虑了，这正是体现技术判断力的地方。</p><p>资源成本 — “人财物时”。需要投入多少人、多少时间，甚至是多少资金和物资在该项目上，这项成本相对容易评估。</p><p>维护成本。这是评估技术方案时要重点考虑的。考虑维护成本是技术管理者和架构师视野宽阔、能力成熟的体现。这里面包括：技术选型成本、升级成本、问题排查成本、代码维护成本等。</p><p>协作成本。多人协作所增加的时间精力开销。一个方案的协作方越多，需要沟通协调的成本也就越高，可控度越低。如果可能的话，尽量减少不同团队和人员之间的耦合，这样会大大降低协作成本。</p><p>机会成本。这是技术管理者做决策时要意识到的。即当你把人力、时间花在这件事上，同时就等于放弃了另外一件事，而没有做另外这件事将带来什么样的影响呢?就是你要考虑的机会成本。</p><p><strong>3)技术风险评估</strong></p><p>也叫技术风险判断力。即，有哪些技术风险需要未雨绸缪，考虑该技术方案带来最大损失的可能性和边界，以及在什么情形下会发生。这项评估工作很考验技术管理者的技术经验和风险意识，而且需要借助全团队的技术力量来做出准确判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术管理者应该管些什么&quot;&gt;&lt;a href=&quot;#技术管理者应该管些什么&quot; class=&quot;headerlink&quot; title=&quot;技术管理者应该管些什么&quot;&gt;&lt;/a&gt;技术管理者应该管些什么&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;作者介绍&lt;/strong&gt;&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="技术团队" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程总结</title>
    <link href="http://ai.mak.cn/2019/09/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2019/09/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-22T16:00:00.000Z</published>
    <updated>2022-11-26T11:22:38.650Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将总结多线程并发的各种处理方式，希望对大家有所帮助。</p><h2 id="一、多线程为什么会有并发问题"><a href="#一、多线程为什么会有并发问题" class="headerlink" title="一、多线程为什么会有并发问题"></a>一、多线程为什么会有并发问题</h2><p>为什么多线程同时访问（读写）同个变量，会有并发问题？</p><blockquote><ol><li>Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。</li><li>线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</li><li>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</li><li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li></ol></blockquote><h2 id="二、Java-内存模型（JMM）"><a href="#二、Java-内存模型（JMM）" class="headerlink" title="二、Java 内存模型（JMM）"></a>二、Java 内存模型（JMM）</h2><p>Java 内存模型(JMM) 作用于工作内存（本地内存）和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步，如下图。</p><p><img src="https://aimak.cn/blog_img/java/jmm-model.jpg" alt="JMM"></p><h2 id="三、并发三要素"><a href="#三、并发三要素" class="headerlink" title="三、并发三要素"></a>三、并发三要素</h2><p><strong>原子性</strong>：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</p><p><strong>可见性</strong>：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</p><h2 id="四、怎么做，才能解决并发问题？（重点）"><a href="#四、怎么做，才能解决并发问题？（重点）" class="headerlink" title="四、怎么做，才能解决并发问题？（重点）"></a>四、怎么做，才能解决并发问题？（重点）</h2><p>下面结合不同场景分析解决并发问题的处理方式。</p><h3 id="一、volatile"><a href="#一、volatile" class="headerlink" title="一、volatile"></a>一、volatile</h3><h4 id="1-1-volatile-特性"><a href="#1-1-volatile-特性" class="headerlink" title="1.1 volatile 特性"></a>1.1 volatile 特性</h4><p><strong>保证可见性，不保证原子性</strong></p><blockquote><ol><li>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</li><li>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。</li></ol></blockquote><p><strong>禁止指令重排序</strong> 指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则：</p><blockquote><ol><li>不会对存在依赖关系的指令重排序，例如 a &#x3D; 1;b &#x3D; a;  a 和b存在依赖关系，不会被重排序</li><li>不能影响单线程下的执行结果。比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作,前两个操作可以重排序，但是c&#x3D;a+b不会被重排序，因为要保证结果是3</li></ol></blockquote><h4 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h4><p>对于一个变量，只有一个线程执行写操作，其它线程都是读操作，这时候可以用 volatile 修饰这个变量。</p><h4 id="1-3-单例双重锁为什么要用到volatile？"><a href="#1-3-单例双重锁为什么要用到volatile？" class="headerlink" title="1.3 单例双重锁为什么要用到volatile？"></a>1.3 单例双重锁为什么要用到volatile？</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestInstance</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TestInstance mInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestInstance <span class="title">getInstance</span>()</span>&#123;       <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;                     <span class="comment">//2</span></span><br><span class="line">        synchronized (TestInstance.<span class="keyword">class</span>)&#123;      <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;             <span class="comment">//4</span></span><br><span class="line">                mInstance = <span class="keyword">new</span> TestInstance(); <span class="comment">//5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>}</p><p>假如没有用volatile，并发情况下会出现问题，线程A执行到注释5 <code>new TestInstance()</code> 的时候，分为如下几个几步操作：</p><ol><li>分配内存</li><li>初始化对象</li><li>mInstance 指向内存</li></ol><p>这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断mInstance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。</p><h4 id="1-4-volatile-原理"><a href="#1-4-volatile-原理" class="headerlink" title="1.4 volatile 原理"></a>1.4 volatile 原理</h4><p>在JVM底层volatile是采用<strong>内存屏障</strong>来实现的，内存屏障会提供3个功能：</p><blockquote><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将缓存的修改操作立即写到主内存</li><li>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</li></ol></blockquote><h4 id="1-5-volatile-的局限性"><a href="#1-5-volatile-的局限性" class="headerlink" title="1.5 volatile 的局限性"></a>1.5 volatile 的局限性</h4><p><strong>volatile 只能保证可见性，不能保证原子性</strong>写操作对其它线程可见，但是不能解决多个线程同时写的问题。</p><h3 id="二、Synchronized"><a href="#二、Synchronized" class="headerlink" title="二、Synchronized"></a>二、Synchronized</h3><h4 id="2-1-Synchronized-使用场景"><a href="#2-1-Synchronized-使用场景" class="headerlink" title="2.1 Synchronized 使用场景"></a>2.1 Synchronized 使用场景</h4><p>多个线程同时写一个变量。</p><p>例如售票，余票是100张，窗口A和窗口B同时各卖出一张票， 假如余票变量用 volatile 修饰，是有问题的。<br> A窗口获取余票是100，B窗口获取余票也是100，A卖出一张变成99，刷新回主内存，同时B卖出一张变成99，也刷新回主内存，会导致最终主内存余票是99而不是98。</p><p>前面说到 volatile 的局限性，就是多个线程同时写的情况，这种情况一般可以使用<strong>Synchronized</strong>。</p><p><strong>Synchronized 可以保证同一时刻，只有一个线程可执行某个方法或某个代码块。</strong></p><h4 id="2-2-Synchronized-原理"><a href="#2-2-Synchronized-原理" class="headerlink" title="2.2 Synchronized 原理"></a>2.2 Synchronized 原理</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    synchronized (SynchronizedTest.<span class="keyword">class</span>) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将这段代码先用<code>javac</code>命令编译，再<code>java p -v SynchronizedTest.class</code>命令查看字节码，部分字节码如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line"><span class="attr">descriptor:</span> <span class="string">([Ljava/lang/String;)V</span></span><br><span class="line"><span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_STATIC</span></span><br><span class="line"><span class="attr">Code:</span></span><br><span class="line">  <span class="string">stack=2,</span> <span class="string">locals=3,</span> <span class="string">args_size=1</span></span><br><span class="line">     <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // class com/lanshifu/opengldemo/test/SynchronizedTest</span></span><br><span class="line">     <span class="attr">2:</span> <span class="string">dup</span></span><br><span class="line">     <span class="attr">3:</span> <span class="string">astore_1</span></span><br><span class="line">     <span class="attr">4:</span> <span class="string">monitorenter</span></span><br><span class="line">     <span class="attr">5:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">     <span class="attr">8:</span> <span class="string">ldc</span>           <span class="comment">#4                  // String 123</span></span><br><span class="line">    <span class="attr">10:</span> <span class="string">invokevirtual</span> <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">    <span class="attr">13:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">14:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">15:</span> <span class="string">goto</span>          <span class="number">23</span></span><br><span class="line">    <span class="attr">18:</span> <span class="string">astore_2</span></span><br><span class="line">    <span class="attr">19:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">20:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">21:</span> <span class="string">aload_2</span></span><br><span class="line">    <span class="attr">22:</span> <span class="string">athrow</span></span><br><span class="line">    <span class="attr">23:</span> <span class="string">invokestatic</span>  <span class="comment">#6                  // Method method:()V</span></span><br><span class="line">    <span class="attr">26:</span> <span class="string">return</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>4: monitorenter</code> 和 <code>14: monitorexit</code>，中间是打印的语句。</p><p>执行同步代码块，首先会执行<code>monitorenter</code>指令，然后执行同步代码块中的代码，退出同步代码块的时候会执行<code>monitorexit</code>指令 。</p><blockquote><p>使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就进入同步队列，线程状态变成BLOCK，同一时刻只有一个线程能够获取到monitor，当监听到monitorexit被调用，队列里就有一个线程出队，获取monitor。详情参考：<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/d53bf830fa09">www.jianshu.com/p/d53bf830f…</a></p></blockquote><p>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一，所以只要这个锁的计数器大于0，其它线程访问就只能等待。</p><h4 id="2-3-Synchronized-锁的升级"><a href="#2-3-Synchronized-锁的升级" class="headerlink" title="2.3 Synchronized 锁的升级"></a>2.3 Synchronized 锁的升级</h4><p>大家对Synchronized的理解可能就是重量级锁，但是Java1.6对 Synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p><p><strong>偏向锁：</strong> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><blockquote><p>当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。</p></blockquote><p><strong>轻量级锁：</strong> 在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。</p><p><strong>重量级锁：</strong> 如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p><h4 id="2-4-Synchronized-缺点"><a href="#2-4-Synchronized-缺点" class="headerlink" title="2.4  Synchronized 缺点"></a>2.4  Synchronized 缺点</h4><ol><li>不能设置锁超时时间</li><li>不能通过代码释放锁</li><li>容易造成死锁</li></ol><h3 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h3><p>上面说到<code>Synchronized</code>的缺点，不能设置锁超时时间和不能通过代码释放锁，<code>ReentranLock</code>就可以解决这个问题。</p><p><strong>在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适</strong>，ReentrantLock还提供了<code>Condition</code>，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</p><h4 id="3-1-ReentrantLock-的使用"><a href="#3-1-ReentrantLock-的使用" class="headerlink" title="3.1 ReentrantLock 的使用"></a>3.1 ReentrantLock 的使用</h4><p><strong>lock 和 unlock</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;lock&quot;</span>);</span><br><span class="line">        reentrantLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;睡眠2秒...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>实现可定时的锁请求：tryLock</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    public static void <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        ReentrantLock reentrantLock = new <span class="built_in">ReentrantLock</span>();</span><br><span class="line">        Thread thread1 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread1<span class="selector-class">.setName</span>(&quot;thread1&quot;);</span><br><span class="line">        thread1<span class="selector-class">.start</span>();</span><br><span class="line">        Thread thread2 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread2<span class="selector-class">.setName</span>(&quot;thread2&quot;);</span><br><span class="line">        thread2<span class="selector-class">.start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class Thread_tryLock extends Thread &#123;</span><br><span class="line">        ReentrantLock reentrantLock;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Thread_tryLock</span>(ReentrantLock reentrantLock) &#123;</span><br><span class="line">            this<span class="selector-class">.reentrantLock</span> = reentrantLock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                boolean tryLock = reentrantLock<span class="selector-class">.tryLock</span>(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                if (tryLock) &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock success :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;睡眠一下：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    Thread<span class="selector-class">.sleep</span>(<span class="number">5000</span>);</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;醒了：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock 超时 :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;unlock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                reentrantLock<span class="selector-class">.unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>打印的日志：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> lock:thread1</span><br><span class="line"><span class="keyword">try</span> lock:thread2</span><br><span class="line"><span class="keyword">try</span> lock success :thread2</span><br><span class="line">睡眠一下：thread2</span><br><span class="line"><span class="keyword">try</span> lock 超时 :thread1</span><br><span class="line">unlock:thread1</span><br><span class="line"><span class="built_in">Exception</span> in thread <span class="string">&quot;thread1&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock<span class="variable">$Sync</span>.<span class="title function_ invoke__">tryRelease</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">151</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.<span class="title function_ invoke__">release</span>(AbstractQueuedSynchronizer.<span class="attr">java</span>:<span class="number">1261</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.<span class="title function_ invoke__">unlock</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">457</span>)</span><br><span class="line">at com.lanshifu.demo_module.test.lock.ReentranLockTest<span class="variable">$Thread_tryLock</span>.<span class="title function_ invoke__">run</span>(ReentranLockTest.<span class="attr">java</span>:<span class="number">60</span>)</span><br><span class="line">醒了：thread2</span><br><span class="line">unlock:thread2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面演示了<code>trtLock</code>的使用，<code>trtLock</code>设置获取锁的等待时间，超过3秒直接返回失败，可以从日志中看到结果。 有异常是因为thread1获取锁失败，不应该调用unlock。</p><h4 id="3-2-Condition-条件"><a href="#3-2-Condition-条件" class="headerlink" title="3.2 Condition 条件"></a>3.2 Condition 条件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Thread_Condition thread_condition = <span class="keyword">new</span> Thread_Condition();</span><br><span class="line">        thread_condition.setName(<span class="string">&quot;测试Condition的线程&quot;</span>);</span><br><span class="line">        thread_condition.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread_condition.singal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Thread_Condition</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">await</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">public</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:我在等待通知的到来...&quot;</span>);</span><br><span class="line">                condition.<span class="keyword">await</span>();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                <span class="comment">//condition.await(2, TimeUnit.SECONDS); //设置等待超时时间</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:等到通知了，我继续执行&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singal</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;我要通知在等待的线程，condition.signal()&quot;</span>);</span><br><span class="line">                condition.signal();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行打印日志</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span></span><br><span class="line">测试Condition的线程:我在等待通知的到来...</span><br><span class="line"><span class="keyword">lock</span></span><br><span class="line">我要通知在等待的线程，condition.signal()</span><br><span class="line">unlock</span><br><span class="line">测试Condition的线程:等到通知了，我继续执行&gt;&gt;&gt;</span><br><span class="line">unlock</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面演示了<code>Condition的 await 和 signal</code> 使用，前提要先lock。</p><h4 id="3-3-公平锁与非公平锁"><a href="#3-3-公平锁与非公平锁" class="headerlink" title="3.3 公平锁与非公平锁"></a>3.3 公平锁与非公平锁</h4><p>ReentrantLock 构造函数传true表示公平锁。</p><p>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的顺序。而非公平锁就是一种锁的抢占机制，是随机获得锁的，可能会导致某些线程一致拿不到锁，所以是不公平的。</p><h4 id="3-4-ReentrantLock-注意点"><a href="#3-4-ReentrantLock-注意点" class="headerlink" title="3.4 ReentrantLock  注意点"></a>3.4 ReentrantLock  注意点</h4><ol><li>ReentrantLock使用lock和unlock来获得锁和释放锁</li><li>unlock要放在finally中，这样正常运行或者异常都会释放锁</li><li>使用condition的await和signal方法之前，必须调用lock方法获得对象监视器</li></ol><h3 id="四、并发包"><a href="#四、并发包" class="headerlink" title="四、并发包"></a>四、并发包</h3><p>通过上面分析，并发严重的情况下，使用锁显然效率低下，因为同一时刻只能有一个线程可以获得锁，其它线程只能乖乖等待。</p><p>Java提供了并发包解决这个问题，接下来介绍并发包里一些常用的数据结构。</p><h4 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h4><p>我们都知道HashMap是线程不安全的数据结构，HashTable则在HashMap基础上，get方法和put方法加上Synchronized修饰变成线程安全，不过在高并发情况下效率底下，最终被<code>ConcurrentHashMap</code>替代。</p><p>ConcurrentHashMap 采用分段锁，内部默认有16个桶，get和put操作，首先将key计算hashcode，然后跟16取余，落到16个桶中的一个，然后每个桶中都加了锁（ReentrantLock），桶中是HashMap结构（数组加链表，链表过长转红黑树）。</p><p>所以理论上最多支持16个线程同时访问。</p><h4 id="4-2-LinkBlockingQueue"><a href="#4-2-LinkBlockingQueue" class="headerlink" title="4.2 LinkBlockingQueue"></a>4.2 LinkBlockingQueue</h4><p>链表结构的阻塞队列，内部使用多个ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>源码不贴太多，简单说一下<code>LinkBlockingQueue</code> 的逻辑：</p><blockquote><ol><li>从队列获取数据，如果队列中没有数据，会调用<code>notEmpty.await();</code>进入等待。</li><li>在放数据进去队列的时候会调用<code>notEmpty.signal();</code>，通知消费者，1中的等待结束，唤醒继续执行。</li><li>从队列里取到数据的时候会调用<code>notFull.signal();</code>，通知生产者继续生产。</li><li>在put数据进入队列的时候，如果判断队列中的数据达到最大值，那么会调用<code>notFull.await();</code>，等待消费者消费掉，也就是等待3去取数据并且发出<code>notFull.signal();</code>，这时候生产者才能继续生产。</li></ol></blockquote><p><code>LinkBlockingQueue</code> 是典型的生产者消费者模式，源码细节就不多说。</p><h4 id="4-3-原子操作类：AtomicInteger"><a href="#4-3-原子操作类：AtomicInteger" class="headerlink" title="4.3  原子操作类：AtomicInteger"></a>4.3  原子操作类：AtomicInteger</h4><p>内部采用CAS（compare and swap）保证原子性</p><p>举一个int自增的例子</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        AtomicInteger <span class="attr">atomicInteger</span> = new AtomicInteger(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">        atomicInteger.incrementAndGet()<span class="comment">;//自增</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>源码看一下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>U 是 Unsafe，看下 <code>Unsafe#getAndAddInt</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过<code>compareAndSwapInt</code>保证原子性。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>面试中问到多线程并发问题，可以这么答：</p><blockquote><ol><li>当只有一个线程写，其它线程都是读的时候，可以用<code>volatile</code>修饰变量</li><li>当多个线程写，那么一般情况下并发不严重的话可以用<code>Synchronized</code>，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。</li><li><code>ReentranLock</code> 可以通过代码释放锁，可以设置锁超时。</li><li>高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如<code>ConcurrentHashMap</code>，<code>LinkBlockingQueue</code>，以及原子性的数据结构如：<code>AtomicInteger</code>。</li></ol></blockquote><p>面试的时候按照上面总结的这个思路回答基本就ok了。既然说到并发包，那么除了<code>ConcurrentHashMap</code>，其它一些常用的数据结构的原理也需要去了解下，例如<code>HashMap、HashTable、TreeMap</code>原理，<code>ArrayList、LinkedList</code>对比，这些都是老生常谈的，自己去看源码或者一些博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章将总结多线程并发的各种处理方式，希望对大家有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;一、多线程为什么会有并发问题&quot;&gt;&lt;a href=&quot;#一、多线程为什么会有并发问题&quot; class=&quot;headerlink&quot; title=&quot;一、多线程为什么会有并发问题&quot;&gt;&lt;/a&gt;一、多线程为</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="并发" scheme="http://ai.mak.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里毕玄：系统架构师如何做好系统设计？</title>
    <link href="http://ai.mak.cn/2019/08/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ai.mak.cn/2019/08/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2022-11-24T05:09:27.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里毕玄：系统架构师如何做好系统设计？"><a href="#阿里毕玄：系统架构师如何做好系统设计？" class="headerlink" title="阿里毕玄：系统架构师如何做好系统设计？"></a>阿里毕玄：系统架构师如何做好系统设计？</h1><blockquote><p>本文转自毕玄老师个人公众号：<strong>hellojavacases</strong></p></blockquote><p>系统设计我一直觉得是远比Java编程技能更难多了的培训，很容易变成务虚课，全是一堆理论，所以，以前从来不敢尝试做这方面的培训，今年由于一些情况，决定大胆尝试下，就在内部搞了个民间的培训，还真有不少同学捧场。在开始上这门课后，我觉得收获最大的搞不好是我自己，整理思路，从和学员的互动中学习到了很多，能更好地对系统设计的一些方法论进行抽象总结，所以我对这些捧场的学员们说：其实是我们一起在共创系统设计的课程 </p><p>我给系统设计培训定的目标是：</p><ol><li>通过这堂课掌握一个思考框架，知道做系统设计的套路，系统设计不是简单的上来就画画框什么，必须按照一定的套路才能更好的进行系统设计；</li><li>拓宽知识面，系统设计中非常重要的是考虑的全面性，以更好的进行权衡取舍，所以能不能借助系统设计培训来拓宽知识面非常重要。</li></ol><p>而要达到这样的效果，怎么去上这堂课挑战其实是不小的：想要传达的思考框架到底是什么？怎么样变成不是纯粹的理论，务虚的传达，从而让大家能更好的掌握并真正的去运用这个思考框架？以前真的没仔细的思考过系统设计的思考框架的问题，其实吧很多的系统设计的模板就是一个思考框架，但在不理解的情况下，是很难应用好的。</p><p><strong>系统设计的套路</strong></p><p>回顾了下自己做过的几个系统的设计，发现现在自己在做系统设计的时候确实是会按照一个套路去做，这个套路就是：</p><p><strong>系统设计的目的-&gt;系统设计的目标-&gt;围绕目标的核心设计-&gt;围绕核心设计形成的设计原则-&gt;各子系统，模块的详细设计。</strong></p><p><strong>1) 系统设计的目的</strong>  </p><p>是指做这个系统设计的目的到底是什么，很多人在做系统设计时，是搞不清为什么要做一个新系统的设计，或者为什么要做一个系统的重构&#x2F;演进的设计，如果搞不清楚这个目的，后面的系统设计上是很容易形成偏差的，导致本来是为了解决一个问题，要去做新的系统或重构&#x2F;升级旧的系统，但最后完全脱离了初心。</p><p>另外，还有很重要的一点是，一个大架构师是需要给很多人讲解系统设计的，只有理解并讲清了系统设计的目的，团队才能更好的去实现。</p><p><strong>2) 系统设计的目标</strong>  </p><p>围绕上面的目的，能不能形成一些可衡量的目标，从而确保最终系统实现和最初的目的不要出现太大的偏差，相信很多人都经历过最终的系统实现和系统设计偏差极大的现象，主要的原因基本都是没有制定衡量系统设计的目标，并在系统设计上让系统能透出这些目标的情况。</p><p><strong>3) 围绕目标的核心设计</strong> </p><p>这步最重要的就是通过设计如何去实现上面的目标，这个环节中技术的专业、视野、全面的考虑、权衡取舍的主观原则、解题的思路，这是形成最后的核心设计的关键。</p><p>在核心设计的这个阶段中，会产生一些新的衡量设计最后实现情况的目标，这些也都要增加到系统设计中，确保最后的实现和设计的偏差度是可视的。</p><p><strong>4) 围绕核心设计形成的设计原则</strong> </p><p>有了上面的核心设计后，可以真正的形成一些设计原则，确保后面的子系统&#x2F;模块的详细设计中能够遵循，并在详细设计中体现出来，这样才能让整个大的系统设计的一致性。</p><p><strong>5) 各子系统&#x2F;模块的详细设计</strong> </p><p>这个部分我倒觉得难度不会太大，毕竟有了前面的铺垫，就是解好一个更小范围的题，程序员群体在解题能力上通常是不错的，所以我一直觉得数学功底好是程序员的基本，数学就是典型的解题的学科。</p><p>ps: 这就是做分享&#x2F;培训的好处，借机仔细整理自己的碎片，从而形成体系。</p><p>关于怎么更好的让大家能掌握并运用这个思考框架，我的想法就是在讲每个步骤的时候讲讲自己当年在这些步骤上犯的错，实际的经验，这样我觉得也许大家以后在做系统设计时就能想起，所以我觉得系统设计这种培训绝对是需要具备大量实际经验的架构师才能做。</p><p>在运用部分，采取的方法就是通过互动，让大家按照同样的思考框架来讲自己的所负责的系统，通过互动来更好的彼此对齐，并借此逐渐变成习惯。</p><p><strong>系统设计之系统建设的目的</strong></p><p>作为系统设计的第一步，重要性毋庸置疑，如果连系统建设的目的都没搞清楚，后面所有的步骤都会错误。如果我们去看很多的系统设计，会发现压根就没有系统建设的目的的仔细分析。</p><p>当需要做系统设计时，就意味着需要建设一套新系统，或者对原有的系统进行比较大的架构的改造升级，这一定是基于什么原因才要去做的。之所以要分析好系统建设的目的，<strong>一方面是为了避免出发点有问题，系统建设的目的应该是充分反映出解决业务层面临的挑战</strong>，或者系统用户层面面临的问题的，而不是出于个人诉求，<strong>另一方面是为了确保在后续的系统设计中能保证目的的达成。</strong></p><p>从对系统建设的目的的分析中，是很容易看出格局和高度的，这两个词看起来非常虚，但其实很实，格局和高度通常是指所做的事影响的范围大小，例如从所在的一个小团队，到所在的大部门，到所在的大BU，到所在的大BG，到跨多BG的业务板块，到整个集团，甚至是到这个社会，这里一定要实事求是，别这里讲的是世界形势，后面的整个系统设计又完全解决不了这里所说的。</p><p>结合我自己的经历来说，在早期做HSF时，在系统建设的目的这点上是最为缺失的，也导致了自己在HSF阶段犯下了几次大的错误，例如最典型的就是HSF做动态化的那次系统架构改造，如果仔细的去分析当时做这件事的目的，就会看到这个是出于技术情怀，而不是业务端面临的业务挑战，或者说HSF的用户面临的问题，也就是之前说的出发点的问题，我觉得这是很多技术人员非常容易犯的错误，就是纯粹是出于技术诉求发动的很大动作的系统重构，我自己是在有一年有一位阿里的高管在给我做辅导时，提到首先要思考清楚为什么做某件事，并且能讲清楚原因，才明白了动机真的是非常重要的，后面做事的时候才能没那么技术化了。</p><p>因为HSF&#x2F;Ali HBase的经历，到了后面做阿里容器&#x2F;调度、异地多活的时候在目的这块才算是能更好的把握，能更好的去结合阿里的业务所面临的挑战来看要做的事。</p><p>大多数时候，驱动系统设计这件事的发生是其他方提出的，作为架构师，做好需求的转换，决定是否要建设新系统，或重构升级老系统，深刻地去理解系统建设的目的也非常重要，因为架构师是最终要给整个技术团队讲为什么要做的，这能够更好地让团队明白做这件事的价值和意义。</p><p><strong>总得来说，我认为做系统设计前，一定要先对于系统建设的目的分析清楚，确保系统建设有价值和有意义，同时确保后面的整个系统设计是能让目的达成的。</strong></p><h2 id="系统建设的目标"><a href="#系统建设的目标" class="headerlink" title="系统建设的目标"></a><strong>系统建设的目标</strong></h2><p>在分析清楚了系统建设的目的后，到了目标这个环节，最重要的是要把前面的目的的描述，<strong>转换为可衡量的目标的描述</strong>，之所以要形成可衡量的目标，最重要的原因是为了确保最后实现的系统是达成了系统建设的目的的，相信很多人都碰到过设计出来的系统和最后落地的系统很不一致的现象，通常这都是缺乏了可衡量的目标造成的。</p><p>举两个例子说下：</p><p>第一个是2011年做容器化，建设这套系统的目的是为了应对预计会越来越大的机器成本，目标相应的制定为支撑相同的业务量，机器下降一半。</p><p>第二个是2013年做异地多活，建设这套系统的目的是为了能够让业务具备更强的抵御灾害的能力，尽管后面发现因为有了异地多活，有了更多的好处，但那些确实在系统设计之初是完全没放在建设目的里的，后面能做到纯属巧合，例如因为有了异地多活使得后面的弹性借助云资源成为了现实，因为有了异地多活，基础设施技术的演进可以更加快速，在设计之初根据目的相应制定的目标为业务能够部署在中国多个地点（地点间距离&gt;1千公里），多个地点部署的业务都处于承接流量的状态，且流量从A点切换到B点能在30s内完成。</p><p>有了清晰的可衡量的系统建设的目标，意味着：</p><ol><li>确保了系统设计过程中可以非常针对性的围绕目标来做，避免偏题；</li><li>更重要也是最容易遗漏的一点，是可以做一个用来跟踪系统建设效果的系统，例如之前做容器化，我们会有一个展示，是容器化后的集群多少机器支撑了多少的业务量，和目前还未容器化的集群的一个对比；异地多活，会有一个管控系统，用来展示系统的部署情况，以及流量切换。只有有了跟踪系统建设目标是否达标的系统，才能真正确保系统建设完毕后和初心保持了一致，否则很多系统建设的时候是一个目的，最后做完了是另外的状况，所以这个跟踪效果的体系是一定要在系统建设的时候同步就做好的。</li></ol><p>从目的-&gt;目标这个部分，理论上并不复杂，但也很容易漏掉，导致后面的系统设计环节出问题，关键是要形成可衡量的目标，以及相应的跟踪目标达成情况的系统。</p><p><strong>达成目标的核心问题</strong> </p><p>如果要达成系统设计的可衡量的目标，到底面临了一些什么核心问题，只有明白了面临什么核心问题，才能更加明确的进行系统设计来解决这些问题。</p><p>还是用我自己的经历来讲这个话题。</p><p>最开始做HSF的时候，为什么要做HSF是比较清晰的，在可衡量的目标上也有一个大概的要支持每条上亿的服务调用，但由于当时的技术功底问题，导致了在提炼核心问题上是有很大差距的，这些也造成了后来HSF总是不断的重构、修修补补之类。所以，我从来就不认为技术功底不好的人能做好一个架构师，架构师绝对不是看到的随手画几个框那么简单，那通常只是个结果，但要合理的把框画出来是需要基于非常坚实的技术功底，HSF在最初设计时认为的核心问题就是怎么实现一个易用有服务定义的RPC框架，但对于如何支撑好上亿的交互调用量，服务化上线后给业务研发会带来什么问题（例如排查问题变复杂了），在核心问题上是有很大的缺失的，例如HSF上线后才发现的中间的负载均衡的问题，而这个问题是导致了HSF结构重新设计的，这个后来回头看就会发现如果是一个知识面更广的架构师可能一开始就会想到这个核心问题，所以如果回过头去看，HSF这样的框架，要达成目标，要解决的核心问题应该是：</p><ol><li>易用、能支撑上亿次服务交互的RPC框架；</li><li>服务间的软件负载均衡问题；</li><li>服务交互的问题排查；</li></ol><p>在做T4（容器）的时候，目的、目标都还比较清晰，问题的提炼现在回顾也做的还ok，T4要解的核心问题为如何实现在一台机器上跑20个应用，T4出现的问题更多是对于核心问题的设计方案上，这个到下篇讲围绕核心问题的系统设计上再写。</p><p>到了做异地多活的时候，目的、目标的清晰化都ok，对于异地多活而言，要做到在中国多个城市都可同时支撑流量，并且可在几十秒内完成流量切换，异地多活中物理距离所带来的网络延时是不可突破的，怎么做到多地活且流量可动态切换，要做到这个，面临的核心问题是：</p><ol><li>如何将流量进行切分，且让请求的整个处理过程能封闭在local完成；</li><li>如何保障异地多活后的数据一致性？</li></ol><p>到了最近几年做统一调度的时候，整个做系统设计的思考框架我觉得算是比较熟练了，所以统一调度的目的、目标都很清晰，结合当时的情况，要实现统一调度的目标，其面临的核心问题是：</p><ol><li>如何实现一套在线业务资源的调度系统去满足各种资源诉求？</li><li>如何尽可能扩大统一的资源池，解决资源池统一面临的资源竞争、资源被抢、多种不同资源规格等问题？</li><li>如何实现在线业务、离线任务两套调度系统的互通？</li><li>如何解决在线业务、离线任务混合部署时的资源竞争的问题？</li></ol><p>从上面的这些cases来看，可以看到，从可衡量的目标映射到技术层面要去解决的核心问题，是很需要技术功底的，对于工程类型的项目、产品而言，工程经验在这个时候也会特别重要，而通常我也觉得这是衡量一个优秀架构师很直接的地方。</p><p><strong>解决核心问题的设计</strong></p><p>继前面的系统建设的目的、可衡量的目标，达成目标的核心问题后，进入到解决核心问题的设计环节了，技术人员其实最擅长的是直奔这个主题，而且估计更期盼的也是这篇，有些时候会导致跳过前面的目的、目标环节，导致最终做出来的系统要么没贴合业务挑战，要么嘛偏离了做这个系统的初衷，所以我仍然强烈建议做系统设计的同学不要着急，一步一步来。</p><p>继续结合自己的cases来讲讲解决核心问题的设计这个环节，回顾自己的cases，犯了不少的错误，也碰到了非常多复杂的权衡选择的状况，才逐渐更加明白一个架构师应该具备的一些能力。</p><p><strong>HSF的设计</strong></p><p>HSF在设计之初要解决的第一个核心问题就是做一个易用，能支撑每天上亿次服务调用的服务方式的RPC框架。</p><p>易用这点在第一个版本犯了错，不过还好是第一个版本，否则纠正错误的代价会无比巨大，那个版本里，如果要把一个spring的bean发布为HSF服务，或者调用一个HSF服务，需要写一个文件，在文件里描述发布的服务和调用的服务，并且在这个文件放在jboss的某个目录里，这个方式看起来对在写代码的过程中完全没有侵入，但导致的巨大问题是这文件放在哪里写，写完后部署的阶段怎么自动放到对应的目录去，在第二个版本里才把这个调整为用一个Spring Bean的方式来做服务的发布和调用，尽管这一定程度导致了业务代码需要有对HSF的明显的依赖，但对维护、部署等都变的很标准，所以从这里可以看到，设计是全方位的，要考虑到的不仅仅是怎么实现，还有别人怎么用，运行、维护阶段又是怎么样的。</p><p>HSF犯的第二个错，就是在能支撑每天上亿次服务调用的RPC框架这点上，是给我自己代码生涯最大的教训，甚至彻底改变了我之后做设计时的技术选型风格。在做HSF之前，我从来没做过一天访问量超过100w的系统，完全搞不清一个每天上亿次的系统到底有什么不同，HSF最早的版本在通讯框架上选择了JBoss-Remoting，原因也其实比较简单，因为我们用的Web容器是JBoss，结果这个版本在一个非常重要的系统上线时，出现了严重的故障，导致了整个网站的响应速度都变的很慢。当时查了几乎整整一天都没查出原因到底是什么，后来回滚恢复，所以可以肯定是HSF上线造成的，等到回滚后的一个星期内才查出原因，是因为JBoss-Remoting在调用远端时，默认的超时时间为60s，而我们后端的那个系统在处理某些服务的时候会特别慢，进而导致了共用的处理线程池满了，所以整个网站的表现就变慢了。</p><p>这次问题让我彻底明白了访问量大的系统最重要的是对整个系统的处理过程要非常的清楚，因为在访问量大的情况下，一些小的问题有可能会放大成很大的问题，进而到故障，所以访问量大的系统对技术的可控性要求是极高的，这也是最大的不同，可控性并不代表一定要完全自己写，但要求如果用到开源的东西，要对开源的东西的代码逻辑非常熟悉，为了解决上面的问题，HSF基于Mina写了一个自己版本的通讯框架，自己来处理连接方式、线程池等，后面在做各种HSF改造，以及其他技术改造时，基本都遵循了技术可控性这个原则。</p><p>在前面核心问题那篇里也讲到，HSF在设计时其实核心问题提炼的就是有问题的，导致了后面在负载均衡、服务化后问题排查这两点上出现了严重的返工现象，而这些本其实都可以避免，就像现在再去做服务化框架的人基本都不会犯这样的错了。</p><p>在负载均衡这点上，在早期版本里，是通过硬件负载均衡设备来做的，这里造成了好几个问题，一是需要先配置要调用的服务的vip地址，当然，这可以通过一个中央的配置服务器之类的方式，第二个是HSF采用的是长连接的方式，通过vip去连接后端的一个集群时，这里会出现非常麻烦的问题，例如后端集群发布重启，很有可能就会造成连接的极度不均衡，进而导致故障。</p><p>除了上面两个问题后，还有一个触发HSF去做改造的原因是当时的硬件负载设备出现了流量跑满的现象，而这是必须要经过的一个点，会造成全站全部崩溃，不希望在未来系统中有个这么大的高风险的集中点，再加上上面的两个问题，决定做彻底的改造，于是HSF开始设计了目前看起来在服务框架体系中非常经典的软件方式的服务注册、发现和寻址的结构。</p><p>在负载均衡这件事上，现在回顾也可以看出这个仍然是当初对一个访问量巨大的系统考虑不够全面造成的。</p><p>在服务化后会带来的排查问题这点上，当初设计的时候更是完全没有考虑到，导致了后面排查问题效率低、人力投入大等等问题，后来为了解决这个问题，学习了Google家Dapper的思想，但花了很长时间这东西才真正落地。</p><p>除了上面这些外，HSF其实还有各种设计问题，例如最早的通讯协议里竟然是没有版本号的，导致后面升级时处理兼容的复杂，又例如更麻烦的一个话题就是在多语言支持上。</p><p>HSF作为我第一个真正做的访问量巨大且核心的系统的设计，由于当初的技术功底，犯下了无数错误，导致了N次返工、故障和弥补，当然也让自己得到了很大的成长，这几年回过头想这个问题，越来越觉得必须无比感谢我当时的主管对我巨大的包容和支持，HSF的经历，让我在解决核心问题的设计这个环节上，明白的是作为一个架构师，在技术选型上深厚的技术功底，在整个设计方案上知识的广度，考虑的全面性（从开发态、部署态、运行态和运维态）都是要求极高的。</p><p><strong>T4的设计</strong></p><p>T4在核心问题的提炼上没有太大的问题，但在怎么解这个问题的设计上那犯下的错误现在来看都是低级到不行。</p><p>为了做到在一台机器上能比以前用虚拟机的方式运行更多的应用进程，最早我们采用的方法是各种hack，其实要实现的就是进程级隔离，结果就是hack到了一定程度后，确实勉强能用了，但上线了一些小范围，有了一些用户后，发现我们的hack是很难枚举的，非常痛苦，直到有一天“发现”了LXC，才走对了路线。</p><p>除了上面这个选型层面的问题外，T4的过程中还碰到过很多类似的问题，例如用什么方法去控制磁盘空间的限制，最早我们也是用的同样的image的方式，但image的方式对磁盘空间超卖其实是非常不友好的，后来为了把这个方案更换成dir quota的方案，一帮人几乎是连续折腾了一个多月，因为线上已经在运行的要通过cp文件等方法来弄。</p><p>HSF的那段看到的很多是在技术深度上的问题，而T4的这段设计，现在回顾最主要的问题是这个技术领域视野的严重问题，所以我认为作为架构师，在相应的技术领域要有足够的视野，一定要知道这个领域的工程界、学术界是什么情况，这样对自己在结合目的、目标以及一些约束条件下做出更合理的技术选型是非常重要的，之前也写过一篇关于<a href="http://mp.weixin.qq.com/s?__biz=MjM5MzYzMzkyMQ==&mid=2649826508&idx=1&sn=cb736765f77d6b13846d63b7ff0310f6&chksm=be91872289e60e34a28abd1588a8eec9289d26024d313621646cd1f0b99409890701b2d0cfa9&scene=21#wechat_redirect">如何扩充技术视野</a>的文章。</p><p><strong>异地多活的设计</strong></p><p>到了做异地多活这个阶段，也许是因为有了前面的一些积累，总结反思，我自己觉得异地多活的设计更多的是选择，至于对错我总体认为还好，所以这里我就讲一些异地多活设计上为了解决核心问题所面临的一些权衡选择，而这也是架构师在做设计上非常重要的一个部分，如何去根据各种约束来做一些方案的权衡选择。</p><p>异地多活在核心问题上要解决的是请求封闭、数据一致性这两个关键问题，在为了解决这两个问题的设计上，参考了工程界的一些情况，最后发现我们所面临的状况还是很不一样。</p><p>在这里就抛出一些异地多活设计上所面临的选择，我就不去讲我的选择逻辑之类的了，方便大家思考，以及交流探讨。</p><ol><li>流量&#x2F;数据拆分的规则到底按什么好？买家&#x2F;卖家&#x2F;商品？</li><li>分流的规则和数据库分库分表的规则的关系：松耦合 Vs 强绑定？</li><li>数据同步策略的选择：部分 Vs 全量？</li><li>数据一致性的保障，在哪些层面做，CAP？</li><li>部署的选择：两地 Vs 三地，地域的分布选择？</li><li>落地节奏，一年？两年？三年？</li></ol><p><strong>架构师应具备的能力总结</strong></p><p>最后根据目的、可衡量的目标、核心问题提炼、解决核心问题的设计这些环节，总结提炼下我觉得架构师需要具备的能力：</p><ol><li>对业务所面临的挑战的理解，从业务挑战到技术挑战映射的能力，或者说技术抽象的能力；</li><li>知识储备以及考虑的全面性，从开发、部署、运行、维护态；</li><li>技术选型能力，极厚的技术功底，开阔的技术视野；</li><li>在各种约束条件下权衡选择的能力，原则。</li></ol><p>所以架构师我觉得绝对不是烂大街的头衔，要做到一个合格的架构师还是相当难的，尤其是工程类型的架构师，需要长期的实战、经验积累。</p><p>系统设计一直是我认为最难讲的内容，主要还是因为我在内部尝试做的一个系统设计的培训，非常感谢一帮同学支持了我做这个培训，要不是他们的参与，我觉得不可能写这篇文章，也不可能较为体系化的说说系统设计，并且更重要的是让我觉得系统设计这个东西其实还是可以不讲的那么虚的，以及系统设计的技能一定程度上确实也是可以培养的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阿里毕玄：系统架构师如何做好系统设计？&quot;&gt;&lt;a href=&quot;#阿里毕玄：系统架构师如何做好系统设计？&quot; class=&quot;headerlink&quot; title=&quot;阿里毕玄：系统架构师如何做好系统设计？&quot;&gt;&lt;/a&gt;阿里毕玄：系统架构师如何做好系统设计？&lt;/h1&gt;&lt;bloc</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
