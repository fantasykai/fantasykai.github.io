<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>新人如何快速上手项目管理</title>
    <link href="http://ai.mak.cn/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://ai.mak.cn/2020/05/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2023-01-10T04:28:18.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>互联网公司除了业务迭代快，大型战役活动也不少，比如阿里巴巴的双11、阿里影业的春节档、优酷的世界杯等等。这些大型战役，不仅考验技术人的代码功底，更考验在超大型项目中团队协作能力、快速应变能力。</p><p>本文将从PMO的专业能力+技术人的实践视角，详解大型项目及战役的运作流程，将复杂项目做模块化拆解，教你站在项目全局看技术实践，同时例举团队高效沟通的技巧，希望为当下SOHO的互联网人带来启发。</p><h1 id="二、做好大型项目的五个关键"><a href="#二、做好大型项目的五个关键" class="headerlink" title="二、做好大型项目的五个关键"></a>二、做好大型项目的五个关键</h1><p>几百人、上千人组成的大型项目&#x2F;战役有很多挑战，乍一看让人望而却步，但仔细梳理下来好像也没有那么复杂，只需要厘清以下的关键：</p><p>拿什么结果 -&gt; 项目的目标<br>谁是我战友 -&gt; 项目的成员<br>啥时候吹号 -&gt; 项目的计划<br>怎么来协同 -&gt; 项目的机制<br>战后做点啥 -&gt; 复盘和沉淀</p><p>思路就是: 明确事-&gt;找对人-&gt;排计划-&gt;定机制-&gt;收好尾。不过，从项目特质上来说，信息是渐明渐细的，梳理和澄清是一件持续的工作。</p><h1 id="三、问题厘清"><a href="#三、问题厘清" class="headerlink" title="三、问题厘清"></a>三、问题厘清</h1><p>有了整体的思路,心里也就有了底气，但也不能眉毛胡子一把抓。不同的阶段重点不同，按照常见的项目阶段来看，可以分为启动期、规划期、执行期、监控期及收尾期。每个阶段需要明确关键目标，锁定核心问题。</p><p>启动期：明确方向，确认人员，厘清目标，明确机制，制定里程碑计划；</p><p>规划期：明确目标、确认方案，制定执行计划；</p><p>执行期：紧盯目标、管控计划、保障落地；</p><p>监控期：基于目标、运用机制、核查计划、发掘风险，制定预案，管控变更。理论上从规划期到收尾期都属于监控期，但项目的差异，着力点和力度有不同。常见的互联网项目，执行期监控力度最大，所以一些流程上把执行和监控揉和在一起了；</p><p>收尾期；有序收尾、深度复盘、有效沉淀。</p><p>这里已经明确了各节点的重点，那如何抓住这些节点值得探讨。作为项目PM或团队管理者，需要把控三点：</p><p>驱动管理节点，紧盯目标，这个目标是宏观的目标，包括业务目标、进度目标、人员的目标；</p><p>保障沟通通道，保障信息的上传下达，步调一致，协同各团队有效参与；</p><p>运用管理机制，包括目标负责制、沟通机制、需求管理机制等；</p><h1 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h1><p><strong>1. 驱动管理节点</strong></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/5e6769dc9f0d4c1fbfb3a546f83e85cc.jpg" alt="1.jpg"></p><p>管理节点一方面要拉齐信息，另一方面要发掘风险和问题，及时做出应对。关键点上核心信息的确认和决策以及同步，当面的会议沟通是非常有效的手段，但保障会议有效是其中的关键。</p><p>会议前；做好议题收集和准备，特别是会议的前置输入材料和关键信息提前准备好；</p><p>会议中；聚焦议题和发言顺序，控制会议时间，保障会议有效；</p><p>会议后；要有结论输出并同步参会人及关联方；</p><p>SOHO模式下，IM、音视频及共享屏幕工具尤为重要，尽量选择团队日常使用、通用性好、使用复杂度低的工具并分享使用TIPS。整体会议安排上做好协同，避免过度的会议影响正常工作；</p><p>方向对焦会: 基于项目价值、核心1号位及关键同学，通过会议确认并输出：方向、初步策略、里程碑及运行机制；</p><p>方案review会: 会议前基于方向对焦会结论，已产出核心方案草案，且在该草案基础上拉通关联团队输出联动业务方案；</p><p>需求评审会：基于业务方案和平台能力明确当前业务需求，通过需求评审会确认各负责人及落地计划；</p><p>复盘会：基于目标、方案结合当前完成情况进行复盘，重点是可复用能力的沉淀和发现问题的后续跟进。</p><p><strong>2. 保障沟通通道</strong></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/4276572e67b64f81a7fba4d04b9c908a.jpg" alt="2.jpg"></p><p>日会：通过项目例会对焦核心信息，同时进行关键工作进度同步、成果验收和快速决策。根据项目所处的阶段和工作的颗粒度，可以调整会议的频率，但不适宜频繁调整节奏和会议室；</p><p>日报：围绕核心目标、策略、进展、风险等核心信息有效记录和同步，重要信息需和对接人确认并反馈；</p><p>文档库：提升信息管理效率，降低PM和关键人员沟通瓶颈；促使团队自主联动，有效同步和纪录核心信息，持续沉淀关键信息给后续复盘和项目做好沉淀。</p><p><strong>3. 建立和运用机制</strong></p><p>持续和聚焦目标、策略（方案）、进度（计划）促成高效执行；发掘和同步风险，准备预案消除和降低风险危害。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/2a6ccf8f5811439aa9b960dacafb0bb4.jpg" alt="3.jpg"></p><h1 id="五、关键点"><a href="#五、关键点" class="headerlink" title="五、关键点"></a>五、关键点</h1><p><strong>1. K.O.（启动会）</strong>:</p><p>目的：启动会能够让各个业务部门的人员清楚知道项目的概况，目标、策略、落地计划，懂得如何配合，确保后续各部门人员配合到位，沟通协调效率高，有利于推动整个项目的推进。</p><p>操作：</p><p>1）会前准备</p><p>明确参会人员：确定他们的时间，并据此确定会议地点。SOHO模式下，选择好协同工具，比如视频会议、视频直播，提前试用告知参会者准备参会设备；</p><p>划分讲话内容：为发言者圈定讲话范围和时限，让参会者要求准备发言内容；线上沟通，需要比现场沟通更精炼；</p><p>准备相关资料：包括宣传资料、现场摆设、座位分布、相关配套服务等等。</p><p>2）会议通知</p><p>召开项目启动会通常提前3天发布通知，紧急情况下适当调整，同时要提前与参会的核心人员进行沟通，让参会人员事先了解自己在项目中需要负责的工作和担任的角色。项目团队的所有成员都要参加项目启动会议，即使有人当时不在办公室，也尽可能通过电话参与会议。</p><p>3）会议议程</p><ol><li>由项目负责人介绍项目背景、目标、范围，奠定整个项目的基础；</li><li>由各业务负责人介绍产品方案；</li><li>由项目经理介绍项目管理机制，包括安全机制、奖惩机制、沟通机制（日会、周会、日报、周报等）、变更管理等；</li><li>由项目负责人为各团队负责人颁发委任状或立军令状，并全团队大合影，在SOHO模式下可以选择工作照拼图。</li></ol><p>4）会议原则</p><p>高层的领导尽量邀请到，这样各负责人可以提高重视度，更积极的组织个参与工作。启动会一定要按时开始、按时结束。这代表着项目管理的基调和规则，有利于形成守时、高效的项目管理风格。<br>启动会必须要正式，会议的议程和时间可以缩短，但是会议的规格和对参会人员的重视程度一定要达到标准，要让参会人员觉得会议很重要，老大讲话投屏、横幅、座位牌、水等尽量要有保证。</p><p>5）会议总结</p><p>项目启动会是一种关键信息对焦和拉通形式，所以，需要总结会议的重点内容和后续计划，并把会上领导关键讲话作为项目过程中的指导方针，把团队的合影、军令状、项目的K.O.文件等在会后一并发给大家，推进项目展开。</p><p><strong>2. 风险管理</strong></p><p>风险在各个项目里长期存在，识别、反馈及处理风险是持续工作。在项目里一方面要建立全员风险管理的意识，鼓励风险的及时识别和上报。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/c9b6988a9dcf4d569f36f7abe5854cb3.jpg" alt="4.jpg"></p><p><strong>3. 相关方管理</strong></p><p>项目经理需要识别项目相关方，分析其对项目的要求或需求，并且管理好这些要求和需求，满足不同的相关方，从而以确保项目的成功。识别和管理相关方是项目中持续要做的工作，且需要明确反对项目的人或组织同样属于相关方。</p><p>1）识别相关方:</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/688b0097ff8542dc91acd23969e18ea3.jpg" alt="5.jpg"></p><p>2）管理相关方：</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/5e4fa92eec09494c9488a1a65fde2424.jpg" alt="6.jpg"></p><p><strong>4. 复盘</strong></p><p>目的：基于目标、方案结合当前完成情况进行复盘，沉淀可服用能力，发掘系统缺陷和无效策略，在结束后修复完善漏洞并记录为下一个项目提供支撑和规避；</p><p>时机：</p><p>不同的项目复盘契机存在差异，但复盘的目标需要明确，一定要杜绝无效的复盘；</p><ol><li>时限型项目达到预定时间；例如：3月底完成APP DAU提升XX的目标；</li><li>目标型项目达到预定目标；例如：Q3完成APP客诉量下降一半的目标；</li><li>项目出现严重问题；</li></ol><p>操作：</p><p>1）复盘原则：</p><p>多目标以目标纬度复盘，确保链条完整性；<br>子项目复盘在组内进行，保障复盘有效性；<br>鼓励畅所欲言，警惕自我吹捧、禁止互相攻击。</p><p>2）会前准备:</p><p>明确需要参与人、时间、地点；划分讲话内容，为发言者圈定讲话范围和时限，让发言者要求准备<br>准备相关资料，包括前期方案及过程数据。</p><h1 id="六、结束语"><a href="#六、结束语" class="headerlink" title="六、结束语"></a>六、结束语</h1><p>以上是组织一个项目的简要流程。从阿里文娱PMO团队的经验出发，项目过程中会有很多复杂的问题出现，但发挥项目的团队能力，最终都能顺利解决。此外，还可以寻求专业的项目管理团队作为教练赋能，最终实现：</p><ol><li>目标可预测；</li><li>资源可调度；</li><li>变化可控制；</li><li>问题可见和追溯，使得战役有序打响并取得预期的胜利。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;互联网公司除了业务迭代快，大型战役活动也不少，比如阿里巴巴的双11、阿里影业的春节档、优酷的世界杯等等。这些大型战役，不仅考</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>Servicemesh和API Gateway关系深度探讨</title>
    <link href="http://ai.mak.cn/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/"/>
    <id>http://ai.mak.cn/2020/04/30/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Service%20Mesh%20%E5%92%8C%20API%20Gateway%20%E5%85%B3%E7%B3%BB%E6%B7%B1%E5%BA%A6%E6%8E%A2%E8%AE%A8/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2023-01-10T02:43:43.607Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://skyao.io/post/202004-servicemesh-and-api-gateway/">https://skyao.io/post/202004-servicemesh-and-api-gateway/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Service Mesh和API Gateway之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在Service Mesh和API Gateway融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。</p><blockquote><p>备注1：为了节约篇幅，我们将直奔主题，假定读者对Servicemesh和API Gateway已有基本的了解。</p><p>备注2: 这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。</p></blockquote><h2 id="原本清晰的界限：定位和职责"><a href="#原本清晰的界限：定位和职责" class="headerlink" title="原本清晰的界限：定位和职责"></a>原本清晰的界限：定位和职责</h2><p>首先，Service Mesh和API Gateway在功能定位和承担的职责上有非常清晰的界限：</p><ul><li>Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯</li><li>API Gateway： 负责将服务以API的形式暴露（给系统外部），以实现业务功能</li></ul><p>如上图所示：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>从功能和职责上说：</p><ul><li>位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力</li><li>在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务</li><li>原子微服务和组合服务部署于 <strong>系统内部</strong>，在采用servicemesh的情况下，由servicemesh提供服务间通讯的能力</li><li>API Gateway用于将系统内部的这些服务暴露给 <strong>系统外部</strong>，以API的形式接受外部请求。</li></ul><p>从部署上说：</p><ul><li>Servicemesh部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统</li><li>API Gateway部署在系统的边缘：一方面暴露在系统之外，对外提供API供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。</li></ul><p>在这里引入两个使用非常广泛的术语：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_407b3c3a252215b00281feebff74034e.png" alt="img"></p><ul><li><strong>东西向</strong>通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部</li><li><strong>南北向</strong>通讯：指服务对外部提供访问，通常是通过API Gateway提供的API对外部保罗，其通讯流量是从系统外部进入系统内部。</li></ul><blockquote><p>解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左西右东”的原则。</p></blockquote><p>总结：Service Mesh和API Gateway在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现Service Mesh和API Gateway关系的讨论了，自然也不会有本文。</p><p>问题的根源在哪里？</p><blockquote><p>强烈推荐阅读：附录中 Christian Posta 的文章 “Do I Need an API Gateway if I Use a Service Mesh?“对此有深度分析和讲解。</p></blockquote><h2 id="哲学问题：网关访问内部服务，算东西向还是南北向？"><a href="#哲学问题：网关访问内部服务，算东西向还是南北向？" class="headerlink" title="哲学问题：网关访问内部服务，算东西向还是南北向？"></a>哲学问题：网关访问内部服务，算东西向还是南北向？</h2><p>如下图所示，图中黄色的线条表示的是API Gateway访问内部服务：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_66bd92965a747bfc1f65b1cdaf9c98c7.png" alt="img"></p><p>问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看 API Gateway 访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_3639b8345d877d10b889d082af357bb8.png" alt="img"></p><p>所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway ，是作为一个整体，还是逻辑上分拆为对内对外两个部分。</p><p>这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现 “API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：</p><ol><li>泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway访问内部服务的通讯机制自行实现，独立于服务间通讯的机制</li><li>兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。</li></ol><p>而最终决策通常也和产品的定位有关：如果希望维持 API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如springcloud生态下的zuul和springcloud gateway。</p><p>但无论选择哪个流派，都改变不了一个事实，当 “API Gateway 作为一个客户端访问内部服务” 时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证…… 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。</p><p>这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。</p><p>这里又是一个类似的哲学问题：当 “API Gateway 作为一个客户端访问内部服务” 时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？</p><p>答案不重要。</p><h2 id="Sidecar：真正的重合点"><a href="#Sidecar：真正的重合点" class="headerlink" title="Sidecar：真正的重合点"></a>Sidecar：真正的重合点</h2><p>在进入servicemesh时代之后，Servicemesh和API gateway 的关系开始是这样：</p><ol><li>功能和职责清晰划分</li><li>客户端访问服务的功能高度重叠</li></ol><p>此时两者的关系很清晰，而且由于当时Servicemesh和API Gateway是不同的产品，两者的重合点只是在功能上。</p><p>而随着时间的推移，当 Servicemesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。</p><p>在Servicemesh出现之后，如何为基于Servicemesh的服务选择合适的API Gateway方案，就慢慢开始提上日程，而其中选择重用Servicemesh的能力也自然成为一个探索的方向，并逐步出现新式API Gateway产品，其想法很直接：</p><p><strong>如何融合东西向和南北向的通讯方案？</strong></p><p>其中的一个做法就是基于Servicemesh的Sidecar来实现API Gateway，从而在南北向通讯中引入Servicemesh这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片(鸣谢赵化冰同学)来解释这个方案的思路：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_b3dce2008e0a698c0a2c0b94fa11cd72.png" alt="img"></p><p>这个时候servicemesh和API Gateway的关系就变得有意思了，因为servicemesh中sidecar的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：</p><ol><li>API Gateway本体：实现API Gateway除了访问内部服务之外的功能</li><li>Sidecar：按照servicemesh的标准做法， 我们视API Gateway为一个部署于servicemesh中的普通服务，为这个服务1:1的部署sidecar</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_7f2933075826470040bdc993f499a41f.png" alt="img"></p><p>在这个方案中，原来用于servicemesh的sidecar，被用在了API Gateway中，替代了API Gateway中原有的客户端访问的各种功能。这个方案让API Gateway的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway可以更专注于 “API Management” 的核心功能。</p><p>此时 servicemesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。</p><p>而采用这个方案的公司，通常都是先有servicemesh产品，再基于servicemesh产品规划（或者重新规划）API Gateway方案，典型如蚂蚁金服的SOFA Gateway产品是基于MOSN，而社区开源产品Ambassador和Gloo都是基于Envoy。</p><p>上述方案的优势在于API Gateway和Sidecar独立部署，职责明确，架构清晰。但是，和servicemesh使用sidecar被质疑多一跳会造成性能开销影响效率一样，API Gateway使用Sidecar也被同样的质疑：多了一跳……</p><p>解决“多一跳”问题的方法简单而粗暴，基于sidecar，将API Gateway的功能加进来。这样API Gateway本体和Sidecar再次合二为一：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_9c29254ffd88f10a2d87f5207d0cd98f.png" alt="img"></p><p>至于走到这一步之后，Servicemesh和API Gateway是什么关系：这到底算是Servicemesh&#x2F;sidecar融合了API Gateway，还是API Gateway融合了Servicemesh&#x2F;Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。</p><h2 id="BFF：把融合进行到底"><a href="#BFF：把融合进行到底" class="headerlink" title="BFF：把融合进行到底"></a>BFF：把融合进行到底</h2><p>BFF(Backend For Frontend)的引入会让Servicemesh和API Gateway走到一个更加亲密的地步。</p><p>先来看看常规的BFF的玩法：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_e140284a158e9b4b6564033a00470096.png" alt="img"></p><p>在这里，多增加了一个 BFF 层，介于API Gateway和内部服务（包括组合服务和原子微服务）之间。注意BFF的工作模式和组合服务很类似，都是组合多个服务。但差别在于：</p><ol><li>组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务</li><li>BFF不同，BFF如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问</li><li>对我们今天的话题而言，最关键的一点：BFF完全收口了从外部进入的流量，而组合服务没有，API Gateway是可以直接访问原子微服务的</li></ol><p>“BFF完全收口外部流量”，这一点在API Gateway和Sidecar融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有BFF的情况下，API Gateway和Sidecar融合后的情景：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_651c59dccf7914428f283feed4dbd00c.png" alt="img"></p><p>放大一点，单独看API Gateway和BFF：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_f9c39a8b510c458355adaf5a268ca4e7.png" alt="img"></p><p>注意到，流量从被API Gateway接收，到进入BFF在这个流程中，这个请求路径中有两个sidecar：</p><ol><li>和BFF部署在一起的，是没有API Gateway功能的普通Sidecar</li><li>API Gateway和Sidecar融合之后，这就是一个“有API Gateway功能的大Sidecar”（或者是“有Sidecar功能的特殊API Gateway”）：虽然扮演了API Gateway的角色，但本质上依然包含一个完整功能的sidecar，和BFF自带的Sidecar是等同的</li></ol><p>所以，问题来了：为什么要放两个sidecar在流程中，缩减到一个会怎么样？我们尝试将两个Sidecar合二为一，去掉BFF自带的Sidecar，直接把扮演API Gateway的sidecar给BFF用：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_a41f2181acde4f58b132873302a99e57.png" alt="img"></p><p>此时的场景是这样：</p><ol><li>流量直接打到BFF上（BFF前面可能会挂其他的网络组件提供负载均衡等功能）</li><li>BFF的sidecar接收流量，完成API Gateway的功能，然后将流量转给BFF</li><li>BFF通过sidecar调用内部服务（和没有合并时一致）</li></ol><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_65454a16542646a5a9751b76bd5d8927.png" alt="img"></p><p>注意这里有一个关键点，在前面时特意注明的：“<strong>BFF完全收口外部流量</strong>”。这是前提条件，因为原有的API Gateway集群已经不再存在，如果BFF没能收口全部流量，则这些未能收口的流量会找不到API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带API Gateway功能的Sidecar，也是可行的，只是管理上会比BFF模式要复杂一些。</p><p>另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的API Gateway的集群，常规的中心化的网关在这个方案中被融合到每一个BFF的实例中，从而实现另外一个重要特性：去中心化。</p><p>上述Servicemesh 和 API Gateway融合的方案，并未停留在纸面上。</p><p>在蚂蚁金服内部，我们基于Servicemesh 和 API Gateway融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化&#x2F;Sidecar化，最终演变成了这样一个方案：</p><p><img src="https://skyao.io/post/202004-servicemesh-and-api-gateway/images/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_0d19f1a6e1e5aee915cd771adc2553b2.png" alt="img"></p><blockquote><p>强烈推荐阅读：附录中我的同事 贾岛 的文章 “蚂蚁金服 API Gateway Mesh 思考与实践” 对此有深入介绍和详细描述。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了 Servicemesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是API Gateway和Sidecar 合二为一。</p><p>后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。</p><p>补充介绍一下文中多次提到的“MOSN”：</p><p>MOSN 是 MOSN 是 Modular Open Smart Network 的简称， 是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。 MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。 MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。</p><ul><li>GitHub：<a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a></li><li>官网：<a href="https://mosn.io/">https://mosn.io</a></li></ul><h2 id="附录：参考资料和推荐阅读"><a href="#附录：参考资料和推荐阅读" class="headerlink" title="附录：参考资料和推荐阅读"></a>附录：参考资料和推荐阅读</h2><p>意犹未尽的同学，欢迎继续阅读以下内容。</p><p>按文章发表的时间排序：</p><ul><li><a href="https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/">The Difference Between API Gateways and Service Mesh</a>： 2020-02，指导架构师确定何时使用API网关以及何时使用服务网格，作者Marco Palladino，来自kong。</li><li><a href="https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">Do I Need an API Gateway if I Use a Service Mesh?</a>：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 <a href="https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">使用了 Service Mesh 后我还需要 API 网关吗</a>，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。</li><li><a href="https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN">蚂蚁金服 API Gateway Mesh 思考与实践</a>: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和API Gateway Mesh的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在Servicemesh和API Gateway融合方面的实践。</li><li><a href="https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/">API Gateway的身份认同危机</a>: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述API Gateway的基本理念如API的定义，API Management的含义，API Gateway模式，以及服务网格和API Gateway的关系。</li><li><a href="https://skyao.io/talk/201810-ant-finance-service-mesh-practice/">长路漫漫踏歌而行：蚂蚁金服Service Mesh实践探索</a>: 2018-10，我在QCon的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于Sidecar的SOFA Gateway产品刚开始开发。</li><li><a href="https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784">API Gateway vs Service Mesh</a>: 2018-09，作者Richard Li，Datawire的CEO ，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的API Gateway开源产品，文章阐述了对服务网格和API Gateway的看法，差异，以及对两者集成的看法。</li><li><a href="https://skyao.io/post/201803-dreammesh-brainstorm-gateway/">DreamMesh抛砖引玉(9)-API Gateway</a>: 2018-03，这个文章也是我写的，2018年初我和servicemesh社区的一些朋友深入探讨之后，在DreamMesh系列博客文章中记录下了当时构想的方案，尤其对 API gateway和sidecar是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！</li><li><a href="https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56">Service Mesh vs API Gateway</a>: 2017-10，原文作者 <a href="https://medium.com/@kasunindrasiri">Kasun Indrasiri</a>，以及 <a href="https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/">赵化冰同学翻译的中文版本</a>，文章不长，主要对比了服务网格和API Gateway的产品功能，提出了两者融合的方式——在API Gateway中通过服务网格来调用下游服务。</li><li><a href="https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/">Application Network Functions With ESBs, API Management, and Now.. Service Mesh?</a>：2017-08，作者 Christian Posta，讲述服务网格与ESB，消息代理和API管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://skyao.io/post/202004-servicemesh-and-api-gateway/&quot;&gt;https://skyao.io/post/202004-servicemesh-and-api-gateway/&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>聊聊API网关的作用</title>
    <link href="http://ai.mak.cn/2020/03/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%81%8A%E8%81%8AAPI%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://ai.mak.cn/2020/03/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E8%81%8A%E8%81%8AAPI%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2023-01-10T00:39:34.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、API网关的用处</strong></p><p>API网关我的分析中会用到以下三种场景。 </p><ol><li>Open API。 企业需要将自身数据、能力等作为开发平台向外开放，通常会以rest的方式向外提供，最好的例子就是淘宝开放平台、腾讯公司的QQ开发平台、微信开放平台。 Open API开放平台必然涉及到客户应用的接入、API权限的管理、调用次数管理等，必然会有一个统一的入口进行管理，这正是API网关可以发挥作用的时候。</li><li>微服务网关。微服务的概念最早在2012年提出，在Martin Fowler的大力推广下，微服务在2014年后得到了大力发展。 在微服务架构中，有一个组件可以说是必不可少的，那就是微服务网关，微服务网关处理了负载均衡，缓存，路由，访问控制，服务代理，监控，日志等。API网关在微服务架构中正是以微服务网关的身份存在。 </li><li>API服务管理平台。上述的微服务架构对企业来说有可能实施上是困难的，企业有很多遗留系统，要全部抽取为微服务器改动太大，对企业来说成本太高。但是由于不同系统间存在大量的API服务互相调用，因此需要对系统间服务调用进行管理，清晰地看到各系统调用关系，对系统间调用进行监控等。 API网关可以解决这些问题，我们可以认为如果没有大规模的实施微服务架构，那么对企业来说微服务网关就是企业的API服务管理平台。</li></ol><p><strong>二、API网关在企业整体架构中的地位</strong></p><p>一个企业随着信息系统复杂度的提高，必然出现外部合作伙伴应用、企业自身的公网应用、企业内网应用等，在架构上应该将这三种应用区别开，三种应用的安排级别、访问方式也不一样。 因此在我的设计中将这三种应用分别用不同的网关进行API管理，分别是：API网关（OpenAPI合伙伙伴应用）、API网关（内部应用）、API网关（内部公网应用）。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e2277268a52f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>三、企业中在如何应用API网关</strong></p><p>1、对于OpenAPI使用的API网关来说，一般合作伙伴要以应用的形式接入到OpenAPI平台，合作伙伴需要到 OpenAPI平台申请应用。 因此在OpenAPI网关之外，需要有一个面向合作伙伴的使用的平台用于合作伙伴，这就要求OpenAPI网关需要提供API给这个用户平台进行访问。 如下架构:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22771fcfb2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>当然如果是在简单的场景下，可能并不需要提供一个面向合作伙伴的门户，只需要由公司的运营人员直接添加合作伙伴应用id&#x2F;密钥等，这种情况下也就不需要合作伙伴门户子系统。 </p><p>2、对于内网的API网关，在起到的作用上来说可以认为是微服务网关，也可以认为是内网的API服务治理平台。 当企业将所有的应用使用微服务的架构管理起来，那么API网关就起到了微服务网关的作用。 而当企业只是将系统与系统之间的调用使用rest api的方式进行访问时使用API网关对调用进行管理，那么API网关起到的就是API服务治理的作用。 架构参考如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22773d85f4b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>3、对于公司内部公网应用（如APP、公司的网站），如果管理上比较细致，在架构上是可能由独立的API网关来处理这部分内部公网应用，如果想比较简单的处理，也可以是使用面向合作伙伴的API网关。 如果使用独立的API网关，有以下的好处：</p><ul><li>面向合作伙伴和面向公司主体业务的优先级不一样，不同的API网关可以做到业务影响的隔离。</li><li>内部API使用的管理流程和面向合作伙伴的管理流程可能不一样。</li><li>内部的API在功能扩展等方面的需求一般会大于OpenAPI对于功能的要求。</li></ul><p>基于以上的分析，如果公司有能力，那么还是建议分开使用合作伙伴OPEN API网关和内部公网应用网关。</p><p><strong>四、API网关有哪些竞争方案</strong></p><p>1、对于Open API平台的API网关，我分析只能选择API网关作为解决方案，业界没有发现比较好的可以用来作为Open API平台的入口的其他方案。</p><p>2、对于作为微服务网关的API网关，业界的选择可以选择的解决方案比较多，也取决于微服务器的实现方案，有一些微服务架构的实现方案是不需要微服务网关的。</p><ul><li>Service Mesh，这是新兴的基于无API网关的架构，通过在客户端上的代理完成屏蔽网络层的访问，这样达到对应用层最小的改动，当前Service Mesh的产品还正在开发中，并没有非常成熟可直接应用的产品。 发展最迅速的产品是Istio。 建议大家密切关注相关产品的研发、业务使用进展。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22773e3b43d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><ul><li>基于duboo架构，在这个架构中通常是不需要网关的，是由客户端直接访问服务提供方，由注册中心向客户端返回服务方的地址。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717e22774198749~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>五、API网关解决方案</strong></p><p>私有云开源解决方案如下：</p><ul><li>Kong kong是基于Nginx+Lua进行二次开发的方案， <a href="https://konghq.com/">https://konghq.com/</a></li><li>Netflix Zuul，zuul是spring cloud的一个推荐组件，<a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a></li><li>orange,这个开源程序是国人开发的， <a href="http://orange.sumory.com/">http://orange.sumory.com/</a></li></ul><p>公有云解决方案：</p><ul><li>Amazon API Gateway，<a href="https://aws.amazon.com/cn/api-gateway/">https://aws.amazon.com/cn/api-gateway/</a></li><li>阿里云API网关，<a href="https://www.aliyun.com/product/apigateway/">https://www.aliyun.com/product/apigateway/</a></li><li>腾讯云API网关， <a href="https://cloud.tencent.com/product/apigateway">https://cloud.tencent.com/product/apigateway</a></li></ul><p>自开发解决方案：</p><ul><li>基于Nginx+Lua+ OpenResty的方案，可以看到Kong,orange都是基于这个方案</li><li>基于Netty、非阻塞IO模型。 通过网上搜索可以看到国内的宜人贷等一些公司是基于这种方案，是一种成熟的方案。</li><li>基于Node.js的方案。 这种方案是应用了Node.js天生的非阻塞的特性。</li><li>基于java Servlet的方案。 zuul基于的就是这种方案，这种方案的效率不高，这也是zuul总是被诟病的原因。</li></ul><p><strong>六、企业怎么选择API网关</strong></p><p>如果是要选择一款已有的API网关，那么需要从以下几个方面去考虑。 </p><p>1、性能与可用性</p><p>如果一旦采用了API网关，那么API网关就会作为企业应用核心，因此性能和可用性是必须要求的。</p><ul><li>从性能上来说，需要让网关增加的时间消耗越短越好，个人觉得需要10ms以下。 系统需要采用非阻塞的IO，如epoll，NIO等。网关和各种依赖的交互也需要是非阻塞的，这样才能保证整体系统的高可用性，如：Node.js的响应式编程和基于java体现的RxJava和Future。</li><li>网关必须支持集群部署，任务一台服务器的crash都应该不影响整体系统的可用性。</li><li>多套网关应该支持同一管理平台和同一监控中心。 如： 一个企业的OpenAPI网关和内部应用的多个系统群的不同的微服务网关可以在同一监控中心进行监控。</li></ul><p>2、可扩展性、可维护性</p><p>一款产品总有不能满足生产需求的地方，因此需求思考产品在如何进行二次开发和维护，是否方便公司团队接手维护产品。</p><p>3、需求匹配度</p><p>需要评估各API网关在需求上是否能满足，如： 如果是OpenAPI平台需要使用API网关，那么需要看API网关在合作伙伴应用接入、合作伙伴门户集成、访问次数限额等OpenAPI核心需求上去思考产品是否能满足要求。 如果是微服务网关，那么要从微服务的运维、监控、管理等方面去思考产品是否足够强大。</p><p>4、是否开源？公司是否有自开发的能力？</p><p>现有的开源产品如kong，zuul，orange都有基础的API网关的核心功能，这些开源产品大多离很好的使用有一定的距离，如：没有提供管理功能的UI界面、监控功能弱小，不支持OpenAPI平台，没有公司运营与运维的功能等。 当然开源产品能获取源代码，如果公司有比较强的研发能力，能hold住这些开源产品，经过二次开发kong、zuul应该还是适应一些公司，不过需求注意以下一些点：</p><ul><li>kong是基于ngnix+lua的，从公司的角度比较难于找到能去维护这种架构产品的人。 需求评估当前公司是否有这个能力去维护这个产品。</li><li>zuul因为架构的原因在高并发的情况下性能不高，同时需要去基于研究整合开源的适配zuul的监控和管理系统。</li><li>orange由于没有被大量使用，同时是国内个人在开源，在可持续性和社区资源上不够丰富，出了问题后可能不容易找到人问。</li></ul><p>另外kong提供企业版本的API网关，当然也是基于ngnix+lua的，企业版本可以购买他们的技术支持、培训等服务、以及拥有界面的管理、监控等功能。</p><p>5、公有云还是私有云</p><p>现在的亚马逊、阿里、腾讯云都在提供基础公有云的API网关，当然这些网关的基础功能肯定是没有问题，但是二次开发，扩展功能、监控功能可能就不能满足部分用户的定制需求了。另外很多企业因为自身信息安全的原因，不能使用外网公有网的API网关服务，这样就只有选择私有云的方案了。</p><p>在需求上如果基于公有云的API网关只能做到由内部人员为外网人员申请应用，无法做到定制的合作伙伴门户，这也不适合于部分企业的需求。<br>如果作为微服务网关，大多数情况下是希望网关服务器和服务提供方服务器是要在内网的，在这里情况下也只有私有云的API网关才能满足需求。</p><p>综合上面的分析，基础公有云的API网关只有满足一部分简单客户的需求，对于很多企业来说私有云的API网关才是正确的选择。</p><p>转自</p><h3 id="BLOG地址：www-liangsonghua-com"><a href="#BLOG地址：www-liangsonghua-com" class="headerlink" title="BLOG地址：www.liangsonghua.com"></a>BLOG地址：<a href="https://link.juejin.cn/?target=http://www.liangsonghua.com">www.liangsonghua.com</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、API网关的用处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;API网关我的分析中会用到以下三种场景。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open API。 企业需要将自身数据、能力等作为开发平台向外开放，通常会以rest的方式向外提供，最好的例子就是淘宝开放平台、腾讯公</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 的 16 条实践解读</title>
    <link href="http://ai.mak.cn/2020/02/28/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/"/>
    <id>http://ai.mak.cn/2020/02/28/java/Spring%20Boot%20%E7%9A%84%2016%20%E6%9D%A1%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2023-01-10T04:40:59.029Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我将重点介绍 Spring Boot 特有的实践（大多数时候，也适用于 Spring 项目）。以下依次列出了最佳实践，排名不分先后。</p><h3 id="1、使用自定义-BOM-来维护第三方依赖"><a href="#1、使用自定义-BOM-来维护第三方依赖" class="headerlink" title="1、使用自定义 BOM 来维护第三方依赖"></a>1、使用自定义 BOM 来维护第三方依赖</h3><p>这条实践是我根据实际项目中的经历总结出的。</p><p>Spring Boot 项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。</p><p>怎么办呢？事实上，Spring IO Platform 就是做的这个事情，它本身就是 Spring Boot 的子项目，同时维护了其他第三方开源库。我们可以借鉴 Spring IO Platform 来编写自己的基础项目 platform-bom，所有的业务模块项目应该以 BOM 的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.spring.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>platform-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Cairo-SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、使用自动配置"><a href="#2、使用自动配置" class="headerlink" title="2、使用自动配置"></a>2、使用自动配置</h3><p>Spring Boot 的一个主要特性是使用自动配置。这是 Spring Boot 的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的 jar 文件时，自动配置就会被激活。</p><p>使用它的最简单方法是依赖 Spring Boot Starters。因此，如果你想与 Redis 进行集成，你可以首先包括：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想与 MongoDB 进行集成，需要这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助于这些 starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的 Jar 地狱。</p><blockquote><p><a href="https://dzone.com/articles/what-is-jar-hell">https://dzone.com/articles/what-is-jar-hell</a></p></blockquote><p>通过使用以下注解属性，可以从自动配置中排除某些配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>（exclude = &#123;ClassNotToAutoconfigure.class&#125;）</span><br></pre></td></tr></table></figure><p>但只有在绝对必要时才应该这样做。</p><p>有关自动配置的官方文档可在此处找到：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html%E3%80%82">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。</a></p></blockquote><h3 id="3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目"><a href="#3、使用-Spring-Initializr-来开始一个新的-Spring-Boot-项目" class="headerlink" title="3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目"></a>3、使用 Spring Initializr 来开始一个新的 Spring Boot 项目</h3><blockquote><p>这一条最佳实践来自 Josh Long （Spring Advocate，@starbuxman）。</p></blockquote><p>Spring Initializr 提供了一个超级简单的方法来创建一个新的 Spring Boot 项目，并根据你的需要来加载可能使用到的依赖。</p><blockquote><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p>使用 Initializr 创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于 Spring 自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。</p><h3 id="4、考虑为常见的组织问题创建自己的自动配置"><a href="#4、考虑为常见的组织问题创建自己的自动配置" class="headerlink" title="4、考虑为常见的组织问题创建自己的自动配置"></a>4、考虑为常见的组织问题创建自己的自动配置</h3><p>这一条也来自 Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。</p><p>如果你在一个严重依赖 Spring Boot 的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。</p><p>这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。</p><p>如果将这个提供 Spring Boot 配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。</p><h3 id="5、正确设计代码目录结构"><a href="#5、正确设计代码目录结构" class="headerlink" title="5、正确设计代码目录结构"></a>5、正确设计代码目录结构</h3><p>尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。</p><p>避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；</p><p>将 Application.java（应用的入口类）保留在顶级源代码目录中；</p><p>我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！</p><h3 id="6、保持-Controller-的简洁和专注"><a href="#6、保持-Controller-的简洁和专注" class="headerlink" title="6、保持 @Controller 的简洁和专注"></a>6、保持 @Controller 的简洁和专注</h3><p>Controller 应该非常简单。你可以在此处阅读有关 GRASP 中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller">https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller</a></p></blockquote><ul><li>控制器应该是无状态的！默认情况下，控制器是单例，并且任何状态都可能导致大量问题；</li><li>控制器不应该执行业务逻辑，而是依赖委托；</li><li>控制器应该处理应用程序的 HTTP 层，这不应该传递给服务；</li><li>控制器应该围绕用例 &#x2F; 业务能力来设计。</li></ul><p>要深入这个内容，需要进一步地了解设计 REST API 的最佳实践。无论你是否想要使用 Spring Boot，都是值得学习的。</p><h3 id="7、围绕业务功能构建-Service"><a href="#7、围绕业务功能构建-Service" class="headerlink" title="7、围绕业务功能构建 @Service"></a>7、围绕业务功能构建 @Service</h3><p>Service 是 Spring Boot 的另一个核心概念。我发现最好围绕业务功能 &#x2F; 领域 &#x2F; 用例（无论你怎么称呼都行）来构建服务。</p><p>在应用中设计名称类似<code>AccountService</code>, <code>UserService</code>, <code>PaymentService</code>这样的服务，比起像<code>DatabaseService</code>、<code>ValidationService</code>、<code>CalculationService</code>这样的会更合适一些。</p><p>你可以决定使用 Controler 和 Service 之间的一对一映射，那将是理想的情况。但这并不意味着，Service 之间不能互相调用！</p><h3 id="8、使数据库独立于核心业务逻辑之外"><a href="#8、使数据库独立于核心业务逻辑之外" class="headerlink" title="8、使数据库独立于核心业务逻辑之外"></a>8、使数据库独立于核心业务逻辑之外</h3><p>我之前还不确定如何在 Spring Boot 中最好地处理数据库交互。在阅读了罗伯特 ·C· 马丁的 “Clear Architecture” 之后，对我来说就清晰多了。</p><p>你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。</p><blockquote><p>罗伯特 C. 马丁强烈地说明，你的数据库是一个 “细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用 Spring Boot 和现代微服务开发会让事情变得更快。</p></blockquote><h3 id="9、保持业务逻辑不受-Spring-Boot-代码的影响"><a href="#9、保持业务逻辑不受-Spring-Boot-代码的影响" class="headerlink" title="9、保持业务逻辑不受 Spring Boot 代码的影响"></a>9、保持业务逻辑不受 Spring Boot 代码的影响</h3><p>考虑到 “Clear Architecture” 的教训，你还应该保护你的业务逻辑。将各种 Spring Boot 代码混合在一起是非常诱人的…… 不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。</p><p>部分服务通常成为库。如果不从代码中删除大量 Spring 注解，则更容易创建。</p><h3 id="10、推荐使用构造函数注入"><a href="#10、推荐使用构造函数注入" class="headerlink" title="10、推荐使用构造函数注入"></a>10、推荐使用构造函数注入</h3><p>这一条实践来自 Phil Webb（Spring Boot 的项目负责人, @phillip_webb）。</p><p>保持业务逻辑免受 Spring Boot 代码侵入的一种方法是使用构造函数注入。不仅是因为<code>@Autowired</code>注解在构造函数上是可选的，而且还可以在没有 Spring 的情况下轻松实例化 bean。</p><h3 id="11、熟悉并发模型"><a href="#11、熟悉并发模型" class="headerlink" title="11、熟悉并发模型"></a>11、熟悉并发模型</h3><p>我写过的最受欢迎的文章之一是 “介绍 Spring Boot 中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。</p><blockquote><p><a href="https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/">https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/</a></p></blockquote><p>在 Spring Boot 中，Controller 和 Service 是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。</p><p>如果你正在使用新的 WebFlux 风格的 Spring Boot 应用程序，我已经解释了它在 “Spring’s WebFlux&#x2F;Reactor Parallelism and Backpressure” 中是如何工作的。</p><h3 id="12、加强配置管理的外部化"><a href="#12、加强配置管理的外部化" class="headerlink" title="12、加强配置管理的外部化"></a>12、加强配置管理的外部化</h3><p>这一点超出了 Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……</p><p>你可以手动处理 Spring 应用程序的配置。如果你正在处理多个 Spring Boot 应用程序，则需要使配置管理能力更加强大。</p><p>我推荐两种主要方法：</p><ul><li>使用配置服务器，例如 Spring Cloud Config；</li><li>将所有配置存储在环境变量中（可以基于 git 仓库进行配置）。</li></ul><p>这些选项中的任何一个（第二个选项多一些）都要求你在 DevOps 更少工作量，但这在微服务领域是很常见的。</p><h3 id="13、提供全局异常处理"><a href="#13、提供全局异常处理" class="headerlink" title="13、提供全局异常处理"></a>13、提供全局异常处理</h3><p>你真的需要一种处理异常的一致方法。Spring Boot 提供了两种主要方法：</p><ul><li>你应该使用 HandlerExceptionResolver 定义全局异常处理策略；</li><li>你也可以在控制器上添加 @ExceptionHandler 注解，这在某些特定场景下使用可能会很有用。</li></ul><p>这与 Spring 中的几乎相同，并且 Baeldung 有一篇关于 REST 与 Spring 的错误处理的详细文章，非常值得一读。</p><blockquote><p><a href="https://www.baeldung.com/exception-handling-for-rest-with-spring">https://www.baeldung.com/exception-handling-for-rest-with-spring</a></p></blockquote><h3 id="14、使用日志框架"><a href="#14、使用日志框架" class="headerlink" title="14、使用日志框架"></a>14、使用日志框架</h3><p>你可能已经意识到这一点，但你应该使用 Logger 进行日志记录，而不是使用 System.out.println() 手动执行。这很容易在 Spring Boot 中完成，几乎没有配置。只需获取该类的记录器实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(MyClass.class);</span><br></pre></td></tr></table></figure><p>这很重要，因为它可以让你根据需要设置不同的日志记录级别。</p><h3 id="15、测试你的代码"><a href="#15、测试你的代码" class="headerlink" title="15、测试你的代码"></a>15、测试你的代码</h3><p>这不是 Spring Boot 特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。</p><p>如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。</p><p>由于存在 Spring Boot 最佳实践，因此你应该考虑将 Spring Cloud Contract 用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。</p><h3 id="16、使用测试切片让测试更容易，并且更专注"><a href="#16、使用测试切片让测试更容易，并且更专注" class="headerlink" title="16、使用测试切片让测试更容易，并且更专注"></a>16、使用测试切片让测试更容易，并且更专注</h3><p>这一条实践来自 Madhura Bhave（Spring 开发者, @madhurabhave23）。</p><p>使用 Spring Boot 测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物…… 实际上并不是那么难！答案是使用测试切片。</p><p>使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自 spring.io 的一篇名为 Custom test slice with Spring test 1.4 的博客文章解释了这种技术。</p><blockquote><p><a href="https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4">https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感谢 Spring Boot，编写基于 Spring 的微服务正变得前所未有的简单。我希望通过这些最佳实践，你的实施过程不仅会变得很快，而且从长远来看也会更加强大和成功。祝你好运！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本文中，我将重点介绍 Spring Boot 特有的实践（大多数时候，也适用于 Spring 项目）。以下依次列出了最佳实践，排名不分先后。&lt;/p&gt;
&lt;h3 id=&quot;1、使用自定义-BOM-来维护第三方依赖&quot;&gt;&lt;a href=&quot;#1、使用自定义-BOM-来维护第三方依赖&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微服务核心架构梳理</title>
    <link href="http://ai.mak.cn/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/"/>
    <id>http://ai.mak.cn/2020/02/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2023-01-09T07:58:34.824Z</updated>
    
    <content type="html"><![CDATA[<p>作业总结的不错，转载一下～</p><p>作者：tengshe789</p><p>链接：<a href="https://urlify.cn/zYJzee">https://urlify.cn/zYJzee</a></p><p>下文，你将看到业界主流微服务框架的核心原理，包括服务发现，网关，配置中心，监控等组件，功能和架构原理的简单介绍。感谢阅读！</p><h1 id="Hello，Microservices"><a href="#Hello，Microservices" class="headerlink" title="Hello，Microservices"></a>Hello，Microservices</h1><p><strong>什么是微服务</strong></p><p>微服务Microservices之父，马丁.福勒，对微服务大概的概述如下：</p><blockquote><p>就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。但通在其常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p></blockquote><p>根据马丁.福勒的描述，我总结了一下几点：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/724387762baa49dabc8fae5f36edade1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ser3itD8NC19CaClz4hTVfpAGkA=" alt="img"></p><p><strong>小服务</strong></p><p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p><p><strong>进程独立</strong></p><p>每一组服务都是独立运行的，可能我这个服务运行在tomcat容器，而另一个服务运行在jetty上。可以通过进程方式，不断的横向扩展整个服务。</p><p><strong>通信</strong></p><p>过去的协议都是很重的，就像ESB，就像SOAP，轻通信，着意味着相比过去更智能更轻量的服务相互调用，就所谓smart endpoints and dumb pipes，这些endpoint都是解耦的，完成一个业务通信调用串起这些micro service就像是linux系统中通过管道串起一系列命令业务。</p><p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p><p><strong>部署</strong></p><p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维指责</p><p><strong>管理</strong></p><p>传统的企业级SOA服务往往很大，不易于管理，耦合性高，团队开发成本比较大。微服务，可以让团队各思其政的选择技术实现，不同的service可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p><h1 id="微服务的利与弊"><a href="#微服务的利与弊" class="headerlink" title="微服务的利与弊"></a><strong>微服务的利与弊</strong></h1><p>为什么用微服务呢？因为好玩？</p><p>不是的。下面是我从网络上找到说的比较全的优点：</p><blockquote><p>优点每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求<br>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。<br>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。<br>微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。<br>微服务能使用不同的语言开发。<br>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins,Hudson,bamboo。<br>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需- - 通过合作才能体现价值。微服务允许你利用融合最新技术。<br>微服务只是业务逻辑的代码，不会和 HTML,CSS或其他界面组件混合。<br>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</p></blockquote><p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p><p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p><h1 id="什么组织适合使用微服务？"><a href="#什么组织适合使用微服务？" class="headerlink" title="什么组织适合使用微服务？"></a><strong>什么组织适合使用微服务？</strong></h1><p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务？</p><p><strong>墨菲定律（设计系统）和康威定律（系统划分）</strong></p><p>康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/9e4d43792c37454aab148326328dcead~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=Fy0R5j/IHPDuxHSy/55w+RiOGBc=" alt="img"></p><p>感兴趣的各位可以研究一下</p><h1 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a><strong>架构演化</strong></h1><p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/c1e94e85a2c842e69cc79b5968dfdbb4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=lknzFU4sJ2RpxE25224WUSlSECA=" alt="img"></p><p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/b8127c777e884c4e8c4fdfabca298d1d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=UwJFqfOgqTedDW253kdV7CIcBiw=" alt="img"></p><p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用API方式发布他们的功能，而平台使用他们的功能发布产品</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/7c64a067343943759a1418e0dccd7f5d~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=YXJpXxB/aiO3D4MC5L84bOjJv6U=" alt="img"></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/429bf7c0a7a84099894e9b7cdfda1fe1~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aMnhFdwrd+teQLj2ZUPbDZJtJYs=" alt="img"></p><h1 id="微服务技术架构体系"><a href="#微服务技术架构体系" class="headerlink" title="微服务技术架构体系"></a><strong>微服务技术架构体系</strong></h1><p>下面我分享一下大部分公司都使用的微服务技术架构体系。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/1a3105e8d32d46379189e66a232c5f5a~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=ij1N/fUpKJzAvGEZlC5KBiLQyaY=" alt="img"></p><p><strong>服务发现</strong></p><p>主流的服务发现，分为三种</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/54bed4ea976241cdbf877ea00744b3ce~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cdJ1FzkKqJmQGQvYq/HY9r9kn4Y=" alt="img"></p><p>第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过dns就能找到我们对应的服务</p><p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/d899c1e6e46142498850771ecaff515f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=VDVwjxxbVq+BMeEc0YiYWvoHfQY=" alt="img"></p><p>第二种，是目前普遍的做法。可以参考我上篇博客分析的zuul网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p><p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在spring cloud上的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/dfa8e250379c48ebae7ca4e035afe9f3~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SEkNf7rkzF306T7LFZtnVqoV6gY=" alt="img"></p><p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p><p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p><p><strong>网关</strong></p><p>\1. 微服务的网关是什么？</p><p>我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p><p>将生活实际联系到微服务上，就不难理解网关的意思了。</p><p>\2. 网关有什么用</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/68c66bd974f0477d887ce55aefdbcc44~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=cZR+tSGtIE2FDJLjo7kgOUpwT7M=" alt="img"></p><ul><li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务条用</li><li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li><li>限流熔断：参考我学好分布式zookepper的博客，当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题</li><li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息</li><li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</li></ul><p>\3. 开源网关Zuul架构</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/6924461c3b584f178a6c1c71eb27dd63~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=aG4q8LZQ37wxOjllgVJsWlmADYc=" alt="img"></p><p>zuul网关核心其实是一个servlet，所有请求都会经过zuul servlet传到zuulFilter Runner，然后分发到三种过滤器。</p><p>先说说架构图左半部分，分别是使用Groovy实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p><p>一般请求都会先经过前置路由过滤器处理，一般的自定义java封装逻辑也会在这里实现。</p><p>路由过滤器，实现的是找到对应的微服务进行调用。</p><p>调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p><p>可以说zuul网关最大的特色就是它三层过滤器。</p><p>架构图右半部分，是zuul网关设计的自定义过滤器加载机制。网关内部会有生产者消费者模型，自动的将过滤器脚本发布到zuul网关读取加载运行。</p><p><strong>配置中心</strong></p><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p><p>因此就有配置中心这个喽~</p><p>现在的开源中心有百度配置中心 Disconf，spring cloud config，Apollo，今天重点说说现在应用质量不错的配置中心阿波罗。</p><h1 id="携程开源的Apollo："><a href="#携程开源的Apollo：" class="headerlink" title="携程开源的Apollo："></a>携程开源的Apollo：</h1><p>开源地址：<br><a href="http://github.com/ctripcorp/a%E2%80%A6">http://github.com/ctripcorp/a…</a></p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/491e23c2faf6474591de5c6315747bf4~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=25CNEBPSxaikMdxrij2U3KeXce0=" alt="img"></p><p>apollo的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。</p><p><strong>通讯方式</strong></p><p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/ed64b2a43bce4d0ba8ad9d098b6d0471~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=OIlCDdABP9f+xZvHYmwNyNHHg7E=" alt="img"></p><p><strong>监控预警</strong></p><p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。一般监控分为如下层次：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/10bde5726cbf454cabb768571febb1c2~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=P1vOxOdm3N1HsbgQ9XtWN1zDRWY=" alt="img"></p><p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。总体来说，微服务可分5个监控点：日志监控，Metrics监控，健康检查，调用链检查，告警系统</p><p><strong>监控架构</strong></p><p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个agent，agent收集到关键信息，会传到一些MQ中，为了解耦。同时将日志传入ELK，将Metrics传入InfluxDB时间序列库。而像nagios，可以定期向agent发起信息检查微服务。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/3b101e363c9c4ec487a25ba97bdaff98~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=sEFV5fgBICGW5MenbusWvbH83B8=" alt="img"></p><p><strong>调用链监控APM</strong></p><p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的Cat，大部分调用链监控（没错，我指的Zipkin）架构是这样的</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/aee3fd28e0cd42299b83486a608251c8~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=4kZFphBO9qDIRp1Oj3YKNb61Bgw=" alt="img"></p><p>当请求进入Web容器的时候，会经过创建Tracer，连接spans（模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过http headers）。Spans有一个上下文，其中包含tracer标识符，将其放在表示分布式操作的树的正确位置。当我们把图中的各种span放到后端的时候，我们的服务调用链会动态的生成调用链。</p><p>下面是一些市场上用的比较多的调用链监控：</p><p>1、Pinpointgithub地址：GitHub - naver&#x2F;pinpoint: Pinpoint is an open source APM (Application Performance Management) tool for large-scale distributed systems written in Java.对java领域的性能分析有兴趣的朋友都应该看看这个开源项目，这个是一个韩国团队开源出来的，通过JavaAgent的机制来做字节码代码植入，实现加入traceid和抓取性能数据的目的。NewRelic、Oneapm之类的工具在java平台上的性能分析也是类似的机制。</p><p>2、SkyWalkinggithub地址：wu-sheng&#x2F;sky-walking这是国内一位叫吴晟的兄弟开源的，也是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统，在github上也有400多颗星了。功能相对pinpoint还是稍弱一些，插件还没那么丰富，不过也很难得了。</p><p>3、Zipkin官网：OpenZipkin · A distributed tracing systemgithub地址：GitHub - openzipkin&#x2F;zipkin: Zipkin is a distributed tracing system这个是twitter开源出来的，也是参考Dapper的体系来做的。</p><p>Zipkin的java应用端是通过一个叫Brave的组件来实现对应用内部的性能分析数据采集。Brave的github地址：<br><a href="http://github.com/openzipkin/%E2%80%A6%E8%BF%99%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84java%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E6%9D%A5%E5%81%9A%E5%88%B0%E5%AF%B9http/servlet%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E8%B7%9F%E8%B8%AA%E3%80%82%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E5%9C%A8spring%E4%B9%8B%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8C%E5%8A%A0%E5%85%A5%E8%BF%99%E4%BA%9B%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E5%AE%8C%E6%88%90%E5%AF%B9java%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%82">http://github.com/openzipkin/…这个组件通过实现一系列的java拦截器，来做到对http/servlet请求、数据库访问的调用过程跟踪。然后通过在spring之类的配置文件里加入这些拦截器，完成对java应用的性能数据采集。</a></p><p>4、CATgithub地址：GitHub - dianping&#x2F;cat: Central Application Tracking这个是大众点评开源出来的，实现的功能也还是蛮丰富的，国内也有一些公司在用了。不过他实现跟踪的手段，是要在代码里硬编码写一些“埋点”，也就是侵入式的。这样做有利有弊，好处是可以在自己需要的地方加埋点，比较有针对性；坏处是必须改动现有系统，很多开发团队不愿意。</p><p>5、Xhprof&#x2F;Xhgui这两个工具的组合，是针对PHP应用提供APM能力的工具，也是非侵入式的。Xhprof github地址：GitHub - preinheimer&#x2F;xhprof: XHGUI is a GUI for the XHProf PHP extension, using a database backend, and pretty graphs to make it easy to use and interpret.Xhgui github地址：GitHub - perftools&#x2F;xhgui: A graphical interface for XHProf data built on MongoDB我对PHP不熟，不过网上介绍这两个工具的资料还是蛮多的。</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/4507d426ed7146688375580da41906ff~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=rypjolffor+bucyFBSFu7Oh2mZY=" alt="img"></p><p><strong>熔断、隔离、限流、降级</strong></p><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用）措施。</p><p>下面介绍一下hystrix的运行流程（没找到架构图不好意思）：</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/159090c7e4cb48c3b028fbd031bcc1e7~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=SaFR9FsnPR98f8EH08yjHM83Y+Y=" alt="img"></p><p>每一个微服务调用时，都会使用hystrix的command方式（上图的左上角那个），然后使用command同步的，或者是响应式的，或者是异步的，判断电路是否熔断（顺着图从左往右看），</p><p>如果断路则走降级fallback；</p><p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施（看图的第5步）；</p><p>如果走完了，执行成功了，则走run()方法，获取response，但是这个过程如果出错了，则继续走降级fallback.</p><p>同时，看图最上面有一个后缀是health的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p><p><strong>容器与服务编排引擎</strong></p><p>从物理机到虚拟机，从虚拟机到容器；从物理集群到open stack，open stack到kubernetes；科技不断的变化，我们的认知也没刷新。</p><p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。 虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。虚拟机依赖于hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致hypervisor在某些方面被认为是一种操作系统。</p><p>一旦 hypervisor安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层Runtime，然后供应用程序运行。</p><p>对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如LXC或libcontainer)安装在主机操作系统(通常是Linux变种)之上。在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p><p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味相比于虚拟机，单个操作系统能够承载更多的容器。云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p><p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p><p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。正因为如此，容器才拥有极为出色的轻量化特性。</p><p>我们最常用的容器是daocker，网址如下<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>容器编排：</p><p>过去虚拟机可以通过云平台open stack管理虚拟化，容器时代如何管理容器呢？这就要看看容器编排引擎了。</p><p><strong>Apache mesos</strong></p><p>mesos是基于master，slave架构，框架决定如何利用资源，master负责管理机器，slave会定期的将机器情况报告给master，master再将信息给框架。master是高可用的，因为zk，也有leader的存在。下面是架构图</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/39a21281f9334b1b853f04a48107336b~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=WPM760vVO3zapa972giTo+2WRLY=" alt="img"></p><p><strong>kubernetes</strong></p><p>kubernetes是最近十分火热的开源容器编排引擎，具体可以参考kubernetes中文文档</p><p><img src="https://p3-sign.toutiaoimg.com/pgc-image/596e958431f54c18a22592150ca8c103~noop.image?_iz=58558&from=article.pc_detail&x-expires=1673855185&x-signature=yG+jZsDug8lqC7rMQSawQEqBlQI=" alt="img"></p><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，先说说每一个Kubernetes节点内部，kubelet管理全局全局pod，而每一个pod承载着一个或多个容器，kube-proxy负责网络代理和负载均衡 。</p><p>Kubernetes节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p><p><strong>服务网格化</strong></p><p>待更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作业总结的不错，转载一下～&lt;/p&gt;
&lt;p&gt;作者：tengshe789&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://urlify.cn/zYJzee&quot;&gt;https://urlify.cn/zYJzee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下文，你将看到业界主流微服务框架的核心原理</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
