<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2022-11-14T03:31:10.728Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>阿里毕玄：我在系统设计上犯过的 14 个错</title>
    <link href="http://ai.mak.cn/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/"/>
    <id>http://ai.mak.cn/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2022-11-14T05:59:23.703Z</updated>
    
    <content type="html"><![CDATA[<p><strong>|</strong> 本文转载至 Hello Java。</p><p>这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中），发现大的错误基本集中在前面几年，从这个点看起来能比较自豪的说在最近的几年在系统设计的掌控上确实比以前成熟了很多。</p><p>除了自己犯的错以外，也还看过其他同学犯的一些错，这个在后面再写一篇文章来分享下，同时也征集大家印象深刻的推倒重来的系统设计的错。</p><p><strong>第1个错</strong></p><p>在设计服务框架时，我期望服务框架对使用者完全不侵入，于是做了一个在外部放一个.xml文件来描述spring里的哪些bean发布为服务的设计，这个版本发布后，第一个小白鼠的用户勉强在用，但觉得用的很别扭，不过还是忍着用下去了，到了发布的时候，发现出现了两个问题，一是这个xml文件研发也不知道放哪好，所以到了发布的时候都不知道去哪拿这个xml文件。</p><p>这个设计的关键错误就在于在设计时没考虑过这个设计方式对研发阶段、运维阶段的影响，后来纠正这个错误的方法是去掉了这个xml文件，改为写了一个Spring FactoryBean，用户在spring的bean配置文件中配置下就可以。</p><p>因此对于一个架构师来说，设计时在全面性上要充分考虑。</p><p><strong>第2个错</strong></p><p>服务框架在核心应用上线时，出现了前端web应用负载高，处理线程数不够用的现象，当时处理这个故障的方式是回滚了服务框架的上线，这个故障排查了比较长的时间后，查到的原因是服务框架用的JBoss Remoting在通信时默认时间是60s，导致一些处理速度慢的请求占据了前端web应用的处理线程池。</p><p>上面这里故障的原因简单来说是分布式调用中超时时间太长的问题，但更深层次来思考，问题是犯在了设计服务框架时的技术选型，在选择JBoss-Remoting时没有充分的掌握它的运行细节，这个设计的错误导致的是后来决定放弃JBoss-Remoting，改为基于Mina重写了服务框架的通信部分，这里造成了服务框架的可用版本发布推迟了两个多月。</p><p>因此对于一个架构师来说，在技术选型上对技术细节是要有很强的掌控力的。</p><p><strong>第3个错</strong></p><p>在服务框架大概演进到第4个版本时，通信协议上需要做一些改造，突然发现一个问题是以前的通信协议上是没有版本号的，于是悲催的只能在代码上做一个很龌蹉的处理来判断是新版本还是老版本。</p><p>这个设计的错误非常明显，这个其实只要在最早设计通信协议时参考下现有的很多的通信协议就可以避免了，因此这个错误纠正也非常简单，就是参考一些经典的协议重新设计了下。</p><p>因此对于一个架构师来说，知识面的广是非常重要的，或者是在设计时对未来有一定的考虑也是非常重要的。</p><p>说到协议，就顺带说下，当时在设计通信协议和选择序列化&#x2F;反序列化上没充分考虑到将来多语言的问题，导致了后来在多语言场景非常的被动，这也是由于设计时前瞻性的缺失，所谓的前瞻性不是说一定要一开始就把未来可能会出现的问题就解掉，而是应该留下不需要整个改造就可以解掉的方法，这点对于架构师来说也是非常重要的。</p><p><strong>第4个错</strong></p><p>在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。</p><p>这个设计的错误主要在于没有考虑生产环境中走硬件负载均衡后，这种单个长连接方式带来的问题，这个错误呢还真不太好纠正，当时临时用的一个方法是服务调用方的连接每发送了1w个请求后，就把连接自动断开重建，最终的解决方法是去掉了负载均衡设备这个中间点。</p><p>因此对于一个架构师来说，设计时的全面性要非常的好，我现在一般更多采用的方式是推演上线后的状况，一般来说在脑海里过一遍会比较容易考虑到这些问题。</p><p><strong>第5个错</strong></p><p>服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本，当时只好用一个临时的扫全网机器的方法来解决。</p><p>这个问题后来纠正的方法是在服务发布和调用者在连接我们的一个点时，顺带把用的服务框架的版本号带上，于是就可以很简单的知道全网的服务框架目前在运行的版本号了。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的，推演能起到很大的帮助作用。</p><p><strong>第6个错</strong></p><p>服务框架这种基础类型的产品，在发布时会碰到个很大的问题，就是需要通知到使用者去发布，导致了整个发布周期会相当的长，当时做了一个决定，投入资源去实现完全动态化的发布，就是不需要重启，等到做的时候才发现这完全就是个超级大坑，最终这件事在投入两个人做了接近半年后，才终于决定放弃，而且最终来看其实升级的问题也没那么大。</p><p>这个问题最大的错误在于对细节把握不力，而且决策太慢。</p><p>因此对于一个架构师来说，技术细节的掌控非常重要，同时决策力也是非常重要的。</p><p><strong>第7个错</strong></p><p>服务发布方经常会碰到一个问题，就是一个服务里的某些方法是比较耗资源的，另外的一些可能是不太耗资源，但对业务非常重要的方法，有些场景下会出现由于耗资源的方法被请求的多了些导致不太耗资源的方法受影响，这种场景下如果要去拆成多个服务，会导致开发阶段还是挺痛苦的，因此服务框架这边决定提供一个按方法做七层路由的功能，服务的发布方可以在一个地方编写一个规则文件，这个规则文件允许按照方法将生产环境的机器划分为不同组，这样当服务调用方调用时就可以做到不同方法调用到不同的机器。</p><p>这个功能对有些场景来说用的很爽，但随着时间的演进和人员的更换，能维护那个文件的人越来越少了，也成为了问题。</p><p>这个功能到现在为止我自己其实觉得也是一直处于争议中，我也不知道到底是好还是不好…</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p><em><strong>*|*</strong></em> 减少犯错误的方法：多阅读、多实践、多总结。</p><p>**<br>**</p><p><strong>第8个错</strong></p><p>服务框架在用的越来越广后，碰到了一个比较突出的问题，服务框架依赖的jar版本和应用依赖的jar版本冲突，服务框架作为一个通用技术产品，基本上没办法为了一个应用改变服务框架自己依赖的jar版本，这个问题到底怎么去解，当时思考了比较久。</p><p>可能是由于我以前OSGi这块背景的原因，在设计上我做了一个决定，引入OSGi，将服务框架的一堆jar处于一个独立的classloader，和应用本身的分开，这样就可以避免掉jar冲突的问题，在我做了引入OSGi这个决定后，团队的1个资深的同学就去做了，结果是折腾了近两个月整个匹配OSGi的maven开发环境都没完全搭好，后来我自己决定进去搞这件事，即使是我对OSGi比较熟，也折腾了差不多1个多月才把整个开发的环境，工程的结构，以及之前的代码基本迁移为OSGi结构，这件事当时折腾好上线后，效果看起来是不错的，达到了预期。</p><p>但这件事后来随着加入服务框架的新的研发人员越来越多，发现多数的新人都在学习OSGi模式的开发这件事上投入了不少的时间，就是比较难适应，所以后来有其他业务问是不是要引入OSGi的时候，我基本都会建议不要引入，主要的原因是OSGi模式对大家熟悉的开发模式、排查问题的冲击，除非是明确需要classloader隔离、动态化这两个点。</p><p>让我重新做一个决策的话，我会去掉对OSGi的引入，自己做一个简单的classloader隔离策略来解决jar版本冲突的问题，保持大家都很熟悉的开发模式。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p><strong>第9个错</strong></p><p>服务框架在用的非常广了后，团队经常会被一个问题困扰和折腾，就是业务经常会碰到调用服务出错或超时的现象，这种情况通常会让服务框架这边的研发来帮助排查，这个现象之所以查起来会比较复杂，是因为服务调用通常是多层的关系，并不是简单的A–&gt;B的问题，很多时候都会出现A–&gt;B–&gt;C–&gt;D或者更多层的调用，超时或者出错都有可能是在其中某个环节，因此排查起来非常麻烦。</p><p>在这个问题越来越麻烦后，这个时候才想起在09年左右团队里有同学看过G家的一篇叫dapper的论文，并且做了一个类似的东西，只是当时上线后我们一直想不明白这东西拿来做什么，到了排查问题这个暴露的越来越严重后，终于逐渐想起这东西貌似可以对排查问题会产生很大的帮助。</p><p>到了这个阶段才开始做这件事后，碰到的主要不是技术问题，而是怎么把新版本升级上去的问题，这个折腾了挺长时间，然后上线后又发现了一个新的问题是，即使服务框架具备了Trace能力，但服务里又会调外部的例如数据库、缓存等，那些地方如果有问题也会看不到，排查起来还是麻烦，于是这件事要真正展现效果就必须让Trace完全贯穿所有系统，为了做成这件事，N个团队付出了好几年的代价。</p><p>因此对于一个架构师来说，设计时的全面性、前瞻性非常重要，例如Trace这个的重要性，如果在最初就考虑到，那么在一开始就可以留好口子埋好伏笔，后面再要做完整就不会太复杂。</p><p><strong>第10个错</strong></p><p>服务的发布方有些时候会碰到一个现象是，服务还没完全ready，就被调用了；还有第二个现象是服务发布方出现问题时，要保留现场排查问题，但服务又一直在被调用，这种情况下就没有办法很好的完全保留现场来慢慢排查问题了。</p><p>这两个现象会出现的原因是服务框架的设计是通过启动后和某个中心建立连接，心跳成功后其他调用方就可以调用到，心跳失败后就不会被调到，这样看起来很自动化，但事实上会导致的另外一个问题是外部控制上下线这件事的能力就很弱。</p><p>这个设计的错误主要还是在设计时考虑的不够全面。</p><p>因此对于一个架构师来说，设计时的全面性非常重要。</p><p><strong>第11个错</strong></p><p>在某年我和几个小伙伴决定改变当时用xen的模式，换成用一种轻量级的“虚拟机”方式来做，从而提升单机跑的应用数量的密度，在做这件事时，我们决定自己做一个轻量级的类虚拟机的方案，当时决定的做法是在一个机器上直接跑进程，然后碰到一堆的问题，例如从运维体系上来讲，希望ssh到“机器”、独立的ip、看到自己的系统指标等等，为了解决这些问题，用了N多的黑科技，搞得很悲催，更悲催的是当时觉得这个问题不多，于是用一些机器跑了这个模式，结果最后发现这里面要黑科技解决的问题实在太多了，后来突然有个小伙伴提出我们试用lxc吧，才发现我们之前用黑科技解的很多问题都没了，哎，然后就是决定切换到这个模式，结果就是线上的那堆机器重来。</p><p>这个设计的主要错误在于知识面不够广，导致做了个不正确的决定，而且推倒重来。</p><p>因此对于一个架构师来说，知识面的广非常重要，在技术选型这点上非常明显。</p><p><strong>第12个错</strong></p><p>还是上面这个技术产品，这个东西有一个需求是磁盘空间的限额，并且要支持磁盘空间一定程度的超卖，当时的做法是用image的方式来占磁盘空间限额，这个方式跑了一段时间觉得没什么问题，于是就更大程度的铺开了，但铺开跑了一段时间后，出现了一个问题，就是经常出现物理机磁盘空间不足的报警，而且删掉了lxc容器里的文件也还是不行，因为image方式只要占用了就会一直占着这个大小，只会扩大不会缩小。</p><p>当时对这个问题极度的头疼，只能是删掉文件后，重建image，但这个会有个要求是物理机上有足够的空间，即使有足够的空间，这个操作也是很折腾人的，因为得先停掉容器，cp文件到新创建的容器，这个如果东西多的话，还是要耗掉一定时间的。</p><p>后来觉得这个模式实在是没法玩，于是寻找新的解决方法，来满足磁盘空间限额，允许超卖的这两需求，最后我们也是折腾了比较长一段时间后终于找到了更靠谱的解决方案。</p><p>这个设计的主要错误还是在选择技术方案时没考虑清楚，对细节掌握不够，考虑的面不够全，导致了后面为了换掉image这个方案，用了极大的代价，我印象中是一堆的人熬了多次通宵来解决。</p><p>因此对于一个架构师来说，知识面的广、对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第13个错</strong></p><p>仍然是上面的这个技术产品，在运行的过程中，突然碰到了一个虚拟机中线程数创建太多，导致其他的虚拟机也创建不了线程的现象（不是因为物理资源不够的问题），排查发现是由于尽管lxc支持各个容器里跑相同名字的账号，但相同名字的账号的uid是相同的，而max processes是限制在UID上的，所以当一个虚拟机创建的线程数超过时，就同样影响到了其他相同账号的容器。</p><p>这个问题我觉得一定程度也可以算是设计问题，设计的时候确实由于对细节掌握的不够，考虑的不全导致忽略了这个点。</p><p>因此对于一个架构师来说，对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第14个错</strong></p><p>在三年前做一个非常大的项目时，项目即将到上线时间时，突然发现一个问题是，有一个关键的点遗漏掉了，只好赶紧临时讨论方案决定怎么做，这个的改动动作是非常大的，于是项目的上线时间只能推迟，我记得那个时候紧急周末加班等搞这件事，最后带着比较高的风险上了。</p><p>这个问题主要原因是在做整体设计时遗漏掉了这个关键点的考虑，当时倒不是完全忽略了这个点，而是在技术细节上判断错误，导致以为不太要做改动。</p><p>因此对于一个架构师来说，对技术细节的掌控是非常重要的，这里要注意的是，其实不代表架构师自己要完全什么都很懂，但架构师应该清楚在某个点上靠谱的人是谁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;|&lt;/strong&gt; 本文转载至 Hello Java。&lt;/p&gt;
&lt;p&gt;这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>详解设计模式在Spring中的应用</title>
    <link href="http://ai.mak.cn/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://ai.mak.cn/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2022-11-14T05:37:53.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：螃蟹<br><a href="http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html">http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html</a><br>Java架构师之路做了编排 </p></blockquote><p>设计模式作为工作学习中的枕边书，却时常处于勤说不用的尴尬境地，也不是我们时常忘记，只是一直没有记忆。</p><p>今天，螃蟹在IT学习者网站就设计模式的内在价值做一番探讨，并以spring为例进行讲解，只有领略了其设计的思想理念，才能在工作学习中运用到“无形”。</p><p>Spring作为业界的经典框架，无论是在架构设计方面，还是在代码编写方面，都堪称行内典范。好了，话不多说，开始今天的内容。</p><p>spring中常用的设计模式达到九种，我们一一举例：</p><p><strong>第一种：简单工厂</strong></p><p>又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 </p><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 </p><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;singletonBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是singletonBean!value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">   &lt;/ bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;itxxzBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;</span><br><span class="line">        singleton=&quot;false&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种：工厂方法（Factory Method）</strong></p><p>通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。</p><p>一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</p><p>螃蟹就以工厂方法中的静态方法为例讲解一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class StaticFactoryBean &#123;</span><br><span class="line">      public static Integer createRandom() &#123;</span><br><span class="line">           return new Integer(new Random().nextInt());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;random&quot;</span><br><span class="line">class=&quot;example.chapter3.StaticFactoryBean&quot;</span><br><span class="line">factory-method=&quot;createRandom&quot; //createRandom方法必须是static的,才能找到</span><br><span class="line">scope=&quot;prototype&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例</span><br><span class="line">      XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;config.xml&quot;));</span><br><span class="line">      System.out.println(&quot;我是IT学习者创建的实例:&quot;+factory.getBean(&quot;random&quot;).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：单例模式（Singleton）</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p><p>spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 </p><p>核心提示点：Spring下默认的bean均为singleton，可以通过singleton&#x3D;“true|false” 或者 scope&#x3D;“？”来指定</p><p><strong>第四种：适配器（Adapter）</strong></p><p>在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</p><p><strong>Adapter类接口</strong>：Target</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface AdvisorAdapter &#123;</span><br><span class="line"></span><br><span class="line">boolean supportsAdvice(Advice advice);</span><br><span class="line"></span><br><span class="line">      MethodInterceptor getInterceptor(Advisor advisor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MethodBeforeAdviceAdapter类</strong>，Adapter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;</span><br><span class="line"></span><br><span class="line">      public boolean supportsAdvice(Advice advice) &#123;</span><br><span class="line">            return (advice instanceof MethodBeforeAdvice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public MethodInterceptor getInterceptor(Advisor advisor) &#123;</span><br><span class="line">            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">      return new MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五种：包装器（Decorator）</strong></p><p>在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ </p><p>首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。<br>spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 </p><p><strong>第六种：代理（Proxy）</strong></p><p>为其他对象提供一种代理以控制对这个对象的访问。 </p><p>从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 </p><p>spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 </p><p><strong>第七种：观察者（Observer）</strong></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 </p><p><strong>第八种：策略（Strategy）</strong></p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>spring中在实例化对象的时候用到Strategy模式在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： </p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/M7B64fHXISuuxb3OYhV7MtTEqMR53b1k2gueQDW4I1oibFLSFGROiaUHUjDRkPBNc0xDfgYnhu5NicENT713wzy4A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>第九种：模板方法（Template Method）</strong></p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p><p>以下是一个具体的例子：<br>JdbcTemplate中的execute方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：螃蟹&lt;br&gt;&lt;a href=&quot;http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html&quot;&gt;http://itxxz.com/a/javashili/tuozhan/2014/0601/7.ht</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何激发团队的创造力</title>
    <link href="http://ai.mak.cn/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    <id>http://ai.mak.cn/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2022-11-14T05:25:15.434Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如何激发团队的创造力？</strong></p><p>人生一切难题，知识给你答案。</p><p>提到创意，有一家公司不能不提——皮克斯，《海底总动员》《头脑特工队》《寻梦环游记》……它的每个创意都令人惊叹。</p><p>今天这本书，就带你看看皮克斯有哪些激发创意的高招——</p><p><strong>《创新公司：皮克斯的启示》</strong></p><p><strong>作者: [美] 艾德·卡特姆 埃米·华莱士</strong> </p><p><strong>译者: 靳婷婷</strong> </p><p><strong>出版: 中信出版社</strong></p><p>作者艾德·卡特姆，是皮克斯动画的总裁。他真正厉害的地方不仅是生产创意，而且独创了一套管理创意团队的机制，让天才们能够毫无障碍地通力合作。下面就带你看看他的做法。</p><p><em>1.</em> <strong>设立“智囊团”。</strong>很多公司会设立专门的创意部门，去开发新创意。但皮克斯的智囊团人员从来不是固定的，只要你擅长讲故事、熟悉电影制度，都能加入，包括导演、编剧、故事总监、文化顾问等等。每部电影进行到一定阶段，智囊团就会碰头，讨论新的创意，评价正在制作的电影。</p><p><em>2.</em> <strong>追求最佳效果，不怕“推倒重建”。</strong>几乎所有公司都宣称追求最佳产品质量，可一旦要牺牲大量成本时，很多公司就犹豫了。但皮克斯的电影即便已经制作完毕，一旦有更好的想法，也会推倒重建。你肯定看过《瓦力》，原结局是瓦力救下了心爱的机器人伊娃，但智囊团认为结局没有冲击力，才改为了伊娃违背程序设定，毅然救下瓦力的结尾。也正是这种精益求精的做法，给皮克斯带来了票房和口碑双收的回报。</p><p><em>3.</em> <strong>明确要求员工给出建设性批评。</strong>我们常会听到这样的批评，“这个活动很无聊”“这个方案没有打动我”，但就是不知道到底是哪里不够好。这就是非建设性的批评——只说感受而不点明问题。皮克斯为了杜绝这种现象，明确要求每次样片修改时，都要点出问题并且指出改进的方向。比如“这是重点台词，但现在的表达不够简单有力”。</p><p><em>4.</em> <strong>注重真实，进行“考察旅行”。</strong>很多公司为了获得创意，会广泛收集素材激发灵感。皮克斯在这一点做得更彻底，直接让主创到故事背景地考察旅行。比如以墨西哥为背景的《寻梦环游记》，主角是一个鞋匠世家，主创特意拜访了当地著名的鞋匠，了解做鞋的各种工艺。片中的万寿菊、剪纸等物品，也都是现实中墨西哥街头常见的装饰物。</p><p><em>5.</em> <strong>确保制作中只有导演才有最终决定权。</strong>一个项目参与的人越多，就越容易出现很多人给出意见、话语权混乱的情况，甚至还可能导致由高层“外行指导内行”。在皮克斯，绝不允许这种情况发生，直接明文规定导演在制作中有最终决定权，即便是高层的建议，导演也可以合理回绝。</p><p><em>6.</em> <strong>不浪费时间，尽快试错。</strong>创意制作过程难免会出现问题，很多公司会停下来讨论，一定要找出最完美的方案才继续。但皮克斯不会原地纠结，认为一个方案不行就及时否定，然后尽快尝试其他方向，而不是等待最佳方案。比如《怪物电力公司》，就经过了无数次否定和尝试的过程，主角设定从一个30岁的男人，变成小男孩，最终又改为小女孩，才进入到剧本阶段。</p><p><em>7.</em> **营造团队安全感，**公开分享失误**。**研究发现，想要团队成员能够高效开展工作，给员工营造良好的心理安全感非常关键。不同于其他公司，员工犯错会严厉责备，皮克斯会由领导层带头，公开分析犯错的原因。这让整个公司有良好的氛围，员工都愿意公开表达意见，避免问题再犯。&gt;&gt;&gt;<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjAxOTU4MA==&mid=3009217590&idx=1&sn=14532c49bc8cb0817544181a10e9309f&chksm=90460825a7318133e7905c02e708d5222abfea930e61b4216f15b7504e39734bcd41cfb0a26d&scene=21#wechat_redirect">如何正确对待错误，戳此查看另一篇文章</a></p><p><em>8.</em> <strong>重视新老员工的传承，制定培训制度。</strong>每个公司都重视新老员工的传承，但如果不落实到具体的制度上，最后很可能会变成一纸空话。皮克斯曾经有过一次教训，把一个项目交给无经验的新导演，结果不幸“流产”。此后皮克斯直接明文规定，资深导演每周都要和新人进行交流，并设置了一套新人培训课程，确保新老员工不断层。</p><p><em>9.</em> <strong>改善办公环境，打破层级来交流。</strong>打破层级不是光喊口号，而是从细节开始的改变。最初，皮克斯的大会议室摆放了一张能坐30人的长桌，开会时每个人都有座位牌，但后来发现，这让坐在中间的人的意见更重要，反而强化了层级，交流效果不好。因此，皮克斯就取消了长桌和座位牌，换成10个人左右的小桌，更利于自由沟通。</p><p><em>10.</em> <strong>设立“点评日”集思广益。</strong>很多公司会收集员工对公司的建议，但大多是私下场合的零碎建议。皮克斯从2013年起，制定了专门汇集意见的“点评日”传统——全体员工当天暂停工作，只做一件事：讨论如何把皮克斯建设得更好，比如“如何搭建一个跨项目的共享资料库”“如何消灭特权现象”。经过讨论，公司再选出优秀方案试行。</p><p>让我们对《创新公司：皮克斯的启示》的作者艾德·卡特姆、埃米·华莱士 ，译者靳婷婷 ，出版方中信出版社，说一声感谢！</p><p>最后，与你分享金句，欢迎你收藏并转发：</p><p>好创意不只依赖灵光闪现，</p><p>还需要开放包容的团队管理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;如何激发团队的创造力？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人生一切难题，知识给你答案。&lt;/p&gt;
&lt;p&gt;提到创意，有一家公司不能不提——皮克斯，《海底总动员》《头脑特工队》《寻梦环游记》……它的每个创意都令人惊叹。&lt;/p&gt;
&lt;p&gt;今天这本书，就带你看看皮克斯有哪</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的一些新特性、使用建议和最佳实践</title>
    <link href="http://ai.mak.cn/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2022-11-14T05:07:53.851Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Redis 5.0已经发布，越来越多的新特性被加入，在工作中发现很多人只是了解一些Redis的基本使用，也并未完整的阅读过Redis的官方文档，对于一些命令不熟悉，不同场景下滥用不合理的数据结构，对一些新的特性似乎也不会去关注，本文总结了一些使用建议。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1、SET key value [expiration EX seconds|PX milliseconds][NX|XX]</p><ul><li>Redis 2.6.12版本后的Set命令支持过期时间等参数，不必再像以前一样分为set和expire两个命令</li></ul><p>2、bitmap</p><ul><li>适用于大量数据的位图信息标记，例如如果要标记大量用户的某个状态值，可以考虑使用bitmap</li><li>bitmap的另外一个应用是基于redis的bloom filter</li></ul><p>3、stream</p><ul><li>Redis4开始提供的新的数据结构，可以理解成轻量级的kafka steam，主要解决了pub&#x2F;sub无法保证通知处理成功和blocked list无法多个client消费的问题，具体点击此处查看topic。</li><li>如果想实现一个简单的聊天室，可以尝试下steam。</li></ul><h1 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h1><p>1、合理分配过期时间</p><ul><li>不管是将Redis作为缓存，还是存储，如果不愿意看到内存被慢慢消耗殆尽，最后只能扩容或者人工介入，就给自己的key设置一个合理的过期时间。 当把Redis作为缓存时，更要预估自己的数据量和数据大小，选择一个合理的过期时间。</li></ul><p>2、多个操作使用pinepine</p><ul><li>这是Redis使用中的一项基本原则，同时需要知道，另外如果下一个命令的input基于上一个命令的output，就不可以放到一个pipeline里面执行了</li><li>使用时考虑pipeline中一个命令执行失败的场景，后面的命令未执行是否因为一致性带来问题</li></ul><p>3、使用命名空间</p><ul><li>方便key的管理，我们开发中常用的redis-desktop客户端能够按照命名空间对key进行展示，另外，命名空间方便需要对某一类key进行统计和管理</li><li>如果需要通过key进行分片，命名空间可以作为分片参数</li></ul><p>4、选用合适的数据结构</p><ul><li>理解每个数据结构的用途，和常用的命令，我曾经见过开发人员因为不知道scard命令可以获得set的size，而将所有的元素取出然后在程序中计算，所以需要平时多查看Redis命令文档；如果能够理解每种数据结构背后的原理，使用时会更加得心应手。</li><li>不建议使用Redis缓存单个数据大小较大的对象，尤其是使用Set，Hash此类数据结构时候，考虑到Redis是单线程，过多的大对象访问增加了网络IO压力，对Redis性能有一定影响，另一方面Redis的虚拟内存page较小，如果内存碎片率较高，则分配&#x2F;申请内存时在性能上有些影响。如果要缓存较大的对象，可以考虑memcache</li></ul><p>5、禁用keys</p><ul><li>很基本的Redis使用常识，可以通过rename-command来将一些类似的命令重命名，实现disable的效果</li></ul><p>6、选用lua script</p><ul><li>如果要保证多个操作的原子性，可以选择使用lua脚本</li></ul><p>7、config set parameter value</p><ul><li>redis 2.0后提供了config set 命令来动态修改一些运行参数而不必重启redis，目前已经支持动态修改maxmemory，可以通过CONFIG GET * 查看支持动态修改的参数列表</li></ul><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>1、key的命名</p><ul><li>合理的命名自己的key，不能在查看数据时可读性更强，也更便于统计和管理</li></ul><p>2、key name的长度</p><ul><li>预估key的存活数量，如果key的数量可能达到百万级别，就需要考虑key的名字过长而导致占用太多的存储空间，我在曾经参与过的一个消息系统中使用redis存储消息阅读量，但是后面由于消息量过多，导致name的占用空间达到几百M，如果精简name，可以节省大量的空间，减少不必要的困扰。 例如，保存用户的基本信息可以使用u:${id}</li></ul><p>3、不滥用Lua Script</p><ul><li>由于Redis是单线程，在QPS很高的情况下，过多的lua脚本执行，特别是内部包含较多业务逻辑处理的情况下，会对Redis性能产生很大的影响。曾经参与过的直播业务的生产环境中，我们在Lua脚本中对送礼物触发的的积分和活动信息的有较多的逻辑处理（20行左右），导致Redis负载100%，所以在排查时Lua脚本有可能是负载较高的元凶之一。</li></ul><p>4、关注内存和slowlog等统计数据</p><ul><li><p>通过info memory查看内存的分配和使用大小，碎片等情况</p></li><li><p>slowlog get N 查看最近几条执行较慢的命令</p></li><li><p>通过redis-cli –bigkeys 通过采样scan元素较多的key，不会一直阻塞redis执行</p></li><li><p>更多好玩的redis-cli命令可以查看此处</p><blockquote><p>monitor命令不建议生产环境使用</p></blockquote></li></ul><p>面对一款优秀开源产品，我们除了要了解它的基本使用，也要擅于运用才能更好发挥其作用，否则会有不必要的麻烦，甚至适得其反。当然如果能深入了解其内部运行机制，知其然并知其所以然，并基于此创造出更加优秀的开源产品，就更符合coder的hacker精神。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Redis 5.0已经发布，越来越多的新特性被加入，在工作中发现很多人只是了解一些Redis的基本使用，也并未完整的阅读过Redis的官方文档，对于一些命令不熟悉，不同场景下滥用不合理的数据结构，对一些新的特性似乎也不会去关注，本文总结了一些使用建议。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="缓存" scheme="http://ai.mak.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://ai.mak.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java12 新特性</title>
    <link href="http://ai.mak.cn/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://ai.mak.cn/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2022-11-14T04:17:04.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Java 12  发布了，一起来看一看特性。</p></blockquote><p><strong>1 Switch 表达式</strong></p><p>使用Java 12，switch不仅可以作为语句也可以作为表达式。 无论作为语句或者作为表达式，switch都可以使用传统&#x2F;简化的作用域和控制流行为。 这将有助于简化代码，并为在switch中使用模式匹配铺平道路。</p><p>Java开发人员正在增强Java编程语言，以使用模式匹配来解决当前switch语句的几个问题。 这包括：switch块的默认控制流行为，switch块默认作用域（被视为单个作用域的块）和switch仅作为语句。</p><p>在Java 11中，switch语句追随C和C++，默认情况下使用fall-through语义。 虽然传统的控制流程在编写低级代码时很有用，但随着switch在更高级别的环境中采用，易出错会盖过其灵活性。</p><p>Java 11 </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMvNJrP0lcJZmQSmr7YySUnffXDnaRFKbCQAhHO7ib4r4y2ytMBc4S3If0ibas6vqzZOcBIeMx6dU5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Java 12</p><p><strong>2 默认CDS归档</strong></p><p>通过在64位平台上的默认类列表的帮助下生成CDS归档来改进JDK构建过程，从而有效地消除了运行java -Xshare：dump。 此功能的目标包括：1。）改进开箱即用的启动时间，以及2.）摆脱使用-Xshare：dump。</p><p><strong>3 Shenandoah GC</strong></p><p>Shenandoah是一种垃圾收集（GC）算法，旨在保证低延迟（10 - 500 ms的下限）。 它通过在运行Java工作线程的同时执行GC操作减少GC暂停时间。 使用Shenandoah，暂停时间不依赖于堆的大小。 这意味着无论堆的大小如何，暂停时间都是差不多的。</p><p>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p><p><strong>4 JMH 基准测试</strong></p><p>此功能为JDK源代码添加了一套微基准测试（大约100个），简化了现有微基准测试的运行和新基准测试的创建过程。 它基于Java Microbenchmark Harness（JMH）并支持JMH更新。</p><p>此功能使开发人员可以轻松运行当前的微基准测试并为JDK源代码添加新的微基准测试。 可以基于Java Microbenchmark Harness（JMH）轻松测试JDK性能。 它将支持JMH更新，并在套件中包含一组（约100个）基准测试。</p><p><strong>5 JVM 常量 API</strong> </p><p>JEP 334引入了一个API，用于建模关键类文件和运行时artifacts，例如常量池。 此API将包括ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc等类。此 API 对于操作类和方法的工具很有帮助。</p><p><strong>6 G1的可中断 mixed GC</strong></p><p>此功能通过将Mixed GC集拆分为强制部分和可选部分，使G1垃圾收集器更有效地中止垃圾收集过程。通过允许垃圾收集过程优先处理强制集，g1可以更多满足满足暂停时间目标。</p><p>G1是一个垃圾收集器，设计用于具有大量内存的多处理器机器。由于它提高了性能效率，g1垃圾收集器最终将取代cms垃圾收集器。</p><p>G1垃圾收集器的主要目标之一是满足用户设置的暂停时间。G1采用一个分析引擎来选择在收集期间要处理的工作量。此选择过程的结果是一组称为GC集的区域。一旦GC集建立并且GC已经开始，那么G1就无法停止。</p><p>如果G1发现GC集选择选择了错误的区域，它会将GC区域的拆分为两部分（强制部分和可选部分）来切换到处理Mix GC的增量模式。如果未达到暂停时间目标，则停止对可选部分的垃圾收集。</p><p><strong>7 G1归还不使用的内存</strong></p><p>此功能的主要目标是改进G1垃圾收集器，以便在不活动时将Java堆内存归还给操作系统。 为实现此目标，G1将在低应用程序活动期间定期生成或持续循环检查完整的Java堆使用情况。</p><p>这将立即归还未使用的部分Java堆内存给操作系统。 用户可以选择执行FULL GC以最大化返回的内存量。</p><p><strong>8 移除多余ARM64实现</strong></p><p>Java 12将只有一个ARM 64位实现（aarch64）。 目标是删除所有与arm64实现相关的代码，同时保留32位ARM端口和64位aarch64实现。</p><p>这将把重点转移到单个64位ARM实现，并消除维护两个实现所需的重复工作。 当前的JDK 11实现中有两个64位ARM实现。</p><p><strong>原文地址：</strong></p><p><a href="https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/">https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; Java 12  发布了，一起来看一看特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1 Switch 表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Java 12，switch不仅可以作为语句也可以作为表达式。 无论作为语句或者</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章读懂“中台”架构</title>
    <link href="http://ai.mak.cn/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/"/>
    <id>http://ai.mak.cn/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2022-11-01T05:49:30.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一篇文章读懂“中台”架构"><a href="#一篇文章读懂“中台”架构" class="headerlink" title="一篇文章读懂“中台”架构"></a>一篇文章读懂“中台”架构</h1><p>转载来自微信公众号：  archstudy 架构思轩</p><p><strong>中台是什么</strong></p><p>企业互联网中台架构，简称<strong>中台</strong>，起源于阿里巴巴，不同的人对中台有不同解读。</p><p>我认为，中台可定义为：中台是一套结合互联网技术和行业特性，将企业核心能力以共享服务中心进行沉淀，形成“大中台、小前台“的组织和业务机制，供企业快速低成本的进行业务创新的企业架构。</p><p>中台的目的是 **“提供企业快速低成本创新的能力”，核心是 <strong>“构建企业共享服务中心”</strong>，过程是构建 <strong>“大中台、小前台“</strong> 组织和业务机制。</p><p>其中，前台作为一线业务，更敏捷更快速适应市场，中台将整个企业的数字运营能力、产品技术能力，对各业务前台形成强力支撑。</p><p><strong>阿里巴巴的中台架构</strong></p><p><img src="http://p9.itc.cn/images03/20200526/93023c40ab584738931eae938d9cdca5.jpeg" alt="图片"></p><p><em>阿里中台架构</em> </p><p><em>from 钟华编著《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》图</em></p><p>上图可以看出，阿里巴巴有超过数十个业务单元（如淘宝、天猫、聚划算、菜鸟）均不是独立构建在阿里云之上，在后端阿里云技术平台和前端业务之间有“共享业务事业部“，将业务中公共、通用的业务沉淀下来，包括用户中心、商品中心、交易中心、评价中心等十几个共享单元，是“厚平台的真正实现“。</p><p>而后端的阿里云提供资源和中间件云服务能力做载体。同时，使用集团近十年的双11、双12的高可靠、可稳定的运维保障能力，对整个系统进行支撑。</p><p>中台的使命是从下到上逐步完善阿里的整个体系，从阿里云、数据、中间件、算法，到上面支撑的各种业务解决方案，构建阿里自己核心的能力。</p><p><strong>中台在阿里巴巴的诞生</strong></p><p>在淘宝初期，主要面向C2C的电商领域，整个系统都是围绕一套“烟囱式”的淘宝技术框架进行。随着业务的不断扩张，集团成立出天猫事业部主抓B2C电商领域，又形成了一套烟囱式发展。</p><p>这种烟囱式的架构体系带来了诸多不足，比如成本的重复投入和维护、数据之间打通复用的难度、几年之后推到重建的风险。</p><p>为了解决这些问题，集团开始构建<strong>共享服务中心体系</strong>，来沉淀和服用业务能力，但是由于没有过多的业务话语权，共享服务体系的建设一开始并不顺利。 </p><p>之后，随着“聚划算”团购项目的启动，各种系统的流量都需要通过聚划算，这时，共享服务中心得以大展手脚，逐步将集团核心的业务能力构建成<strong>用户中心、商品中心、交易中心、评价中心、店铺中心</strong>等等数十个共享服务。</p><p>可以说整个阿里中台的革命也是共享服务中心的革命，各共享服务中心聚焦核心业务单元能力的构建，协助目前集团上百个前台业务的快速创新。</p><p>这里需要强调一下，中台是<strong>去中心化</strong>的，而共享服务中心正是一个个解耦的服务模块，这里的中心有一些特点：</p><ol><li>共享中心以共享<strong>业务+数据</strong>能力为主，比如领域服务层+API接口</li></ol><ul><li>共享中心的目的是沉淀传统行业业务和数据能力，并<strong>开放出去</strong></li><li>共享中心是中台的重要部分，目的是实现前端应用和后台的<strong>彻底解耦</strong></li></ul><p><strong>中台的好处</strong></p><p>没有中台前，企业的<strong>痛点</strong>体现在：</p><p><strong>复杂</strong>：系统庞大、逻辑复杂 （学习理解成本高，每人了解系统全貌，最懂的是程序员，需要翻代码才能知道具体逻辑）</p><p><strong>重复</strong>：系统差异性大、标准不一 （同样的需求在不同系统重复造轮子，对于一个通用功能，没人说清楚是否有，或知道但现有的够不够支持）</p><p><strong>沟通成本高</strong>：团队多，跨部门的沟通多（无用的拉通对齐会太多，沟通需求和信息获取成本极高）</p><p>中台就是为了让企业进行核心能力的<strong>沉淀</strong>，更给予我们快速创新的<strong>机会</strong>，具体包括：</p><p><strong>1、中台赋予业务快速创新和试错能力</strong></p><p>企业可以聚焦核心共享服务的建设，提高服务的重用。</p><p><strong>2、打造数字化运营能力</strong></p><p>中台有助于业务通过共享核心能力的沉淀，进行数字化运营。通过对中心核心数据的分析，更加精确地对业务进行调整和优化，全方位动态调整资源利用。</p><p><strong>3、改变组织阵型带来组织效能提升</strong></p><p>中台的变化也是组织阵型的变化。一方面，对于公司，中台侧重的是跨部门跨团队的深入合作。另一方面，对于个人，中台推荐的是类微服务的小而精团队，员工从事多种岗位，对全局和整体有更深入的锻炼。</p><p><strong>中台是平台化的自然演进</strong></p><p><img src="https://img1.baidu.com/it/u=1775402040,4133540010&fm=253&fmt=auto&app=138&f=PNG?w=674&h=333" alt="图片"></p><p>这里比较一下中心化、平台化、中台化。</p><p>中心化类似烟囱式架构，一个中心解决整个技术堆栈。</p><p>平台的目标为高内聚、低耦合、职责边界清晰，是单一团队、部门、系统的效率提升。</p><p>中台的目标是提升效能、数据化运营、更好支持业务发展和创新，是<strong>多领域、多BU、多系统的负责协同</strong>。</p><p>中台是平台的自然演进：这种演进带来“去中心化“的组织模式，突出对<strong>能力复用、协调控制的能力</strong>，以及业务创新的差异化构建能力。</p><p><strong>企业中台化转型</strong></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2F80%2Fv2-60d6ae21eb72c390ea7fa74a3b8f955b_1440w.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669873642&t=90c9dc8d95deb7e65fd891c37b80d3d0" alt="图片"></p><p>传统企业应用中台战略进行互联网化转型，主要需要关注以下6点。</p><p><strong>1、尽可能拆分，共享中心建设</strong></p><p>企业应该尽可能地拆分自己的应用，进行共享服务中心的建设，将核心的业务能力复用和沉淀。</p><p>共享中心的拆分要注意层次。</p><p>首先，可以从<strong>基础主数据和核心共享数据</strong>出发去定义中心，例如客户中心，订单中心，所有功能目的都是围绕客户或订单数据本身。</p><p>第二，可以围绕<strong>核心业务展开进行中心的定义</strong>，比如交易中心，人事共享服务中心，这种中心的强调核心业务能力，而不是针对某特定数据。</p><p>另外，可以以<strong>核心业务规则和逻辑构建的中心</strong>，比如包调度中心，规则中心等，这些都是实现核心业务逻辑处理为主的中心。</p><p><strong>2、去中心化，线性扩展</strong></p><p>企业需要采用去中心化架构，<strong>没有核心流量汇入点，服务中心尽量无状态</strong>，便于水平扩展。这样平均分担压力，负载均衡，对单个中心带来的负载更小，故障影响的范围也更小。</p><p>同时，也要求我们的数据服务也要进行<strong>分布式改造</strong>，使用<strong>分库分表，读写分离</strong>的思想，便于根据实际情况扩索容。</p><p><strong>3、数据化运营</strong></p><p>当然，去中心化也会面对系统运维和管理成本上升的问题。企业需要对自身的运维运营过程进行积累和沉淀，整理出数据化、<strong>自动化运维</strong>的经验，同时增强<strong>监控告警、限流降级、性能分析诊断</strong>等方面的能力，精准定位目前系统中存在的问题，并提出相应的改善方案。</p><p>另外，数据是企业最宝贵的财富，企业可以通过各中心的数据，今而挖掘新的业务机会，快速创新。</p><p><strong>4、异步化，最终一致</strong></p><p>在大量的实践中，大部分业务流程不需要强一致性，而使用最终一致来平衡。</p><p>我们需要使用<strong>异步解耦</strong>，如使用<strong>消息队列</strong>来完成业务逻辑，缩短相应周期。</p><p>以双11为例，一个交易需要200多个系统，假设每个系统需要10毫秒，再加上一些网络和前端延迟，总时长将超过3秒。而在互联网领域，3秒的RT会造成大量的用户流失。使用异步化，缩短服务主链路可以大大缓解这一问题。</p><p><strong>5、尽可能自动化</strong></p><p>企业进行中台改造，会面临很多机器来负载业务，要求企业尽可能提高自动化能力，比如<strong>自动部署、自动弹性扩容、自动升降级、自动限流降级</strong>，降低运营成本，也提高系统的稳定性和业务连续性。比如消息队列中以自动化的形式实现系统的秒级切换和快速恢复，对应用几乎没有影响。</p><p><strong>6、尽可能使用成熟组件</strong></p><p>中台的建设要求企业将重心放在服务中心上，对于底层组件，尤其是中间件层面，尽量使用成熟的组件来提高系统稳定性和性能。</p><p>目前，阿里巴巴中间件已经将多年经双十一购物狂欢节的严苛考验的技术沉淀，以阿里云标准云服务的方式输出给外部客户，其中包括多款阿里云中间件产品（比如EDAS&#x2F;MQ&#x2F;DRDS&#x2F;ARMS&#x2F;PTS），并提供全方位的互联网化转型的架构咨询、技术支持、交付培训等服务。并不仅仅是技术红利的分享，更重要的是整个阿里中台战略思想的传播。</p><p><strong>Takeaways</strong></p><ul><li><p>中台可以帮助传统企业将企业核心能力<strong>以共享服务形式沉淀，供企业快速低成本的进行业务创新</strong>的企业架构。</p></li><li><p><strong>中台是平台化的自然演进</strong>，是一种体系&#x2F;生态&#x2F;方法论。</p></li><li><p>中台的目的是“<strong>提供企业快速低成本创新的能力</strong>”。中台的核心是“<strong>构建企业共享服务中心</strong>”。</p></li><li><p>企业中台化转型中，需要关注<strong>拆分&#x2F;去中心化&#x2F;数字化&#x2F;异步化&#x2F;自动化&#x2F;成熟组件</strong>等方面。</p></li></ul><p><strong>Reference</strong></p><p>《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》— 钟华</p><p><a href="http://www.open-open.com/news/view/1f1f312">http://www.open-open.com/news/view/1f1f312</a></p><p><a href="http://www.sohu.com/a/166699898_413980">http://www.sohu.com/a/166699898_413980</a></p><p>作者简介</p><p><strong>王思轩</strong>，计算机专业博士，阿里巴巴中间件技术架构师。</p><p>获得加拿大卡尔顿大学计算机博士学位，并获得法国波尔多大学和哈尔滨工业大学双硕士，哈尔滨工业大学本科，发表过10余篇国际学术论文。多年从事于云计算和系统架构设计工作，曾就职于华为，Qlik，Honeywell。现就职于阿里，花名宇升，负责并参与Aliware云产品重点项目的设计和交付，以及企业互联网架构的咨询培训工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一篇文章读懂“中台”架构&quot;&gt;&lt;a href=&quot;#一篇文章读懂“中台”架构&quot; class=&quot;headerlink&quot; title=&quot;一篇文章读懂“中台”架构&quot;&gt;&lt;/a&gt;一篇文章读懂“中台”架构&lt;/h1&gt;&lt;p&gt;转载来自微信公众号：  archstudy 架构思轩&lt;/p&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>技术团队的4个难题</title>
    <link href="http://ai.mak.cn/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/"/>
    <id>http://ai.mak.cn/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2022-10-27T05:51:10.493Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于阿里巴巴中间件</p><p>从单个应用到多个应用，从百千级别的访问流量到十万、百万级别，从两三个人的创业技术团队到上千人的技术团队矩阵，这些过程中，技术团队都避不开了以下 4 个问题：</p><ul><li><p>如何预测业务峰值时的容量</p></li><li><p>如何提升业务的稳定性</p></li><li><p>如何提高业务的监控能力</p></li><li><p>如何提高开发效率</p></li></ul><p><strong>如何预测业务峰值时的容量</strong></p><hr><p>早期的做法是在开发测试环境进行压测，来评估线上容量，但线下环境的机器规模，和线上差距很大，很难通过线下推导线上。根据经验，将采购的机器加入不同的应用里面，这时候就会遇到一个问题： <strong>最大业务峰值容量是多少？</strong></p><p>这个问题，其实挺难回答的。这个应用多加几台，那个应用少加几台，整体的业务峰值承受能力就会不一样，加减的规则很难通过人的经验来确定，最多只能作为一些辅助判断。另外，核心交易链路的梳理，也是一个体力活，如果依赖人为处理，有可能会漏掉一些看起来不那么重要的”分支”，这是整个容量不确定的地方，可变的因子很多。</p><p>比较有效的方式， <strong>是在生产系统部署全链路压测</strong>，来验证各个生产环节是否能经受住各类流量的访问，让真实的流量来访问生产环境，实现全方位的真实业务场景模拟，确保各个环节的性能、容量和稳定性均可做到万无一失。</p><p><strong>如何提升业务的稳定性</strong></p><hr><p>日常的各种运营活动，都有可能带来巨大的流量高峰，除了通过引入全链路压测来验证各个生产环节是否能经受住各类流量的访问， <strong>构建系统的高可用保障能力也很关键</strong>，涉及多个组件或模块，例如<strong>软负载和配置中心、服务接入和调度编排、消息接收和发送、容器和调度、限流和降级</strong> 等。</p><p>运营一次活动，最大的流量峰值是可以预测的，这就是服务的最大接待能力，比如50万笔的交易创建峰值，那超过的怎么办？这时候，采用限流的方式，被限流的客户在某一段时间内无法进行购物，一旦系统恢复服务能力，就可以继续服务被限流的客户，从而避免因流量超过上限，而影响整个平台的客户。</p><p><strong>如何提高业务的监控能力</strong></p><hr><p>分布式应用系统在协作性，扩展性和一定的容错性方面，体现出了优势，但是<strong>在监控、运维和诊断层面，面临相当大的挑战。</strong></p><p>早期，架构师可以画出整个应用系统的交互架构图，随着业务的发展，当拥有大量的应用、微服务和容器，即便整理了一幅交互架构关系图，也会因为应用系统的变更，新需求的实现，整个应用系统的交互又会发生变化，这种变化无处不在，每天都在发生。因此，随着业务量的增加，需要覆盖面广且深的<strong>全链路跟踪监控系统</strong> ，来诊断调用链的问题。</p><p>越是复杂的业务形态，定位的难度越大，就越需要全方位、360度无死角的监控，因此，建立一个平台化、跨领域和立体化的监控，能极大的缩短业务遇到问题时的恢复时间。</p><p><strong>如何提高开发效率</strong></p><hr><p>开发效率是一个很广泛的话题。不同的开发岗位，不同的使用场景，会有不一样的开发效率工具。这里，我们介绍几款后端工程师经常会用到的效率工具。</p><p>云端部署效率工具：</p><p>Cloud Toolkit 是一款 IDE插件，可以帮助开发者更高效地开发、测试、诊断并部署应用。借助这个工具，开发者能够方便地将本地应用一键部署到任意机器，或 ECS、EDAS、Kubernetes，并支持高效执行终端命令和 SQL 等。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485392&idx=3&sn=113a67be48740443b9a29d172da48b12&chksm=fdeb35b0ca9cbca6f48b61c8c333683b6acbaac4f1e8101ff54546d9256347bff629e0e513c5&scene=21#wechat_redirect">点此了解详情。</a></p><p>MacOS 搜索利器：</p><p>MacOS 自带的聚焦搜索（Spotlight），可以将文稿、邮件、应用等整合在一起，通过关键词匹配来进行搜索。Alfred 可以看作是Spotlight的增强版，是计算机依赖者的效率神器，支持添加自定义网络搜索引擎，指定规则精准定位本地文件，以及在命令框内使用计算器、词典等实用工具。</p><p>画图效率工具：</p><p>系统架构图是为了抽象的表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。通过架构图，可以让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体，所谓一图胜千言。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485842&idx=2&sn=39bf21a40e810d8993aaeb6054f4cada&chksm=fdeb3bf2ca9cb2e4e40442c80fc833372686f373c3c0e23f5b3cf438d00ebd6586bd4772f36c&scene=21#wechat_redirect">点此了解详情。</a></p><p>JSON 浏览效率插件</p><p>对于 JSON 的数据，如果不编排，格式查看起来会很费劲。JSON-handle 是一款对 JSON 格式的内容进行浏览和编辑，以树形图样式展现 JSON 文档的插件，支持实时编辑。</p><p>Java 代码规约扫描效率插件</p><p>这是一款 Java 代码规约扫描工具，旨在以工具的手段进行代码规约的落地，项目包含三部分：PMD规则实现、IntelliJ IDEA 插件、Eclipse 插件，帮助开发人员在工程研发的多个阶段进行代码规约检查， 降低故障率、提升编码效率和质量。<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDU0MTE0OA==&mid=2661009238&idx=1&sn=3813042bae641ce8cac04ff57bf30ee2&chksm=80feaf65b789267361c560cb2b134e325343a927925b985642cba95210fe9222aaf2f006c90b&token=2107695414&lang=zh_CN&scene=21#wechat_redirect">点此了解详情。</a></p><p>当然，除了这些现成的效率工具，提升整个技术团队的开发效率，需要单独开发或改造一些系统，例如团队协作平台、服务化改造等，当你以实习生的身份加入公司后，若有机会参与到这些提升开发效率的项目过程中。由此形成的效率意识，将会影响到你今后的工作习惯和理念。</p><blockquote><p>本文部分内容来源于阿里巴巴中间件资深产品专家丹臣的内部分享《阿里巴巴中间件上云实践》。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下文章来源于阿里巴巴中间件&lt;/p&gt;
&lt;p&gt;从单个应用到多个应用，从百千级别的访问流量到十万、百万级别，从两三个人的创业技术团队到上千人的技术团队矩阵，这些过程中，技术团队都避不开了以下 4 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何预测业务峰值时的容量&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="开发效率" scheme="http://ai.mak.cn/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>哪怕1%的提升，效益都非常大 | 当传统拥抱互联网</title>
    <link href="http://ai.mak.cn/2019/03/17/%E6%9D%82%E8%AE%B0/%E5%BD%93%E4%BC%A0%E7%BB%9F%E6%8B%A5%E6%8A%B1%E4%BA%92%E8%81%94%E7%BD%91/"/>
    <id>http://ai.mak.cn/2019/03/17/%E6%9D%82%E8%AE%B0/%E5%BD%93%E4%BC%A0%E7%BB%9F%E6%8B%A5%E6%8A%B1%E4%BA%92%E8%81%94%E7%BD%91/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2022-11-13T09:29:08.627Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自笔记侠，一直关注笔记侠的文章，分享</p><p><a href="https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrpg">https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrpg</a></p><p>故事硬核《独家深访：腾讯变革150天全记录》中有这样一个细节。2016年腾讯云峰会，马化腾出现在会场，给云站台。</p><p>他的鲜明风格之一就是不给腾讯任何产品站台——一个例行邀请，“竟然来了”，汤道生回忆，云团队像过节一样开心，“关键他不仅仅是给云的团队看，他出来是给整个行业看”。</p><p>最终，腾讯在2018年“香港总办会议”的共识中达成了最重要的几项：</p><p>一、进行组织架构调整，成立云与智慧产业事业群（CSIG），主攻产业互联网；</p><p>二、从TO C 到 TO B，继续巩固消费互联网，重兵投入产业互联网。</p><p>国家在发生深刻转型，全面的数字化、智能化时代已经来临，每个产业都在拥抱云、大数据与人工智能，“跟以前拥抱电一样”。</p><p>早在2013年底，马化腾就提出互联网+的概念。他当时去国家发改委演讲，向主任、各司局局长、处长将近600人，讲用互联网去“+”传统的各行各业。两场重要演讲之后，这个概念流行开来。</p><p>2015年两会前，马化腾受邀向政府智库提交了“互联网+”的意见。这个概念被写入了政府工作报告。</p><p>那正是“互联网+”如日中天的时候，“互联网+打车”颠覆出行，“互联网外卖”改写餐饮，“互联网支付”影响金融……一时间互联网人都在说赋能、颠覆，仿佛新的大革命已然来临，正大刀阔斧重组重造。</p><p>但互联网当主角，传统行业不服气，说“我+你还差不多” 。他们的忧虑在于，一旦开门欢迎互联网，下场会不会是把自个儿颠覆了。</p><p>行至深水区，“+”的对象变成了那些有着高壁垒的行业——教育、医疗、能源、制造业……腾讯2B前方团队突然发现“+”不了了，许多产业的核心技术，互联网公司不懂，人家也不可能把自己的命脉交到别人手上。</p><p>僵局之中，马化腾捕捉到一个奇特的变化信号。</p><p>2016年两会期间，他去拜访链家CEO左晖，了解到了全新的故事样本：一个线下传统中介机构不仅没有被互联网企业入侵、颠覆，还倒攻线上，成功逆袭，“最终成了老大”。</p><p><strong>一、拥抱互联网，如火如荼</strong></p><p>王兴在2016年就新美大公司上半年工作进行了一次内部讲话，他说：“往后看，‘互联网＋’要做的是各个行业从上游到下游的产业互联网化。</p><p>不是仅仅停留在最末端做营销、做交易那一小段，而是真正能够用互联网、用IT全面提升整个行业的效率…</p><p>‘互联网＋’根本上还是要靠创新服务于各行各业，靠互联网、靠IT技术为各行各业的各个环节提升体验、提高效率、降低成本。”</p><p>正如王兴所言：“从最宏大的角度来讲，整个中国经济也进入了‘下半场’。党和政府讲‘新常态’差不多要两年了，从去年年底到现在，也在反复讲‘供给侧结构性改革’。</p><p>如果你去细看这些提法背后的论述，你就能看到这些论述并不是中央领导的‘拍脑袋’和‘心血来潮’，而是中国经济发展到了这个阶段，确实是需要转变增长模式。</p><p>过去那种粗放的高速增长已经一去不复返了，不能再简单追求GDP的数字，中国经济也是进入了‘下半场’的状态。”</p><p>▲ 长按图片保存可分享至朋友圈</p><p>投资了新美大、优步、Airbnb等的宽带资本，也在2016年就已经提出有一个更广阔的市场叫“互联网+”（“互联网+”正是马化腾过去重点在公开场合提及的），也就是“产业互联网”。各种各样的企业，都得拥抱互联网，不拥抱互联网，就会面临着各种问题。</p><p>最先和互联网碰撞的一批是零售行业。</p><p>1.食</p><p>2017年末，2018年初，随着电商红利见底，阿里、京东等线上巨头开始大举进军线下市场，纷纷开设实体店。</p><p>如此一来，零售企业的生存环境便遭到进一步挤压。为求生存发展，零售企业开启转型之路，纷纷推出智慧门店，如沃尔玛的惠选超市、家乐福的Le Marche、优衣库的数字体验馆、苏宁的苏宁极物……</p><p>不同于传统零售门店，这些智慧门店引入了各种“黑科技”，如用自助收银机、“扫码购”等减少排队结账的时间，利用VR技术提供虚拟试装、试衣等。</p><p>永辉超市收到了腾讯集结全公司能力定制的智慧解决方案包——以选址为例，不再凭经验，而是在腾讯云预测销量前提下科学布局。市场占有率前十的超市品牌5家变成了腾讯的盟友。</p><p>永辉超市的互联网升级做得相对较快，其中一个原因是在传统行业基础上，创始人张轩宁非常重视人，重视年轻的高精尖团队，并从互联网挖过去人，发展非常快。</p><p>《第三次零售革命》作者、盛景网联合伙人颜艳春研究了7-11的损益表，发现7-11日本公司8000名员工创造了接近100亿人民币的净利润，人均创造利润为120万元，人效比肩世界上最赚钱的电商平台公司阿里巴巴。</p><p>这背后，是一个快消品行业的产业共同体和命运共同体，90%的参与方，无论上游、中游还是下游都获得了3-5倍的成长。</p><p>之前，在很多人的眼里，7-11是一个传统的连锁便利店，实际上，对7-11的这个认知是错误的。</p><p>它的模型：7-11总部着手把在日本每一个商圈里头部、碎片化的需求连接起来，团结进来。</p><p>就像三峡大坝一样，把需求端2万家夫妻老婆店团结起来，通过产业路由器，把供给端的178个工厂，还有140个物流中心连接起来，但这都不是它自己的资产，全部是这些头牌供给。</p><p>它根本就不是一家传统商业模式的零售公司，7-11将自己打造成为产业路由器平台，将这些小店与这些物流中心和所有工厂实时连接起来。</p><p>将自己唯一一个中介去中介化，4个不赚（不赚差价，不赚通道费，不赚佣金，不赚广告费）。</p><p>通过共享采购、共享配送、共享制造、共享研发、共享库存，共享供应链，为小店、小工厂提供了三大赋能（从商品赋能、经营赋能到基础设施赋能），成就了他们，每家的投资都得到了很大的回报。</p><p>7-11创造了一种新的利他经济模型，把实体经济和电商经济所有的商业逻辑彻底摧毁。</p><p>其实不只是智慧零售，各行各业的盟友越来越多。</p><p>2.衣</p><p>2018年3月30日，优衣库全新独栋概念店将在深圳万象天地正式开业。</p><p>优衣库在这家门店首次推出融合线上线下、打通实体与虚拟的“数字体验馆”，在店内的货架侧面和四方立柱的单面墙上安装了两款智能科技。</p><p>四方立柱上安装的是一款智能语音集成设备“智能小U”：顾客站在智能小U面前，设备自动完成对顾客的五官识别。</p><p>顾客可触摸屏幕商品清单，点击自己喜欢的服饰，然后进入4D虚拟试穿画面。</p><p>货架侧面的电子大屏则主要突出广告功能，只要顾客打开手机QQ的扫一扫功能，对着大屏上的静态海报扫描一遍，手机屏幕立即出现海报对应的TVC广告。</p><p>据悉，3月30日起，数字体验馆将在优衣库全国近600家门店陆续上市。</p><p>3.住</p><p>我们从衣食走到住房。</p><p>有人把近两年疯狂扩张的链家称为现象级公司，这家原本盘踞在北京的房地产中介公司在2015年进行了如火如荼的并购，把业务扩展到了全国。</p><p>链家长期以来就是一家跨界企业，从最初的房地产网站起家，到后来转向线下，再到现在的互联网化，链家既不在互联网圈，也不完全是传统意义上的地产中介公司。</p><p>之前，链家的高管们被分为势均力敌的两队，一队负责用互联网思维来干掉链家(简称“互联网派”)，一队作为传统中介琢磨如何应对(简称“传统派”)。这是左晖一直拷问管理层的一个问题。　</p><p>“当时思路没有现在这么清晰。”链家地产副总裁林倩回忆道。</p><p>管理层们脑洞大开，在讨论互联网到底能在多大程度上取代传统中介时，“互联网派”几乎取得了压倒性的胜利。</p><p>事实上，这直接影响了链家地产之后在线上的布局。从彼时起，每年投在链家在线上的资金都在亿元左右。</p><p>多年布局下来，链家在线促成的二手房买卖成交占到其整体成交量的30%左右，这一数字已经高出链家在其它互联网公司购买端口来促成成交的比例。</p><p>而在链家董事长左晖心目中，链家一直是一个由数据驱动的房地产平台。</p><p>他称自己2013年发微博吹牛说链家已经有100TB的数据。但两年时间后，数据库的规模已经增至1000TB，并且还在不断增长。</p><p>在二手房领域，不仅仅是信息分散，且没有被电子化，定义不够标准和统一。</p><p>贝壳找房和链家网CEO彭永东举例说，北京有700多万套二手房，有10万种户型。</p><p>每套房子的户型图，长、宽、高的尺寸，一个小区到底有多少这样的户型，同样户型能卖多少钱，不同用户定价是多少，都要被整理到数据库中去，以供决策参考。</p><p><strong>二、干不倒的实体店</strong></p><p>开篇，我们就讲到了零售行业。零售行业拥抱互联网的速度更快、也更容易。</p><p>2015年初，盒马鲜生的创始人侯毅，用一个下午的时间改变了阿里对线下店的认知。</p><p>过去，阿里认为电商遇上实体店，就像端机关枪的遇上了冷兵器，简直所向无敌。</p><p>但是，市场是在不断变化的，那时阿里高管第一次意识到，实体店是不可取代的。正因如此，阿里悄悄的布下了一个局，开始正式涉足线下经济。</p><p>两年前，知道盒马鲜生隶属阿里公司的人寥寥无几。</p><p>当这个信息被众人周知的时候，很多人感慨，零售市场到处都是京东和阿里的身影，作为一个零售行业的人，除非加入京东或者阿里，否则没有出路了。</p><p>颜艳春认为，未来相当长的一段时间里，70%的生意仍然是在线下场景完成的。</p><p>▲ 长按图片保存可分享至朋友圈</p><p>米兰有一家超市叫Eataly，在超市里可以坐下来休息、听音乐，甚至点两份牛排，十分受欢迎。</p><p>占地6500平米，一年可以营收4000万欧元。他们在美国纽约的分店，据说一年可以营收5000万美金。</p><p>这家店为什么可以取得成功呢？</p><p>因为互联网没有办法颠覆人性，线下的体验、人类情感的连接和宣泄是美妙的，不可取代的场景。</p><p>所以颜艳春大胆预言：<strong>得实体店者得天下，得头牌实体店，得天下第一</strong>。</p><p>再拿孩子王（”孩子王”是五星控股集团旗下零售事业，总部位于江苏南京。专业从事孕婴童商品一站式购物及提供全方位增值服务）为例。</p><p>孩子王在妈妈圈里拥有200家店、2000万用户，平均每家店拥有10万用户，每一个店每年举办100场线下活动直接连接起来的。将低频的交易场景转变成高频的约会场景，这个模式获得了巨大的成功。</p><p>聚焦到一个领域的实体店做得尤其漂亮。</p><p>包括Costco、Airbnb、7-11在内的公司，都只关注一个领域，亚马逊只卖最畅销的1000本书。</p><p>盒马鲜生只做吃这个品类，并将其发挥到极致，承诺不卖隔夜肉，只卖当天的肉和菜。光上海的10家店铺就拥有200万用户，店铺里面热闹的氛围是很棒的高频场景。</p><p>这些店都有一个共同的特征，它们不是传统的实体店，而是经过互联网加工过的实体店。</p><p>在实体店这个高度碎片化的市场里，即便投资100家公司，也不一定能够控制10%的市场份额。</p><p>这对于创业者来说，是一种机会，不是大家一起集中开喜茶，而是应该去思考如何去团结存量，如何用互联网(数字化)手段，让实体店过得更滋润。</p><p><strong>三、哪怕1%的收益，效益都非常大</strong></p><p>许多大型企业在使用互联网的过程当中迭代速度很快，因为互联网化过程带给它们很多有用的信息数据，让企业经营者能够更深层地理解自己所处的行业，这是互联网带来很重要的变化。</p><p>BAT之后诞生的新型企业，并不依赖简单的商业模式，而是学会驾驭了一种新型工具，对于人工智能更是如此。人工智能出现，会有一批更加新型的企业崛起，BAT很难在商业模式上跟它们直面竞争。</p><p>给大家举几个例子。</p><p>心上，现在是全国最大的二手奢侈品交易平台。最开始的业务全部是线下进行的，进行—、二手奢侈品的洗涤和养护，有4家直营店，40家加盟店。</p><p>在2014年时，创始人董博文决定做线上转型，这个过程势必有很大的困难。她一开始不清楚互联网商业逻辑，于是开始招兵买马一点一点构建互联网团队。</p><p>使用互联网工具之后，她发现很多客户是可以量化的，原来的用户定位和商品定位不够准确。</p><p>转型初期，她认为线上互联网奢侈品的交易平台应该是高端奢侈品，客单价是5000块钱左右，后来通过调整数据定位客户类型后发现，价格越低成交量越大，1750元是最优点。</p><p>二手奢侈品交易平台面对的是小康人群或者是中产人群，在消费过程中的认知应该是：我需要刚需品，而我不需要为了这东西付很多钱。所以她在数据调整过程当中理解到之前的用户定位是错误的。</p><p>同样的，她在供应链里也发现了一些问题。比如公司买的洗涤养护液和面辅料，这些东西可能是通过A公司去买，物流过程很复杂，账期很长，价格很高。</p><p>搭起整个互联网控制结构以后，她发现进货环节、产品特性、用户类型存在问题，然后开始不断地进行迭代。</p><p>这个过程中能非常明显地感觉到她在驾驭工具，最开始使用互联网工具后，她认为只是搭建了一个网站而已，后来这个工具给她带来了大量的数据和参考依据，她也越来越了解自己的商业模式。</p><p>任何一个公司都是倾向于产业升级和企业升级，把企业原来的那套理论体系逐渐的总结成新的规律去推动，把公司做得越来越规范的过程。</p><p>这是一个从经验走向规范化、走向数据化、走向结构化的过程，互联网只是其中一个推动的工具，只是使某一些企业在从信息化走向数据结构化的过程中，让它的数据变得更加标准，所以才能更深刻地理解自己的商业模式过程。</p><p>比如像农业和工业企业也能受到互联网影响，是因为原来他们的管理都是依靠于人进行管理的，依靠于自己的经验进行管理的。</p><p>而突然有了互联网之后，多出了一种数据化、量化的工具，使得整个行业更加标准化。</p><p>比如农业公司甲加由，一个在河南的农业公司，它很快从工业化衍生出了金融属性化，原因是它非常注重量化管理，他们对所有农户的工作状态用信用评级、用数据化衡量，做到了很多村镇银行很难办到的一步。</p><p>通过量化管理，它能给农户进行评级，对接银行、金融产品，给农户发放贷款做保险、卖期货。</p><p><strong>传统行业拥抱互联网，哪怕有1%的提升，都会产生非常高的效益。不管是农业、电力、航空、铁路还是石油。</strong></p><p>中国宽带产业基金合伙人周耘认为，产业互联网产生的经济效益，会有几个方面：</p><p>① 工业升级：</p><p>生产设备和物联网相结合，不管是物联网，还是供应链、工单、流程再造，都跟提升效益相关；</p><p>② 服务升级：</p><p>比如想知道外出人员，去哪了？做什么？你无从了解，现在可以通过移动互联网，通过位置服务，通过跟客户交互，都能知道了，也能提高效率。</p><p>在当前的国家经济形势下，正好赶上下一个浪潮：产业互联网，2B企业越来越多，<strong>传统行业和互联网的相互结合，会孕育着更多的投资和机会。</strong></p><p><strong>四、用对姿势，很关键</strong></p><p>企业的成长其实跟人的进化是很像的，都是不断使用新工具的过程。</p><p>但在工具的使用过程中，一些公司并没有利用得恰如其分。</p><p>2016年，投资了特斯拉、推特、百度的德丰杰，其中国的德丰杰龙脉基金合伙人王岳华指出，消费互联网时代已是过去，产业互联网时代才是未来。</p><p>当时他就已经看到消费者互联网的渗透增长变慢，变为稳定。国内传统制造业很多产业比如陶瓷业、家装业，很多传统产业没有很好地应用互联网化。</p><p>我们来看这样一个故事，古代打仗都用冷兵器，近代打仗用热兵器，这两种兵器的更迭是在什么时候？</p><p>在19世纪美国南北战争中。在那个时候刚配备枪炮的军队根本不知道怎么用，于是两边军队各站成一排，两边的军官在短暂沟通后下令开打，两边就开始相互扫射，这是一个令人啼笑皆非的故事。</p><p>为什么会出现这种问题？</p><p>因为对于军官和士兵来讲，他们使用了新的工具，但是没有更新战术和方法。方法论、战术是非常重要的，当时的枪怎么用，大家都不知道，还是处于拿着枪互相肉搏的状态，这是典型的用工具和战术的更迭过程。</p><p>我们每天都需要接触大量的互联网公司，大多数公司都声称自己的产品是互联网化的，但其实它们并不是标准的互联网公司。</p><p><strong>他们虽然有了新的互联网工具，但却不知道如何使用。</strong></p><p>还有一种情况是，有些科技公司想赋能传统行业，却找不到正确的路径，拿金融客户举例。</p><p>当前，随着经济增速放缓，息差收窄，监管趋严，互联网金融科技企业全面跨界渗透，中小银行的生存环境日益严峻，转型求变已成必然之势。</p><p>行业实践证明，金融科技的运用可以帮助银行提升核心业务能力、业务效率、用户体验，降低风险与成本，是中小银行实现转型的必备能力。</p><p>除了一些大型银行和全国性股份制银行，一些小型的农商行们普遍存在资产规模小、业务区域受限、风险控制能力弱等短板。</p><p>因此，为这类客户服务的供应商也特别多，其中既有各种国际巨头IOE、MBB、四大……，它们把这里视为自己的利润主战场；也有N多本土化的服务商，想进来分一杯羹。</p><p>总之，蛇有蛇路，鼠有鼠道，八仙过海，各显神通。但其中，真正能做到，理解金融类客户业务本质的并不多。</p><p>传统产业的升级，有时需要自己内向成长，有时需要借助外力，当外力的操作姿势不对时，也需要传统产业和外力打成一片，两者真正融合到一起。</p><p>当然，也有一些行业可能真的不适合互联网，这也需要我们警惕。</p><p>很多人认为很多To B的行业可以做线上化，于是出现了找木网、找纱线、纺织、建材这些细分类目的网站，这其实并不算严格意义上的互联网企业。</p><p>比如一家建材公司想把所有的建材、石料板材都放到线上，创始人的网站构想也非常清楚，团队干劲也比较足，每年有几个亿的成交量，开始觉得做得不错。</p><p>最后到公司一看，发现公司的工作状态是什么？虽然有网站，但没有人运营维护，所有人都在打销售电话，这是完全依赖于人和客户进行沟通的一种商业模式，它不能算是一个互联网化的公司。</p><p>互联网化公司最开始的时候要能看到商品是标准的，而不依赖于人和客户沟通，这是很重要的一点。</p><p>再比一个纱线公司，前端的研发和后端的布局是很完善的，以为对于纱这一品类是可以互联网化的。因为这个行业可能是50个SKU（库存进出计量单位），然后把它们全部标准化放到线上，大家在线上进行交易。</p><p>结果到公司去看的时候，很让人震惊的是，纱线有12000到15000种SKU，每一年下雨的雨水不一样，纱线韧性弹性不一样，边纹不一样，口径粗细不一样，颜色不一样，每一种纱线SKU有50多种标签，出来之后有几万种SKU，买方就没有办法在网上选择。</p><p>所有的人买纱线都是要亲自根据手感来挑选——“这种纱线对我有效，以后不要麻烦看别的了，以后我只进货这一种”。它是高度依赖于线下体验的产品，这种产品非常难以互联网化。</p><p>在供应链中从生产过程、到仓储流转、到分销，有很多的企业，比如第二产业中建材类等行业，都是如此。</p><p>并不是所有的行业都可以互联网化，并不是所有的企业用同一种方式进行转型都是可以升级的，完全不是的。</p><p>很多行业没有办法进行互联网转型升级，只能拿它作为辅助性工具管理公司。</p><p>产业互联网的大潮下，行人急匆匆，审时度势很重要，不忘初心更要紧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章来自笔记侠，一直关注笔记侠的文章，分享&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrpg&quot;&gt;https://mp.weixin.qq.com/s/D4mg4iNNgeSc8jpWcNKrp</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>全面了解HTTP和HTTPS</title>
    <link href="http://ai.mak.cn/2019/03/02/%E7%BD%91%E7%BB%9C/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3HTTP%E5%92%8CHTTPS/"/>
    <id>http://ai.mak.cn/2019/03/02/%E7%BD%91%E7%BB%9C/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3HTTP%E5%92%8CHTTPS/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2022-11-13T13:51:48.770Z</updated>
    
    <content type="html"><![CDATA[<p>作者：左大人，链接：jianshu.com&#x2F;p&#x2F;27862635c077</p><p> <strong>前言</strong> </p><p>Http和Https属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。<br>在学习Http和Https的过程中，主要是参考了阮一峰老师的博客，讲的很全面，并且通俗易懂，有兴趣的同学可以去学习学习。</p><p><em><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">http://www.ruanyifeng.com/blog/2016/08/http.html</a></em></p><p>这篇文章主要是按照自己的思路来讲解对Http和Https的理解。文章将会从以下几个方面介绍。</p><p>目录树：</p><ul><li>一、网络层结构</li><li>二、Http协议</li><li>三、Tcp三次握手</li><li>四、Https协议&#x2F;SSL协议</li><li>五、SSL证书</li><li>六、RSA加密和DH加密</li><li>七、Http和Https对比</li></ul><p>从目录结构可以看出，每个标题展开来说都是一个很大的主题。但本文旨在让各位同学对Http和Https相关知识有一个全面的认知，不会太过深入探讨各个主题，有兴趣的同学可以进行针对性研究。</p><p> <strong>01 网络层结构</strong> </p><p>网络结构有两种主流的分层方式：OSI七层模型和TCP&#x2F;IP四层模型。</p><h3 id="OSI七层模型和TCP-x2F-IP四层模型"><a href="#OSI七层模型和TCP-x2F-IP四层模型" class="headerlink" title="OSI七层模型和TCP&#x2F;IP四层模型"></a><strong>OSI七层模型和TCP&#x2F;IP四层模型</strong></h3><p>OSI是指Open System Interconnect，意为开放式系统互联。</p><p>TCP&#x2F;IP是指传输控制协议&#x2F;网间协议，是目前世界上应用最广的协议。</p><table><thead><tr><th align="left">OSI层</th><th align="left">对应TCP&#x2F;IP层</th><th align="left">OSI各层功能</th><th align="left">网络协议</th><th align="left">设备</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left">应用层</td><td align="left">应用程序（电子邮件，文件服务）,用户接口</td><td align="left">HTTP，FTP，TFTP，NFS</td><td align="left">网关</td></tr><tr><td align="left">表示层</td><td align="left">应用层</td><td align="left">数据的表示，压缩和加密（数据格式化，代码转换，数据加密）</td><td align="left">TELNET，SNMP</td><td align="left">网关</td></tr><tr><td align="left">会话层</td><td align="left">应用层</td><td align="left">建立、管理和终止会话</td><td align="left">SMTP，DNS</td><td align="left">网关</td></tr><tr><td align="left">传输层</td><td align="left">传输层</td><td align="left">提供端到端可靠报文段传递和错误恢复</td><td align="left">TCP，UDP</td><td align="left">网关</td></tr><tr><td align="left">网络层</td><td align="left">网际互联层</td><td align="left">提供数据包从源到宿的传递和网际交互</td><td align="left">IP，ICMP，ARP，RARP，UUCP</td><td align="left">路由器</td></tr><tr><td align="left">链路层</td><td align="left">网络接口层</td><td align="left">将比特组装成帧和点到点传递</td><td align="left">FDDI，SLIP，PPP，PDN</td><td align="left">交换机</td></tr><tr><td align="left">物理层</td><td align="left">网络接口层</td><td align="left">传输比特流，以二进制数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802，IEEE802.2</td><td align="left">集线器，中继器</td></tr></tbody></table><h3 id="两种模型区别"><a href="#两种模型区别" class="headerlink" title="两种模型区别"></a><strong>两种模型区别</strong></h3><ol><li><p>OSI采用七层模型，TCP&#x2F;IP是四层模型</p></li><li><p>TCP&#x2F;IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。</p></li><li><p>在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP&#x2F;IP是基于协议建立的模型，不适用于非TCP&#x2F;IP的网络。</p></li><li><p>实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP&#x2F;IP已经成为国际标准。</p></li></ol><p> <strong>02 HTTP协议</strong> </p><p>Http是基于TCP&#x2F;IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。</p><h3 id="Http协议的发展历史"><a href="#Http协议的发展历史" class="headerlink" title="Http协议的发展历史"></a><strong>Http协议的发展历史</strong></h3><ol><li>1991年发布Http&#x2F;0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。</li><li>1996年发布Http&#x2F;1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致Http&#x2F;1.0新能很差。</li><li>1997发布Http&#x2F;1.1版本，完善了Http协议，直至20年后的今天仍是最流行的版本。<br>优点：a. 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。b. 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。c. 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。d. 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。e. 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。<br>缺点：TCP连接中的响应有顺序，服务器处理完一个回应才能处理下一个回应，如果某个回应特别慢，后面的请求就会排队等着（对头堵塞）。</li><li>2015年发布Http&#x2F;2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title="** **"></a>** **</h3><h3 id="Http请求和响应格式"><a href="#Http请求和响应格式" class="headerlink" title="Http请求和响应格式"></a><strong>Http请求和响应格式</strong></h3><p>Request格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /barite/account/stock/groups HTTP/1.1</span><br><span class="line">QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCA</span><br><span class="line">DEVICE-TYPE: ANDROID</span><br><span class="line">API-VERSION: 15</span><br><span class="line">Host: shitouji.bluestonehk.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">User-Agent: okhttp/3.10.0</span><br></pre></td></tr></table></figure><p>Response格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.3</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;</span><br></pre></td></tr></table></figure><p>说明一下请求头和响应头的部分字段：</p><ul><li>Host：指定服务器域名，可用来区分访问一个服务器上的不同服务</li><li>Connection：keep-alive表示要求服务器不要关闭TCP连接，close表示明确要求关闭连接，默认值是keep-alive</li><li>Accept-Encoding：说明自己可以接收的压缩方式</li><li>User-Agent：用户代理，是服务器能识别客户端的操作系统（Android、IOS、WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同操作。</li><li>Content-Type：服务器告诉客户端数据的格式，常见的值有text&#x2F;plain，image&#x2F;jpeg，image&#x2F;png，video&#x2F;mp4，application&#x2F;json，application&#x2F;zip。这些数据类型总称为MIME TYPE。</li><li>Content-Encoding：服务器数据压缩方式</li><li>Transfer-Encoding：chunked表示采用分块传输编码，有该字段则无需使用Content-Length字段。</li><li>Content-Length：声明数据的长度，请求和回应头部都可以使用该字段。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title="** **"></a>** **</h2><p>**<br>**</p><p><strong>03 Tcp三次握手</strong> </p><p>Http和Https协议请求时都会通过Tcp三次握手建立Tcp连接。</p><p><strong>那么，三次握手是指什么呢？</strong></p><p><img src="https://aimak.cn/blog_img/tcp_3.jpg" alt="img"></p><p><strong>那么，为什么一定要三次握手呢，一次可以吗？两次可以吗？</strong></p><p>带着这些问题，我们来分析一下为什么必须是三次握手。</p><ol><li>第一次握手，A向B发送信息后，B收到信息。B可确认A的发信能力和B的收信能力</li><li>第二次握手，B向A发消息，A收到消息。A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力</li><li>第三次握手，A向B发送消息，B接收到消息。B可确认A的收信能力和B的发信能力</li></ol><p>通过三次握手，A和B都能确认自己和对方的收发信能力，相当于建立了互相的信任，就可以开始通信了。</p><p>下面，我们介绍一下三次握手具体发送的内容，用一张图描述如下：</p><p><img src="https://aimak.cn/blog_img/tcp_3_1.jpg" alt="img"></p><p>首先，介绍一下几个概念：</p><ul><li>ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1</li><li>SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN&#x3D;1，其他情况都是0</li><li>FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN&#x3D;1，其他情况都是0，跟SYN类似</li><li>seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有</li><li>ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段</li></ul><p>知道了上面几个概念后，看一下三次握手的具体流程：</p><ol><li>第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。</li><li>第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack&#x3D;x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq&#x3D;y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。</li></ol><p>从图中可以看出，建立连接经历了三次握手，当数据传输完毕，需要断开连接，而断开连接经历了四次挥手：</p><ol><li>第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了</li><li>第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。</li><li>第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。</li></ol><p>下面是Tcp报文段首部格式图，对于理解Tcp协议很重要：</p><p><img src="https://aimak.cn/blog_img/tcp_3_baowen.jpg" alt="img"></p><p> <strong>04 Https协议&#x2F;SSL协议</strong> </p><p>Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL&#x2F;TLS），SSL是Https协议的安全基础。Https默认端口号为443。</p><p><strong>前面介绍了Http协议，各位同学能说出Http存在的风险吗？</strong></p><ol><li>窃听风险：Http采用明文传输数据，第三方可以获知通信内容</li><li>篡改风险：第三方可以修改通信内容</li><li>冒充风险：第三方可以冒充他人身份进行通信</li></ol><p>SSL&#x2F;TLS协议就是为了解决这些风险而设计，希望达到：</p><ol><li>所有信息加密传输，三方窃听通信内容</li><li>具有校验机制，内容一旦被篡改，通信双发立刻会发现</li><li>配备身份证书，防止身份被冒充</li></ol><p>下面主要介绍SSL&#x2F;TLS协议。</p><h3 id="SSL发展史（互联网加密通信）"><a href="#SSL发展史（互联网加密通信）" class="headerlink" title="SSL发展史（互联网加密通信）"></a><strong>SSL发展史（互联网加密通信）</strong></h3><ol><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL&#x2F;2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL&#x2F;3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS&#x2F;1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS&#x2F;1.1版本和TLS&#x2F;1.2版本</li></ol><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title="** **"></a>** **</h3><h3 id="SSL原理及运行过程"><a href="#SSL原理及运行过程" class="headerlink" title="SSL原理及运行过程"></a><strong>SSL原理及运行过程</strong></h3><p>SSL&#x2F;TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。</p><p>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。</p><p>下面用一张图表示SSL加密传输过程：</p><p><img src="https://aimak.cn/blog_img/tcp_3_ssl.jpg" alt="img"></p><p>详细介绍一下图中过程：</p><ol><li>客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式</li><li>服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）</li><li>客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端</li><li>服务端使用自己的私钥解密出C</li><li>客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。</li></ol><p><strong>05 SSL证书</strong> </p><p>上面提到了，Https协议中需要使用到SSL证书。</p><p>SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。<br>证书有很多类型，按认证级别分类：</p><ul><li>域名认证（DV&#x3D;Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名</li><li>公司认证（OV&#x3D;Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息</li><li>扩展认证（EV&#x3D;Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。</li></ul><p>EV证书浏览器地址栏样式：</p><p><img src="https://aimak.cn/blog_img/ssl_1.jpg" alt="img"></p><p>OV证书浏览器地址栏样式：</p><p><img src="https://aimak.cn/blog_img/ssl_2.jpg" alt="img"></p><p>DV证书浏览器样式：</p><p><img src="https://aimak.cn/blog_img/ssl_3.jpg" alt="img"></p><p>按覆盖范围分类：</p><ul><li>单域名证书：只能用于单域名，foo.com证书不能用不<a href="http://www.foo.com/">www.foo.com</a></li><li>通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可用于<a href="http://www.foo.com/">www.foo.com</a></li><li>多域名证书：可用于多个域名，比如foo.com和bar.com</li></ul><p>认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广Https，电子前哨基金会成立了Let’s Encrypt提供免费证书。</p><p><em><a href="https://letsencrypt.org/">https://letsencrypt.org/</a></em></p><p>证书的经销商也很多，知名度比较高的有亚洲诚信(Trust Asia)。</p><p><strong>06 RSA加密和DH加密</strong> </p><h3 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a><strong>加密算法分类</strong></h3><p>加密算法分为对称加密、非对称加密和Hash加密算法。</p><ul><li>对称加密：甲方和乙方使用同一种加密规则对信息加解密</li><li>非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。</li><li>Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程</li></ul><p>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</p><p>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。</p><p>常见的非对称加密算法有RSA、DH、DSA、ECC</p><p>Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列</p><p><strong>下面着重介绍一下RSA算法和DH算法。</strong></p><h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a><strong>RSA加密算法</strong></h3><p>Https协议就是使用RSA加密算法，可以说RSA加密算法是宇宙中最重要的加密算法。</p><p>RSA算法用到一些数论知识，包括互质关系，欧拉函数，欧拉定理。此处不具体介绍加密的过程，如果有兴趣，可以参照RSA算法加密过程。</p><p><em><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></em></p><p>RSA算法的安全保障基于大数分解问题，目前破解过的最大秘钥是700+位，也就代表1024位秘钥和2048位秘钥可以认为绝对安全。</p><p>大数分解主要难点在于计算能力，如果未来计算能力有了质的提升，那么这些秘钥也是有可能被破解的。</p><h3 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a><strong>DH加密算法</strong></h3><p>DH也是一种非对称加密算法，DH加密算法过程。</p><p><em><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B</a></em></p><p>DH算法的安全保障是基于离散对数问题。</p><p><strong>07 Http协议和Https协议的对比</strong> </p><p>Http和Https的区别如下：</p><ol><li>https协议需要到CA申请证书，大多数情况下需要一定费用</li><li>Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议</li><li>Http和Https端口号不一样，Http是80端口，Https是443端口</li><li>Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全。</li><li>Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。</li></ol><p> <strong>08 总结</strong> </p><p>经过了3天的学习和总结，总算完成了这篇文章，本文可以帮助读者大体上把握Http和Https的知识框架。</p><p>并没有深入探讨每个主题的内容，当读者有了自己知识框架之后，可以自行深入了解每个知识点的内容。<br>这边提供一份总结资料：计算机网络相关知识汇总。</p><p><em><a href="https://github.com/JeffyLu/JeffyLu.github.io/issues/22">https://github.com/JeffyLu/JeffyLu.github.io/issues/22</a></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：左大人，链接：jianshu.com&amp;#x2F;p&amp;#x2F;27862635c077&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;前言&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Http和Https属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。&lt;b</summary>
      
    
    
    
    <category term="网络" scheme="http://ai.mak.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="http://ai.mak.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>所有社交背后，都藏着孤独和利益</title>
    <link href="http://ai.mak.cn/2019/02/28/%E6%9D%82%E8%AE%B0/%E6%89%80%E6%9C%89%E7%A4%BE%E4%BA%A4%E8%83%8C%E5%90%8E%EF%BC%8C%E9%83%BD%E8%97%8F%E7%9D%80%E5%AD%A4%E7%8B%AC%E5%92%8C%E5%88%A9%E7%9B%8A/"/>
    <id>http://ai.mak.cn/2019/02/28/%E6%9D%82%E8%AE%B0/%E6%89%80%E6%9C%89%E7%A4%BE%E4%BA%A4%E8%83%8C%E5%90%8E%EF%BC%8C%E9%83%BD%E8%97%8F%E7%9D%80%E5%AD%A4%E7%8B%AC%E5%92%8C%E5%88%A9%E7%9B%8A/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2022-11-14T00:23:22.328Z</updated>
    
    <content type="html"><![CDATA[<p>人天生就是社交动物。</p><p>互联网的出现，给我们提供了更加丰富的社交渠道和信息源。</p><p>哲学家齐泽克用“马桶里面的世界”比喻了一个未知的“彼处”——我们在“此处”看着水流冲向“彼处”，而这个按下冲水键就会去到的地方，的确像极了虚拟的网络世界。</p><p>虚拟世界是没有边界的，它给我们带来了超越日常经验的体验，同时，它也提升了我们的社交效率、降低了社交成本。</p><p>关于社交，有很多可说的，今天我们就聊聊社交，聊聊这个影响了数十亿人群的社交创业梦。</p><h2 id="一、社交的狂欢"><a href="#一、社交的狂欢" class="headerlink" title="一、社交的狂欢"></a><strong>一、社交的狂欢</strong></h2><p>每一年都会有一群人问：社交创业还有机会吗？</p><p>要回答这个问题，我们可以先问问自己，技术飞速发展，我们的社交需求真的能被完全满足了吗？</p><h3 id="1-代际下的商业现象和趋势"><a href="#1-代际下的商业现象和趋势" class="headerlink" title="1. 代际下的商业现象和趋势"></a><strong>1. 代际下的商业现象和趋势</strong></h3><p>改革开放四十年，整个社会无论从组织形态、思想观念还是经济文化方面，都发生了巨大的变化，每一代人都被相应的时代环境打下了差异的烙印。</p><p>同一代际的个体因为生长在相似背景下，很容易形成一代人的共性。然而，随着社会的迅速发展，代际差异的时间间隔变得越来越短。</p><p>对于每一代人而言，他们都有特有的社交方式，而当我们谈论代际差异的时候，本质是在谈需求满足形式的变化。</p><p>QQ的使用功能就具有一定的代际差异。可以说，很多人是伴随QQ成长起来的——虽然如今QQ的发展没能超越微信，但其实这两款软件的使用人群是完全不一样的。</p><p>据报告显示：90后们更加注重QQ的娱乐和生活功能，74%使用QQ空间，29%使用QQ游戏。</p><p>80后们更加注重QQ的使用功能，63%使用QQ邮箱，56%使用传送文件功能，而使用QQ空间和游戏的比例都比90后要低。</p><p>90后在使用QQ的聊天方式上也更富有娱乐性，76%使用表情，66%使用图片，80后聊天时使用表情和图片的比例稍低但也大量使用表情包，68%使用表情，60%使用图片。</p><p>学术界将社交网络中的表情包称为“网络觅母”（meme），能够更加形象生动地传递文化和感情信息，超越了语言文字的局限性，给使用者留下的创作和想象空间更大，既可以富于娱乐性，也可以富于批判性。对于更加追求个性化和多元化的当代青年来讲，“网络觅母”着实是表达自我的最佳工具。</p><p>对于QQ而言，二十年间它做过无数的尝试和取舍，目的都是为了更好地满足不同代际的社交体验。</p><p>即使是在微信和QQ一统社交江湖的情况下，也没有阻挡一波又一波的社交创业浪潮。一个很重要的原因就是：代际社交需求差异是客观存在的，这正是社交创业前赴后继的重要原因。</p><p>在各大应用商城里，搜索关键词“社交”，跳出来的社交软件起码有成百上千个。</p><p>据第三方机构统计，2018年中国社交app用户偏年轻化，尤其是探探一类的陌生人社交app，24岁以下用户占一半以上。</p><p>也就是说：95后用户正在成为社交主力军，这批有想法、更自主的新生代，有着不同于前人的社交需求。</p><p>如果把现在市面上的社交软件分为两大类的话：</p><p>第一类是<strong>广域的社交平台</strong>：有熟人关系的强社交，如facebook、微信；有陌生人关系的弱社交，如陌陌和微博。</p><p>第二种是<strong>垂直的社交平台</strong>：比如在陌生人关系基础上的兴趣社交，豆瓣、知乎；在互动形式上的创新社交，snapchat、secret；针对特殊性向人群的社交，blued、拉拉花园等等。</p><p>人和技术这两大因素的变迁，直接促成了社交产品的变化。</p><p>过去两年，诸多第三方机构都在关心一个群体，认为他们是经济的未来和主要引擎。</p><p>他们就是——Z世代。</p><p>Z世代主要指1995—2010年出生的互联网一代，他们是移动互联网世界的“原住民”，在深度数字化的环境下长大。</p><p>Z世代有着明显的时代特征。他们不仅仅是完全成长于数字技术成熟期的原生一代，他们还是中国社会最为典型的“独一代”——数据显示，中国家庭子女个数在2000 年下降至0.94——基本上，Z世代是所在家庭中唯一的孩子。</p><p>Z世代的说法越来越流行。如今，他们已经成为全球人口最多的群体，人数高达19亿人，占全球总人口的25%，而作为人口大国的中国则为Z世代贡献了大约2.65亿人。</p><p>所以近几年，品牌商们也会想尽办法让品牌年轻化，以此拉拢Z世代。因为它们发现，Z世代购买渠道、动机大多来自社交圈，对品牌消费的首要目的也是进行社交。</p><p>几乎每一份Z世代的消费行为研究报告都会指出，Z世代的消费动机与渠道多来自于社交。</p><p>对于Z世代而言，消费行为即“社交货币”，有了消费就等同于他们手持踏入某个社交圈的“门票”，65%的Z世代期待与朋友们拥有共同的语言。</p><p>根据腾讯《2019年Z世代营销实战手册》报告显示：Z世代典型的消费态度，是通过进行品牌消费融入所在圈层、维护社交圈，其次是打造鲜明的个人人设。相比于“品牌实用主义”的前辈们，Z世代的品牌消费背后都是社交动机在驱使。</p><p>仔细分析会发现，Z世代“消费为社交”的行为又分为两种——突破社交壁垒与维护自我圈子。</p><p>今天有不少女生也开始热衷于购买篮球鞋。一方面她们是受到审美与时尚潮流的影响，另一方面，她们发现这或许可以帮助她们打开新的社交世界。</p><p>从《Z世代消费力白皮书》的数据显示：60%的Z世代表示希望通过消费，可以更好地融入社交的圈子，买出共鸣，吸引同好。也有57%的Z世代表示，消费可以帮助自己维系社交关系。在某个领域的消费潮流，或许就是这个群体的社交通行证及话语体系。</p><p>《Z世代消费力白皮书》称，“Z世代们拥有和同伴们相同的东西，创造更多的共同话题，不落伍，才能更好地维系社交关系，不被排挤。”</p><p>当Z世代成为市场主角的时候，无论是社交产品还是品牌商，也需要被重新定义了。</p><h3 id="2-风口可能一直都在"><a href="#2-风口可能一直都在" class="headerlink" title="2. 风口可能一直都在"></a><strong>2. 风口可能一直都在</strong></h3><p>俗话说“自古流量出社交”，这也就能解释为什么每个产品经理都有一颗做社交的心，每个网站和APP都有个社交梦。</p><p>社交的3个构成要素：人（关系链）、信息、互动。</p><ul><li>关系链是促成双方产生社交的前提，用户在平台上建立关系链，为社交打好地基，关系链建立的越多、越复杂、越成熟，用户的归属感和粘性就会越高。</li><li>信息具有多种表达形式，文字、图片、视频、音频等等。</li><li>互动场景分为公开场景和私密场景，例如我们在微博上分享新鲜事就是在公开场景下进行的，熟人和不认识的人都能看到，但一对一的和其他人聊天是在私密场景下的互动。</li></ul><p>每一个组合，都是社交的可能。</p><p>1967年美国社会心理学家米尔格伦（StanleyMilgram）提出了一个“六度分离”理论。</p><p>按照六度分隔理论，当每一个体的社交圈不断扩大时，最后就构成了一个庞杂的巨型网络。</p><p>后来有人根据这一理论，创立了面向社会性网络的互联网服务，通过“熟人的熟人”来进行网络社交拓展。</p><p>国内最早的 SNS 社交网站就是基于这样的逻辑问世的。</p><p>2011 年腾讯推出了微信。微信是腾讯在移动互联网时代的一款社交产品，专注熟人社交。如今微信拥有超过10亿的用户，跨越各个年龄层。</p><p>微信做熟人社交为何能成？原因之一就是微信腾飞之前，腾讯已经手握QQ这一“国民级”即时通讯应用。腾讯通过QQ对微信的用户导流，在初期快速打败米聊，而后又击败易信、来往等，成长为国民即时通讯应用。</p><p>近年来，随着动漫、轻小说、短视频等形式的火爆，目前不少平台都试图从内容出发，在社交领域切一块蛋糕。</p><p>值得注意的是，2019年1月15日，王欣、张一鸣、罗永浩选择在同一天分别发布了“马桶MT”、“多闪”和“聊天宝”，他们随即全遭微信封杀。此举被社交江湖解读为“围剿微信”的三英战吕布、围攻光明顶，虽然结果不尽人意。</p><p>这件事说明了三点：</p><p>一是在新媒体时代，社交是刚需，人人离不了，移动社交软件通过为人们的社交提供便利积聚人气，也能为自己带来利益；</p><p>二是5G时代即将到来，社交场景、移动应用将更加丰富，移动社交软件的潜能巨大，每一个纬度都可能隐藏着巨大的商机，每一个垂直通道都可能裹挟众多用户；</p><p>三是“共享经济”风口之后，创业领域的风口乏善可陈，“移动社交”具有非常多的遐想空间，具备成为新一波创业风口的可能。</p><h2 id="二、社交，为什么成了新的创业梦？"><a href="#二、社交，为什么成了新的创业梦？" class="headerlink" title="二、社交，为什么成了新的创业梦？"></a><strong>二、社交，为什么成了新的创业梦？</strong></h2><p>今天，几乎每个人都将大把的时间花在移动社交上。</p><p>据统计，全球目前有30亿人口使用网络社交软件，大概占据了全球人口40%左右。平均每人每天花了2小时在使用社交软件，相当于一天的1&#x2F;12。</p><p>前段时间，#加了新好友，聊过几句再无下落#的话题上了热搜，有1.5亿人浏览，1.2万人讨论。</p><p>很多网友纷纷表示，这说的不就是我嘛。</p><p>在一群朋友的饭局上，人们交换一些绝对不会拨打的电话号码或是转眼就不记得是谁的微信，在饭局结束之后，拿着各自的手机说声再见。</p><p>如今的社交怎么了？</p><h3 id="1-技术迭代打开了社交多元化的大门"><a href="#1-技术迭代打开了社交多元化的大门" class="headerlink" title="1. 技术迭代打开了社交多元化的大门"></a><strong>1. 技术迭代打开了社交多元化的大门</strong></h3><p>美国新闻工作者、经济学家弗里德曼在《世界是平的》一书中为我们描绘了当前世界的重大变化：</p><p>由于科技和通信技术的进步，原先横亘在人与人之间的沟壑和藩篱被逐步抹平，全世界的人们彼此空前接近。</p><p>通信和科技的进步对社交产生了深远的影响，科技和通信本身是不带任何感情色彩和社会属性的技术，任何人都可以用它，但用到什么效果和层次，取决于你自身的能力。</p><p>以社交媒体微信为例，理论上说，我们可以用微信通讯录、微信群，结识到任何想结识的人或者被任何人结识。但现实是，有些人你不想加，有些人你加不上。有些圈子你不想进入、有些圈子你进不去。</p><p>在朋友圈管理上，我们发布的和转发的信息正在透露我们的职业、年龄、品位，你屏蔽谁、关注谁，你给谁点赞、给谁留言，你能收获多少留言收获多少赞，都反映你在现实生活中处在什么样的圈层。</p><p>Facebook CEO 马克·扎克伯格在2010年首次引入了社交图谱的概念——一个将人们和不同事物联系起来的地图，社交图谱是一种表明“我认识你”的网络图谱。而这种社交图谱正在被互联网的“圈层化”运动所掩埋。</p><p>圈层，原指一个区域内本身具备很强的社会联系、社会属性相近的群体，现在多用于泛指兴趣爱好相同的人组成的群体，其内部独特丰富的文化被称为圈层文化。</p><p>圈层文化具有原创、年轻、活跃、黏性高的属性，因此文化的传播以内容为主导，散点涟漪式扩大，形成裂变，也就是圈层效应。</p><p>圈层包括两个层面，一个是圈子，一个是关系网层级。</p><p>互联网冲击下，各行各业、各个阶层、各个人都有了自己的“圈子”。在移动互联网时代，圈子的分类更加明显。</p><p>人们常说，你身边的朋友，决定了你的层次。</p><p>这话不无道理，一个人的发展，跟他所处的圈层有很大关系，圈层决定了你的位置。</p><p>主动去链接能人，选择与更强的人同行，你所处的圈层也会越来越强。</p><p>而当你圈层强大起来之后，又会反作用在你身上，推动你的发展，这是一个良性的循环。</p><p>虽然痴迷快手的人望着B站的萌妹子，瞧着新奇，却看不懂，学不来。但是技术的飞速变革，正在加快不同圈层之间的融合。</p><p>圈层融合的价值在圈层文化发展成熟的日本已被证明。</p><p>2010年，日本动画公司 Sunrise、角川书店旗下杂志《电击 G’s magazine》以及唱片公司 Lantis先联合推出了一个叫做《LoveLive!》的二三次元联动的多媒体企划。</p><p>该项目深受粉丝追捧，是日本 Oricon 排行榜前几名的常客。衍生组合μ’s 最终演出的 BD 销量在第一周就达到了 7.1 万张，这个数字在历代日本女性歌手音乐 BD 销售纪录中排行第四。</p><p>《LoveLive!》成功的背后，除了其独特的“读者参与型偶像企划”模式外，是企划团队对圈层文化用户需求的精确分析。</p><p>日本是世界上最大的亚文化聚集地，《LoveLive!》的媒体渠道全方位覆盖，在最大限度宣传推广的同时，用二次元和三次元的偶像对应关系设定，吸引了偶像宅、游戏宅、动画宅、音乐宅等圈层文化的人群，成功地将不同文化背景领域的粉丝聚集在一起，最终实现了二三次元的交汇。</p><p>2017年爆火的《中国有嘻哈》，也是圈层文化在本土的第一次逆袭。</p><p>以原本被认为小众的“嘻哈”作为切入点的综艺，上线四个小时后播放总量就突破了1亿，吴亦凡的一句“你有Freestyle吗？”登上了微博热搜。节目从一开始的吸引嘻哈圈层和导师粉丝，到后来选手的歌曲在音乐平台上线后，横扫榜单，成功地将嘻哈文化由小众人群推向大众，最终节目以近30亿的播放量完美收官。</p><p>圈层文化看似小众，实则不然，其发展已逐渐超越自身圈层，影响主流文化。</p><h3 id="2-每个人都寻找自己的“村落”"><a href="#2-每个人都寻找自己的“村落”" class="headerlink" title="2. 每个人都寻找自己的“村落”"></a><strong>2. 每个人都寻找自己的“村落”</strong></h3><p>耶鲁大学校长彼得·萨洛维在2017毕业季演讲中说，这是一个人们敲敲键盘就可以在社交媒体上同时和几百个人聊天交友的时代，然而，越来越多的人的生活是围着互联网转，越社交越孤独。</p><p>心理学大师罗杰斯也曾经提出来过一个概念，叫“基本孤独感”，是说我们有摆脱不了也无法被安慰的孤独。</p><p>细细体味一下，我们在人际交往关系中，有很多这样的时候，我们明明双方在彼此沟通交流，但是我们总是“不得劲”，觉得没有感受到这场交流有什么意义，至少于我们个人没有达到我们想要达到的意义。哪怕明明我们身处闹市，哪怕明明我们亲朋为伴，好友相陪，我们还是有治愈不了的孤独感。</p><p><strong>我们为什么会孤独？</strong></p><p><strong>① 现有的社交媒体看似热闹，却不完全真实；</strong></p><p>归根结底，我们离不开有温度和力量的肢体接触，而这些，社交媒体永远给不了。</p><p><strong>② 现有社交媒体的关系可控性更强，也更冷酷；</strong></p><p>不论是熟人社交还是陌生人社交，在社交媒体上，拉黑、删除、可见设置等等，这种能主动掌控的社交，让人与人的关系变得冷漠。</p><p><strong>③ 朋友圈，真实也虚假；</strong></p><p>在社交网络，我们可以选择让自己“被看见”或者“不被看见”。为了“被看见”，朋友圈成了舞台，晒幸福的，晒恩爱的，晒豪车豪宅的……一旦没有得到回应，就陷入巨大的失落或者焦虑之中。</p><p><strong>④ 信息茧房下的群体性孤独；</strong></p><p>沉迷于网络社交，忽视现实生活中的人际交流，迷恋网络游戏，成为情感机器人的依赖者，这种情况我们称为信息茧房下的“群体性孤独”。</p><p>社交“群体性孤独”会使得人们更加痴迷于互联网环境，并且心生攀比，这种不良的心态会使得其生活变得更加孤独。</p><p>“群体性孤独”还会影响人们理性辨别能力的培养，对于社交“群体性孤独”的人而言，他们对于尊重和爱的需求是虚拟化的，片面地认为陌生人对于自己的点赞，就是一种人际交往中的关怀。</p><p>越来越多的人陷入到这种社交的孤独和焦虑之中。</p><p><strong>我们要如何摆脱这种状态？</strong></p><p><strong>① 找到社交的最佳尺度；</strong></p><p>社交是可以有一个最佳尺度的，不管是线下社交，还是线上社交，要掌握主动权。</p><p>基于Facebook的研究发现，当主动在社交网络上发起一些行为时，幸福感会更高，积极情绪会更多。</p><p><strong>②明确需要；</strong></p><p>明确需要通过社交网络得到什么。比如需要信息支持或者需要情感依托。</p><p><strong>③ 社交工具的本质；</strong></p><p>看清楚社交工具的本质，有利于更好地管理社交关系。</p><p>在苏珊·平克的《村落效应》中，作者呼吁我们应该“面对面社交”。应该在面对面社交与虚拟社交之间取得平衡。既要与家人及朋友重新建立亲密的联系，又要与邻居、同事或其他人分享共同兴趣。</p><p>这样可以有效改善个人生活质量及情绪，提升人们的幸福感。</p><h3 id="3-社交的本质从来没有变过"><a href="#3-社交的本质从来没有变过" class="headerlink" title="3. 社交的本质从来没有变过"></a><strong>3. 社交的本质从来没有变过</strong></h3><p>风墟先生在《社交的本质》一文中提到，社交分为两种，一种是共情社交，一种是功利社交。</p><p>共情社交是指为了获得情感联结与情感体验，打发无聊，或是有共同的兴趣等而产生的社交行为。</p><p>这种社交不涉及利益的交换，且绝大多数人自小产生的社交行为都是源于这种共情类的需求。</p><p>共情社交存在的根本原因在于：当一个人的心智在某方面尚未成熟独立时，或是当他生活不如意时，他需要从朋友那里获得情感上的联结和支持。</p><p>功利社交是指为了达成某一目的，或是从对方身上获得利益而产生的社交行为。</p><p>随着一个人心智的完善和社会地位的提升，他会越来越注重社交的效益性。</p><p>功利社交有两个基本前提：</p><p><strong>一是“有效”信息的交互传递。</strong></p><p>这个信息是广义的，在人际交往中的如语言、情感、物质、知识等都可以包括在这个信息的范畴内。</p><p>沟通的本质就是信息的传递。而有效是功利性社交的一个基本要素。人们产生功利社交行为之前基本上都是抱有一定的目的性，当我和你产生社交时，我们的交流应该是有价值的，而不是毫无意义的闲扯和浪费时间的各说各话。</p><p><strong>二是较为“对等”的价值水平。</strong></p><p>这个价值水平并不仅仅只是指社会地位。它依据的是具体情况和个人的评判标准。</p><p>功利性社交的根本目的就是能够从对方那里获得一定的利益或是得到帮助，如果一个人和一个人的差距极大，很清楚对方这个人在未来的生活中不可能带来丝毫的利益，那么这段社交关系就是无价值的，所以本能地就会舍弃。</p><p>商业行为的本质是逐利，社交最终还是要回归本质。</p><p>记得新版微信推出的时候，页面出现了这样一句话：“因你看见，所以存在”，这也许是社交帝国缔造者张小龙的社交梦。</p><p>最后，未来的社交产品会是什么样子，我们不知道，但我们永远心怀期待。</p><h3 id="中国社交产品发展路径"><a href="#中国社交产品发展路径" class="headerlink" title="中国社交产品发展路径"></a><strong>中国社交产品发展路径</strong></h3><p>1994年，中国大陆第一个互联网BBS——曙光站上线。</p><p>1995年，马化腾在家搭建了慧多网深圳站点，起名Pony-soft。</p><p>1996年，求伯君在珠海架设了“西线”BBS站，雷军在北京架设了“西点”；同年，丁磊加入广州飞捷，架设了基于公网的BBS，并在上面认识了周卓林；汪延和李嵩波加入四通利方，利方在线成立，并先后开辟了“谈天说地”和“体育沙龙”版块。</p><p>1997年，中国网络论坛兴起。也就是这一年，“猫扑”问世。</p><p>1998年，西祠胡同（综合性网络社区）因“911事件”西祠网友大讨论，创下单个版块在线千人的历史记录。</p><p>1999年2月，QQ上线。这个以企鹅为标志物的即时通讯软件，适逢当年中国互联网大力发展的大环境，其方便快捷的特性一下子吸引了中国大众的眼球，在短短的几年间，席卷全中国。</p><p>2002年8月，博客中国成立。</p><p>2003年12月，全球最大的中文社区百度贴吧上线。</p><p>2005年，王兴、王慧文、赖斌强、唐阳等几位大学生创办校内网（后改名人人网），同年，杨勃创办的社区网站豆瓣上线。</p><p>2006年，校内网与5Q网强强联合，最终成功占领了校园市场；通过熟人关系的突破，SNS终究还是在中国找到了出路。</p><p>2008年3月，定位在白领圈的开心网成立，并在随后的两个月内上线了朋友买卖和争车位应用，类似朋友圈小游戏的社交裂变模式第一次出现在SNS网站上。</p><p>2009年8月，新浪微博上线。</p><p>2010年四季度，QQ空间用户超过4.8亿；2013年末，QQ空间被列为世界第三，中国第一的社交网站。</p><p>2010年5月，腾讯微博上线。</p><p>2010年10月，一款名为“kik”的应用登陆App Store和Android Market，短短15天内就有超过100万人注册下载。</p><p>2010年11月20日，在工信部官方调停3Q大战的当天，“微信”项目正式启动，次年1月21日，微信上线。</p><p>2011年，陌陌上线。</p><p>2012年3月29日凌晨4点，微信用户突破1亿，历时433天。这几乎是互联网历史上的一个奇迹：QQ在线用户数突破1亿用了将近10年，Facebook用了5年半，Twitter用了4年。</p><p>2012年4月19日，朋友圈上线，微信完成了通信工具向社交平台的升级，基于手机的熟人社交圈正式出现，微博、人人遭到沉重打击。</p><p>2013年10月，中国的实名制商业社交平台脉脉上线。</p><p>2014年，探探上线。</p><p>2016年9月，专注年轻人音乐短视频社区平台抖音上线。</p><p>2019年1月15日，王欣、张一鸣、罗永浩选择在同一天分别发布了“马桶MT”、“多闪”和“聊天宝”。“马桶MT”上线1小时就被关停。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>QuestMobile2018年度报告：立足当下泛传媒业，十大趋势定位未来</p><p>圈层文化爆款频出，多圈层融合成为未来趋势 | 行业研究</p><p>中国社交二十年</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人天生就是社交动物。&lt;/p&gt;
&lt;p&gt;互联网的出现，给我们提供了更加丰富的社交渠道和信息源。&lt;/p&gt;
&lt;p&gt;哲学家齐泽克用“马桶里面的世界”比喻了一个未知的“彼处”——我们在“此处”看着水流冲向“彼处”，而这个按下冲水键就会去到的地方，的确像极了虚拟的网络世界。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>RESTful 架构基础</title>
    <link href="http://ai.mak.cn/2019/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/RESTful%20%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://ai.mak.cn/2019/02/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/RESTful%20%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2022-11-14T00:39:18.178Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="http://t.cn/EVBQ2Ug">http://t.cn/EVBQ2Ug</a></p><p>REST（Representational State Transfer）架构风格是一种世界观，把信息提升为架构中的一等公民。通过 REST 可以实现系统的高性能、可伸缩、通用性、简单性、可修改性和可扩展等特性。这篇文章解释了主要的 HTTP 操作，对 HTTP 响应码进行描述，并列举相关开发库和框架。此外，本文还提供了额外的资源，对每个主题进行了更深入的探讨。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>REST 架构风格不是一种可以购买的技术，也不是一个可以添加到软件开发项目中的开发库。首先也是最重要的，REST 是一种世界观，把将信息提升为构建架构中的一等公民。</p><p>Roy Fielding 的博士论文“架构风格和基于网络的软件架构设计”介绍和整理了“RESTful”系统的思想和相关术语。这是一篇学术论文，虽然使用正式语言，但是仍然易于理解并且提供了实践基础。</p><p>总结一下，RESTful 通过体系结构的特定选择能从部署的系统中获得理想特性。尽管这种风格定义的约束细节并没有为所有场合设计，但是的确可以广泛适用。</p><p>由于 Web 对消费者偏好有多重影响，REST 风格的倡导者鼓励企业组织在其边界内使用相同原则，就像他们在面向外部客户的网页上做的那样。本文将讨论现代 REST Web 实现中的基本约束和属性。</p><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><p>REST 表示什么含义？以无状态方式传输、访问和操作文本数据。当正确部署后，REST 为互联网上不同应用程序之间提供了一致的互操作性。无状态（stateless）这个术语至关重要，它使得应用程序可以用不可知的方式进行通信。RESTful API 通过统一资源定位符地址（URL）公开服务。URL 名称将资源的区分为接受内容或返回内容。RFC 1738中定义了 URL scheme，可以在这里找到: <a href="https://tools.ietf.org/rfc/rfc1738.txt">https://tools.ietf.org/rfc/rfc1738.txt</a></p><p>RESTful URL 类似于下面这个 library API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>实际公开的不一定是某种任意的服务，而是代表对消费者有价值的信息资源。URL 作为资源句柄，可以请求、更新或删除内容。</p><p>开始把服务发布到某个地方，然后开始与 REST 服务进行交互。返回的内容可能是 XML、JSON 格式，或者更确切地说是像 Atom 或自定义 MIME 类型等超媒体格式。虽然一般建议尽可能重用现有的格式，但是对正确设计的媒体类型正在变得越来越宽容。</p><p>需要请求资源的时候，客户机会发一个超文本传输协议（HTTP）GET 请求，例如在浏览器中键入一个 URL 然后点击回车，选择书签，或者点击锚引用链接。</p><p>通过编程方式与 RESTful API 交互，有数十个客户端 API 或工具可供选择。使用 curl 命令行工具，可以输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>上面的命令使用默认格式，但你可能不需要这种格式的信息。幸运的是 HTTP 有一种机制，可以指定返回信息的格式。在请求中指定 “Accept” 头，如果服务器支持这种格式，会以指定的格式返回。这个过程称为内容协商，这是 HTTP 中未被充分利用的功能之一，可以使用一个类似于上面例子中的 curl 命令来指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl –H &quot;Accept:application/json&quot; http://fakelibrary.org/library</span><br></pre></td></tr></table></figure><p>由于资源名称与内容格式是独立的，从而让请求不同格式信息成为可能。虽然 REST 中的 “R” 的含义是 “表现”而非“资源”，但是应该在构建系统时允许客户端指定请求的内容格式，请牢记这一点。在我们的例子中 library API 可能包含以下 URL：</p><ul><li><a href="http://fakelibrary.org/library%EF%BC%9A%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%9B%BE%E4%B9%A6%E3%80%81DVD%E7%AD%89%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84%E9%93%BE%E6%8E%A5%E3%80%82">http://fakelibrary.org/library：图书馆基本信息，搜索图书、DVD等相关资源基本功能的链接。</a></li><li><a href="http://fakelibrary.org/book%EF%BC%9A%E5%AD%98%E6%94%BE%E4%B9%A6%E7%B1%8D%E7%9A%84%E2%80%9C%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E2%80%9D%E3%80%82%E4%BB%8E%E6%A6%82%E5%BF%B5%E4%B8%8A%E8%AF%B4%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E7%9A%84%E4%B9%A6%E7%B1%8D%E3%80%82%E6%98%BE%E7%84%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%BE%97%E5%88%B0%E8%A7%A3%E5%86%B3%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%8D%E4%BC%9A%E5%B8%8C%E6%9C%9B%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E5%9B%BE%E4%B9%A6%EF%BC%8C%E8%80%8C%E6%98%AF%E5%B8%8C%E6%9C%9B%E9%80%9A%E8%BF%87%E7%B1%BB%E5%88%AB%E3%80%81%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E7%AD%89%E6%9D%A5%E6%A3%80%E7%B4%A2%E5%9B%BE%E4%B9%A6%E3%80%82">http://fakelibrary.org/book：存放书籍的“信息空间”。从概念上说，这里可能会存放所有的书籍。显然，如果这个问题得到解决，我们不会希望返回所有图书，而是希望通过类别、搜索关键词等来检索图书。</a></li><li><a href="http://fakelibrary.org/book/category/1234%EF%BC%9A%E5%9C%A8%E4%B9%A6%E7%B1%8D%E7%9A%84%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E9%87%8C%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%88%AB%E6%B5%8F%E8%A7%88%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%88%90%E4%BA%BA%E5%B0%8F%E8%AF%B4%E3%80%81%E5%84%BF%E7%AB%A5%E4%B9%A6%E7%B1%8D%E3%80%81%E5%9B%AD%E8%89%BA%E4%B9%A6%E7%B1%8D%E7%AD%89%E3%80%82%E4%BD%BF%E7%94%A8%E6%9D%9C%E5%A8%81%E5%8D%81%E8%BF%9B%E5%88%B6%E5%9B%BE%E4%B9%A6%E5%88%86%E7%B1%BB%E6%B3%95%E6%98%AF%E5%8F%AF%E8%A1%8C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%83%B3%E8%B1%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E3%80%82%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%EF%BC%8C%E8%BF%99%E7%A7%8D%E2%80%9C%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E2%80%9D%E5%8F%AF%E8%83%BD%E6%98%AF%E6%97%A0%E9%99%90%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%94%E5%8F%AF%E8%83%BD%E6%94%B6%E5%88%B0%E4%BA%BA%E4%BB%AC%E5%AE%9E%E9%99%85%E5%85%B3%E5%BF%83%E7%9A%84%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%BD%B1%E5%93%8D%E3%80%82">http://fakelibrary.org/book/category/1234：在书籍的信息空间里，我们可以指定类别浏览，例如成人小说、儿童书籍、园艺书籍等。使用杜威十进制图书分类法是可行的，但我们也可以想象自定义分组。问题的关键在于，这种“信息空间”可能是无限的，而且可能收到人们实际关心的信息类型影响。</a></li><li><a href="http://fakelibrary.org/book/isbn/978-0596801687%EF%BC%9A%E6%8F%90%E5%88%B0%E6%9F%90%E6%9C%AC%E5%85%B7%E4%BD%93%E7%9A%84%E4%B9%A6%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8C%85%E6%8B%AC%E4%B9%A6%E5%90%8D%E3%80%81%E4%BD%9C%E8%80%85%E3%80%81%E5%87%BA%E7%89%88%E5%95%86%E3%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%95%B0%E3%80%81%E5%8F%AF%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">http://fakelibrary.org/book/isbn/978-0596801687：提到某本具体的书，应该包括书名、作者、出版商、系统中的拷贝数、可用拷贝数等信息。</a></li></ul><blockquote><p>译注： 杜威十进制图书分类法由美国图书馆专家麦尔威·杜威发明，于1876年首次发表，历经22次的大改版。该分类法以三位数字代表分类码，共可分为10个大分类、100个中分类及1000个小分类。</p></blockquote><p>就图书馆用户而言，上面提到的这些 URL 可能就是只读的，但是图书馆员使用应用程序时实际上可以操作这些资源。</p><p>例如添加一本新书，可以向 main&#x2F;book 地址 POST 一个 XML。 使用 curl 提交，看起来可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  curl –u username:password -d @book.xml -H &quot;Content-type: text/xml&quot; http://fakelibrary.org/book</span><br></pre></td></tr></table></figure><p>此时，服务器可能会对提交的内容进行校验，创建与图书相关的记录，并返回响应代码201——表示已创建新资源。新资源的 URL 可以在响应的 Location 头中找到。</p><p>RESTful 请求一个重要特性：每次请求都包含了充足的状态信息来响应请求。这为服务器的可见性和无状态创造了条件，并为扩展系统和识别发送的请求内容提供了理想特性。对于缓存结果也非常有帮助。服务器地址和请求状态组合成可计算的 hash 键值，并形成一个结果集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org + /book/isbn/978-0596801687</span><br></pre></td></tr></table></figure><p>接下来我们会先介绍 GET 请求。客户端在需要时发出 GET 请求获取指定资源。客户端可以在本地缓存请求结果，服务器可以在远程缓存结果，系统的中间层可以在请求链路中间缓存结果。这是一个与具体应用程序无关的特性，可以加入系统设计中。</p><p>正因为可以操作资源，也就意味着并不是每个人都可以这样做。我们完全可以建立一个防护模型，要求用户在操作前验证身份，证明他们具有该操作的授权。在本文的最后，将提供一些提升 RESTful 服务安全性的内容。</p><h1 id="2-REST-和-SOAP-比怎么样？"><a href="#2-REST-和-SOAP-比怎么样？" class="headerlink" title="2. REST 和 SOAP 比怎么样？"></a>2. REST 和 SOAP 比怎么样？</h1><blockquote><p>SOAP：简单对象访问协议（Simple Object Access Protocol）。是交换数据的一种协议规范，是一种轻量的、简单的、基于XML的协议。一条 SOAP 消息就是一个普通的 XML 文档，包含必需的 Envelope 元素、可选的 Header 元素、必需的 Body 元素和可选的 Fault 元素。</p></blockquote><p>把 REST 与 SOAP 划等号是错误的。在这两者之间进行比较，带来的困扰远多于好处。简单来说，它们不是一回事。尽管可以用这两种方法解决许多架构问题，但是它们不能相互替换。</p><p>这种混淆很大程度上源于对 “REST 是通过 URL 调用 Web 服务”这句话的误解。这种观点与 RESTful 架构的功能相距甚远。如果不全面深入理解 RESTful 的架构实现，就很容易误解 REST 实践的本意。</p><p>利用 REST 的最佳方式，是将生产和消费过程中的信息与技术分离实现解耦，进而更好地管理系统，让架构具备以下特性：</p><ul><li>高性能</li><li>可扩展</li><li>通用</li><li>简洁</li><li>可修改</li><li>可扩展</li></ul><p>这并不是说，基于 SOAP 构建的系统不能具备上述特性。而是当技术、组织或过程的复杂性造成不能在单个事务中完成请求的生命周期时，这种情况 SOAP 能够发挥最佳效果。</p><h1 id="3-Richardson-成熟度模型"><a href="#3-Richardson-成熟度模型" class="headerlink" title="3. Richardson 成熟度模型"></a>3. Richardson 成熟度模型</h1><p>Leonard Richardson 引入了一种成熟度模型，部分阐述了 SOAP 与 REST 之间的区别，并提供一种对不同类型的系统进行分类的框架。许多人不恰当地称之为 “REST”。可以将这种分类看作系统中不同 Web 技术组件紧密程度的度量标准：包括信息资源、HTTP 作为应用层协议和作超媒体作为控制媒介。</p><table><thead><tr><th>LEVEL</th><th>ADOPTION</th></tr></thead><tbody><tr><td>0</td><td>This is basically where SOAP is. There are no information resources, HTTP is treated like a transport protocol, and there is no concept of hypermedia. Conclusion: REST and SOAP are different approaches.</td></tr><tr><td>1</td><td>URLs are used, but not always as appropriate information resources, and everything is usually a GET request (including requests that update server state). Most people new to REST first build systems that look like this.</td></tr><tr><td>2</td><td>URLs are used to represent information resources. HTTP is respected as an application protocol, sometimes including content negotiation. Most Internet-facing “REST” web services are really only at this level because they only support non- hypermedia formats.</td></tr><tr><td>3</td><td>URLs are used to represent information resources. HTTP is respected as an application protocol including content negotiation. Hypermedia drives the interactions for clients.</td></tr></tbody></table><p>称其为“成熟度模型”似乎意味着应该只构建“成熟度”最高的系统。这种看法是不合适的。第2级是有价值的，从2级向3级转变通常只是采用了一种新的 MIME 类型。然而，从0级到3级的转变要困难得多，因此增量式升级转变通常也会增值。</p><p>首先，确定希望公开哪些信息资源。采用 HTTP 作为处理这些信息资源的应用协议，包括内容协商。接下来，当一切就绪时，使用基于超媒体的 MIME 类型，这样就可以充分享受 REST 的好处了。</p><h1 id="4-动词"><a href="#4-动词" class="headerlink" title="4. 动词"></a>4. 动词</h1><p>动词是用来与服务器资源交互的方法或操作。 RESTful 系统中有限的动词让刚接触该的使用者感到困惑和沮丧。看似武断和不必要的约束，目的是鼓励以应用程序无关的形式提供可预测的行为。通过明确、清晰地定义这些动词的行为，客户端可以在网络中断或故障时自主处理。</p><p>精心设计的 RESTful 系统主要使用4个 HTTP 动词。</p><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>GET 请求是最常用的 Web 动词。 GET 请求将命名资源从服务器传输到客户端。尽管客户端不需要知道请求的资源内容，但是请求返回的结果是带元数据标记的字节流，这表明客户端应该知道如何解释资源。 在 Web 中通常用 “text&#x2F;html” 或 “application&#x2F;xhtml+xml” 表示。正如之前提到的那样，只要服务器支持，客户端可以通过内容协商提前指定请求的返回格式。</p><p>GET 请求关键点之一，不要修改服务器端的任何内容。这是一个基本的安全要求，也是不熟悉 REST 的开发者犯的最大错误之一。你可能会遇到这样的 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/res/action=update?data=1234</span><br></pre></td></tr></table></figure><p><strong>不要这样做！</strong> 由于 GET 请求安全性允许缓存请求，这会让正在构建的 RESTful 系统陷入混乱。 GET 请求也意味着幂等性，即多次请求不会对系统产生任何影响。这是基于分布式基础设施的一个重要特性。如果进行 GET 请求时被打断，由于幂等性，客户端可以再次发起请求。这点非常重要。在设计良好的基础结构中，客户端可以从任意应用程序发起请求。虽然一定会有与应用程序相关的特定行为，但是加入与应用程序无关的行为越多，系统就会越有弹性，也更容易维护。</p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>在辨别 POST 和 PUT 动词意图的时候，情况开始变得不那么清晰。根据定义，二者似乎都可以被客户端用来创建或更新服务器资源，然而它们的用途各有不同。</p><p>当无法预测请求创建的资源的标识时，客户端会使用 POST 请求。在新增雇员、下订单或提交表单的时候，我们无法预测服务器将如何命名正在创建的资源。这就是为什么将资源提交给类似 Servlet 这样的程序处理。接下来，服务器会接受请求、校验请求、验证用户凭据等。成功处理后，服务器将返回 201 HTTP 响应代码，其中包含一个 “Location” 头，代表新创建的资源的位置。</p><p><strong>注意：</strong> 有些人将 POST 视为创建资源的 GET 会话。他们会对创建的资源通过 body 返回200，而不是返回201。这似乎是避免二次请求的一种快捷方式，但是这种做法混合了 POST 和 GET，让缓存资源的潜在影响变得微妙。尽量避免因为走捷径而牺牲大局。短期看这似乎是值得的，但随着时间的推移，这些捷径叠加起来可能会带来不利的影响。</p><p>POST 动词的另一个主要用途是“追加（Append）”资源信息，即增量编辑或部分更新，而不是提交完整的资源。这里应使用 PUT 操作。对已知资源使用 POST 更新，可用于向订单添加新送货地址或更新购物车中某个商品的数量。</p><p>由于是更新资源的部分信息，<strong>POST 既不安全也不幂等</strong>。</p><p>POST 的最后一种常见用法是提交查询。将查询的内容或表单内容进行 URL 编码后提交给服务执行查询。通常可以直接返回 POST 结果，因为没有与查询相关的标识。</p><p><strong>注意：</strong> 建议将这样的查询转换为信息资源本身。如果采用 POST 查询，可以考虑采用 GET 请求，后者支持缓存。你可以与其他人分享这个链接。</p><h2 id="4-3-PUT"><a href="#4-3-PUT" class="headerlink" title="4.3 PUT"></a>4.3 PUT</h2><p>由于 HTML 表单目前还不支持 PUT，许多开发人员基本上会忽略 PUT 动词。然而，PUT 有一个重要作用并且是 RESTful 系统完整愿景的一部分。</p><p>客户端可以向指定 URL 发 PUT 请求，服务器用请求中的数据执行覆盖操作。PUT 请求在某种程度上是等幂的，而 POST 更新不是。</p><p>如果客户端在 PUT 覆盖请求时被打断，由于重新发送覆盖操不会造成任何后果，因此可以再次发送。客户端具备管理状态能力，所以直接重发覆盖命令即可。</p><p><strong>注意：</strong> 这种协议层处理并不意味着要取消更高级别（如应用层）的事务，但是同样地，它也是一种体系结构上理想的属性，可以在应用层以下使用。</p><p>如果客户端能够提前了解资源的标识，那么 PUT 也可用于创建资源。正如我们在 POST 部分中讨论的那样，通常不会出现这种情况。但是如果客户端能够控制服务器端信息空间，那么这种操作也是合理的。</p><h2 id="4-4-DELETE"><a href="#4-4-DELETE" class="headerlink" title="4.4 DELETE"></a>4.4 DELETE</h2><p>在公共网络上 DELETE 动词没有被广泛使用（谢天谢地!）。然而，对于控制信息空间非常有用，它是资源生命周期中非常有用的一部分。</p><p>DELETE 请求意在实现等幂。可能由于网络故障 DELETE 请求被打断，这时我们希望客户端继续尝试。第一次请求无论成功与否，资源都应该返回204（无指定内容）。对之前已删除的资源或不存在的资源可能需要一些额外处理，两种情况都应该返回404。一些安全策略要求为不存在的和已删除的资源返回404，这样 DELETE 请求就不会泄漏有关资源是否存在的信息。</p><p>还有另外三个没有广泛使用但是有价值的动词。</p><h2 id="4-5-HEAD"><a href="#4-5-HEAD" class="headerlink" title="4.5 HEAD"></a>4.5 HEAD</h2><p>HEAD 动词用来请求资源，但不实际检索。客户端可以通过 HEAD 检查资源是否存在，并检查资源相关的元数据。</p><h2 id="4-6-OPTIONS"><a href="#4-6-OPTIONS" class="headerlink" title="4.6 OPTIONS"></a>4.6 OPTIONS</h2><p>OPTIONS 动词也可以用来查询服务器相关资源的情况，方法是询问哪些其它动词可用于该资源。</p><h2 id="4-7-PATCH"><a href="#4-7-PATCH" class="headerlink" title="4.7 PATCH"></a>4.7 PATCH</h2><p>最新的动词 PATCH 直到2010年才正式采纳为 HTTP 的一部分。旨在提供一种标准化方式来表示部分更新。PATCH 请求通过标准格式让交互的意图更明确。这是推荐使用 PATCH 而非 POST 的原因，尽管 POST 可以用于任何事情。 IETF 发布了 RFC 文档，定义用于 PATCH 操作的 XML 和 JSON。</p><p>如果客户端 PATCH 请求的 header 中带 If-Match，则此部分为幂等更新。可以重试中断的请求，因为如果第一次请求成功，那么 If-Match header 会不同于新状态。如果相同，则未处理原始请求可应用 PATCH。</p><h1 id="5-响应码"><a href="#5-响应码" class="headerlink" title="5. 响应码"></a>5. 响应码</h1><p>HTTP 响应码为我们在客户端和服务器之间的对话提供了丰富的请求状态信息。大多数人只熟悉一般意义上的200、403、404或者500，但是还有更多有用的代码可供使用。这里表格并不全面，但是它们涵盖了许多在 RESTful 环境中应该考虑使用的最重要代码。数字可按照以下类别分组：</p><ul><li>1XX：信息类</li><li>2XX：操作成功</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务器错误</li></ul><p>第一组响应码表明客户端的请求格式正确且处理成功。具体操作如下表所示：</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>200</td><td>OK. The request has successfully executed. Response depends upon the verb invoked.</td></tr><tr><td>201</td><td>Created. The request has successfully executed and a new resource has been created in the process. The response body is either empty or contains a representation containing URIs for the resource created. The Location header in the response should point to the URI as well.</td></tr><tr><td>202</td><td>Accepted. The request was valid and has been accepted but has not yet been processed. The response should include a URI to poll for status updates on the request. This allows asynchronous REST requests</td></tr><tr><td>204</td><td>No Content. The request was successfully processed but the server did not have any response. The client should not update its display.</td></tr></tbody></table><p>表1 成功的客户端请求</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently. The requested resource is no longer located at the specified URL. The new Location should be returned in the response header. Only GET or HEAD requests should redirect to the new location. The client should update its bookmark if possible.</td></tr><tr><td>302</td><td>Found. The requested resource has temporarily been found somewhere else. The temporary Location should be returned in the response header. Only GET or HEAD requests should redirect to the new location. The client need not update its bookmark as the resource may return to this URL.</td></tr><tr><td>303</td><td>See Other. This response code has been reinterpreted by the W3C Technical Architecture Group (TAG) as a way of responding to a valid request for a non-network addressable resource. This is an important concept in the Semantic Web when we give URIs to people, concepts, organizations, etc. There is a distinction between resources that can be found on the Web and those that cannot. Clients can tell this difference if they get a 303 instead of 200. The redirected location will be reflected in the Location header of the response. This header will contain a reference to a document about the resource or perhaps some metadata about it.</td></tr></tbody></table><p>表2 — 客户端重定向请求</p><p>表3中的响应代码表示客户端请求无效，如果条件不发生变化，重新请求仍无法处理。这些故障可能有请求格式错误、未授权的请求、请求的资源不存在等。</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>405</td><td>Method Not Allowed.</td></tr><tr><td>406</td><td>Not Acceptable.</td></tr><tr><td>410</td><td>Gone.</td></tr><tr><td>411</td><td>Length Required.</td></tr><tr><td>412</td><td>Precondition Failed.</td></tr><tr><td>413</td><td>Entity Too Large.</td></tr><tr><td>414</td><td>URI Too Long.</td></tr><tr><td>415</td><td>Unsupported Media Type.</td></tr><tr><td>417</td><td>Expectation Failed.</td></tr></tbody></table><p>表3 客户端请求错误</p><p>最后，表4中的响应代码表示服务器暂时无法处理客户端请求（可能仍然无效）。客户端应当在将来的某个时候重新请求。</p><table><thead><tr><th>CODE</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error.</td></tr><tr><td>501</td><td>Not Implemented.</td></tr><tr><td>503</td><td>Service Unavailable.</td></tr></tbody></table><p>表4 服务器处理请求错误</p><p>服务根据其自身功能要求具有不同程度的可扩展性。</p><p><strong>注意：</strong> 试试响应代码418，它会返回简洁有力的回复：”我是一个茶壶。”</p><h2 id="5-1-REST-资源"><a href="#5-1-REST-资源" class="headerlink" title="5.1 REST 资源"></a>5.1 REST 资源</h2><h3 id="5-1-1-论文"><a href="#5-1-1-论文" class="headerlink" title="5.1.1 论文"></a>5.1.1 论文</h3><p>Fielding 博士的论文《架构的风格与基于网络的软件架构设计》是对 RESTful 思想的主要介绍：<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></p><h3 id="5-1-2-RFC-规范"><a href="#5-1-2-RFC-规范" class="headerlink" title="5.1.2 RFC 规范"></a>5.1.2 RFC 规范</h3><p>REST 常见用法的技术规范由<strong>国际互联网工程任务组（IETF）定义，按照请求评议（RFC）</strong>流程完善。规范由数字定义，并随着时间推移不时更新版本，以替换已经过时的文件。目前，这里有最新的相关 RFC 文件。</p><h4 id="5-1-2-1-URI"><a href="#5-1-2-1-URI" class="headerlink" title="5.1.2.1 URI"></a>5.1.2.1 URI</h4><p>RFC 3986定义了 URI 命名方案的通用语法。URI 是一种命名方案，包含了对其他如网址、支持名字子空间等编码方案。网址：<a href="http://www.ietf.org/rfc/rfc3986.txt&gt;">http://www.ietf.org/rfc/rfc3986.txt&gt;</a></p><h4 id="5-1-2-2-URL"><a href="#5-1-2-2-URL" class="headerlink" title="5.1.2.2 URL"></a>5.1.2.2 URL</h4><p>Url 是 URI 的一种形式，其中嵌入了充足的信息（通常是访问方案和地址），用于解析和定位资源统一资源定位符。 网址：<a href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a></p><h4 id="5-1-2-3-IRI"><a href="#5-1-2-3-IRI" class="headerlink" title="5.1.2.3 IRI"></a>5.1.2.3 IRI</h4><p>国际化资源标识符（IRI）在概念上是一个用 Unicode 编码的 URI，用于在 Web 上使用的标识符中支持世界上各种语言的字符。 IETF 选择创建一个新的标准，而不是改变 URI 方案本身，以避免破坏现有的系统并明确区分这两种方法。那些支持 IRI 的人故意这样做。 还定义了在 IRI 和 URI 之间进行转换的映射方案。 网址&lt;：<a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a></p><h4 id="5-1-2-4-HTTP"><a href="#5-1-2-4-HTTP" class="headerlink" title="5.1.2.4 HTTP"></a>5.1.2.4 HTTP</h4><p>HTTP 1.1版本定义了一个应用程序协议，用于操作通常以超媒体格式表示的信息资源。虽然它是一个应用级协议，但通常不与应用程序绑定，由此产生了重要的体系结构优势。 大多数人认为 HTTP 和超文本标记语言文（HTML）就是“Web”，但是 HTTP 在非面向文档的系统开发中也很有用。 网址： <a href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</a></p><h4 id="5-1-2-5-PATCH-格式"><a href="#5-1-2-5-PATCH-格式" class="headerlink" title="5.1.2.5 PATCH 格式"></a>5.1.2.5 PATCH 格式</h4><p>JavaScript 对象表示法（JSON）Patch 网址：<a href="https://www.ietf.org/rfc/rfc6902.txt">https://www.ietf.org/rfc/rfc6902.txt</a><br>XML Patch 网址：<a href="https://www.ietf.org/rfc/rfc7351.txt">https://www.ietf.org/rfc/rfc7351.txt</a></p><h2 id="5-2-描述语言"><a href="#5-2-描述语言" class="headerlink" title="5.2 描述语言"></a>5.2 描述语言</h2><p>人们对使用各种语言来描述 API 非常感兴趣，通过描述语言可以更容易地编写客户端和服务器文档，甚至生成骨架代码。一些比较流行、有趣的描述语言包括：</p><h3 id="5-2-1-RAML"><a href="#5-2-1-RAML" class="headerlink" title="5.2.1 RAML"></a>5.2.1 RAML</h3><p>RAML 是一种 YAML&#x2F;JSON 语言，可以定义2级成熟度的 API。它支持可重用模式和特性，通过模式和特性实现功能 API 设计的标准化。网址：<a href="http://raml.org/">http://raml.org</a></p><h3 id="5-2-2-Swagger"><a href="#5-2-2-Swagger" class="headerlink" title="5.2.2 Swagger"></a><strong>5.2.2 Swagger</strong></h3><p>Swagger 是另一种 YAML&#x2F;JSON 语言，支持定义2级成熟度的 API。它包含代码生成器、编辑器、 API 文档可视化功能，能够与其他服务集成的。 网址：<a href="http://swagger.io/">http://swagger.io</a></p><h3 id="5-2-3-Apiary-io"><a href="#5-2-3-Apiary-io" class="headerlink" title="5.2.3 Apiary.io"></a>5.2.3 Apiary.io</h3><p>Apiary.io 是一个协作式的托管站点。它支持 Markdown 格式的 API 文档，可以围绕设计过程进行社交，并且支持模拟数据的托管实现，以便于在 API 实现之前对其进行测试。 网址：<a href="http://apiary.io/">http://apiary.io</a></p><h3 id="5-2-4-Hydra-Cg"><a href="#5-2-4-Hydra-Cg" class="headerlink" title="5.2.4 Hydra-Cg"></a>5.2.4 Hydra-Cg</h3><p>Hydra-Cg 是一种超媒体描述语言，通过像 JSON-LD 这样的标准方便地实现数据关联和并其它数据源的交互。网址：<a href="http://www.hydra-cg.com/">http://www.hydra-cg.com</a></p><h2 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h2><p>有一些用于构建、生成和使用 RESTful 系统的库和框架。虽然任何 Web 服务器都可以配置成提供 REST API，但有了这些框架、库和环境可以让过程变得更容易。</p><p>以下概述了一些主流的环境：</p><h3 id="5-3-1-JAX-RS"><a href="#5-3-1-JAX-RS" class="headerlink" title="5.3.1 JAX-RS"></a>5.3.1 JAX-RS</h3><p>JAX-RS 规范为 JEE 环境增加了对 REST 的支持。网址：<a href="https://jax-rs-spec.java.net/">https://jax-rs-spec.java.net</a></p><h3 id="5-3-2-Restlet"><a href="#5-3-2-Restlet" class="headerlink" title="5.3.2 Restlet"></a>5.3.2 Restlet</h3><p>Restlet API 是构建用于生产和消费 RESTful 系统的 Java API 先行者之一。它专注于为客户端和服务器生成一些非常干净、强大的 API。</p><p>Restlet Studio 是一个免费工具，能够在 RAML 和基于 swagger 的 API 描述之间进行转换，支持 Restlet、 Node 和 JAX-RS 服务器和客户端的骨架和 Stub 代码。网址：<a href="http://restlet.org/">http://restlet.org</a></p><h3 id="5-3-3-NetKernel"><a href="#5-3-3-NetKernel" class="headerlink" title="5.3.3 NetKernel"></a>5.3.3 NetKernel</h3><p>Netkernel 是一个比较有趣的 RESTful 系统。它基于微内核，是支持各种架构风格环境的代表。Netkernel 受益于在软件体系结构中采用 Web 的经济属性。你可以把它想象成“在内部引入 REST”。虽然任何基于 REST 的系统在外面看起来都一样，但在运行环境内部 NetKernel 看起来也一样。网址：<a href="http://netkernel.org/">http://netkernel.org</a></p><h3 id="5-3-4-Play"><a href="#5-3-4-Play" class="headerlink" title="5.3.4 Play"></a>5.3.4 Play</h3><p>两个主要的 Scala REST 框架之一。网址：<a href="https://www.playframework.com/">https://www.playframework.com</a></p><h3 id="5-3-5-Spray"><a href="#5-3-5-Spray" class="headerlink" title="5.3.5 Spray"></a>5.3.5 Spray</h3><p>两个主要的 Scala REST 框架之一。它设计成配合 Akka actor 模型一起工作。网址：<a href="http://spray.io/">http://spray.io</a></p><h3 id="5-3-6-Express"><a href="#5-3-6-Express" class="headerlink" title="5.3.6 Express"></a>5.3.6 Express</h3><p>两个主要的 Node.js REST 框架之一。网址：<a href="http://expressjs.com/">http://expressjs.com</a></p><h3 id="5-3-7-hapi"><a href="#5-3-7-hapi" class="headerlink" title="5.3.7 hapi"></a>5.3.7 hapi</h3><p>两个主要的 Node.js REST 框架之一。网址：<a href="http://hapijs.com/">http://hapijs.com</a></p><h3 id="5-3-8-Sinatra"><a href="#5-3-8-Sinatra" class="headerlink" title="5.3.8 Sinatra"></a>5.3.8 Sinatra</h3><p>Sinatra 是一个领域特定语言（DSL），用来在 Ruby 中创建 RESTful 应用程序。网址：<a href="http://www.sinatrarb.com/">http://www.sinatrarb.com</a></p><h2 id="5-4-客户端"><a href="#5-4-客户端" class="headerlink" title="5.4 客户端"></a>5.4 客户端</h2><p>通过浏览器调用 REST API 是可行的，但是还有其它客户端可用于测试和构建面向资源的系统。</p><h3 id="5-4-1-curl"><a href="#5-4-1-curl" class="headerlink" title="5.4.1 curl"></a>5.4.1 curl</h3><p>curl 是流行的库和命令行工具之一，支持在各种资源上调用各种协议。网址：<a href="https://curl.haxx.se/">https://curl.haxx.se</a></p><h3 id="5-4-2-httpie"><a href="#5-4-2-httpie" class="headerlink" title="5.4.2 httpie"></a>5.4.2 httpie</h3><p>httpie 是一个非常灵活和易用的客户端，支持通过 HTTP 与资源进行交互。网址：<a href="https://httpie.org/">https://httpie.org</a></p><h3 id="5-4-3-Postman"><a href="#5-4-3-Postman" class="headerlink" title="5.4.3 Postman"></a>5.4.3 Postman</h3><p>健全的 API 测试需要能够捕获和重播请求，支持各种身份验证和授权方案等功能。以前的命令行工具允许这样做，但 Postman 是一个较新的桌面应用程序，让这些工作对于开发团队来说变得更容易。网址：<a href="https://www.getpostman.com/">https://www.getpostman.com</a></p><h1 id="6-书籍"><a href="#6-书籍" class="headerlink" title="6. 书籍"></a>6. 书籍</h1><ul><li>“RESTful Web APIs”：Leonard Richardson、Mike Amundsen 和 Sam Ruby，2013，O’Reilly 出版社</li><li>“RESTful Web Services Cookbook”：Subbu Allamaraju，2010，O’Reilly 出版社</li><li>“REST in Practice”：Jim Webber、Savas Parastatidis 和 Ian Robinson，2010，O’Reilly 出版社。中文版《REST实战(中文版)》</li><li>“Restlet in Action” by Jerome Louvel and Thierry Boileau，2011，Manning 出版社</li><li>“Resource-Oriented Architecture Patterns for Webs of Data (Synthesis Lectures on the Semantic Web: Theory and Technology)”：Brian Sletten，2013，Morgan &amp; Claypool</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源：&lt;a href=&quot;http://t.cn/EVBQ2Ug&quot;&gt;http://t.cn/EVBQ2Ug&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST（Representational State Transfer）架构风格是一种世界观，把信息提升为架构中的一等公民。通过 REST 可以</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="restful" scheme="http://ai.mak.cn/tags/restful/"/>
    
  </entry>
  
</feed>
