<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2024-12-17T09:56:05.262Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Transformer</title>
    <link href="http://ai.mak.cn/2024/05/18/ai/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Transformer%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    <id>http://ai.mak.cn/2024/05/18/ai/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Transformer%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</id>
    <published>2024-05-17T16:00:00.000Z</published>
    <updated>2024-12-17T09:56:05.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Transformer"><a href="#深入理解Transformer" class="headerlink" title="深入理解Transformer"></a>深入理解Transformer</h1><blockquote><p>作者：得物技术<br>链接：<a href="https://juejin.cn/post/7358743626166222874">https://juejin.cn/post/7358743626166222874</a><br>来源：稀土掘金</p></blockquote><blockquote><ul><li>本文深入介绍了 Transformer 技术原理，包括注意力机制、架构设计、Token 处理、编解码器工作流程等，还讲解了 Transformer-XL 提升上下文长度的方法，分享了 Transformer 相关应用，如 BERT 掩词填充、BART 文本摘要等，并提供了参考文档。</li></ul></blockquote><p>谷歌在2017年发布Transformer架构的论文时，论文的标题是：Attention Is All You Need。重点说明了这个架构是基于注意力机制的。</p><h2 id="一、什么是注意力机制"><a href="#一、什么是注意力机制" class="headerlink" title="一、什么是注意力机制"></a><strong>一</strong>、<strong>什么是注意力机制</strong></h2><p>在深入了解Transformer的架构原理之前，我们首先要了解下，什么是注意力机制。人类的大脑对于信息的获取也存在注意力机制，下面我举几个简单的例子：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0012f40763e84cc8baa4a6063c572357~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=293&s=137911&e=png&b=daf9fe" alt="图片">从上面的图片中，我们可能更容易关注，颜色更深的字、字号更大的字，另外像“震惊”这种吸引人眼球的文案也非常容易吸引人的关注。我们知道在海量的互联网信息中，往往那些起着“标题党”的文章更能吸引人的注意，从而达到吸引流量的目的，这是一种简单粗暴的方式。另外在大量的同质化图片中，如果有一张图片它的色彩、构图等都别出一格，那你也会一眼就能注意到它，这也是一种简单的注意力机制。假设有以下这两段文字，需要翻译成英文：<strong>1、我在得物上买了最新款的苹果，体验非常好。</strong> <strong>2、我在得物上买了阿克苏的苹果，口感非常好。</strong> 我们人类能很快注意到第一段文字中的苹果是指苹果手机，那么模型在翻译时就需要把他翻译成iPhone，而第二段文字中的苹果就是指的苹果这种水果，模型翻译时就需要将他翻译成apple。人类的大脑为什么能分辨出这两个苹果是指代的不同的意思呢？原因就是人类的大脑能从上下文中获取到关键信息，从而帮助我们理解每种苹果是什么意思。其实说到这里，我们就已经揭开了Transformer架构的核心，即注意力机制的原理：从文本的上下文中找到需要注意的关键信息，帮助模型理解每个字的正确含义。但是实际的实现方式又是非常复杂的。接下来让我们一起深入理解下Transformer的架构原理。</p><h2 id="二、Transformer架构设计"><a href="#二、Transformer架构设计" class="headerlink" title="二、Transformer架构设计"></a><strong>二</strong>、<strong>Transformer架构设计</strong></h2><p>Transformer的架构设计如下图所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59a5ad40a7f348feb23baf45a07b2dfe~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=672&h=1066&s=16767&e=png&b=fff6df" alt="图片"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ee0296b74bc4dd5ad99c446d3c8c115~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=680&h=980&s=241104&e=png&b=fdf7f7" alt="图片">Transformer架构中有两个核心的组件Encoder和Decoder，左边的这张图是Transformer架构的一个简单表示形式，右边的这张图是Transformer架构的一个完整表示形式，其中有一个重要的Multi-Head Attention组件，称为注意力层。Transformer架构中的两个核心的组件Encoder和Decoder，每个组件都可以单独使用，具体取决于任务的类型：</p><ul><li>Encoder-only models: 适用于需要理解输入的任务，如句子分类和命名实体识别。</li><li>Decoder-only models: 适用于生成任务，如文本生成。</li><li>Encoder-decoder models 或者 sequence-to-sequence models: 适用于需要根据输入进行生成的任务，如翻译或摘要。</li></ul><h2 id="三、理解Transformer中的Token"><a href="#三、理解Transformer中的Token" class="headerlink" title="三、理解Transformer中的Token"></a><strong>三</strong>、<strong>理解Transformer中的Token</strong></h2><p>因为模型是无法直接处理文本的，只能处理数字，就跟ASCII码表、Unicode码表一样，计算机在处理文字时也是先将文字转成对应的字码，然后为每个字码编写一个对应的数字记录在表中，最后再处理。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0e81aa7c724b89862bc74f56667b48~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=713&h=368&s=231277&e=png&b=eeee80" alt="图片"></p><p><strong>将文本拆分成token</strong></p><p>所以模型在处理文本时，第一步就是先将文本转换成对应的字码，也就是大模型中的token，但是怎么将文本转换成对应的token却是一个复杂的问题，在Transformers(HuggingFace提供的一个对Transformer架构的具体实现的组件库)中提供了专门的Tokenizer分词器来实现这个任务，一般来说有以下几种方式：</p><p><strong>基于单词的分词器</strong></p><p>第一种标记器是基于单词的(word-based)。它通常很容易设置和使用，只需几条规则，并且通常会产生不错的结果。例如，在下图中，目标是将原始文本拆分为单词，并为每个单词找到一个映射的数字表达：将文本拆分成单词，也有很多不同的方式，比如通过空格来拆分、通过标点符号来拆分。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093a0cc2b57e4b878bc43d525fb555b1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=234&s=28625&e=png&b=ffffff" alt="图片">如果我们想使用基于单词的标记器(tokenizer)完全覆盖一种语言，我们需要为语言中的每个单词都创建一个数字标记，这将生成大量的标记。除此之外，还可能存在一些无法覆盖的单词，因为单词可能存在很多的变种情况，比如：dogs是dog的变种，running是run的变种。如果我们的标识符中没有覆盖所有的单词，那么当出现一个未覆盖的单词时，标记器将无法准确知道该单词的数字标记是多少，进而只能标记为未知：UNK。如果在文本转换的过程中有大量的文本被标记为UNK，那么也将影响后续模型推理。</p><p><strong>基于字符的标记器</strong></p><p>为了减少未知标记数量的一种方法是使用更深一层的标记器(tokenizer)，即基于字符的(character-based)标记器(tokenizer)。基于字符的标记器(tokenizer)将文本拆分为字符，而不是单词。这有两个主要好处：</p><ul><li>词汇量要小得多。</li><li>未知的标记(token)要少得多，因为每个单词都可以从字符构建。</li></ul><p>但是这里也出现了一些关于空格和标点符号的问题：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678e68a6a5f3414a946017eede9d777d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=77&s=15103&e=png&b=f4efff" alt="图片">这种方法也不是完美的。由于现在表示是基于字符而不是单词，因此人们可能会争辩说，从直觉上讲，它的意义不大：每个字符本身并没有多大意义，而单词就是这种情况。然而，这又因语言而异；例如，在中文中，每个字符比拉丁语言中的字符包含更多的信息。另一件要考虑的事情是，我们的模型最终会处理大量的词符(token)：虽然使用基于单词的标记器(tokenizer)，单词只会是单个标记，但当转换为字符时，它很容易变成 10 个或更多的词符(token)。为了两全其美，我们可以使用结合这两种方法的第三种技术：<strong>子词标记化(subword tokenization)</strong> 。</p><p><strong>基于子词的标记器</strong></p><p>子词分词算法依赖于这样一个原则，<strong>即不应将常用词拆分为更小的子词，而应将稀有词分解为有意义的子词。</strong> 例如，“annoyingly”可能被认为是一个罕见的词，可以分解为“annoying”和“ly”。这两者都可能作为独立的子词出现得更频繁，同时“annoyingly”的含义由“annoying”和“ly”的复合含义保持。下面这张图，展示了基于子词标记化算法，如何标记序列“Let’s do tokenization!”：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d7c23fbcfa4978bb05d6b485b51514~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=79&s=19357&e=png&b=f4efff" alt="图片">这些子词最终提供了很多语义含义：例如，在上面的示例中，“tokenization”被拆分为“token”和“ization”，这两个具有语义意义同时节省空间的词符(token)（只需要两个标记(token)代表一个长词）。这使我们能够对较小的词汇表进行相对较好的覆盖，并且几乎没有未知的标记。</p><p><strong>向量、矩阵、张量</strong></p><p>了解完token之后，我们还要了解下向量、矩阵和张量的概念，因为他们是大模型计算中基础的数据结构。</p><p><strong>向量(Vector)</strong></p><p>向量是一个有序的数字列表，通常用来表示空间中的点或者方向。在数学中，向量可以表示为一个列向量或行向量，具体取决于上下文。例如，一个三维空间中的点可以用一个三维列向量表示，如 <strong>v</strong>&#x3D;[x,y,z]T，其中 x,y,z 是实数。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4d6e10f7c749bbac754abd7a0fed51~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=580&h=148&s=2904&e=png&b=b1dd9f" alt="图片"></p><p><strong>矩阵(Matrix)</strong></p><p>矩阵是一个二维数组，由行和列组成，可以被视为向量的一个特例。矩阵在数学中用于表示线性变换、系统方程的系数等。矩阵的维度通常表示为 m×n，其中 m 是行数，n 是列数。例如，一个 4×3 的矩阵有四行三列。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e8c534a55e44f8e91289aad7224bfac~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=320&h=418&s=2874&e=png&b=dcdde0" alt="图片"></p><p><strong>张量(Tensor)</strong></p><p>张量是一个多维数组，可以看作是向量和矩阵的更底层的表示，向量和矩阵是张量的特例。例如向量是一维的张量，矩阵是二维的张量。张量可以有任意数量的维度，而不仅仅是一维（向量）或二维（矩阵）。张量在物理学中用来表示多维空间中的物理量，如应力、应变等。在深度学习中，张量用于表示数据和模型参数的多维结构。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b49f57afd704065b77f84befd690645~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=376&h=308&s=17035&e=png&b=f3c890" alt="图片"></p><p><strong>将token转换成向量</strong></p><p>在获取到token之后，再将每个token映射为一个数字，当然了，Transformer能够处理的数据，并不是简单的1&#x2F;2&#x2F;3这样的数字，而是一种向量数据，如下图所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5c6f8c2cd646d98330eaf04fb13dea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=776&h=282&s=6746&e=png&b=ffffff" alt="图片"></p><p><strong>将向量转换成嵌入</strong></p><p>得到向量之后，再将向量转换成词嵌入，也就是我们所熟知的embeddings。在Transformer模型中，编码器接收的词嵌入（embeddings）可以被视为矩阵。这些词嵌入是将输入序列中的每个token映射到一个固定维度的向量空间中的结果。每个词嵌入都是一个向量，而这些向量按顺序排列形成一个矩阵。具体来说，如果你有一个句子或序列，其中包含了N个token，每个token都被映射到一个d维的向量空间中，那么你将得到一个N×d的矩阵，其中N是序列的长度，d是嵌入向量的维度。这个矩阵就是词嵌入矩阵，它是一个二维张量，因为它具有两个维度：序列长度（时间步长）和嵌入维度。在Transformer模型的编码器中，这个嵌入矩阵首先会通过一个线性层（可选）进行处理，然后添加位置编码（positional encoding），最后输入到自注意力（self-attention）和前馈网络（feed-forward network）等组件中进行进一步的处理，具体细节我接下来会进行详细解释。总结来说，编码器接收的词嵌入是一个矩阵，这个矩阵可以被视为一个二维张量，其中包含了序列中每个词的d维向量表示。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ebed94e1f43e99a85449e0b1cb216~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=562&s=181589&e=png&b=dafcfe" alt="图片"></p><h2 id="四、理解Transformer的编解码器"><a href="#四、理解Transformer的编解码器" class="headerlink" title="四、理解Transformer的编解码器"></a><strong>四</strong>、<strong>理解Transformer的编解码器</strong></h2><p>下面让我们以文本翻译来深入理解Transformer中的Encoder和Decoder是怎样工作的，假设我们有以下这个翻译任务，输入是一段法文，输出是英文。整个流程是Transformer将输入的input，经过Encoders处理后，将结果投递到Decoders中处理，最后输出翻译后的结果。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8288479eccc94453b9cfdf9d048f9c65~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=697&h=422&s=32125&e=png&b=fdfaf9" alt="图片">但是实际在Transformer的内部，是由多个独立的Encoder和Decoder组成的，这里我们使用6个做验证，当然我们也可以使用其他数量的Encoder和Decoder，笔者怀疑6个是经过验证后相对折中的一个值。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eefd8b316e414ad193183072eaaa62e1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=900&h=610&s=104117&e=png&b=fdfbfa" alt="图片">这6个Encoder和Decoder在结构上都是相同的，但是Encoder和Decoder的内部还有更细分的组件：每一层的Encoder由2个子组件组成：自注意力层和前馈网络层，<strong>其中文本的输入会先流入自注意力层，正是由于自注意力层的存在，帮助Encoder在对特定文本进行遍历时，能够让Encoder观察到文本中的其他单词</strong>。然后自注意力层的结果被输出到前馈网络层。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bca0128b67d54c8caf9630f707ca9100~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=749&h=339&s=27550&e=png&b=ffffff" alt="图片">每一层的Decoder由3个子组件组成：除了自注意力层、前馈网络层，<strong>在两者之间还有一个编解码注意力层，这个组件主要是帮助Decoder专注于输入句子的相关部分</strong>。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f873eb1637ac46d8ab79952502b65af4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=877&h=291&s=34928&e=png&b=ffffff" alt="图片"></p><h2 id="五、理解Token在编码器中的流转"><a href="#五、理解Token在编码器中的流转" class="headerlink" title="五、理解Token在编码器中的流转"></a><strong>五</strong>、<strong>理解Token在编码器中的流转</strong></h2><p>现在我们已经知道了Transformer模型中的核心组件Encoder和Decoder，接下来我们来看Token在Transformer中是怎么流转的，换句话说Encoder和Decoder是怎么处理Token的。拿最开始的法文翻译的例子，模型将文本转换token后，紧接着就是将每个token转换成向量表达，在下图中，我们用x1、x2、x3这样的box来表示每个token的向量：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6062eb2df44c88b6ae3afa6dcb054b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=773&h=138&s=21424&e=png&b=ffffff" alt="图片">得到每个token的向量之后，从最底层的Encoder开始，每个token会沿着自己的路径从下往上流转，经过每一个Encoder，对每个Encoder来说，共同点是他们接收的向量的维度都是相同的，为了保证这一点，所有的token都需要被embedding成相同大小的向量。</p><p><strong>对Token进行位置编码</strong></p><p>在流经每个Encoder时，向量都会从自注意力层流向前馈层，如下图所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25b413c86074abd8d2597cfef9539dd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=903&h=590&s=52118&e=png&b=fff8f7" alt="图片">这里需要注意的是，<strong>不同位置的向量在进入自注意力层的时候，相互之间是有依赖关系的，这就是注意力层需要关注的上下文的信息。</strong> 而当自注意力层处理后的向量进入前馈层后，前馈层是可以并行计算以提升性能的，因为在前馈层中向量之间不存在依赖关系。每个向量在经过Encoder处理后，得到的仍然是一个相同大小的向量，然后再提交给下一个Encoder进行处理。</p><p>为什么说不同位置的向量相互之间是有依赖关系的呢？我们可以想象一下，如果不关注一整个句子中token的位置信息，那么翻译出来的结果是不准确的，比如：</p><ol><li><strong>Sam is always looking for trouble</strong></li><li><strong>Trouble is always looking for Sam</strong></li></ol><p>为了让模型知道每个token的位置信息，传统的RNN网络的做法是，顺序处理每个token，这样在处理当前token时，可以往前查看已经处理过的token的信息，但是缺点是所有的token节点都共用一套相同的参数，即下图中的：</p><p>U：输入参数</p><p>W：隐藏参数</p><p>V：输出参数</p><p><strong>由于RNN的窗口较小，这种方案带来的问题是，当token数变大时，模型无法参考更早之前已经参考过的token，这样就会造成上下文记忆丢失。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3478560935041b38b8802ca67062ad0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=864&h=353&s=98342&e=png&b=fefefe" alt="图片">那么Transformer是怎么对token进行位置编码的呢？首先我们知道每个token会被转换成512维(或更高的维度)的向量，比如：[0.12142,0.34181,….,-0.21231] 可以将这个向量分为两个部分，奇数和偶数部分。奇数部分使用cos函数，加上当前token的位置信息pos，通过cos编码得到一个奇数编码值；偶数部分使用sin函数，加上当前token的位置信息pos，通过sin编码得到一个偶数编码值；<strong>最后拿token的embeddings和pos的embeddings相加，得到位置编码后的positional input embeddings。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f11e50479854b6fa1ddfa8268c9a0a5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=877&h=676&s=129759&e=png&b=010101" alt="图片"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f435fdbe9a4b7d92a3a1533a78c030~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=884&h=681&s=129345&e=png&b=010101" alt="图片"></p><p><strong>自注意力机制</strong></p><p>有了位置编码的信息后，模型将接收经过位置编码的embeddings输入，为了方便描述，我们把token换成更简单的文本，如下图所示，Encoder在接收到两个向量之后，通过自注意力层，将原始向量转换成携带了自注意力值的向量，也就是图中的z1和z2。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5778c1edfc64a4c9c42621c79f69f5b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=657&s=64603&e=png&b=fff9f8" alt="图片"></p><p><strong>计算注意力值</strong></p><p>那z1和z2这两个向量是怎么得到的呢？原论文中给出了计算公式：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82707b451c4442b09b2c468889eea6c2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=440&h=82&s=7578&e=png" alt="图片">这个公式是用来计算注意力值的，借助了Q、K、V这三个矩阵：首先通过Q矩阵**和转置后的K矩阵转置相乘，得到结果后再除以dk的开平方，再通过softmax函数得到一个归一化的结果，最后将归一化的结果和矩阵V相乘就得到了表示注意力值的矩阵。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8a8de27d5f4abe9094fa5003b39776~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=893&h=349&s=14389&e=png&b=ffffff" alt="图片">这里的Q、K、V三个矩阵(查询矩阵、键矩阵、值矩阵)是通过原始token的embedding矩阵计算得到的，具体的方法是，先训练出三个矩阵：Wq,Wk,Wv, 然后使用embedding处理后的X矩阵和这三个矩阵相乘得到：</p><p><strong>Q&#x3D;Wq * X</strong></p><p><strong>K&#x3D;Wk * X</strong></p><p><strong>V&#x3D;Wv * X</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050c3ab21ac1434ea7f2b3d92b75e1cf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=581&h=658&s=13223&e=png&b=ffffff" alt="图片"><strong>需要注意的是我们embedding输入原本是向量，并不是矩阵，这里是将所有的向量打包之后，形成了一个矩阵，方便矩阵之间的计算。</strong> 下面我们一步步了解下注意力值是怎么计算的，使用原始的embedding，而不是打包后的矩阵，<strong>首先模型将会为句子中的每个token都计算出一个score分数，这个分数表示了该token对句子中其他token的关注程度，分数越高关注度越高。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/770bcbac42004c0eb9f8b14e05e06f84~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=697&s=87041&e=png&b=ffffff" alt="图片">但是需要注意的是这里计算得到的中间向量q、k、v的维度是<strong>64维</strong>，小于Encoder接收的输入向量的维度，这是一个经过计算后得到的相对稳定的数值。如下图所示，当我们在计算Tinking这个token的注意力值时，会依次计算出Thinking对其他token(在这里也就是Thinking和Machines)的注意力值，计算token1对其他各个token的score的方式是：q1 与 k1 做点积，q1 与 k2 做点积。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87a6ccfaa33e4973844d82aa126df4bc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=685&h=358&s=20465&e=png&b=ffffff" alt="图片">得到每个score后，再把score除以K向量维度的平方根也就是√64&#x3D;8，然后将结果通过Softmax进行归一化，得到一个0<del>1之间的概率值，所有的归一化的加和值等于1。![图片](<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c612b31ae464ce592b2f17a644dfba3">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c612b31ae464ce592b2f17a644dfba3</a></del>tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w&#x3D;867&amp;h&#x3D;546&amp;s&#x3D;35500&amp;e&#x3D;png&amp;b&#x3D;ffffff)最后将Softmax的值，与V向量相乘，得到自注意力层的输出结果向量：z1和z2，需要注意的是相乘的过程中会将不相关的token的关注度降低。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39f75aa4e9e44189bbd34c6d023baff4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=786&h=747&s=40925&e=png&b=ffffff" alt="图片">到这里其实已经把Encoder是怎么计算每个token对句子中其他token的注意力值的方法解释清楚了，下面我们用一张图从更高的层面来观察这个过程，假设我们想要翻译下面这个句子：<strong>The animal didn’t cross the street because it was too tired.</strong> 句子中的it是表示什么呢，是animal还是street？模型就是通过自注意力值来确定的，当对it进行编码时，Encoder会对句子中的每个token都计算一遍注意力值，模型会将it更关注的“The animal”编码到it中。这样模型在后续的处理过程中就能知道it指代的是“The animal”。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e33ed7ffc7e1414c840370969f5fc3c6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=437&h=413&s=33175&e=png&b=fef7f6" alt="图片"></p><p><strong>多头注意力机制</strong></p><p>论文中通过引入多个Encoder形成了一种“多头注意力”的机制，对自注意力层进行了能力的提升，主要包括：</p><ol><li>多头注意力扩展了模型关注不同位置的能力</li><li>多头注意力为自注意力层提供了多个子空间</li></ol><p>Transformer模型使用了8个注意力头，所以在计算每个Encoder的输出时，我们会得到8个z向量。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3bea63f03b486297ff4804f1365afc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=638&s=43187&e=png&b=ffffff" alt="图片"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0ce1bd6398842b7b2b82e3f37868a88~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1018&h=483&s=30082&e=png&b=ffffff" alt="图片">但是前馈层只能接收1个z向量，所以我们还需要将这8个z向量做压缩得到1个向量，具体的做法是将这8个z向量链接起来，然后乘以一个附加的权重矩阵Wo，最后得到z向量，如下图所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0c0449f7d491c90d043ceda3171d9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=597&s=68367&e=png&b=ffffff" alt="图片">最后我们用一张完整的大图来描述下在多个Encoder下，注意力值的计算过程，也就是多头注意力机制：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6661db08ea6b4e468b83abf6f5863120~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=605&s=128979&e=png&b=ffffff" alt="图片">下面我们可以看下，在多头注意力机制下，在编码it这个token时，模型在注意哪些其他的token：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0628d2f3618346ad92352ec43ba1dcf8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=438&h=395&s=35228&e=png&b=fdf8f8" alt="图片"><strong>可以看到其中一个头(橙色)更关注“The Animal”，因为这两个token对应的橙色更深，另外一个头(绿色)则更关注“tired”，因为这两个token对应的绿色更深。</strong></p><p><strong>残差网络</strong></p><p>首先我们了解下什么是残差网络，残差网络（Residual Network，简称ResNet）是一种深度卷积神经网络（CNN）架构，由Microsoft Research Asia的Kaiming He**等人在2015年提出。ResNet的核心思想是通过引入“残差学习”（residual learning）来解决深度神经网络训练中的退化问题（degradation problem）。在传统的深度神经网络中，随着网络层数的增加，理论上网络的表示能力应该更强，但实际上，过深的网络往往难以训练，性能反而不如层数较少的网络。这种现象被称为“退化问题”，即随着网络深度的增加，网络的准确率不再提升，甚至下降。ResNet通过引入“跳跃连接”（skip connections）或“捷径连接”（shortcut connections）来解决这个问题。在ResNet中，输入不仅传递给当前层，还直接传递到后面的层，跳过一些中间层。这样，后面的层可以直接学习到输入与输出之间的残差（即差异），而不是学习到未处理的输入。这种设计允许网络学习到恒等映射（identity mapping），即输出与输入相同，从而使得网络可以通过更简单的路径来学习到正确的映射关系。在Transformer模型中，残差网络的使用主要是为了解决自注意力机制（self-attention）带来的问题。Transformer模型完全基于注意力机制，没有卷积层，但其结构本质上也是深度网络。在Transformer中，每个编码器（encoder）和解码器（decoder）层都包含自注意力和前馈网络，这些层的参数量非常大，网络深度也很容易变得很深。使用残差连接可以帮助Transformer模型更有效地训练深层网络。在Transformer的自注意力层中，输入通过自注意力和前馈网络后，与原始输入相加，形成残差连接。这种设计使得网络即使在增加更多层数时，也能保持较好的性能，避免了退化问题。总结来说，残差网络在Transformer模型中的应用解决了以下几个问题：</p><ol><li><strong>缓解退化问题：</strong> 通过残差学习，使得网络即使在增加层数时也能保持或提升性能。</li><li><strong>加速收敛：</strong> 残差连接提供了梯度的直接路径，有助于梯度在深层网络中的传播，加速训练过程。</li><li><strong>提高表示能力：</strong> 允许网络学习更复杂的函数，同时保持对简单函数的学习能力。</li></ol><p>Transformer模型的成功部分归功于残差连接的设计，这使得它能够构建更深、更强大的模型，从而在自然语言处理（NLP）和计算机视觉等领域取得了显著的成果。<strong>可以使用下面这张图来解释残差网络，原始向量x在经过自注意力层之后得到z向量，为了防止网络过深带来的退化问题，Transformer模型使用了残差网络，具体做法是使用计算得到的z矩阵，在和原始输入的x矩阵做残差链接，即图中的X+Z，然后使用LayerNorm函数进行层归一化，计算得到新的z向量，然后输入到前馈层。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8c412a4463458a87d04c47092172e4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=712&h=666&s=59798&e=png&b=fffbfa" alt="图片">将 <strong>Add &amp; Normalize</strong> 简化之后表示为如下：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d54dcf5be99426c9eeb12dd416070b2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=666&h=483&s=48032&e=png&b=fffcfc" alt="图片"></p><p><strong>前馈网络</strong></p><p>归一化后的残差输出，被送入点对点前馈网络进行进一步处理，点对点前馈网络是几个线性层，中间有ReLU激活函数，将点对点输出的结果与前馈网络的输入进行相加做残差链接，然后再做进一步的归一化。点对点前馈网络主要用于进一步处理注意力的输出，让结果具有更丰富的表达。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c325276afe5419c9309efb34bce9480~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=936&h=716&s=116576&e=png&b=000000" alt="图片">到这里编码器就已经介绍完了，编码器输出的结果中携带了每个token的相关注意力信息，将用以帮助解码器在解码过程中关注输入中的特定的token信息。</p><h2 id="六、理解Token在解码器中的流转"><a href="#六、理解Token在解码器中的流转" class="headerlink" title="六、理解Token在解码器中的流转"></a><strong>六</strong>、<strong>理解Token在解码器中的流转</strong></h2><p>每个解码器拥有与编码器相似的结构但也有不同的地方，它有两个多头注意力层，一个点对点前馈网络层，并且在每个子层之后都有残差链接和层归一化。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12979fcd9e1d4c1ba44e0ffd0d4281c9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=470&h=1306&s=124247&e=png&b=fefefe" alt="图片">解码器是自回归的，它将前一个Decoder输出的结果和来自编码器输出的注意力信息当做解码器的输入。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32f24652d7d47a4b6e48e523ddcbae0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=614&s=174102&e=png&b=fff7f4" alt="图片">这里我们需要了解清楚，解码器的先前的输出结果是怎么得到的，即解码器的第一个输出结果从哪得到的。在Transformer模型的训练过程中，解码器的第一个输出序列通常是根据特定的起始标记（start token）或者一个预先定义的初始状态得到的。这个起始标记是一个特殊的符号，它标志着输出序列的开始。以下是解码器如何获得第一个输出序列的详细过程：<strong>1. 起始标记：</strong> 在训练阶段，解码器的输入序列通常以一个起始标记（例如）开始。这个标记是一个预定义的词汇表中的词，它告诉解码器输出序列的生成即将开始。<strong>2. 初始化状态：</strong> 解码器在开始生成输出之前，会接收到编码器的输出，即编码器的上下文向量。这些上下文向量包含了输入序列（如源语言文本）的信息。在某些情况下，解码器的初始状态也可以通过一个额外的向量（如位置编码）来初始化，以提供序列中每个位置的信息。<strong>3. 自注意力机制：</strong> 在第一个时间步，解码器使用自注意力机制处理起始标记。由于此时没有之前的输出，自注意力机制会关注起始标记本身，以及可能的位置编码。<strong>4. 编码器-解码器注意力：</strong> 解码器接着使用编码器-解码器注意力机制来关注编码器的输出。这允许解码器在生成第一个输出时就利用到输入序列的信息。<strong>5. 输出层：</strong> 解码器的输出层将上述步骤得到的向量转换为概率分布，这个分布表示了词汇表中每个词作为第一个输出的概率。<strong>6. 选择第一个输出：</strong> 在训练阶段，解码器可能会使用强制策略，这意味着解码器的第一个输出会直接使用目标序列中的第一个词。在推理阶段，解码器会根据概率分布选择概率最高的词作为第一个输出。<strong>7. 迭代生成：</strong> 一旦获得了第一个输出，解码器就会将其作为下一个时间步的输入，并重复上述过程来生成后续的输出序列。在实际应用中，解码器的第一个输出序列的生成方式可能会根据具体的任务和模型配置有所不同。例如，在某些情况下，解码器可能会接收到一个完整的前缀序列，而不是单一的起始标记，这在文本摘要任务中较为常见。在这种情况下，解码器会基于这个前缀序列来生成剩余的输出序列。</p><p><strong>Masked多头注意力机制</strong></p><p>需要注意的是解码器中的第一层是一个特殊的多头注意力层，是一个执行了mask的注意力层，因为解码器是自回归的，并且依次生成结果token，我们需要防止它在处理某个token时，对未来的token进行处理，<strong>原因是模型在训练的时候，是不知道未来输出的token是什么的，为了保证训练过程和解码的过程的一致性，我们需要让解码器在计算某个token的注意力值的时候，只关注这个句子中已经出现过的token，而屏蔽掉句子中当前token之后的其他token的信息。</strong> 可以通过以下这张图来描述Mask的过程，当解码器在处理it时，应该把it之后的所有token屏蔽掉。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1032e811031e4b0191c6a429b8c3aeef~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=928&h=832&s=201434&e=png&b=fcf9f9" alt="图片"></p><p><strong>计算注意力值</strong></p><p>在解码器中计算注意力值时，是用Encoder最后的输出，和每一个Decoder进行交互，这就需要Decoder中的第二层Encoder-Decoder Attention。每个Decoder计算出结果之后，再作为输入传递给下一个Decoder。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1777def6d9af4fe9963659f73ce518c3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=703&s=111525&e=png&b=ffffff" alt="图片"></p><p><strong>线性分类器&amp;Softmax</strong></p><p>当最后一个Decoder计算完毕后，解码器得到了一个输出结果的向量数据。我们如何把它变成一个词呢？这就是最后一个 Linear 层的工作，后面是 Softmax 层。线性层是一个简单的全连接神经网络，它将解码器产生的向量投影到一个更大的向量中，称为 logits 向量。假设我们的模型知道从训练数据集中学习的 10,000 个独特的英语单词。这将使 logits 向量有 10,000 个单元格宽——每个单元格对应一个唯一单词的分数，这就是我们解释线性层模型输出的方式。然后，softmax 层将这些分数转换为概率（全部为正，全部加起来为 1.0）。选择概率最高的单元格，并生成与其关联的单词作为该时间步的输出。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a8e0c600e14c91900fe9d2f916134e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=869&h=561&s=53732&e=png&b=fffefe" alt="图片"></p><p><strong>编解码器的协同工作</strong></p><p>现在让我们看看编码器和解码器之间是如何协同工作的。编码器首先处理输入的文本token，然后输出一组注意力向量 K 和 V。这些向量将由每个解码器在其“编码器-解码器注意力”层中使用，这有助于解码器关注输入序列中的特定token的位置信息，具体计算注意力值的方法跟编码器中是一样的，<strong>需要注意的是，这里的K、V矩阵来自于编码器的输出，而Q矩阵来自于解码器的输入。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb7c17840eec47bfbbe9ff960c9b0736~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=671&s=121710&e=png&b=fefcfc" alt="图片">重复回归以上的步骤，直到出现结束符号的标识，表示解码器已完成其输出。每个步骤的输出在下一个时间步骤中被反馈到底部解码器，并且解码器像编码器一样向上反馈其解码结果。就像我们对编码器输入所做的那样，我们将位置编码嵌入并添加到这些解码器输入中以指示每个单词的位置。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d20a1917514e9db702c64ffd4e9811~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=603&s=110156&e=png&b=fefcfc" alt="图片">至此，已经分析完Transformer的编码器和解码器的全流程了。</p><h2 id="七、Transformer-XL怎样提升上下文长度"><a href="#七、Transformer-XL怎样提升上下文长度" class="headerlink" title="七、Transformer-XL怎样提升上下文长度"></a><strong>七</strong>、<strong>Transformer-XL怎样提升上下文长度</strong></h2><p>传统的Transformer模型中，上下文长度是固定的，主要有以下几个原因：</p><ol><li><strong>计算效率：</strong> 在最初的设计中，Transformer模型是为了处理序列到序列的任务，如机器翻译。对于这类任务，输入序列（如源语言句子）和输出序列（如目标语言句子）通常具有相似的长度，因此固定上下文长度可以简化模型设计，提高计算效率。</li><li><strong>模型复杂度：</strong> Transformer模型的核心是自注意力机制，该机制在计算时需要对序列中的每个元素进行成对的比较，以计算注意力权重。如果上下文长度不固定，那么每次添加或删除元素时，都需要重新计算整个序列的注意力权重，这会导致计算复杂度和内存需求急剧增加。</li><li><strong>训练稳定性：</strong> 固定长度的上下文可以提供稳定的训练环境，有助于模型学习到更加一致和可靠的表示。如果上下文长度不固定，模型可能需要在每次迭代中适应新的序列长度，这可能会影响训练的稳定性和模型的收敛速度。</li><li><strong>硬件限制：</strong> 在实际应用中，硬件资源（如GPU内存）是有限的。固定长度的上下文可以确保模型在任何时候都不会超出硬件资源的限制，从而避免因资源不足而导致的训练中断。</li><li><strong>模型泛化：</strong> 固定长度的上下文允许模型在训练时学习到特定长度范围内的依赖关系，这有助于模型在实际应用中泛化到类似的序列长度上。</li></ol><p>然而，固定上下文长度也带来了一些限制，特别是在处理长序列时，模型无法捕获超过固定长度的依赖关系，这限制了模型在某些任务（如长文本生成和理解）上的性能。为了解决这个问题，Transformer-XL等模型通过引入新的机制来允许处理更长的上下文，从而在不牺牲计算效率的情况下捕获更长期的依赖关系。国产开源公司月之暗面的大模型产品kimi，能够处理长达20万字的超长上下文，那么他是怎么做到的呢，核心是他的模型在Transformer的基础上做了扩展，实现了自己的Transformer-XL架构。Transformer-XL通过引入两个关键的技术改进来提升token上下文长度的处理能力：片段递归机制（segment-level recurrence）和相对位置编码机制（relative positional encoding）。</p><ol><li><strong>片段递归机制：</strong> 在传统的Transformer模型中，由于上下文长度是固定的，模型无法捕获超过预定义上下文长度的长期依赖性。Transformer-XL通过引入循环机制来解决这个问题。具体来说，它不再从头开始计算每个新片段的隐藏状态，而是重复使用之前片段中获得的隐藏状态，并将这些状态作为当前片段的“记忆”。这样，信息就可以在不同片段之间传递，从而捕获更长的依赖关系。这种机制允许模型在不引起时间混乱的前提下，超越固定长度去学习依赖性，同时解决了上下文碎片化问题。</li><li><strong>相对位置编码机制：</strong> 在Transformer-XL中，为了能够在不造成时间混乱的情况下重复使用状态，引入了相对位置编码的概念。相对位置编码与传统的绝对位置编码不同，它只编码token之间的相对位置关系，而不是token与固定起始点的绝对位置。这种编码方式使得模型能够在处理长序列时更有效地利用位置信息，并且可以泛化至比在训练过程中观察到的长度更长的注意力长度。</li></ol><p>通过这两种机制，Transformer-XL显著提升了模型在处理长序列时的性能。</p><h2 id="八、Transformer相关应用分享"><a href="#八、Transformer相关应用分享" class="headerlink" title="八、Transformer相关应用分享"></a><strong>八</strong>、<strong>Transformer相关应用分享</strong></h2><p><strong>使用BERT做掩词填充</strong></p><p>BERT（Bidirectional Encoder Representations from Transformers）是一种预训练语言表示模型，由Google AI在2018年提出。BERT的核心创新在于利用Transformer架构的编码器部分来学习文本数据的深层次双向表示。这种表示能够捕捉到文本中词汇的上下文关系，从而在多种自然语言处理（NLP）任务中取得了显著的性能提升。以下是BERT模型的一些关键特点：<strong>双向上下文理解：</strong> 与之前的单向语言模型不同，BERT通过在预训练阶段使用掩码语言模型（Masked Language Model, MLM）任务，学习了词汇在句子中的双向上下文信息。这意味着模型能够同时考虑一个词前后的词汇来理解其含义。<strong>预训练和微调：</strong> BERT采用了两阶段的训练策略。在预训练阶段，BERT在大量文本数据上进行无监督学习，学习语言的通用模式。在微调阶段，BERT可以通过少量标注数据针对特定任务进行有监督学习，以适应各种NLP任务，如情感分析、问答系统、命名实体识别等。<strong>Transformer架构：</strong> BERT基于Transformer的编码器部分，这是一种注意力机制（Attention Mechanism）的架构，它允许模型在处理序列数据时考虑序列中所有位置的信息。<strong>大规模预训练：</strong> BERT在非常大的文本语料库上进行预训练，这使得模型能够学习到丰富的语言知识。预训练的规模和质量对模型性能有重要影响。<strong>多样化的任务适应性：</strong> 通过微调，BERT可以适应多种不同的NLP任务，而不需要对模型架构进行大的修改。这使得BERT成为了一个灵活且强大的工具。BERT的推出标志着NLP领域的一个重大进展，它在多项NLP任务上刷新了记录，并催生了一系列基于BERT的改进模型，如RoBERTa、ALBERT、DistilBERT等。这些模型在不同的方面对BERT进行了优化，以提高性能、减少计算资源消耗或改善特定任务的表现。以下是使用BERT做掩词填充的示例，输入一段文本，让模型预测出下一个被掩盖的词：<a href="https://link.juejin.cn/?target=https://huggingface.co/google-bert/bert-base-uncased!%5B%E5%9B%BE%E7%89%87">huggingface.co&#x2F;google-bert…</a>](<a href="https://link.juejin.cn/?target=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5872dfd6621145abbcd888a90d28f7e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image%23?w=755&h=477&s=42042&e=png&b=ffffff">p3-juejin.byteimg.com&#x2F;tos-cn-i-k3…</a>)</p><p><strong>使用BART做文本摘要</strong></p><p>BART（Bidirectional and Auto-Regressive Transformers）是一种先进的自然语言处理（NLP）模型，它结合了BERT（Bidirectional Encoder Representations from Transformers）和GPT（Generative Pre-trained Transformer）的特点，用于文本理解和生成任务。BART模型特别擅长处理不同类型的文本噪声和序列变换，使其在多种NLP任务中表现出色。<strong>设计原理和结构</strong></p><p>BART是基于Transformer架构的自编码自回归模型。它通过两个主要步骤进行预训练：</p><ol><li>使用任意噪声函数破坏文本（例如，随机打乱句子顺序、删除或遮蔽token）。</li><li>模型学习重建原始文本。</li></ol><p>这种预训练方式使得BART能够有效地处理文本生成、翻译和理解等任务。BART的编码器是双向的，能够捕捉文本的前后文信息，而解码器是自回归的，能够基于前面的输出生成后续的内容。<strong>应用</strong>BART在多种NLP任务上取得了显著的成绩，包括但不限于：</p><ul><li>文本摘要</li><li>机器翻译</li><li>对话生成</li><li>问答系统</li><li>文本分类</li></ul><p><strong>与其他模型的对比</strong>与其他预训练模型相比，BART在处理文本生成任务时尤其出色。它在自然语言理解任务中也有很好的表现，与BERT和GPT等模型相比，BART在多个基准数据集上取得了竞争性或更好的结果。<strong>预训练和微调</strong>BART模型通过大量的文本数据进行预训练，然后在特定任务上进行微调。预训练阶段，模型学习如何从噪声文本中恢复原始文本，而微调阶段则是针对特定任务调整模型参数，以优化任务性能。以下是使用BART做文本摘要的应用示例：<a href="https://link.juejin.cn/?target=https://huggingface.co/facebook/bart-large-cnn!%5B%E5%9B%BE%E7%89%87">huggingface.co&#x2F;facebook&#x2F;ba…</a>](<a href="https://link.juejin.cn/?target=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed7a1c38b024c40814d3f6e3a658338~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image%23?w=708&h=615&s=111417&e=png&b=fefefe">p3-juejin.byteimg.com&#x2F;tos-cn-i-k3…</a>)</p><p><strong>使用DistilBERT做问答</strong></p><p>DistilBERT是一种轻量级的BERT模型，它通过知识蒸馏（knowledge distillation）技术从预训练的BERT模型中学习知识。这种方法的核心思想是使用一个较小的BERT模型作为“学生”模型，而原始的、较大的BERT模型则充当“教师”模型。在训练过程中，学生模型尝试复制教师模型的输出，以此来学习教师模型的知识。<strong>主要特点和优势</strong> <strong>模型大小和效率：</strong> DistilBERT的模型大小和参数量都比原始的BERT模型小，这使得它在资源受限的环境中（如移动设备）更加实用。它的推理速度也比BERT快，因为它需要处理的参数更少。<strong>知识蒸馏：</strong> DistilBERT使用了一种称为“软目标”的知识蒸馏方法。在这种方法中，学生模型不仅学习来自训练数据的标签，还学习教师模型的输出，这些输出被视为附加的、软性的标签。<strong>保持性能：</strong> 尽管DistilBERT的模型大小减小了，但它仍然保持了与原始BERT模型相当的性能，特别是在自然语言理解任务上。<strong>灵活性：</strong> DistilBERT保留了BERT模型的基本架构，包括Transformer的串联层，这使得它可以很容易地适应各种下游任务。<strong>结构和训练</strong>DistilBERT的结构相对简单，它仅保留了BERT的6层Transformer，删除了token type embedding和pooler层。在训练过程中，它使用了一种称为“模型压缩”的技术，通过这种方法，模型的层数被减半，同时从教师模型的层初始化学生模型的层。<strong>应用场景</strong>由于其较小的模型大小和较快的推理速度，DistilBERT适用于需要快速处理和低资源消耗的NLP任务，例如文本分类、情感分析、问答系统和语言模型等。总的来说，DistilBERT是一个高效的BERT变体，它通过知识蒸馏技术实现了模型的压缩，同时保持了良好的性能，特别适合在资源受限的环境中使用。以下是是使用DistilBERT做问答的实例：<a href="https://link.juejin.cn/?target=https://huggingface.co/distilbert/distilbert-base-uncased-distilled-squad!%5B%E5%9B%BE%E7%89%87">huggingface.co&#x2F;distilbert&#x2F;…</a>](<a href="https://link.juejin.cn/?target=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d3a52d36404160aaa932cf8bee79b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image%23?w=657&h=627&s=119134&e=png&b=fdfdfd">p3-juejin.byteimg.com&#x2F;tos-cn-i-k3…</a>)</p><p><strong>使用T5做文本翻译</strong></p><p>T5模型，全称为“Text-to-Text Transfer Transformer”，是由Google Research团队开发的一种自然语言处理（NLP）模型。T5模型的核心思想是将所有NLP任务统一转换为文本到文本（Text-to-Text）的格式，从而可以使用同一个模型和训练过程来处理多种不同的任务，如翻译、摘要、问答等。<strong>主要特点和优势</strong> <strong>统一的框架：</strong> T5模型通过将任务转换为文本到文本的格式，简化了不同NLP任务的处理方式。例如，对于翻译任务，输入可以是“translate English to German: [English text]”，输出则是翻译后的文本。基于Transformer架构：T5模型采用了Transformer的encoder-decoder架构，这是一种高效的网络结构，特别适合处理序列数据。<strong>预训练和微调：</strong> T5模型首先在大规模的数据集上进行预训练，学习语言的通用表示，然后可以针对特定任务进行微调，以优化任务性能。<strong>广泛的应用场景：</strong> T5模型可以应用于多种NLP任务，包括但不限于文本分类、命名实体识别、情感分析、机器翻译和对话生成等。<strong>高效的计算能力：</strong> T5模型的设计允许它高效地处理大规模数据集，并且具有强大的并行处理能力。<strong>训练和应用</strong>T5模型在训练时使用了一种称为“C4”的大规模数据集，这个数据集由经过清洗的Common Crawl数据组成。模型通过不同的预训练目标和策略进行训练，包括自回归、自编码和文本重排等。在应用方面，T5模型的强大语言表示能力和广泛的应用场景使其成为NLP领域的一个重要工具。它可以通过微调来适应不同的领域和任务，从而在多个NLP任务上取得优异的性能。T5模型通过其创新的Text-to-Text框架和基于Transformer的架构，在自然语言处理领域提供了一种新的解决方案，能够处理多种复杂的语言任务，并且具有很好的扩展性和适应性。以下是使用T5做文本翻译的示例：<a href="https://link.juejin.cn/?target=https://huggingface.co/google-t5/t5-base!%5B%E5%9B%BE%E7%89%87">huggingface.co&#x2F;google-t5&#x2F;t…</a>](<a href="https://link.juejin.cn/?target=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b35f058ef3646969c0ba292300f0ebb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image%23?w=666&h=451&s=33125&e=png&b=ffffff">p3-juejin.byteimg.com&#x2F;tos-cn-i-k3…</a>)</p><p><strong>使用GPT-2写小说</strong></p><p>GPT-2（Generative Pre-trained Transformer 2）是由OpenAI开发的自然语言处理（NLP）模型，它是GPT系列模型的第二代。GPT-2在自然语言理解和生成方面表现出色，能够生成连贯、相关且多样化的文本。这个模型在发布时因其生成文本的质量和多样性而受到广泛关注。<strong>主要特点和优势</strong> <strong>大规模预训练：</strong> GPT-2通过在大规模的互联网文本数据集上进行预训练，学习到了丰富的语言模式和知识。这种预训练使得模型能够理解和生成自然语言文本。<strong>Transformer架构：</strong> GPT-2基于Transformer模型架构，这是一种依赖于自注意力（self-attention）机制的深度学习架构，非常适合处理序列数据，如文本。<strong>无监督学习：</strong> GPT-2采用无监督学习方法，通过预测下一个词的任务来预训练模型。这种训练方式不依赖于标注数据，使得模型能够学习到更广泛的语言知识。<strong>生成能力：</strong> GPT-2特别擅长文本生成任务，能够生成连贯、有逻辑的段落和文章，甚至能够模仿特定的写作风格。<strong>多样性：</strong> GPT-2能够处理多种语言任务，包括文本生成、翻译、问答、摘要等。<strong>版本和规模</strong>GPT-2有多个版本，不同版本之间主要区别在于模型的大小和参数数量。例如，最小的版本有1.17亿个参数，而最大的版本（GPT-2 1.5 Billion）有15亿个参数。随着模型规模的增加，性能和生成文本的质量也相应提高。<strong>应用场景</strong>GPT-2可以应用于多种场景，如聊天机器人、文本摘要、内容创作辅助、语言翻译等。它的生成能力使得在创意写作、新闻生成和其他需要自然语言生成的领域中具有潜在的应用价值。<strong>挑战和限制</strong>尽管GPT-2在生成文本方面表现出色，但它也面临一些挑战和限制，包括生成文本的偏见问题、事实准确性问题以及潜在的滥用风险。因此，OpenAI在发布GPT-2时采取了谨慎的态度，逐步放开对模型的访问权限。总的来说，GPT-2是一个强大的NLP模型，它在文本生成和理解方面的能力使其成为自然语言处理领域的一个重要里程碑。以下是使用GPT-2做文本生成的示例：<a href="https://link.juejin.cn/?target=https://huggingface.co/openai-community/gpt2!%5B%E5%9B%BE%E7%89%87">huggingface.co&#x2F;openai-comm…</a>](<a href="https://link.juejin.cn/?target=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b480b976be4351a9aee2ddf51a6a75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image%23?w=688&h=391&s=39014&e=png&b=ffffff">p3-juejin.byteimg.com&#x2F;tos-cn-i-k3…</a>%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BD%93%E9%AA%8C%E5%9C%B0%E5%9D%80%EF%BC%9Ahttps%3A%2F%2Ftransformer.huggingface.co%2Fdoc%2Fgpt2-large%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E4%B8%80%E6%AE%B5%E5%B0%8F%E8%AF%B4%E7%9A%84%E5%BC%80%E5%A4%B4%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AAs) aliens entered our planet，然后Transformer就会依据我们输入的文本，自动脑补剩下的小说情节。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d3275388f85411382c53e30e252401c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=655&s=159877&e=png&b=fefefe" alt="图片">那Transformer是怎么做到的呢？如下图所示，Transformer在生成每一个token时，会参考前面所有的token，并生成与之相符的token，这样循环往复就能生成完整的一段内容。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b73860b769a4d43bfa7ebff36d232fb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=336&s=39118&e=png" alt="图片"></p><h2 id="九、参考文档"><a href="#九、参考文档" class="headerlink" title="九、参考文档"></a><strong>九</strong>、<strong>参考文档</strong></h2><p><a href="https://link.juejin.cn/?target=https://arxiv.org/pdf/1706.03762.pdfhttps://jalammar.github.io/illustrated-transformer/https://www.bilibili.com/video/BV1ih4y1J7rx">arxiv.org&#x2F;pdf&#x2F;1706.03…</a></p><p>*<strong>文&#x2F;</strong> 逅弈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解Transformer&quot;&gt;&lt;a href=&quot;#深入理解Transformer&quot; class=&quot;headerlink&quot; title=&quot;深入理解Transformer&quot;&gt;&lt;/a&gt;深入理解Transformer&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作者：得物</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Transformer 总结</title>
    <link href="http://ai.mak.cn/2024/05/02/ai/Transformer%20%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2024/05/02/ai/Transformer%20%E6%80%BB%E7%BB%93/</id>
    <published>2024-05-01T16:00:00.000Z</published>
    <updated>2024-12-17T09:39:51.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformer-总结"><a href="#Transformer-总结" class="headerlink" title="Transformer 总结"></a>Transformer 总结</h1><p>在大模型发展历程中，有两个比较重要点：第一，Transformer 架构。它是模型的底座，但 Transformer 不等于大模型，但大模型的架构可以基于 Transformer；第二，GPT。严格意义上讲，GPT 可能不算是一个模型，更像是一种预训练范式，它本身模型架构是基于 Transformer，但 GPT 引入了“预测下一个词”的任务，即不断通过前文内容预测下一个词。之后，在大量的数据上进行学习才达到大模型的效果。</p><p>之所以说 Transformer 架构好，是因为 Transformer 能够解决之前自然语言处理中最常用的 RNN 的一些核心缺陷，具体来看：一是，难以并行化，反向传播过程中需要计算整个序列；二是，长时依赖关系建模能力不够强；三是，模型规模难以扩大。</p><p>那么，Transformer 具体是如何工作的？</p><p>首先，是对输入进行标识符化，基于单词形式，或字母，或字符子串，将输入文本切分成几个 token，对应到字典中的 ID 上，并对每个 ID 分配一个可学习的权重作为向量表示，之后就可以针对做训练，这是一个可学习的权重。</p><p>在输入 Transformer 结构之后，其核心的有自注意力模块和前向传播层。而在自注意力模块中，Transformer 自注意力机制建模能力优于 RNN 序列建模能力。因此，有了 Transformer 架构后，基本上就解决了运行效率和训练很大模型的问题。</p><p>基于 Transformer 架构的主流语言大模型主要有以下几种：</p><p>一是，自编码模型，如 BERT，简单讲就是给到一句话，然后把这句话的内容挖空，当问及挖空的内容时，就把内容填回去，这其实是典型地用来做一个自然语言理解的任务，但做生成任务是非常弱的；</p><p>二是，自回归模型，如 GPT，它是通过不断地预测下一个词，特点是只能从左到右生成，而看不到后面的内容。GPT-1 最后接了一个 Linear 层做分类或选题题等任务，到了 GPT-2 ，已经将一些选择任务或者分类任务全部都变成文本任务，统一了生成的范式；</p><p>三是，编码器-解码器模型，如 T5，它的输入和输出是分为比较明显的两块内容，或者是问答式，或者序列到序列的转换型的任务；</p><p>四是，通用语言模型，如 GLM，该模型结合了自回归和自编码两种形式的模型，举个例子，“123456”是一串输入的序列，现在把 “3”、“5”、“6” 挖空，让模型去学习，那么，挖空以后换成一个 “ mask token” 告诉模型这个地方遮掉了一些内容，现在需要去预测出来遮掉的内容。</p><p>与 BERT 不同的是，GLM 把自回归和自编码方式进行结合后，挖出来的内容直接拼到了文本的后面，然后加上一个 “ start token”，告诉模型现在是开始生成了，开始做填空任务了，然后把标准答案 “5”、“6” 放在 “ star token”后面让它去预测，直到预测到 “end token”，它就知道这个填空已经结束了。这个过程称为自回归填空式的任务，整个计算流程还是自回归式，但它不断预测下一个词，既实现了填空的功能，又能看到上下文内容。此外，相比于 GPT 模型，GLM 采用了一个双向注意力的机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Transformer-总结&quot;&gt;&lt;a href=&quot;#Transformer-总结&quot; class=&quot;headerlink&quot; title=&quot;Transformer 总结&quot;&gt;&lt;/a&gt;Transformer 总结&lt;/h1&gt;&lt;p&gt;在大模型发展历程中，有两个比较重要点：第一，</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>前端组件汇总</title>
    <link href="http://ai.mak.cn/2024/04/27/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>http://ai.mak.cn/2024/04/27/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2024-04-26T16:00:00.000Z</published>
    <updated>2024-12-17T09:29:25.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端组件汇总"><a href="#前端组件汇总" class="headerlink" title="前端组件汇总"></a>前端组件汇总</h1><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><ul><li><a href="https://github.com/zeratulmdq/vue-accordion">vue-accordion</a>-适用于 Vue.js 的简单手风琴导航菜单组件。</li><li><a href="https://github.com/euvl/vue-js-dropdown">vue-js-dropdown</a>-Vue.js 2 下拉菜单组件。轻巧，易于使用和扩展，无外部缺陷。</li><li><a href="https://github.com/vouill/vue-slideout">vue-slideout</a>-流行的库[slideout]的 Vue 实现(<a href="https://github.com/Mango/slideout">https://github.com/Mango/slideout</a>)</li><li><a href="https://github.com/AshleyLv/vue-quick-menu">vue-quick-menu</a>-这是基于 vue.js2 的 Web 导航组件。</li><li><a href="https://github.com/michitaro/vue-menu">@ hscmap &#x2F; vue-menu</a>-vue2 的菜单&#x2F;上下文菜单组件。</li><li><a href="https://github.com/classicalcondition/vue-router-nav">vue-router-nav</a>-简约的响应式导航栏，呈现 vue-router 的路线。</li><li><a href="https://github.com/hjl19911127/vue-drawer-layout">vue-drawer-layout</a>-一个简单的 DrawerLayout 组件(例如 Android)具有 Vue.js。</li><li><a href="https://github.com/RGRU/vue-simple-menu">vue-simple-menu</a>-具有一组基本功能的简单菜单组件，在 80％的情况下足够</li><li><a href="https://github.com/MisRob/vue-tree-navigation">vue-tree-navigation</a>-具有 vue-router 支持的 Vue.js 2 树导航</li><li><a href="https://github.com/borisbutenko/bp-vuejs-dropdown">bp-vuejs-dropdown</a>-Vuejs &#x3D;&gt; 2 下拉菜单。易于使用，无需外部，可选。</li><li><a href="https://github.com/Lunrtick/vue-bulma-accordion">vue-bulma-accordion</a>-简单，易于配置的手风琴或具有 Bulma 自定义样式的可折叠样式或内置的可用图标</li><li><a href="https://github.com/TerryZ/v-selectmenu">v-selectmenu</a>-针对 Vue2 的简单，容易和高度定制的菜单解决方案。</li><li><a href="https://github.com/mbj36/vue-burger-menu">vue-burger-menu</a>-具有不同 CSS 动画的画布外边栏 Menu 组件。</li><li><a href="https://github.com/JonathanDn/vue-dropdown">vue-dynamic-dropdown</a>-一个高度可定制的，易于使用的优雅下拉组件</li><li><a href="https://github.com/johndatserakis/vue-navigation-bar">vue-navigation-bar</a>-适用于您的 Vue 项目的简单，漂亮的导航栏。</li><li><a href="https://github.com/romainsimon/vue-simple-search-dropdown">vue-simple-search-dropdown</a>-一个没有外部依赖关系的简单可搜索输入下拉组件</li><li><a href="https://github.com/Innologica/vue-dropdown-menu">@ innologica &#x2F; vue-dropdown-menu</a>-Vue 的下拉菜单组件。任何元素都可以是下拉触发器，任何内容都可以下拉内容。</li><li><a href="https://github.com/Dimon24021993/vue-menu-aim">vue-menu-aim</a>-菜单三角形选择，又名亚马逊</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li><a href="https://github.com/manju16832003/v-minusplusinput">minus-plus-input</a>-带正负号的数字输入；包含在 Vue.js v1 和 v2 中。</li><li><a href="https://github.com/Keiwen/vue-integer-plusminus">vue-integer-plusminus</a>-带有 vue 2 增量和减量按钮的整数输入。</li><li><a href="https://github.com/JayeshLab/vue-numeric-input">vue-numeric-input</a>-带有控件的数字输入组件。</li><li><a href="https://github.com/Seokky/vue-number-smarty">vue-number-smarty</a>-数字输入可以在聚焦字段时更改滚动值。</li><li><a href="https://github.com/Seokky/vuetify-number-smarty">vuetify-number-smarty</a>-数字输入可在字段聚焦时更改滚动值(Vuetify.js 实现)。</li></ul><h2 id="轮播"><a href="#轮播" class="headerlink" title="轮播"></a>轮播</h2><ul><li><a href="https://github.com/shhdgit/vue-easy-slider">vue-easy-slider</a>-Vue.js 的滑块组件。</li><li><a href="https://github.com/lsycxyj/vue-l-carousel">vue-l-carousel</a>-Vue.js v2.x +的响应式轮播(即滑块或滑动)组件。</li><li><a href="https://github.com/surmon-china/vue-awesome-swiper">vue-awesome-swiper</a>-Vue.js(1.x〜2.x)的 Swiper(slide)组件。</li><li><a href="https://github.com/vue-bulma/lory">vue-lory</a>-基于 lory 的 Vue 滑块组件。</li><li><a href="https://github.com/staskjs/vue-slick">vue-slick</a>-Slick-carousel 的 Vue 组件。</li><li><a href="https://github.com/drewjbartlett/vue-flickity">vue-flickity</a>-Flickity.js 的 Vue 组件。</li><li><a href="https://github.com/wlada/vue-carousel-3d">vue-carousel-3d</a>-Vue Carousel 3D-Vue.js 美观，灵活且受触摸支持的 3D Carousel。</li><li><a href="https://github.com/SSENSE/vue-carousel">vue-carousel</a>-适用于 Vue.js 的灵活，响应迅速，触摸友好的轮播。</li><li><a href="https://github.com/OrangeXC/vue-coverflow">vue-coverflow</a>-vue2.x Coverflow 组件。</li><li><a href="https://github.com/lukaszflorczak/vue-agile">vue-agile</a>–受 Slick 启发的轮播组件，仅以 Vue.js 和 Vanilla JS 编写。</li><li><a href="https://github.com/viktorlarsson/vue-tiny-slider">vue-tiny-slider</a>–由 ganlanyuan 创建的轮播组件，用 Vue.js 编写。没有 jQuery。适用于 IE8 +。</li><li><a href="https://github.com/mubaidr/vue-swimlane">vue2-text-swimlane</a>-用于 Vue.js 的 Text Swimlane 插件</li><li><a href="https://github.com/rap2hpoutre/vue-picture-swipe">vue-picture-swipe</a>-Vue Picture Swipe Gallery(具有缩略图，延迟加载和轻扫的图像画廊)由 photowipe 支持。</li><li><a href="https://github.com/sainf/vue2-siema">vue2-siema</a>-非常小的 Siema 转盘&#x2F;滑块库的插件包装。</li><li><a href="https://github.com/deulos/vue-flux">vue-flux</a>-带有 20 个炫酷过渡的图片滑块。</li><li><a href="https://github.com/antonreshetov/vue-glide">vue-glide</a>- [Glide.js]上方的 Vue 滑块和轮播组件(<a href="https://github.com/glidejs/glide">https://github.com/glidejs/glide</a>)</li><li><a href="https://github.com/s950329/vue-owl-carousel">vue-owl-carousel</a>- [Owl Carousel 2]的 Vue 组件(<a href="https://owlcarousel2.github.io/OwlCarousel2/">https://owlcarousel2.github.io/OwlCarousel2/</a>)</li><li><a href="https://github.com/antoniandre/vueper-slides">vueper-slides</a>-适用于 Vue JS 的易于触摸且响应迅速的幻灯片&#x2F;轮播。</li><li><a href="https://github.com/loo41/vuc">vue-canvas-carousel</a>- [vuc-carousel]的 Vue 画布组件(<a href="http://vuc.tianchenyong.top/#/carousel">http://vuc.tianchenyong.top/#/carousel</a>)</li><li><a href="https://github.com/baianat/hooper">胡珀</a>-针对 Vue 优化的可自定义的可访问轮播滑块</li><li><a href="https://github.com/ChristophAnastasiades/Lingallery">语言</a>-Vue 的简单图像库组件，在下面显示带有缩略图的大图像</li><li><a href="https://github.com/dreambo8563/vue-piece-slider">vue-piece-slider</a>-动画幻灯片的碎片化外观</li><li><a href="https://github.com/leepyng/vue2-photo-carousel">vue2-photo-carousel</a>-Vue2 的照片轮播组件</li></ul><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><ul><li><a href="https://github.com/bbonnin/vue-morris">vue-morris</a>-VueJS 组件包装了 Morris.js。</li><li><a href="https://github.com/haydenbbickerton/vue-charts">vue-charts</a>-适用于 Vue.js 的 Google Charts 插件。</li><li><a href="https://github.com/apertureless/vue-chartjs">vue-chartjs</a>-Chart.js 的 Vue.js 包装器。</li><li><a href="https://github.com/hchstera/vue-charts">hchs-vue-charts</a>-基于 ChartJs 的 Vue2.0 包装器。</li><li><a href="https://github.com/Justineo/vue-echarts">vue-echarts</a>-Vue.js 的 ECharts 组件。</li><li><a href="https://github.com/QingWei-Li/vue-trend">vuetrend</a>-Vue.js 的简洁优雅火花线。</li><li><a href="https://github.com/weizhenye/vue-highcharts">vue-highcharts</a>-Vue 的 Highcharts 组件。</li><li><a href="https://github.com/xlsdg/vue-echarts-v3">vue-echarts-v3</a>-ECharts.js(v3.x +)的 Vue.js(v2.x +)组件包装。</li><li><a href="https://github.com/lakb248/vue-chartist">vue-chartist</a>-Chartist 的 Vue.js 2.0 组件包装。</li><li><a href="https://github.com/fireyy/g2-vue">g2-vue</a>-用于在 Vue 组件中轻松使用 G2 的工厂包装。</li><li><a href="https://github.com/DeviaVir/vue-bar">vuebars</a>-适用于 Vue.js 的简洁优雅的火花棒。</li><li><a href="https://github.com/emiliorizzo/vue-d3-network">vue-d3-network</a>-使用 d3-force 绘制网络图形的 Vue 组件</li><li><a href="https://github.com/alexcode/vue2vis">vue2vis</a>- <a href="http://visjs.org/">Visjs</a>的 Vue2 包装器。</li><li><a href="https://github.com/chryb/vue-c3">vue-c3</a>-用于 c3 图表的可重用 vue 组件</li><li><a href="https://github.com/d2bjs/vue-d2b">vue-d2b</a>-d2b 图表的 Vue 组件。(包括轴，饼图，sankey 和森伯斯特图)</li><li><a href="https://github.com/SeregPie/VueChart">VueChart</a>-一个非常简单的 Chart Vue 包装器。</li><li><a href="https://github.com/ankane/vue-chartkick">vue-chartkick</a>-用一行 Vue 创建漂亮的 JavaScript 图表</li><li><a href="https://github.com/ignoreintuition/d3vue">d3vue</a>-用于在 VueJS 中创建反应性数据可视化的 D3 插件</li><li><a href="https://github.com/JustSteveKing/vue2-frappe">vue2-frappe</a>-VueJS 的 Frappe Charts 的简单包装</li><li><a href="https://github.com/devstark-com/vue-google-charts">vue-google-charts</a>-Google Charts lib 的反应性 Vue.js 包装器</li><li><a href="https://github.com/juijs/vue-graph">vue-graph</a>-数据可视化库，用于 Vue.js 中的仪表板实现</li><li><a href="https://github.com/David-Desmaisons/Vue.D3.sunburst">vue.d3.sunburst</a>-基于 D3.js 的反应性旭日形组件</li><li><a href="https://github.com/ignoreintuition/v-chart-plugin">v-chart-plugin</a>-一个可定制的组件，用于添加绑定到组件数据的 D3 图表。</li><li><a href="https://github.com/jqwidgets/vue/tree/master/chart">vue-jqxchart</a>-具有饼图，气泡，甜甜圈，线，条，栏，面积，瀑布，极地和蜘蛛系列的制图组件。</li><li><a href="https://github.com/nhnent/toast-ui.vue-chart">toast-ui.vue-chart</a>- [TOAST UI 图表]的 Vue 包装器(<a href="http://ui.toast.com/tui">http://ui.toast.com/tui</a> -图表&#x2F;)。</li><li><a href="https://github.com/apexcharts/vue-apexcharts">vue-apexcharts</a>- [ApexCharts]的 Vue.js 组件(<a href="https://github.com/apexcharts/apexcharts.js)%E3%80%82">https://github.com/apexcharts/apexcharts.js)。</a></li><li><a href="https://github.com/mazipan/vue-doughnut-chart">vue-doughnut-chart</a>-Vue.js 的甜甜圈图组件。</li><li><a href="https://github.com/ElemeFE/v-charts">v-charts</a>-基于 Vue2.x 和 Echarts 的图表组件。</li><li><a href="https://github.com/dumptyd/vue-css-donut-chart">vue-css-donut-chart</a>-用于绘制纯 CSS 甜甜圈图的轻量级 Vue 组件。</li><li><a href="https://github.com/dmtrbrl/vue-trend-chart">vue-trend-chart</a>-Vue.js 的简单趋势图</li><li><a href="https://github.com/keller-mark/vueplotlib">vueplotlib</a>-声明性，交互式，链接的绘图组件</li><li><a href="https://github.com/amroessam/vgauge">vgauge</a>-GaugeJS 的 Vue 包装器-创建漂亮的量规</li><li><a href="https://github.com/David-Desmaisons/vue-plotly">vue-plotly</a>- <a href="https://plot.ly/javascript/">plotly.js</a>声明性图表库的包装，随附 20 图表类型，包括 3D 图表，统计图和 SVG 地图。</li><li><a href="https://github.com/greghub/vue-funnel-graph-js">vue-funnel-graph-js</a>-Vue.js 的漏斗图绘制库。创建垂直和水平动画 SVG 漏斗图，并添加标签，值，图例和其他信息。</li><li><a href="https://github.com/djaxho/pure-vue-chart">pure-vue-chart</a>-在没有任何图表库相关性的情况下实现的轻量级 vue 图表</li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li><a href="https://github.com/egoist/vue-timeago">vue-timeago</a>-Vue 的一个很小的 timeago 组件。</li><li><a href="https://github.com/saman/vue-moment-jalaali">vue-moment-jalaali</a>-针对您的 Vue.js 项目的 Jalaali Moment.js 过滤器。</li><li><a href="https://github.com/sagarkbhatt/vuejs-countdown-timer">vue-countdown-timer</a>-添加了时区转换支持。</li><li><a href="https://github.com/f/vue-analog-clock-range">vue-analog-clock-range</a>-显示时差的模拟时钟范围。</li><li><a href="https://github.com/julon/vue-moment-lib">vue-moment-lib</a>-使用相同的 momentjs API 的简单 Vue.js 2.0 MomentJS 库(过滤器和全局变量)。</li><li><a href="https://github.com/getanwar/vuejs-countdown">vuejs-countdown</a>-适用于 vue js 2.0 的简单倒数计时器组件</li><li><a href="https://github.com/philipjkim/vue2-flip-countdown">vue2-flip-countdown</a>-Vue 2.x 具有倒转效果的倒数计时器</li><li><a href="https://github.com/pablosirera/timeline-vuejs">timeline-vuejs</a>-Vue 的简约时间表</li><li><a href="https://github.com/mlinquan/vue-awesome-countdown">vue-awesome-countdown</a>-Vue 2.5.0+具有高性能和高精度的倒计时插件。官方网站：<a href="https://vac.js.org/">https://vac.js.org</a></li><li><a href="https://github.com/bestvist/vue-clock2">vue-clock2</a>-显示 Vue 的时钟组件。</li><li><a href="https://github.com/P3trur0/vuemodoro">vuemodoro</a>-Pomodoro 计时器作为单个文件 Vue 组件。</li></ul><h2 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h2><ul><li><a href="https://github.com/Wanderxx/vue-fullcalendar">vue-fullcalendar</a>-Vue 日历 fullCalendar。无需 jQuery。安排事件管理。</li><li><a href="https://github.com/GeoffZhu/vue-event-calendar">vue-event-calendar</a>-Vue2 的简单事件日历，除 Vue2 外没有其他依赖项。</li><li><a href="https://github.com/FranckFreiburger/vue-calendar-picker">vue-calendar-picker</a>-用于事件显示，时段选择和日期选择器的轻量级日历组件。</li><li><a href="https://github.com/KimWooHyun/vue-lunar-calendar">vue-lunar-calendar</a>-农历的 vue 组件。使用 Moment.js 进行日期操作。</li><li><a href="https://github.com/richardtallent/vue-simple-calendar">vue-simple-calendar</a>-基于 Flexbox 的 Vue 月历功能；支持多日活动，本地化，节日表情符号，拖放。没有依赖关系。</li><li><a href="https://github.com/Trekels/vue2-calendar">vue2-calendar</a>-一个简单的完整日历组件，旨在灵活而轻巧。</li><li><a href="https://github.com/tuhe32/vue-jLunar-datePicker">vue-jlunar-datepicker</a>-具有节日和节气的中国农历日期选择器组件。</li><li><a href="https://github.com/CroudSupport/vue-fullcalendar">vue-full-calendar</a>-Vue 1 和 2 的完整<a href="https://fullcalendar.io/">fullcalendar.io</a>包装器</li><li><a href="https://github.com/nathanreyes/v-calendar">v-calendar</a>-动画日历&#x2F;日期选择器，显示简单和重复日期的区域，指标和日弹出窗口。</li><li><a href="https://github.com/laleshii/vue-infinite-calendar">vue-infinite-calendar</a>-Vue 2 的简单无限日历实现</li><li><a href="https://github.com/kylin-z/vue-calendar">vue-calendar</a>-适用于 Vue 2.1.5+的简单日历组件，支持自定义内容。没有依赖关系。</li><li><a href="https://github.com/kitwon/vue2-event-calendar">vue2-event-calendar</a>-Vue2 的事件日历，支持自定义事件项和日历标题。</li><li><a href="https://github.com/leepyng/vue-datepicker-infinite">vue2-datePicker-infinite</a>-Vue2 的无限 datePicker，易于使用且没有依赖性。</li><li><a href="https://github.com/icai/vue2-calendar">vue2-slot-calendar</a>-vue 2 日历，支持月球或日期事件的日期选择器组件，引导程序样式。</li><li><a href="https://github.com/stormseed/quasar-calendar">quasar-calendar</a>-使用 Quasar 框架的 vue.js 日历，可实现每月，多天和议程视图。</li><li><a href="https://github.com/mengxiong10/vue2-datepicker">vue2-datepicker</a>-Vue2 的漂亮 datepicker &#x2F; datetimepicker 组件</li><li><a href="https://github.com/enrian/vue-pikaday">vue-pikaday</a>- <a href="https://github.com/dbushell/Pikaday">Pikaday</a>datepicker 的 VueJS 包装器组件</li><li><a href="https://github.com/lkmadushan/vue-tuicalendar">vue-tuicalendar</a>- <a href="https://github.com/nhnent/tui.calendar">tui.calendar</a>日历的 VueJS 包装器组件</li><li><a href="https://github.com/jqwidgets/vue/tree/master/scheduler">vue-jqxscheduler</a>-VueJS Scheduler 组件。</li><li><a href="https://github.com/nhnent/toast-ui.vue-calendar">toast-ui.vue-calendar</a>- [TOAST UI 日历]的 Vue 包装器(<a href="http://ui.toast.com/tui">http://ui.toast.com/tui</a> -日历)。</li><li><a href="https://github.com/ManukMinasyan/vue-functional-calendar">vue-functional-calendar</a>-基于 Vue 的轻量级高性能日历组件(日期选择器，日期范围)。</li><li><a href="https://github.com/antoniandre/vue-cal">vue-cal</a>-Vue JS 完整日历，无依赖项，无 BS。🤘。</li><li><a href="https://github.com/liloow/vue-draggableCal">vue-draggableCal</a>-不是普通的日期选择器。一个 Vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动使用且具有 0 个依赖项，已压缩 17kb</li><li><a href="https://github.com/nono1526/vue-material-year-calendar">vue-material-year-calendar</a>-Vue2 的全年(每页 12 个月)日历。使用 dayjs。</li><li><a href="https://github.com/codesthq/vuelendar">vuelendar</a>-用 VueJS 编写的简洁日历</li></ul><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><ul><li><a href="https://github.com/xkjyeah/vue-google-maps">vue2-google-maps</a>-Google Maps 组件，用于带有 2 向数据绑定的 vue。</li><li><a href="https://github.com/KoRiGaN/Vue2Leaflet">vue2-leaflet</a>-传单地图的 Vue 2 组件。</li><li><a href="https://github.com/phegman/vue-mapbox-gl">vue-mapbox-gl</a>-Mapbox GL JS 的 Vue 2.x 组件</li><li><a href="https://github.com/PNKBizz/vue-yandex-map">vue-yandex-maps</a>-Yandex Maps 的 Vue 2.x 组件</li><li><a href="https://github.com/Dafrok/vue-baidu-map">vue-baidu-map</a>-百度地图的 Vue 2.x 组件。</li><li><a href="https://github.com/voluntadpear/vue-choropleth">vue-choropleth</a>-Vue 2.x 组件，用于显示一个 Choropleth 贴图。</li><li><a href="https://github.com/ghettovoice/vuelayers">vuelayers</a>-Vue 2 组件可与 OpenLayers 一起使用。</li><li><a href="https://github.com/Akryum/vue-googlemaps">vue-googlemaps</a>-Vue 2.x 组件，用于集成 Google Maps。</li><li><a href="https://github.com/eperedo/vue-static-map">vue-static-map</a>-Vue 2.x 简单组件，可生成静态 Google 地图</li><li><a href="https://github.com/soal/vue-mapbox">vue-mapbox</a>-Mapbox GL JS 库周围的 Vue 2.x 包装器，提供了与地图交互的途径。</li></ul><h2 id="音频视频"><a href="#音频视频" class="headerlink" title="音频视频"></a>音频视频</h2><ul><li><a href="https://github.com/SevenOutman/vue-aplayer">Vue-APlayer</a>-：cake：用于 Vue 2.x 的易于配置的音乐播放器。</li><li><a href="https://github.com/shershen08/vuejs-sound-player">vue-audio</a>-音频标签包装器；Vue 2.x 的声音播放器组件</li><li><a href="https://github.com/sinchang/vue-dplayer">vue-dplayer</a>-基于 DPlayer 的 Vue 2.x 视频播放器组件。</li><li><a href="https://github.com/chrishurlburt/vue-canvasvideo">vue-canvasvideo</a>-一个 Vue 2.x 组件，用于在 iOS &#x2F; Safari 上播放视频背景和自动播放视频。</li><li><a href="https://github.com/petsgre/music">vue-music</a>-基于 html5&#96;&#96;的 Vue 组件。</li><li><a href="https://github.com/staskobzar/vue-audio-visual">vue-audio-visual</a>-Vue HTML5 音频可视化组件。</li><li><a href="https://github.com/redxtech/vue-plyr">vue-plyr</a>-一组用于 plyr 视频和音频播放器的 Vue 组件。</li><li><a href="https://github.com/TerryZ/v-playback">v-playback</a>-一个 Vue2 插件，可简化视频播放。</li><li><a href="https://github.com/grishkovelli/vue-audio-recorder">vue-audio-recorder</a>-Vue.js 的音频记录器。它允许在服务器上创建，播放，下载和存储记录</li><li><a href="https://github.com/johndatserakis/vue-video-section">vue-video-section</a>-Vue 的简单视频标头&#x2F;部分组件。适用于视频背景并在其上叠加内容。</li></ul><h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><ul><li><a href="https://github.com/PeachScript/vue-infinite-loading">vue-infinite-loading</a>-适用于 Vue.js 1.0 和 Vue.js 2.0 的无限滚动插件。</li><li><a href="https://github.com/egoist/vue-mugen-scroll">vue-mugen-scroll</a>-Vue.js 的无限滚动组件 2。</li><li><a href="https://github.com/ElemeFE/vue-infinite-scroll">vue-infinite-scroll</a>-vue.js 的无限滚动指令。</li><li><a href="https://github.com/lookstudios/vue-loop">vue-loop</a>-Vue.js 2 的无限内容循环组件。</li><li><a href="https://github.com/wangdahoo/vue-scroller">vue-scroller</a>-Vue.js 2 的无限内容循环组件，包括诸如“拉动刷新”，“无限加载”之类的功能，’snaping-scroll’。</li><li><a href="https://github.com/legeneek/vue-infinite-list">vue-infinite-list</a>-无限列表 mixin 可以为 Vue.js 2 回收 dom</li><li><a href="https://github.com/biigpongsatorn/vue-infinite-slide-bar">vue-infinite-slide-bar</a>-∞ 无限滑动条组件。</li><li><a href="https://github.com/zuolei828/vue-virtual-infinite-scroll">vue-virtual-infinite-scroll</a>-基于 Iscroll 的 vue2 组件，支持具有高性能滚动，无限负载和拉动的大数据列表刷新。</li></ul><h2 id="拉动刷新"><a href="#拉动刷新" class="headerlink" title="拉动刷新"></a>拉动刷新</h2><ul><li><a href="https://github.com/lakb248/vue-pull-refresh">vue-pull-refresh</a>-拉动刷新 Vue.js 2.0 的组件。</li><li><a href="https://github.com/stackjie/vue-pull-to">vue-pull-to</a>-下拉刷新和上拉为 Vue.js 组件加载了更多内容并无限滚动。</li><li><a href="https://github.com/bedlate/vue-data-loading">vue-data-loading</a>-另一个用于无限滚动和向下&#x2F;向上加载数据的组件。</li><li><a href="https://github.com/duyanpeng/vue-quick-loadmore">vue-quick-loadmore</a>-Vue 的下拉刷新和上拉无限滚动插件。</li></ul><h2 id="降价"><a href="#降价" class="headerlink" title="降价"></a>降价</h2><ul><li><a href="https://github.com/miaolz123/vue-markdown">vue-markdown</a>-适用于 Vue 的强大，高速 Markdown 解析器。</li><li><a href="https://github.com/hinesboy/mavonEditor">vue-mavonEditor</a>-基于 Vue 的降价编辑器，支持多种个性化功能。</li><li><a href="https://github.com/Vivify-Ideas/vue-simple-markdown">vue-simple-markdown</a>-适用于 Vue 的简单，高速 Markdown 解析器。</li><li><a href="https://github.com/F-loat/vue-simplemde">vue-simplemde</a>- <a href="https://github.com/sparksuite/simplemde-markdown-editor">simplemde</a>的包装。不论是初学者还是专家，都可轻松编辑。具有内置的自动保存和拼写检查功能。</li><li><a href="https://github.com/nhnent/toast-ui.vue-editor">toast-ui.vue-editor</a>- [TOAST UI 编辑器]的 Vue 包装器(<a href="http://ui.toast.com/tui">http://ui.toast.com/tui</a> -编辑)。</li></ul><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><ul><li><a href="https://github.com/FranckFreiburger/vue-pdf">vue-pdf</a>-基于 mozilla 的 PDF.js 的 pdf 查看器</li><li><a href="https://github.com/arkokoley/pdfvuer">pdfvuer</a>-Vue 的 PDF 查看器，使用 Mozilla 的 PDF.js 和文本支持。<a href="https://blog.koley.in/pdfvuer/">演示</a></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li><a href="https://github.com/David-Desmaisons/Vue.D3.tree">Vue.D3.tree</a>-基于[D3.js]的树状视图(<a href="https://d3js.org/">https://d3js.org/</a>)</li><li><a href="https://github.com/arvidkahl/vue-json-tree-view">vue-json-tree-view</a>-Vue.js 的 JSON 树视图组件。</li><li><a href="https://github.com/halower/vue2-tree">vue-tree</a>-Vue.js 2.X 的树组件。</li><li><a href="https://github.com/amsik/liquor-tree">liquor-tree</a>-惊人的 Vue 树组件</li><li><a href="https://github.com/wyr1227/vue-trees">vue-trees-ui</a>-基于 Vue 的 Tree Ui。</li><li><a href="https://github.com/elbywan/bosket">Bosket</a>-前端框架(Vue，React，Angular 和 Riot)的树视图组件的集合。</li><li><a href="https://github.com/plantain-00/tree-component">plantain-00 &#x2F; tree-component</a>-一个 reactjs，angular 和 vuejs 树组件。</li><li><a href="https://github.com/holiber/sl-vue-tree">sl-vue-tree</a>-适用于 Vue.js 的简单可定制的可拖动树组件</li><li><a href="https://github.com/phphe/vue-draggable-nested-tree">vue-draggable-nested-tree</a>-适用于 Vuejs2 [@phphe](<a href="https://github.com的功能强大的可自定义可拖动树视图组件./">https://github.com的功能强大的可自定义可拖动树视图组件。</a> com &#x2F; phphe)</li><li><a href="https://github.com/scalia/vuejs-tree">vuejs-tree</a>-高度可定制的 VueJs 树查看器</li><li><a href="https://github.com/zdy1988/vue-jstree">vue-jstree</a>-适用于 Vue2 的树形插件，带有漂亮的图标和拖放功能</li><li><a href="https://github.com/XAHTEP26/vue-vtree">vue-vtree</a>-Vue.js 的通用且灵活的树组件</li><li><a href="https://github.com/tylerkrupicka/vue-json-component">vue-json-component</a>-JSON 树视图，没有依赖项，TypeScript 支持且易于定制。</li><li><a href="https://github.com/ParadeTo/vue-tree-list">vue-tree-list</a>-用于树形结构的 vue 组件</li></ul><h2 id="社交分享"><a href="#社交分享" class="headerlink" title="社交分享"></a>社交分享</h2><ul><li><a href="https://github.com/nicolasbeauvais/vue-social-sharing">vue-social-sharing</a>-一个 Vue.js 组件，用于共享指向社交网络的链接，可与 Vue.js 1.X 或 2.X 一起使用。</li><li><a href="https://github.com/koddr/vue-goodshare">vue-goodshare</a>-用于社交共享的 Vue.js 组件，具有精美的按钮设计。简单的安装，丰富的文档，开发人员支持，SEO 友好，干净的代码，无需脚本即可快速跟踪页面上的用户活动。使用 Vue.js2.x。</li><li><a href="https://github.com/mbj36/vue-socialmedia-share">vue-socialmedia-share</a>-一个 Vue.js 组件，用于使用 Vue 2.X 共享与社交网络的链接</li><li><a href="https://github.com/Onatcer/vue-picture-sharesheet">vue-picture-sharesheet</a>-一个 Vue 图片共享表组件，受到苹果新闻编辑室中图片共享表的启发</li><li><a href="https://github.com/chiaweilee/vue-twitter">vue-twitter</a>-用于嵌入 Twitter 小部件(例如时间线，按钮)的 Vue.js 组件</li><li><a href="https://github.com/Alexandrshy/vue-share-buttons">vue-share-buttons</a>-Vue.js 组件，用于在您的项目中放置按钮，您可以共享任何东西</li></ul><p>＃＃ 二维码</p><ul><li><a href="https://github.com/theomessin/vue-qriously">vue-qriously</a>-一个 Vue.js 2 组件，用于使用 qrious 在 HTML Canvas 上绘制 QR 代码。</li><li><a href="https://github.com/superman66/vue-qart">vue-qart</a>-vue 2.x 用于 qart.js 的指令。</li><li><a href="https://github.com/gruhn/vue-qrcode-reader">vue-qrcode-reader</a>-一个 Vue.js 2 组件，可从相机流中检测和解码 QR 码。</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><a href="https://github.com/shayneo/vue-fuse">vue-fuse</a>-模糊搜索库 Fuse.js 的轻量级插件</li><li><a href="https://community.algolia.com/vue-instantsearch/">vue-instantsearch</a>-使用<a href="https://www.algolia.com/">Algolia</a>创建即时搜索体验的终极工具箱。</li><li><a href="https://github.com/InnerSearch/vue-innersearch">vue-innersearch</a>-用于 Elasticsearch 的 Vue.js 包装器</li><li><a href="https://github.com/appbaseio/reactivesearch">reactivesearch-vue</a>-用于使用 Elasticsearch 构建数据驱动的应用程序的 UI 组件</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/eliep/vue-avatar">vue-avatar</a>-vue.js 的头像组件。</li><li><a href="https://github.com/surmon-china/vue-touch-ripple">vue-touch-ripple</a>-Vue.js 的触摸波纹组件(1.x〜2.x)。</li><li><a href="https://github.com/cngu/vue-typer">vue-typer</a>-Vue 组件，用于模拟用户键入，选择和擦除文本。</li><li><a href="https://github.com/MartyWallace/vue-keyboard">vue-keyboard</a>-Vue 2 虚拟键盘组件。</li><li><a href="https://github.com/mhayes/vue-twentytwenty">vue-twentytwenty</a>-图像比较组件，可与 Vue.js 2.x 一起使用</li><li><a href="https://github.com/apertureless/vue-cookie-law">vue-cookie-law</a>-Vue.js 2.x 的 Cookie 信息插件</li><li><a href="https://github.com/JiriChara/vue-gravatar">vue-gravatar</a>-适用于 Vue.js 2.x 的简陋的 gravatar 组件</li><li><a href="https://github.com/Inndy/vue-clipboard2">vue-clipboard2</a>-一种易于使用的 Vue.js 2.x 剪贴板剪贴板绑定</li><li><a href="https://github.com/cuduy197/vue-flashcard">vue-flashcard</a>-带有 Vue.js 2.x 动画的 FLashcard 组件：bulb：</li><li><a href="https://github.com/kavalcante/vue-truncate-collapsed">vue-truncate-collapsed</a>-一个简单的组件，它会截断文本并为 Vue.js 2 添加可点击的“阅读更多&#x2F;显示较少”。 X</li><li><a href="https://github.com/BrockReece/vue-kanban">vue-kanban</a>-灵活的拖放式看板板组件</li><li><a href="https://github.com/aidewoode/vue-letter-avatar">vue-letter-avatar</a>-vue.js 的简单优雅的字母头像组件</li><li><a href="https://github.com/metachris/vue-highlightjs">vue-highlightjs</a>-使用 highlight.js 突出显示语法</li><li><a href="https://github.com/euvl/v-clipboard">v-clipboard</a>-简单，小巧且易于使用的指令将您的模型保存到剪贴板(最小 2kb，无依赖项)</li><li><a href="https://github.com/MicroDroid/vue-invisible-recaptcha">vue-invisible-recaptcha</a>-超级简单的 Google 隐形 reCAPTCHA 集成</li><li><a href="https://github.com/Gomah/vue-embed">vue-embed</a>-Embed 组件基于 Vue 2.x 的 embed.js，该组件可嵌入表情符号，媒体，地图，tweet，要点，代码，服务和减价。</li><li><a href="https://github.com/creotip/vue-particles">vue-particles</a>-粒子背景的 Vue.js 组件</li><li><a href="https://github.com/termosa/vue-uniq-ids">vue-uniq-ids</a>-Vue.js 2.x 插件，可帮助使用与 ID 相关的属性，且无副作用</li><li><a href="https://github.com/drewjbartlett/vue-multivue">vue-multivue</a>-在同一页面上使用同一类的多个 vue 应用。</li><li><a href="https://github.com/eddiemf/vue-affix">vue-affix</a>-一个 Vue.js 2.x 插件，可在滚动时在窗口中添加元素，类似于 Bootstrap Affix，但更简单，更智能</li><li><a href="https://github.com/OXOYO/X-Browser-Update-Vue">X-Browser-Update-Vue</a>-一个 Vue.js 浏览器更新插件。</li><li><a href="https://github.com/dabernathy89/vue-query-builder">vue-query-builder</a>-用于使用嵌套条件构建复杂查询的 UI 组件。</li><li><a href="https://github.com/karakanb/vue-info-card">vue-info-card</a>-一个简单漂亮的卡片组件，带有优美的火花线和 CSS3 翻转动画。</li><li><a href="https://github.com/vinayakkulkarni/v-offline">v-offline</a>-简单，小巧且易于使用的 Vue 应用程序检测离线和在线事件(最小 390b)</li><li><a href="https://github.com/SeregPie/VueWordCloud">vue-word-cloud</a>-词云生成器。</li><li><a href="https://github.com/grzhan/vue-flat-surface-shader">vue-flat-surface-shader</a>- <a href="https://github.com/wagerfield/%E5%B9%B3%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8">Vue-flat-surface-shader</a></li><li><a href="https://github.com/ddgll/vue-easteregg">vue-easteregg</a>-Easey 在您的 Vue 应用中添加了 Easteregg(默认使用 konami 代码)</li><li><a href="https://github.com/noomerzx/vue-barcode-scanner">vue-barcode-scanner</a></li><li><a href="https://github.com/BrockReece/vue-heatmapjs">vue-heatmapjs</a>-用于跟踪和可视化鼠标活动的 Vue 指令</li><li><a href="https://github.com/meganetaaan/vue-maze">vue-maze</a>-由 Vue.js 组件制作的小巧迷宫游戏</li><li><a href="https://github.com/AshleyLv/vue-drag-verify">vue-drag-verify</a>-这是一个 vue 组件，可以滑动以解锁以进行登录或注册。</li><li><a href="https://github.com/kevinwarne/vue-balloon">vue-balloon</a>-Vue 组件，用于在页面一角创建固定的，可缩放的容器。与 gmail 中使用的邮件撰写包装类似。</li><li><a href="https://github.com/KamilOcean/vue-sticker">vue-sticker</a>-任意方向的贴纸效果</li><li><a href="https://github.com/vinayakkulkarni/v-rating">v-rating</a>-⭐️ 使用 VueJS 制作的语义 UI 中的评级组件(&lt;500B 压缩，速度非常快)</li><li><a href="https://github.com/michalsnik/vue-content-placeholders">vue-content-placeholders</a>-用于在 vue 中渲染诸如 Facebook 之类的伪造(渐进)内容的可组合组件</li><li><a href="https://github.com/fireyy/vue-page-designer">vue-page-designer</a>-Vue 组件，用于拖放来设计和构建移动网站。</li><li><a href="https://github.com/julon/vue-creativecommons">vue-creativecommons</a>-CreativeCommons.org Vue.js 组件库。</li><li><a href="https://github.com/coderdiaz/vue-status-indicator">vue-status-indicator</a>-一个 Vue.js 组件，用于将状态指示器显示为彩色圆点。</li><li><a href="https://github.com/mazipan/vue-google-adsense">vue-google-adsense</a>-具有 InFeed 和 InArticle Ads 支持的 Vue.js Google Adsense 组件</li><li><a href="https://github.com/shershen08/emoji-vue">emoji-vue</a>-Vue.js 项目的 Emoji😎👌🏻 下拉菜单</li><li><a href="https://github.com/vitogit/vue-chessboard">vue-chessboard</a>-棋盘 vue 组件可加载位置，创建位置并查看威胁。</li><li><a href="https://github.com/anteriovieira/vue-mindmap">vue-mindmap</a>-用于 mindnode 映射的 Vue 组件。</li><li><a href="https://github.com/ignoreintuition/v-currency">v-currency</a>-用于格式化货币的 Vue 组件。</li><li><a href="https://github.com/DCzajkowski/vue-emoji-picker">vue-emoji-picker</a>-高度可定制的 Unicode 表情符号选择器 🔥🚀</li><li><a href="https://github.com/meganetaaan/vue-8-puzzle">vue-8-puzzle</a>-一个由 Vue.js 组件制作的小巧幻灯片益智游戏</li><li><a href="https://github.com/evildvl/vue-e164">vue-e164</a>-具有 E.164 标准支持的可自定义电话格式化程序</li><li><a href="https://github.com/deemaagog/vue-pgn">vue-pgn</a>-Vue.js 组件，用于以 pgn 格式查看棋牌游戏</li><li><a href="https://github.com/fpluquet/vue-avatar-editor">vue-avatar-editor</a>-使用清晰的用户界面调整大小，旋转并裁剪上传的头像。</li><li><a href="https://github.com/Botre/vue-connection-listener">vue-connection-listener</a>-Vue 事件总线插件监听在线&#x2F;离线更改。</li><li><a href="https://github.com/Botre/vue-sauce">vue-sauce</a>-Vue 的“查看源代码”指令。</li><li><a href="https://github.com/Botre/vue-prom">vue-prom</a>-Vue 承诺包装器组件。</li><li><a href="https://github.com/viclm/numeric-keyboard">数字键盘</a>-用于移动浏览器的数字键盘。</li><li><a href="https://github.com/Intera/vue-zoom-on-hover">vue-zoom-on-hover</a>-鼠标悬停时图像缩放</li><li><a href="https://github.com/HCESrl/vue-sensitive-image">vue-sensitive-image</a>-Vue 组件，可让您快速创建具有最佳数量的所有设备图像源的响应式图像标签。</li><li><a href="https://github.com/TonPC64/vue-highlight-text">vue-highlight-text</a>-Vue 组件，用于突出显示单词的多个实例</li><li><a href="https://github.com/anteriovieira/vue-cast-props">vue-cast-props</a>-提供了一种将 props 转换为常见数据类型的便捷方法。</li><li><a href="https://github.com/JustSteveKing/vue2-heropatterns">vue2-heropatterns</a>-一个 Vue2 实现，允许您将流行的 Hero Patterns 添加到任何 Div 上</li><li><a href="https://github.com/Developmint/vue-link">vue-link</a>-一个将所有链接都链接在一起的组件(处理外部和内部链接相同)</li><li><a href="https://github.com/vinayakkulkarni/vue-identify-network">vue-identify-network</a>-⚡️ 识别您的用户正在使用哪种互联网！</li><li><a href="https://github.com/ridaamirini/vue-cloneya">vue-cloneya</a>-用于克隆 DOM 元素的 vue 组件</li><li><a href="https://github.com/FissionHQ/vue-survey-builder">vue-survey-builder</a>-vue.js 应用程序的调查生成器</li><li><a href="https://github.com/Developmint/vue-if-bot">vue-if-bot</a>-一个轻量级的组件，用于基于用户代理向客户端隐藏&#x2F;显示内容</li><li><a href="https://github.com/clampy-js/vue-clampy">vue-clampy</a>-Vue.js(2+)指令，通过在其中包含内容的元素加上省略号来限制元素的内容太长。</li><li><a href="https://github.com/promosis/vue-cookie-accept-decline">vue-cookie-accept-decline</a>-在页面上显示带有文字，拒绝按钮和接受按钮的横幅。记住使用 cookie 进行选择。使用创建时的当前选择来发出事件。符合 GDPR 要求。</li><li><a href="https://github.com/lossendae/vue-avatar">@ lossendae &#x2F; vue-avatar</a>-VueJS 2.0 的头像组件。</li><li><a href="https://github.com/AlbertLucianto/vue-text-highlight">vue-text-highlight</a>-Vue.js 的文本荧光笔库 💄</li><li><a href="https://github.com/bsdfzzzy/vue2-hammer">vue2-hammer</a>Vue 2.x 的 Hammer.js 包装器支持移动触摸。</li><li><a href="https://github.com/johndatserakis/vue-countable">vue-countable</a>-countable.js 的 Vue 绑定。提供实时的段落，句子，单词和字符计数。</li><li><a href="https://github.com/phegman/v-show-slide">v-show-slide</a>-一个 Vue.js 指令，用于将元素上下移动动画：自动滑动。</li><li><a href="https://github.com/eCollect/vue-swipe-actions">vue-swipe-actions</a>-适用于 Vue.js 的 iOS 样式滑动操作</li><li><a href="https://github.com/nzlt/vue-friendly-iframe">vue-friendly-iframe</a>-用于创建超快速加载，无阻塞 iframe 的 Vue js 组件。</li><li><a href="https://github.com/mattmezza/vue-beautiful-chat">vue-beautiful-chat</a>-一个简单而美丽的 Vue 聊天组件后端不可知，完全可自定义和可扩展。</li><li><a href="https://github.com/zeknoss/vue-magnifier">vue-magnifier</a>-Vue.js 2.x 的简单图像缩放&#x2F;放大组件。</li><li><a href="https://github.com/Astray-git/vue-highlight-words">vue-highlight-words</a>-Vue 组件可在较大的文本正文中突出显示单词。从[react-highlight-words]移植(<a href="https://github.com/bvaughn/react-highlight-words">https://github.com/bvaughn/react-highlight-words</a>)</li><li><a href="https://github.com/yanthems/vue-tags-ball">vue-tags-ball</a>-使用此插件创建漂亮的球形标签</li><li><a href="https://github.com/spemer/vue-rippler">vue-rippler</a>-用于自定义波纹效果的简单 Vue.js 插件</li><li><a href="https://github.com/chiaweilee/vue-contacts">vue-contacts</a>-Vue 的移动通讯录组件</li><li><a href="https://github.com/jmaczan/basic-vue-chat">basic-vue-chat</a>-易于使用的 Vue.js 聊天</li><li><a href="https://github.com/JayeshLab/vue-resize-text">vue-resize-text</a>-一个 vue 指令，可根据元素宽度自动调整字体大小。</li><li><a href="https://github.com/GabrielBibiano/vue-github-profile">vue-github-profile</a>-一个 Vue 组件，用于查看确定的用户的配置文件和存储库</li><li><a href="https://github.com/P3trur0/vue-niege">vue-niege</a>-🎅 单文件 Vue 组件可通过画布添加暴风雪。</li><li><a href="https://github.com/JonathanDn/vue-stars-rating">vue-dynamic-star-rating</a>-高度动态的 Vue 明星评分组件，例如 Google Play 评分 ⭐️⭐️⭐️⭐️⭐️⭐️</li><li><a href="https://github.com/lucpotage/vue-katex">vue-katex</a>-在 Vue.js 中使用 KaTeX 进行数学排版的简单插件</li><li><a href="https://github.com/loo41/vuc">vue-canvas-identify</a>- [vuc-identify]的 Vue 画布组件(<a href="http://vuc.tianchenyong.top/">http://vuc.tianchenyong.top</a>)</li><li><a href="https://github.com/loo41/vuc">vue-canvas-material</a>- [vuc-material]的 Vue 画布组件(<a href="http://vuc.tianchenyong.top/#/materia">http://vuc.tianchenyong.top/#/materia</a>)</li><li><a href="https://github.com/superhos/vue-baberrage">vue-baberrage</a>-一个基于 Vue.js 的简单弹幕插件 😎</li><li><a href="https://github.com/shershen08/vue-terminal-ui">vue-terminal-ui</a>-🖥TerminalUI 模拟器 Vue：自定义和基本命令</li><li><a href="https://github.com/ndabAP/vue-command">vue-command</a>-完全正常工作的 Vue.js 终端模拟器</li><li><a href="https://github.com/P3trur0/vue-ribbon">vue-ribbon</a>-GitHub 功能区的 Vue 组件</li><li><a href="https://github.com/trunda/avatio-avatar">avatio-avatar</a>-插图化身的 Vue 组件- <a href="https://avatio.cool/">Avatio</a>使用</li><li><a href="https://github.com/man15h/vue-jazzicon">vue-jazzicon</a>-用于 Vue 的简陋的 Jazzicon 组件。</li><li><a href="https://github.com/craigh411/vue-star-rating">vue-star-rating</a>-一个简单的，高度可定制的星级评分组件 ⭐️⭐️⭐️</li><li><a href="https://github.com/potato4d/vue-fixed-header">vue-fixed-header</a>-简单且跨浏览器友好的由 TypeScript 编写的 Vue.js 固定标头组件。</li><li><a href="https://github.com/dreambo8563/vue-particle-effect-buttons">vue-particle-effect-buttons</a>一个爆发粒子效果按钮组件。</li><li><a href="https://github.com/gorbypark/vue-insomnia">vue-insomnia</a>-防止显示屏进入休眠状态(唤醒锁定)。</li><li><a href="https://github.com/yimocanxue/vue-car-plate-keyboard">vue-car-plate-keyboard</a>-用于 VueJS 2.x 的汽车牌照号码键盘。能源车牌 🚗🚗🚗)</li><li><a href="https://github.com/krthr/vue-dataflow-editor">vue-dataflow-editor</a>-Vue2 数据流图编辑器</li><li><a href="https://github.com/kevinfaguiar/cool-emoji-picker">cool-emoji-picker</a>-Vue 的快速即插即用[Tw] emoji Picker(用于 Twemoji 渲染的+ textarea)组件。</li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><a href="https://github.com/cristijora/vue-tabs">vue-tabs</a>-简单的标签和药丸。</li><li><a href="https://github.com/zhangxiang958/vue-tab">vue-swipe-tabs</a>-vue.js(vue2)的触摸滑动选项卡组件。</li><li><a href="https://github.com/spatie/vue-tabs-component">vue-tabs-component</a>-一种使用 Vue 显示标签的简便方法。</li><li><a href="https://github.com/kevindesousa/vue-k-tabs">vue-k-tabs</a>-具有 Gitlab 设计的简单标签组件。</li><li><a href="https://github.com/karambafe/vue-tabs-with-active-line">vue-tabs-with-active-line</a>-简单的 Vue 2 组件，可让您制作带有移动底线的标签</li><li><a href="https://github.com/viewweiwu/vue-tabs-chrome">vue-tabs-chrome</a>-一个类似于 Chrome 的标签的 Vue 组件。</li></ul><h2 id="电话号码输入格式器"><a href="#电话号码输入格式器" class="headerlink" title="电话号码输入格式器"></a>电话号码输入格式器</h2><ul><li><a href="https://github.com/LouisMazel/vue-phone-number-input">vue-phone-number-input</a>-一个漂亮的输入，用于格式化与国家&#x2F;地区代码有效的电话号码：fire：</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li><a href="https://github.com/hiyali/vue-smooth-picker">vue-smooth-picker</a>-Vue 2.x 的平滑选择器组件，例如 iOS 本机日期时间选择器。</li></ul><h2 id="发电机"><a href="#发电机" class="headerlink" title="发电机"></a>发电机</h2><ul><li><a href="https://github.com/formschema/native">FormSchema Native</a>-使用 JSON Schema 和 Vue.js 生成表单</li><li><a href="https://github.com/fightingm/vue-awesome-form">vue-awesome-form</a>-一个 vue.js 组件，就像 json-editor</li><li><a href="https://github.com/michaellyu/vue-generator">vue-generator</a>-Vue 项目的初始路由器和组件。</li><li><a href="https://github.com/14nrv/vue-form-json">vue-form-json</a>-从 json 生成具有验证和 bulma 样式的 vue 表单</li><li><a href="https://github.com/xaboy/form-create">form-create</a>-具有动态呈现，数据收集，验证和提交功能的表单生成器，支持 json 数据</li><li><a href="https://github.com/codetrial/element-form-builder">element-form-builder</a>-使用 JSON 模式构建 element-ui 表单。</li><li><a href="https://github.com/ncform/ncform">ncform</a>-一种非常好的配置生成表单的方式</li><li><a href="https://github.com/laraform/laraform">Laraform</a>-具有 Laravel 支持的 Vue.js 的高级表单生成器</li><li><a href="https://github.com/dream2023/vue-ele-form">vue-ele-form</a>-Vue DataForm，基于 element-ui</li></ul><h2 id="日期选择器"><a href="#日期选择器" class="headerlink" title="日期选择器"></a>日期选择器</h2><ul><li><a href="https://github.com/hilongjw/vue-datepicker">vue-datepicker</a>- [未维护]具有用于 Vue.js 的材质设计的日历和 datepicker 组件。</li><li><a href="https://github.com/phoenixwong/vue2-timepicker">vue2-timepicker</a>- [未维护] Vue 2.x 的下拉时间选择器(小时|分钟|秒)，具有灵活的时间格式支持。</li><li><a href="https://github.com/charliekassel/vuejs-datepicker">vuejs-datepicker</a>-一个简单的 Vue.js datepicker 组件。支持禁用日期，内联模式，翻译。</li><li><a href="https://github.com/nkoehring/vuedt">vuedt</a>- [未维护]疯狂的轻量级(5.5kb！)Vuejs 日期和时间选择器组件，动画效果很好，而且没有太多的模糊感。</li><li><a href="https://github.com/ankurk91/vue-flatpickr-component">vue-flatpickr-component</a>用于<a href="https://github.com/chmln/flatpickr">flatpickr</a>日期时间选择器的 Vue.js 组件</li><li><a href="https://github.com/ankurk91/vue-bootstrap-datetimepicker">vue-bootstrap-datetimepicker</a>Vue.js 组件，用于[eonasdan-bootstrap-datetimepicker](<a href="https://github.com/Eonasdan/bootstrap-">https://github.com/Eonasdan/bootstrap-</a> datetimepicker &#x2F;)</li><li><a href="https://github.com/pepour/vue-jalaali-datepicker">vue-jalaali-datepicker</a>-vue.js 的 Jalaali 日历和日期选择器 2。</li><li><a href="https://github.com/ridewn/vue-date-picker">vue-date-picker</a>-一个受材料设计启发的 vue 日期选择器组件</li><li><a href="https://github.com/ittus/vue-monthly-picker">vue-monthly-picker</a>-仅适用于月份和年份选择器的 Vue.js 组件</li><li><a href="https://github.com/krystalcampioni/vue-hotel-datepicker">vue-hotel-datepicker</a>-响应式日期范围选择器，显示选定的住宿天数，允许自定义入住&#x2F;退房规则，屏蔽日期，本地化支持等。</li><li><a href="https://github.com/dyonir/vue2-persian-datepicker">vue2-persian-datepicker</a>-vue 的真棒波斯 datepicker 组件。کامپوننتانتخابتاریخبرایویو。</li><li><a href="https://github.com/mariomka/vue-datetime">vue-datetime</a>-Vue 的移动友好日期时间选择器。支持日期，日期时间和时间模式，i18n 和禁用日期。</li><li><a href="https://github.com/bliblidotcom/vue-rangedate-picker">vue-rangedate-picker</a>-具有简单用法的范围日期选择器</li><li><a href="https://github.com/dwqs/v2-datepicker">v2-datepicker</a>-基于 Vue 2.x 的简单 datepicker 组件。</li><li><a href="https://github.com/weifeiyue/vue-datepicker-local">vue-datepicker-local</a>-Vue2 的一个漂亮的 Datepicker 组件。</li><li><a href="https://github.com/MikaelEdebro/vue-airbnb-style-datepicker">vue-airbnb-style-datepicker</a>-Vue datepicker，外观和功能与流行的 AirBnb datepicker 相似。轻巧，可配置且良好的浏览器支持！</li><li><a href="https://github.com/talkhabi/vue-persian-datetime-picker">vue-persian-datetime-picker</a>波斯材料 datepicker。支持日期时间，日期，时间，年，月。</li><li><a href="https://vcalendar.io/">VCalendar</a>非常可定制且功能强大的日历&#x2F;日期选择器组件，具有许多功能和完善的文档。</li><li><a href="https://github.com/Owumaro/vue-date-range-picker">@ owumaro &#x2F; vue-date-range-picker</a>-使用 Bootstrap 4 样式进行日期范围选择的 Vue 组件</li><li><a href="https://github.com/ikarosu/vue-datepicker-mobile">vue-datepicker-mobile</a>-适用于 vue2 的移动友好日期选择器。：cn：选择日期或日期范围，然后自定义所需的日期。</li><li><a href="https://github.com/liloow/vue-draggableCal">vue-draggable-cal</a>-不是普通的日期选择器。一个 Vuejs 可拖动的日期选择器，具有全新的响应式设计，可移动且具有 0 个依赖项，已压缩 17kb。</li><li><a href="https://github.com/Shchepotin/vue-vanilla-datetime-picker">vue-vanilla-datetime-picker</a>-Vue 的日期时间选择器。</li><li><a href="https://github.com/Innologica/vue2-daterange-picker/blob/master/README.md">vue2-daterange-picker</a>-基于 bootstrap-daterangepicker 的 Vue2 日期范围选择器(无 jQuery 依赖性)</li><li><a href="https://github.com/alexiscolin/vue-timeselector">vue-timeselector</a>-完全简单可定制的 Vue.js 功能强大的时间选择器组件。</li><li><a href="https://github.com/8788/vue-date-picker">vue-date-picker</a>-Vue 2.x 的轻量级 datepicker 组件。</li><li><a href="https://github.com/chronotruck/vue-ctk-date-time-picker">vue-ctk-date-time-picker</a>-一个漂亮的 VueJS 组件，用于选择日期和时间(使用范围模式)：新：</li><li><a href="https://github.com/jamespjarvis/simple-vue2-datetimepicker">simple-vue2-datetimepicker</a>-一个简单易用的 vue.js 组件，用于日期和时间选择。：新：</li><li><a href="https://github.com/sbarry50/vue-business-hours">vue-business-hours</a>-Vue 组件，用于在管理面板或仪表板中选择营业时间。</li><li><a href="https://github.com/ly525/material-vue-daterange-picker">material-vue-daterange-picker</a>-Vuejs 2.x 的 Material Design 样式的日期范围选择器，与 vuetify 和友好版本兼容手机。</li><li><a href="https://github.com/mathieustan/vue-datepicker">vue-datepicker</a>-具有 Vuejs 2.x 的 Material Design 样式的干净响应式日期选择器。(日期&#x2F;月&#x2F;季度&amp;&amp;日期范围选择器)：新：</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ul><li><a href="https://github.com/sagalbot/vue-select">vue-select</a>-一个本地 Vue.js 组件，提供与 Select2 类似的功能，而无需 jQuery 的开销。</li><li><a href="https://github.com/monterail/vue-multiselect">vue-multiselect</a>-Vue.js 的通用选择&#x2F;多重选择&#x2F;标记组件。</li><li><a href="https://github.com/stfalcon-studio/stf-vue-select">stf-vue-select</a>-最灵活和自定义的选择 Vue2</li><li><a href="https://github.com/mazipan/vue-select-image">vue-select-image</a>-Vue 2 组件，用于从列表中选择图像</li><li><a href="https://github.com/riophae/vue-treeselect">@ riophae &#x2F; vue-treeselect</a>-具有对 Vue.js 的嵌套选项支持的多选组件。</li><li><a href="https://github.com/k186/pd-select">@ k186 &#x2F; pd-select</a>-一个移动 UI 组件，例如 Vue 2.x 的 IOS 选择器，可以随便定义。</li><li><a href="https://github.com/mikerodham/vue-dropdowns">vue-dropdowns</a>-如果对 vue2.x 使用对象，则是一种显示选择框的简约且可适应的方法</li><li><a href="https://github.com/zanseven007/v-cascade">v-cascade</a>-带有 Vue 2.x 的层叠选择器的一个可爱组件(支持 PC 和 Mobile)</li><li><a href="https://github.com/IneoO/vue-multi-select">vue-multi-select</a>-用于对 Vue2 进行选择&#x2F;多重选择的自定义组件。</li><li><a href="https://github.com/TerryZ/v-region">v-region</a>-一个简单的区域选择器，提供中文行政区划数据。</li><li><a href="https://github.com/TerryZ/v-selectpage">v-selectpage</a>-Vue2，分页列表或表格视图的强大选择器，使用标签进行多项选择，i18n 和服务器端资源支持。</li><li><a href="https://github.com/iliyaZelenko/vue-cool-select">vue-cool-select</a>-引导程序&#x2F;材质设计主题，支持广告位，自动填充，事件，验证等。</li><li><a href="https://github.com/myENA/advanced-select">@ myena &#x2F; advanced-select</a>-具有搜索功能，用于(取消)全选和 Bootstrap 3 主题的单&#x2F;多选择组件</li><li><a href="https://github.com/Sandalf/vue-bootstrap-select">@ alfsnd &#x2F; vue-bootstrap-select</a>-Vue 版本的<a href="https://github.com/snapappointments/bootstrap-%E9%80%89%E6%8B%A9/">bootstrap-select</a>。</li></ul><h2 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h2><ul><li><a href="https://github.com/NightCatSama/vue-slider-component">vue-slider-component</a>-vue1.x 和 vue2.x 的滑块。</li><li><a href="https://github.com/devstark-com/vue-circle-slider">vue-circle-slider</a>-vue2.x 的圆形滑块组件。</li><li><a href="https://github.com/fanyeh/vue-slider">vue-netflix-slider</a>-像 Netflix 的滑块。</li><li><a href="https://github.com/biigpongsatorn/vue-slide-bar">vue-slide-bar</a>-非常简单的 vue 滑条组件。</li><li><a href="https://github.com/hosein2398/Textra">textra</a>-Vue js 插件可滑动文本。</li><li><a href="https://github.com/kramer99/vue-knob-control">vue-knob-control</a>-Vue.js 的旋钮控件</li></ul><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul><li><a href="https://github.com/SortableJS/Vue.Draggable">vuedraggable</a>-Vue 组件允许与 View-Model 同步进行拖放排序。基于 Sortable.js。</li><li><a href="https://github.com/Astray-git/vue-dragula">vue-dragula</a>-拖放是如此简单，很痛苦。</li><li><a href="https://github.com/kristianmandrup/vue2-dragula">vue2-dragula</a>-Vue2 的<code>vue-dragula</code>分支，有很多改进。</li><li><a href="https://github.com/hilongjw/vue-dragging">awe-dnd</a>-具有 Vue 的可排序列表指令。</li><li><a href="https://github.com/mauricius/vue-draggable-resizable">vue-draggable-resizable</a>-用于可拖动和可调整大小元素的 Vue2 组件。</li><li><a href="https://github.com/hejianxian/vddl">vddl</a>-用于使用 HTML5 拖放 API 修改列表的 Vue 组件，支持 VueJs 版本 1 和 2。</li><li><a href="https://github.com/cameronhimself/vue-drag-drop">vue-drag-drop</a>-HTML5 拖放 API 的最小且轻巧的包装器。</li><li><a href="https://github.com/goweiwen/vue-swing">vue-swing</a>-可滑动的卡片界面，如在 Jelly 和 Tinder 等应用中所见。</li><li><a href="https://github.com/Jexordexan/vue-slicksort">vue-slicksort</a>-一套无需依赖的混合包，用于动画，触摸友好，可排序的列表</li><li><a href="https://github.com/IsraelZablianov/draggable-vue-directive">draggable-vue-directive</a>-处理任何 Vue 组件拖放的简单指令。</li><li><a href="https://github.com/kutlugsahin/vue-smooth-dnd">vue-smooth-dnd</a>-smooth-dnd 库的 Vue 包装器。拖放，可分类的库，适用于许多情况。</li><li><a href="https://github.com/kirillmurashov/vue-drag-resize">vue-drag-resize</a>-一个无依赖的 Vue 组件，用于可拖动和可调整大小的元素，具有高宽比，反应性道具等</li><li><a href="https://github.com/Esvalirion/vue-drag-it-dude">vue-drag-it-dude</a>-Vue2 组件，可让您将对象拖动到任意位置。</li><li><a href="https://github.com/Vivify-Ideas/vue-draggable">vue-draggable</a>-Vue 拖放库没有任何依赖性。简单易用。</li><li><a href="https://github.com/rhwilr/vue-nestable">vue-nestable</a>-作为 vue 组件制作的简单拖放层次列表。</li><li><a href="https://github.com/phphe/vue-draggable-nested-tree">vue-draggable-nested-tree</a>-适用于 Vuejs2 [@phphe](<a href="https://github.com的功能强大的可自定义可拖动树视图组件./">https://github.com的功能强大的可自定义可拖动树视图组件。</a> com &#x2F; phphe)</li></ul><h2 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h2><ul><li><a href="https://github.com/santiblanko/vue-instant">vue-instant</a>-Vue 即时可让您轻松为 vue 2 应用程序创建带有自动建议的自定义搜索控件。</li><li><a href="https://github.com/paliari/v-autocomplete">v-autocomplete</a>-Vue.js 的自动填充组件</li><li><a href="https://github.com/sandi-racy/vue-awesomplete">vue-awesomplete</a>-Awesomplete 的 Vue 包装器</li><li><a href="https://github.com/charliekassel/vuejs-autocomplete">vue-auto-complete</a>-Vue2 的自动完成。适用于对象或 api 调用。</li><li><a href="https://github.com/Educents/vue-autosuggest">vue-autosuggest</a>-WAI-ARIA 完整的 Autosuggest 组件，对渲染和样式进行了完全自定义。</li><li><a href="https://github.com/soraino/v-autosuggest">v-autosuggest</a>-一个简单的模块化 Vuejs 组件，可以自动建议来自动态或静态数据查询的输入。</li><li><a href="https://github.com/ieski/AutoComplete">自动完成</a>-适用于 Vue.js 2. *的简单自动完成组件</li><li><a href="https://github.com/Attrash-Islam/vue-infinite-autocomplete">vue-infinite-autocomplete</a>-Vue 的 Vue 无限-自动完成包装 2。</li><li><a href="https://github.com/KazanExpress/vue-simple-suggest">vue-simple-suggest</a>-Vue.js 的简单但功能丰富的自动完成组件</li><li><a href="https://github.com/TerryZ/v-suggest">v-suggest</a>-一个 Vue2 插件，用于输入内容建议，支持键盘快速选择。</li><li><a href="https://github.com/alexurquhart/vue-bootstrap-typeahead">vue-bootstrap-typeahead</a>-使用 Bootstrap 4 CSS 的 Vue2 的 typeahead &#x2F; autocomplete 组件。</li></ul><h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><ul><li><a href="https://github.com/matiastucci/vue-input-tag">vue-input-tag</a>-Vue.js 2.0 输入标签组件。</li><li><a href="https://github.com/jcc/v-distpicker">v-distpicker</a>一个灵活，高度可用的区域选择器，用于为 Vue.js 2.x 挑选中国的省，市和地区。</li><li><a href="https://github.com/waynecz/vue-img-inputer">vue-img-inputer</a>Vue 2 的优美，高度可定制的 img 类型输入</li><li><a href="https://github.com/dameety/vue-image-preview">vue-img-preview</a>vue 2 中的图像输入预览组件</li><li><a href="https://github.com/vinayakkulkarni/v-image">v-image</a>：相机：用于输入 type &#x3D; file 的小组件(&lt;1kb，已压缩)</li><li><a href="https://github.com/AlexMordred/vue-tagsinput">@ voerro &#x2F; vue-tagsinput</a>一个简单的标签输入了带有 typeahead &#x2F; autocomplete 的 Vue.js 2 组件</li><li><a href="https://github.com/tomquinonero/vue-tag-selector">vue-tag-selector</a>-类似于标签的输入。轻巧，可自定义并处理 REGEX 验证！</li></ul><h2 id="颜色选择器"><a href="#颜色选择器" class="headerlink" title="颜色选择器"></a>颜色选择器</h2><ul><li><a href="https://github.com/xiaokaike/vue-color">vue-color</a>-适用于 Sketch，Photoshop，Chrome 等的 Vue 拾色器。</li><li><a href="https://github.com/saintplay/vue-swatches">vue-swatches</a>-帮助用户选择漂亮的颜色！</li><li><a href="https://github.com/radial-color-picker/vue-color-picker">radial-color-picker</a>-简约的拾色器，着重于尺寸，可访问性和性能。</li><li><a href="https://github.com/shlomnissan/vue-color-picker-board">vue-color-picker-board</a>-为人类设计的 Vue 拾色器组件！</li><li><a href="https://github.com/baianat/verte">verte</a>-一个完整的 Vue.js 颜色选择器组件。</li></ul><h2 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h2><ul><li><a href="https://github.com/drewjbartlett/vue-switches">vue-switches</a>-具有主题支持的 Vue.js 的开&#x2F;关开关组件。</li><li><a href="https://github.com/euvl/vue-js-toggle-button">vue-js-toggle-button</a>-Vue.js 2.0+切换&#x2F;切换按钮-简单，漂亮，可自定义。</li><li><a href="https://github.com/mariomka/vue-checkbox-radio">vue-checkbox-radio</a>-一个 Vue 组件，可轻松设置复选框和广播输入的样式。</li><li><a href="https://github.com/Keiwen/vue-enhancedCheck">vue-enhanced-check</a>-用于重新设计&#x2F;标记复选框&#x2F;无线电的 Vue 组件，包括切换&#x2F;切换按钮。</li><li><a href="https://github.com/hamed-ehtesham/pretty-checkbox-vue">pretty-checkbox-vue</a>- [pretty-checkbox 3]的实现(<a href="https://lokesh-coder.github.io/pretty-">https://lokesh-coder.github.io/pretty-</a> checkbox &#x2F;)(用于美化复选框和单选按钮的纯 CSS 库)组件，适用于 Vue.js 2.2+。</li><li><a href="https://github.com/roszpun/vue-collapse/">vue2-collapse</a>-Vue Collapse 是一个灵活的内容切换插件，用于手风琴列表或任何其他有条件的内容呈现。</li><li><a href="https://github.com/vanderb/vue-badger-accordion">vue-badger-accordion</a>-用于 Vue.js 2.0+的 Badger 手风琴的包装组件</li><li><a href="https://github.com/Carrene/vue-loading-checkbox">vue-loading-checkbox</a>-具有加载状态的高度可定制的 Vue.js 复选框 UI 组件</li><li><a href="https://github.com/DannyFeliz/vue-rocker-switch">vue-rocker-switch</a>-Vue.js 的可自定义翘板开关组件。</li><li><a href="https://github.com/JonathanDn/vue-toggle-btn">vue-toggle-btn</a>-高度可定制，易于使用的优雅切换&#x2F;切换按钮组件</li></ul><h2 id="屏蔽输入"><a href="#屏蔽输入" class="headerlink" title="屏蔽输入"></a>屏蔽输入</h2><ul><li><a href="https://github.com/niksmr/vue-masked-input">vue-masked-input</a>-Vue.js 的蒙版输入组件。</li><li><a href="https://github.com/text-mask/text-mask">vue-text-mask</a>-用于 React，Angular，Ember，Vue 和普通 JavaScript 的输入掩码。</li><li><a href="https://github.com/lakb248/vue-ip-input">vue-ip-input</a>-由 vuejs 实现的 ip 输入。</li><li><a href="https://github.com/kevinongko/vue-numeric">vue-numeric</a>-输入字段组件，用于显示基于 Vue 的货币值。</li><li><a href="https://github.com/moip/awesome-mask">awesome-mask</a>-基于纯 VanillaJS 实现的 Mask 指令</li><li><a href="https://github.com/vuejs-tips/v-money">v-money</a>-货币的微小(&lt;2k 压缩)输入&#x2F;指令掩码</li><li><a href="https://github.com/autoNumeric/vue-autoNumeric">vue-autonumeric</a>-一个 Vue.js 组件，包装了很棒的<a href="http://autonumeric.org/">AutoNumeric</a>输入格式化程序库</li><li><a href="https://github.com/scleriot/vue-inputmask">vue-inputmask</a>-Vue.js 指令可将 Robin Herbots 的 inputmask 库添加到您的输入中(香草 javascript)。</li><li><a href="https://github.com/joseluisq/vue-input-number">vue-input-number</a>-Vue.js 2 的自定义输入数字组件。</li><li><a href="https://github.com/ndelvalle/v-unicode">v-unicode</a>-Vue 指令通过 unicode 值限制输入。</li><li><a href="https://github.com/ankurk91/vue-cleave-component">vue-cleave-component</a>- [cleave.js]的 Vue.js 组件(<a href="http://nosir.github.io/cleave.js">http://nosir.github.io/cleave.js</a> &#x2F;)</li><li><a href="https://github.com/peteringram0/vue-ip">vue-ip</a>-具有端口和材料设计支持的 ip 地址输入</li><li><a href="https://github.com/raidan00/vue-r-mask">vue-r-mask</a>-具有类似于 javascript 正则表达式的模板的指令。</li><li><a href="https://github.com/zhouyuexie/vue-input-code">vue-input-code</a>-基于 Vue.js 2.0+验证码输入组件。</li><li><a href="https://github.com/myokyawhtun/label-edit">label-edit</a>-受 Trello 的启发。单击以显示可编辑的输入并返回值更改。这是 Vue 组件。</li><li><a href="https://github.com/ankurk91/vue-jquery-mask">vue-jquery-mask</a>- [jQuery Mask 插件]的 Vue.js v2.x 组件(<a href="https://github.com/igorescobar/">https://github.com/igorescobar/</a> jQuery-掩码-插件)</li><li><a href="https://github.com/vuejs-tips/vue-the-mask">vue-the-mask</a>-Tiny(&lt;2k gzipipped)和 Vue.js 的无依赖掩码输入</li><li><a href="https://github.com/loo41/vuc">vue-canvas-input</a>- [vuc-input]的 Vue 画布组件(<a href="http://vuc.tianchenyong.top/#/identify">http://vuc.tianchenyong.top/#/identify</a>)</li><li><a href="https://github.com/dm4t2/vue-currency-input">vue-currency-input</a>-轻松输入 Vue.js 的货币格式数字。</li><li><a href="https://github.com/Scrum/vue-restricted-input">vue-restricted-input</a>-基于[restricted-input]的 vue.js 输入掩码库(<a href="https://github.com/braintree">https://github.com/braintree</a> &#x2F;受限输入)</li></ul><h2 id="RTF-编辑"><a href="#RTF-编辑" class="headerlink" title="RTF 编辑"></a>RTF 编辑</h2><ul><li><a href="https://github.com/surmon-china/vue-quill-editor">vue-quill-editor</a>-Vue2 的鹅毛笔编辑器组件。</li><li><a href="https://github.com/alidcastano/vue-mobiledoc-editor">vue-mobiledoc-editor</a>-适用于 Vuejs 的 mobiledoc 编辑器组件工具包。</li><li><a href="https://github.com/FranzSkuffka/vue-medium-editor">vue2-medium-editor</a>-Vue 2 的 MediumEditor 组件。</li><li><a href="https://github.com/helpbase/vue-froala">vue-froala</a>-用于 Froala 编辑器的 VueJS 包装器。</li><li><a href="https://github.com/froala/vue-froala-wysiwyg">vue-froala-wysiwyg</a>-Froala WYSIWIG HTML 编辑器的官方 VueJS 插件。</li><li><a href="https://github.com/fritx/vue-at">vue-at</a>-Vue 的 At.js。</li><li><a href="https://github.com/chmln/vue-wysiwyg">vue-wysiwyg</a>轻巧，快速且可扩展的所见即所得编辑器</li><li><a href="https://github.com/ankurk91/vue-trumbowyg">vue-trumbowyg</a>[Trumbowyg]的 Vue.js 组件(<a href="http://alex-d.github.io/Trumbowyg/)%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97%E7%BC%96%E8%BE%91%E5%99%A8">http://alex-d.github.io/Trumbowyg/)所见即所得编辑器</a></li><li><a href="https://github.com/CinKon/vue-pell-editor">vue-pell-editor</a>用于<a href="https://jaredreich.com/pell">Pell</a>的 Vue.js 组件所见即所得编辑器</li><li><a href="https://github.com/dyonir/vue-tinymce-editor">vue-tinymce-editor</a>Vue2 的 Tinymce 编辑器组件。</li><li><a href="https://github.com/Eazymov/vue-mce">vue-mce</a>-VueJS 的 tinymce 编辑器组件。</li><li><a href="https://github.com/davidroyer/vue2-editor">Vue2-Editor</a>-使用 Vue.js 和 Quilljs 的 HTML 编辑器</li><li><a href="https://github.com/surmon-china/vue-codemirror">vue-codemirror</a>-Vue2 的 Codemirror 组件。</li><li><a href="https://github.com/m3esma/vue-easy-tinymce">vue-easy-tinymce</a>-一个简单而强大的软件包，可在 Vue.js 项目中轻松使用 tinymce。</li><li><a href="https://github.com/SyedWasiHaider/vue-highlightable-input">vue-highlightable-input</a>-输入文字时突出显示和设置样式</li><li><a href="https://github.com/hanhdt/vue-trix">vue-trix</a>-用于 Vue.js 的简单轻巧的 Trix 富文本编辑器</li><li><a href="https://github.com/heyscrumpy/tiptap">tiptap</a>-Vue.js 的不可渲染且可扩展的 RTF 编辑器</li><li><a href="https://github.com/nhnent/toast-ui.vue-editor">toast-ui.vue-editor</a>- [TOAST UI 编辑器]的 Vue 包装器(<a href="http://ui.toast.com/tui">http://ui.toast.com/tui</a> -编辑)。</li><li><a href="https://github.com/ckeditor/ckeditor5-vue">ckeditor5-vue</a>-Vue.js 的官方 CKEditor 5 Rich Text 编辑器组件。</li><li><a href="https://github.com/yimogit/yimo-vue-editor">yimo-vue-editor</a>-Vue2 的 wangEditor2 组件。</li><li><a href="https://github.com/arnog/vue-mathlive">vue-mathlive</a>适用于 Vue.hjs 的 MathLive 数学编辑器(mathfield)</li></ul><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul><li><a href="https://github.com/Vanthink-UED/vue-core-image-upload">vue-core-image-upload</a>-一个用于裁剪和上传图像的 vue 插件。</li><li><a href="https://github.com/zhanziyang/vue-croppa">vue-croppa</a>-适用于 Vue 2.0 的简单易用的可自定义轻量级移动友好图像裁剪器。</li><li><a href="https://github.com/xyxiao001/vue-cropper">vue-cropper</a>-vue2.0 的图片剪辑插件</li><li><a href="https://github.com/nhnent/toast-ui.vue-image-editor">toast-ui.vue-image-editor</a>- [TOAST UI 图像编辑器]的 Vue 包装器(http：&#x2F;&#x2F; ui。 toast.com&#x2F;tui-image-editor)。</li><li><a href="https://github.com/duyanpeng/vue-quick-cropper">vue-quick-cropper</a>-Vue 移动头像上传裁剪插件可以选择裁剪区域和缩放。</li><li><a href="https://github.com/loo41/vuc">vue-canvas-image</a>-Vue 画布组件，用于<a href="http://vuc.tianchenyong.top/#/image">vuc-image</a></li><li><a href="https://github.com/jofftiquez/vue-croppie">vue-croppie</a>-另一个图像裁剪器</li><li><a href="https://github.com/wannaxiao/vue-slim-cropper">vue-slim-cropper</a>-💇Vue 2.x 的简单优雅的移动图像裁剪上传组件。</li><li><a href="https://github.com/Norserium/vue-advanced-cropper">vue-advanced-cropper</a>-先进的裁剪器，使您有机会创建几乎任何想要的裁剪器</li><li><a href="https://github.com/diegopamio/vue-cloudinary">vue-cloudinary</a>-vue(2.0)插件提供了可重用的指令，可通过动态操作从 Cloudinary(<a href="https://cloudinary.com)获取图像(调整大小/%E8%A3%81%E5%89%AA/%E6%95%88%E6%9E%9C/%E6%B0%B4%E5%8D%B0/%E7%BC%A9%E6%94%BE/%E6%A0%BC%E5%BC%8F%E5%8C%96)%E5%92%8C%E4%BC%98%E5%8C%96">https://cloudinary.com)获取图像(调整大小/裁剪/效果/水印/缩放/格式化)和优化</a>(webp &#x2F; png &#x2F;自动质量&#x2F;自动视网膜)。</li><li><a href="https://github.com/ssshooter/img-vuer">img-Vuer</a>-Vue2 的 Mobile-First 图像查看器&#x2F;图库</li><li><a href="https://github.com/kevindesousa/vue-image-loader">vue-image-loader</a>-Vue 加载器&#x2F;渐进式图像插件，例如 Medium。</li><li><a href="https://github.com/john015/vue-load-image">vue-load-image</a>-在图像加载期间显示加载器，并在图像加载失败时显示替代内容。</li><li><a href="https://github.com/wannaxiao/vue-image-painter">vue-image-painter</a>-V Vue 2.x 的图像魔术动画绘制效果组件。</li></ul><h2 id="视频操作"><a href="#视频操作" class="headerlink" title="视频操作"></a>视频操作</h2><ul><li><a href="https://github.com/MishaPetrov/vue-playlist">vue-playlist</a>-轻量级的 vue(2.0)组件，没有依赖关系，可提供真正无缝的 html5 视频播放。使用 Vanilla JS 进行无缝视频播放的唯一且唯一可行的解 决方案。它需要一系列视频并将它们拼接在一起成为一个视频。</li></ul><p>＃＃ 上传文件</p><ul><li><a href="https://github.com/thetutlage/vue-clip">vue-clip</a>-用于 VueJ 的简单且可入侵的文件上传器。支持 Vue&gt; &#x3D; 2.1。</li><li><a href="https://github.com/saivarunk/vue-simple-upload">vue-simple-upload</a>-Vue.js 的简单文件上传组件。</li><li><a href="https://github.com/updivision/vue2-multi-uploader">vue2-multi-uploader</a>-使用 Vue.js v2 和 Axios 的拖放式多文件上传器组件。上载器显示文件名，大小和添加文件的总大小。它还允许设置所需的最小文件上传数量。</li><li><a href="https://github.com/rowanwins/vue-dropzone">vue-dropzone</a>-Dropzone.js 的 Vue.js(vue2)组件-具有图像预览功能的拖放文件上传实用程序。</li><li><a href="https://github.com/alexsasharegan/vue-transmit">vue-transmit</a>-一个纯粹的基于 Vue 2.0 的 Dropzone.js 的 Vue.js 拖放上传器组件</li><li><a href="https://github.com/lian-yue/vue-upload-component">vue-upload-component</a>-Vue 上载组件，多文件上载，上载目录，拖动上载，拖动目录。支持 Vue&gt; &#x3D; 2.0</li><li><a href="https://github.com/simple-uploader/vue-uploader">vue-uploader</a>-一个由 simple-uploader.js 驱动的 Vue.js 上传组件</li><li><a href="https://github.com/InCuca/ic-firebase-uploader">ic-firebase-uploader</a>-用于 Firebase 存储的干净的多文件上传组件。</li><li><a href="https://github.com/charliekassel/vuejs-uploader">vuejs-uploader</a>-用于大型文件上传的可恢复的分段文件上传器。</li><li><a href="https://github.com/pqina/vue-filepond">vue-filepond</a>-FilePond 的 Vue.js 组件-文件上传库，可以上传您扔给它的任何内容。</li><li><a href="https://github.com/TerryZ/v-uploader">v-uploader</a>-一个 Vue2 插件，可以使上传文件变得更加轻松简单，您可以拖动文件或在对话框中选择文件进行上传</li></ul><h2 id="上下文菜单"><a href="#上下文菜单" class="headerlink" title="上下文菜单"></a>上下文菜单</h2><ul><li><a href="https://github.com/vmaimone/vue-context-menu">vue-context-menu</a>-vue js 的上下文菜单组件。</li><li><a href="https://github.com/timwis/vue-lil-context-menu">vue-lil-context-menu</a>-Vue 的灵活的 lil 上下文菜单组件。</li><li><a href="https://github.com/zgj233/vue-mouse-menu">vue-mouse-menu</a>-适用于 vue 2+的鼠标菜单组件。</li><li><a href="https://github.com/michitaro/vue-menu">@ hscmap &#x2F; vue-menu</a>-vue2 的菜单&#x2F;上下文菜单组件。</li><li><a href="https://github.com/rawilk/vue-context">vue-context</a>-用于 vue js 的简单但灵活的上下文菜单。</li><li><a href="https://github.com/johndatserakis/vue-simple-context-menu">vue-simple-context-menu</a>-为 Vue 构建的简单上下文菜单组件。左键单击和右键单击都可以很好地工作。</li><li><a href="https://github.com/Johnathan/vue-context-menu-popup">vue-context-menu-popup</a>-Vue 2 的上下文菜单弹出窗口。右键单击即可工作，也可以通过编程方式触发。</li><li><a href="https://github.com/Kiyoaki-w/Ki-vue-context">@ kiyoaki_w &#x2F; vue-context</a>-为 Vue2 构建的可自定义上下文菜单组件，支持惊人的图标。</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/ridermansb/vue-gmaps">vue-gmaps</a>-使用 Google Maps API 搜索地点和地址。</li><li><a href="https://github.com/QingWei-Li/vuep">vuep</a>-使用实时编辑器和预览渲染 Vue 组件的组件。</li><li><a href="https://github.com/Gomah/vue-places">vue-places</a>-Places 组件基于 Vue 2.x 的 places.js。将任何输入转换为地址自动完成。</li><li><a href="https://github.com/apertureless/vue-password-strength-meter">vue-password-strength-meter</a>-vue.js 中基于 zxcvbn 的密码强度计。</li><li><a href="https://github.com/bkzl/vue-float-label">vue-float-label</a>-Vue.js 的浮动标签模式。</li><li><a href="https://github.com/javisperez/vuelongpress">vue-longpress</a>-一个 VueJS(2.x)按钮组件，需要您持续按下以确认给定的动作。</li><li><a href="https://github.com/olefirenko/vue-google-autocomplete">vue-google-autocomplete</a>-适用于 Google Maps Places API 的 Vue.js(2.x)自动建议组件。</li><li><a href="https://github.com/lakb248/vue-ip-input">vue-ip-input</a>-Vue.js 2.x 的 ip 输入组件</li><li><a href="https://github.com/termosa/vue-default-value">vue-default-value</a>-Vue.js 2.x 指令为可编辑元素设置默认值，而不会影响模型状态</li><li><a href="https://github.com/outluch/vue-model-autoset">vue-model-autoset</a>-一个 Vue.js 插件，可解决通过 v-model 指令观察动态添加的属性时 Vue 的限制</li><li><a href="https://github.com/NxtChg/pieces/tree/master/js/vue/vue-submit">vue-submit</a>-Ladda 的简单实现([1](<a href="http://lab.hakim.se/">http://lab.hakim.se</a> &#x2F;ladda&#x2F;)，<a href="https://msurguy.github.io/ladda-bootstrap/">2</a>)不到 90 行代码，没有任何依赖关系。</li><li><a href="https://github.com/SinanMtl/vue-rate">vue-rate</a>-Vue 的费率组件</li><li><a href="https://github.com/MadimetjaShika/vuetify-google-autocomplete">vuetify-google-autocomplete</a>-适用于 Google Maps Places API 的 Vuetify 就绪 Vue.js(2.x)自动建议组件。</li><li><a href="https://github.com/PygmySlowLoris/vue-ripple-directive">vue-ripple-directive</a>-材质纹波效果作为 Vue 指令。</li><li><a href="https://github.com/PygmySlowLoris/vue-fab">vue-fab</a>-Vue 浮动操作按钮。</li><li><a href="https://github.com/mazipan/vue-complexify">vue-complexify</a>-来自 jquery.complexify.js 的 Vuejs 移植库。</li><li><a href="https://github.com/FiguredLimited/vue-mc">vue-mc</a>-Vue.js 的模型和集合</li><li><a href="https://www.tallent.us/vue-stars/">vue-stars</a>-高度可定制的等级控制(使用星号或其他字符)</li><li><a href="https://github.com/imRohan/vue-confirmation-button">vue-confirmation-button</a>-可自定义的确认按钮，要求用户在执行操作之前先阅读消息</li><li><a href="https://github.com/ppietris/vue-poll">vue-poll</a>-用于投票的 Vue.js 组件</li><li><a href="https://github.com/gwenaelp/vue-diagrams">vue-diagrams</a>-vue.js 的图表组件，受 react-diagrams 启发</li><li><a href="https://github.com/updivision/vue-easy-polls">vue-easy-polls</a>-一个 Vue.js 组件，用于创建民意调查，投票和显示结果。它易于实现且易于定制。</li><li><a href="https://github.com/mengdu/m-button">vue-m-button</a>-vue 的漂亮按钮组件。</li><li><a href="https://github.com/ittus/vue-long-click">vue-long-click</a>-用于 vue 的长按(长按)指令库，支持移动设备和台式机。</li><li><a href="https://github.com/FGRibreau/ui-predicate/tree/master/packages/ui-predicate-vue">vue-ui-predicate</a>-规则编辑器，通用过滤 UI，Vue JS 的谓词组件。</li><li><a href="https://github.com/ajerez/vue-mobile-detection">vue-mobile-detection</a>-Vue.js 原型函数<code>this。$ isMobile()</code>会根据布尔值是否返回布尔值用户正在使用手机浏览。</li><li><a href="https://github.com/Cobertos/vue-input-contenteditable">vue-input-contenteditable</a>-用于&#96;contenteditable’的 Vue 组件包装，具有您通常期望的所有功能。进行漂亮的输入，不受“ input [type &#x3D;’text’]”的限制。</li></ul><h2 id="向导"><a href="#向导" class="headerlink" title="向导"></a>向导</h2><ul><li><a href="https://github.com/cristijora/vue-form-wizard">vue-form-wizard</a>-基于选项卡的组件，可以代替经典的 bootstrap 和 jQuery 表单向导</li><li><a href="https://github.com/PygmySlowLoris/vue-stepper">vue-stepper</a>-一个简单的步进器，具有诸如 next，back 和 end 之类的简单动作，可以执行简单的表单。</li><li><a href="https://github.com/adi518/vue-stepper-component">vue-stepper-component</a>-具有 Vuex 支持和零依赖性的完全可定制的 Stepper 组件。</li></ul><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><ul><li><a href="https://github.com/ynishi/vuecsv">vuecsv</a>-来自 json 的简单 CSV 下载程序，带有选项模式面板组件。</li></ul><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><ul><li><a href="https://github.com/TugayYaldiz/vue-comment-grid">vue-comment-grid</a>-💬 使用 CSS Grid 和 Firebase REST API + Authentication 构建的自适应 Vue.js 注释系统插件。</li></ul><h2 id="帆布"><a href="#帆布" class="headerlink" title="帆布"></a>帆布</h2><ul><li><a href="http://github.com/dankuck/vue-easeljs">vue-easeljs</a>-对 HTML5 canvas 元素的数据驱动控制。</li><li><a href="https://github.com/chenxuan0000/vue-canvas-effect">vue-canvas-effect</a>-Vue.js 的简单画布效果集合。</li><li><a href="https://github.com/rafaesc/vue-konva">vue-konva</a>-Vue＆Canvas-JavaScript 库，用于使用 Vue 绘制复杂的画布图形。</li><li><a href="https://github.com/mycure-inc/vue-html2canvas">vue-html2canvas</a>-Vue mixin 捕获 html 并使用 Html2Canvas 将其转换为图像。</li><li><a href="https://github.com/ZYSzys/vue-canvas-nest">vue-canvas-nest</a>-适用于 canvas-nest 的 Vue.js 组件。</li><li><a href="https://github.com/neighborhood999/vue-signature-pad">vue-signature-pad</a>-V Vue 签名板组件</li></ul><h2 id="链接预览"><a href="#链接预览" class="headerlink" title="链接预览"></a>链接预览</h2><ul><li><a href="https://github.com/nivaldomartinez/link-prevue">link-prevue</a>-用于生成链接预览的灵活组件。</li></ul><h2 id="游览"><a href="#游览" class="headerlink" title="游览"></a>游览</h2><ul><li><a href="https://github.com/pulsardev/vue-tour">vue-tour</a>-轻巧且可自定义的游览插件</li><li><a href="https://github.com/sschandi/vue-page-guide">vue-page-guide</a>-具有指令的页面游览&#x2F;指南插件</li></ul><h2 id="UI-布局"><a href="#UI-布局" class="headerlink" title="UI 布局"></a>UI 布局</h2><ul><li><a href="https://github.com/MopTym/vue-waterfall">vue-waterfall</a>-Vue.js 的瀑布布局组件。</li><li><a href="https://github.com/David-Desmaisons/Vue.Isotope">vueisotope</a>-用于同位素过滤器和分类魔术布局的 Vue 组件。</li><li><a href="https://github.com/jbaysolutions/vue-grid-layout">vue-grid-layout</a>-Vue.js 的可拖动和可调整大小的网格布局。</li><li><a href="https://github.com/surmon-china/vue-drag-zone">vue-drag-zone</a>-Vue.js(2.x)的拖动区域组件。</li><li><a href="https://github.com/shershen08/vue-masonry">vue-masonry</a>-用于砌体块布局的 Vue.js 指令。</li><li><a href="https://github.com/bkzl/vue-fraction-grid">vue-fraction-grid</a>-基于 Flexbox 的 Vue.js 响应式分数网格系统。</li><li><a href="https://github.com/tangbc/vue-virtual-scroll-list">vue-virtual-scroll-list</a>-Vue(2.x)组件通过使用虚拟滚动列表支持大数据。</li><li><a href="https://github.com/Akryum/vue-virtual-scroller">vue-virtual-scroller</a>-用于有效滚动大量元素的组件(Vue 2.x)。</li><li><a href="https://github.com/ddgll/vue-virtualscroll">vue-virtualscroll</a>- [Vue 2.x]组件用于虚拟滚动内容。</li><li><a href="https://github.com/rachmanzz/vue-inview">vue-inview</a>- [Vue 2.x]视口，在输入或离开 DOM 元素时获取通知。</li><li><a href="https://github.com/dattn/dnd-grid">dnd-grid</a>-具有可拖动和可调整大小的框的 vuejs 网格</li><li><a href="https://github.com/ktquez/vue-extend-layout">vue-extend-layout</a>-扩展默认布局或为 Vue.js SPA 的页面创建自定义布局</li><li><a href="https://github.com/paulcollett/vue-masonry-css">vue-masonry-css</a>-由 CSS 驱动的 Vue.js Masonry 布局组件，无依赖</li><li><a href="https://github.com/alvarotrigo/vue-fullpage.js">vue-fullpage.js</a>-Vue.js 的官方 fullPage.js 组件。</li><li><a href="https://github.com/starkwang/vue-virtual-collection">vue-virtual-collection</a>-用于有效渲染大型集合数据的 Vue 组件。</li><li><a href="https://github.com/xudafeng/autosensitive-vue">自动响应-vue</a>-Vue 的自动响应网格布局库。</li><li><a href="https://github.com/SeregPie/VueFlex">VueFlex</a>-一个 flexbox 网格系统。</li><li><a href="https://gitlab.com/shellyBits/v-chacheli">v-chacheli</a>-一个 Vue.js 组件，用于创建和显示类似于仪表板的自定义网格布局。</li><li><a href="https://github.com/mattrothenberg/vue-grid-styled">vue-grid-styled</a>-一组轻量级的功能网格组件，从 React 的<a href="https://github.com移植/">grid-styled</a> &#x2F; jxnblk &#x2F;网格样式&#x2F;)</li><li><a href="https://github.com/anthinkingcoder/simple-grid">简单网格</a>-用于网格布局的 Vue 组件，支持 flex。</li><li><a href="https://github.com/kavalcante/vue-container-component">vue-container-component</a>-受 Bootstrap 容器启发的简单容器组件</li><li><a href="https://github.com/alexiscolin/vue-colcade">vue-colcade</a>-用于将 Colcade 网格布局集成到 Vuejs 的小包装。</li><li><a href="https://github.com/arnedesmedt/vue-ads-layout">vue-ads-layout</a>-一个小的 Vue 组件库，可快速生成带有工具栏，左&#x2F;右抽屉和页脚的响应式 Web 应用程序布局。所有组件都可以固定或相对放置。</li><li><a href="https://github.com/imlinus/Vue-Magic-Grid">vue-magic-grid</a>-Vue.js 2 的 Magic Grid 小端口。</li><li><a href="https://github.com/venkatperi/vue-splitter-pane">vue-splitter-pane</a>-一个 Vuejs 组件，它以可调节的拆分方式(垂直或水平)呈现两个插槽。</li><li><a href="https://github.com/antoniandre/splitpanes">splitpanes</a>-一个 Vue JS 可靠，简单且可触摸的窗格拆分器&#x2F;缩放器。</li><li><a href="https://github.com/promosis/vue-mock-layout">vue-mock-layout</a>-轻松模拟 Vue 应用程序的布局。</li><li><a href="https://github.com/dreambo8563/vue-simple-drawer">vue-simple-drawer</a>-带有反弹动画，支持嵌套和自定义主题的小抽屉面板。方向：左&#x2F;右&#x2F;上&#x2F;下</li><li><a href="https://github.com/1000ch/vue-grd">vue-grd</a>-用于网格布局的简单，轻巧和灵活的 Vue.js 组件。</li></ul><h2 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h2><ul><li><a href="https://github.com/quasarframework/quasar">quasar-framework</a>-类星体框架。使用 VueJs 2 使用相同的代码构建响应式网站，混合移动应用程序(在 Android 和 iOS 上看起来本机)和 Electron 应用程序。</li><li><a href="https://github.com/vuematerial/vue-material">vue-material</a>-Vue.js 的材料设计。</li><li><a href="https://github.com/vuetifyjs/vuetify">vuetify</a>-Vue.js 的材料组件框架 2。</li><li><a href="https://github.com/museui/muse-ui">muse-ui</a>-Vue.js 的材料组件库 2。</li><li><a href="https://github.com/rafaelpimpa/buefy">buefy</a>-基于布尔玛框架的组件。</li><li><a href="https://github.com/ElemeFE/element">element-ui</a>-用于 Web 的 Vue.js 2.0 UI 工具包。</li><li><a href="https://github.com/vouill/vue-bulma-components">vue-bulma-components</a>-对 vue 组件轻松使用 bulma 类语法。</li><li><a href="https://www.iviewui.com/">iview-ui</a>-适用于 Web 的 Vue.js 2.0 UI 框架。</li><li><a href="https://at.aotu.io/">AT-UI</a>-Vue.js 2.0 使用 ♥ 制作的专门用于桌面应用程序的全新扁平 UI-Kit</li><li><a href="https://www.npmjs.com/package/v-semantic">v-semantic</a>-Vue 的<a href="https://semantic-ui.com/">semantic-ui</a>的实现</li><li><a href="https://bootstrap-vue.github.io/">bootstrap-vue</a>-Vue.js 2 的<a href="https://getbootstrap.com/">bootstrap-4</a>网格和组件的实现。</li><li><a href="https://myliang.github.io/fish-ui">fish-ui</a>-用于 Web 的 Vue.js 2.0 UI 工具包</li><li><a href="https://github.com/zircleUI/zircleUI">zircle-ui</a>-开发可缩放用户界面的前端库。</li><li><a href="https://github.com/stasson/vue-mdc-adapter">vue-mdc-adapter</a>-根据 MDC 团队[指南]的 Vue.js 的材料组件集成(<a href="https://github.com/material">https://github.com/material</a> -components &#x2F; material-components-web &#x2F; blob &#x2F; master &#x2F; docs &#x2F; integrating-into-frameworks.md)。</li><li><a href="https://github.com/matsp/material-components-vue">Material Components Vue</a>- [material-components-web]的包装器(<a href="https://github.com/material-components/material-components-%E7%BD%91%E7%BB%9C)%E7%9A%84">https://github.com/material-components/material-components-网络)的</a> Vue.js</li><li><a href="https://github.com/sudheerj/vueface">VueFace</a>-用于 Web 的 Vue.js 2.0 UI 组件库</li><li><a href="https://github.com/lusaxweb/vuesax">vuesax</a>-Vue.js 的前端 vue 组件。</li><li><a href="https://bitbucket.org/acidmartin/vuecidity">vuecidity</a>-Vue.js 2.0 的 UI 组件框架</li><li><a href="https://github.com/vueComponent/ant-design-vue">ant-design-vue</a>-基于 Ant Design 和 Vue 2.5.0 的企业级 UI 组件</li><li><a href="https://github.com/heyui/heyui">heyui</a>-(<a href="https://www.heyui.top/zh)-%E9%80%82%E7%94%A8%E4%BA%8E">https://www.heyui.top/zh)-适用于</a> Web 的 Vue.js 2.0 UI 工具包。</li><li><a href="https://carvuejs.github.io/">Carvue.js</a>-IBM 的 Vue.js 碳设计系统</li><li><a href="https://material.balmjs.com/">BalmUI</a>-Vue.js 的下一代 Material UI</li><li><a href="https://osiris-ui.github.io/osiris">Osiris UI</a>-：art：一个 Vue.js 2.0 通用响应式 UI 组件库</li><li><a href="https://github.com/N3-components/N3-components">N3-components</a>-使用 Vue 2 构建的漂亮 Web 组件</li><li><a href="https://github.com/designrevision/shards-vue">碎片 Vue</a>-✨ 基于 Bootstrap 4 框架的时尚＆UI 组件库。</li><li><a href="https://github.com/SAP/fundamental-vue">基础 Vue</a>-基于 SAP Fiori 基础的组件。</li><li><a href="https://github.com/framevuerk/framevuerk">Framevuerk</a>-🚀 快速，响应迅速，无依赖性，基于 Vue.js 的方向支持和可配置 UI 框架。</li><li><a href="https://github.com/carbon-design-system/carbon-components-vue">@ Carbon &#x2F; vue</a>-@carbon 团队的 Carbon Design System 组件。</li><li><a href="https://github.com/jdf2e/nutui/">NutUI</a>-适用于移动网络的 Vue.js 2.0 UI 工具包</li><li><a href="https://github.com/inkline/inkline/">Inkline</a>-Inkline 是用于 Vue.js 的现代 UI &#x2F; UX 框架，旨在创建完美的响应式 Web 应用程序。</li><li><a href="https://github.com/Wscats/vue-awesome-mui">vue-awesome-mui</a>-用于 Web 的 Vue.js 2.0 MUI 组件</li><li><a href="https://github.com/mdbootstrap/Vue-Bootstrap-with-Material-Design">MDBootstrap</a>-基于最新的 Bootstrap 4 和 Vue 2.6.10 的强大 UI 工具包，提供了一组平滑的，响应式页面模板，布局，组件和小部件，以快速构建响应迅速，移动优先的网站和应用。</li></ul><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><ul><li><a href="https://github.com/framework7io/framework7">Framework7-Vue</a>-使用 Framework7＆Vue 构建功能齐全的 iOS 和 Android 应用。</li><li><a href="https://github.com/airyland/vux">vux</a>- [中文]基于 WeUI 的 Vue UI 组件。</li><li><a href="https://github.com/OnsenUI/OnsenUI">vue-onsenui</a>-使用 HTML5 和 JavaScript 的移动应用开发框架和 SDK。创建美观，高性能的跨平台移动应用程序。基于 Web 组件，并提供 Angular 1、2，React 和 Vue.js 的绑定。</li><li><a href="https://weex.incubator.apache.org/">Weex</a>-Weex 提供了发布跨平台的功能，因此 Web，Android 和 IOS 应用程序可以使用相同的 API 开发功能。</li><li><a href="https://github.com/bmfe/eros-template">weex-eros</a>- [中文] Eros 是基于 Weex 和 Vue 的应用程序解决方案，使您能够使用 Vue 的 API，简单快速地开发 Vue 中小型应用程序。</li><li><a href="https://github.com/ElemeFE/mint-ui">mint-ui</a>-Vue.js 的移动 UI 元素。</li><li><a href="https://github.com/youzan/vant">vant</a>-来自 YouZan 的 Vue.js 2.0 移动用户界面。</li><li><a href="https://didi.github.io/cube-ui">cube-ui</a>-Vue.js 编写的出色的移动 ui lib 实现 2。</li><li><a href="https://didi.github.io/mand-mobile">mand-mobile</a>-基于 Vue.js 2 的移动 UI 工具包，专为金融场景而设计。</li></ul><h2 id="组件集合"><a href="#组件集合" class="headerlink" title="组件集合"></a>组件集合</h2><ul><li><a href="https://github.com/posva/vue-mdc">vue-mdc</a>-Vue.js 的 Material Components Web。</li><li><a href="https://github.com/JosephusPaye/Keen-UI">keen-ui</a>-用 Vue 编写并受 Material Design 启发的基本 UI 组件的轻量级集合。</li><li><a href="https://github.com/vue-bulma/vue-admin">vue-admin</a>-Vue 管理面板框架，由 Vue 2.0 和 Bulma 0.3 提供支持。</li><li><a href="https://github.com/vuikit/vuikit">vuikit</a>-具有 Vue 所有功能的 UIkit。</li><li><a href="https://github.com/wxsms/uiv">uiv</a>由 Vue2 实现的 Bootstrap3 组件。</li><li><a href="https://github.com/wffranco/vue-strap">wffranco &#x2F; vue-strap</a>-使用 Vue.js 2 构建的 Bootstrap 3 组件</li><li><a href="https://github.com/chaogao/jsmod-pc-vue">jsmod-vue-pc</a>-适用于 vue 2.0 的高度可扩展的 Web 组件</li><li><a href="https://github.com/guilhermewaess/SemVue">guilhermewaess &#x2F; SemVue</a>-使用 Vue 2 实现的语义 UI 模块</li><li><a href="https://github.com/aidewoode/office-ui-fabric-vue">office-ui-fabric-vue</a>-Vue.js 的 Office UI Fabric 实现</li><li><a href="https://github.com/epicmaxco/vuestic-admin">vuestic-admin</a>-带有自定义组件集合的 Vue Admin 仪表板。内置 Vue 2 和 Bootstrap 4</li><li><a href="https://github.com/Semantic-UI-Vue/Semantic-UI-Vue">语义 UI Vue</a>-Vue 的语义 UI 集成</li><li><a href="https://github.com/lusaxweb/vuesax">vuesax</a>-Vue.js 的前端 vue 组件。</li><li><a href="https://www.syncfusion.com/products/vue">Vue 的基本 JS 2</a>-功能齐全的 45+ Vue.js 组件，其中包括数据网格，图表，计划程序和图表组件等。</li><li><a href="https://github.com/banshee-ui/banshee">Banshee</a>-一个几乎没有渲染的 Vue UI 组件和实用程序框架，没有 CSS。</li><li><a href="https://github.com/nvms/vue-atlas">vue-atlas</a>-漂亮的 Vue 组件库。</li><li><a href="https://github.com/DevExpress/devextreme-vue">DevExtreme Vue 组件</a>-65+响应迅速且功能完善的 Vue UI 组件，具有可自定义的 Material Design 和 Bootstrap 兼容主题。</li><li><a href="https://www.jqwidgets.com/vue/">jqwidgets</a>-70 多个具有 Material Design 主题的 Vue.js 2.0 UI 组件。</li><li><a href="https://github.com/juijs/vue-uix">vue-uix</a>-Vue.js 中用于网页实现的 UI 集合</li><li><a href="https://github.com/LeCoupa/vuedarkmode">vuedarkmode</a>-Vue.js 的极简暗设计系统 🎨</li><li><a href="https://www.telerik.com/kendo-vue-ui/components/">Kendo Vue 用户界面</a>–为业务应用程序构建的 70 多个 UI 组件，包括网格。对多种设计语言(包括材料设计和 Bootstrap)的支持完全响应。</li><li><a href="https://github.com/arturmiz/vuent">Vuent</a>-实现 Microsoft Fluent Design 的 Vue.js 组件</li><li><a href="https://github.com/dreambo8563/bpit-vue">bpit &#x2F; vue</a>-专注于效果的 Vue 组件库</li><li><a href="https://github.com/alfonsobries/vue-tailwind">vue-tailwind</a>-具有可自定义类的 Vue 组件可用于 TailwindCSS，但与任何框架兼容。</li></ul><h2 id="管理模板"><a href="#管理模板" class="headerlink" title="管理模板"></a>管理模板</h2><ul><li><a href="https://github.com/TonyLuo/iview-vue-admin">iView Vue 管理员</a>-iView Vue 管理员&#x2F;基于 iView 2.x 的管理门户模板</li><li><a href="https://github.com/TonyLuo/element-vue-admin">element Vue Admin</a>-element Vue Admin &#x2F;基于 Element UI 2.x 的管理门户模板</li><li><a href="https://github.com/PanJiaChen/vue-element-admin">vue-element-admin</a>-基于 Element UI 2.x 的神奇 vue 管理员</li><li><a href="https://github.com/d2-projects/d2-admin">D2 管理员</a>-vue 制作的优雅后台模板<a href="https://d2admin.fairyever.com/">在线演示</a></li><li><a href="https://github.com/wxs77577/rest-admin">rest-admin</a>-基于 Vue 和 Bootstrap 4 的 Restful 管理面板<a href="http://rest-admin.genyii.com/">在线演示</a></li><li><a href="https://github.com/DesignRevision/shards-dashboard-vue">Shards Dashboard Lite Vue</a>-✨ 现代管理模板，具有数十个自定义组件和模板。</li><li><a href="https://github.com/tookit/vue-material-admin">Vue 材质管理员</a>-Vue 材质设计管理员模板</li><li><a href="https://github.com/codetrial/element-admin">element-admin</a>-使用 Vue CLI 3 和 element-ui 的简单而强大的 vue 管理员。</li></ul><h2 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h2><ul><li><a href="https://github.com/nuxt/nuxt.js">Nuxt.js</a>-通用的 Vue.js 框架。</li><li><a href="https://github.com/ream/ream">Ream</a>-用于构建服务器呈现的静态网站的简约框架。</li><li><a href="https://github.com/universal-vue/uvue">Universal vue</a>-Vue CLI 插件，可轻松创建通用 Vue 应用程序</li></ul><h2 id="静态网站生成器"><a href="#静态网站生成器" class="headerlink" title="静态网站生成器"></a>静态网站生成器</h2><ul><li><a href="https://github.com/vuejs/vuepress">VuePress</a>-简约的 Vue 驱动的静态网站生成器。</li><li><a href="https://github.com/egojump/peco">Peco</a>-人类的静态网站生成器。未维护</li><li><a href="https://github.com/egoist/saber">Sabre</a>-一个静态网站生成器，用于使用 Vue.js 构建快速的网站。</li><li><a href="https://github.com/gridsome/gridsome">Gridsome</a>-使用 Vue.js 构建超快速，现代化的网站</li></ul><h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/scriptPilot/app-framework">app-framework</a>-具有 HTML 和 JavaScript 的 IOS 和 Android 应用程序-开发，构建和部署-免费和开源。</li><li><a href="https://github.com/myfirebase/myfirebase">Myfirebase</a>-一种已解耦的单页应用程序框架，该框架与 google firebase 高度兼容。</li><li><a href="https://github.com/tower1229/Vue-Access-Control">Vue-Access-Control</a>基于 Vue.js 的前端访问控制框架 2。</li><li><a href="https://github.com/basys/basys">Basys</a>工具箱，用于构建完整的 Vue.js 应用程序</li><li><a href="https://github.com/zhennann/cabloy">CabloyJS</a>基于 KoaJS＆EggJS＆VueJS＆Framework7 的终极 NodeJS 全栈业务开发平台</li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li><a href="https://github.com/iFgR/vue-shortkey">vue-shortkey</a>-Vue-ShortKey-Vue.js 的插件。</li><li><a href="https://github.com/scaccogatto/vue-throttle-event">vue-throttle-event</a>-基于 requestAnimationFrame 的油门事件。</li><li><a href="https://github.com/scaccogatto/vue-waypoint">vue-waypoint</a>-Vue 的 Waypoint 组件，这是滚动时触发功能的最简单方法。</li><li><a href="https://github.com/simplesmiler/vue-clickaway">vue-clickaway</a>-可重用的 Vue.js 组件的可重用 clickaway 指令。</li><li><a href="https://github.com/vue-comps/vue-scrollfire">vue-scrollfire</a>-在特定的滚动位置触发事件。</li><li><a href="https://github.com/David-Desmaisons/Vue.resize">vue-resize-directive</a>-Vue 指令可检测具有去污和节流能力的调整大小事件。</li><li><a href="https://github.com/ndelvalle/v-click-outside">v-click-outside</a>-Vue 指令对元素外部的点击做出反应，而不会停止事件传播。</li><li><a href="https://github.com/nchutchind/vue-outside-events">vue-outside-events</a>-Vue 2.x 指令可帮助指定元素侦听发生在自身外部的特定事件。</li><li><a href="https://github.com/JSmith01/vue-selectable">vue-selectable</a>-Vue 1.x &#x2F; 2.x 指令可通过鼠标选择项目。</li><li><a href="https://github.com/huangshuwei/vue-click-helper">vue-click-helper</a>-Vue2.x 指令可处理同一元素上的 click 事件和 dblclick 事件。</li><li><a href="https://github.com/Dafrok/v-hotkey">v-hotkey</a>-Vue 2.x 指令，用于将热键绑定到组件。</li><li><a href="https://github.com/Akryum/vue-resize">vue-resize</a>-Vue 2.x 组件可检测 DOM 元素的大小调整(基于事件&#x2F;无 window.onresize)</li><li><a href="https://github.com/Akryum/vue-observe-visibility">vue-observe-visibility</a>-使用 Intersection Observer API 的 Vue 2.x 指令可检测元素是否可见(在视口中是否被隐藏) CSS)。</li><li><a href="https://github.com/zhanziyang/v-dragged">v-dragged</a>-用于拖动事件检测的 Vue 2.x 指令插件。</li><li><a href="https://github.com/ianaya89/vue-esc">vue-esc</a>-Vue.js 指令，可在转义键盘上添加文档事件监听器。</li><li><a href="https://github.com/shentao/vue-global-events/">vue-global-events</a>–使用 Vue 的事件修饰符处理全局事件(如快捷方式)的组件</li><li><a href="https://github.com/gu-fan/vue-edge-check/">vue-edge-check</a>–检查浏览器边缘，以防止用&#96;vue-router’滑动边缘时奇怪地触发过渡效果</li><li><a href="https://github.com/PNKBizz/vue-mutation-observer">vue-mutation-observer</a>–使用 MutationObserver API 观察 DOM 中变化的简单而微小的指令</li><li><a href="https://github.com/AlekseyPleshkov/vue-scroll-show">vue-scroll-show</a>–如果用户在滚动后到达该元素，则显示该元素</li><li><a href="https://github.com/Almoullim/vue-tabevents">vue-tabevents</a>–其他打开的标签页之间易于通信</li><li><a href="https://github.com/shwilliam/vue-visibility-trigger">vue-visibility-trigger</a>-👀 滚动到视图时以声明方式触发方法</li></ul><h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><ul><li><a href="https://github.com/scaccogatto/vue-viewports">vue-viewports</a>-定义您的自定义视口，并在组件中使用它们。</li><li><a href="https://github.com/reinerBa/Vue-Responsive">vue 响应</a>：Vue.js(2.x)指令用于隐藏&#x2F;显示具有 Bootstrap 4、3 或自定义断点的 HTML 元素。</li><li><a href="https://github.com/drenglish/vue-match-media">vue-match-media</a>-Vue 2.x 兼容插件，提供一致，语义化的方法来使组件具有媒体查询意识。</li><li><a href="https://github.com/jofftiquez/vue-media-query-mixin">vue-media-query-mixin</a>-Vue 2 媒体查询 mixin 可以在组件 js 和组件模板中使用。与引导程序和可视化视口兼容。如果屏幕宽度为 xs，则返回 wxS；如果屏幕宽度为 sm，则返回 wSM。</li><li><a href="https://github.com/apertureless/vue-breakpoints">vue-breakpoints</a>-Vue 2 最小组件，用于显示和隐藏基于断点的元素。受到 Airbnb 的启发。</li><li><a href="https://github.com/AlexandreBonaventure/vue-mq">vue-mq</a>-提供一些有用的工具，以语义和移动优先的 API(Vue 2.x)快速设置响应式设计</li><li><a href="https://github.com/SeregPie/VueResizeSensor">VueResizeSensor</a>-支持调整大小事件的容器。</li><li><a href="https://github.com/adi518/vue-breakpoint-component">vue-breakpoint-component</a>-用于 组成 CSS 断点状态。</li><li><a href="https://github.com/nash403/fine-mq">fine-mq</a>-一个很好的 API，可以轻松地管理 JS 中的媒体查询，并且可以与 VueJS 作为插件进行一流的集成。</li><li><a href="https://github.com/Kelin2025/vue-sensitive-components">vue-response-components</a>-使用<code>ResizeObserver</code>创建响应组件。</li><li><a href="https://github.com/promosis/vue-screen-size">vue-screen-size</a>-可以轻松，被动地访问屏幕的宽度和高度。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li><a href="https://github.com/formly-js/vue-formly">vue-formly</a>-JavaScript 支持的 Vue.js 表单。</li><li><a href="https://github.com/simplesmiler/vue-focus">vue-focus</a>-用于可重用 Vue.js 组件的可重用 focus 指令。</li><li><a href="https://github.com/icebob/vue-form-generator">vue-form-generator</a>-Vue.js 的基于架构的表单生成器组件。</li><li><a href="https://gitlab.com/formschema/native">FormSchema Native</a>-使用 JSON Schema 和 Vue.js 生成表单</li><li><a href="https://github.com/InCuca/ic-formly">ic-formly</a>-由 vue-formly 提供支持的简单表单组件。</li><li><a href="https://github.com/laravel-enso/formbuilder">表单生成器</a>-基于 Json 模板的表单生成器，基于 Vue 和 Laravel。</li><li><a href="https://github.com/Botre/vue-autofocus-directive">vue-autofocus-directive</a>-Vue 自动聚焦指令。</li><li><a href="https://github.com/fightingm/vue-awesome-form">vue-awesome-form</a>-一个 vue.js 组件，就像 json-editor</li><li><a href="https://github.com/antonreshetov/vue-form-components">vue-form-components</a>-带有验证的干净＆最小化 vue 表单元素</li><li><a href="https://github.com/ncform/ncform">ncform</a>-一种非常好的配置生成表单的方式</li><li><a href="https://github.com/logaretm/vee-validate">vee-validate</a>-简单的 Vue.js 输入验证插件。</li><li><a href="https://github.com/xpepermint/vue-rawmodel">vue-rawmodel</a>-Vue.js v2 的 RawModel.js 插件。表单验证从未如此简单。</li><li><a href="https://github.com/monterail/vuelidate">vuelidate</a>-针对 Vue.js 的简单，轻量级基于模型的验证。</li><li><a href="https://github.com/semisleep/simple-vue-validator">simple-vue-validator</a>-一个简单而灵活的 vue.js 验证器库。</li><li><a href="https://github.com/joseluisq/vue-vform">vue-vform</a>-Vue.js 2 表单组件，集成了 jQuery 验证和 Axios。</li><li><a href="https://github.com/fergaldoyle/vue-form">vue-form</a>-Vue.js 的全面表单验证。</li><li><a href="https://github.com/cj/vuelidation">vuelidation</a>-简单，功能强大的 vuejs 验证。</li><li><a href="https://github.com/val-bubbleflat/laravel-vue-validator">laravel-vue-validator</a>-显示来自 laravel 验证规则的错误</li><li><a href="https://github.com/deulos/vue-daval">vue-daval</a>-超级 vue 数据验证器。简便，简单，准确。</li><li><a href="https://github.com/gustavoSoriano/willvalidate">willvalidate</a>-Vue.js 的验证表单。</li><li><a href="https://github.com/silksofthesoul/vue-m-validator">vue-m-validator</a>-用于 VueJ 的模型数据验证库。</li><li><a href="https://github.com/Pitu/vue-isyourpasswordsafe">vue-isyourpasswordsafe</a>-用 Vue 编写的小型实用程序，用于检查给定的密码是否已针对“我已被拥有” API 泄漏。</li><li><a href="https://github.com/AlekseyPleshkov/vue-form-send">vue-form-send</a>-用于从表单和原始验证发送数据的 Vue.js 指令</li><li><a href="https://github.com/janiskelemen/formvuelar">FormVuelar</a>-考虑服务器端验证的 Vue 表单组件</li><li><a href="https://phphe.github.io/vue-final-validate/">vue-final-validate</a>-根据我的开发经验，Vue 验证解决方案支持嵌套，异步。</li><li><a href="https://github.com/cretueusebiu/vform">vform</a>-一种在 Vue 中处理 Laravel 后端验证的简单方法。</li></ul><h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><ul><li><a href="https://github.com/PxyUp/vue-not-visible">vue-not-visible</a>-Vue 指令，用于从屏幕上小于断点的 dom(如 v-if)元素中删除。</li><li><a href="https://github.com/mya-ake/vue-window-size">vue-window-size</a>-提供反应性窗口大小属性。</li><li><a href="https://github.com/shwilliam/vue-sensitive-text">vue-sensitive-text</a>-↔ 相对于其父节点的宽度缩放其子节点的组件</li></ul><h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><ul><li><a href="https://github.com/theomessin/vue-chat-scroll">vue-chat-scroll</a>-Vue.js 2.0 的自动滚动至底部指令。</li><li><a href="https://github.com/rigor789/vue-scrollTo">vue-scrollto</a>-添加了一个指令，该指令侦听单击事件并滚动到元素。</li><li><a href="https://github.com/Developmint/vue-next-level-scroll">vue-next-level-scroll</a>-一种基于组件且支持 SSR 的方法，可使用现代 Scroll Behavior API 进行平滑滚动</li><li><a href="https://github.com/metawin-m/vue-scroll-sync">vue-scroll-sync</a>-同步容器滚动位置的组件</li><li><a href="https://github.com/phegman/v-scroll-lock">v-scroll-lock</a>-用于正文滚动锁定而不中断目标元素滚动的 Vue.js 指令</li><li><a href="https://github.com/mercs600/vue2-perfect-scrollbar">vue2-perfect-scrollbar</a>-PerfectScrollbar 简约包装器</li><li><a href="https://github.com/KevinHoughton/vue-scroll-to">vue-scroll-to</a>-添加了一个指令，该指令侦听单击事件并滚动到元素。</li><li><a href="https://github.com/guillaumebriday/vue-scroll-progressbar">vue-scroll-progressbar</a>-可自定义的组件，用于指示进度条中滚动的相对位置。</li><li><a href="https://github.com/caiofsouza/vue-backtotop">vue-backtotop</a>-Vue.js 的 Back-to-top 组件，单击该组件可将页面滚动到顶部。</li><li><a href="https://github.com/luiguild/v-bar">VBar</a>-适用于 Vue.js 2x 的虚拟响应式跨浏览器滚动条组件。</li><li><a href="http://serafin.io/vuebar/">Vuebar</a>-使用本地滚动行为的自定义滚动条的 Vue 2 指令。轻巧，高性能，可定制且无依赖性。</li><li><a href="https://github.com/ozangulle/vue-detached-scrollbar">vue-detached-scrollbar</a>-一个简单的滚动条，可以从正在滚动的容器中分离出来。</li><li><a href="https://github.com/YvesCoding/vuescroll">vuescroll</a>-基于 Vue.js 的滚动插件，用于统一 PC 和移动设备中的滚动。</li><li><a href="https://github.com/hfalucas/vue-simplebar">vue-simplebar</a>-Simplebar 插件的 Vue.js 包装器。</li><li><a href="https://github.com/scaccogatto/smooth-vuebar">smooth-vuebar</a>-平滑滚动条的 Vue 指令包装</li><li><a href="https://github.com/chrishurlburt/vue-scrollview">vue-scrollview</a>-一个组件，该组件利用作用域的插槽来检测 vue 组件何时进入和离开视口。</li><li><a href="https://github.com/eddiemf/vue-scrollactive">vue-scrollactive</a>-根据视口中的当前部分在菜单项中添加一个活动类，单击菜单项时也会滚动到该部分。</li><li><a href="https://github.com/heavyy/vue-intersect">vue-intersect</a>-一个 Vue 组件，用于向 Vue 组件或 HTML 元素添加交集观察者。</li><li><a href="https://github.com/AlexandreBonaventure/vue-scrollmonitor">vue-scrollmonitor</a>-一个 Vue 插件，可在支持多种浏览器的情况下观看视口内部元素的可见性状态(使用提供&#x2F;注入，因此兼容 <a href="mailto:vue@2.2">vue@2.2</a> 。X)</li><li><a href="https://github.com/xiaoluoboding/vue-stroll">vue-stroll</a>-适用于 Vue.js 2.x 的超棒 CSS3 列表滚动效果组件。</li><li><a href="https://github.com/nash403/navscroll-js">navscroll-js</a>-在滚动时突出显示菜单项，并且在单击菜单项时也会滚动到某个部分。用作 vue 组件，vue 指令或与 vanilla js 一起使用。</li><li><a href="https://github.com/Desdesdesgo/vue-scrollwatch">vue-scrollwatch</a>-一个轻便的插件，可检测滚动事件，在元素进入视口时自定义回调，将’scrollTo’api 暴露给特定元素。使用 vue 指令。</li><li><a href="https://github.com/vtimofeev/vue-check-view">vue-check-view</a>-一个检查元素是否在视口中的插件。快速，小型，无依赖性，实时演示。</li><li><a href="https://github.com/JALBAA/vue-stickto">vue-stickto</a>-支持多个 DOM 节点的 vue 指令会自动粘贴到顶部</li><li><a href="https://github.com/ibufu/vue2-scrollspy">vue2-scrollspy</a>-一个 scrollspy 插件和动画滚动到。</li><li><a href="https://github.com/jeneser/vue-scroll-behavior">vue-scroll-behavior</a>-自定义路线导航中的滚动行为。特别是哈希模式。</li><li><a href="https://github.com/voxtobox/vue-scroll-stop">vue-scroll-stop</a>-到达边缘时停止传播滚动。</li><li><a href="https://github.com/chenxuan0000/vue-seamless-scroll">vue-seamless-scroll</a>-Vue.js 的简单无缝 滚动。</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><a href="https://github.com/vuejs/vue-router">vue-router</a>-Vue.js 的官方路由器。</li><li><a href="https://github.com/ElderJames/vue-router-storage">vue-router-storage</a>-Vue.js 2 和 vue-router 2 的路由器存储和解决方案</li><li><a href="https://github.com/edgarnadal/vue-tidyroutes">vue-tidyroutes</a>-分散的 vue-router 路由定义</li><li><a href="https://github.com/raniesantos/vue-routisan">vue-routisan</a>-基于 Laravel 路由系统的 Vue 路由器的优雅路由定义</li><li><a href="https://github.com/raniesantos/vue-error-page">vue-error-page</a>-提供路由器视图的包装器，使您可以显示错误页面而不更改 URL</li><li><a href="https://github.com/40818419/vue-router-sitemap">vue-router-sitemap</a>-通过 vue-router 配置生成 sitemap.xml</li><li><a href="https://github.com/f/vue-smart-route">vue-smart-route</a>-智能路由指令，可使用 Vue.js 制作具有智能外观的应用程序。</li><li><a href="https://github.com/ccqgithub/vue-router-lite">vue-router-lite</a>-Vue.js 2 的基于组件的声明性路由器。</li></ul><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul><li><a href="https://github.com/hilongjw/vue-lazyload">vue-lazyload</a>-一个 Vue.js 插件，用于将图像或组件延迟加载到应用程序中。</li><li><a href="https://github.com/darrynten/vue-lazy-background-images">vue-lazy-background-images</a>-延迟加载 Vue 2 的背景图像。</li><li><a href="https://github.com/MatteoGabriele/vue-progressive-image">vue-progressive-image</a>-Vue 渐进式图像加载插件。</li><li><a href="https://github.com/lsycxyj/vue-l-lazyload">vue-l-lazyload</a>-Vue.js v2.x +的 lazyload 插件。</li><li><a href="https://github.com/JALBAA/vue-lazyload-img">vue-lazyload-img</a>-专门针对移动浏览器进行了优化。支持 V2 和 v1。</li><li><a href="https://github.com/yyh1102/vue-lazyload-images">vue-lazy-images</a>-Vue 2.x 的 lazyload 图像插件。</li><li><a href="https://github.com/nkoehring/v-lazy-img">v-lazy-img</a>-Tiny(&lt;0.6kb)指令，用于 Vue 2 的渐进式图像加载。</li><li><a href="https://github.com/matheusgrieger/vue-clazy-load">vue-clazy-load</a>-使用 IntersecionObserver for Vue 2 的轻量级可转换图像延迟加载组件。</li><li><a href="https://github.com/thangman22/vue-lazy-this">vue-lazy-this</a>-使用 Intersection Observer API 的延迟加载组件。</li><li><a href="https://github.com/dwqs/v2-lazy-list/">v2-lazy-list</a>-一个基于 Vue 2.x 的简单的延迟加载列表组件</li><li><a href="https://github.com/ooade/pimg">pimg</a>-一个用于延迟加载图像的简单渐进图像组件。</li><li><a href="https://github.com/mazipan/vue-tiny-lazyload-img">vue-tiny-lazyload-img</a>-用于延迟加载图像的小尺寸 Vue.js v.2 +指令</li><li><a href="https://github.com/3vilArthas/vue-lazy-youtube-video">vue-lazy-youtube-video</a>-一个用于延迟加载 YouTube 视频的简单 Vue.js 组件。</li><li><a href="https://github.com/Kazap/lazyload-vue">lazyload-vue</a>-适用于 vanilla-lazyload 的 Vue 插件。</li></ul><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ul><li><a href="https://github.com/TahaSh/vue-paginate">vue-paginate</a>-一个简单的 vue.js 插件，可对数据进行分页。</li><li><a href="https://github.com/matfish2/vue-pagination-2">vue-pagination-2</a>-Vue.js 2 分页组件。</li><li><a href="https://github.com/sant123/vuejs-uib-pagination">vuejs-uib-pagination</a>-适用于 Vue.js 的最佳，完整的分页插件。受角引导分页启发。</li><li><a href="https://github.com/lokyoung/vuejs-paginate">vuejs-paginate</a>-用于创建分页的 Vue.js(v2.x +)组件。</li><li><a href="https://github.com/brunoseco/vue-pagination-bootstrap">vue-pagination-bootstrap</a>-一个 Vue.js(1.x＆2.x)服务器端分页组件，带有基于 Bootstrap 的模板</li><li><a href="https://github.com/vinayakkulkarni/laravel-vue-semantic-ui-pagination">laravel-vue-semantic-ui-pagination</a>-与 Laravel 和 Semantic-UI 一起使用的 Vue.js 2.x 分页。</li><li><a href="https://github.com/alziqziq/vue-paginate-al">vue-paginate-al</a>-Vue 分页并返回您的数据。</li><li><a href="https://github.com/coderdiaz/vue-tiny-pagination">vue-tiny-pagination</a>-用于创建微小分页的 Vue 组件。</li><li><a href="https://github.com/gilbitron/laravel-vue-pagination">laravel-vue-pagination</a>-适用于 Laravel 分页器的 Vue.js 分页组件，可与 Bootstrap 一起使用。</li><li><a href="https://github.com/Botre/vue-lpage">vue-lpage</a>-低级 Vue 分页组件。</li><li><a href="https://github.com/TerryZ/v-page">v 页</a>-一个简单的分页栏，包括基于 Vue2.x 的长度菜单，i18n 支持。</li><li><a href="https://github.com/grinmax/vue-smart-pagination">vue-smart-pagination</a>-具有许多不错设置的任何数据的智能分页。</li><li><a href="https://github.com/sbaidon/vue-paginatron">vue-paginatron</a>-分页组件使用范围插槽道具构建，具有最大的灵活性。</li><li><a href="https://github.com/arnedesmedt/vue-ads-pagination">vue-ads-pagination</a>-使用 css 框架[tailwindcss](<a href="https://tailwindcss.com/docs/what">https://tailwindcss.com/docs/what</a> -is-tailwind &#x2F;)</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li><a href="https://github.com/asika32764/vue2-animate">vue2-animate</a>-Animate.css 的 Vue.js 2.0 端口。与 Vue 的内置转换一起使用。</li><li><a href="https://github.com/radical-dreamers/animated-vue">animated-vue</a>-一个 Vue.js 2.x 插件，可轻松使用 Animate.css 动画作为过渡。就像&#96;&#96;一样简单！</li><li><a href="https://github.com/chenqingspring/vue-lottie">vue-lottie</a>-一个 Vue.js 2.x 插件，用于基于 bodymovin 渲染特效动画</li><li><a href="https://github.com/jaweii/vueg">Vueg</a>-使 vue-router 具有过渡效果&#x2F;为 webApp 提供转场特效的开源 Vue 插件</li><li><a href="https://jofftiquez.github.io/v-animate-css/">v-animate-css</a>-最容易实现 Animate.css 的 Vue 2 指令</li><li><a href="https://github.com/lukechinworth/vue-mixin-tween">vue-mixin-tween</a>-Mixin 工厂，它将补间值添加到动画的组件上下文中</li><li><a href="https://github.com/JefferyHus/v-odometer">v-odometer</a>-轻松平滑地转换数字。使用此库可为您的应用程序提供平滑的动画，仅适用于数字。</li><li><a href="https://github.com/cristijora/vue2-transitions">vue2-transitions</a>✨ 可重复使用的 Vue 2 过渡组件</li><li><a href="https://github.com/mattrothenberg/vue-overdrive">vue-overdrive</a>Vue 应用程序的超级简单的魔术移动过渡 🎩</li><li><a href="https://github.com/Leocardoso94/animated-number-vue">animated-number-vue</a>超级简单的数字动画方法。</li><li><a href="https://github.com/Orlandster1998/vue-typed-js">vue-typed-js</a>集成了 Typed.js，可轻松创建打字动画。</li><li><a href="https://github.com/inamori/vue-parent-change-transition">vue-parent-change-transition</a>启用子组件在更改父组件时进行动画处理。</li><li><a href="https://github.com/guanzo/vue-smooth-reflow">vue-smooth-reflow</a>响应数据变化而转换元素重排。</li><li><a href="https://github.com/SeregPie/VueTween">VueTween</a>允许组件补间其属性。</li><li><a href="https://github.com/danieldiekmeier/vue-slide-up-down">vue-slide-up-down</a>就像 jQuery 的<code>slideUp</code> &#x2F;<code>slideDown</code>一样，但是对于 Vue！</li><li><a href="https://github.com/BenAHammond/vue-anime">vue-animejs</a>Vue 的简单<code>anime.js</code>指令。</li><li><a href="https://github.com/zulko/eagle.js/">Eagle.js</a>Eagle.js 是 Vue.js 的基于 Web 的幻灯片框架。</li><li><a href="https://github.com/Popmotion/popmotion/tree/master/packages/vue-pose">vue-pose</a>Pose for Vue 是一个声明式运动系统，结合了 CSS 过渡的简单性和 CSS 的强大功能和灵活性 JavaScript。</li><li><a href="https://github.com/k-okina/vue-slide-up-down-component">vue-slide-up-down-component</a>这是一个简单的界面，但是实现了非常灵活而强大的幻灯片动画 Vue！</li><li><a href="https://github.com/pearofducks/femtoTween">femtoTween</a>具有一流 Vue 支持的简约(零深度，小于 1k)补间库</li><li><a href="https://github.com/deivthings/vue-sequential-entrance">vue-sequential-entrance</a>插件，用于创建带有页面元素列表的优雅的连续动画入口。零努力。简单轻巧</li><li><a href="https://github.com/mike-prince/vue-animate-scroll">vue-animate-scroll</a>一种超级轻量级 的方法，可在元素滚动到视图中时向其添加 CSS 动画。</li><li><a href="https://github.com/kai-oswald/vue-svg-transition">vue-svg-transition</a>创建 2 状态，SVG 驱动的过渡</li><li><a href="https://github.com/Orlandster/vue-page-transition">vue-page-transition</a>Vue.js 的简单路由&#x2F;页面转换</li></ul><h2 id="元标记"><a href="#元标记" class="headerlink" title="元标记"></a>元标记</h2><ul><li><a href="https://github.com/ktquez/vue-head">vue-head</a>-管理 head 标签的元信息，一种简单的方法。</li><li><a href="https://github.com/declandewet/vue-meta">vue-meta</a>-在 Vue 2.0 组件中管理页面元信息。支持 SSR +流媒体。</li><li><a href="https://github.com/troxler/vue-headful">vue-headful</a>-从视图中设置文档&#96;&#96;和 meta 标签。</li><li><a href="https://github.com/VeryWow/vue-simple-headful">vue-simple-headful</a>-使用 vue.js 轻松设置元标记-具有 TypeScript 支持的更简单的<code>vue-headful</code>替代方法。</li></ul><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul><li><a href="https://github.com/calebroseland/vue-dom-portal">vue-dom-portal</a>-Vue.js 组件中 DOM 元素的转义口。</li><li><a href="https://linusborg.github.io/portal-vue">portal-vue</a>-一个 Vue 插件，用于在 DOM 中的任何位置渲染组件的模板(在 virtualDOM 级别上有效，不会在 DOM 中移动节点)</li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li><a href="https://github.com/freearhey/vue2-filters">vue2-filters</a>-适用于 Vue 2. *的标准过滤器 Vue 1. *的集合。</li><li><a href="https://github.com/jofftiquez/vue-morphling">vue-morphling</a>-Vue 2 的标准和自定义过滤器的集合。</li><li><a href="https://github.com/mazipan/vue-currency-filter">vue-currency-filter</a>-轻巧且可自定义的 Vue 2 货币过滤器。</li><li><a href="https://github.com/Trekels/vue-trans">vue-trans</a>-一个简单的过滤器，提供了与 Symfony trans 相似的翻译方式。</li><li><a href="https://github.com/mazipan/vue-string-filter">vue-string-filter</a>-轻量级 Vue 2 字符串处理过滤器。</li><li><a href="https://github.com/ERPedersen/vue-units">vue-units</a>-在 Vue 2 中使用的方便的单位转换过滤器的集合。</li><li><a href="https://github.com/lloydjatkinson/vue-numeral-filter">vue-numeral-filter</a>-过滤器的集合，允许在组件的模板部分内联使用 Numeral.js。</li><li><a href="https://github.com/eduardnikolenko/vue-filter-date-format">vue-filter-date-format</a>-Vue 2 的简单日期时间过滤器。</li><li><a href="https://github.com/eduardnikolenko/vue-filter-pluralize">vue-filter-pluralize</a>-Vue 2 的简单复数过滤器。</li><li><a href="https://github.com/eduardnikolenko/vue-filter-date-parse">vue-filter-date-parse</a>-Vue 2 的简单解析日期时间过滤器。</li></ul><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ul><li><a href="https://github.com/MMF-FE/vue-svgicon">vue-svgicon</a>-创建 svg 图标组件的工具。(版本 2.x)。</li><li><a href="https://github.com/LucasLeandro1204/vue-content-loading">vue-content-loading</a>-Vue 组件可轻松构建(或使用预设)Facebook 之类的 SVG 加载卡。</li><li><a href="https://github.com/DrSensor/vue-annotator">vue-annotator</a>-使用任何 SVG 元素(“ rect”，“ polygon”以及其他更多元素，即使包装了 HTML 元素如“ canvas”，也可以为页面添加注释)在<code>foreignObject</code>中)</li><li><a href="https://github.com/thierrymichel/vue-svg-sprite">vue-svg-sprite</a>-简单使用 SVG sprite(vue 2.x)的指令。</li><li><a href="https://github.com/biigpongsatorn/vue-svg-filler">vue-svg-filler</a>-用于自定义 svg 文件 🖍(vue 2.x)的 Vue 组件。</li></ul><h2 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/staskjs/vue-resource-progressbar-interceptor">vue-resource-progressbar-interceptor</a>-将进度条与所有请求联系在一起的拦截器，很明显，正在加载某些东西。</li><li><a href="https://github.com/David-Desmaisons/Vue.ImagesLoaded">vue-images-loaded</a>-Vue.js 2.0 指令可检测图像加载。</li><li><a href="https://github.com/javisperez/vue-visible">vue-visible</a>-VueJS(2.x)的 v-visible 指令，类似于 v-show 但具有可见性。</li><li><a href="https://github.com/FranckFreiburger/vue-resize-sensor">vue-resize-sensor</a>-用于检测容器大小的组件(基于事件)</li><li><a href="https://github.com/ndelvalle/v-blur">v-blur</a>-Vue 指令动态模糊元素</li><li><a href="https://github.com/mokkabonna/vue-async-methods">vue-async-methods</a>-用于基于承诺的方法的帮助程序实用程序</li><li><a href="https://github.com/braceslab/vue-openseadragon">vue-openseadragon</a>-适用于 Vue.js 的 OpenSeaDragon 组件(缩放和平移)</li><li><a href="https://github.com/samturrell/vue-match-heights">vue-match-heights</a>-指令将元素的高度设置为相同。</li><li><a href="https://github.com/FL3NKEY/vue-conditional-attrs">vue-conditional-attrs</a>-用于条件渲染属性和指令的 Vue.js 组件</li><li><a href="https://github.com/arthurvasconcelos/vue-cbsc">vue-cbsc</a>-一个 Vue.js 2.x 组件，用于以编程方式混合，着色和转换颜色。</li><li><a href="https://github.com/twcapps/vue-spatialnavigation">vue-spatialnavigation</a>-用于空间导航(键盘导航)的 Vue 指令(Vue.js 2.x)</li><li><a href="https://github.com/FL3NKEY/vue-lifecycle">vue-lifecycle</a>-Vue.js 生命周期指令。</li><li><a href="https://github.com/3vilArthas/v-aspect-ratio">vue-aspect-ratio</a>-vue 的长宽比指令。</li><li><a href="https://github.com/kooljay82/vue-m-camera">@ kooljay82 &#x2F; vue-m-camera</a>-为避免自动更改通过用户设备的相机拍摄的照片方向。</li></ul><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><ul><li><a href="https://github.com/hujiulong/vue-3d-model">vue-3d-model</a>-Vue 组件中的 3D 模型查看器。</li><li><a href="https://github.com/ChiChou/vue-pano">vue-pano</a>-Vue 组件中的全景查看器。</li><li><a href="https://github.com/fritx/vue-threejs">vue-threejs</a>-Three.js 的 Vue 绑定。</li><li><a href="https://github.com/vue-gl/vue-gl">VueGL</a>-Vue.js 组件通过 three.js 反应性地渲染 3D 图形</li><li><a href="https://github.com/imudin/vue-vr">vue-vr</a>-使用 Vue 构建 VR 应用程序的框架</li><li><a href="https://github.com/AlbanCrepel/vue-displacement-slideshow">vue-displacement-slideshow</a>-一个 Vue.js 组件，可简化 Webgl 图像位移转换。</li></ul><h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><ul><li><a href="https://github.com/mirari/vue-fullscreen">vue-fullscreen</a>-用于全屏的简单 Vue 组件。</li></ul><h2 id="页面可见性"><a href="#页面可见性" class="headerlink" title="页面可见性"></a>页面可见性</h2><ul><li><a href="https://github.com/stefanodotit/vue-page-visibility-awesome">vue-page-visibility-awesome</a>-易于配置的页面可见性 api 的 Vue 2.x 组件。</li><li><a href="https://github.com/vv13/vue-authplugin">vue-authplugin</a>-美观的 auth 控制插件，支持指令和原型方法。</li></ul><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><ul><li><a href="https://mycure-inc.github.io/vue-html-to-paper/">vue-html-to-paper</a>-Vue mixin 用于将 html 元素打印到纸张上。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端组件汇总&quot;&gt;&lt;a href=&quot;#前端组件汇总&quot; class=&quot;headerlink&quot; title=&quot;前端组件汇总&quot;&gt;&lt;/a&gt;前端组件汇总&lt;/h1&gt;&lt;h2 id=&quot;菜单&quot;&gt;&lt;a href=&quot;#菜单&quot; class=&quot;headerlink&quot; title=&quot;菜单&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-调参总结</title>
    <link href="http://ai.mak.cn/2024/04/14/ai/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B0%83%E5%8F%82%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2024/04/14/ai/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B0%83%E5%8F%82%E6%80%BB%E7%BB%93/</id>
    <published>2024-04-13T16:00:00.000Z</published>
    <updated>2024-12-17T09:20:18.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习-调参总结"><a href="#机器学习-调参总结" class="headerlink" title="机器学习-调参总结"></a>机器学习-调参总结</h1><p><code>超参数调优</code>是机器学习例程中的基本步骤之一。该方法也称为<code>超参数优化</code>，需要搜索超参数的最佳配置以实现最佳性能。</p><p>机器学习算法需要用户定义的输入来实现准确性和通用性之间的平衡。这个过程称为超参数调整。有多种工具和方法可用于调整超参数。</p><blockquote><p>原文出处：<a href="https://analyticsindiamag.com/top-8-approaches-for-tuning-hyperparameters-of-machine-learning-models/">https://analyticsindiamag.com/top-8-approaches-for-tuning-hyperparameters-of-machine-learning-models/</a></p></blockquote><p>本文整理了一份用于调整机器学习模型超参数的前八种方法的列表。</p><h2 id="1-贝叶斯优化"><a href="#1-贝叶斯优化" class="headerlink" title="1 贝叶斯优化"></a>1 贝叶斯优化</h2><p>贝叶斯优化已成为机器学习算法超参数调整的有效工具，更具体地说，适用于深度神经网络等复杂模型。</p><p>它提供了一个有效的框架来优化昂贵的黑盒功能，而无需知道它的形式。它已应用于多个领域，包括学习最优机器人力学、序列实验设计和合成基因设计。</p><h2 id="2-遗传算法"><a href="#2-遗传算法" class="headerlink" title="2 遗传算法"></a>2 遗传算法</h2><p>遗传算法 (EA) 是一种优化算法，它通过根据称为算子的某些规则修改一组候选解决方案（种群）来工作。</p><p>EA 的主要优势之一是它们的通用性：这意味着 EA 可以在广泛的条件下使用，因为它们简单且独立于潜在问题。在超参数调整问题中，遗传算法已被证明比基于精度&#x2F;速度的网格搜索技术表现更好。</p><h2 id="3-基于梯度的优化"><a href="#3-基于梯度的优化" class="headerlink" title="3 基于梯度的优化"></a>3 基于梯度的优化</h2><p>基于梯度的优化是一种优化多个超参数的方法，基于机器学习模型选择标准相对于超参数的梯度计算。</p><p>当满足训练标准的一些可微性和连续性条件时，可以应用这种超参数调整方法。</p><h2 id="4-网格搜索"><a href="#4-网格搜索" class="headerlink" title="4 网格搜索"></a>4 网格搜索</h2><p>网格搜索是超参数调优的基本方法。它对用户指定的超参数集执行详尽的搜索。这种方法是最直接的导致最准确的预测。</p><p>使用这种调优方法，用户可以找到最佳组合。网格搜索适用于几个超参数，但是搜索空间有限。</p><h2 id="5-Keras-Tuner"><a href="#5-Keras-Tuner" class="headerlink" title="5 Keras Tuner"></a>5 Keras Tuner</h2><p>Keras Tuner是一个库，允许用户为机器学习或深度学习模型找到最佳超参数。</p><p>该库有助于查找内核大小、优化学习率和不同的超参数。Keras Tuner可用于为各种深度学习模型获取最佳参数，以实现最高精度。</p><h2 id="6-基于种群的优化"><a href="#6-基于种群的优化" class="headerlink" title="6 基于种群的优化"></a>6 基于种群的优化</h2><p>基于种群的方法本质上是一系列基于随机搜索（如遗传算法）的方法。</p><p>最广泛使用的基于种群的方法之一是 DeepMind 提出的基于种群的训练（PBT）。PBT在两个方面，是一种独特的方法：</p><ul><li>它允许在训练期间使用自适应超参数</li><li>它结合了并行搜索和顺序优化</li></ul><h2 id="7-ParamILS"><a href="#7-ParamILS" class="headerlink" title="7 ParamILS"></a>7 ParamILS</h2><p>ParamILS（参数配置空间中的迭代局部搜索）是一种用于自动算法配置的通用随机局部搜索方法。ParamILS 是一种自动算法配置方法，有助于开发高性能算法及其应用程序。</p><p>ParamILS 使用默认和随机设置进行初始化，并采用迭代第一改进作为辅助本地搜索过程。它还使用固定数量的随机移动来进行扰动，并且总是接受更好或同样好的参数配置，但会随机重新初始化搜索。</p><h2 id="8-随机搜索"><a href="#8-随机搜索" class="headerlink" title="8 随机搜索"></a>8 随机搜索</h2><p>随机搜索可以说是对网格搜索的基本改进。该方法是指对可能参数值的某些分布的超参数进行随机搜索。</p><p>搜索过程继续进行，直到达到所需的精度。随机搜索类似于网格搜索，但已证明比后者创建更好的结果。</p><p>该方法通常被用作 HPO 的基线来衡量新设计算法的效率。尽管随机搜索比网格搜索更有效，但它仍然是一种计算密集型方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习-调参总结&quot;&gt;&lt;a href=&quot;#机器学习-调参总结&quot; class=&quot;headerlink&quot; title=&quot;机器学习-调参总结&quot;&gt;&lt;/a&gt;机器学习-调参总结&lt;/h1&gt;&lt;p&gt;&lt;code&gt;超参数调优&lt;/code&gt;是机器学习例程中的基本步骤之一。该方法也称为&lt;c</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装多个JDK版本</title>
    <link href="http://ai.mak.cn/2024/04/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Mac%20%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85JDK%E5%A4%9A%E7%89%88%E6%9C%AC/"/>
    <id>http://ai.mak.cn/2024/04/10/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Mac%20%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85JDK%E5%A4%9A%E7%89%88%E6%9C%AC/</id>
    <published>2024-04-09T16:00:00.000Z</published>
    <updated>2024-04-10T06:21:03.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前很多java应用使用到了jdk8，jdk11，jdk17等不同的版本，Mac上需要安装多个版本，并方便切换</p></blockquote><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>官方网站：<a href="https://www.oracle.com/cn/java/technologies/downloads/#jdk17-mac">Java Downloads</a> | Oracle</p><p>根据mac芯片是intel还是apple进行不同版本下载：</p><ul><li>ARM64 DMG Installer 苹果M，芯片</li><li>x64 DMG Installer Intel 芯片</li></ul><h3 id="查看安装目录"><a href="#查看安装目录" class="headerlink" title="查看安装目录"></a>查看安装目录</h3><p>安装pkg文件后，打开终端窗口，查看我们安装的 JDK 版本</p><ul><li><p>访问 JDK 安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /Library/Java/JavaVirtualMachines</span><br></pre></td></tr></table></figure></li><li><p>查看安装的 JDK 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure></li></ul><p>可以看到安装了两个版本 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -lrt</span><br><span class="line">drwxr-xr-x  3 root  wheel  96  8 22  2017 jdk1.8.0_144.jdk</span><br><span class="line">drwxr-xr-x  3 root  wheel  96  4 10 10:25 jdk-17.jdk</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>3.1 打开环境变量文件</p><ul><li><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure></li><li><p>打开环境变量配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi/subl等 .bash_profile</span><br></pre></td></tr></table></figure><p>3.2 配置 JDK 多版本环境变量</p></li><li><p>复制如下内容粘贴到.bash_profile中，</p></li><li><p>因为我是安装了三个，所以配置了三个版本</p></li><li><p>自己是安装了几个版本就配置几个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)</span><br><span class="line">export JAVA_11_HOME=$(/usr/libexec/java_home -v11)</span><br><span class="line">export JAVA_17_HOME=$(/usr/libexec/java_home -v17)</span><br><span class="line"></span><br><span class="line">alias java8=&#x27;export JAVA_HOME=$JAVA_8_HOME&#x27;</span><br><span class="line">alias java11=&#x27;export JAVA_HOME=$JAVA_11_HOME&#x27;</span><br><span class="line">alias java17=&#x27;export JAVA_HOME=$JAVA_17_HOME&#x27;</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=$JAVA_11_HOME</span><br></pre></td></tr></table></figure></li><li><p>保存</p></li><li><p>3.3 检查环境变量</p></li><li><p>配置文件立即生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>查看 JAVA_HOME 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure></li><li><p>查看 JDK 版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>JDK 版本切换<br>我们定义了个别名：java8，和java17，其中默认配置为 jdk11。</li></ol><p>相互切换，在终端中输入命令即可，如下</p><ul><li><p>切换到JDK8：<br>java8 </p></li><li><p>查看 JDK 版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>切换到JDK11：<br>java11</p></li></ul><h1 id="查看-JDK-版本信息"><a href="#查看-JDK-版本信息" class="headerlink" title="查看 JDK 版本信息"></a>查看 JDK 版本信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><ul><li>切换到JDK17：<br>java17</li></ul><h1 id="查看-JDK-版本信息-1"><a href="#查看-JDK-版本信息-1" class="headerlink" title="查看 JDK 版本信息"></a>查看 JDK 版本信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/Zhaoruifeng158/article/details/135832564">https://blog.csdn.net/Zhaoruifeng158/article/details/135832564</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目前很多java应用使用到了jdk8，jdk11，jdk17等不同的版本，Mac上需要安装多个版本，并方便切换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;下载JDK&quot;&gt;&lt;a href=&quot;#下载JDK&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>基于神经网络的网络流量预测</title>
    <link href="http://ai.mak.cn/2024/03/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%9F%BA%E4%BA%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/"/>
    <id>http://ai.mak.cn/2024/03/26/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%9F%BA%E4%BA%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/</id>
    <published>2024-03-25T16:00:00.000Z</published>
    <updated>2024-03-29T07:32:30.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><p>随着互联网的不断发展，网络流量预测已经成为一项重要的技术，用于优化网络资源分配、提高网络性能和可靠性。传统的流量预测方法主要基于统计学和机器学习，但这些方法在处理复杂网络流量数据时存在一定局限性。深度学习技术在近年来迅速发展，已经成功应用于多个领域，包括图像识别、自然语言处理、语音识别等。因此，研究深度学习在网络流量预测中的应用具有重要意义。</p><p>本文将从以下几个方面进行阐述：</p><ol><li>背景介绍</li><li>核心概念与联系</li><li>核心算法原理和具体操作步骤以及数学模型公式详细讲解</li><li>具体代码实例和详细解释说明</li><li>未来发展趋势与挑战</li><li>附录常见问题与解答</li></ol><h1 id="2-核心概念与联系"><a href="#2-核心概念与联系" class="headerlink" title="2. 核心概念与联系"></a>2. 核心概念与联系</h1><p>网络流量预测是指根据历史网络流量数据，预测未来网络流量的大小和趋势。这项技术在网络规划、运营和管理中具有重要意义，可以帮助网络管理员更有效地分配网络资源、提高网络性能和可靠性。</p><p>深度学习是一种人工智能技术，通过模拟人类大脑的学习和思维过程，使计算机能够从数据中自动学习出模式和规律。深度学习技术在图像识别、自然语言处理、语音识别等领域取得了显著的成功，因此在网络流量预测领域也有广泛的应用前景。</p><h1 id="3-核心算法原理和具体操作步骤以及数学模型公式详细讲解"><a href="#3-核心算法原理和具体操作步骤以及数学模型公式详细讲解" class="headerlink" title="3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解"></a>3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解</h1><p>深度学习在网络流量预测中主要应用于以下几种算法：</p><ol><li>卷积神经网络（CNN）</li><li>循环神经网络（RNN）</li><li>长短期记忆网络（LSTM）</li><li>自编码器（Autoencoder）</li><li>卷积递归神经网络（CRNN）</li></ol><p>下面我们将逐一详细介绍这些算法的原理、步骤和数学模型。</p><h2 id="1-卷积神经网络（CNN）"><a href="#1-卷积神经网络（CNN）" class="headerlink" title="1. 卷积神经网络（CNN）"></a>1. 卷积神经网络（CNN）</h2><p>卷积神经网络（Convolutional Neural Networks，CNN）是一种深度学习算法，主要应用于图像和音频等二维和一维数据的处理。在网络流量预测中，CNN可以用于处理时间序列数据，以捕捉流量数据中的时间特征。</p><p>CNN的主要组件包括卷积层、池化层和全连接层。卷积层用于对输入数据进行卷积操作，以提取特征；池化层用于对卷积层的输出进行下采样，以减少参数数量和计算复杂度；全连接层用于对池化层的输出进行分类。</p><p>在网络流量预测中，CNN的具体操作步骤如下：</p><ol><li>数据预处理：将原始流量数据进行归一化处理，以减少计算复杂度和提高模型性能。</li><li>构建CNN模型：根据问题需求选择合适的CNN结构，包括卷积层、池化层和全连接层的数量和大小。</li><li>训练模型：使用历史流量数据训练CNN模型，以学习出流量特征。</li><li>预测流量：使用训练好的CNN模型对未来流量数据进行预测。</li></ol><h2 id="2-循环神经网络（RNN）"><a href="#2-循环神经网络（RNN）" class="headerlink" title="2. 循环神经网络（RNN）"></a>2. 循环神经网络（RNN）</h2><p>循环神经网络（Recurrent Neural Networks，RNN）是一种能够处理序列数据的深度学习算法。在网络流量预测中，RNN可以用于处理时间序列数据，以捕捉流量数据中的时间特征。</p><p>RNN的主要组件包括隐藏层和输出层。隐藏层用于存储和更新序列数据，输出层用于输出预测结果。RNN的主要优势在于可以捕捉序列数据中的长距离依赖关系，但其主要缺点是难以处理长序列数据，容易出现梯度消失问题。</p><p>在网络流量预测中，RNN的具体操作步骤如下：</p><ol><li>数据预处理：将原始流量数据进行归一化处理，以减少计算复杂度和提高模型性能。</li><li>构建RNN模型：根据问题需求选择合适的RNN结构，包括隐藏层和输出层的数量和大小。</li><li>训练模型：使用历史流量数据训练RNN模型，以学习出流量特征。</li><li>预测流量：使用训练好的RNN模型对未来流量数据进行预测。</li></ol><h2 id="3-长短期记忆网络（LSTM）"><a href="#3-长短期记忆网络（LSTM）" class="headerlink" title="3. 长短期记忆网络（LSTM）"></a>3. 长短期记忆网络（LSTM）</h2><p>长短期记忆网络（Long Short-Term Memory，LSTM）是一种特殊的RNN，具有内部状态和门机制，可以更好地处理长序列数据。在网络流量预测中，LSTM可以用于处理时间序列数据，以捕捉流量数据中的时间特征。</p><p>LSTM的主要组件包括输入门、遗忘门、输出门和内部状态。这些门机制可以控制信息的进入、保留和输出，从而解决RNN中的梯度消失问题。</p><p>在网络流量预测中，LSTM的具体操作步骤如下：</p><ol><li>数据预处理：将原始流量数据进行归一化处理，以减少计算复杂度和提高模型性能。</li><li>构建LSTM模型：根据问题需求选择合适的LSTM结构，包括隐藏层和输出层的数量和大小。</li><li>训练模型：使用历史流量数据训练LSTM模型，以学习出流量特征。</li><li>预测流量：使用训练好的LSTM模型对未来流量数据进行预测。</li></ol><h2 id="4-自编码器（Autoencoder）"><a href="#4-自编码器（Autoencoder）" class="headerlink" title="4. 自编码器（Autoencoder）"></a>4. 自编码器（Autoencoder）</h2><p>自编码器（Autoencoder）是一种深度学习算法，主要应用于降维和生成任务。在网络流量预测中，自编码器可以用于处理时间序列数据，以捕捉流量数据中的时间特征。</p><p>自编码器的主要组件包括编码层和解码层。编码层用于对输入数据进行编码，以提取特征；解码层用于对编码后的数据进行解码，以重构原始数据。自编码器的目标是使解码后的数据与原始数据最小化差异。</p><p>在网络流量预测中，自编码器的具体操作步骤如下：</p><ol><li>数据预处理：将原始流量数据进行归一化处理，以减少计算复杂度和提高模型性能。</li><li>构建自编码器模型：根据问题需求选择合适的自编码器结构，包括编码层和解码层的数量和大小。</li><li>训练模型：使用历史流量数据训练自编码器模型，以学习出流量特征。</li><li>预测流量：使用训练好的自编码器模型对未来流量数据进行预测。</li></ol><h2 id="5-卷积递归神经网络（CRNN）"><a href="#5-卷积递归神经网络（CRNN）" class="headerlink" title="5. 卷积递归神经网络（CRNN）"></a>5. 卷积递归神经网络（CRNN）</h2><p>卷积递归神经网络（Convolutional Recurrent Neural Networks，CRNN）是一种结合卷积神经网络和循环神经网络的深度学习算法。在网络流量预测中，CRNN可以用于处理时间序列数据，以捕捉流量数据中的时间特征。</p><p>CRNN的主要组件包括卷积层、池化层、隐藏层和输出层。卷积层用于对输入数据进行卷积操作，以提取特征；池化层用于对卷积层的输出进行下采样，以减少参数数量和计算复杂度；隐藏层用于存储和更新序列数据；输出层用于输出预测结果。</p><p>在网络流量预测中，CRNN的具体操作步骤如下：</p><ol><li>数据预处理：将原始流量数据进行归一化处理，以减少计算复杂度和提高模型性能。</li><li>构建CRNN模型：根据问题需求选择合适的CRNN结构，包括卷积层、池化层、隐藏层和输出层的数量和大小。</li><li>训练模型：使用历史流量数据训练CRNN模型，以学习出流量特征。</li><li>预测流量：使用训练好的CRNN模型对未来流量数据进行预测。</li></ol><h1 id="4-具体代码实例和详细解释说明"><a href="#4-具体代码实例和详细解释说明" class="headerlink" title="4. 具体代码实例和详细解释说明"></a>4. 具体代码实例和详细解释说明</h1><p>在本节中，我们将通过一个简单的例子来演示如何使用Python和Keras库实现网络流量预测。</p><p>首先，安装所需的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码pip install numpy pandas keras tensorflow</span><br></pre></td></tr></table></figure><p>然后，准备数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">复制代码<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;flow_data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择时间序列数据</span></span><br><span class="line">time_series = data[<span class="string">&#x27;flow&#x27;</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化数据</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">time_series = scaler.fit_transform(time_series.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据</span></span><br><span class="line">look_back = <span class="number">60</span></span><br><span class="line">X, y = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(look_back, <span class="built_in">len</span>(time_series)):</span><br><span class="line">    X.append(time_series[i-look_back:i, <span class="number">0</span>])</span><br><span class="line">    y.append(time_series[i, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">X, y = np.array(X), np.array(y)</span><br><span class="line">X = np.reshape(X, (X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集和测试集</span></span><br><span class="line">train_size = <span class="built_in">int</span>(<span class="built_in">len</span>(X) * <span class="number">0.8</span>)</span><br><span class="line">X_train, X_test = X[:train_size], X[train_size:]</span><br><span class="line">y_train, y_test = y[:train_size], y[train_size:]</span><br></pre></td></tr></table></figure><p>接下来，构建模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">复制代码<span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, LSTM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建LSTM模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(<span class="number">50</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(X_train.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后，训练模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">复制代码model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>最后，预测流量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">复制代码predicted_flow = model.predict(X_test)</span><br><span class="line">predicted_flow = scaler.inverse_transform(predicted_flow)</span><br></pre></td></tr></table></figure><h1 id="5-未来发展趋势与挑战"><a href="#5-未来发展趋势与挑战" class="headerlink" title="5. 未来发展趋势与挑战"></a>5. 未来发展趋势与挑战</h1><p>随着深度学习技术的不断发展，网络流量预测将会面临以下几个挑战：</p><ol><li>数据不足和质量问题：网络流量数据通常是大量的、高维的、不均匀的，这会增加预测模型的难度。未来，需要开发更高效的数据预处理和增强技术，以提高模型性能。</li><li>模型复杂性和计算成本：深度学习模型通常具有较高的参数数量和计算复杂度，这会增加训练和预测的时间和资源消耗。未来，需要开发更简洁的模型结构和更高效的计算方法，以提高模型性能和可扩展性。</li><li>多源数据集成：网络流量数据通常来自多个不同的源，如路由器、交换机、服务器等。未来，需要开发更智能的数据集成和融合技术，以提高预测准确性。</li><li>实时预测和自适应调整：网络流量是时间序列数据，其特征和模式可能会随着时间的推移发生变化。未来，需要开发更智能的实时预测和自适应调整技术，以提高预测准确性和可靠性。</li></ol><h1 id="6-附录常见问题与解答"><a href="#6-附录常见问题与解答" class="headerlink" title="6. 附录常见问题与解答"></a>6. 附录常见问题与解答</h1><p>Q: 深度学习在网络流量预测中的优势是什么？</p><p>A: 深度学习在网络流量预测中的优势主要体现在以下几个方面：</p><ol><li>能够捕捉时间序列数据中的复杂特征，以提高预测准确性。</li><li>能够自动学习出流量特征，无需人工特征工程。</li><li>能够处理大量、高维的数据，提高模型性能。</li><li>能够实现实时预测和自适应调整，提高预测可靠性。</li></ol><p>Q: 深度学习在网络流量预测中的局限性是什么？</p><p>A: 深度学习在网络流量预测中的局限性主要体现在以下几个方面：</p><ol><li>需要大量的训练数据，可能会导致过拟合和欠拟合问题。</li><li>模型参数数量和计算复杂度较高，可能会导致训练和预测的时间和资源消耗。</li><li>模型解释性较差，可能会导致预测结果的可解释性问题。</li></ol><p>Q: 如何选择合适的深度学习算法？</p><p>A: 选择合适的深度学习算法需要考虑以下几个因素：</p><ol><li>问题类型：根据问题类型选择合适的深度学习算法，如图像识别、自然语言处理、语音识别等。</li><li>数据特征：根据数据特征选择合适的深度学习算法，如时间序列数据、空间数据、文本数据等。</li><li>模型性能：根据模型性能选择合适的深度学习算法，如准确性、召回率、F1分数等。</li><li>计算资源：根据计算资源选择合适的深度学习算法，如GPU、TPU、CPU等。</li></ol><h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h1><p>[1] Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016). Deep Learning. MIT Press.</p><p>[2] Chollet, F. (2017). Deep Learning with Python. Manning Publications Co.</p><p>[3] Zhou, H., &amp; Liu, B. (2018). A Comprehensive Survey on Deep Learning for Traffic Prediction. arXiv preprint arXiv:1809.03160.</p><p>[4] Wang, Y., Zhang, Y., &amp; Zhang, J. (2017). Deep Learning for Network Traffic Prediction. arXiv preprint arXiv:1703.06856.</p><p>[5] LSTM: Long Short-Term Memory. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://keras.io/layers/recurrent/%23lstm">keras.io&#x2F;layers&#x2F;recu…</a></p><p>[6] CRNN: Convolutional Recurrent Neural Networks. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://keras.io/examples/cnn/%23convolutional-recurrent-neural-networks-crnn">keras.io&#x2F;examples&#x2F;cn…</a></p><p>[7] Autoencoder. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://keras.io/examples/generative/autoencoder/">keras.io&#x2F;examples&#x2F;ge…</a></p><p>[8] MinMaxScaler. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html">scikit-learn.org&#x2F;stable&#x2F;modu…</a></p><p>[9] TensorFlow. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://www.tensorflow.org/">www.tensorflow.org/</a></p><p>[10] Keras. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://keras.io/">keras.io&#x2F;</a></p><p>[11] Pandas. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://pandas.pydata.org/pandas-docs/stable/index.html">pandas.pydata.org&#x2F;pandas-docs…</a></p><p>[12] NumPy. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://numpy.org/doc/stable/index.html">numpy.org&#x2F;doc&#x2F;stable&#x2F;…</a></p><p>[13] Scikit-learn. (n.d.). Retrieved from <a href="https://link.juejin.cn/?target=https://scikit-learn.org/stable/index.html">scikit-learn.org&#x2F;stable&#x2F;inde…</a></p><p>[14] TensorFlow: A Scalable Machine Learning Framework for Everyone. (2015). Retrieved from <a href="https://link.juejin.cn/?target=https://www.tensorflow.org/overview">www.tensorflow.org/overview</a></p><p>[15] Chollet, F. (2015). Deep Learning with TensorFlow. O’Reilly Media.</p><p>[16] Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016). Deep Learning. MIT Press.</p><p>[17] LeCun, Y., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[18] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[19] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[20] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[21] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.00315.</p><p>[22] Bengio, Y., Courville, A., &amp; Vincent, P. (2012). Deep Learning. Foundations and Trends® in Machine Learning, 3(1-5), 1-316.</p><p>[23] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[24] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[25] Hinton, G., Srivastava, N., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2012). Deep Learning. Nature, 489(7416), 242-243.</p><p>[26] LeCun, Y., Bottou, L., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[27] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[28] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[29] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[30] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.00315.</p><p>[31] Bengio, Y., Courville, A., &amp; Vincent, P. (2012). Deep Learning. Foundations and Trends® in Machine Learning, 3(1-5), 1-316.</p><p>[32] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[33] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[34] Hinton, G., Srivastava, N., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2012). Deep Learning. Nature, 489(7416), 242-243.</p><p>[35] LeCun, Y., Bottou, L., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[36] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[37] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[38] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[39] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.00315.</p><p>[40] Bengio, Y., Courville, A., &amp; Vincent, P. (2012). Deep Learning. Foundations and Trends® in Machine Learning, 3(1-5), 1-316.</p><p>[41] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[42] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[43] Hinton, G., Srivastava, N., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2012). Deep Learning. Nature, 489(7416), 242-243.</p><p>[44] LeCun, Y., Bottou, L., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[45] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[46] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[47] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[48] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.00315.</p><p>[49] Bengio, Y., Courville, A., &amp; Vincent, P. (2012). Deep Learning. Foundations and Trends® in Machine Learning, 3(1-5), 1-316.</p><p>[50] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[51] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[52] Hinton, G., Srivastava, N., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2012). Deep Learning. Nature, 489(7416), 242-243.</p><p>[53] LeCun, Y., Bottou, L., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[54] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[55] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[56] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[57] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.00315.</p><p>[58] Bengio, Y., Courville, A., &amp; Vincent, P. (2012). Deep Learning. Foundations and Trends® in Machine Learning, 3(1-5), 1-316.</p><p>[59] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[60] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative Adversarial Networks. arXiv preprint arXiv:1406.2661.</p><p>[61] Hinton, G., Srivastava, N., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2012). Deep Learning. Nature, 489(7416), 242-243.</p><p>[62] LeCun, Y., Bottou, L., Bengio, Y., &amp; Hinton, G. (2015). Deep Learning. Nature, 521(7553), 436-444.</p><p>[63] Bengio, Y. (2009). Learning Deep Architectures for AI. Foundations and Trends® in Machine Learning, 2(1-5), 1-142.</p><p>[64] Schmidhuber, J. (2015). Deep Learning in Neural Networks: An Introduction. arXiv preprint arXiv:1505.00091.</p><p>[65] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long Short-Term Memory. Neural Computation, 9(8), 1735-1780.</p><p>[66] Xing, J., Cui, Y., &amp; Tong, H. (2015). Convolutional Recurrent Neural Networks. arXiv preprint arXiv:1503.0031</p><p>作者：OpenChat<br>链接：<a href="https://juejin.cn/post/7325129599447531570">https://juejin.cn/post/7325129599447531570</a><br>来源：稀土掘金</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1.背景介绍&quot;&gt;&lt;/a&gt;1.背景介绍&lt;/h1&gt;&lt;p&gt;随着互联网的不断发展，网络流量预测已经成为一项重要的技术，用于优化网络资源分配、提高网络性能和可靠性。传统的</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 LSTM神经网络模型</title>
    <link href="http://ai.mak.cn/2024/02/27/ai/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20LSTM%20%E7%BD%91%E7%BB%9C/"/>
    <id>http://ai.mak.cn/2024/02/27/ai/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20LSTM%20%E7%BD%91%E7%BB%9C/</id>
    <published>2024-02-26T16:00:00.000Z</published>
    <updated>2024-05-28T07:08:56.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载 <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">https://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p></blockquote><h1 id="如何理解-LSTM神经网络模型"><a href="#如何理解-LSTM神经网络模型" class="headerlink" title="如何理解 LSTM神经网络模型"></a>如何理解 LSTM神经网络模型</h1><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p>人类不会每分每秒都从头开始思考。当你阅读这篇文章时，你会根据对前面单词的理解来理解每个单词。你不会抛弃一切，重新从头开始思考。你的思想具有持久性。</p><p>传统的神经网络无法做到这一点，这似乎是一个重大缺陷。例如，假设你想对电影中每个时刻发生的事件进行分类。目前还不清楚传统的神经网络如何利用其对电影中先前事件的推理来指导后续事件。</p><p>循环神经网络解决了这个问题。它们是具有循环的网络，可使信息持久存在。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-rolled.png" alt="img"></p><p><strong>循环神经网络</strong></p><p>在上图中，神经网络的一个部分，A，查看一些输入<code>X_t</code>，并输出一个值<code>h_t</code>. 循环允许信息从网络的一个步骤传递到下一个步骤。</p><p>这些循环使得循环神经网络看起来有些神秘。但是，如果你再仔细想想，就会发现它们与普通神经网络并没有太大区别。循环神经网络可以看作是同一网络的多个副本，每个副本都会向后继者传递一条消息。考虑一下如果我们展开循环会发生什么：</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="展开的循环神经网络。"></p><p><strong>展开的循环神经网络。</strong></p><p>这种链式特性表明循环神经网络与序列和列表密切相关。它们是用于此类数据的神经网络的自然架构。</p><p>而且它们确实被使用！在过去的几年中，RNN 在各种问题上的应用取得了令人难以置信的成功：语音识别、语言建模、翻译、图像字幕……等等。在 Andrej Karpathy 的优秀博客文章《循环<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">神经网络的不合理有效性》</a>中讨论使用 RNN 可以实现的惊人成就。但它们确实非常了不起。</p><p>这些成功的关键在于使用“LSTM”，这是一种非常特殊的循环神经网络，在许多任务中，它的效果比标准版本好得多。几乎所有基于循环神经网络的令人兴奋的结果都是通过它们实现的。本文将探讨的就是这些 LSTM。</p><h2 id="长期依赖的问题"><a href="#长期依赖的问题" class="headerlink" title="长期依赖的问题"></a>长期依赖的问题</h2><p>RNN 的吸引力之一是它们可能能够将先前的信息与当前任务联系起来，例如使用先前的视频帧可能有助于理解当前帧。如果 RNN 能够做到这一点，它们将非常有用。但它们能做到吗？这取决于情况。</p><p>有时，我们只需要查看最近的信息即可执行当前任务。例如，考虑一个语言模型，它试图根据前面的单词预测下一个单词。如果我们试图预测 <strong>“云在天空中”</strong> 中的最后一个单词，我们不需要任何其他上下文——很明显下一个单词将是天空。在这种情况下，相关信息与需要它的地方之间的差距很小，RNN 可以学习使用过去的信息。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-shorttermdepdencies.png" alt="img"></p><p>但也有需要更多背景信息的情况。考虑尝试预测文本“我在法国长大……我能说一口流利的<em>法语</em>”中的最后一个单词。最近的信息表明下一个单词可能是一种语言的名称，但如果我们想缩小范围，确定是哪种语言，我们需要更早的法国背景信息。相关信息与需要信息点之间的差距完全有可能变得非常大。</p><p>不幸的是，随着差距的扩大，RNN 无法学会连接信息。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-longtermdependencies.png" alt="神经网络难以应对长期依赖关系。"></p><p>理论上，RNN 绝对有能力处理这种“长期依赖关系”。人类可以仔细挑选参数来解决这种形式的小问题。遗憾的是，在实践中，RNN 似乎无法学习它们。Hochreiter [(1991) <a href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf">德语]</a>和<a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf">Bengio 等人 (1994)</a>深入探讨了这个问题，他们发现了一些非常根本的原因，说明这个问题可能很难解决。</p><p>值得庆幸的是，LSTM 没有这个问题！</p><h2 id="LSTM-网络"><a href="#LSTM-网络" class="headerlink" title="LSTM 网络"></a>LSTM 网络</h2><p>长短期记忆网络（通常简称为“LSTM”）是一种特殊的 RNN，能够学习长期依赖关系。它们由<a href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter 和 Schmidhuber（1997 年）</a>提出，并在后续工作中被许多人改进和推广。1<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/#fn1">它们</a>在解决各种问题方面都表现出色，目前已被广泛使用。</p><p>LSTM 的设计明确地避免了长期依赖问题。长时间记忆信息实际上是它们的默认行为，而不是它们需要努力学习的事情！</p><p>所有循环神经网络都具有神经网络重复模块链的形式。在标准 RNN 中，此重复模块将具有非常简单的结构，例如单个 tanh 层。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-SimpleRNN.png" alt="img"></p><p><strong>标准 RNN 中的重复模块包含单层。</strong></p><p>LSTM 也具有这种链式结构，但重复模块的结构不同。它不是只有一个神经网络层，而是有四个，并以非常特殊的方式相互作用。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="LSTM 神经网络。"></p><p><strong>LSTM 中的重复模块包含四个交互层。</strong></p><p>不必担心细节。稍后我们将逐步介绍 LSTM 图。现在，我们先熟悉一下我们将要使用的符号。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM2-notation.png" alt="img"></p><p>在上图中，每条线都承载着一个完整的向量，从一个节点的输出到其他节点的输入。粉色圆圈表示逐点运算，如向量加法，而黄色框表示学习到的神经网络层。线合并表示连接，而线分叉表示其内容被复制，副本被发送到不同的位置。</p><h2 id="LSTM-背后的核心思想"><a href="#LSTM-背后的核心思想" class="headerlink" title="LSTM 背后的核心思想"></a>LSTM 背后的核心思想</h2><p>LSTM 的关键是细胞状态，即贯穿图表顶部的水平线。</p><p>细胞状态有点像传送带。它沿着整个链条笔直运行，只有一些微小的线性相互作用。信息很容易不加改变地沿着它流动。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-C-line.png" alt="img"></p><p>LSTM 确实有能力从细胞状态中删除或添加信息，并由称为门的结构严格调节。</p><p>门是一种选择性地让信息通过的方式。它们由 S 型神经网络层和逐点乘法运算组成。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-gate.png" alt="img"></p><p>S 型层输出介于 0 和 1 之间的数字，描述每个组件应通过的量。值为 0 表示“不让任何组件通过”，而值为 1 表示“让所有组件通过！”</p><p>LSTM 有三个这样的门，用于保护和控制单元状态。</p><h2 id="逐步了解-LSTM"><a href="#逐步了解-LSTM" class="headerlink" title="逐步了解 LSTM"></a>逐步了解 LSTM</h2><p>我们的 LSTM 的第一步是决定要从细胞状态中丢弃哪些信息。这个决定是由一个叫做“遗忘门”的 S 型层做出的。它查看<code>h_&#123;t-1&#125;</code>和<code>x_t</code>，并输出一个介于 0 和 1 对于细胞状态中的每个数字<code>C_&#123;t-1&#125;</code>。 A. 1 代表“完全保留这一点”，而0 代表“彻底摆脱这个。”</p><p>让我们回到语言模型的示例，该模型尝试根据所有先前的单词预测下一个单词。在这样的问题中，单元状态可能包括当前主语的性别，以便可以使用正确的代词。当我们看到一个新主语时，我们希望忘记旧主语的性别。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" alt="img"></p><p>下一步是决定我们要在单元状态中存储哪些新信息。这分为两部分。首先，一个称为“输入门”的 S 型层决定我们要更新哪些值。接下来，一个 tanh 层创建一个新候选值的向量，<code>C̃_t</code>，可以将其添加到状态中。在下一步中，我们将把这两者结合起来，以创建对状态的更新。</p><p>在我们的语言模型示例中，我们希望将新主语的性别添加到单元状态中，以替换我们忘记的旧主语。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png" alt="img"></p><p>现在是时候更新旧的细胞状态了，<code>x_&#123;t-1&#125;</code>，进入新的细胞状态 <code>C_t</code> 前面的步骤已经决定了要做什么，我们只需要实际去做。</p><p>我们将旧状态乘以 <code>f~_t</code>，忘记我们之前决定忘记的事情。然后我们添加 <code>i_t</code>*<code>C̃_t</code>。这是新的候选值，根据我们决定更新每个状态值的程度进行缩放。</p><p>在语言模型的情况下，我们实际上会删除有关旧主题性别的信息并添加新信息，正如我们在前面的步骤中所决定的那样。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png" alt="img"></p><p>最后，我们需要决定要输出什么。此输出将基于我们的细胞状态，但将是一个经过过滤的版本。首先，我们运行一个 S 型层，它决定要输出细胞状态的哪些部分。然后，我们将细胞状态通过双曲函数双曲函数（将值推至− 1 和 1 ）并将其乘以 S 型门的输出，这样我们就只输出我们决定的部分。</p><p>对于语言模型示例，由于它刚刚看到一个主语，因此它可能需要输出与动词相关的信息，以防接下来是动词。例如，它可能会输出主语是单数还是复数，这样我们就知道如果接下来是动词，动词应该变位成什么形式。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png" alt="img"></p><h2 id="长期短期记忆的变体"><a href="#长期短期记忆的变体" class="headerlink" title="长期短期记忆的变体"></a>长期短期记忆的变体</h2><p>到目前为止，我所描述的是一个非常普通的 LSTM。但并非所有 LSTM 都与上面的相同。事实上，几乎每篇涉及 LSTM 的论文似乎都使用了略有不同的版本。这些差异很小，但值得一提的是其中的一些。</p><p><a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf">Gers 和 Schmidhuber (2000)</a>提出的一种流行的 LSTM 变体是添加“窥孔连接”。这意味着我们让门层查看单元状态。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-peepholes.png" alt="img"></p><p>上图为所有门添加了窥视孔，但许多论文只会给出一些窥视孔，而不会给出其他窥视孔。</p><p>另一种变体是使用耦合的遗忘门和输入门。我们不是分别决定遗忘什么以及应该向什么添加新信息，而是一起做出这些决定。我们只会在要输入某些东西来代替它时才会忘记。我们只会在忘记旧东西时向状态输入新值。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-tied.png" alt="img"></p><p><a href="http://arxiv.org/pdf/1406.1078v3.pdf">LSTM 的一个稍微更戏剧性的变体是Cho 等人（2014 年）</a>提出的门控循环单元（GRU ）。它将遗忘门和输入门合并为一个“更新门”。它还合并了单元状态和隐藏状态，并做了一些其他更改。由此产生的模型比标准 LSTM 模型更简单，而且越来越受欢迎。</p><p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png" alt="门控循环单元神经网络。"></p><p>这些只是最值得注意的 LSTM 变体中的一小部分。还有很多其他的变体，例如<a href="http://arxiv.org/pdf/1508.03790v2.pdf">Yao 等人 (2015)</a>提出的深度门控 RNN 。还有一些完全不同的方法来解决长期依赖关系，例如<a href="http://arxiv.org/pdf/1402.3511v1.pdf">Koutnik 等人 (2014)</a>提出的 Clockwork RNN 。</p><p>这些变体中哪一个最好？差异重要吗？<a href="http://arxiv.org/pdf/1503.04069.pdf">Greff 等人（2015 年）</a>对流行的变体进行了很好的比较，发现它们都差不多。Jozefowicz<a href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">等人（2015 年）</a>测试了超过一万个 RNN 架构，发现有些架构在某些任务上比 LSTM 效果更好。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>之前，我提到了人们使用 RNN 取得的显著成果。基本上，所有这些都是使用 LSTM 实现的。它们在大多数任务上确实表现更好！</p><p>LSTM 写成一组方程式后，看起来相当吓人。希望本文一步步介绍它们能让你更容易理解。</p><p>LSTM 是我们利用 RNN 实现的一大进步。人们自然会想：还有另一大进步吗？研究人员的普遍看法是：“是的！还有下一步，那就是注意力！”这个想法是让 RNN 的每一步都从更大的信息集合中挑选信息来查看。例如，如果您使用 RNN 创建描述图像的标题，它可能会挑选图像的一部分来查看它输出的每个单词。事实上，<a href="http://arxiv.org/pdf/1502.03044v2.pdf">Xu<em>等人</em>(2015)</a>就是这么做的——如果您想探索注意力，这可能是一个有趣的起点！使用注意力已经取得了许多非常令人兴奋的成果，而且似乎还有更多的成果即将面世……</p><p>注意力并不是 RNN 研究中唯一令人兴奋的线索。例如，<a href="http://arxiv.org/pdf/1507.01526v1.pdf">Kalchbrenner<em>等人</em>(2015)</a>的网格 LSTM看起来非常有前景。在生成模型中使用 RNN 的工作 - 例如<a href="http://arxiv.org/pdf/1502.04623.pdf">Gregor<em>等人</em>(2015)</a>、<a href="http://arxiv.org/pdf/1506.02216v3.pdf">Chung<em>等人</em>(2015)</a>或<a href="http://arxiv.org/pdf/1411.7610v3.pdf">Bayer &amp; Osendorfer (2015)</a> - 也看起来非常有趣。过去几年对于循环神经网络来说是激动人心的几年，而未来的几年只会更加激动人心！</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>我非常感谢许多人帮助我更好地理解 LSTM、对可视化效果发表评论并对这篇文章提供反馈。</p><p>我非常感谢 Google 的同事们提供的有益反馈，特别是<a href="http://research.google.com/pubs/OriolVinyals.html">Oriol Vinyals</a>、<a href="http://research.google.com/pubs/GregCorrado.html">Greg Corrado</a>、<a href="http://research.google.com/pubs/JonathonShlens.html">Jon Shlens</a>、<a href="http://people.cs.umass.edu/~luke/">Luke Vilnis</a>和<a href="http://www.cs.toronto.edu/~ilya/">Ilya Sutskever</a>。我还要感谢许多其他朋友和同事抽出时间帮助我，包括<a href="https://www.linkedin.com/pub/dario-amodei/4/493/393">Dario Amodei</a>和<a href="http://cs.stanford.edu/~jsteinhardt/">Jacob Steinhardt</a>。我特别感谢<a href="http://www.kyunghyuncho.me/">Kyunghyun Cho</a>对我的图表的极其周到的反馈。</p><p>在写这篇文章之前，我在两个关于神经网络的研讨会系列中练习解释 LSTM。感谢所有参加研讨会的人对我的耐心和反馈。</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载 &lt;a href=&quot;https://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;https://colah.github.io/posts/2015-08-Understanding-</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="深度学习" scheme="http://ai.mak.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Makedown数学公式参考</title>
    <link href="http://ai.mak.cn/2024/02/27/%E5%B7%A5%E5%85%B7/Makedown%E5%85%AC%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83/"/>
    <id>http://ai.mak.cn/2024/02/27/%E5%B7%A5%E5%85%B7/Makedown%E5%85%AC%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83/</id>
    <published>2024-02-26T16:00:00.000Z</published>
    <updated>2024-05-28T06:35:59.302Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://segmentfault.com/a/1190000042253190">https://segmentfault.com/a/1190000042253190</a></p><h2 id="一、公式使用参考"><a href="#一、公式使用参考" class="headerlink" title="一、公式使用参考"></a>一、公式使用参考</h2><h3 id="1．如何插入公式"><a href="#1．如何插入公式" class="headerlink" title="1．如何插入公式"></a>1．如何插入公式</h3><p>$\TeX$ 可使用行中公式放在文中与其它文字混编，或单独成行的独立公式。</p><p><strong>（1）行中公式</strong></p><p>可以用如下方法表示：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> 表达式 <span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ J_<span class="string">\alpha(x)</span> = <span class="string">\sum_&#123;m=0&#125;^\infty</span> <span class="string">\frac&#123;(-1)^m&#125;&#123;m!</span> <span class="string">\Gamma</span> (m + <span class="string">\alpha</span> + <span class="number">1</span>)&#125; &#123;<span class="string">\left(&#123;</span> <span class="string">\frac&#123;x&#125;&#123;2&#125;</span> &#125;<span class="string">\right)&#125;^&#123;2m</span> + <span class="string">\alpha&#125;</span> <span class="string">\text</span> &#123;，行内公式示例&#125; $</span><br></pre></td></tr></table></figure><p>显示：<br>$ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p><p><strong>（2）独立公式</strong></p><p>可以用如下方法表示：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> 表达式 <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ J_<span class="string">\alpha(x)</span> = <span class="string">\sum_&#123;m=0&#125;^\infty</span> <span class="string">\frac&#123;(-1)^m&#125;&#123;m!</span> <span class="string">\Gamma</span> (m + <span class="string">\alpha</span> + <span class="number">1</span>)&#125; &#123;<span class="string">\left(&#123;</span> <span class="string">\frac&#123;x&#125;&#123;2&#125;</span> &#125;<span class="string">\right)&#125;^&#123;2m</span> + <span class="string">\alpha&#125;</span> <span class="string">\text&#123;，独立公式示例&#125;</span> $$</span><br></pre></td></tr></table></figure><p>显示：</p><p>𝐽𝛼(𝑥)&#x3D;∑𝑚&#x3D;0∞(−1)𝑚𝑚!Γ(𝑚+𝛼+1)(𝑥2)2𝑚+𝛼，独立公式示例<em>J**α</em>(<em>x</em>)&#x3D;<em>m</em>&#x3D;0∑∞<em>m</em>!Γ(<em>m</em>+<em>α</em>+1)(−1)<em>m</em>(2<em>x</em>)2<em>m</em>+<em>α</em>，独立公式示例</p><p><strong>（3）自动编号</strong></p><p>公式可以用如下方法表示：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;equation&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    表达式</span></span><br><span class="line"><span class="language-xml">    \label</span><span class="template-variable">&#123;<span class="keyword">eq</span>:当前公式名&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;equation&#125;</span></span><br></pre></td></tr></table></figure><p>自动编号后的公式可在全文任意处使用 <code>\eqref&#123;eq:公式名&#125;</code> 语句引用。</p><p>例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">$$ 在公式 \eqref</span><span class="template-variable">&#123;<span class="keyword">eq</span>:sample&#125;</span><span class="language-xml"> 中，我们看到了这个被自动编号的公式。$$</span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;equation&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    E=mc^2 \text</span><span class="template-variable">&#123;，自动编号公式示例&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    \label</span><span class="template-variable">&#123;<span class="keyword">eq</span>:sample&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;equation&#125;</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$ \begin{equation} E&#x3D;mc^2 \text{，自动编号公式示例} \label{eq:sample7} \end{equation} $$</p><p>$$ 在公式 \eqref{eq:sample6} 中，我们看到了这个被自动编号的公式。$$</p><p><strong>（4）手动编号</strong></p><p>若需要手动编号，可在公式后使用 <code>\tag&#123;编号&#125;</code> 语句。</p><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ J_<span class="string">\alpha(x)</span> = <span class="string">\sum_&#123;m=0&#125;^\infty</span> <span class="string">\frac&#123;(-1)^m&#125;&#123;m!</span> <span class="string">\Gamma</span> (m + <span class="string">\alpha</span> + <span class="number">1</span>)&#125; &#123;<span class="string">\left(&#123;</span> <span class="string">\frac&#123;x&#125;&#123;2&#125;</span> &#125;<span class="string">\right)&#125;^&#123;2m</span> + <span class="string">\alpha&#125;</span> <span class="string">\text&#123;，使用</span> <span class="string">\tag</span> 手动编号&#125; <span class="string">\tag&#123;0.1&#125;</span> $$</span><br></pre></td></tr></table></figure><p>显示：</p><p>$$ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text{，使用 \tag 手动编号} \tag{0.1} $$</p><p><strong>（5）不自动编号</strong></p><p>公式可以用如下方法表示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;equation*&#125;</span><br><span class="line">    表达式</span><br><span class="line">\<span class="keyword">end</span>&#123;equation*&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><p>表达式表达式</p><h3 id="2．如何输入上下标"><a href="#2．如何输入上下标" class="headerlink" title="2．如何输入上下标"></a>2．如何输入上下标</h3><p><code>^</code> 表示上标，<code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code> 将这些内容括成一个整体。<br>上下标可以嵌套，也可以同时使用。</p><ul><li><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> x^&#123;y^z&#125;=(<span class="number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="number">-2</span>xy^w&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑥𝑦𝑧&#x3D;(1+e𝑥)−2𝑥𝑦𝑤<em>x<strong>y</strong>z</em>&#x3D;(1+e<em>x</em>)−2<em>x<strong>y</strong>w</em></p><p>如果要在左右两边都有上下标，可以使用 <code>\sideset</code> 命令；也可以简单地在符号前面多打一个上下标，此时会以行内公式渲染。<br>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">$$ \sideset</span><span class="template-variable">&#123;^1_2&#125;</span><span class="template-variable">&#123;^3_4&#125;</span><span class="language-xml">\bigotimes \quad or \quad </span><span class="template-variable">&#123;^1_2&#125;</span><span class="language-xml">\bigotimes </span><span class="template-variable">&#123;^3_4&#125;</span><span class="language-xml"> $$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>$$ \sideset{^1_2}{^3_4}\bigotimes \quad or \quad {^1_2}\bigotimes {^3_4} $$</p><h3 id="3．如何输入括号和分隔符"><a href="#3．如何输入括号和分隔符" class="headerlink" title="3．如何输入括号和分隔符"></a>3．如何输入括号和分隔符</h3><p><code>()</code>、<code>[]</code> 和 <code>|</code> 表示符号本身，使用 <code>\&#123;\&#125;</code> 来表示 <code>&#123;&#125;</code> 。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令。</p><p>一些特殊的括号：</p><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\langle</td><td align="center">$\langle$</td><td align="center">\rangle</td><td align="center">$\rangle$</td></tr><tr><td align="center">\lceil</td><td align="center">$\lceil$</td><td align="center">\rceil</td><td align="center">$\rceil$</td></tr><tr><td align="center">\lfloor</td><td align="center">$\lfloor$</td><td align="center">\rfloor</td><td align="center">$\rfloor$</td></tr><tr><td align="center">\lbrace</td><td align="center">$\lbrace$</td><td align="center">\rbrace</td><td align="center">$\rbrace$</td></tr><tr><td align="center">\lvert</td><td align="center">$\lvert$</td><td align="center">\rvert</td><td align="center">$\rvert$</td></tr><tr><td align="center">\lVert</td><td align="center">$\lVert$</td><td align="center">\rVert</td><td align="center">$\rVert$</td></tr></tbody></table><p>有时，我们需要在行内使用两个竖杠表示向量间的某种空间距离，可以这样写：<br><span style="text-align: center; display: block"> <code>\lVert \boldsymbol&#123;X&#125;_i - \boldsymbol&#123;S&#125;_j \rVert^2</code> → $\lVert \boldsymbol{X}_i - \boldsymbol{S}_j \rVert^2$ </span></p><ul><li><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> f(x,y,z) = <span class="number">3</span>y^<span class="number">2</span>z \left( <span class="number">3</span>+\<span class="built_in">frac</span>&#123;<span class="number">7</span>x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑓(𝑥,𝑦,𝑧)&#x3D;3𝑦2𝑧(3+7𝑥+51+𝑦2)<em>f</em>(<em>x</em>,<em>y</em>,<em>z</em>)&#x3D;3<em>y</em>2<em>z</em>(3+1+<em>y</em>27<em>x</em>+5)</p><p>有时要用 <code>\left.</code> 或 <code>\right.</code> 进行匹配而不显示本身。</p><ul><li><p>例子：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">$$ \left. \frac</span><span class="template-variable">&#123;&#123;\<span class="name">rm</span> d&#125;u&#125;&#123;&#123;\rm d&#125;x&#125; \right| _&#123;<span class="attr">x</span>=<span class="number">0</span>&#125; $$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>d𝑢d𝑥∣𝑥&#x3D;0d<em>x</em>d<em>u</em>∣∣<em>x</em>&#x3D;0</p><h3 id="4．如何输入分数"><a href="#4．如何输入分数" class="headerlink" title="4．如何输入分数"></a>4．如何输入分数</h3><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 来生成一个分数，分数可多层嵌套。<br>若分数只有一层，也可使用 <code>分子 \over 分母</code> 命令。<br>例内 <code>\quad</code> <code>\mid</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built_in">frac</span>&#123;a<span class="number">-1</span>&#125;&#123;b<span class="number">-1</span>&#125; \quad <span class="keyword">or</span> \quad &#123;a+<span class="number">1</span> \over b+<span class="number">1</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑎−1𝑏−1𝑜𝑟𝑎+1𝑏+1<em>b</em>−1<em>a</em>−1<em>or**b</em>+1<em>a</em>+1</p><p>当分式 <strong>仅有两个字符时</strong> 可直接输入 <code>\frac ab</code> 来快速生成一个 $\Large\frac ab$ 。</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ <span class="string">\frac</span> <span class="number">12</span>,<span class="string">\frac</span> <span class="number">1a</span>,<span class="string">\frac</span> a2 <span class="string">\quad</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\text&#123;2</span> letters only:&#125; <span class="string">\quad</span> <span class="string">\frac</span> <span class="number">12a</span> <span class="string">\,,</span> k<span class="string">\frac</span> q&#123;r^<span class="number">2</span>&#125; $$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>12,1𝑎,𝑎2∣2 letters only:12𝑎,𝑘𝑞𝑟221,<em>a</em>1,2<em>a</em>∣2 letters only:21<em>a</em>,<em>k**r</em>2<em>q</em></p><h3 id="5．如何输入开方"><a href="#5．如何输入开方" class="headerlink" title="5．如何输入开方"></a>5．如何输入开方</h3><p>使用 <code>\sqrt [根指数，省略时为2] &#123;被开方数&#125;</code> 命令输入开方。<br>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built_in">sqrt</span>&#123;<span class="number">2</span>&#125; \quad <span class="keyword">or</span> \quad \<span class="built_in">sqrt</span>[n]&#123;<span class="number">3</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>2𝑜𝑟3𝑛2<em>or**n</em>3</p><h3 id="6．如何输入省略号"><a href="#6．如何输入省略号" class="headerlink" title="6．如何输入省略号"></a>6．如何输入省略号</h3><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与 <strong>文本底线</strong> 对齐的省略号，<code>\cdots</code> 表示与 <strong>文本中线</strong> 对齐的省略号。</p><ul><li><p>例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">$$ f(x_1,x_2,\underbrace</span><span class="template-variable">&#123;\ldots&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;\rm ldots&#125;</span><span class="language-xml"> ,x_n) = x_1^2 + x_2^2 + \underbrace</span><span class="template-variable">&#123;\cdots&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;\rm cdots&#125;</span><span class="language-xml"> + x_n^2 $$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑓(𝑥1,𝑥2,…⏟ldots,𝑥𝑛)&#x3D;𝑥12+𝑥22+⋯⏟cdots+𝑥𝑛2<em>f</em>(<em>x</em>1,<em>x</em>2,ldots…,<em>x**n</em>)&#x3D;<em>x</em>12+<em>x</em>22+cdots⋯+<em>x**n</em>2</p><h3 id="7．如何输入向量"><a href="#7．如何输入向量" class="headerlink" title="7．如何输入向量"></a>7．如何输入向量</h3><p>使用 <code>\vec&#123;向量&#125;</code> 来自动产生一个向量。也可以使用 <code>\overrightarrow</code> 等命令自定义字母上方的符号。<br>例内 <code>\quad</code> <code>\mid</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \vec&#123;a&#125; \cdot \vec&#123;b&#125;=<span class="number">0</span> <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑎⃗⋅𝑏⃗&#x3D;0<em>a</em>⋅<em>b</em>&#x3D;0</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ xy <span class="string">\text&#123;</span> <span class="keyword">with</span> arrows:&#125; <span class="string">\quad</span> <span class="string">\overleftarrow&#123;xy&#125;</span> <span class="string">\;</span> <span class="string">\mid</span> <span class="string">\;</span> <span class="string">\overleftrightarrow&#123;xy&#125;</span> <span class="string">\;</span> <span class="string">\mid</span> <span class="string">\;</span> <span class="string">\overrightarrow&#123;xy&#125;</span> $$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>𝑥𝑦 with arrows:𝑥𝑦←∣𝑥𝑦↔∣𝑥𝑦→<em>x**y</em> with arrows:<em>x**y</em>∣<em>x**y</em>∣<em>x**y</em></p><h3 id="8．如何输入积分"><a href="#8．如何输入积分" class="headerlink" title="8．如何输入积分"></a>8．如何输入积分</h3><p>使用 <code>\int_积分下限^积分上限 &#123;被积表达式&#125;</code> 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>∫01𝑥2d𝑥∫01<em>x</em>2d<em>x</em></p><p>本例中 <code>\,</code> 和 <code>&#123;\rm d&#125;</code> 部分可省略，但加入能使式子更美观，详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>及<a href="https://segmentfault.com/a/1190000042253190#">如何进行字体转换</a>。</p><h3 id="9．如何输入极限运算"><a href="#9．如何输入极限运算" class="headerlink" title="9．如何输入极限运算"></a>9．如何输入极限运算</h3><p>使用 <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code> 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号。</p><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ <span class="string">\lim_&#123;n</span> <span class="string">\to</span> <span class="string">\infty&#125;</span> <span class="string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\lim_&#123;x\leftarrow&#123;示例&#125;&#125;</span> <span class="string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> $$</span><br></pre></td></tr></table></figure><p>显示：</p><p>lim⁡𝑛→∞1𝑛(𝑛+1)𝑎𝑛𝑑lim⁡𝑥←示例1𝑛(𝑛+1)<em>n</em>→∞lim<em>n</em>(<em>n</em>+1)1<em>an<strong>d</strong>x</em>←示例lim<em>n</em>(<em>n</em>+1)1</p><h3 id="10．如何输入累加、累乘运算"><a href="#10．如何输入累加、累乘运算" class="headerlink" title="10．如何输入累加、累乘运算"></a>10．如何输入累加、累乘运算</h3><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code> 来输入一个累加。与之类似，使用 <code>\prod</code> <code>\bigcup</code> <code>\bigcap</code> 来分别输入累乘、并集和交集，更多符号可参考“<a href="https://segmentfault.com/a/1190000042253190#">其它特殊字符</a>”。</p><p>此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 <code>\sum_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125;</code> 显示为 $\sum_{i&#x3D;1}^n \frac{1}{i^2}$ ；</p><p>或在行内可使用 <code>\sum\limits_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code> 使上下标仍在正上正下方。<br><span style="text-align: center; display: block;"> 如 <code>\sum\limits_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125;</code> 显示为 $\sum\limits_{i&#x3D;1}^n \frac{1}{i^2}$ 。</span></p><p>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ <span class="string">\sum_&#123;i=1&#125;^n</span> <span class="string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\prod_&#123;i=1&#125;^n</span> <span class="string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\bigcup_&#123;i=1&#125;^&#123;2&#125;</span> <span class="string">\Bbb&#123;R&#125;</span> $$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>∑𝑖&#x3D;1𝑛1𝑖2𝑎𝑛𝑑∏𝑖&#x3D;1𝑛1𝑖2𝑎𝑛𝑑⋃𝑖&#x3D;12𝑅<em>i</em>&#x3D;1∑<em>n**i</em>21<em>an<strong>d</strong>i</em>&#x3D;1∏<em>n**i</em>21<em>an<strong>d</strong>i</em>&#x3D;1⋃2R</p><h3 id="11．如何输入希腊字母"><a href="#11．如何输入希腊字母" class="headerlink" title="11．如何输入希腊字母"></a>11．如何输入希腊字母</h3><p>输入 <code>\小写希腊字母英文全称</code> 和 <code>\首字母大写希腊字母英文全称</code> 来分别输入小写和大写希腊字母。<br><strong>对于大写希腊字母与现有字母相同的，直接输入大写字母即可。</strong></p><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\alpha</td><td align="center">$\alpha$</td><td align="center">A</td><td align="center">$A$</td><td align="center">\beta</td><td align="center">$\beta$</td><td align="center">B</td><td align="center">$B$</td></tr><tr><td align="center">\gamma</td><td align="center">$\gamma$</td><td align="center">\Gamma</td><td align="center">$\Gamma$</td><td align="center">\delta</td><td align="center">$\delta$</td><td align="center">\Delta</td><td align="center">$\Delta$</td></tr><tr><td align="center">\epsilon</td><td align="center">$\epsilon$</td><td align="center">E</td><td align="center">$E$</td><td align="center">\zeta</td><td align="center">$\zeta$</td><td align="center">Z</td><td align="center">$Z$</td></tr><tr><td align="center">\eta</td><td align="center">$\eta$</td><td align="center">H</td><td align="center">$H$</td><td align="center">\theta</td><td align="center">$\theta$</td><td align="center">\Theta</td><td align="center">$\Theta$</td></tr><tr><td align="center">\iota</td><td align="center">$\iota$</td><td align="center">I</td><td align="center">$I$</td><td align="center">\kappa</td><td align="center">$\kappa$</td><td align="center">K</td><td align="center">$K$</td></tr><tr><td align="center">\lambda</td><td align="center">$\lambda$</td><td align="center">\Lambda</td><td align="center">$\Lambda$</td><td align="center">\mu</td><td align="center">$\mu$</td><td align="center">M</td><td align="center">$M$</td></tr><tr><td align="center">\nu</td><td align="center">$\nu$</td><td align="center">N</td><td align="center">$N$</td><td align="center">\xi</td><td align="center">$\xi$</td><td align="center">\Xi</td><td align="center">$\Xi$</td></tr><tr><td align="center">o</td><td align="center">$o$</td><td align="center">O</td><td align="center">$O$</td><td align="center">\pi</td><td align="center">$\pi$</td><td align="center">\Pi</td><td align="center">$\Pi$</td></tr><tr><td align="center">\rho</td><td align="center">$\rho$</td><td align="center">P</td><td align="center">$P$</td><td align="center">\sigma</td><td align="center">$\sigma$</td><td align="center">\Sigma</td><td align="center">$\Sigma$</td></tr><tr><td align="center">\tau</td><td align="center">$\tau$</td><td align="center">T</td><td align="center">$T$</td><td align="center">\upsilon</td><td align="center">$\upsilon$</td><td align="center">\Upsilon</td><td align="center">$\Upsilon$</td></tr><tr><td align="center">\phi</td><td align="center">$\phi$</td><td align="center">\Phi</td><td align="center">$\Phi$</td><td align="center">\chi</td><td align="center">$\chi$</td><td align="center">X</td><td align="center">$X$</td></tr><tr><td align="center">\psi</td><td align="center">$\psi$</td><td align="center">\Psi</td><td align="center">$\Psi$</td><td align="center">\omega</td><td align="center">$\omega$</td><td align="center">\Omega</td><td align="center">$\Omega$</td></tr><tr><td align="center">\partial</td><td align="center">$\partial$</td><td align="center">\nabla</td><td align="center">$\nabla$</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>部分字母有变量专用形式，以 <code>\var-</code> 开头。</strong></p><table><thead><tr><th align="center">小写形式</th><th align="center">大写形式</th><th align="center">变量形式</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\epsilon</td><td align="center">E</td><td align="center">\varepsilon</td><td align="center">$\epsilon \mid E \mid \varepsilon$</td></tr><tr><td align="center">\theta</td><td align="center">\Theta</td><td align="center">\vartheta</td><td align="center">$\theta \mid \Theta \mid \vartheta$</td></tr><tr><td align="center">\rho</td><td align="center">P</td><td align="center">\varrho</td><td align="center">$\rho \mid P \mid \varrho$</td></tr><tr><td align="center">\sigma</td><td align="center">\Sigma</td><td align="center">\varsigma</td><td align="center">$\sigma \mid \Sigma \mid \varsigma$</td></tr><tr><td align="center">\phi</td><td align="center">\Phi</td><td align="center">\varphi</td><td align="center">$\phi \mid \Phi \mid \varphi$</td></tr></tbody></table><h3 id="12．如何输入其它特殊字符"><a href="#12．如何输入其它特殊字符" class="headerlink" title="12．如何输入其它特殊字符"></a>12．如何输入其它特殊字符</h3><h4 id="1-．关系运算符"><a href="#1-．关系运算符" class="headerlink" title="(1)．关系运算符"></a>(1)．关系运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\pm</td><td align="center">$\pm$</td><td align="center">\times</td><td align="center">$\times$</td><td align="center">\div</td><td align="center">$\div$</td><td align="center">\mid</td><td align="center">$\mid$</td></tr><tr><td align="center">\nmid</td><td align="center">$\nmid$</td><td align="center">\cdot</td><td align="center">$\cdot$</td><td align="center">\circ</td><td align="center">$\circ$</td><td align="center">\ast</td><td align="center">$\ast$</td></tr><tr><td align="center">\odot</td><td align="center">$\odot$</td><td align="center">\otimes</td><td align="center">$\otimes$</td><td align="center">\oplus</td><td align="center">$\oplus$</td><td align="center">\leq</td><td align="center">$\leq$</td></tr><tr><td align="center">\geq</td><td align="center">$\geq$</td><td align="center">\neq</td><td align="center">$\neq$</td><td align="center">\approx</td><td align="center">$\approx$</td><td align="center">\equiv</td><td align="center">$\equiv$</td></tr><tr><td align="center">\sum</td><td align="center">$\sum$</td><td align="center">\prod</td><td align="center">$\prod$</td><td align="center">\coprod</td><td align="center">$\coprod$</td><td align="center">\backslash</td><td align="center">$\backslash$</td></tr></tbody></table><h4 id="2-．集合运算符"><a href="#2-．集合运算符" class="headerlink" title="(2)．集合运算符"></a>(2)．集合运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\emptyset</td><td align="center">$\emptyset$</td><td align="center">\in</td><td align="center">$\in$</td><td align="center">\notin</td><td align="center">$\notin$</td></tr><tr><td align="center">\subset</td><td align="center">$\subset$</td><td align="center">\supset</td><td align="center">$\supset$</td><td align="center">\subseteq</td><td align="center">$\subseteq$</td></tr><tr><td align="center">\supseteq</td><td align="center">$\supseteq$</td><td align="center">\cap</td><td align="center">$\cap$</td><td align="center">\cup</td><td align="center">$\cup$</td></tr><tr><td align="center">\vee</td><td align="center">$\vee$</td><td align="center">\wedge</td><td align="center">$\wedge$</td><td align="center">\uplus</td><td align="center">$\uplus$</td></tr><tr><td align="center">\top</td><td align="center">$\top$</td><td align="center">\bot</td><td align="center">$\bot$</td><td align="center">\complement</td><td align="center">$\complement$</td></tr></tbody></table><h4 id="3-．对数运算符"><a href="#3-．对数运算符" class="headerlink" title="(3)．对数运算符"></a>(3)．对数运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\log</td><td align="center">$\log$</td><td align="center">\lg</td><td align="center">$\lg$</td><td align="center">\ln</td><td align="center">$\ln$</td></tr></tbody></table><h4 id="4-．三角运算符"><a href="#4-．三角运算符" class="headerlink" title="(4)．三角运算符"></a>(4)．三角运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\backsim</td><td align="center">$\backsim$</td><td align="center">\cong</td><td align="center">$\cong$</td><td align="center">\angle A</td><td align="center">$\angle A$</td></tr><tr><td align="center">\sin</td><td align="center">$\sin$</td><td align="center">\cos</td><td align="center">$\cos$</td><td align="center">\tan</td><td align="center">$\tan$</td></tr><tr><td align="center">\csc</td><td align="center">$\csc$</td><td align="center">\sec</td><td align="center">$\sec$</td><td align="center">\cot</td><td align="center">$\cot$</td></tr></tbody></table><h4 id="5-．微积分运算符"><a href="#5-．微积分运算符" class="headerlink" title="(5)．微积分运算符"></a>(5)．微积分运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\int</td><td align="center">$\int$</td><td align="center">\iint</td><td align="center">$\iint$</td><td align="center">\iiint</td><td align="center">$\iiint$</td></tr><tr><td align="center">\partial</td><td align="center">$\partial$</td><td align="center">\oint</td><td align="center">$\oint$</td><td align="center">\prime</td><td align="center">$\prime$</td></tr><tr><td align="center">\lim</td><td align="center">$\lim$</td><td align="center">\infty</td><td align="center">$\infty$</td><td align="center">\nabla</td><td align="center">$\nabla$</td></tr></tbody></table><h4 id="6-．逻辑运算符"><a href="#6-．逻辑运算符" class="headerlink" title="(6)．逻辑运算符"></a>(6)．逻辑运算符</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\because</td><td align="center">$\because$</td><td align="center">\therefore</td><td align="center">$\therefore$</td><td align="center">\neg</td><td align="center">$\neg$</td></tr><tr><td align="center">\forall</td><td align="center">$\forall$</td><td align="center">\exists</td><td align="center">$\exists$</td><td align="center">\not\subset</td><td align="center">$\not\subset$</td></tr><tr><td align="center">\not&lt;</td><td align="center">$\not&lt;$</td><td align="center">\not&gt;</td><td align="center">$\not&gt;$</td><td align="center">\not&#x3D;</td><td align="center">$\not&#x3D;$</td></tr><tr><td align="center">\vdash</td><td align="center">$\vdash$</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="7-．戴帽符号"><a href="#7-．戴帽符号" class="headerlink" title="(7)．戴帽符号"></a>(7)．戴帽符号</h4><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\hat{xy}</td><td align="center">$\hat{xy}$</td><td align="center">\widehat{xyz}</td><td align="center">$\widehat{xyz}$</td><td align="center">\bar{y}</td><td align="center">$\bar{y}$</td></tr><tr><td align="center">\tilde{xy}</td><td align="center">$\tilde{xy}$</td><td align="center">\widetilde{xyz}</td><td align="center">$\widetilde{xyz}$</td><td align="center">\acute{y}</td><td align="center">$\acute{y}$</td></tr><tr><td align="center">\breve{y}</td><td align="center">$\breve{y}$</td><td align="center">\check{y}</td><td align="center">$\check{y}$</td><td align="center">\grave{y}</td><td align="center">$\grave{y}$</td></tr><tr><td align="center">\dot{x}</td><td align="center">$\dot{x}$</td><td align="center">\ddot{x}</td><td align="center">$\ddot{x}$</td><td align="center">\dddot{x}</td><td align="center">$\dddot{x}$</td></tr></tbody></table><p>若需要在特定文字顶部\底部放置内容，可使用 <code>\overset&#123;顶部内容&#125;&#123;正常内容&#125;</code> 和 <code>\underset&#123;底部内容&#125;&#123;正常内容&#125;</code> 命令。<br>例内 <code>\qquad</code> <code>\quad</code> <code>\mid</code> <code>\;</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="https://segmentfault.com/a/1190000042253190#">在字符间加入空格</a>。</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ <span class="string">\verb+\overset&#123;above&#125;&#123;level&#125;+</span> <span class="string">\qquad</span> <span class="string">\overset&#123;xx&#125;&#123;ABC&#125;</span> <span class="string">\;\;</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\overset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="string">\,</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\overset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>\overset{above}{level}𝐴𝐵𝐶𝑥𝑥∣⟼𝑥2 ∣𝑇∙∘∘∙\overset{above}{level}<em>A<strong>BC</strong>xx</em>∣⟼<em>x</em>2 ∣<em>T</em>∙∘∘∙</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ <span class="string">\verb+\underset&#123;below&#125;&#123;level&#125;+</span> <span class="string">\qquad</span> <span class="string">\underset&#123;xx&#125;&#123;ABC&#125;</span> <span class="string">\;\;</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\underset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="string">\,</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\underset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>\underset{below}{level}𝐴𝐵𝐶𝑥𝑥∣⟼𝑥2 ∣𝑇∙∘∘∙\underset{below}{level}<em>xx<strong>A</strong>BC</em>∣<em>x</em>2⟼ ∣∙∘∘∙<em>T</em></p><p>此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号，<br>如 <code>\overset&#123;H_2&#125;&#123;\underset&#123;1300℃&#125;&#123;\Longleftrightarrow&#125;&#125;</code>：<br>SrO+VSr′′⟺1300℃H2SrSr×+2e′+12O2(g)SrO+VSr′′​1300℃⟺​H2​​SrSr×​+2e′+21​O2​(g)</p><p>和 <code>\overset&#123;Surface/bulk&#125;&#123;\underset&#123;diffusion&#125;&#123;\longleftrightarrow&#125;&#125;</code>：<br>2OHO(STN)∘+2OO(YSZ)×⟷diffusionSurface&#x2F;bulk2OHO(YSZ)∘+2OO(STN)×2OHO(STN)∘​+2OO(YSZ)×​diffusion⟷​Surface&#x2F;bulk​2OHO(YSZ)∘​+2OO(STN)×​</p><p>在书写化学方程式时可声明 <code>\require&#123;AMDcd&#125;</code> 语句，使用 MathJax 内置的交换图表功能，具体例子可<a href="https://segmentfault.com/a/1190000042253190#1%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%8D%A2%E5%9B%BE%E8%A1%A8">参见下文</a>。</p><h4 id="8-．连线符号"><a href="#8-．连线符号" class="headerlink" title="(8)．连线符号"></a>(8)．连线符号</h4><p>其它可用的文字修饰符可参见官方文档 <a href="https://link.segmentfault.com/?enc=/HSJ3WSU0CTgZfNy5Yf78g==.R0WMMPY+9yDpdC3N2hOE4e25sOmj2pHTKz4+FOaaXMG8xcfQKCdeVlqbAUoyrmpRA1V8jXEgDaLKWFrqG6c04kNh/d7J1B2mKW4TrxU7OJwBvBY3jkNVBBo7dhaw2q4ao3XoT+1+a2w08WIsGYa/ew==">“Additional decorations”</a>。</p><table><thead><tr><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\fbox{a+b+c+d}</td><td align="center">$\fbox{a+b+c+d}$</td></tr><tr><td align="center">\overleftarrow{a+b+c+d}</td><td align="center">$\overleftarrow{a+b+c+d}$</td></tr><tr><td align="center">\overrightarrow{a+b+c+d}</td><td align="center">$\overrightarrow{a+b+c+d}$</td></tr><tr><td align="center">\overleftrightarrow{a+b+c+d}</td><td align="center">$\overleftrightarrow{a+b+c+d}$</td></tr><tr><td align="center">\underleftarrow{a+b+c+d}</td><td align="center">$\underleftarrow{a+b+c+d}$</td></tr><tr><td align="center">\underrightarrow{a+b+c+d}</td><td align="center">$\underrightarrow{a+b+c+d}$</td></tr><tr><td align="center">\underleftrightarrow{a+b+c+d}</td><td align="center">$\underleftrightarrow{a+b+c+d}$</td></tr><tr><td align="center">\overline{a+b+c+d}</td><td align="center">$\overline{a+b+c+d}$</td></tr><tr><td align="center">\underline{a+b+c+d}</td><td align="center">$\underline{a+b+c+d}$</td></tr><tr><td align="center">\overbrace{a+b+c+d}^{Sample}</td><td align="center">$\overbrace{a+b+c+d}^{Sample}$</td></tr><tr><td align="center">\underbrace{a+b+c+d}_{Sample}</td><td align="center">$\underbrace{a+b+c+d}_{Sample}$</td></tr><tr><td align="center">\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}</td><td align="center">$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td></tr><tr><td align="center">\underbrace{a\cdot a\cdots a}_{b\text{ times}}</td><td align="center">$\underbrace{a\cdot a\cdots a}_{b\text{ times}}$</td></tr></tbody></table><h4 id="9-．箭头符号"><a href="#9-．箭头符号" class="headerlink" title="(9)．箭头符号"></a>(9)．箭头符号</h4><ul><li>推荐使用符号：</li></ul><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\to</td><td align="center">$\to$</td><td align="center">\mapsto</td><td align="center">$\mapsto$</td><td align="center">\underrightarrow{1℃&#x2F;min}</td><td align="center">$\underrightarrow{1℃&#x2F;min}$</td></tr><tr><td align="center">\implies</td><td align="center">$\implies$</td><td align="center">\iff</td><td align="center">$\iff$</td><td align="center">\impliedby</td><td align="center">$\impliedby$</td></tr></tbody></table><ul><li>其它可用符号：</li></ul><table><thead><tr><th align="center">输入</th><th align="center">显示</th><th align="center">输入</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\uparrow</td><td align="center">$\uparrow$</td><td align="center">\Uparrow</td><td align="center">$\Uparrow$</td></tr><tr><td align="center">\downarrow</td><td align="center">$\downarrow$</td><td align="center">\Downarrow</td><td align="center">$\Downarrow$</td></tr><tr><td align="center">\leftarrow</td><td align="center">$\leftarrow$</td><td align="center">\Leftarrow</td><td align="center">$\Leftarrow$</td></tr><tr><td align="center">\rightarrow</td><td align="center">$\rightarrow$</td><td align="center">\Rightarrow</td><td align="center">$\Rightarrow$</td></tr><tr><td align="center">\leftrightarrow</td><td align="center">$\leftrightarrow$</td><td align="center">\Leftrightarrow</td><td align="center">$\Leftrightarrow$</td></tr><tr><td align="center">\longleftarrow</td><td align="center">$\longleftarrow$</td><td align="center">\Longleftarrow</td><td align="center">$\Longleftarrow$</td></tr><tr><td align="center">\longrightarrow</td><td align="center">$\longrightarrow$</td><td align="center">\Longrightarrow</td><td align="center">$\Longrightarrow$</td></tr><tr><td align="center">\longleftrightarrow</td><td align="center">$\longleftrightarrow$</td><td align="center">\Longleftrightarrow</td><td align="center">$\Longleftrightarrow$</td></tr></tbody></table><h3 id="13．如何进行字体转换"><a href="#13．如何进行字体转换" class="headerlink" title="13．如何进行字体转换"></a>13．如何进行字体转换</h3><p>若要对公式的某一部分字符进行字体转换，可以用 <code>&#123;\字体 &#123;需转换的部分字符&#125;&#125;</code> 命令，其中 <code>\字体</code> 部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 $italic$ 。</p><p>示例中 <strong>全部大写</strong> 的字体仅大写可用。</p><table><thead><tr><th align="center">输入</th><th align="center">全字母可用</th><th align="center">显示</th><th align="center">输入</th><th align="center">仅大写可用</th><th align="center">显示</th></tr></thead><tbody><tr><td align="center">\rm</td><td align="center">罗马体</td><td align="center">$\rm{Sample}$</td><td align="center"><strong>\mathcal</strong></td><td align="center"><strong>花体（数学符号等）</strong></td><td align="center">$\mathcal{SAMPLE}$</td></tr><tr><td align="center">\it</td><td align="center">斜体</td><td align="center">$\it{Sample}$</td><td align="center"><strong>\mathbb</strong></td><td align="center"><strong>黑板粗体（定义域等）</strong></td><td align="center">$\mathbb{SAMPLE}$</td></tr><tr><td align="center">\bf</td><td align="center">粗体</td><td align="center">$\bf{Sample}$</td><td align="center">\mit</td><td align="center">数学斜体</td><td align="center">$\mit{SAMPLE}$</td></tr><tr><td align="center">\sf</td><td align="center">等线体</td><td align="center">$\sf{Sample}$</td><td align="center">\scr</td><td align="center">手写体</td><td align="center">$\scr{SAMPLE}$</td></tr><tr><td align="center">\tt</td><td align="center">打字机体</td><td align="center">$\tt{Sample}$</td><td align="center">\cal</td><td align="center">等同于 <code>\mathcal</code></td><td align="center">$\cal{ABCXYZ}$</td></tr><tr><td align="center">\frak</td><td align="center">旧德式字体</td><td align="center">$\frak{Sample}$</td><td align="center">\Bbb</td><td align="center">等同于 <code>\mathbb</code></td><td align="center">$\Bbb{ABCXYZ}$</td></tr><tr><td align="center">\boldsymbol</td><td align="center">向量或者矩阵的加粗斜体</td><td align="center">$\boldsymbol{\vec\alpha}$</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>转换字体十分常用，例如在积分中：</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\begin&#123;array&#125;&#123;cc&#125;</span></span><br><span class="line">  <span class="string">\mathrm&#123;Bad&#125;</span> &amp; <span class="string">\mathrm&#123;Better&#125;</span> <span class="string">\\</span></span><br><span class="line">  <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">  <span class="string">\int_0^1</span> x^<span class="number">2</span> dx &amp; <span class="string">\int_0^1</span> x^<span class="number">2</span> <span class="string">\,&#123;\rm</span> d&#125;x</span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>显示：</p><p>BadBetter∫01𝑥2𝑑𝑥∫01𝑥2d𝑥Bad∫01<em>x</em>2<em>d**x</em>Better∫01<em>x</em>2d<em>x</em></p></li></ul><p>注意比较两个式子间 $dx$ 与 ${\rm d} x$ 的不同。<br>使用 <code>\operatorname</code> 命令也可以达到相同的效果，详见<a href="https://segmentfault.com/a/1190000042253190#">定义新的运算符</a>。</p><h3 id="14．如何高亮一行公式"><a href="#14．如何高亮一行公式" class="headerlink" title="14．如何高亮一行公式"></a>14．如何高亮一行公式</h3><p>使用 <code>\bbox[底色, (可选)边距, (可选)边框 border: 框宽度 框类型 框颜色]</code> 命令来高亮一行公式。<br>底色和框颜色支持详见“<a href="https://segmentfault.com/a/1190000042253190#">更改文字颜色</a>”，边距及框宽度支持 <code>绝对像素 px</code> 或 <code>相对大小 em</code>，框类型支持 <code>实线 solid</code> 或 <code>虚线 dashed</code>。</p><ul><li><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\bbox[yellow]&#123;</span></span><br><span class="line">  e^x=<span class="string">\lim_&#123;n\to\infty&#125;</span> <span class="string">\left(</span> <span class="number">1</span>+<span class="string">\frac&#123;x&#125;&#123;n&#125;</span> <span class="string">\right)^n</span> <span class="string">\qquad</span> (<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></li><li><p>显示：</p></li></ul><p>$$ \bbox[yellow]{ e^x&#x3D;\lim_{n\to\infty} \left( 1+\frac{x}{n} \right)^n \qquad (1) } $$</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\bbox[#9ff,</span> <span class="number">5px</span>]&#123; % 此处向外添加 <span class="number">5</span> 像素的边距</span><br><span class="line">    e^x=<span class="string">\lim_&#123;n\to\infty&#125;</span> <span class="string">\left(</span> <span class="number">1</span>+<span class="string">\frac&#123;x&#125;&#123;n&#125;</span> <span class="string">\right)^n</span> <span class="string">\qquad</span> (<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>显示：</li></ul><p>$$ \bbox[#9ff, 5px]{ e^x&#x3D;\lim_{n\to\infty} \left( 1+\frac{x}{n} \right)^n \qquad (1) } $$</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">% 此处使用 <span class="number">0.5</span> 倍行高作为边距，附加 <span class="number">2</span> 像素的实线边框（Ctrl+Alt+Y 可见）</span><br><span class="line"><span class="string">\bbox[#2f3542,</span> <span class="number">0.5em</span>, border:<span class="number">2px</span> solid <span class="comment">#f1f2f6]&#123;</span></span><br><span class="line">    <span class="string">\color&#123;#f1f2f6&#125;&#123;e^x=\lim_&#123;n\to\infty&#125;</span> <span class="string">\left(</span> <span class="number">1</span>+<span class="string">\frac&#123;x&#125;&#123;n&#125;</span> <span class="string">\right)^n</span> <span class="string">\qquad</span> (<span class="number">1</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>显示：</li></ul><p>$$ \bbox[#2f3542, 0.5em, border:2px solid #f1f2f6]{ \color</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;https://segmentfault.com/a/1190000042253190&quot;&gt;https://segmentfault.com/a/1190000042253190&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、公式使用参考&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Markdown" scheme="http://ai.mak.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>2023 哔哩哔哩技术精选技术干货</title>
    <link href="http://ai.mak.cn/2024/01/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/2023%20%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E6%8A%80%E6%9C%AF%E7%B2%BE%E9%80%89%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/"/>
    <id>http://ai.mak.cn/2024/01/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/2023%20%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E6%8A%80%E6%9C%AF%E7%B2%BE%E9%80%89%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/</id>
    <published>2024-01-05T16:00:00.000Z</published>
    <updated>2024-02-20T09:06:59.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023-哔哩哔哩技术精选技术干货"><a href="#2023-哔哩哔哩技术精选技术干货" class="headerlink" title="2023 哔哩哔哩技术精选技术干货"></a>2023 哔哩哔哩技术精选技术干货</h1><p>作者：哔哩哔哩技术 <a href="https://www.bilibili.com/read/cv28997672/">https://www.bilibili.com/read/cv28997672/</a> 出处：bilibili</p><p>哔哩哔哩技术精彩回顾（点击标题查看）</p><p><strong>01</strong> <a href="https://www.bilibili.com/read/cv22150189/?from=search&spm_id_from=333.337.0.0"><strong>节省数亿IT成本，B站FinOps实践</strong></a></p><blockquote><p>B站在22年初开始落地FinOps，并连续两年实现了，业务增长技术成本零增长。本文介绍了B站如何落地FinOps，推进成本洞察、技术优化和运营优化，提升资源效率的经验，最终实现了数亿IT成本的节省。</p></blockquote><p><strong>02</strong> <a href="https://www.bilibili.com/read/cv24473211/?from=search&spm_id_from=333.337.0.0"><strong>持续降本：B站日志平台3.0演进之路</strong></a></p><blockquote><p>基于ClickHouse的Billions 2.0日志方案上线后，我们又引入了基于Iceberg的湖仓一体架构，推出了Billions 3.0方案。本文介绍了Billions 3.0方案如何进一步提高资源利用率，以实现降本增效的目标，以及我们在存储和引擎层面针对日志场景所做的优化工作。</p></blockquote><p><strong>03</strong> <a href="https://www.bilibili.com/read/cv27753037/?from=search&spm_id_from=333.337.0.0"><strong>云厂商CDN故障后，连夜设计了云边端协同新方案</strong></a></p><blockquote><p>CDN、SLB和BFS网关类流量层组件，天然具备分布式容灾能力，在故障的转移、降级重试和熔断层面，做好上下游的限流统一口径、分层分组件的降级预案、以及服务SLO指标承诺，同时结合端侧开放的调度能力，可以大大提升整体链路的容灾降级能力。</p></blockquote><p><strong>04</strong> <a href="https://www.bilibili.com/read/cv23920810/?from=search&spm_id_from=333.337.0.0"><strong>账号多租户架构升级与落地实践</strong></a></p><blockquote><p>当我们有很多重复的轮子时，服务维护成本高且效率低，平台化建设就显得尤为重要。本文介绍了账号平台化建设的经验，详细分析了账号系统的架构设计逻辑，平台化下不同业务差异化逻辑的设计方案，以及系统灰度切换方案。</p></blockquote><p><strong>05</strong> <a href="https://www.bilibili.com/read/cv25743553/?from=search&spm_id_from=333.337.0.0"><strong>从0到1:哔哩哔哩智能客服系统的设计与实现</strong></a></p><blockquote><p>B站过去的客服系统是通过外部采购获得的，已经运行了几年。然而，随着公司业务的快速发展，外部采购的系统逐渐暴露出其局限性。该系统难以根据业务需求进行定制化开发，而且也无法与公司内部系统进行高效整合，进而影响了工作效率的提升。为了解决这些问题，我们决定开展新客服系统的自主研发工作。经过深入调研、访谈和体验评估，我们确定了几个关键的指标，如用户满意度、智能问答拦截率和平均处理时长。这些核心指标为新客服系统的研发提供了明确的方向。我们从0到1研发了客服系统的智能问答，坐席调度，工作台，知识库，IM聊天基础能力，客服工单，权限管理。本文将带你了解各个核心模块的主要设计思想和实现过程。</p></blockquote><p><strong>06</strong><a href="https://www.bilibili.com/read/cv21576373/?from=search&spm_id_from=333.337.0.0"><strong>【点个赞吧】 - B站千亿级点赞系统服务架构设计</strong></a></p><blockquote><p>B站最具代表的功能之一，为了经受住百万流量、千亿存储的压力，且提供超高的服务可用性与容灾能力，点赞高可用系统应运而生。同时系统不断改造升级，多级|多态存储、双机房等不断演进。</p></blockquote><p><strong>07</strong> <a href="https://www.bilibili.com/read/cv22750308/?from=search&spm_id_from=333.337.0.0"><strong>B站PC客户端-架构设计</strong></a></p><blockquote><p>相对与WEB网页，PC客户端具有跓留电脑的快捷、独立的应用窗口、特有的交互方式等优势。我站之前有一个收编于第三方的UWP客户端，不仅UI粗糙而且还有维护困难、不能跨平台等问题。在21年底，一个电脑预装的需求让我们有了开发一个全新的PC客户端的想法。在降本增效的大背景下，我们通过现有团队抽调人力的方式，采用成熟的跨平台Electron框架，爆肝3个多月完成了1.0版本的研发，实现了直播、推荐、番剧、影视、动态、空间和UGC&#x2F;OGV视频播放等功能，后续迭代中还实现了消息、离线缓存、增量更新、播放本地视频、精选模式、视频投稿等新功能。新版本哔哩哔哩PC客户端于22年5月10在官网正式上线，包含MacOS和Windows两个版本，适配Arm和X86系统架构。我们与联想、惠普达成了预装合作，在微软商店、腾讯管家、华为应用市场、360软件管家等多个PC软件渠道完成了上线，还入选了23年微软商店『精选娱乐应用』和华为市场的『闲暇时光首选』。</p></blockquote><p><strong>08</strong> <a href="https://www.bilibili.com/read/cv26375467/?from=search&spm_id_from=333.337.0.0"><strong>告警平台：给告警一个胶带</strong></a></p><blockquote><p>因为需要质量所以需要告警。从告警覆盖到告警处理、跟进与治理的闭环有助于持续改善告警。告警系统好比一个强力宽胶带把业务研发、组件研发、SRE粘合在一起，快速感知故障，提前发现隐患，让B站行稳致远。本文介绍了B站告警平台一年来的具体演进，包括但不限于构建告警合作模式、丰富告警处理手段、告警治理提升超10倍信噪比实践等，希望能给到大家帮助。</p></blockquote><p><strong>09</strong> <a href="https://www.bilibili.com/read/cv20999025/?from=search&spm_id_from=333.337.0.0"><strong>热点检测治理</strong></a></p><blockquote><p>热门活动和突发热点话题往往会带来瞬间的极端流量，同时这种流量存在极大的负载倾斜。为了快速识别突发热点以及解决热点带来的负载倾斜问题， 我们开发了自动热点识别与治理框架。该框架基于HeavyKeeper算法实现，同时通过衰减优化极大提高了热点检测的灵敏度，达到了热点流量的秒级识别。此外对于识别到的热点，框架自动集成了local cache，通过local cache可以大幅降低后端服务的负载，local cache还支持运营侧白名单配置，支持热门活动的快速预热。灵敏的热点识别度以及高命中率的local cache大幅提升了业务应对突发热点冲击的可用性。</p></blockquote><p><strong>10</strong> <strong><a href="https://www.bilibili.com/read/cv28615128/?from=search&spm_id_from=333.337.0.0">爬虫与反爬-接口安全的风控介绍</a></strong></p><blockquote><p>互联网平台开放的接口众多，其中不少包含了平台重要的数据信息，网络上各式各样的爬虫经常会针对这些接口进行攻击，对于接口的保护和对爬虫流量的清理，对于平台的稳定和数据安全有着至关重要的作用。本文从哔哩哔哩上存在的爬虫形式入手，介绍了当前针对爬虫的攻击，在数据链路、可信校验、风险识别策略、异常感知、风险处置等方面做的防控工作。</p></blockquote><p><strong>11</strong> <strong><a href="https://www.bilibili.com/read/cv27467636/?from=search&spm_id_from=333.337.0.0">B站KAFKA探索与实践</a></strong></p><blockquote><p>开源kafka作为消息组件的主要选择，在大数据领域也有重要的作用。尽管kafka已是成熟的组件，然而在大规模高流量场景下，kafka的维护工作依然是很痛的。本文介绍了我们在kafka的稳定性层面的思考，以及对应的优化思路，一步步将kafka打造成多租户隔离高吞吐低成本的自维护系统。</p></blockquote><p><strong>12</strong> <strong><a href="https://www.bilibili.com/read/cv24072108/?from=search&spm_id_from=333.337.0.0">竟然是”你”偷走了那0.001的服务可用性</a></strong></p><blockquote><p>在业务开发过程中，或多或少会遇到一些性能问题，不少还是疑难杂症，难以下手。我们也知道go有强大的pprof性能分析工具，但是实战时经常一头雾水。本文以一次服务抖动性能问题解决过程为例，讲述go性能问题排查思路以及常用手段，没有难懂的理论知识，简单直白。</p></blockquote><p><strong>13</strong> <a href="https://www.bilibili.com/read/cv28773484/?from=search&spm_id_from=333.337.0.0"><strong>B站大型开播平台重构</strong></a></p><blockquote><p>B站开播平台作为直播内容的产出入口，伴随着B站直播的成长贯穿始终。然而业务飞速成长的同时也必然伴随着技术债务的积累，加之业务知识的遗忘、技术栈的不统一等问题，开播平台几乎已经变成了一个遗留系统，无法满足业务快速迭代的需求，因此从PHP到Go的重构势在必行。本文讲述的重构采用了领域驱动设计作为架构理念，并使用六边形架构作为架构风格。同时，采用了测试驱动开发等方法论来推动项目的实施，并借助事件溯源、流量复制、链路观测等工程设计和运维方法，以确保新系统的顺利上线。在本文中，你还可以了解到开播平台重构全过程的问题分析、设计思路和实际示例，以及安全的新旧服务切换操作和项目顺利上线后的提升效果展示。让我们一起深入探索B站开播平台重构的历程吧，相信在读完本文能让你对大型重构项目有所思考~</p></blockquote><p><strong>14</strong> <a href="https://www.bilibili.com/read/cv25913386/?from=search&spm_id_from=333.337.0.0"><strong>高达平台 - 全链路低代码解决方案</strong></a></p><blockquote><p>低代码开发平台已成为现代软件开发的革命性工具，它们极大地简化了应用程序的开发过程，使得无需深入编程经验的开发者也能快速构建和部署应用。通过图形化界面和预置组件，低代码平台使企业能够迅速响应业务需求、加速数字转型并优化客户体验。这种方法不仅提高了开发效率和生产力，还降低了开发成本和复杂性，使更多的组织能够在竞争激烈的市场中保持敏捷和创新。它将继续推动着业务和IT部门之间的协同工作，为未来的数字化时代创造更多的可能性。</p></blockquote><p><strong>15</strong> <strong><a href="https://www.bilibili.com/read/cv27905829/?from=search&spm_id_from=333.337.0.0">B站故障演练平台实践</a></strong></p><blockquote><p>B 站故障演练平台，深度结合公司业务特点，在微服务框架中嵌入故障演练中间件，提供依赖自动收集、基础组件故障注入、灵活的爆炸半径控制、丰富的演练场景策略等多种能力，助力业务实现强弱依赖治理，提升系统稳定性。此外，通过丰富的开放接口，平台可实现与各类自动化流程打通，实现演练的自动化、常态化，有效提升演练的效率。</p></blockquote><p><strong>16</strong> <a href="https://www.bilibili.com/read/cv21313074/?from=search&spm_id_from=333.337.0.0"><strong>B站微服务API管理</strong></a></p><blockquote><p>API管理在应用开发的过程中至关重要，B站采用自动生成的方式，通过标准化接口定义，自动采集和生成API文档，从而提高开发效率并减少管理工作。文章总结了B站在API管理方面的经验，阐述API管理对于降低成本和提高效率的关键作用。随着公司规模扩大和接口数量增加，统一的API管理平台能够减少跨部门沟通成本。</p></blockquote><p><strong>17</strong> <a href="https://www.bilibili.com/read/cv22232558/?from=search&spm_id_from=333.337.0.0"><strong>资源隔离技术之内存隔离</strong></a></p><blockquote><p>本文由混部技术的内存隔离问题引入对龙蜥社区开源内核memcg OOM 优先级和memcg后台异步回收特性的分析，并基于相关特性进行了简单的模拟混部测试，结果表明：memcg OOM优先级可以降低在线任务被杀死的概率，优先杀死离线任务，但先祖memcg发生OOM时，对在线任务造成的性能影响仍然无法消除；memcg后台异步回收可以降低在线任务触发直接内存回收的概率，但在线任务<code>Page Cache</code>也被回收，可能对其性能造成一定影响；未来我们将通过不断地实践内存隔离能力在混部场景中的应用，持续发现和解决其中存在的问题，打磨出最适合B站业务混部的内存隔离方案，助力降本增效。</p></blockquote><p><strong>18</strong> <strong><a href="https://www.bilibili.com/read/cv22970825/?from=search&spm_id_from=333.337.0.0">实现亿级费用减省,B站大数据治理之路</a></strong></p><blockquote><p>如今各行各业都开始认同 数据治理 是发挥数据资产价值的必要手段，2020年开始 B站大数据团队 开始实践数据治理，2022年 公司成立了数据委员会 继续发力支持数据治理工作。 本文详细拆解了 团队在2个治理阶段中的 核心问题 与 解题思路，主要包括对如下问题的深度探讨：如何启动数据治理？如何让用户参与配合？如何化被动为主动？</p></blockquote><p><strong>19</strong> <strong><a href="https://www.bilibili.com/read/cv22543150/?from=search&spm_id_from=333.337.0.0">bilibili-AVIF图片格式落地</a></strong></p><blockquote><p>文章介绍了B站在AVIF图片格式落地方面的实践和经验。AVIF是一种开源的图片格式，具有更高的压缩率和更小的文件体积，对于提升网页性能和用户体验具有重要意义。文章详细介绍了B站在AVIF格式落地过程中的技术选型、方案设计、性能测试等方面的考虑，以及在实际应用中遇到的问题和解决方案。通过采用AVIF格式，B站成功地提升了网页加载速度和用户体验，同时也为其他网站提供了有益的参考和借鉴。</p></blockquote><p><strong>20</strong> <a href="https://www.bilibili.com/read/cv21867369/?from=search&spm_id_from=333.337.0.0"><strong>B站流程引擎设计与实践</strong></a></p><blockquote><p>在企业快速发展的档口，如何搭建一套兼容当前IT架构且能适应未来变化的通用业务流程引擎是提升企业运营效率的关键。Comet流程引擎自 2019 年启动研发并发布第一个版本，至今已陆续发布多个正式版本。该系统以其足够的灵活性、通用性和易用性，支撑了B站业务中大量需要借助流程引擎来实现逻辑流转和自动化的场景，跨度从底层基础设施、基础架构到上层各类业务，如各类资源申请、应用发布、推送审核、电子签约、版权评级等等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023-哔哩哔哩技术精选技术干货&quot;&gt;&lt;a href=&quot;#2023-哔哩哔哩技术精选技术干货&quot; class=&quot;headerlink&quot; title=&quot;2023 哔哩哔哩技术精选技术干货&quot;&gt;&lt;/a&gt;2023 哔哩哔哩技术精选技术干货&lt;/h1&gt;&lt;p&gt;作者：哔哩哔哩技术 </summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2023 中国开源开发者报告</title>
    <link href="http://ai.mak.cn/2023/12/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/2023%20%E4%B8%AD%E5%9B%BD%E5%BC%80%E6%BA%90%E5%BC%80%E5%8F%91%E8%80%85%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2023/12/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/2023%20%E4%B8%AD%E5%9B%BD%E5%BC%80%E6%BA%90%E5%BC%80%E5%8F%91%E8%80%85%E6%8A%A5%E5%91%8A/</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2024-02-20T02:56:11.332Z</updated>
    
    <content type="html"><![CDATA[<p>《2023 中国开源开发者报告》正式发布。</p><p><img src="https://p8.itc.cn/q_70/images01/20231230/4281dad4482343a5ab5ff8d45e000974.png" alt="img"></p><p>此报告由开源中国与 Gitee 发布，整体分为三章，分别是：</p><ul><li>第一章《开源开发者事件回顾》</li><li>第二章《2023 LLM 技术报告》</li><li>第三章《&lt;Gitee × OSS Compass&gt; Insight：中国开发者开源新动向》</li></ul><p>开源开发者圈子来看，2023 年是大模型 LLM 年、生成式 AI GenAI 年。</p><p>LLM 领域大放异彩，此报告浓墨重彩地在《2023 LLM 技术报告》中梳理了 2023 年 LLM 的技术行情。报告整体围绕 LLM Tech Map 梳理逻辑来展开，从基础设施、大模型、Agent、AI 编程、工具和平台，以及算力几个方面，为开发者整理了当前 LLM 中最为热门和硬核的技术领域以及相关的软件产品和开源项目。</p><p><img src="https://p1.itc.cn/q_70/images01/20231229/d2cac718b89b4e5e93fb59eec81d34ac.png" alt="img"></p><p><strong>《2023 LLM 技术报告》详情可查看（这是子报告）：</strong><br><strong><a href="https://talk.gitee.com/report/china-open-source-2023-llm-report.pdf?fr=media">https://talk.gitee.com/report/china-open-source-2023-llm-report.pdf?fr=media</a></strong></p><p>除了 LLM，开源开发者圈当然还有更多高亮事件，此次年度报告中整理成了另一篇章《开源开发者事件回顾》，这一篇章梳理成了 9 个大块：</p><ul><li>【AIGC】回顾 2023 大语言模型 LLM 元年的重磅事件。</li><li><strong>【1024 黄金眼】关注 IT 相关民生事件，以老百姓的眼睛看 IT 圈，和开发者零距离接触。</strong></li><li>【项目停更】到了该说 “再见” 的时候了，江湖有缘再见。</li><li><strong>【生产事故】冥场面！速来围观 2023 十大生产事故 “名场面”。</strong></li><li>【开源治理】开源健康发展必不可少的一环。</li><li><strong>【硬核发版】最硬核、最极客的年度发版汇总！</strong></li><li>【热门话题】回顾 2023 年度热门开发者事件！</li><li><strong>【重磅官宣】2023 年度开源官宣。</strong></li><li>【R.I.P.】谨以此篇纪念今年离我们而去的行业巨擘。</li></ul><p>这些事件，作为圈内人的你还有印象吗？</p><p>第三章《&lt;Gitee × OSS Compass&gt; Insight：中国开发者开源新动向》中，采用 Gitee 与 OSS Compass 作为数据来源，试图通过数据来反映 2023 年开源开发者圈子的相关情况。亮点数据：</p><ul><li>TypeScript 是增长最快的编程语言，增长率达到 49.04%</li><li>MulanPSL-2.0 在 “2023 年使用增长率最快的开源许可证” 中排行第二，增长率为 18.34%</li><li>较为活跃的社区代表：OpenHarmony、openEuler 与 MindSpore</li></ul><p><strong>详情请查看完整报告：</strong><br><strong><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=media">https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=media</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《2023 中国开源开发者报告》正式发布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p8.itc.cn/q_70/images01/20231230/4281dad4482343a5ab5ff8d45e000974.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;此</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>系统性能指标规范</title>
    <link href="http://ai.mak.cn/2023/11/23/%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2023/11/23/%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%A7%84%E8%8C%83/</id>
    <published>2023-11-22T16:00:00.000Z</published>
    <updated>2024-02-18T06:45:32.894Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>系统界面操作反应时间要求：</strong><ul><li>用户界面操作应在2秒以内响应，确保用户体验流畅。</li><li>针对复杂操作或数据加载，允许最长5秒的等待时间。</li><li>超过5秒的操作，采用异步交互设计。</li></ul></li><li><strong>系统最大承载容量：</strong><ul><li>平台应支持同时管理xxx千万台网络设备。</li><li>平台设计容量应考虑未来扩展，确保在硬件升级的情况下能够支持更大规模的网元管理。</li></ul></li><li><strong>并发性要求：</strong><ul><li>平台应支持最少1000个并发用户会话。</li><li>同时，平台应具备处理至少10,000个并发操作的能力，以保证多用户&#x2F;多系统同时执行任务时系统稳定性。</li></ul></li><li><strong>程序异常恢复时间要求：</strong><ul><li>系统应在出现异常情况时自动触发故障恢复机制，按照故障等级，确保在30分钟内恢复正常状态。</li><li>异常恢复过程中，系统应记录详细的日志，以便进行故障分析和改进。</li></ul></li><li><strong>日志记录与管理：</strong><ul><li>平台应具备完善的日志记录功能，记录所有关键操作和异常情况。</li><li>日志存储时间不少于60天，且支持日志的检索与导出功能。</li></ul></li><li><strong>安全性能指标：</strong><ul><li>平台应具备防护措施，确保对恶意攻击和未授权访问的及时响应。</li><li>安全审计功能应记录所有敏感操作，并在检测到异常行为时触发告警。</li></ul></li><li><strong>系统可用性要求：</strong><ul><li>平台应实现99.99%的系统可用性，包括计划维护期内的可用性。</li><li>系统升级和维护应在低峰时段进行，最小化对用户的影响。</li></ul></li><li><strong>性能监控与调优：</strong><ul><li>平台应提供性能监控工具，用于实时监测系统各项指标。</li><li>周期性进行性能调优，确保系统在长时间运行中依然保持高性能状态。</li></ul></li><li><strong>用户培训与支持：</strong><ul><li>提供详尽的用户手册和培训材料，以帮助用户更好地了解和使用系统。</li><li>设立专业技术支持团队，及时响应用户的问题和反馈。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;系统界面操作反应时间要求：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;用户界面操作应在2秒以内响应，确保用户体验流畅。&lt;/li&gt;
&lt;li&gt;针对复杂操作或数据加载，允许最长5秒的等待时间。&lt;/li&gt;
&lt;li&gt;超过5秒的操作，采用异步交互设计。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="运维" scheme="http://ai.mak.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>得到精选｜运动的杠杆：真正有效的锻炼方法是什么</title>
    <link href="http://ai.mak.cn/2023/10/16/%E6%9D%82%E8%AE%B0/%E8%BF%90%E5%8A%A8%E7%9A%84%E6%9D%A0%E6%9D%86%EF%BC%9A%E7%9C%9F%E6%AD%A3%E6%9C%89%E6%95%88%E7%9A%84%E9%94%BB%E7%82%BC%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://ai.mak.cn/2023/10/16/%E6%9D%82%E8%AE%B0/%E8%BF%90%E5%8A%A8%E7%9A%84%E6%9D%A0%E6%9D%86%EF%BC%9A%E7%9C%9F%E6%AD%A3%E6%9C%89%E6%95%88%E7%9A%84%E9%94%BB%E7%82%BC%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2023-10-15T16:00:00.000Z</published>
    <updated>2023-10-23T03:15:44.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>节选自：得到精选｜运动的杠杆：真正有效的锻炼方法是什么</p></blockquote><p>咱们继续讲彼得·阿提亚的《超预期寿命》这本书。前面我们已经介绍了导致现代人衰老和死亡最重要的四种原因 —— 代谢障碍、心血管疾病、癌症和神经退行性疾病 —— 这“四骑士”的机制，这一讲开始我们来说应对方法。</p><p>阿提亚把应对策略分为五个方面：运动、营养、睡眠、情绪和药物，其中药物都是穿插提到，我们重点说前四个方面。</p><p>有个笑话说，如果我知道我将来会死在哪里，我只要确保不去那个地方就行了。这个思路其实是有用的。如果我们知道自己最有可能死亡的原因，而且这个原因碰巧又可以用比较微小的代价避免，那这就是一个杠杆，你就很值得去做一点事情避免那个情况。</p><p>幸运的是，确实存在这样的杠杆。</p><p>比如说，每年都有很多人死于车祸，通常大家认为车祸的原因有超速、酒后驾车、开车注意力不集中等等，这些对我们的帮助不是很大，因为你防不胜防。但是有一个数据，却是特别有用。</p><p>有相当高比例的车祸死亡事故，是发生在交叉路口。</p><p>你正常开车驶过一个路口，你的前方是绿灯，你没毛病。可是跟你交叉的路上有个司机闯红灯，正好从左侧撞到你的车上……遇到这种情况你特别容易死。</p><p>但这种情况也特别容易避免。只要你每次过路口的时候，哪怕自己是绿灯，也先往左边看一眼，确保那边的车都停下了你再过。这是一个非常小的动作，但是它能让你避免一种非常常见的交通意外死亡。四两拨千斤，这就是杠杆。所以这就是你必须做的事情。</p><p>同样道理，我们不可能把所有时间都花在长寿上，这里面也需要杠杆。如果花20%的时间就能起到80%的作用，那就应该优先做好那20%。</p><p>而对长寿来说，最重要的杠杆就是我们这一讲要说的运动。<strong>运动是对健康和寿命最有效的干预，比任何药物、任何其他干预措施都有效。</strong></p><p>而且哪怕你每天只做一点运动，就比完全不运动要好得多。研究表明每周90分钟的运动量 —— 也就是每天十几分钟 —— 就能把各种原因导致的死亡风险降低14%：你很难找到这么有效的药物。这就是你最值得做的事情。</p><p>而且运动之中还有运动的杠杆。<strong>我们最应该关心的是三个指标：心肺功能、肌肉力量和稳定性。</strong></p><p>✵</p><p>在讲这三个指标之前，咱们先说一种最基本的运动，也是我们专栏之前讲丹尼尔·利伯曼的《锻炼》那本书时提到过的，叫做「中等强度有氧运动」。阿提亚把它称之为「第二区」运动，这是一般健身教练根据运动强度进行的分区，第二区是强度比较弱但不是散步那种最弱的，是大约介于快走和慢跑之间。</p><p>你快走、慢跑、游泳或者骑自行车都可以，要点是在做这个运动的时候你可以说完整的句子，但是说话感觉有点费力。你的心率大约是你最高心率的70%-85%。</p><p>这个运动本身并不费力，你甚至觉得挺轻松，可以坚持很长时间。初学者只要快走就能进入第二区，有运动基础的可能得比如用跑步机走个上坡，都比较容易。中等强度有氧运动锻炼的是所谓「1型肌肉纤维」，也就是慢肌腱，适合慢节奏、高耐力的动作，长时间使用也不会疲劳。</p><p>从利伯曼和阿提亚这两本书看来，现在学界已经形成共识，这个中等强度有氧运动，就是一切锻炼的根本。如果你只能练一门功夫，练这个就对了。</p><p>中等强度有氧不仅有利于减肥，而且有利于身体的综合健康，它给做其他任何事情提供了耐力基础。</p><p>其中一个重要作用是改善线粒体。线粒体是帮助细胞产生能量的一种物质，它能燃烧葡萄糖和脂肪。衰老最显著的特征就是线粒体的数量和质量在下降。中等强度有氧运动能刺激细胞产生更有效的线粒体。线粒体健康，身体代谢葡萄糖和脂肪的能力就强，尤其是能代谢更多的脂肪 —— 这就是为什么中等强度有氧运动最有利于减肥，也最能有效控制1型和2型糖尿病。</p><p>中等强度有氧的强度又不高，方法又随意，那么关键就是得保证运动时间。如果年龄比较大或是刚刚开始训练，每周两次、每次30分钟就大有助益。如果你有一定的运动基础，每周4次、每次45分钟效果更好。</p><p>而且这种运动还对大脑有好处。我们专栏前面讲过散步对大脑思维的好处，阿提亚这里则是特别强调二区运动能增加大脑的血流量，而这有助于预防阿尔茨海默症、提升认知能力。</p><p>这样说来，每天快走几十分钟，一边走一边听听得到什么的，就是你最重要的长寿杠杆。</p><p>在这个基础之上，我们需要优化三项指标。</p><p>✵</p><p><strong>第一个是心肺功能指标，叫做「最大摄氧量（VO2 Max）」</strong>。它的意思是你每公斤体重每分钟可以消耗的最大氧气量。这个数值越大越好。</p><p>人在静止不动的情况下消耗的氧气是最少的，运动强度越高需要的氧气流量就越大，但是每个人都有个极限值，这就是最大摄氧量。有些医院和健身中心能帮你测量最大摄氧量，一般是在跑步机上带着面罩猛跑。</p><p>阿提亚说，最大摄氧量也许是唯一最有力的长寿标志。最大摄氧量高说明心肺功能强。什么叫身体好？这就叫身体好。</p><p>最大摄氧量越低，各种疾病的死亡率就越高。统计表明心肺功能差的坏处比吸烟、糖尿病、癌症和心脏病的坏处都要大。而且最大摄氧量给人带来的好处是没有上限的，也就是说哪怕你的心肺功能已经很好，你也还是可以继续锻炼提高，它会让你更好。</p><p>中等强度有氧运动也能在一定程度上提高最大摄氧量，但是为了更有效，你最好上高强度的有氧训练。这是一种间歇式的训练，快跑、骑自行车和用划船机都可以。比如你可以以接近冲刺的速度快跑4分钟，然后慢走4分钟，然后再快跑再慢走，这样重复四到六次。</p><p>阿提亚建议刚刚开始锻炼的人先专门练习五、六个月的中等强度有氧，完了再加入最大摄氧量训练。这种高强度有氧每周搞个一两次就可以了。但是请注意，老年人，不要把年老体弱当借口，也应该做这个训练，因为也有好处。</p><p>✵</p><p><strong>第二个指标是肌肉力量</strong>。前面说的中等强度有氧练的都是1型肌肉纤维，但是你还需要锻炼2型肌肉纤维，也就是能快速抽动、让你“有劲儿”的肌肉。</p><p>简单说，就是你的负重能力和握力有多强 —— 你能不能双手各提一个大箱子走一段路。锻炼肌肉力量的最直接方法是举重。</p><p>我知道纳西姆·塔勒布特别喜欢举重。不过他练得可能有点不得法，经常受伤。</p><p>锻炼肌肉也对线粒体也有好处，而且有的研究认为肌肉力量比心肺功能还要重要。</p><p>衰老的一个显著标志就是力量下降。一般人在65岁以后肌肉质量会急剧下降，到75岁以后下降幅度会更大，而且肌肉的萎缩是难以恢复的。如果一个人本来身体挺健康，因为摔伤了、骨折了，卧床不起，一段时间之后他的肌肉就会萎缩。他起来之后再怎么锻炼，也难以达到之前的水平。</p><p>肌肉之外还有一个重要指标是骨密度，也可以通过力量训练提高，但是可能需要辅助营养和药物，咱们就不细说了。</p><p>✵</p><p><strong>第三个指标是稳定性</strong>。稳定性的作用是让你不受伤。</p><p>很多老年人之所以不锻炼，各种活动都下降，并不是因为身体的自然衰老，也不是因为不愿意锻炼 —— 而是因为他有伤。你未必能想象到，45岁以上的美国人中有超过27%的人患有慢性疼痛，有10%到12%人表示在过去六个月中，疼痛在“大多数日子或每天”限制了他们的活动。</p><p>他们之所以受伤，是因为不能很好地控制自己的身体。老年人意外死亡最重要的原因，就是跌倒。跌倒可能让人直接死亡，也可能只是骨折。骨折后的生命质量会很差，因为你不能动；然后就是肌肉萎缩，在无奈和疼痛中缓慢地走向死亡。</p><p>所以人到了一定年龄，避免受伤是第一位的。</p><p>要想不受伤，你就需要比较强的稳定能力。这是一种下意识地驾驭力量的能力：该减速能减速，该停止能停止，面对外部刺激能迅速做一个调整，任何情况下都能尽量让身体保持稳定。</p><p>具体的训练方法你可能得找健身教练。阿提亚笼统地讲了一些，包括什么呼吸练习、双脚的平衡、脊柱等等。一个简单方法是上台阶：找一个特别结实的箱子放在你面前，它的高度是你抬腿上去的时候大腿正好跟地面平行，就这样你上去再下来。</p><p>我听说过的一个测量稳定性的方法是双手叉腰单腿站立 ——</p><p>四十多岁的人的标准是闭眼单腿站立7秒钟，睁眼40秒钟；七十多岁则是闭眼2秒钟，睁眼18秒。更详细的标准见下表 ——</p><p>达不到标准，就意味着容易跌倒受伤。</p><p>✵</p><p>这一讲我们说了四种锻炼方法 ——</p><p>\1. 中等强度有氧运动，这是一切锻炼的基础，也是最简单最容易做到的，也是好处最大的。每天出去快走一圈就可以；</p><p>\2. 高强度有氧，用于提升心肺功能。它需要的时间短，但是强度大；</p><p>\3. 力量训练，用于保持肌肉。主要训练方法是负重。力量跟长寿也很有关系，但它更重要的作用是保证你的生命质量：你希望一直都有劲儿；</p><p>\4. 稳定性训练，则是为了保证安全，避免受伤。</p><p>你说这四种锻炼有啥不一般的吗？其实这就是对人最自然的要求：你需要经常运动，偶尔快速运动，你需要有劲儿，你需要一定的稳定性。你只是在这个不正常的现代环境中寻求做个正常人而已。</p><p>我认为这一讲的一个重要认知是<strong>具体的训练方法不重要，重要的是强度，是你在针对哪个指标进行训练。</strong>快走、跑步、游泳、自行车、划船机、椭圆机、举重、搬运箱子，你干什么都可以，只要别受伤就行。</p><p>你完全不需要、也不应该参加那种跟一大帮人用四肢在大街上爬行的怪异运动。简单点更不容易受伤，也不尴尬。</p><p>阿提亚本人是个锻炼狂人。除了我们说的这些他还练习过拳击之类的项目，而且强度非常高，都是专业水平。我从全书的逻辑分析，花那么多时间锻炼应该是不必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;节选自：得到精选｜运动的杠杆：真正有效的锻炼方法是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们继续讲彼得·阿提亚的《超预期寿命》这本书。前面我们已经介绍了导致现代人衰老和死亡最重要的四种原因 —— 代谢障碍、心血管疾病、癌症和神经退行性疾病</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>运营商的网络架构</title>
    <link href="http://ai.mak.cn/2023/10/08/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://ai.mak.cn/2023/10/08/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2023-10-07T16:00:00.000Z</published>
    <updated>2023-10-08T07:14:41.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.jx-ev.com/info/4004.html">转载自</a></p></blockquote><h2 id="本文目录一览："><a href="#本文目录一览：" class="headerlink" title="本文目录一览："></a>本文目录一览：</h2><ul><li>1、<a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%EF%BC%9F">什么是网络架构？</a></li><li>2、<a href="#NSA%E5%92%8CSA%E7%BD%91%E7%BB%9C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB?">NSA和SA网络有什么区别？</a></li><li>3、<a href="#%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%81%94%E9%80%9A%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86">移动网络与联通构造原理</a></li><li>4、<a href="#%E4%B8%89%E5%A4%A7%E8%BF%90%E8%90%A5%E5%95%86%EF%BC%88%E7%A7%BB%E5%8A%A8%E3%80%81%E7%94%B5%E4%BF%A1%E3%80%81%E8%81%94%E9%80%9A%EF%BC%89%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90">三大运营商（移动、电信、联通）的组织架构解析</a></li><li>5、<a href="#%E7%94%B5%E4%BF%A1%E8%BF%90%E8%90%A5%E5%95%86%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1">电信运营商的网络层次</a></li></ul><h2 id="什么是网络架构？"><a href="#什么是网络架构？" class="headerlink" title="什么是网络架构？"></a>什么是网络架构？</h2><p>网络架构是进行通信连接的一种网络结构。</p><p>网络架构是为设计、构建和管理一个通信网络提供一个构架和技术基础的蓝图。网络构架定义了数据网络通信系统的每个方面，包括但不限于用户使用的接口类型、使用的网络协议和可能使用的网络布线的类型。</p><p>网络架构典型的有一个分层结构。分层是一种现代的网络设计原理，它将通信任务划分成很多更小的部分，每个部分完成一个特定的子任务和用小数量良好定义的方式与其它部分相结合。</p><p>扩展资料：</p><p>使用网络架构注意事项：</p><p>1、动态多路径</p><p>能够通过多个WAN链路对流量进行负载均衡并不是一项新功能。但是，在传统的WAN中，此功能很难配置，并且通常以静态方式将流量分配给给定的WAN链路。即使面对诸如拥塞链路之类的负面拥塞，也不能改变给定WAN链路的流量分配。</p><p>2、应用程序级别</p><p>如果应用程序的性能开始下降，因为该应用程序使用的托管虚拟化网络功能（VNF）的物理服务器的CPU利用率过高，则VNF可能会移动到利用率较低的服务器中。</p><p>3、能见度</p><p>有许多工具声称可以为网络组织提供对传统WAN的完全可见性，以便解决与网络和&#x2F;或应用程序性能相关的问题。但是，无论是这些工具的缺陷还是网络组织使用的故障排除流程，采用新的WAN架构将使故障排除任务变得更加复杂。</p><p>参考资料来源：百度百科：LTE网络架构</p><h2 id="NSA和SA网络有什么区别？"><a href="#NSA和SA网络有什么区别？" class="headerlink" title="NSA和SA网络有什么区别？"></a>NSA和SA网络有什么区别？</h2><p>1、核心不同：</p><p>NSA新建5G基站，采用4G核心网或新建5G核心网；SA新建5G基站和5G核心网。</p><p>2、运营商不同：</p><p>从运营商的角度来说，NSA（非独立组网）可以看做是5G初期的一种过渡方案，而SA（独立组网）才是5G的完全体。</p><p>由于NSA组网需要4G、5G公用核心网，因此这种方式将不能支持5G低时延的特性。随着5G网络的建设，绝大多数运营商都将逐渐转向SA组网，或采用SA&#x2F;NSA混合组网的方式。</p><p>3、网络架构不同：</p><p>NSA是融合现在4G基站和网络架构部署的5G网络。因此，其建设速度非常快，直接利用4G基站加装5G基站。</p><p>即可实现5G网络覆盖。但由于架构使用的还是4G网络架构，导致5G网络的海量物联网接入和低时延特性无法发挥。而SA组网被称为独立组网。换言之就是重新建设5G基站和后端5G网络，从而完全实现5G网络的所有特性和功能。</p><h2 id="移动网络与联通构造原理"><a href="#移动网络与联通构造原理" class="headerlink" title="移动网络与联通构造原理"></a>移动网络与联通构造原理</h2><p>移动网络和联通网络构造原理都属于移动通信网络体系架构：网络架构，该架构可分为三大模块：网络部署场景、接入网和核心网。</p><p>具体的构造原理和试验如下：</p><p>3.1.1中国移动黑龙江公司网络部署场景设计方案</p><p>1.室外借助分布式天线（distributedantennasystem，DAS）和大规模MIMO（multipleinputmulti-pleoutput）配备基站，天线元件分散放置在小区，且通过光纤与基站连接。移动事物（如终端）部署Mo-bileFemtocell，可以动态地改变其到运营商核心网络的连接。同时，部署虚拟蜂窝作为宏蜂窝的补充，提升了室外覆盖率。</p><p>2.室内用户需要与安装在室外建筑的大型天线阵列的室内AP进行通信，这样就可以利用多种适用于短距离通信的技术实现高速率传输，比如60GHz毫米波通信，可以解决频谱稀缺问题。</p><p>3.1.2 中国移动黑龙江公司接入网设计方案</p><p>5G通信网络接入网部署中，采用新型的分布式基站进行组网把宏基站的部分载波通过标准的CPRI接口拉远实现分布式组网，也就是将传统基站的基带处理部分（BBU）和射频收发信机部分（RRU）设计成单独的模块。分布式基站不仅带来快速、便捷的网络部署，而且有利于大幅降低运营商建网的成本。由于无线频谱资源的高价格、高频通信技术的使用，使原有基站覆盖密度越来越大，因此必须对无线接入侧的网络做相应的调整，才能保证5G网络下的无线带宽及物联需求的应用。</p><p>CoP(CPRI over Packet)承载技术是承接5G通信网络接入网中的研究和部署重点。为满足业务需求和基站承载，需要建立一种新的承载技术架构来满足云通信的需求，现通过以下几点方案进行接入网部署：</p><p>在RRU增加的情况下使其满足免机房需要，新的CoP FO 设备能跟RRU供址部署，建立成一个新的前传网络（Fronthanl）,通过CoP FO 设备将RRU进行汇聚传给接入侧的A设备。该方式针对现有IP RAN设备基本无需改动，只需要在原有的设备中插入带有CRPI协议的新增板卡就可以工作。</p><p>对于Fronthanl接入侧的保护机制有CPRI接口和ETH接口；网络侧保护机制可以采用线性“1+1”保护或环网Wrapping、Steering保护。</p><p>对于无线侧RRU的接入点模块FO是全室外模式，易部署、省机房，满足于大网络容量要求。</p><p>在组网类型上，优先选用环型拓扑结构，可以实现RRU任意的部署，实现接入设备A无源CWDM解决方案。</p><p>3.1.2 中国移动黑龙江公司核心网设计方案</p><p>1.现有核心网网元由传统平台向云平台演进</p><p>（1）RCS在互联网基地部署应用，IMS AS、CSCF&#x2F;BGCF等网元进行技术试点；</p><p>（2）控制类网元（MME、PCRF）、数据类网元（HSS、HLR）、信令转接网元（DRA）等正在研究设计阶段，成熟后马上推动现网引入；</p><p>（3）媒体转发面网元（MGW&#x2F;SBC）,根据SDN技术进行进行部署；</p><p>（4）2G、3G电路域相关网元正逐步融合、替换和退网，不再考虑运化升级。</p><p>构建以DC为中心的网络云化平台，部署基于云化架构的NFV（网络功能虚拟化），引入跨DC部署与无状态设计，并将传统核心网业务搬迁至此云化平台；</p><p>2.控制面网元功能重构</p><p>（1）业务处理节点：承接传统核心网GW&#x2F;SBC等媒体接入处理类网元的功能；</p><p>（2）融合控制接节点：承接传统核心网MME&#x2F;CSCF&#x2F;HSS等管理控制类网元和HSS的等用户数据类网元的功能；</p><p>（3）业务能力节点：承接传统核心网应用服务AS&#x2F;业务平台类网元的功能层次，同时支持提供网络能力开放和网络拓扑设置功能。</p><p>3.引入C&#x2F;U分离，并利用MEC技术构建分布式网络，保障低时延业务应用。</p><p>4.引入SBA架构、网络切片Slicing、接入无关技术Access Agnostic，为各式各样差异化需求提供on demand服务，以支撑5G业务。</p><p>3.2 5G关键技术</p><p>3.2.1 CoP(CPRI over Packet)承载技术</p><p>CoP承载技术是集成前传承载和后传承载的中心枢纽模块，采用的是高效装载技术，其由于CRPI结构化和非结构化是的数据成帧灵活，便于整个网络调节，采用光承载，继承了原有波分承载的有点，也能进一步节省传输光缆。CPRI over Packet的NGFI承载方案，具体对比指标比较如下:</p><p>3.2.2 网络功能虚拟化（net-workfunctionvirtualization，NFV）</p><p>NFV（网络功能虚拟化）利用软硬件解耦及功能抽象，以虚拟化技术降低昂贵的设备成本费，根据业务需求进行自动部署、弹性伸缩、故障隔离等步骤，让运营商可通过此极速将承载各种网络功能的通用硬件与云计算虚拟化技术相结合，实现网元虚拟化和虚拟网络可编程，简化网络升级的步骤和降低购买新专用网络硬件的成本，把网络技术重点放到部署新的网络软件上。</p><p>3.2.3 基于OFDM优化的波形和多址接入</p><p>5G NR设计过程中最重要的一项决定，就是采用基于OFDM优化的波形和多址接入技术，因为OFDM 技术被当今的 4G LTE 和 Wi-Fi 系统广泛采用，因其可扩展至大带宽应用，而具有高频谱效率和较低的数据复杂性，因此能够很好地满足 5G 要求。 OFDM 技术家族可实现多种增强功能，例如通过加窗或滤波增强频率本地化、在不同用户与服务间提高多路传输效率，以及创建单载波 OFDM 波形，实现高能效上行链路传输。</p><p>不过OFDM体系也需要创新改造，才能满足5G的需求：</p><p>\1. 通过子载波间隔扩展实现可扩展的OFDM参数配置；</p><p>\2. 通过OFDM加窗提高多路传输效率。</p><p>3.2.4 灵活的框架设计</p><p>5G NR灵活的框架设计：</p><p>\1. 可扩展的时间间隔（Scalable Transmission Time Interval (TTI)）</p><p>相比当前的 4G LTE网络，5G NR将使时延降低一个数量级。目前LTE网络中，TTI（时间间隔）固定在1 ms（毫秒）。为此，3GPP在4G演进的过程中提出一个降低时延的项目。尽管技术细节还不得而知，但这一项目的规划目标就是要将一次傅里叶变换的时延降低为目前的1&#x2F;8（即从1.14ms降低至143µs（微秒）。</p><p>\2. 自包含集成子帧（Self-contained integrated subframe）</p><p>自包含集成子帧是另一项关键技术，对降低时延、向前兼容和其他一系列5G特性意义重大。通过把数据的传输（transmission）和确认（acknowledgement）包含在一个子帧内，时延可显著降低。</p><p>\3. 先进的新型无线技术（Advanced wireless technologies）</p><p>5G必然是在充分利用现有技术的基础之上，充分创新才能实现的，而4G LTE正是目前最先进的移动网络平台，5G在演进的同时，LTE本身也还在不断进化（比如最近实现的千兆级4G+），5G不可避免地要利用目前用在4G LTE上的先进技术，如载波聚合，MIMO技术，非共享频谱的利用等等。</p><p>大规模MIMO：</p><p>MIMO（Multiple-Input Multiple-Output）技术是目前无线通信领域的一个重要创新研究项目，通过智能使用多根天线（设备端或基站端），发射或接受更多的信号空间流，能显著提高信道容量；而通过智能波束成型，将射频的能量集中在一个方向上，可以提高信号的覆盖范围。</p><p>毫米波：</p><p>全新 5G 技术正首次将频率大于 24 GHz 以上频段（通常称为毫米波）应用于移动宽带通信。大量可用的高频段频谱可提供极致数据传输速度和容量，这将重塑移动体验。但毫米波的利用并非易事，使用毫米波频段传输更容易造成路径受阻与损耗（信号衍射能力有限）。通常情况下，毫米波频段传输的信号甚至无法穿透墙体，此外，它还面临着波形和能量消耗等问题。</p><h2 id="三大运营商（移动、电信、联通）的组织架构解析"><a href="#三大运营商（移动、电信、联通）的组织架构解析" class="headerlink" title="三大运营商（移动、电信、联通）的组织架构解析"></a>三大运营商（移动、电信、联通）的组织架构解析</h2><p>1949年11月1日，国家宣布成立邮电部，中国的邮政和电信业务都被邮电部垄断。</p><p>自此至1973年期间，邮电部，邮政和电信经历多次分离、合并。</p><p>1994年7月19日，由电子部、电力部、铁道部等15家单位出资，成立了中国联合通讯有限公司。</p><p>1997年，邮电部做出在全国实施“邮电分营”的决定。同年，从邮电部分离出来的电信在纽约和香港成功上市。</p><p>2000年4月20日，中国移动通信集团公司正式成立，负责原中国电信的移动通信网络业务。</p><p>自2001年开始，国内电信业又开始了新一轮的重组，原来的卫通、铁通、网通、吉通这几家不断被兼并，最终变成了现在的移动、电信、联通三家全业务牌照运营商共存的状态。</p><p>了解完中国运营商的发展史后，大家应该都清楚了现在的三大运营商都是国资委下面的国企。</p><p>而每年暑假开始，各家运营商都会陆续开展校园招聘，以中国电信2021年春季招聘为例，招聘单位包含公司总部、全国各省公司以及各控股子公司等，分布在全国各地。之前主要由各省公司和省级子公司统一组织，近几年逐渐将招聘下放到各个地市公司。</p><p>而招聘的岗位分类和专业要求举例如下：</p><p>一般而言，招聘面向的是当年应届的国内外普通高等院校毕业的本科生和硕士，总部部门和研究院会有少量研究岗位面向博士，同时有些公司在招聘公告上也会对学校、英语、计算机等提出相应的要求。</p><p>自从2009年我国正式进入3G时代开始，就开始了中国移动、中国电信和中国联通三家运营商三分天下的格局。 随着技术的发展，除了固话、移动电话、短信、宽带等这些传统业务，运营商近些年也开始在云业务、视频业务、IT系统等新业务上发力，组织架构也随之更新。</p><p>运营商都属于重资产的国有企业，均为 集团总公司 —— 各省公司（包括同级子公司和分支机构） —— 各市公司 —— 各县公司 的架构模式，主要以地域划分，同时兼顾业务分类。例如，集团总部统筹管理全国多个省份公司，其部门和某个省公司部门的大致对应关系图如下：</p><p>举一些具体业务部门的例子来说。</p><p>市场口和客服口的相关部门：</p><p>市场部：负责各类市场政策制定和策划安排</p><p>政企客户部：针对政府、企业、商业场所等大客户提供解决方案和营销</p><p>公众客户部：针对公众客户进行市场营销，拓展家庭和个人客户市场</p><p>客服&#x2F;用户调度中心：主要负责各类客户的售后服务、以及部分售前咨询、售中业务变更等</p><p>建设维护口的部门：</p><p>负责网络规划、设备采购、建设，以及有线&#x2F;无线网络的维护、优化，保障网络平稳高效运行</p><p>信息化口的部门：</p><p>负责IT系统（BSS、OSS、MSS、EDW）的运营维护</p><p>管控相关部门：</p><p>人事、行政、法律、财务等行政管理部门</p><p>具体到三家运营商目前的组织架构划分情况来看：</p><p>一、其中目前体量最大的 中国移动： 中国移动全资拥有中国移动（香港）集团有限公司，由其控股的中国移动有限公司在国内31个省（自治区、直辖市）和香港设立全资子公司，并在香港和纽约上市。</p><p>二、 中国电信集团公司： 总部拥有22个职能部门；管辖有31个省级子分公司；另有中电信欧洲公司、澳门公司、股份公司、通信服公司、信元公司、中英海底光缆公司等。另外还包括其它一些参股公司、三产公司、物业公司等。</p><p>中国电信2005年将组织结构转变成平衡独立的前端和后端结构：前端部门包括政企客户、家庭客户以及个人客户部门；而后端部门包括其他支持和行政单位。</p><p>三、 中国联合网络通信集团有限公司： 现在的联通于2009年1月6日由原中国网通和原中国联通合并重组而成，公司在国内31个省（自治区、直辖市）和境外多个国家和地区设有分支机构。</p><p>中国联通作为第一家央企集团层面的“混改”试点企业，混改成效众说纷纭，同时在5G时代，和电信共建共享的战略成效也有待时间的检验。</p><h2 id="电信运营商的网络层次"><a href="#电信运营商的网络层次" class="headerlink" title="电信运营商的网络层次"></a>电信运营商的网络层次</h2><p>现在网络分七层分别为</p><p><strong>物理层</strong> 为数据链路层提供物理连接，在其上串行传送比特流，即所传送数据的单位是比特。此外，该层中还具有确定连接设备的电气特性和物理特性等功能。</p><p><strong>数据链路层</strong> 负责在网络节点间的线路上通过检测、流量控制和重发等手段，无差错地传送以帧为单位的数据。为做到这一点，在每一帧中必须同时带有同步、地址、差错控制及流量控制等控制信息。</p><p><strong>网络层</strong> 为了将数据分组从源（源端系统）送到目的地（目标端系统），网络层的任务就是选择合适的路由和交换节点，使源的传输层传下来的分组信息能够正确无误地按照地址找到目的地，并交付给相应的传输层，即完成网络的寻址功能。</p><p><strong>传输层</strong> 传输层是高低层之间衔接的接口层。数据传输的单位是报文，当报文较长时将它分割成若干分组,然后交给网络层进行传输。传输层是计算机网络协议分层中的最关键一层，该层以上各层将不再管理信息传输问题。</p><p><strong>会话层</strong> 该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。</p><p><strong>表示层</strong> 该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。</p><p><strong>应用层</strong> 该层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jx-ev.com/info/4004.html&quot;&gt;转载自&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本文目录一览：&quot;&gt;&lt;a href=&quot;#本文目录一览：&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="网络" scheme="http://ai.mak.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开源系统监控工具简介</title>
    <link href="http://ai.mak.cn/2023/10/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BC%80%E6%BA%90%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B/"/>
    <id>http://ai.mak.cn/2023/10/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BC%80%E6%BA%90%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B/</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2024-01-05T09:31:33.849Z</updated>
    
    <content type="html"><![CDATA[<p>通过跟踪监控服务器的性能、网络流量、应用程序性能以及用户体验情况，可帮助我们更好地了解整个IT环境运行状态，为系统运维、调优提供支撑。掌握一些好的监控工具可以为我们更好地跟踪服务器状态，持续优化系统提供最佳解决方案。</p><p>本文主要列举了一些目前应用最好的开源免费系统监控工具。</p><h3 id="01-Nagios"><a href="#01-Nagios" class="headerlink" title="01 Nagios"></a>01 Nagios</h3><p><a href="https://www.nagios.org/">https://www.nagios.org/</a></p><blockquote><p>Nagios一个强大的开源工具，用于监控系统、网络和基础设施。它是监控工具的鼻祖，它的历史可以追溯到1999年。这个强大的开源工具提供了包括对系统、网络和基础设施的监控。Nagios可以持续监控服务器，跟踪服务器存在的潜在问题，在潜在问题转变成为严重问题之前及时提醒运维人员。Nagios的主要优势在于它的可扩展插件库和个性化定制能力，Nagios的插件库可以显著扩展工具的功能。但是，Nagios的学习曲线有些陡峭，对于初学者来说可能是一个缺点。</p></blockquote><h3 id="02-Zabbix"><a href="#02-Zabbix" class="headerlink" title="02 Zabbix"></a>02 Zabbix</h3><p><a href="https://www.zabbix.com/">https://www.zabbix.com</a></p><blockquote><p>Zabbix是另一个流行的开源监控解决方案，可以用于监控网络、服务器、应用程序等。该工具功能强大，可以有效地管理复杂网络，让运维人员能够详细了解和控制整个基础设施的性能。虽然Zabbix的整个界面不够简练，但Zabbix强大的模板功能可以用来简化整个监控设置。</p></blockquote><h3 id="03-Prometheus"><a href="#03-Prometheus" class="headerlink" title="03 Prometheus"></a>03 Prometheus</h3><p><a href="https://prometheus.io/">https://prometheus.io/</a></p><blockquote><p>Prometheus是一个基于时间序列数据库的开源监控系统，专门用于监控大规模的微服务和容器。特别适合在Kubernetes环境中收集各类运行指标并提供报告，这个工具是云原生体系的最爱。</p></blockquote><p>另外，可以通过集成Grafana，提高Prometheus的可视化能力。</p><h3 id="04-Grafana"><a href="#04-Grafana" class="headerlink" title="04 Grafana"></a>04 Grafana</h3><blockquote><p>Grafana是一个支持多平台、可分析、可视化的开源平台，经常与Prometheus等监控工具结合使用。它支持基于监控数据创建美观、直观的仪表盘。<br>  Grafana可以将应用服务器的响应时间、并发数、CPU指标、内存指标等监控数据转化为可视化图表，使运维人员更容易掌握运行趋势或者系统问题。</p></blockquote><h3 id="05-Netdata"><a href="#05-Netdata" class="headerlink" title="05 Netdata"></a>05 Netdata</h3><p><a href="https://www.netdata.cloud/">https://www.netdata.cloud/</a></p><blockquote><p>LNetdata是一个用于实时监控系统和应用程序的性能和运行状况的轻量级开源监控工具。它可以在各种系统上运行，并且它的前端WEB页面的易用性也很好。<br> Netdata可以提供有关服务器的磁盘I&#x2F;O、CPU使用率、RAM使用率和网络带宽的分析。</p></blockquote><h3 id="06-ELK-Stack"><a href="#06-ELK-Stack" class="headerlink" title="06 ELK Stack"></a>06 ELK Stack</h3><blockquote><p>ELK Stack是一组工具，用于分析结构化或非结构化数据。ELK Stack结合了Elasticsearch、Logstash和Kibana三种开源工具，可以在大部分类型的结构化或非结构化数据中进行实时检索并分析，并提供分析报告。目前广泛用于系统运行日志和事件数据分析。<br> 在微服务体系架构中，ELK Stack可以从每个微服务中收集日志，分析数据，并以易于理解的形式进行呈现。但ELK整体运行比较消耗资源，因此建议定期调整ELK配置，以避免浪费资源。</p></blockquote><h3 id="07-Icinga"><a href="#07-Icinga" class="headerlink" title="07 Icinga"></a>07 Icinga</h3><p><a href="https://icinga.com/">https://icinga.com/</a></p><blockquote><p>Icinga是一个开源的网络监控系统，它可以检查网络资源的可用性，将网络中断信息及时通知用户，并根据数据生成性能报告。这个工具有良好的可伸缩性和可扩展性，非常适合大型复杂环境。<br> 在一个庞大的IoT设备网络环境中，Icinga 可以跟踪每台设备，确保它们处于在线状态并正常运行。但Icinga的设置可能有点复杂，第一次使用的用户需要花点时间。</p></blockquote><h3 id="08-Cacti"><a href="#08-Cacti" class="headerlink" title="08 Cacti"></a>08 Cacti</h3><p><a href="https://www.cacti.net/">https://www.cacti.net/</a></p><blockquote><p>Cacti是一个基于Web的网络监控工具，它使用RRDTool来存储和显示网络统计数据。它提供了快速的轮询器、先进的图形模板以及多种数据采集的方法。<br> 如果网络中的设备类型比较多，Cacti的SNMP支持从各种网络设备中提取指标，并以易于理解的图形显示指标信息。但Cacti的主要缺点是用户界面并不怎么直观。</p></blockquote><h3 id="09-OpenNMS"><a href="#09-OpenNMS" class="headerlink" title="09 OpenNMS"></a>09 OpenNMS</h3><p><a href="https://www.opennms.com/">https://www.opennms.com/</a></p><blockquote><p>OpenNMS是一个开源网络管理应用程序，提供自动发现、事件管理、通知管理、性能检测和服务保证等功能。例如，OpenNMS可以监控核心网络设备，并提醒高延迟链路或故障设备等问题。</p></blockquote><h3 id="10-Collectd"><a href="#10-Collectd" class="headerlink" title="10 Collectd"></a>10 Collectd</h3><p><a href="https://github.com/collectd/collectd">https://github.com/collectd/collectd</a></p><blockquote><p>Collectd是一个可执行的守护进程，它可以定期收集系统和应用程序性能指标，并存储这些数值。这个工具它非常轻量级，几乎可以在任何系统上运行。<br> 例如，Collectd可以用来监视小型家庭网络，并收集网络延迟、带宽使用和设备状态相关的数据。将Collectd与Grafana等可视化工具结合使用，可获得更加完整的监控解决方案。</p></blockquote><h3 id="11-Sensu"><a href="#11-Sensu" class="headerlink" title="11 Sensu"></a>11 Sensu</h3><p><a href="https://github.com/sensu">https://github.com/sensu</a></p><blockquote><p>Sensu是一个开源的监控事件管道，提供自动化的监控工作流程。Sensu强大的框架能够用于各种小型、大型云基础实施，方便用于观察、自动化和控制。特别适合用于云基础设施。<br> 例如，在一个多个不同服务的大型云环境中，Sensu不仅可以监控这些服务的状态，还可以自动响应类似自动重新启动失败等服务的事件，</p></blockquote><h3 id="12-InfluxDB"><a href="#12-InfluxDB" class="headerlink" title="12 InfluxDB"></a>12 InfluxDB</h3><p><a href="https://github.com/influxdata/influxdb">https://github.com/influxdata/influxdb</a></p><blockquote><p>InfluxDB其实是一个能够处理高写入和高查询负载的时间序列数据库，旨在存储大量带时间戳的数据，它的高性能结构可以处理大量的写入和查询负载，支持存储、分析一段比较长时间内的趋势数据。<br> 因此，InfluxDB可以成为监控应用程序、实时分析等的理想选择。<br> 例如：我们要跟踪网站的用户参与度，InfluxDB可以存储包括点击率、跳出率和停留时间等相关指标。这为我们提供了一个用户行为随时间变化的全面数据视图。<br> 另外，由于InfluxDB本质是个数据库，为了便于分析，可以与Grafana结合在一起实现监控数据可视化。</p></blockquote><h2 id="13-Fluentd"><a href="#13-Fluentd" class="headerlink" title="13 Fluentd"></a>13 Fluentd</h2><p><a href="https://github.com/fluent/fluentd">https://github.com/fluent/fluentd</a></p><blockquote><p>Fluentd是一个数据采集和分析的开源工具，可用于建立统一的日志基础设施。支持从Web服务器、数据库和应用程序等各种来源收集日志，并以多种格式输出。并且还可以将日志和报告可以发送到Elasticsearch。</p></blockquote><h3 id="14-Telegraf"><a href="#14-Telegraf" class="headerlink" title="14 Telegraf"></a>14 Telegraf</h3><p><a href="https://github.com/influxdata/telegraf">https://github.com/influxdata/telegraf</a></p><blockquote><p>Telegraf是一个用于收集、处理、聚合和编写指标的代理，用于收集和发送各种系统指标。它是InfluxData平台的一部分（InfluxDB也是InfluxData的一部分）。<br> <strong>假如</strong>需要监视在不同平台上运行的几个不同应用程序的性能。那么可以使用Telegraf从每个应用程序中收集指标并将其存储到InfluxDB，从而创建统一的监控平台。Telegraf简单且灵活，但它也只是一个日志指标代理。</p></blockquote><h3 id="15-Logstash"><a href="#15-Logstash" class="headerlink" title="15 Logstash"></a>15 <strong>Logstash</strong></h3><p><a href="https://github.com/elastic/logstash">https://github.com/elastic/logstash</a></p><blockquote><p>Logstash是ELK Stack的一个重要组成部分，充当数据处理的管道。它可以从几乎任何类型的源获取数据、动态转换数据并将数据发送到目的地。<br> 假如我们要监控来多个系统（如Web服务器，安全设备和数据库），Logstash可以收集所有这些系统的日志，将收集到的数据以统一的格式发送到Elasticsearch。这使得分析和故障排除更加容易。Logstash虽然强大，但Logstash需要消耗一定的资源，如果您在较大的环境中使用Logstash，需要定期监控性能和微调，以避免资源浪费。</p></blockquote><h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a><strong>总之</strong></h2><p>以上列举的几个工具各有优缺点，选择合适的系统监控工具取决于具体的运行环境和对监控的要求。另外，在实际生产环境中，工具无法解决所有的问题，但是一个好的工具可以为我们提供最佳的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过跟踪监控服务器的性能、网络流量、应用程序性能以及用户体验情况，可帮助我们更好地了解整个IT环境运行状态，为系统运维、调优提供支撑。掌握一些好的监控工具可以为我们更好地跟踪服务器状态，持续优化系统提供最佳解决方案。&lt;/p&gt;
&lt;p&gt;本文主要列举了一些目前应用最好的开源免费系</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="运维" scheme="http://ai.mak.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用脚本掩盖MBP闪烁问题</title>
    <link href="http://ai.mak.cn/2023/09/21/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E6%8E%A9%E7%9B%96MBP%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/"/>
    <id>http://ai.mak.cn/2023/09/21/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E6%8E%A9%E7%9B%96MBP%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-10-23T03:06:32.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用脚本掩盖MBP闪烁问题"><a href="#使用脚本掩盖MBP闪烁问题" class="headerlink" title="使用脚本掩盖MBP闪烁问题"></a>使用脚本掩盖MBP闪烁问题</h2><blockquote><p>电脑是 Mac Book Pro 最早一批带Touch Bar 的版本，不仅鸡肋，还过了质保，就开始坏,使用一段时间后，开始频繁闪烁，各种晃眼，维修成本还很高，查了各种资料，想要停用Touch Bar，主要制止闪烁就行，这里根据网上资料，整理</p></blockquote><p>该方法参考了以下文章：</p><p><a href="https://link.zhihu.com/?target=https://medium.com/macoclock/macbook-touchbar-flicker-fix-bafa754aae13">https://medium.com/macoclock/macbook-touchbar-flicker-fix-bafa754aae13medium.com/macoclock/macbook-touchbar-flicker-fix-bafa754aae13</a></p><p>对触控栏的闪烁情况进行了观察，发现触控栏存在三种状态：</p><ul><li><strong>工作状态</strong>：不断操作电脑时，触控栏处于工作状态，闪烁轻微，影响很小；</li><li><strong>中间状态</strong>：停止操作电脑1分钟后，触控栏进入中间状态，显示内容与工作状态相同，但闪烁明显，影响较大；</li><li><strong>闲置状态</strong>：进入中间状态15秒后，触控栏进入闲置状态，不再显示内容，却闪烁剧烈，影响很大。</li></ul><h3 id="①-编辑脚本"><a href="#①-编辑脚本" class="headerlink" title="① 编辑脚本"></a>① 编辑脚本</h3><p>打开程序 <code>脚本编辑器</code>，选择 <code>新建文稿</code>，编辑脚本如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> idle</span><br><span class="line"><span class="comment">-- 设置触控栏重置时间为59秒</span></span><br><span class="line"><span class="keyword">set</span> resetTime <span class="keyword">to</span> <span class="number">59</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取电脑闲置时间（纳秒，1E9纳秒=1秒）</span></span><br><span class="line"><span class="keyword">set</span> idleTime <span class="keyword">to</span> (<span class="built_in">do shell script</span> <span class="string">&quot;ioreg -c IOHIDSystem | sed -nE &#x27;s/.*\&quot;HIDIdleTime\&quot; = //p&#x27;&quot;</span>) <span class="keyword">as</span> <span class="built_in">integer</span></span><br><span class="line"><span class="comment">-- 将电脑闲置时间转换为秒</span></span><br><span class="line"><span class="keyword">set</span> idleTime <span class="keyword">to</span> idleTime / <span class="number">1.0E+9</span> <span class="keyword">as</span> <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果电脑闲置时间大于等于重置时间，进行触控栏重置</span></span><br><span class="line"><span class="keyword">if</span> idleTime ≥ resetTime <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 重置触控栏</span></span><br><span class="line"><span class="built_in">do shell script</span> <span class="string">&quot;pkill TouchBarServer&quot;</span> user <span class="built_in">name</span> <span class="string">&quot;[用户名]&quot;</span> password <span class="string">&quot;[密码]&quot;</span> <span class="keyword">with</span> administrator privileges</span><br><span class="line"><span class="comment">-- 等待重置时间后执行</span></span><br><span class="line"><span class="built_in">return</span> resetTime</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当电脑闲置时间等于重置时间时执行</span></span><br><span class="line"><span class="built_in">return</span> resetTime - idleTime</span><br><span class="line"><span class="keyword">end</span> idle</span><br></pre></td></tr></table></figure><p>⚠️ 注意修改以下内容：</p><ul><li>修改常量重置时间 <code>resetTime</code> 的值。<br>当电脑闲置时间达到该值后，就重启触控栏。<br>该值应小于从停止操作电脑开始到触控栏发生闪烁的时间。<br>由于我的触控栏处于中间状态时，也有明显的闪烁，所以将该值设置为 <code>59</code> 秒，在触控栏进入中间状态前就对其重启。<br>若您的触控栏中间状态闪烁不明显，则可将该值设置为 <code>74</code> 秒，在触控栏进入闲置状态前对其重启即可。</li><li>设置系统用户名和密码。<br>在重置触控栏时，需使用系统用户名和密码进行授权，所以需将脚本中的 <code>[用户名]</code> 和 <code>[密码]</code> 分别替换为您的用户名和密码。</li></ul><h3 id="②-导出程序"><a href="#②-导出程序" class="headerlink" title="② 导出程序"></a>② 导出程序</h3><p>在 <code>脚本编辑器</code> 菜单中选择 <code>文件 → 导出</code>，在导出对话框中进行以下设置后，选择 <code>存储</code> 按钮。</p><ul><li>导出为：触控<a href="https://www.zhihu.com/search?q=%E6%A0%8F%E9%97%AA%E7%83%81%E4%BF%AE%E5%A4%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">栏闪烁修复</a>.app</li><li>位置：应用程序</li><li>文件格式：应用程序</li><li>选项：☑︎ 运行处理程序后保持打开</li><li><a href="https://www.zhihu.com/search?q=%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">代码签名</a>：签名以在本地运行</li></ul><p><img src="https://picx.zhimg.com/80/v2-ec3f7e55a91080e7171fab06527df33b_1440w.webp?source=1940ef5c" alt="img"></p><p>导出程序</p><h3 id="③-隐藏程序的运行痕迹（不介意可跳过）"><a href="#③-隐藏程序的运行痕迹（不介意可跳过）" class="headerlink" title="③ 隐藏程序的运行痕迹（不介意可跳过）"></a>③ 隐藏程序的运行痕迹（不介意可跳过）</h3><p>右键生成的 <code>触控栏闪烁修复.app</code>，选择 <code>显示包内容</code>，在 <code>Contents/Info.plist</code> <a href="https://www.zhihu.com/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">配置文件</a>中加入配置项 <code>LSUIElement</code>，以隐藏该程序的运行痕迹。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>LSUIElement<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置项 <a href="https://link.zhihu.com/?target=https://developer.apple.com/documentation/bundleresources/information_property_list/lsuielement">LSUIElement</a> 的描述名称为 <code>Application is agent (UIElement)</code>，类型为<a href="https://www.zhihu.com/search?q=%E5%B8%83%E5%B0%94%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">布尔型</a>，指示该应用程序是否为在<a href="https://www.zhihu.com/search?q=%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">后台运行</a>且不显示在程序坞中的<a href="https://www.zhihu.com/search?q=%E4%BB%A3%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">代理应用程序</a>。</p><p>当然，如果可以接受该程序运行时在屏幕顶部显示的菜单栏和在<a href="https://www.zhihu.com/search?q=%E7%A8%8B%E5%BA%8F%E5%9D%9E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2844450021%7D">程序坞</a>中显示的图标，可跳过这一步。</p><h3 id="④-设置程序开机自启动"><a href="#④-设置程序开机自启动" class="headerlink" title="④ 设置程序开机自启动"></a>④ 设置程序开机自启动</h3><p>打开 <code>系统设置 → 设置登录项 → 通用 → 登录项 → 登录时打开</code>，选择程序 <code>触控栏闪烁修复.app</code>。</p><p>作者：Jqgsninimo<br>链接：<a href="https://www.zhihu.com/question/327169975/answer/2844450021">https://www.zhihu.com/question/327169975/answer/2844450021</a><br>来源：知乎</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用脚本掩盖MBP闪烁问题&quot;&gt;&lt;a href=&quot;#使用脚本掩盖MBP闪烁问题&quot; class=&quot;headerlink&quot; title=&quot;使用脚本掩盖MBP闪烁问题&quot;&gt;&lt;/a&gt;使用脚本掩盖MBP闪烁问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;电脑是 Mac Book </summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Mac" scheme="http://ai.mak.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>史铁生语录02</title>
    <link href="http://ai.mak.cn/2023/09/08/%E8%AF%AD%E5%BD%95/%E5%8F%B2%E9%93%81%E7%94%9F%E8%AF%AD%E5%BD%9502/"/>
    <id>http://ai.mak.cn/2023/09/08/%E8%AF%AD%E5%BD%95/%E5%8F%B2%E9%93%81%E7%94%9F%E8%AF%AD%E5%BD%9502/</id>
    <published>2023-09-07T16:00:00.000Z</published>
    <updated>2023-09-09T15:46:12.334Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">拖延的最大坏处还不是耽误，</span><br><span class="line">而是会使自已变得犹豫，</span><br><span class="line">甚至丧失信心。</span><br><span class="line">不管什么事，决定了，</span><br><span class="line">就立刻去做，</span><br><span class="line">这本身就能使人生气勃勃，</span><br><span class="line">保持一种主动和快乐的心情。</span><br><span class="line"></span><br><span class="line">史铁生《最有用的事》</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>史铁生语录01</title>
    <link href="http://ai.mak.cn/2023/09/07/%E8%AF%AD%E5%BD%95/%E5%8F%B2%E9%93%81%E7%94%9F%E8%AF%AD%E5%BD%9501/"/>
    <id>http://ai.mak.cn/2023/09/07/%E8%AF%AD%E5%BD%95/%E5%8F%B2%E9%93%81%E7%94%9F%E8%AF%AD%E5%BD%9501/</id>
    <published>2023-09-06T16:00:00.000Z</published>
    <updated>2023-09-09T15:46:14.969Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 步步都是走在回去的路上。</span><br><span class="line"> 当牵牛花初开的时节，</span><br><span class="line"> 葬礼的号角就已吹响。</span><br><span class="line"> 但是太阳，他每时每刻都是夕阳也都是旭日。</span><br><span class="line"> 当他熄灭着走下山去收尽苍凉残照之际，</span><br><span class="line"> 正是他在另一面燃烧着爬上山巅布散烈烈朝辉之时。</span><br><span class="line"> 有一天，我也将沉静着走下山去，扶着我的拐杖。</span><br><span class="line"> 那一天.在某一处山洼里，</span><br><span class="line"> 势必会跑上来一个欢蹦的孩子，抱着他的玩具。</span><br><span class="line">当然，那不是我。</span><br><span class="line">但是，那不是我吗?</span><br><span class="line">宇宙以其不息的欲望将一个歌舞炼为永恒。</span><br><span class="line">这欲望有怎样一个人间的姓名，大可忽略不计。</span><br><span class="line">                   </span><br><span class="line">                                     写于一九八九年五月五日</span><br><span class="line">                                     修改于一九九O年一月七日</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>骑起来</title>
    <link href="http://ai.mak.cn/2023/08/30/%E8%AF%AD%E5%BD%95/%E9%AA%91%E8%B5%B7%E6%9D%A5/"/>
    <id>http://ai.mak.cn/2023/08/30/%E8%AF%AD%E5%BD%95/%E9%AA%91%E8%B5%B7%E6%9D%A5/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-09-10T00:53:13.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>白天归顺生活，夜晚臣服于灵魂，生活原本沉闷，但骑起来就会有风……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;白天归顺生活，夜晚臣服于灵魂，生活原本沉闷，但骑起来就会有风……&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC移动硬盘非正常断开连接后硬盘无法识别</title>
    <link href="http://ai.mak.cn/2023/08/20/%E5%B7%A5%E5%85%B7/MAC%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E9%9D%9E%E6%AD%A3%E5%B8%B8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/"/>
    <id>http://ai.mak.cn/2023/08/20/%E5%B7%A5%E5%85%B7/MAC%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E9%9D%9E%E6%AD%A3%E5%B8%B8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%A1%AC%E7%9B%98%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/</id>
    <published>2023-08-19T16:00:00.000Z</published>
    <updated>2023-08-20T11:42:55.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC移动硬盘非正常断开连接后硬盘无法识别"><a href="#MAC移动硬盘非正常断开连接后硬盘无法识别" class="headerlink" title="MAC移动硬盘非正常断开连接后硬盘无法识别"></a>MAC移动硬盘非正常断开连接后硬盘无法识别</h1><p>步骤1：先找到外接移动硬盘，在 Mac “终端”执行命令</p><p>步骤2：加载移动硬盘，可以在终端执行以下两个命令之一</p><p>步骤3：终止后台自动执行的“磁盘修复进程”</p><p>步骤4：手动执行磁盘修复命令</p><p>步骤5：Windows系统的磁盘修复</p><p>参考6：修复方案及相关命令详解</p><hr><p>  MAC 的移动硬盘非正常退出后（断电、直接拔掉等），重新连接后无法在“Finder桌面”或“磁盘工具”里正常看到移动硬盘的图标。</p><p>  每次出现这个问题都是在网上搜索一番，敲几行命令，有实话敲完就OK，，有时候不管，放一段时间自动修复了，还是在一次成功解决后，记录下来吧</p><h1 id="步骤1：先找到外接移动硬盘，在-Mac-“终端”执行命令"><a href="#步骤1：先找到外接移动硬盘，在-Mac-“终端”执行命令" class="headerlink" title="步骤1：先找到外接移动硬盘，在 Mac “终端”执行命令"></a><strong>步骤1：先找到外接移动硬盘，在 Mac “终端”执行命令</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p>  执行后，显示的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk0 (internal, physical):</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      GUID_partition_scheme                        *500.3 GB   disk0</span><br><span class="line">   1:                        EFI ⁨EFI⁩                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS ⁨Container disk1⁩         500.0 GB   disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      APFS Container Scheme -                      +500.0 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume ⁨Macintosh HD - 数据⁩     278.7 GB   disk1s1</span><br><span class="line">   2:                APFS Volume ⁨Preboot⁩                 301.7 MB   disk1s2</span><br><span class="line">   3:                APFS Volume ⁨Recovery⁩                1.1 GB     disk1s3</span><br><span class="line">   4:                APFS Volume ⁨VM⁩                      1.1 GB     disk1s4</span><br><span class="line">   5:                APFS Volume ⁨Macintosh HD⁩            15.4 GB    disk1s5</span><br><span class="line">   6:              APFS Snapshot ⁨com.apple.os.update-...⁩ 15.4 GB    disk1s5s1</span><br><span class="line"></span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:     FDisk_partition_scheme                        *1.0 TB     disk2</span><br><span class="line">   1:               Windows_NTFS ⁨Elements⁩                1.0 TB     disk2s1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  从终端提示内容可以看到，外接移动硬盘（external, physical）名称是：disk2, 容量1TB，硬盘的文件格式没有明确标注，从microsoft Basic Data 几个字样推断，再加上之前在 Windows 系统也能正常使用，应该是能兼容 Windows 和 Mac 系统的 exFAT 格式（<em>不同的文件格式，请参考文末链接</em>），当然从后面运行命令后，系统提示的信息也能看到。</p><p>  另外，disk2 下面包括两个盘符标记：disk2s1 和 disk2s2, 多个盘符表示硬盘包括多个分区，可以看到disk2s1的 TYPE NAME 是 EFI ：</p><blockquote><p>EFI系统分区中存放了可供引导启动的文件，作用是引导操作系统正常启动。EFI系统分区是一个使用FAT32格式化的小分区，该分区在Windows操作系统下一般是不可见的，其中存储已安装系统的EFI引导加载程序以及启动时固件使用的应用程序。</p></blockquote><p>  因为 EFI 分区在这里对我们没有什么意义，我们实际存储数据的的硬盘分区是 disk2s2，后面命令的操作对象和执行结果也是针对的硬盘分区 disk2s2 来说的。</p><h1 id="步骤2：加载移动硬盘，可以在终端执行以下两个命令之一"><a href="#步骤2：加载移动硬盘，可以在终端执行以下两个命令之一" class="headerlink" title="步骤2：加载移动硬盘，可以在终端执行以下两个命令之一"></a><strong>步骤2：加载移动硬盘，可以在终端执行以下两个命令之一</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount命令可以只挂载硬盘的某个分区</span><br><span class="line">diskutil mount /dev/disk2s2# mountdisk命令可以实现挂载整个硬盘（包括所有分区）</span><br><span class="line">diskutil mountdisk /dev/disk2</span><br></pre></td></tr></table></figure><p>  通常异常退出的移动硬盘，执行这两个命令都会提示错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 执行 sudo diskutil mount /dev/disk2s2 命令报错</span><br><span class="line">Volume on disk2 timed out waiting to mount# 执行 sudo diskutil mountDisk /dev/disk2 命令报错：</span><br><span class="line">One or more volume(s) failed to mount</span><br></pre></td></tr></table></figure><p>  <strong>为什么会提示等待超时呢？</strong>其实是因为你把硬盘的数据线重新接上电脑时，系统检测到硬盘异常，Mac 系统会在“<strong>后台自动运行</strong>” 磁盘修复进程: <strong>fsck</strong>，从而导致 <strong>diskutil mount</strong> 命令运行超时。</p><blockquote><p><strong>如果你刚接上硬盘不能识别，不要着急反复拔掉和重新连接，可以稍微耐心等待系统的自动修复完成。如果等待时间过长还没有恢复，可以继续执行下面的步骤。</strong></p></blockquote><h1 id="步骤3：终止后台自动执行的“磁盘修复进程”"><a href="#步骤3：终止后台自动执行的“磁盘修复进程”" class="headerlink" title="步骤3：终止后台自动执行的“磁盘修复进程”"></a><strong>步骤3：终止后台自动执行的“磁盘修复进程”</strong></h1><p>  先执行下面命令，找到后台运行的 fsck 进程的PID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep fsck</span><br></pre></td></tr></table></figure><p>  显示后台正在运行的 fsck 进程，从下面截图能看到：<strong>fsck_exfat -y -x &#x2F;dev&#x2F;rdisk2s2</strong> ，从这里也能判断硬盘文件格式应该是：<strong>exfat</strong>。</p><p>  执行命令 kill fsck，终止自动修复进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 21364 是 PID 进程号</span><br><span class="line">sudo pkill -f fsck 或 sudo kill -9 21364</span><br></pre></td></tr></table></figure><p>  注意：执行完毕后，再次执行【步骤2】的磁盘加载命令，一般都能装载成功，桌面上会出现移动硬盘盘符标志。但是运气比较差的话，杀死 fsck 进程后，硬盘会自动以”<strong>只读状态</strong>“完成加载，并弹出提示对话框，如下图所示。接下来可以继续尝试后面的步骤来进行硬盘修复。</p><h1 id="步骤4：手动执行磁盘修复命令"><a href="#步骤4：手动执行磁盘修复命令" class="headerlink" title="步骤4：手动执行磁盘修复命令"></a><strong>步骤4：手动执行磁盘修复命令</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fsck_exfat -y -x /dev/disk2s2</span><br></pre></td></tr></table></figure><p>  一般常用的磁盘修复命令有： <strong>fsck_hfs、fsck_exfat、fsck_apfs</strong> 等，<strong>fsck</strong> 代表磁盘修复命令，下划线后面 <strong>hfs，exfat，apfs</strong> 代表硬盘的文件格式。（<em>fsck 命令详解，请参考文末链接</em>）。 </p><p>  注意，<strong>fask_[文件格式]</strong> 命令要正确，另外，“手动执行修复命令”与“系统提供【磁盘工具】- 【急救】”是一样的原理和效果，在终端手动执行修复命令后，会显示修复过程中的详细信息，例如那些文件是问题的</p><p>  【步骤4】如果能顺利执行完毕就可以加载硬盘成功，但是【步骤4】的时长不好判断，从几分钟到半个小时的都有，甚至还有人等待十几个小时最后放弃的。笔者碰到的情况是：“手动修复方式”和“磁盘工具-急救”两种方案都试过了，都是等待几个小时也没有等到修复结束的时刻。虽然“磁盘工具 - 急救”对话框有个“详情”标签展开可以检测到错误文件的信息，对话框页面也有一个进度条，但是一直都只显示空空进度条，没有任何进度更新，只好放弃！</p><h1 id="步骤5：Windows系统的磁盘修复"><a href="#步骤5：Windows系统的磁盘修复" class="headerlink" title="步骤5：Windows系统的磁盘修复"></a><strong>步骤5：Windows系统的磁盘修复</strong></h1><p>  如果【步骤四】不幸失败了，但是你必须要拯救这块硬盘的话，就去找一台 Windows 系统的电脑，<strong>既然 Mac 系统修复失败，那么为什么不试试 Windows 系统的磁盘修复功能呢？</strong>前面提到过，这块硬盘文件格式是 exFAT，兼容两个系统。</p><p>  在接上安装有 Windows 10 系统的笔记本电脑后，系统提示：“磁盘错误，需要扫描和修复”，于是点击“确认”，开始修复和修复结束的对话框如图所示:</p><p>  这次等待时间接近3个小时，虽然时间很长，但是进度条在缓慢移动，相比 Mac 系统，至少让你还有等待下去的期待。这个时间可能跟硬盘大小、速度、文件数量有关系（笔者的硬盘是机械硬盘，2T，剩余空间60G）。以上是 Win10 的提供的磁盘修复对话框，如果接上硬盘后，系统没有任何提示，你可以在 DOS 窗口手动输入命令来实现相同的修复过程。（<em>Windows Dos磁盘修复方法，参考文末链接</em>）。</p><p>  如果最终没有成功的话，可能真的是磁盘数据损坏无法修复了，需要及时备份以防数据丢失。</p><h1 id="参考6：修复方案及相关命令详解"><a href="#参考6：修复方案及相关命令详解" class="headerlink" title="参考6：修复方案及相关命令详解"></a><strong>参考6：修复方案及相关命令详解</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mac下移动硬盘异常退出修复方法</span><br><span class="line">https://zhuanlan.zhihu.com/p/83542978</span><br><span class="line">https://blog.csdn.net/Bobdragery/article/details/95086132</span><br><span class="line">https://apple.stackexchange.com/questions/235309/external-drive-does-not-mount-after-plug-off-without-eject# Windows Dos磁盘修复方法</span><br><span class="line">https://blog.csdn.net/qq_26834611/article/details/107968650# MacOS 磁盘管理工具 diskutil 介绍</span><br><span class="line">https://www.jianshu.com/p/6a1f365617ad# Linux fsck命令介绍：检测和修复文件系统</span><br><span class="line">http://c.biancheng.net/view/887.html# unmount, unmountdisk, eject命令的区别</span><br><span class="line">http://newsn.com.cn/say/mac-umount.html</span><br><span class="line"># mount与mountdisk命令的区别</span><br><span class="line">https://newsn.net/say/mac-mount-2.html# Fat32、NTFS、exFAT、HFS+、APFS文件系统的区别</span><br><span class="line">https://blog.csdn.net/qq_39111085/article/details/103800464</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MAC移动硬盘非正常断开连接后硬盘无法识别&quot;&gt;&lt;a href=&quot;#MAC移动硬盘非正常断开连接后硬盘无法识别&quot; class=&quot;headerlink&quot; title=&quot;MAC移动硬盘非正常断开连接后硬盘无法识别&quot;&gt;&lt;/a&gt;MAC移动硬盘非正常断开连接后硬盘无法识别&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>创新</title>
    <link href="http://ai.mak.cn/2023/08/18/%E8%AF%AD%E5%BD%95/%E5%88%9B%E6%96%B0/"/>
    <id>http://ai.mak.cn/2023/08/18/%E8%AF%AD%E5%BD%95/%E5%88%9B%E6%96%B0/</id>
    <published>2023-08-17T16:00:00.000Z</published>
    <updated>2023-08-20T13:24:51.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鸡蛋从外打破叫破碎，从内部打破叫新生</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连续式创新</span><br><span class="line">平台式创建</span><br><span class="line">颠覆式创新</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;鸡蛋从外打破叫破碎，从内部打破叫新生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
</feed>
