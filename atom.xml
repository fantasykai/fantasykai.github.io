<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2022-11-14T03:31:10.728Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>技术人具备“结构化思维”意味着什么？</title>
    <link href="http://ai.mak.cn/2019/07/18/%E6%9D%82%E8%AE%B0/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%85%B7%E5%A4%87%E2%80%9C%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E2%80%9D%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://ai.mak.cn/2019/07/18/%E6%9D%82%E8%AE%B0/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%85%B7%E5%A4%87%E2%80%9C%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E2%80%9D%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2022-11-19T15:11:21.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术人具备“结构化思维”意味着什么？"><a href="#技术人具备“结构化思维”意味着什么？" class="headerlink" title="技术人具备“结构化思维”意味着什么？"></a>技术人具备“结构化思维”意味着什么？</h1><p><strong>什么是结构化思维？</strong></p><p>那么到底是什么是结构化思维呢？简单来说，结构化思维的定义就是：逻辑+套路。</p><p><strong>表达要有逻辑</strong></p><p><strong>所谓逻辑是指我们的结构之间必须是有逻辑关系的</strong>。例如，你说话的时候用“第一、第二、第三”这个逻辑顺序是合理的，但是，用“第一，第二，第四”就会显得很奇怪。当然，即使你用了”一、二、三”，也不一定就意味着你的内容有逻辑关系。想让内容有逻辑关系，我们要学会四种组织思想的逻辑关系：</p><p>1）<strong>演绎（因果）顺序：</strong>“大前提、小前提、结论”的演绎推理方式就是演绎顺序。比如，经典三段论：所有人都要死，苏格拉底是人，苏格拉底要死。</p><p>2）<strong>时间（步骤）顺序：</strong>“第一、第二、第三”，“首先、然后、再者”等，很多的时间顺序同时也是因果顺序。</p><p>3）<strong>空间（结构）顺序：</strong>“前端、后端、数据”，“波士顿、纽约、华盛顿”，化整为零（将整体分解为部分）等都是空间顺序。</p><p>4）<strong>程度（重要性）顺序</strong>：比如“最重要、次重要、不重要”等。</p><p>实际上，所有的逻辑关系都在这四种顺序之内。只要我们的思想和表达在这四种逻辑顺序之内，就是有逻辑的，否则就会显得没有逻辑性。</p><p><strong>做事要有套路</strong></p><p><strong>套路是指我们解决问题的方法论，这个也非常重要</strong>。比如，5W2H 分析法就是一个非常好的，可以帮助我们分析问题的一个”套路”。试想一下，面对任何一个问题，你都能从 Why、Who、When、Where、What、How 和 How much（如下图所示），七个方面去思考。是不是比不知道这个方法论的人，用点状的思考，5W2H 分析法就全面得多。</p><p><img src="https://aimak.cn/blog_img/manager/5w2h.jpeg" alt="图片"></p><p>例如，我们在对问题域进行分析和领域知识提炼的时候，就可以用上5W2H。5W2H模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。</p><p><img src="https://aimak.cn/blog_img/manager/6w.jpeg" alt="图片"></p><p>逻辑是一种能力，而套路是方法论，是经验。逻辑是道的东西，而方法论是术的东西。二者都很重要，只有熟练的掌握二者我们才能更好的进行结构化思考。</p><p><strong>如何进行结构化思考？</strong></p><p>逻辑性和方法论是结构化思维的底层，那么如何进行结构化思考呢？这也是有方法论的，总的来说是有两个步骤，首先是“建立中心”，然后再进行“分解”。</p><p><strong>建立中心</strong></p><p><strong>建立中心也就是要定义清楚要解决的问题，要明确目标</strong>。是我们结构的顶层节点，也是一种以终为始的思考方式。也就是说，我们首先要搞清楚 why，然后再进行 how。</p><p>★ 建立中心有两种方式：</p><ol><li><strong>自上而下</strong>：适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。</li><li><strong>自下而上</strong>：对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。</li></ol><p>建立中心通常不会是一次成型的，随着对问题理解的变化，对中心的抽象也会进行相应的调整。不同的抽象层次其面对的问题宽度是不一样的。具体要用哪个层次的抽象作为“中心”，要视具体情况而定。</p><p>比如面对“系统 bug 多”的问题，向上抽象是“提升代码质量”，向下抽象是“加强测试”，都可以作为中心，选择哪个为中心取决于你当前要解决的问题是什么。</p><p><img src="https://aimak.cn/blog_img/manager/chouxiangcengci.jpeg" alt="图片"></p><p><strong>结构化分解</strong></p><p>确定完中心之后，我们需要构建一个结构，使用结构化的思维对问题进行分解。分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序。</p><p>在做空间分解的时候，要注意满足 MECE（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）原则。</p><p>比如我们要对衣服进行分类，如果按照季节和风格进行分类，就会出现互相重叠，并且不能穷尽的情况，也就不满足 MECE。这种分类是逻辑混乱的。</p><p><img src="https://aimak.cn/blog_img/manager/luojihunluan.jpeg" alt="图片"></p><p>我们可以按季节分：春秋装，冬装，夏装。除了这3类之外，没有其他季节了，这个就是「不遗漏」。</p><p><img src="https://aimak.cn/blog_img/manager/fenlei.jpeg" alt="图片"></p><p><strong>结构化思维应用</strong></p><h1 id="如何落地新团队？"><a href="#如何落地新团队？" class="headerlink" title="如何落地新团队？"></a><strong>如何落地新团队？</strong></h1><p>想象这样一个场景，你刚刚入职一家新公司，或者转岗到一个新团队，作为一个技术人，你将如何落地开展你的工作呢？</p><p>这里，我们就能用上结构化思维来帮我们理清思路，从而有条不紊的开展工作了。我们要知道对一个企业来说，核心要素无外乎就是业务、技术和人，也就是说这三个要素是我们要建立的中心。基于这个中心，我们可以进行进一步拆解，形成子结构。然后对子结构再进行分析找到应对策略。这样一步步递进，我们就已经在用结构化思维解决如何落地新团队的问题了。</p><p><img src="https://aimak.cn/blog_img/manager/zuzhijiagou.jpeg" alt="图片"></p><p>★ 1. 熟悉业务</p><p><strong>1）了解产品</strong>：任何一个团队都有自己要负责的产品，申请一个测试账号去用一下产品，是熟悉产品比较好的方式。</p><p><strong>2）了解流程</strong>：任何业务都有自己的业务流程，而业务流里面最核心的是信息流。我们可以通过人员采访，了解关键节点的信息输入和信息输出；可以画一些泳道活动图，理清楚系统的主要角色，以及他们之间的交互关系。</p><p><strong>3）客户走访</strong>：通过走访客户，我们可以更加获得业务的第一手资料，更加贴近业务和客户诉求。</p><p>★ 2. 熟悉技术</p><p><strong>1）了解系统架构</strong>：可以让团队的技术人员介绍下他们当初系统设计和架构的思路。</p><p><strong>2）了解领域模型</strong>：查看关键的核心表结构和系统 API，这样可以快速了解系统的领域模型。</p><p><strong>3）了解代码结构</strong>：下载系统工程，熟悉整个工程结构和模块职责。以一个最重要的流程为入手点，阅读代码，看清楚核心的执行逻辑。做一个小需求，掌握相关的流程和权限。</p><p>★ 3. 熟悉人</p><p><strong>1）了解组织结构</strong>：查看公司的组织树，知道公司大概是如何运作的，以及哪些是KP（Key Person，关键人）。比如，一个典型的电商公司会包括产品部、运营部、销售部、技术部、人力资源部、财务部、法务部等。</p><p><strong>2）了解人员角色</strong>：了解公司都有哪些岗位，以及各岗位的职责范围。</p><p><strong>3）拜山头</strong>：找到和自己工作息息相关的岗位人员，比如产品和运营。积极和他们沟通，向他们请教业务问题，多多交流。这样一方面可以建立更好的人际关系，另一方面也可以更快地熟悉业务。</p><p><strong>打造极客文化</strong></p><p>我最近刚刚转岗到新部门，新部门的老板抛给我一个命题：如何帮助技术团队打造极客文化？</p><p>这个问题的中心很明确，接下来，看看我是如何使用结构化思维来解这个问题的。首先我们从空间顺序进行分解，也就是打造极客文化，我们可以去做哪些事情。</p><p><img src="https://aimak.cn/blog_img/manager/kongjian.jpeg" alt="图片"><br>空间顺序分解</p><p>确定完要做的事情，我们还可以按照时间顺序对如何落地这些事情进行分解。</p><p><img src="https://aimak.cn/blog_img/manager/shijian.jpeg" alt="图片"><br>时间顺序分解</p><p>这样把按照这两个维度进行结构化拆解的方案给到老板，老板就会很清晰地知道你的规划和落地策略了。</p><p><strong>如何做晋升述职</strong></p><p>作者在阿里巴巴已经做了好几年的晋升评委，发现很多同学都缺乏结构化思维，冗长的 PPT 里，却不能把价值说清楚，不能把推导过程说清楚。实际上，我们需要有一些方法论来指导我们进行关键述职。</p><p>接下来，我主要说一下述职中存在的两个典型问题：“罗列事情”和“价值的背后”</p><p>★ 1.罗列事情</p><p>对自己做过的事情进行简单罗列，也许你的确做了不少事情。但是不能体现你对问题思考的深度和做这个事情带来的价值。这样的述职很难打动评委，更结构化的表达应该是：<strong>“提出问题，定义问题，分析问题，解决问题，最后是展望未来”</strong>。</p><p>这是一个经典的表述问题的结构，也是麦肯锡推荐的问题解决的框架。</p><p><img src="https://aimak.cn/blog_img/manager/maikenxi01.jpeg" alt="图片"></p><p>类似的框架还有 zoom in&#x2F;zoom out。 我们说事情时，应该像电影镜头一样，先从远拉近，再由近拉远。zoom in 是先从宏观背景开始，首先让大家知道你的事情发生的背景，为什么这事重要？然后讲到具体细节，怎么做成的？解决了什么问题？背后的思考是什么？最后 Zoom out，再从细节调回到整体，结果是什么，带来的客户价值是什么，你对未来的思考是什么。</p><p>★ 2.价值的背后</p><p>把价值说清楚的确很重要，正所谓：路走对了，就不怕远。如果你连价值都不明确，后面做的再多也是白搭。但是，仅仅阐述价值也是不够的，会让人觉得你有邀功之嫌。</p><p>比如你说：“我主导研发的风控系统把公司的坏账率从5%降低到2%”。这样的表述是不够的，你还需要把价值背后的过程和思考说清楚。对于这个结果，评委可能会问：</p><ol><li>之前为什么那么高？</li><li>为什么你的方法可以降低？是如何归因的？</li><li>具体解决了什么问题？</li><li>是否可以总结出一套办法，以后别人也能用这个办法解决这些问题？</li></ol><p>如果你在评委提问之前，就能对这些问题进行深入思考和适当呈现。那么你就是既有结果又有过程了。</p><p>通过这些案例，我们可以看到具备结构化思维，可以帮助我们快速的理清处理问题的思路，提升工作效率。经常锻炼结构化思维，可以极大的提升我们职场竞争力，让工作有条不紊，事半功倍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术人具备“结构化思维”意味着什么？&quot;&gt;&lt;a href=&quot;#技术人具备“结构化思维”意味着什么？&quot; class=&quot;headerlink&quot; title=&quot;技术人具备“结构化思维”意味着什么？&quot;&gt;&lt;/a&gt;技术人具备“结构化思维”意味着什么？&lt;/h1&gt;&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="技术团队" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>管理者核心能力如何提升</title>
    <link href="http://ai.mak.cn/2019/07/06/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E8%80%85%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87/"/>
    <id>http://ai.mak.cn/2019/07/06/%E6%9D%82%E8%AE%B0/%E7%AE%A1%E7%90%86%E8%80%85%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2022-11-19T14:45:23.738Z</updated>
    
    <content type="html"><![CDATA[<p>今天读到腾讯大学文章《互联网领导者升级的7种武器》，有感而发，在互联网背景下，尤其互联网+企业，管理者的核心能力应该是什么，从哪些维度升级？</p><p> <strong>一</strong> </p><p><strong>行业咖眼中的互联网领导力五要素</strong></p><p>先看一个行业咖的观点，刘润在《5分钟商学院》书里讲述过，互联网时代领导力的五个要素：专、小、变、快、远.</p><p><strong>1、专——专注</strong></p><p>选择性注意“威胁、此刻、重要”，只做“专注白名单”中的事。</p><p>第一，利用威胁，没有伞的孩子，才会努力奔跑；</p><p>第二，利用此刻，让最后期限，成为第一生产力；</p><p>第三，利用重要，赋予事情重大的意义。</p><p><strong>2、小——通过变小，获得专注</strong></p><p>“小”，是“专”的孪生兄弟。在高速变化的互联网时代，越来越多的管理者开始懂得，通过变小获得专注。</p><p>第一，创业公司，要克制招人冲动；</p><p>第二，成熟公司，要缩小企业规模；</p><p>第三，转型公司，要追求战略专注。</p><p><strong>3、变——修炼“变革之心”</strong></p><p>面对充满VUCA（易变性、不确定性、复杂性、模糊性）的新世界，如何修炼“变革之心”，刘润提出三根轴：</p><p><strong>第一，给管理加上时间轴</strong>。比如KPI不是错的，只是不适合创业期；粗放管理不是错的，只是不适合成熟期。</p><p><strong>第二，给商业加上概率轴</strong>。有些成功是大概率事件；有些成功是小概率事件，要能意识到外部环境、时机、风险的复杂性，以及内部速度、坚持，或者放弃的重要性。</p><p><strong>第三，给个人加上博弈轴</strong>。面对模糊性看一步，走一步，才能修炼自己的“变革之心”。</p><p><strong>4、快——天下武功，唯快不破</strong></p><p>在互联网变革时代，唯有用内部的快，响应外部的变，才能抓住时代机遇。如何训练“以快应变”的领导力，刘润建议大家注意三点：</p><p><strong>第一、不要放弃思考；</strong></p><p><strong>第二、当下就要行动；</strong></p><p><strong>第三、练好刹车转弯。</strong></p><p><strong>5、远——远见</strong></p><p>远见，就是站在未来看今天。谁也不敢说自己能预测未来，但是我们至少可以训练预测未来的几项基础能力：</p><p><strong>第一是洞察力；</strong></p><p><strong>第二是判断力；</strong></p><p><strong>第三是学习力。</strong></p><p> <strong>二</strong> </p><p><strong>腾讯提出的互联网四维领导力</strong></p><p>在2019腾讯T+HR峰会，腾讯咨询助理总经理徐洁以“互联网领导者升级的7种武器”为主题，分享互联网人需要哪些核心领导力。</p><p>徐洁从“提升组织能力、驱动组织绩效、打造全脑效应、注重提升情商”四个维度来谈如何提升互联网领导力的，这四个维度是以下内容：</p><p><strong>1、提升组织能力——四个驱动力因素</strong></p><p>哪些领导力要素可以驱动用户导向、创新和敏捷这些至关重要的组织能力？腾讯咨询通过几十个指标的相关性和驱动性数据分析，发现四点尤为突出：</p><p><strong>（1）明确目标——知道为什么、做什么和如何衡量</strong></p><p>高层在制定目标的时候不用过于担心犯错，更需要关注如何让高层、中层乃至员工“共同看见”，并通过灵活调整和反思学习进行优化。</p><p><strong>（2）建立信任——“信任&#x3D;同理心+共同的价值观+安全可靠”</strong></p><p>信任就像爱，看不见摸不着，每个人都需要，但经常缺乏。如果没有明确目标和共同的价值观作为前提，信任无从谈起。</p><p><strong>（3）有效松绑——在组织中减少不必要的流程和束缚。</strong></p><p>有些互联网组织在经济周期来临时，惊觉“缺了许多功课”，于是拼命补课、着手建立大量流程和规范。这时反而需要注意规避走入“过犹不及”的误区。</p><p><strong>（4）关注创新——变革、突破会成为未来几年的关键词，</strong></p><p>人类大脑天生对熟悉或既有成功路径感到安全，管理者们需要着手建立团队成员对全新路径、打法、行为模式感到安全的氛围。</p><p><strong>2、领导风格升级——“愿景型”+“辅导型”</strong></p><p>为什么有的领导者善于发掘目标、建立信任，而有的领导没日没夜率先投入业务却没有大幅带来绩效？腾讯咨询提出两种领导方式：</p><p><strong>（1）“愿景型”领导——看到未来、描述画面、并激发团队能量。</strong></p><p>腾讯咨询从300多个顶级互联网公司中高层领导者的数据分析来看，排名第一的擅长之处是“愿景型”。</p><p>许多领导者相信企业的初心愿景会比收入、利润这些数值更有意义，就算眼前艰难，依然选择长期相信。</p><p>只是，对于老板来说，需要做好Chief Explain Officer“首席解释官”工作，对于战略方向、文化价值观、战略重点，需要不厌其烦反复宣导，才能提升全员的理解和认同。</p><p><strong>（2）“辅导型”领导——发掘团队的优势，赋能人的成长</strong></p><p>大部分的领导者会关注战略、策略、执行、结果这些“事”上，对“人”的长期发展没那么关注，甚至觉得不重要。</p><p>腾讯咨询，从理论到实际的数据分析都说明，发掘团队的优势、着眼发展等行为，能够强力驱动绩效。</p><p><strong>3、打造全脑效应——高管团队需认知互补</strong></p><p>腾讯咨询建议，作为CEO和HR负责人，需要考虑如何创造机制，让一群人组合成一个更为强大的大脑，并让每一个个体持续升级自我，以适应不同业务战场。</p><p><strong>（1）互联网高管的认知优势</strong></p><p>腾讯调研发现，与传统企业相比，互联网中高管的“思考型”占比上升。</p><p>互联网企业中，倾向提出创意的“发散型”中高管大约占比6%，善于解决问题的“聚焦型”占比57%，适应性强的“行动型”占比19%，而倾向不断琢磨的“思考型”占比18%。</p><p><strong>（2）高层团队需要着力互补</strong></p><p>腾讯咨询建议，从打造高管团队“全脑”效应来看，CEO需要考虑团队中差异性人群长期生存和发展。</p><p>比如“行动型”CEO，可能会嫌弃“思考型”高管想的太多、反应太慢，乃至贻误战机。而“聚焦型”CEO，则常常认为“发散型”高管点子太多、缺乏逻辑、无法落地。</p><p><strong>4、注重提升情商——从自我走向关系，激发出最佳状态。</strong></p><p>腾讯咨询认为，情商作为个人底层操作系统，也是领导风格改善的关键。</p><p><strong>（1）互联网领导者的情商长板</strong></p><p>互联网领导者擅长成就导向、团队协作与积极展望。也愿意“打群架”应对变动不居的世界。</p><p>所谓积极展望，像是环境锻炼出来的成长思维，即使眼前已经亏了100亿、或者股票持续破发，依然能稳定心神、调动正面能量带领组织奋力向前。</p><p><strong>（2）互联网领导者的情商短板</strong></p><p>腾讯咨询认为，互联网领导者不太擅长理解自我、同理心和影响他人。</p><p>对自我情感模式的洞察程度，很大程度驱动着同理心——即洞察他人的能力。而同理心则是建立信任、连接和影响力的基石。</p><p>同时，通过情商分析发现，互联网领导者相对不太擅长发挥影响力，可以看到改变世界、影响他人是许多人内心很爽的事情，但是不太擅长。</p><p>最后，腾讯咨询基于以上四维领导力的分析，提出互联网高管领导力三板斧和中层领导力三板斧。</p><p><strong>5、腾讯版高管领导力的三板斧</strong></p><p><strong>第一、开启认知。</strong></p><p>在战略业务、组织打造和领导力提升等方面，需要高管们更为坦诚分享见解、疑惑甚至尖锐的反馈。</p><p><strong>第二、情商升级。</strong></p><p>过去高管团队注重“脑部”，未来也需要关注“心灵”即情商体系升级。辅导他人、激励式领导、同理心是推荐的3个重点关注素质。</p><p><strong>第三、聚焦核心。</strong></p><p>找到适合自身企业的战略落地和追踪方式。无论采取战略解码或者OKR的方式，集合整个公司的力量在3-5个关键战役上突破。</p><p><strong>6、腾讯版高管领导力的三板斧</strong></p><p><strong>第一、方向驱动。</strong></p><p>对上，打通团队的成果对整个公司的意义；对下，每个员工都知道如何发力贡献价值。</p><p><strong>第二、成长至上。</strong></p><p>现在的人才不仅看给多少钱，更看重未来的成长空间。工作本身的意义和成长契机吸引和激发高绩效成员，同时在工作中可以有空间尝试新方法、新业务。</p><p><strong>第三、信任为基</strong></p><p>团队成员彼此尊重和信任，需要定义团队“心理安全度”。要将真诚、同理、塑造信任纳为己任。</p><p>诸位，从腾讯版的领导力三板斧，你是不是能看出来阿里巴巴九板斧的影子？</p><p>不管怎么样，终于，看到腾讯从管理角度对行业进行理念与模式输出，可喜可贺。</p><p> <strong>三</strong> </p><p><strong>网易的阴性领导力</strong></p><p>最后，再看另外一个大厂的互联网领导力理念。</p><p>“阴性领导力”理念的提出者是网易项目管理专家雷蓓蓓，她写过一本书《网易一千零一夜》，值得推荐。</p><p>网易这个“阴性领导力”（高感受力+高反思力+高感知力），跟阿里巴巴提出的“雌雄同体”的有点异曲同工。</p><p>阴性领导力的理念提出有几个背景：</p><p><strong>一、互联网目前主流的领导风格</strong>，呈现强烈的阳性特征，强势的，结果导向的、简单粗暴的，这种命令控制型的领导模式局限在于，周边遍布着不满情绪和压抑，久而久之影响组织的创造力。</p><p><strong>二、伴随人工智能的兴起</strong>，依赖数据计算和逻辑处理的工作，将会越来越多被替代，而从心出发，具备高感受力、高反思力、高感知力的阴性领导力，将代表着下一代领导力的未来。</p><p>“阴性领导力”核心内容如下：</p><p><strong>1、高感受力</strong></p><p>所谓高感受力，会关注冰山下每个人细微的感受、感觉和感情，而不只是硬邦邦的逻辑、推理和结果。</p><p>作者认为，具备高感受力，首先是一个让人觉得有温度的leader。</p><p>当一件事情遇到困难，持续的努力都没有起色，TA会问，你需要什么帮助？然后一起去找新的可能解法，而不是责问你为什么没有做好。</p><p>交待了几次的事情迟迟没有启动，TA会说“这件事情似乎不在你的兴奋点上，对吗？”，然后仔细听你的诉说，同时思考如何能够让你在做事的同时找到自己的发展。</p><p>一位温度的leader，总是能够最大程度激活个体的能量，通过组织的力量而非个人的力量，让团队完成远大的目标。</p><p><strong>2、高反思力</strong></p><p>所谓高反思能力，不再一味强势坚守自己的观点：“我是对的！你是错的！”而是，时常反观自省：“我可能想错了，原来还可以这样！”</p><p>高反思能力分为三个阶段：</p><p><strong>第一层次，反思通常发生在遭遇巨大变化之时</strong>，特别是面对巨大的打击和挫折，人会因此被迫产生一种自我回观，对之前的行为作出调整。</p><p><strong>第二层次，反思已经变成了一项周期性进行的活动</strong>，每走过一个阶段，就会触发自觉地总结回顾，为后一个阶段积蓄一些改变的动力。</p><p><strong>第三层次，主动反思的意识已经融入了血液</strong>，进行中一旦意识到问题，就会马上响应做出改进。响应速度之快，哪怕在事情发生的前后5分钟，其思维模式和行为模式都在不断进化。</p><p>作者认为，具备高反思能力的人，在心态、思维和意志上，都是非常开放的。一个人如果具备高反思能力，越是环境剧烈变化，越是会锻炼出极强的反脆弱能力。</p><p><strong>3、高感知力</strong></p><p>所谓高感知力，向内看，与初心连接。</p><p>作者说，“我们身边的很多人，包括我自己，从小努力学习，是为了考个好大学；长大后殚精竭虑，是为了找个好工作；然后我们兢兢业业经营自己的事业和人生，是为了得到他人的认可。</p><p>“我们给自己设定了一个又一个的目标，在人生的路上不断狂奔，却渐渐忘了自己为什么要出发。终有一日，某个新的挑战，某件事，某个触动，会让我们停下来，开始调转镜头，看向自己。”</p><p>具备高感知力的人，在践行的同时，会自带超敏锐的感知传感器，一边做一边感知一边调整，迭代反馈都在瞬间同步发生，这才是真正的“知行合一”小编觉得，如果阴性领导力翻译成感性领导力、柔性领导力，感觉也许更好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天读到腾讯大学文章《互联网领导者升级的7种武器》，有感而发，在互联网背景下，尤其互联网+企业，管理者的核心能力应该是什么，从哪些维度升级？&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行业咖眼中的互联网领导力五要素&lt;/strong</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="技术团队" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>技术 TL 的核心职责</title>
    <link href="http://ai.mak.cn/2019/04/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%20TL%20%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3/"/>
    <id>http://ai.mak.cn/2019/04/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%20TL%20%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2022-11-19T11:36:18.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术-TL-的核心职责"><a href="#技术-TL-的核心职责" class="headerlink" title="技术 TL 的核心职责"></a>技术 TL 的核心职责</h1><p>技术 TL 的核心职责</p><blockquote><p>在之前分享的文章《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655822815&idx=1&sn=be007e648940ecfac3dbccaef0b6c03f&chksm=bd74ee088a03671ebf9a2e3fc75bb5cd38c38f2f23c09f65792d8345f93737710d40f8af45f5&scene=21#wechat_redirect">如何成为优秀的技术主管？</a>》中，阿里巴巴高级技术专家云狄从开发规范、开发流程、技术规划与管理三个角度，分享对技术 TL 的理解与思考。</p></blockquote><p>今天的文章，他将继续深入探讨这一话题，从管理的角度分享技术 TL 的核心职责，主要分为如下几个方面与大家共同探讨、交流：</p><ul><li><strong>团队建设</strong></li><li><strong>团队管理</strong></li><li><strong>团队文化</strong></li><li><strong>沟通与辅导</strong></li><li><strong>招聘与解雇</strong></li></ul><p>互联网公司的技术团队管理通常分为两个方向：技术管理和团队管理，互联网公司的技术 TL 与传统软件公司的 PM 还是有很大的区别。</p><p>传统软件公司的 PM 更多注重于对项目的管理，包括项目任务拆解、项目进度以及风险等。</p><p>对于多数互联网公司而言，技术 TL 更多的职责不再局限于项目角度，而是对业务与技术都要有深入的了解，就像黑夜里的灯塔，能够引导和修正团队成员前进的航向。</p><p>综合技术和业务角度去深度思考问题，具备一定的前瞻性，并在技术领域投入持续的学习热情，向团队成员传道，补齐短板，提高整个团队的战斗力。</p><p>技术 TL 职责不仅需要制定日常规范，包括开发规范、流程规范等，推动规范的落地，以公有的强制约定来避免不必要的内耗。</p><p>另外一多半的时间可能花在了开发任务分解分配、开发实践、技术架构评审、代码审核和风险识别上，剩余的时间则花在为了保障系统按时交付所需的各种计划、协作、沟通、管理上。</p><p>管理大师彼得·德鲁克说：“组织的目的，就是让平凡的人做出不平凡的事。”</p><p>然而，不是任何一群平凡的人聚集到一起，都能做出不平凡的事。甚至一群优秀的人聚集到一起，也可能只是一个平庸的组织。</p><p>大到一个国家，小到一个团队，任何一个卓越的组织，都必须有一个卓越的领导者。领导者是一个组织的灵魂，领导者在很大程度上决定了组织所能达到的高度。</p><p>阿里有句土话“平凡人、非凡事”，技术团队同样如此，管理者的战略眼光、管理方法、人格魅力等，都会给团队的工作结果带来决定性的影响。</p><p>其实每个公司、每个团队的背景不太一样，从管理学的角度探讨一些问题，没有统一标准的答案，本文中一些观点仅是个人观点，更多是我个人成长为技术 TL 的一些观点理念。</p><p>同时我也是吸取了前辈们一些优秀的管理理念，包括我最为尊敬的通用电气 CEO 杰克·韦尔奇、苹果 CEO 乔布斯、Intel CEO 格鲁夫，国内我最推崇的技术管理者 Robbin（丁香园的技术副总裁）。</p><h3 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h3><hr><p>从 2014 年开始带这块业务技术团队，至今有 5 个年头。回想起来，团队管理中所有能遇上的问题都遇到过了。</p><p>其中的磕磕绊绊数不胜数，完全是在实践当中吸取教训，团队建设这块在这里和大家简单分享一下，当然这里面也有做得不够好的地方。</p><p>在阿里每个人都能感受到拥抱变化，基本上每年组织架构都会调整，甚至有些团队每半年都会调整一次。</p><p>2014 年我也算是被分配到这个团队负责这块业务，这块业务是集团收购一家子公司的业务，整个团队文化和技术体系与阿里有很大的差异化。</p><p>一般来说新官上任三把火，新的技术 TL 空降之后往往会大肆招人，快速推进改革，而且有些技术 TL 喜欢把原来的一些旧将搬进来。</p><p>当时我没有急于这么去做，没有招过一个新员工，而是立足于稳定现有的团队，主要基于以下原因：</p><ul><li><p><strong>团队和业务了解不够深：</strong>对于目前团队的人员以及业务，我不够了解，不清楚这里面有哪些坑和陷阱，一旦初战不利，领导的信任度被透支，在公司恐怕难有立足之地，更不用谈论改造团队，发挥自己的才能了。</p></li><li><p><strong>流程与制度：</strong>针对团队现状存在的一些问题，我初步判断并不是人的问题，很多问题是一些组织、流程、制度上的问题。</p><p>我认为只有好的制度才能造就好的团队，在没有解决现有团队的痼疾之前招聘新人，不但不会带来新的生产力，反而会造成团队的混乱，应该先打下一个好的根基，再招人，才能事半功倍。</p></li><li><p><strong>团队安全感：</strong>不想让团队现有的成员感觉一朝天子一朝臣，担心自己在团队中会被边缘化，成为弃儿。另外一方面能够让现有团队心理比较安全，可以安心地好好工作，不至于发生更多的动荡。</p></li></ul><p>经过了几个月的摸底了解，大概清楚当时团队存在的一些问题和原因：</p><ul><li><strong>业务配合不规范：</strong>产品、运营、研发部门之间配合没有建立合理的工作流程，比如对于产品需求的 PRD 评审没有标准，对于运营需求没有量化指标，大家都是疲于奔命做需求，导致大家的积极性不够高。</li><li><strong>跨团队协作混乱：</strong>跨部门之间的工作配合毫无规范可言，部门之间相互推诿，随便什么业务人员都会随时给研发人员下命令，长此以往，伤害了研发团队的积极性。</li></ul><p>针对以上问题，我主要把协作流程规范梳理了一番，制定了相对合理、规范的产品合作流程，同产品同学约法三章，明确了 PRD 输出的标准和规范，运营的业务需求也统一由产品输出，杜绝一句话需求。</p><p>同产品、前端、UED、QA 团队的协作统一标准流程，下游对上游依赖方输出的工作必须有明确的标准规范，口头说的统统无效，拒绝合作。</p><p>针对跨团队协作乱的情况，我特别想说明一下，由于研发部门不是直接创造收入的业务部门，而是承担业务部门的服务者角色。</p><p>作为一个服务者，往往站在一个被动和弱势的位置上，很容易被业务人员举着收入的大棒指挥你无条件的服从。</p><p>业务部门人员随便指派任务，随意变更需求，团队同学无所适从。这样一来，部门内部无论怎样合理的计划都会被外部的力量轻易打破，让团队同学无所适从，导致大家的工作积极性不高，喜欢互相推卸责任。</p><p>久而久之，员工就产生了自我保护意识，凡工作尽量往后退，凡责任尽量往别处推，不求有功但求无过。</p><p>为打破员工养成的这种自我封闭的保护意识，鼓励员工更加积极主动做事情，我能够做的就是把这些责任都扛在自己身上，亲自去协调每项工作。</p><p>让团队成员没有后顾之忧，让团队同学相信我可以搞定他们担心的事情，出了任何问题我可以来背锅，给自己的团队创造一个相对宽松和自由的工作空间，保护团队不被外部的各种杂事伤害到。</p><h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><hr><p>人往往会高估自己而低估别人，很多管理者都会觉得手下交上来的工作做得不够完美，这里考虑不周那里做的啰嗦，但很多时候你只是看到了他人不擅长的地方，或者只是对方和你的出发点不同给出了不同的解决方案而已。</p><p>很多时候，我们并不如自己想象的那么强。管理者在充分理解一些管理的理念之后，不断地在实际的管理工作中去实践并收集反馈和迭代，这样才能够形成自己的管理风格，并找到最适合当前团队的管理方法。</p><p>作为一个团队的管理者，通常会有两种风格管理策略，简要概括为：</p><ul><li><strong>集权式的管理风格</strong></li><li><strong>放权式的管理风格</strong></li></ul><p><strong>集权式管理</strong>：管理者的风格是偏细节的，定义清晰的工作目标，并且把工作目标分解得非常细致，让手下的团队能按照整个计划步步为营往前推进，这是一种风格，相对来讲比较集权。</p><p>可以说我带这个团队的第一年是这种风格，我甚至会参加每一次需求评审，无论需求大小，会和研发同学一起去写代码。</p><p>对研发团队我会做详细的 Code Review，亲自带领研发团队做技术交流和分享，参与技术讨论确认架构方案，这样以来和大家建立起了充分的信任。</p><p><strong>放权式管理</strong>：定义大的目标，把握大的方向，做关键性的决策。但是并不深入每个细节去管控手下团队的执行细节，以结果为导向。</p><p>我到这个团队一年后，业务流程已经清晰的建立起来了，骨干员工在业务上能够完全领会并且达到我的要求，这个时候放权可以充分调动团队的自主性和创造性，多数技术人员他们喜欢被领导，不喜欢被管理。</p><p>以上这两类管理风格没有对错之分，究竟哪种方式更适合完全取决于团队的状况。</p><p>其实这里我更想说一下关于放权式的管理风格，对于一个制度刚刚建立，流程还没有跑顺畅，团队残缺，骨干员工业务能力不及格的团队，采用放权式管理是错误的。</p><p>你必须事无巨细，从第一线的业务细节抓起，手把手的带员工，教会他们怎么正确的做事情，怎样达到你的要求，手把手的培养业务骨干，搭建团队核心架构。</p><p>这些年我看到过太多的案例，管理层自己从不真正深入业务，也缺乏对业务的深刻理解，没有找到问题的本质原因。</p><p>总是寄希望于招人来解决问题，结果换了一茬又一茬人，问题永远解决不了，而且从来不深刻反思自己是否亲自尝试解决业务问题。很多时候架构反映出来的问题，其实是组织、流程的问题。</p><p>总之，作为管理层，如果自己没有深入一线去发现问题，自己动手去解决问题的决心和勇气的话，那这个团队很难有新的突破和成功。</p><h3 id="团队文化"><a href="#团队文化" class="headerlink" title="团队文化"></a>团队文化</h3><hr><p>在我刚参加工作的前几年，就听过一些关于团队文化和企业文化的一些概念，并没有特别深刻的印象。</p><p>尤其我读了《基业长青》这本书后，让我感受到对于一个企业而言，决定短期的是技巧，决定中期的是战略，决定长期的是文化。</p><p>企业文化对一家公司来说真的很重要，同样团队文化对于一个团队来说也很重要，我在带团队之初也曾经忽视了团队文化的冲击。</p><p>在带领这个团队之初，我私下找一些团队同学做 1on1 沟通，我发现这里面的问题还是比较严重的。</p><p>很多人为了避免故障遭受惩罚，不敢去重构优化代码，把自己封闭到一个很小的圈子，也没有过多的追求和理想，以前也没有末位淘汰机制，大家觉得可以继续吃大锅饭。</p><p>当时部门都是工作多年的老人，老的风气和习惯已经形成了很顽固的不良文化，工作情绪受到很大的影响。</p><p>老的不良的文化包括：</p><ul><li><strong>做事情没有积极性。</strong></li><li><strong>永远不承认自己的错误，永远找借口推卸责任，永远都是别人的问题。</strong></li><li><strong>不求有功但求无过；责任心差，对待工作自我要求低。</strong></li><li><strong>对工作安排喜欢讨价还价。</strong></li></ul><p>在一个不好的文化氛围下，优秀的员工会被排挤，团队没有向心力，也很难留住好的人才，员工流失率会非常高。</p><p>我认为衡量一个团队文化氛围是否有吸引力，有一个很重要的指标，是新员工的流失率：</p><ul><li>如果一个团队氛围非常好，新员工入职以后往往能够快速融入进来，流失率很低。</li><li>如果团队氛围差，新员工入职以后比较茫然难以融入，往往会很快离职，流失率非常高，实际上留不住新员工远远比留不住老员工更可怕。</li></ul><p>接下来我希望给团队树立的文化是：</p><ul><li><strong>坦诚，公开，透明。</strong></li><li><strong>平等相处，消除等级感。</strong></li><li><strong>工作气氛轻松，团队关系和谐。</strong></li><li><strong>敢于担当，主动承担责任。</strong></li><li><strong>成就他人，乐于分享。</strong></li></ul><p>关于团队文化这个话题其实很泛，可以单独写一篇文章出来的。这里我主要基于团队文化以上几点，谈一下我的一些个人的看法。</p><p><strong>坦诚的力量</strong></p><p>首先，我觉得坦诚无论对于一个 TL 还是团队成员来说，坦诚也是一种价值观，对于一个团队的发展来说是非常重要的。</p><p>作为一个 TL，带领一支团队，我觉得最重要的是 TL 本人必须做到坦诚的态度，只有对团队坦诚，才能和团队之间形成信任，只有和团队形成了信任，才能成为一支默契的团队。</p><p><strong>通用电气 CEO 杰克·韦尔奇说过</strong>：什么是信任？当一个领导真诚、坦率、言出必行的时候，信任就出现了，事情就是这么简单。为什么坦诚精神能行得通？很简单，因为坦诚有化繁为简的力量！</p><p>坦诚的性格是管理者最基本的要求，只有管理者坦诚，才能获得团队的信任，作秀式的演讲和奖励并不能够真正获得团队的心，还是需要在工作中脚踏实地一点一滴去做好最平凡普通的事情。</p><p>坦诚能够让你直面自身的缺陷，有针对性地改变自己，解决团队的问题，造就一个互相信任的团队氛围。</p><p>我见过一个比较典型的案例，日常工作中主管对于下属不够坦诚，下属与主管的平时一些工作沟通中，下属做的不够好的地方，主管不及时进行沟通与辅导，结果最后 KPI 考核被打了低绩效。</p><p>换位思考一下，这个被打低绩效的人是我，我也会不服气，有问题你为啥不提前告诉我，让我提前去改正。</p><p>对待下属要有勇气，敢于指出他们的问题，对于表现不好的员工要敢于批评和管理，例如为什么解雇你。</p><p>这些谈话和冲突往往让人感到不舒服，我也承认每次谈低绩效是硬着头皮的，但是你必须有这样的勇气，坦诚不仅仅要对那些表现良好的人，还要对那些表现糟糕的人。</p><p>苹果创始人乔布斯是一个对自己、对别人坦诚得可怕的人，坦诚的残酷，直面事情最真实的一面。</p><p>的确坦诚的态度在很多时候会让别人感觉不舒服，乔布斯粗暴的坦诚态度也备受争议，但我觉得，如果你是一个结果导向的人，还是应该尽量坚持坦诚的态度，否则最终的结果可能远远偏离你的目标。</p><p><strong>允许你的下属 challenge 你</strong></p><p>其次，我再聊一下关于平等相处，消除等级感，这点我觉得最重要的是让大家感受到你的亲和力，不是一个高高在上的领导。</p><p>比如很多时候团队一些技术方案的决策不是你一个人来决定，有时候还是要善于倾听一下团队成员的意见，要允许团队成员 challenge 你。</p><p>其实，国内外要求下属服从的企业文化很普遍，这不一定是坏事，特别是公司如果有想法的人太多，想法又无法统一起来，公司的整体战略呈现精神分裂状态，那基本上就离死不远了。</p><p>所以管理层统一公司战略，一线员工强调使命必达。</p><p>国内的外企格外强调下属的服从性，把这一点作为员工的基本职业素养来培训，常用来讲解的故事就是《把信送给加西亚》，强调上司安排一项工作以后，下属不允许谈任何条件，不允许 challenge 上司，必须无条件服从，克服一切困难也要完成工作任务，以解领导之忧。</p><p>这种执行力让上司感觉很舒服，而且公司管理实施难度也比较低。</p><p>多数管理者都喜欢比较听话的下属，认为顺从的下属更好用。心态上高人一等，不会放低心态倾听下属的意见，即使自己错了也不会承认错误，一方面害怕自己的权威被挑战，另外害怕向下属认错，觉得抹不开面子。</p><p>我不是圣人，作为 TL 曾经也犯过一些错误，我也曾私下里和个别同学道过歉。放开心态，不需要过多的太在意别人的看法，这些我觉得都是无所谓的小事。</p><p>从我个人自身的一些经历来看，其实一味地要求下属服从是有害的，要适当允许你的下属 challenge 你。</p><p>如果一味地要求下属服从，不能进行任何反驳，长时间下来会导致团队的人缺乏思考，只是一味的按照 TL 的想法去执行，当下属内心并不认可工作本身，仅仅出于职业性完成工作，成绩最多是合格，很难达到卓越。</p><p>同时会导致下属缺乏工作积极性主动性，容易养成下属逃避责任的习惯。</p><p>相反我觉得作为 TL 一定要鼓励下属积极主动地思考，让下属能够自己设定成长目标，对工作拥有归属感和责任感。</p><p>尽量给予下属更自由的空间，不要设置过多形式主义的约束；要允许下属去 challenge 你，参与你的决策，甚至质疑你的决策。</p><p>用这种方式增加下属对工作的归属感，工作责任心更强，更积极主动，能够自我驱动。</p><p>当你的决策错误的时候，下属可以帮你纠错，集体的智慧毕竟高于个人，俗话说“三个臭皮匠赛过诸葛亮”。</p><p><strong>Owner 意识</strong></p><p>“Owner 意识”主要体现在两个层面：</p><ul><li><strong>认真负责的态度。</strong>认真负责是工作的底线。</li><li><strong>积极主动的精神。</strong>积极主动是“Owner 意识”更高一级的要求。</li></ul><p>自私确实是人的天性，不是自己的东西，很难谈什么责任感，更不用说主动性了。</p><p>因此，团队管理就是要努力地培养大家的责任感，主人翁意识，想做到这一点，就需要增强团队成员的参与感，让他们知晓并理解所做事情的价值、来龙去脉，不断地强化使命感。</p><p>例如可以将系统、业务范围等根据团队成员的兴趣点、以往项目经历等多种因素划分给指定人负责，并明确赏罚机制。</p><p>要清晰地传达一种思想，那就是：这块东西就是你的，干好了评优、升职、加薪等都会优先考虑；干不好，出事情了，你要负责，我也会负责。</p><p>如果有一天你看到团队成员像呵护自己的孩子一样，去对待自己的工作，那么你的目的已经达到了，他已经完全具备 Owner 意识了。</p><p><strong>建立学习型的组织</strong></p><p>最后一点我要谈的是建立学习型的组织，团队成员要尽可能地分享自己的知识和想法，大家互相学习，也通过分享能够总结自己学习过程中零散的知识点。</p><p>如何建立人才梯队的，其实就是要建立学习型组织，让大家积极参与学习与分享。</p><p>具体做法 KPI 里设置一项技术分享与团队贡献，团队内部轮流进行技术分享，一方面让大家去学习、研究一些前沿技术。</p><p>尤其是团队可能会用到的一些技术储备，如果他真的能把这个技术给大家讲明白的话，那他就是真的掌握了，同时也让其他人开始了解并学习这项技术，同时还能够锻炼其演讲与口才。</p><p>鼓励团队成员敢于去分享，乐于去分享，开放心态成就他人。把技术培训和分享坚持下去，形成这样一种学习型的文化以后，你就会发现整个研发团队的技术能力的提升速度是非常惊人的，并且不会再占用太多额外的时间。</p><p>当你再招一个资历较浅的新员工时，他也能在这种环境中快速提升，通常半年左右时间就能达到非常好的水平。</p><p>当然，一开始的团队可能没有这样的意识，就需要你作为管理者强行去推动，把要求列入 KPI，很认真地考核他，慢慢地，团队就会形成这样的氛围和文化。</p><p>当然建立这种学习型的组织，也可以建立一些读书分享会，把读的一些书籍感受分享给大家，另外一点团队的 Wiki 知识库一定要建立起来，让团队同学把一些日常的技术方案、项目总结、故障总结通过文档的形式积累起来。</p><h3 id="沟通与辅导"><a href="#沟通与辅导" class="headerlink" title="沟通与辅导"></a>沟通与辅导</h3><hr><p>根据美国普林斯顿大学的调查报告，在所有对工作产生影响的因素中，沟通占的比例高达 75%。而我们工作中出现的 80% 问题都是由沟通不当造成的，可见沟通的重要性。</p><p>多数时候，我们只想着表达自己的观点，只关注自己想说什么，我们会尽量使用漂亮的 PPT、华美的语言、一堆的数据、甚至引章据典，而不关心别人听懂没有，没有思考别人是否想听，别人是否听得懂。</p><p>沟通在我们的工作中无处不在，你会发现尤其在技术这个圈子里，能够进行高效沟通的人占比会更少一些。</p><p>沟通按照沟通对象类型通常分为向下沟通(同下属沟通)、横向沟通(跨团队沟通)、向上沟通(同老板沟通)，接下来只讨论如何同下属进行沟通，<strong>最为有效沟通方式</strong>：<strong>一对一沟通。</strong></p><p>一对一沟通，又被称作一对一会议、One-on-one 等，是互联网公司常用的沟通方式。</p><p>一对一沟通虽然被广泛使用，但是涉及的文章却很少，这里我给大家推荐《格鲁夫给经理人的第一课》、《创业维艰 : 如何完成比难更难的事》，这两本书有更多关于一对一沟通的介绍。</p><p>格鲁夫是 Intel 公司的总裁，成功带领 Intel 公司完成了从半导体存储器到微处理器的转型，也是我非常欣赏的一位 CEO。</p><p>《创业维艰》的作者本·霍洛维茨是硅谷的顶级 VC，投资了 Facebook、Twitter 等公司。</p><p>在《格鲁夫给经理人的第一课》一书中，格鲁夫对「一对一沟通」的介绍如下：</p><blockquote><p>在英特尔，一对一会议通常是由经理人召集他的部属召开的，这也是维系双方从属关系最主要的方法。<strong>一对一会议主要的目的在于互通信息以及彼此学习</strong>。经过对特定事项的讨论，上司可以将其技能以及经验传授给下属，并同时建议他切入问题的方式；而下属也能对工作中碰到的问题进行汇报。</p></blockquote><p>在我看来，技术研发同学多数比较内向，不轻易向别人表达自己内心的一些想法。</p><p>一对一沟通的意义是可以使得信息从下而上地传递，同时可以把一些疑问、想法、意见、问题、规划等等和管理者做沟通，从而获得在其它渠道不易获得的信息，保证透明。</p><p><strong>1on1 沟通聊什么</strong></p><p>在《创业维艰：如何完成比难更难的事》这本书中专门拿出了一节提到了一对一沟通（1on1），具体聊那些内容给了一些建议。</p><p>作为 TL 我通常会与团队的人聊以下话题：</p><ul><li>你有没有认为自己的价值和能力被低估了吗？为什么？</li><li>你觉得在工作中能学到东西吗？你最近学到了什么？你还希望在哪些领域进行学习？</li><li>近期这段时间，对自己有哪些满意、不满意的地方？</li><li>目前工作中，有哪些困惑？希望我如何去帮助你？</li><li>对团队和我的一些期待和建议。</li><li>在公司战略和目标方面，你最不清楚的是什么?</li></ul><p>以上这些内容，除了在一对一沟通中交流之外，很难找到别的渠道来有效解决。</p><p>通过这些 1on1 的沟通，真的可以得到很多反馈信息，甚至得到的一些信息令我感到吃惊，原来还有这些细节问题我没有做好。</p><p>一对一沟通构造了一个渠道，这个渠道自下而上，使得以上这些内容都能够被倾听，从而被解决。</p><p><strong>1on1 沟通的一些注意点</strong></p><h4 id="①找个私密的环境"><a href="#①找个私密的环境" class="headerlink" title="①找个私密的环境"></a><strong>①找个私密的环境</strong></h4><p>找个空会议室或者别人听不到谈话的角落，不要在工位或嘈杂的环境中进行，因为私密的环境才能降低沟通中某些话被他人听到的心理压力，才能更轻松和真实的表达自己。</p><h4 id="②最好提前告知-1on1-的团队成员"><a href="#②最好提前告知-1on1-的团队成员" class="headerlink" title="②最好提前告知 1on1 的团队成员"></a><strong>②最好提前告知 1on1 的团队成员</strong></h4><p>一般需要提前 1 周把 1on1 沟通的话题、具体时间通知到团队成员，这样的好处是团队成员可以提前准备下聊的内容，因为临时性的沟通很容易出现因为人类记忆力的问题，导致一些想聊的问题在当时没想到。</p><h4 id="③定期进行"><a href="#③定期进行" class="headerlink" title="③定期进行"></a><strong>③定期进行</strong></h4><p>在《创业维艰》一书中，本·霍洛维茨认为一对一沟通需要保证至少一个月一次。而格鲁夫认为，需要根据部属对工作的熟悉度，而进行不同程度的掌控。</p><p>另外，格鲁夫还认为，事情变化的速度也是影响一对一沟通频率的因素。作为技术研发部门，我通常会 1-2 月进行一次 1on1 沟通。</p><h4 id="④用心倾听并行动"><a href="#④用心倾听并行动" class="headerlink" title="④用心倾听并行动"></a><strong>④用心倾听并行动</strong></h4><p>沟通要有效，用心倾听、保持真诚是必要的前提，否则员工不可能将心中的问题提出来。</p><p>保持真诚需要不敷衍任何团队同学提出的问题，不管这个问题有多尖锐。如果你也不知道如何解决这个问题，不妨和团队同学一起讨论讨论，看看大家能不能一起寻找可行的办法。</p><p>切忌不要讲空话和套话，一旦团队同学发现这是一个无效的沟通渠道之后，「自下而上」的通道就被关闭了。</p><h4 id="⑤适当引导"><a href="#⑤适当引导" class="headerlink" title="⑤适当引导"></a><strong>⑤适当引导</strong></h4><p>并不是每一个员工都懂得一对一沟通的重要性，也不是每一个员工都能主动倾述问题，寻求帮助。很多程序员的性格都是比较内向的，有一些甚至不善于表达自己。</p><p>所以，虽然员工是一对一沟通的「主角」，但是上司也是需要进行适当的引导。</p><p>对于上司已经发现的员工工作中的困难，可以适当的主动提出来，以便于更好地讨论，这也会让员工感到很体贴。</p><h3 id="招聘与解雇"><a href="#招聘与解雇" class="headerlink" title="招聘与解雇"></a>招聘与解雇</h3><hr><p>对于一个团队来说，人才是最核心、关键的。招聘和解雇尤其对于一个新上任的技术 TL，都是一个很大的挑战，接下来我们重点讨论这两个话题。</p><p><strong>招聘</strong></p><p>招聘很多时候取决于公司在什么发展时期，需要招聘什么样的人。在初创时期，本不太可能招聘到清一色的专家人才，这个时候活下来比啥都重要，态度和味道是重点看的。</p><p>在高速发展之后，可能需要引进能带来新思路的一些人才，这取决于业务、技术、组织三者的对齐。那么这个时候，就是既要高技能，又要好的做事态度、习惯。</p><p>在搭建技术团队招聘前，要先明确所搭团队的类型，一般来说有三种不同类型的技术团队，即：</p><ul><li><strong>项目驱动型</strong></li><li><strong>业务驱动型</strong></li><li><strong>技术驱动型</strong></li></ul><p>不同类型的技术团队在招聘时也有很大的不同，比如技术驱动型团队你可能需要一个在中间件、语言功底非常深厚、有大局观的人，业务驱动型的团队可能需要有业务 Sense，并且具备良好技术和业务架构能力的人。</p><p>在招聘这条路上，我也走过弯路，一开始我对候选人的背景、语言功底、架构能力以及运维、数据库方面比较关注，希望能招到全栈的技术人才，后来发现我忽视了一个很重要的点沟通与协作能力、态度。</p><p>后来导致新人来到团队后，虽然技术牛 B，但喜欢闭门造车，不喜欢和别人沟通，团队协作能力不够好，整体产出和效率不高。</p><p>所以在招聘新人的过程中，不能够只盯着候选人有什么经验，会什么框架等技术面，也需要着重考量他们的综合素质，一个领导力好的候选人，能够非常快速地融入团队，也能够非常快的学习一些知识。</p><p>招聘步骤：</p><ul><li><p><strong>根据搭建团队的目标，做好招聘计划</strong>。根据团队自身的定位，招聘合适的人才。</p><p>有几点需要 TL 特别关注的，作为 TL 要对候选人的成长负责，切忌因人设岗、因单独项目而招人。</p><p>比如前端团队招聘一些后端开发，工程团队招聘算法，这样以来可能会导致候选人进来后很难融入到团队，没有存在感，长时间下来会导致新人离职。</p></li><li><p><strong>确定招聘需求（定岗定责）</strong>：列出每个岗位的职责、需要具备的技能及其他要求。招聘需求归根结底是需要什么样的人，与整体业务和组织发展匹配。</p></li><li><p><strong>合理利用人才招聘渠道</strong>。从我自身的经历来看，人才招聘渠道多数通过互联网招聘渠道以及朋友推荐更可靠一些，对于高级别的人才可以采用猎头定向挖人。</p></li></ul><p><strong>人才筛选</strong>：作为技术面试官，对于人才的筛选也是非常重要关键的一个环节，要根据自己团队的目标来选取合适的人才，设定完成的时间期限，将面试的重点放在专业技能、管理能力、价值观（公司认同）等方面。</p><p>一般要求如下：</p><ul><li><strong>和岗位需要的专业技能高度匹配</strong>：专业技术技能面试过关，定岗定责。</li><li><strong>沟通力强</strong>：理解公司的业务，知晓管理层，了解公司的发展方向。</li><li><strong>责任心</strong>：凡事有交代，件件有着落，事事有回音。</li><li><strong>靠谱并自带正能量</strong>：不抱怨，主动解决问题，懂得纪律的重要性，一诺千金。</li><li><strong>价值观认同</strong>：认同公司，有目标有理想、有激情有冲劲。</li><li><strong>背景调查</strong>：非常有用的一个办法，可以大幅度降低选人风险，不用怕麻烦，这个工作的付出永远都是值得的。</li></ul><p>另外，我想说的对于技术面试官需要有一定甄别人才的能力，同时有意识地提高这方面的能力。</p><p>我提供以下几点建议给技术面试官：</p><ul><li><p>如果对候选人有些犹豫和纠结，请你放弃这个候选人，你最担心的问题往往很大概率上会发生。</p></li><li><p>明确我们招聘的候选人标准，比如后端 Java 研发：Java 基础和分布式领域知识技能考察是必须的，少问记忆性问题和太理论性问题，更多地从候选人的一些实践经历中，提取出对这个候选人的更有价值的判断。</p></li><li><p>一面非常重要，要保证客观、公平，后面的交叉和终面往往参考前面的评价反馈，我们今天不仅是为我们的团队选拔人才，更是为公司选拔人才，还是要高标准的要求。</p><p>从心理学角度讲，必须要交叉面试，而且交叉面试官给出的反馈往往是比较客观、中肯的，而且要以交叉面试官的评价为主。</p></li><li><p>面试官切忌拿自己擅长的东西去考察候选人，需要认真的看候选人的简历，从候选人的经历中去考察这个人的综合能力。</p></li></ul><p>一个团队的健康发展，最重要的是核心技术人，所以招聘工作必须谨慎，一旦有人加入就等于同上了一艘船，其中的纠结、痛苦、欢喜都要一起面对。</p><p>招募一个不合适人员的成本不仅仅是薪资那么简单。所以请一定要放过那些经验不错、资质不错但是很犹豫匹配度、落地融入堪忧的面试者，其结局大部分都是彼此痛苦。</p><p>作为技术 TL 最成功的是招到比你更优秀的人，你不需要担心自己会不会被取代：</p><ul><li><strong>一是成就个人和成就团队</strong>，作为 TL 应该抱着如何成就团队的发展思路，不能让自己成为天花板，本身技术就不应该是你最擅长的事情！</li><li><strong>二是兼容并蓄，发展多样性</strong>。刘邦善用汉初三杰，单项能力不如韩信、张良。TL 不要以自己的长短来衡量招聘的人，而是看团队技能视图的缺口和发展项。</li></ul><p><strong>解雇</strong></p><p>解雇员工通常更多的是针对触犯公司文化、原则红线，或者持续无法跟上公司节奏的员工进行的处理。</p><p><strong>在阿里也有这么一句土话：</strong>“如果你没有开除或解雇过一位员工，算不上真正合格的管理者”，大多数技术管理者性格比较随和，不喜欢开除员工。</p><p>但是出现触犯红线的员工或者跟不上节奏的员工，尤其是不认可团队价值观的同学，会把一些负面情绪、行为影响到团队其他同学，因此需要杀伐决断，当机立断采用合适的方法让员工离开。</p><p>当然，如果只是能力跟不上的员工，你也可以推荐给其他公司适合的岗位，让和自己一起奋战过的兄弟有一个好归宿，也会让在职的员工感觉温暖。</p><p>整体上“慈不掌兵”，在开人这件事情上，高级管理者不要过于犹豫，为了一两个人最后影响整体团队的士气反而得不偿失。</p><p>多数互联网公司对于技术人员都有相应的 KPI 考核，对于达不到预期的人员会进行淘汰。</p><p>解雇尤其对于新上任的技术主管还是有一定挑战的，我相信人的本性还是善良的，作为技术 TL 不想让团队成员面对这一难题，包括我自己在内。</p><p>一家公司在成长，组织肯定要升级，人员的新老交替也是正常的。如果团队成员的表现达不到预期，不通过 KPI 考核机制告诉他，也许他不会意识到自身的一些问题，他永远不会成长起来，相对短期这些经济回报而言，个人的成长更为关键重要。</p><p><strong>在阿里有这么一句土话：</strong>“不经历 3.25 的人生，不是完美的阿里之旅”，当你处于发展的低谷时，经历一次末位考核结果也许能够让他彻底清醒，认识到自己的不足，彻底激发自己的潜能，能够触底反弹。</p><p>心理学上有个著名的邓宁-克鲁格效应，又称达克效应。大意是，人很容易对自我产生认知偏差，最简单来说，就是会过于高估自己。</p><p>达克效应的曲线图：</p><p><img src="https://aimak.cn/blog_img/dakeer.jpeg" alt="图片"></p><p>上面的图片上反映出，大部分人其实都处于愚昧之巅。人能够成长为智者和大师要先从愚昧之巅，掉到绝望之谷，然后辛苦攀爬，积累知识和经验，成为智者和大师。</p><p>有担当的管理者的一个重要责任，就是把下属从愚昧之巅推向绝望之谷，至于能否爬上开悟之坡，看个人造化。</p><p>一个合格的技术 TL 必须要给团队成员塑造一个绝望山谷，同时还要让他看到一个开悟之坡，这样员工会不断突破自我。</p><p>作为一个有担当的管理者，我们不应该是一个老好人的角色，也要有冷酷无情的一面。</p><p><strong>阿里也有一句土话：</strong>“心要仁慈，刀要快”，当团队中出现一些达不到团队要求的人，管理者应该主动去拉他一把，如果多次尝试，最终达不到预期，应该请他离开。</p><p>因为到了中途，再被残酷淘汰，无论对组织，还是对个人，损失都更大。</p><p>每一位开发者眼中，都有自己理想中的技术管理者。你认为优秀的技术 TL 身上有哪些特质？欢迎在留言区讨论，与大家分享交流。</p><p><em>作者**：</em>云狄*</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术-TL-的核心职责&quot;&gt;&lt;a href=&quot;#技术-TL-的核心职责&quot; class=&quot;headerlink&quot; title=&quot;技术 TL 的核心职责&quot;&gt;&lt;/a&gt;技术 TL 的核心职责&lt;/h1&gt;&lt;p&gt;技术 TL 的核心职责&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在之</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="技术团队" scheme="http://ai.mak.cn/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Redis 开发规范</title>
    <link href="http://ai.mak.cn/2019/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E4%BA%91%20Redis%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2019/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%98%BF%E9%87%8C%E4%BA%91%20Redis%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2022-11-19T09:58:22.845Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在使用阿里云Redis的开发规范，从下面几个方面进行说明。</p><ul><li><p>键值设计</p></li><li><p>命令使用</p></li><li><p>客户端使用</p></li><li><p>相关工具</p></li></ul><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1、key名设计"><a href="#1、key名设计" class="headerlink" title="1、key名设计"></a><strong>1、key名设计</strong></h4><h5 id="可读性和可管理性"><a href="#可读性和可管理性" class="headerlink" title="可读性和可管理性"></a>可读性和可管理性</h5><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ugc:video:1</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h5><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125;简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125;。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="不要包含特殊字符"><a href="#不要包含特殊字符" class="headerlink" title="不要包含特殊字符"></a>不要包含特殊字符</h5><p>反例：包含空格、换行、单双引号以及其他转义字符</p><h4 id="2、value设计"><a href="#2、value设计" class="headerlink" title="2、value设计"></a><strong>2、value设计</strong></h4><h5 id="拒绝bigkey"><a href="#拒绝bigkey" class="headerlink" title="拒绝bigkey"></a>拒绝bigkey</h5><p>防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p><h5 id="选择适合的数据类型"><a href="#选择适合的数据类型" class="headerlink" title="选择适合的数据类型"></a>选择适合的数据类型</h5><p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)。了解下，Redis 为什么这么快？</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line"></span><br><span class="line">set user:1:age 19</span><br><span class="line"></span><br><span class="line">set user:1:favor football</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 19 favor football</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="控制key的生命周期"><a href="#控制key的生命周期" class="headerlink" title="控制key的生命周期"></a>控制key的生命周期</h5><p>redis不是垃圾桶，建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><h5 id="1、O-N-命令关注N的数量"><a href="#1、O-N-命令关注N的数量" class="headerlink" title="1、O(N)命令关注N的数量"></a><strong>1、O(N)命令关注N的数量</strong></h5><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><h5 id="2、禁用命令"><a href="#2、禁用命令" class="headerlink" title="2、禁用命令"></a><strong>2、禁用命令</strong></h5><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><h5 id="3、合理使用select"><a href="#3、合理使用select" class="headerlink" title="3、合理使用select"></a><strong>3、合理使用select</strong></h5><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><h5 id="4、使用批量操作提高效率"><a href="#4、使用批量操作提高效率" class="headerlink" title="4、使用批量操作提高效率"></a><strong>4、使用批量操作提高效率</strong></h5><p>1.原生命令：例如mget、mset。</p><p>2.非原生命令：可以使用pipeline提高效率。</p><p>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p><p>注意两者不同：</p><p>原生是原子操作，pipeline是非原子操作</p><p>pipeline可以打包不同的命令，原生做不到</p><p>pipeline需要客户端和服务端同时支持。</p><h5 id="5-不建议过多使用Redis事务功能"><a href="#5-不建议过多使用Redis事务功能" class="headerlink" title="5.不建议过多使用Redis事务功能"></a><strong>5.不建议过多使用Redis事务功能</strong></h5><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)。分布式事务不理解？一次给你讲清楚！</p><h5 id="6、Redis集群版本在使用Lua上有特殊要求"><a href="#6、Redis集群版本在使用Lua上有特殊要求" class="headerlink" title="6、Redis集群版本在使用Lua上有特殊要求"></a><strong>6、Redis集群版本在使用Lua上有特殊要求</strong></h5><p>1、所有key都应该由 KEYS 数组来传递，redis.call&#x2F;pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn” 2、所有key，必须在1个slot上，否则直接返回error, “-ERR eval&#x2F;evalsha command keys must in same slotrn”</p><h5 id="7、monitor命令"><a href="#7、monitor命令" class="headerlink" title="7、monitor命令"></a><strong>7、monitor命令</strong></h5><p>必要情况下使用monitor命令时，要注意不要长时间使用。</p><h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><h5 id="1、避免多个应用使用一个Redis实例"><a href="#1、避免多个应用使用一个Redis实例" class="headerlink" title="1、避免多个应用使用一个Redis实例"></a><strong>1、避免多个应用使用一个Redis实例</strong></h5><p>不相干的业务拆分，公共数据做服务化。</p><h5 id="2、使用连接池"><a href="#2、使用连接池" class="headerlink" title="2、使用连接池"></a><strong>2、使用连接池</strong></h5><p>可以有效控制连接，同时提高效率，标准使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    //具体的命令</span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(&quot;op key &#123;&#125; error: &quot; + e.getMessage(), key, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span><br><span class="line">    if (jedis != null) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="3、熔断功能"><a href="#3、熔断功能" class="headerlink" title="3、熔断功能"></a><strong>3、熔断功能</strong></h5><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><h5 id="4、合理的加密"><a href="#4、合理的加密" class="headerlink" title="4、合理的加密"></a><strong>4、合理的加密</strong></h5><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><h5 id="5、淘汰策略"><a href="#5、淘汰策略" class="headerlink" title="5、淘汰策略"></a><strong>5、淘汰策略</strong></h5><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p>其他策略如下：</p><p>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p><p>allkeys-random：随机删除所有键，直到腾出足够空间为止。</p><p>volatile-random:随机删除过期键，直到腾出足够空间为止。</p><p>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p><h3 id="四、相关工具"><a href="#四、相关工具" class="headerlink" title="四、相关工具"></a>四、相关工具</h3><h5 id="1、数据同步"><a href="#1、数据同步" class="headerlink" title="1、数据同步"></a><strong>1、数据同步</strong></h5><p>redis间数据同步可以使用：redis-port</p><h5 id="2、big-key搜索"><a href="#2、big-key搜索" class="headerlink" title="2、big key搜索"></a><strong>2、big key搜索</strong></h5><p>redis大key搜索工具</p><h5 id="3、热点key寻找"><a href="#3、热点key寻找" class="headerlink" title="3、热点key寻找"></a><strong>3、热点key寻找</strong></h5><p>内部实现使用monitor，所以建议短时间使用facebook的redis-faina 阿里云Redis已经在内核层面解决热点key问题</p><h3 id="五、删除bigkey"><a href="#五、删除bigkey" class="headerlink" title="五、删除bigkey"></a>五、删除bigkey</h3><p><strong>1.下面操作可以使用pipeline加速。</strong></p><p><strong>2.redis 4.0已经支持key的异步删除，欢迎使用。</strong></p><h5 id="1、Hash删除-hscan-hdel"><a href="#1、Hash删除-hscan-hdel" class="headerlink" title="1、Hash删除: hscan + hdel"></a>1、Hash删除: hscan + hdel</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void delBigHash(String host, int port, String password, String bigHashKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = new ScanParams().count(100);</span><br><span class="line">    String cursor = &quot;0&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        ScanResult&lt;Entry&lt;String, String&gt;&gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);</span><br><span class="line">        List&lt;Entry&lt;String, String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        if (entryList != null &amp;&amp; !entryList.isEmpty()) &#123;</span><br><span class="line">            for (Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; while (!&quot;0&quot;.equals(cursor));</span><br><span class="line"></span><br><span class="line">    //删除bigkey</span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、List删除-ltrim"><a href="#2、List删除-ltrim" class="headerlink" title="2、List删除: ltrim"></a>2、List删除: ltrim</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void delBigList(String host, int port, String password, String bigListKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    long llen = jedis.llen(bigListKey);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    int left = 100;</span><br><span class="line">    while (counter &lt; llen) &#123;</span><br><span class="line">        //每次从左侧截掉100个</span><br><span class="line">        jedis.ltrim(bigListKey, left, llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终删除key</span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、Set删除-sscan-srem"><a href="#3、Set删除-sscan-srem" class="headerlink" title="3、Set删除: sscan + srem"></a>3、Set删除: sscan + srem</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void delBigSet(String host, int port, String password, String bigSetKey) &#123;</span><br><span class="line">    Jedis jedis = new Jedis(host, port);</span><br><span class="line">    if (password != null &amp;&amp; !&quot;&quot;.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = new ScanParams().count(100);</span><br><span class="line">    String cursor = &quot;0&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        if (memberList != null &amp;&amp; !memberList.isEmpty()) &#123;</span><br><span class="line">            for (String member : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey, member);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; while (!&quot;0&quot;.equals(cursor));</span><br><span class="line"></span><br><span class="line">    //删除bigkey</span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、SortedSet删除-zscan-zrem"><a href="#4、SortedSet删除-zscan-zrem" class="headerlink" title="4、SortedSet删除: zscan + zrem"></a>4、SortedSet删除: zscan + zrem</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delBigZset</span><span class="params">(String host, <span class="type">int</span> port, String password, String bigZsetKey)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ScanParams</span> <span class="variable">scanParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanParams</span>().count(<span class="number">100</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (tupleList != <span class="literal">null</span> &amp;&amp; !tupleList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey, tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">&quot;0&quot;</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍在使用阿里云Redis的开发规范，从下面几个方面进行说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;键值设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相关工具&lt;/p&gt;
&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="缓存" scheme="http://ai.mak.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://ai.mak.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>阿里毕玄：我在系统设计上犯过的14个错</title>
    <link href="http://ai.mak.cn/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/"/>
    <id>http://ai.mak.cn/2019/04/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%98%BF%E9%87%8C%E6%AF%95%E7%8E%84%EF%BC%9A%E6%88%91%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%8A%AF%E8%BF%87%E7%9A%84%2014%20%E4%B8%AA%E9%94%99/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2022-11-19T09:58:40.520Z</updated>
    
    <content type="html"><![CDATA[<p><strong>|</strong> 本文转载至 Hello Java。</p><p>这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中），发现大的错误基本集中在前面几年，从这个点看起来能比较自豪的说在最近的几年在系统设计的掌控上确实比以前成熟了很多。</p><p>除了自己犯的错以外，也还看过其他同学犯的一些错，这个在后面再写一篇文章来分享下，同时也征集大家印象深刻的推倒重来的系统设计的错。</p><p><strong>第1个错</strong></p><p>在设计服务框架时，我期望服务框架对使用者完全不侵入，于是做了一个在外部放一个.xml文件来描述spring里的哪些bean发布为服务的设计，这个版本发布后，第一个小白鼠的用户勉强在用，但觉得用的很别扭，不过还是忍着用下去了，到了发布的时候，发现出现了两个问题，一是这个xml文件研发也不知道放哪好，所以到了发布的时候都不知道去哪拿这个xml文件。</p><p>这个设计的关键错误就在于在设计时没考虑过这个设计方式对研发阶段、运维阶段的影响，后来纠正这个错误的方法是去掉了这个xml文件，改为写了一个Spring FactoryBean，用户在spring的bean配置文件中配置下就可以。</p><p>因此对于一个架构师来说，设计时在全面性上要充分考虑。</p><p><strong>第2个错</strong></p><p>服务框架在核心应用上线时，出现了前端web应用负载高，处理线程数不够用的现象，当时处理这个故障的方式是回滚了服务框架的上线，这个故障排查了比较长的时间后，查到的原因是服务框架用的JBoss Remoting在通信时默认时间是60s，导致一些处理速度慢的请求占据了前端web应用的处理线程池。</p><p>上面这里故障的原因简单来说是分布式调用中超时时间太长的问题，但更深层次来思考，问题是犯在了设计服务框架时的技术选型，在选择JBoss-Remoting时没有充分的掌握它的运行细节，这个设计的错误导致的是后来决定放弃JBoss-Remoting，改为基于Mina重写了服务框架的通信部分，这里造成了服务框架的可用版本发布推迟了两个多月。</p><p>因此对于一个架构师来说，在技术选型上对技术细节是要有很强的掌控力的。</p><p><strong>第3个错</strong></p><p>在服务框架大概演进到第4个版本时，通信协议上需要做一些改造，突然发现一个问题是以前的通信协议上是没有版本号的，于是悲催的只能在代码上做一个很龌蹉的处理来判断是新版本还是老版本。</p><p>这个设计的错误非常明显，这个其实只要在最早设计通信协议时参考下现有的很多的通信协议就可以避免了，因此这个错误纠正也非常简单，就是参考一些经典的协议重新设计了下。</p><p>因此对于一个架构师来说，知识面的广是非常重要的，或者是在设计时对未来有一定的考虑也是非常重要的。</p><p>说到协议，就顺带说下，当时在设计通信协议和选择序列化&#x2F;反序列化上没充分考虑到将来多语言的问题，导致了后来在多语言场景非常的被动，这也是由于设计时前瞻性的缺失，所谓的前瞻性不是说一定要一开始就把未来可能会出现的问题就解掉，而是应该留下不需要整个改造就可以解掉的方法，这点对于架构师来说也是非常重要的。</p><p><strong>第4个错</strong></p><p>在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。</p><p>这个设计的错误主要在于没有考虑生产环境中走硬件负载均衡后，这种单个长连接方式带来的问题，这个错误呢还真不太好纠正，当时临时用的一个方法是服务调用方的连接每发送了1w个请求后，就把连接自动断开重建，最终的解决方法是去掉了负载均衡设备这个中间点。</p><p>因此对于一个架构师来说，设计时的全面性要非常的好，我现在一般更多采用的方式是推演上线后的状况，一般来说在脑海里过一遍会比较容易考虑到这些问题。</p><p><strong>第5个错</strong></p><p>服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本，当时只好用一个临时的扫全网机器的方法来解决。</p><p>这个问题后来纠正的方法是在服务发布和调用者在连接我们的一个点时，顺带把用的服务框架的版本号带上，于是就可以很简单的知道全网的服务框架目前在运行的版本号了。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的，推演能起到很大的帮助作用。</p><p><strong>第6个错</strong></p><p>服务框架这种基础类型的产品，在发布时会碰到个很大的问题，就是需要通知到使用者去发布，导致了整个发布周期会相当的长，当时做了一个决定，投入资源去实现完全动态化的发布，就是不需要重启，等到做的时候才发现这完全就是个超级大坑，最终这件事在投入两个人做了接近半年后，才终于决定放弃，而且最终来看其实升级的问题也没那么大。</p><p>这个问题最大的错误在于对细节把握不力，而且决策太慢。</p><p>因此对于一个架构师来说，技术细节的掌控非常重要，同时决策力也是非常重要的。</p><p><strong>第7个错</strong></p><p>服务发布方经常会碰到一个问题，就是一个服务里的某些方法是比较耗资源的，另外的一些可能是不太耗资源，但对业务非常重要的方法，有些场景下会出现由于耗资源的方法被请求的多了些导致不太耗资源的方法受影响，这种场景下如果要去拆成多个服务，会导致开发阶段还是挺痛苦的，因此服务框架这边决定提供一个按方法做七层路由的功能，服务的发布方可以在一个地方编写一个规则文件，这个规则文件允许按照方法将生产环境的机器划分为不同组，这样当服务调用方调用时就可以做到不同方法调用到不同的机器。</p><p>这个功能对有些场景来说用的很爽，但随着时间的演进和人员的更换，能维护那个文件的人越来越少了，也成为了问题。</p><p>这个功能到现在为止我自己其实觉得也是一直处于争议中，我也不知道到底是好还是不好…</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p>减少犯错误的方法：<strong>多阅读、多实践、多总结。</strong></p><p><strong>第8个错</strong></p><p>服务框架在用的越来越广后，碰到了一个比较突出的问题，服务框架依赖的jar版本和应用依赖的jar版本冲突，服务框架作为一个通用技术产品，基本上没办法为了一个应用改变服务框架自己依赖的jar版本，这个问题到底怎么去解，当时思考了比较久。</p><p>可能是由于我以前OSGi这块背景的原因，在设计上我做了一个决定，引入OSGi，将服务框架的一堆jar处于一个独立的classloader，和应用本身的分开，这样就可以避免掉jar冲突的问题，在我做了引入OSGi这个决定后，团队的1个资深的同学就去做了，结果是折腾了近两个月整个匹配OSGi的maven开发环境都没完全搭好，后来我自己决定进去搞这件事，即使是我对OSGi比较熟，也折腾了差不多1个多月才把整个开发的环境，工程的结构，以及之前的代码基本迁移为OSGi结构，这件事当时折腾好上线后，效果看起来是不错的，达到了预期。</p><p>但这件事后来随着加入服务框架的新的研发人员越来越多，发现多数的新人都在学习OSGi模式的开发这件事上投入了不少的时间，就是比较难适应，所以后来有其他业务问是不是要引入OSGi的时候，我基本都会建议不要引入，主要的原因是OSGi模式对大家熟悉的开发模式、排查问题的冲击，除非是明确需要classloader隔离、动态化这两个点。</p><p>让我重新做一个决策的话，我会去掉对OSGi的引入，自己做一个简单的classloader隔离策略来解决jar版本冲突的问题，保持大家都很熟悉的开发模式。</p><p>因此对于一个架构师来说，设计时的全面性是非常重要的。</p><p><strong>第9个错</strong></p><p>服务框架在用的非常广了后，团队经常会被一个问题困扰和折腾，就是业务经常会碰到调用服务出错或超时的现象，这种情况通常会让服务框架这边的研发来帮助排查，这个现象之所以查起来会比较复杂，是因为服务调用通常是多层的关系，并不是简单的A–&gt;B的问题，很多时候都会出现A–&gt;B–&gt;C–&gt;D或者更多层的调用，超时或者出错都有可能是在其中某个环节，因此排查起来非常麻烦。</p><p>在这个问题越来越麻烦后，这个时候才想起在09年左右团队里有同学看过G家的一篇叫dapper的论文，并且做了一个类似的东西，只是当时上线后我们一直想不明白这东西拿来做什么，到了排查问题这个暴露的越来越严重后，终于逐渐想起这东西貌似可以对排查问题会产生很大的帮助。</p><p>到了这个阶段才开始做这件事后，碰到的主要不是技术问题，而是怎么把新版本升级上去的问题，这个折腾了挺长时间，然后上线后又发现了一个新的问题是，即使服务框架具备了Trace能力，但服务里又会调外部的例如数据库、缓存等，那些地方如果有问题也会看不到，排查起来还是麻烦，于是这件事要真正展现效果就必须让Trace完全贯穿所有系统，为了做成这件事，N个团队付出了好几年的代价。</p><p>因此对于一个架构师来说，设计时的全面性、前瞻性非常重要，例如Trace这个的重要性，如果在最初就考虑到，那么在一开始就可以留好口子埋好伏笔，后面再要做完整就不会太复杂。</p><p><strong>第10个错</strong></p><p>服务的发布方有些时候会碰到一个现象是，服务还没完全ready，就被调用了；还有第二个现象是服务发布方出现问题时，要保留现场排查问题，但服务又一直在被调用，这种情况下就没有办法很好的完全保留现场来慢慢排查问题了。</p><p>这两个现象会出现的原因是服务框架的设计是通过启动后和某个中心建立连接，心跳成功后其他调用方就可以调用到，心跳失败后就不会被调到，这样看起来很自动化，但事实上会导致的另外一个问题是外部控制上下线这件事的能力就很弱。</p><p>这个设计的错误主要还是在设计时考虑的不够全面。</p><p>因此对于一个架构师来说，设计时的全面性非常重要。</p><p><strong>第11个错</strong></p><p>在某年我和几个小伙伴决定改变当时用xen的模式，换成用一种轻量级的“虚拟机”方式来做，从而提升单机跑的应用数量的密度，在做这件事时，我们决定自己做一个轻量级的类虚拟机的方案，当时决定的做法是在一个机器上直接跑进程，然后碰到一堆的问题，例如从运维体系上来讲，希望ssh到“机器”、独立的ip、看到自己的系统指标等等，为了解决这些问题，用了N多的黑科技，搞得很悲催，更悲催的是当时觉得这个问题不多，于是用一些机器跑了这个模式，结果最后发现这里面要黑科技解决的问题实在太多了，后来突然有个小伙伴提出我们试用lxc吧，才发现我们之前用黑科技解的很多问题都没了，哎，然后就是决定切换到这个模式，结果就是线上的那堆机器重来。</p><p>这个设计的主要错误在于知识面不够广，导致做了个不正确的决定，而且推倒重来。</p><p>因此对于一个架构师来说，知识面的广非常重要，在技术选型这点上非常明显。</p><p><strong>第12个错</strong></p><p>还是上面这个技术产品，这个东西有一个需求是磁盘空间的限额，并且要支持磁盘空间一定程度的超卖，当时的做法是用image的方式来占磁盘空间限额，这个方式跑了一段时间觉得没什么问题，于是就更大程度的铺开了，但铺开跑了一段时间后，出现了一个问题，就是经常出现物理机磁盘空间不足的报警，而且删掉了lxc容器里的文件也还是不行，因为image方式只要占用了就会一直占着这个大小，只会扩大不会缩小。</p><p>当时对这个问题极度的头疼，只能是删掉文件后，重建image，但这个会有个要求是物理机上有足够的空间，即使有足够的空间，这个操作也是很折腾人的，因为得先停掉容器，cp文件到新创建的容器，这个如果东西多的话，还是要耗掉一定时间的。</p><p>后来觉得这个模式实在是没法玩，于是寻找新的解决方法，来满足磁盘空间限额，允许超卖的这两需求，最后我们也是折腾了比较长一段时间后终于找到了更靠谱的解决方案。</p><p>这个设计的主要错误还是在选择技术方案时没考虑清楚，对细节掌握不够，考虑的面不够全，导致了后面为了换掉image这个方案，用了极大的代价，我印象中是一堆的人熬了多次通宵来解决。</p><p>因此对于一个架构师来说，知识面的广、对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第13个错</strong></p><p>仍然是上面的这个技术产品，在运行的过程中，突然碰到了一个虚拟机中线程数创建太多，导致其他的虚拟机也创建不了线程的现象（不是因为物理资源不够的问题），排查发现是由于尽管lxc支持各个容器里跑相同名字的账号，但相同名字的账号的uid是相同的，而max processes是限制在UID上的，所以当一个虚拟机创建的线程数超过时，就同样影响到了其他相同账号的容器。</p><p>这个问题我觉得一定程度也可以算是设计问题，设计的时候确实由于对细节掌握的不够，考虑的不全导致忽略了这个点。</p><p>因此对于一个架构师来说，对技术细节的掌控和设计的全面性都非常重要。</p><p><strong>第14个错</strong></p><p>在三年前做一个非常大的项目时，项目即将到上线时间时，突然发现一个问题是，有一个关键的点遗漏掉了，只好赶紧临时讨论方案决定怎么做，这个的改动动作是非常大的，于是项目的上线时间只能推迟，我记得那个时候紧急周末加班等搞这件事，最后带着比较高的风险上了。</p><p>这个问题主要原因是在做整体设计时遗漏掉了这个关键点的考虑，当时倒不是完全忽略了这个点，而是在技术细节上判断错误，导致以为不太要做改动。</p><p>因此对于一个架构师来说，对技术细节的掌控是非常重要的，这里要注意的是，其实不代表架构师自己要完全什么都很懂，但架构师应该清楚在某个点上靠谱的人是谁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;|&lt;/strong&gt; 本文转载至 Hello Java。&lt;/p&gt;
&lt;p&gt;这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>详解设计模式在Spring中的应用</title>
    <link href="http://ai.mak.cn/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://ai.mak.cn/2019/03/28/java/%E8%AF%A6%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2022-11-14T05:37:53.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：螃蟹<br><a href="http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html">http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html</a><br>Java架构师之路做了编排 </p></blockquote><p>设计模式作为工作学习中的枕边书，却时常处于勤说不用的尴尬境地，也不是我们时常忘记，只是一直没有记忆。</p><p>今天，螃蟹在IT学习者网站就设计模式的内在价值做一番探讨，并以spring为例进行讲解，只有领略了其设计的思想理念，才能在工作学习中运用到“无形”。</p><p>Spring作为业界的经典框架，无论是在架构设计方面，还是在代码编写方面，都堪称行内典范。好了，话不多说，开始今天的内容。</p><p>spring中常用的设计模式达到九种，我们一一举例：</p><p><strong>第一种：简单工厂</strong></p><p>又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 </p><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 </p><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;singletonBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是singletonBean!value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">   &lt;/ bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;itxxzBean&quot; class=&quot;com.itxxz.HelloItxxz&quot;</span><br><span class="line">        singleton=&quot;false&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种：工厂方法（Factory Method）</strong></p><p>通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。</p><p>一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</p><p>螃蟹就以工厂方法中的静态方法为例讲解一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class StaticFactoryBean &#123;</span><br><span class="line">      public static Integer createRandom() &#123;</span><br><span class="line">           return new Integer(new Random().nextInt());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;random&quot;</span><br><span class="line">class=&quot;example.chapter3.StaticFactoryBean&quot;</span><br><span class="line">factory-method=&quot;createRandom&quot; //createRandom方法必须是static的,才能找到</span><br><span class="line">scope=&quot;prototype&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例</span><br><span class="line">      XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;config.xml&quot;));</span><br><span class="line">      System.out.println(&quot;我是IT学习者创建的实例:&quot;+factory.getBean(&quot;random&quot;).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：单例模式（Singleton）</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p><p>spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 </p><p>核心提示点：Spring下默认的bean均为singleton，可以通过singleton&#x3D;“true|false” 或者 scope&#x3D;“？”来指定</p><p><strong>第四种：适配器（Adapter）</strong></p><p>在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</p><p><strong>Adapter类接口</strong>：Target</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface AdvisorAdapter &#123;</span><br><span class="line"></span><br><span class="line">boolean supportsAdvice(Advice advice);</span><br><span class="line"></span><br><span class="line">      MethodInterceptor getInterceptor(Advisor advisor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MethodBeforeAdviceAdapter类</strong>，Adapter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;</span><br><span class="line"></span><br><span class="line">      public boolean supportsAdvice(Advice advice) &#123;</span><br><span class="line">            return (advice instanceof MethodBeforeAdvice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public MethodInterceptor getInterceptor(Advisor advisor) &#123;</span><br><span class="line">            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">      return new MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五种：包装器（Decorator）</strong></p><p>在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ </p><p>首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。<br>spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 </p><p><strong>第六种：代理（Proxy）</strong></p><p>为其他对象提供一种代理以控制对这个对象的访问。 </p><p>从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 </p><p>spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 </p><p><strong>第七种：观察者（Observer）</strong></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 </p><p><strong>第八种：策略（Strategy）</strong></p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>spring中在实例化对象的时候用到Strategy模式在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： </p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/M7B64fHXISuuxb3OYhV7MtTEqMR53b1k2gueQDW4I1oibFLSFGROiaUHUjDRkPBNc0xDfgYnhu5NicENT713wzy4A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>第九种：模板方法（Template Method）</strong></p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p><p>以下是一个具体的例子：<br>JdbcTemplate中的execute方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：螃蟹&lt;br&gt;&lt;a href=&quot;http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html&quot;&gt;http://itxxz.com/a/javashili/tuozhan/2014/0601/7.ht</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何激发团队的创造力</title>
    <link href="http://ai.mak.cn/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    <id>http://ai.mak.cn/2019/03/26/%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%BF%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2022-11-14T05:25:15.434Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如何激发团队的创造力？</strong></p><p>人生一切难题，知识给你答案。</p><p>提到创意，有一家公司不能不提——皮克斯，《海底总动员》《头脑特工队》《寻梦环游记》……它的每个创意都令人惊叹。</p><p>今天这本书，就带你看看皮克斯有哪些激发创意的高招——</p><p><strong>《创新公司：皮克斯的启示》</strong></p><p><strong>作者: [美] 艾德·卡特姆 埃米·华莱士</strong> </p><p><strong>译者: 靳婷婷</strong> </p><p><strong>出版: 中信出版社</strong></p><p>作者艾德·卡特姆，是皮克斯动画的总裁。他真正厉害的地方不仅是生产创意，而且独创了一套管理创意团队的机制，让天才们能够毫无障碍地通力合作。下面就带你看看他的做法。</p><p><em>1.</em> <strong>设立“智囊团”。</strong>很多公司会设立专门的创意部门，去开发新创意。但皮克斯的智囊团人员从来不是固定的，只要你擅长讲故事、熟悉电影制度，都能加入，包括导演、编剧、故事总监、文化顾问等等。每部电影进行到一定阶段，智囊团就会碰头，讨论新的创意，评价正在制作的电影。</p><p><em>2.</em> <strong>追求最佳效果，不怕“推倒重建”。</strong>几乎所有公司都宣称追求最佳产品质量，可一旦要牺牲大量成本时，很多公司就犹豫了。但皮克斯的电影即便已经制作完毕，一旦有更好的想法，也会推倒重建。你肯定看过《瓦力》，原结局是瓦力救下了心爱的机器人伊娃，但智囊团认为结局没有冲击力，才改为了伊娃违背程序设定，毅然救下瓦力的结尾。也正是这种精益求精的做法，给皮克斯带来了票房和口碑双收的回报。</p><p><em>3.</em> <strong>明确要求员工给出建设性批评。</strong>我们常会听到这样的批评，“这个活动很无聊”“这个方案没有打动我”，但就是不知道到底是哪里不够好。这就是非建设性的批评——只说感受而不点明问题。皮克斯为了杜绝这种现象，明确要求每次样片修改时，都要点出问题并且指出改进的方向。比如“这是重点台词，但现在的表达不够简单有力”。</p><p><em>4.</em> <strong>注重真实，进行“考察旅行”。</strong>很多公司为了获得创意，会广泛收集素材激发灵感。皮克斯在这一点做得更彻底，直接让主创到故事背景地考察旅行。比如以墨西哥为背景的《寻梦环游记》，主角是一个鞋匠世家，主创特意拜访了当地著名的鞋匠，了解做鞋的各种工艺。片中的万寿菊、剪纸等物品，也都是现实中墨西哥街头常见的装饰物。</p><p><em>5.</em> <strong>确保制作中只有导演才有最终决定权。</strong>一个项目参与的人越多，就越容易出现很多人给出意见、话语权混乱的情况，甚至还可能导致由高层“外行指导内行”。在皮克斯，绝不允许这种情况发生，直接明文规定导演在制作中有最终决定权，即便是高层的建议，导演也可以合理回绝。</p><p><em>6.</em> <strong>不浪费时间，尽快试错。</strong>创意制作过程难免会出现问题，很多公司会停下来讨论，一定要找出最完美的方案才继续。但皮克斯不会原地纠结，认为一个方案不行就及时否定，然后尽快尝试其他方向，而不是等待最佳方案。比如《怪物电力公司》，就经过了无数次否定和尝试的过程，主角设定从一个30岁的男人，变成小男孩，最终又改为小女孩，才进入到剧本阶段。</p><p><em>7.</em> **营造团队安全感，**公开分享失误**。**研究发现，想要团队成员能够高效开展工作，给员工营造良好的心理安全感非常关键。不同于其他公司，员工犯错会严厉责备，皮克斯会由领导层带头，公开分析犯错的原因。这让整个公司有良好的氛围，员工都愿意公开表达意见，避免问题再犯。&gt;&gt;&gt;<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjAxOTU4MA==&mid=3009217590&idx=1&sn=14532c49bc8cb0817544181a10e9309f&chksm=90460825a7318133e7905c02e708d5222abfea930e61b4216f15b7504e39734bcd41cfb0a26d&scene=21#wechat_redirect">如何正确对待错误，戳此查看另一篇文章</a></p><p><em>8.</em> <strong>重视新老员工的传承，制定培训制度。</strong>每个公司都重视新老员工的传承，但如果不落实到具体的制度上，最后很可能会变成一纸空话。皮克斯曾经有过一次教训，把一个项目交给无经验的新导演，结果不幸“流产”。此后皮克斯直接明文规定，资深导演每周都要和新人进行交流，并设置了一套新人培训课程，确保新老员工不断层。</p><p><em>9.</em> <strong>改善办公环境，打破层级来交流。</strong>打破层级不是光喊口号，而是从细节开始的改变。最初，皮克斯的大会议室摆放了一张能坐30人的长桌，开会时每个人都有座位牌，但后来发现，这让坐在中间的人的意见更重要，反而强化了层级，交流效果不好。因此，皮克斯就取消了长桌和座位牌，换成10个人左右的小桌，更利于自由沟通。</p><p><em>10.</em> <strong>设立“点评日”集思广益。</strong>很多公司会收集员工对公司的建议，但大多是私下场合的零碎建议。皮克斯从2013年起，制定了专门汇集意见的“点评日”传统——全体员工当天暂停工作，只做一件事：讨论如何把皮克斯建设得更好，比如“如何搭建一个跨项目的共享资料库”“如何消灭特权现象”。经过讨论，公司再选出优秀方案试行。</p><p>让我们对《创新公司：皮克斯的启示》的作者艾德·卡特姆、埃米·华莱士 ，译者靳婷婷 ，出版方中信出版社，说一声感谢！</p><p>最后，与你分享金句，欢迎你收藏并转发：</p><p>好创意不只依赖灵光闪现，</p><p>还需要开放包容的团队管理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;如何激发团队的创造力？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人生一切难题，知识给你答案。&lt;/p&gt;
&lt;p&gt;提到创意，有一家公司不能不提——皮克斯，《海底总动员》《头脑特工队》《寻梦环游记》……它的每个创意都令人惊叹。&lt;/p&gt;
&lt;p&gt;今天这本书，就带你看看皮克斯有哪</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的一些新特性、使用建议和最佳实践</title>
    <link href="http://ai.mak.cn/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2019/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2022-11-14T05:07:53.851Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Redis 5.0已经发布，越来越多的新特性被加入，在工作中发现很多人只是了解一些Redis的基本使用，也并未完整的阅读过Redis的官方文档，对于一些命令不熟悉，不同场景下滥用不合理的数据结构，对一些新的特性似乎也不会去关注，本文总结了一些使用建议。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1、SET key value [expiration EX seconds|PX milliseconds][NX|XX]</p><ul><li>Redis 2.6.12版本后的Set命令支持过期时间等参数，不必再像以前一样分为set和expire两个命令</li></ul><p>2、bitmap</p><ul><li>适用于大量数据的位图信息标记，例如如果要标记大量用户的某个状态值，可以考虑使用bitmap</li><li>bitmap的另外一个应用是基于redis的bloom filter</li></ul><p>3、stream</p><ul><li>Redis4开始提供的新的数据结构，可以理解成轻量级的kafka steam，主要解决了pub&#x2F;sub无法保证通知处理成功和blocked list无法多个client消费的问题，具体点击此处查看topic。</li><li>如果想实现一个简单的聊天室，可以尝试下steam。</li></ul><h1 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h1><p>1、合理分配过期时间</p><ul><li>不管是将Redis作为缓存，还是存储，如果不愿意看到内存被慢慢消耗殆尽，最后只能扩容或者人工介入，就给自己的key设置一个合理的过期时间。 当把Redis作为缓存时，更要预估自己的数据量和数据大小，选择一个合理的过期时间。</li></ul><p>2、多个操作使用pinepine</p><ul><li>这是Redis使用中的一项基本原则，同时需要知道，另外如果下一个命令的input基于上一个命令的output，就不可以放到一个pipeline里面执行了</li><li>使用时考虑pipeline中一个命令执行失败的场景，后面的命令未执行是否因为一致性带来问题</li></ul><p>3、使用命名空间</p><ul><li>方便key的管理，我们开发中常用的redis-desktop客户端能够按照命名空间对key进行展示，另外，命名空间方便需要对某一类key进行统计和管理</li><li>如果需要通过key进行分片，命名空间可以作为分片参数</li></ul><p>4、选用合适的数据结构</p><ul><li>理解每个数据结构的用途，和常用的命令，我曾经见过开发人员因为不知道scard命令可以获得set的size，而将所有的元素取出然后在程序中计算，所以需要平时多查看Redis命令文档；如果能够理解每种数据结构背后的原理，使用时会更加得心应手。</li><li>不建议使用Redis缓存单个数据大小较大的对象，尤其是使用Set，Hash此类数据结构时候，考虑到Redis是单线程，过多的大对象访问增加了网络IO压力，对Redis性能有一定影响，另一方面Redis的虚拟内存page较小，如果内存碎片率较高，则分配&#x2F;申请内存时在性能上有些影响。如果要缓存较大的对象，可以考虑memcache</li></ul><p>5、禁用keys</p><ul><li>很基本的Redis使用常识，可以通过rename-command来将一些类似的命令重命名，实现disable的效果</li></ul><p>6、选用lua script</p><ul><li>如果要保证多个操作的原子性，可以选择使用lua脚本</li></ul><p>7、config set parameter value</p><ul><li>redis 2.0后提供了config set 命令来动态修改一些运行参数而不必重启redis，目前已经支持动态修改maxmemory，可以通过CONFIG GET * 查看支持动态修改的参数列表</li></ul><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>1、key的命名</p><ul><li>合理的命名自己的key，不能在查看数据时可读性更强，也更便于统计和管理</li></ul><p>2、key name的长度</p><ul><li>预估key的存活数量，如果key的数量可能达到百万级别，就需要考虑key的名字过长而导致占用太多的存储空间，我在曾经参与过的一个消息系统中使用redis存储消息阅读量，但是后面由于消息量过多，导致name的占用空间达到几百M，如果精简name，可以节省大量的空间，减少不必要的困扰。 例如，保存用户的基本信息可以使用u:${id}</li></ul><p>3、不滥用Lua Script</p><ul><li>由于Redis是单线程，在QPS很高的情况下，过多的lua脚本执行，特别是内部包含较多业务逻辑处理的情况下，会对Redis性能产生很大的影响。曾经参与过的直播业务的生产环境中，我们在Lua脚本中对送礼物触发的的积分和活动信息的有较多的逻辑处理（20行左右），导致Redis负载100%，所以在排查时Lua脚本有可能是负载较高的元凶之一。</li></ul><p>4、关注内存和slowlog等统计数据</p><ul><li><p>通过info memory查看内存的分配和使用大小，碎片等情况</p></li><li><p>slowlog get N 查看最近几条执行较慢的命令</p></li><li><p>通过redis-cli –bigkeys 通过采样scan元素较多的key，不会一直阻塞redis执行</p></li><li><p>更多好玩的redis-cli命令可以查看此处</p><blockquote><p>monitor命令不建议生产环境使用</p></blockquote></li></ul><p>面对一款优秀开源产品，我们除了要了解它的基本使用，也要擅于运用才能更好发挥其作用，否则会有不必要的麻烦，甚至适得其反。当然如果能深入了解其内部运行机制，知其然并知其所以然，并基于此创造出更加优秀的开源产品，就更符合coder的hacker精神。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Redis 5.0已经发布，越来越多的新特性被加入，在工作中发现很多人只是了解一些Redis的基本使用，也并未完整的阅读过Redis的官方文档，对于一些命令不熟悉，不同场景下滥用不合理的数据结构，对一些新的特性似乎也不会去关注，本文总结了一些使用建议。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="缓存" scheme="http://ai.mak.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://ai.mak.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java12 新特性</title>
    <link href="http://ai.mak.cn/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://ai.mak.cn/2019/03/20/java/Java12%20%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2022-11-14T04:17:04.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Java 12  发布了，一起来看一看特性。</p></blockquote><p><strong>1 Switch 表达式</strong></p><p>使用Java 12，switch不仅可以作为语句也可以作为表达式。 无论作为语句或者作为表达式，switch都可以使用传统&#x2F;简化的作用域和控制流行为。 这将有助于简化代码，并为在switch中使用模式匹配铺平道路。</p><p>Java开发人员正在增强Java编程语言，以使用模式匹配来解决当前switch语句的几个问题。 这包括：switch块的默认控制流行为，switch块默认作用域（被视为单个作用域的块）和switch仅作为语句。</p><p>在Java 11中，switch语句追随C和C++，默认情况下使用fall-through语义。 虽然传统的控制流程在编写低级代码时很有用，但随着switch在更高级别的环境中采用，易出错会盖过其灵活性。</p><p>Java 11 </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMvNJrP0lcJZmQSmr7YySUnffXDnaRFKbCQAhHO7ib4r4y2ytMBc4S3If0ibas6vqzZOcBIeMx6dU5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Java 12</p><p><strong>2 默认CDS归档</strong></p><p>通过在64位平台上的默认类列表的帮助下生成CDS归档来改进JDK构建过程，从而有效地消除了运行java -Xshare：dump。 此功能的目标包括：1。）改进开箱即用的启动时间，以及2.）摆脱使用-Xshare：dump。</p><p><strong>3 Shenandoah GC</strong></p><p>Shenandoah是一种垃圾收集（GC）算法，旨在保证低延迟（10 - 500 ms的下限）。 它通过在运行Java工作线程的同时执行GC操作减少GC暂停时间。 使用Shenandoah，暂停时间不依赖于堆的大小。 这意味着无论堆的大小如何，暂停时间都是差不多的。</p><p>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p><p><strong>4 JMH 基准测试</strong></p><p>此功能为JDK源代码添加了一套微基准测试（大约100个），简化了现有微基准测试的运行和新基准测试的创建过程。 它基于Java Microbenchmark Harness（JMH）并支持JMH更新。</p><p>此功能使开发人员可以轻松运行当前的微基准测试并为JDK源代码添加新的微基准测试。 可以基于Java Microbenchmark Harness（JMH）轻松测试JDK性能。 它将支持JMH更新，并在套件中包含一组（约100个）基准测试。</p><p><strong>5 JVM 常量 API</strong> </p><p>JEP 334引入了一个API，用于建模关键类文件和运行时artifacts，例如常量池。 此API将包括ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc等类。此 API 对于操作类和方法的工具很有帮助。</p><p><strong>6 G1的可中断 mixed GC</strong></p><p>此功能通过将Mixed GC集拆分为强制部分和可选部分，使G1垃圾收集器更有效地中止垃圾收集过程。通过允许垃圾收集过程优先处理强制集，g1可以更多满足满足暂停时间目标。</p><p>G1是一个垃圾收集器，设计用于具有大量内存的多处理器机器。由于它提高了性能效率，g1垃圾收集器最终将取代cms垃圾收集器。</p><p>G1垃圾收集器的主要目标之一是满足用户设置的暂停时间。G1采用一个分析引擎来选择在收集期间要处理的工作量。此选择过程的结果是一组称为GC集的区域。一旦GC集建立并且GC已经开始，那么G1就无法停止。</p><p>如果G1发现GC集选择选择了错误的区域，它会将GC区域的拆分为两部分（强制部分和可选部分）来切换到处理Mix GC的增量模式。如果未达到暂停时间目标，则停止对可选部分的垃圾收集。</p><p><strong>7 G1归还不使用的内存</strong></p><p>此功能的主要目标是改进G1垃圾收集器，以便在不活动时将Java堆内存归还给操作系统。 为实现此目标，G1将在低应用程序活动期间定期生成或持续循环检查完整的Java堆使用情况。</p><p>这将立即归还未使用的部分Java堆内存给操作系统。 用户可以选择执行FULL GC以最大化返回的内存量。</p><p><strong>8 移除多余ARM64实现</strong></p><p>Java 12将只有一个ARM 64位实现（aarch64）。 目标是删除所有与arm64实现相关的代码，同时保留32位ARM端口和64位aarch64实现。</p><p>这将把重点转移到单个64位ARM实现，并消除维护两个实现所需的重复工作。 当前的JDK 11实现中有两个64位ARM实现。</p><p><strong>原文地址：</strong></p><p><a href="https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/">https://stackify.com/java-12-new-features-and-enhancements-developers-should-know/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; Java 12  发布了，一起来看一看特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1 Switch 表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Java 12，switch不仅可以作为语句也可以作为表达式。 无论作为语句或者</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章读懂“中台”架构</title>
    <link href="http://ai.mak.cn/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/"/>
    <id>http://ai.mak.cn/2019/03/19/%E6%9D%82%E8%AE%B0/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AF%BB%E6%87%82%E2%80%9C%E4%B8%AD%E5%8F%B0%E2%80%9D%E6%9E%B6%E6%9E%84/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2022-11-01T05:49:30.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一篇文章读懂“中台”架构"><a href="#一篇文章读懂“中台”架构" class="headerlink" title="一篇文章读懂“中台”架构"></a>一篇文章读懂“中台”架构</h1><p>转载来自微信公众号：  archstudy 架构思轩</p><p><strong>中台是什么</strong></p><p>企业互联网中台架构，简称<strong>中台</strong>，起源于阿里巴巴，不同的人对中台有不同解读。</p><p>我认为，中台可定义为：中台是一套结合互联网技术和行业特性，将企业核心能力以共享服务中心进行沉淀，形成“大中台、小前台“的组织和业务机制，供企业快速低成本的进行业务创新的企业架构。</p><p>中台的目的是 **“提供企业快速低成本创新的能力”，核心是 <strong>“构建企业共享服务中心”</strong>，过程是构建 <strong>“大中台、小前台“</strong> 组织和业务机制。</p><p>其中，前台作为一线业务，更敏捷更快速适应市场，中台将整个企业的数字运营能力、产品技术能力，对各业务前台形成强力支撑。</p><p><strong>阿里巴巴的中台架构</strong></p><p><img src="http://p9.itc.cn/images03/20200526/93023c40ab584738931eae938d9cdca5.jpeg" alt="图片"></p><p><em>阿里中台架构</em> </p><p><em>from 钟华编著《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》图</em></p><p>上图可以看出，阿里巴巴有超过数十个业务单元（如淘宝、天猫、聚划算、菜鸟）均不是独立构建在阿里云之上，在后端阿里云技术平台和前端业务之间有“共享业务事业部“，将业务中公共、通用的业务沉淀下来，包括用户中心、商品中心、交易中心、评价中心等十几个共享单元，是“厚平台的真正实现“。</p><p>而后端的阿里云提供资源和中间件云服务能力做载体。同时，使用集团近十年的双11、双12的高可靠、可稳定的运维保障能力，对整个系统进行支撑。</p><p>中台的使命是从下到上逐步完善阿里的整个体系，从阿里云、数据、中间件、算法，到上面支撑的各种业务解决方案，构建阿里自己核心的能力。</p><p><strong>中台在阿里巴巴的诞生</strong></p><p>在淘宝初期，主要面向C2C的电商领域，整个系统都是围绕一套“烟囱式”的淘宝技术框架进行。随着业务的不断扩张，集团成立出天猫事业部主抓B2C电商领域，又形成了一套烟囱式发展。</p><p>这种烟囱式的架构体系带来了诸多不足，比如成本的重复投入和维护、数据之间打通复用的难度、几年之后推到重建的风险。</p><p>为了解决这些问题，集团开始构建<strong>共享服务中心体系</strong>，来沉淀和服用业务能力，但是由于没有过多的业务话语权，共享服务体系的建设一开始并不顺利。 </p><p>之后，随着“聚划算”团购项目的启动，各种系统的流量都需要通过聚划算，这时，共享服务中心得以大展手脚，逐步将集团核心的业务能力构建成<strong>用户中心、商品中心、交易中心、评价中心、店铺中心</strong>等等数十个共享服务。</p><p>可以说整个阿里中台的革命也是共享服务中心的革命，各共享服务中心聚焦核心业务单元能力的构建，协助目前集团上百个前台业务的快速创新。</p><p>这里需要强调一下，中台是<strong>去中心化</strong>的，而共享服务中心正是一个个解耦的服务模块，这里的中心有一些特点：</p><ol><li>共享中心以共享<strong>业务+数据</strong>能力为主，比如领域服务层+API接口</li></ol><ul><li>共享中心的目的是沉淀传统行业业务和数据能力，并<strong>开放出去</strong></li><li>共享中心是中台的重要部分，目的是实现前端应用和后台的<strong>彻底解耦</strong></li></ul><p><strong>中台的好处</strong></p><p>没有中台前，企业的<strong>痛点</strong>体现在：</p><p><strong>复杂</strong>：系统庞大、逻辑复杂 （学习理解成本高，每人了解系统全貌，最懂的是程序员，需要翻代码才能知道具体逻辑）</p><p><strong>重复</strong>：系统差异性大、标准不一 （同样的需求在不同系统重复造轮子，对于一个通用功能，没人说清楚是否有，或知道但现有的够不够支持）</p><p><strong>沟通成本高</strong>：团队多，跨部门的沟通多（无用的拉通对齐会太多，沟通需求和信息获取成本极高）</p><p>中台就是为了让企业进行核心能力的<strong>沉淀</strong>，更给予我们快速创新的<strong>机会</strong>，具体包括：</p><p><strong>1、中台赋予业务快速创新和试错能力</strong></p><p>企业可以聚焦核心共享服务的建设，提高服务的重用。</p><p><strong>2、打造数字化运营能力</strong></p><p>中台有助于业务通过共享核心能力的沉淀，进行数字化运营。通过对中心核心数据的分析，更加精确地对业务进行调整和优化，全方位动态调整资源利用。</p><p><strong>3、改变组织阵型带来组织效能提升</strong></p><p>中台的变化也是组织阵型的变化。一方面，对于公司，中台侧重的是跨部门跨团队的深入合作。另一方面，对于个人，中台推荐的是类微服务的小而精团队，员工从事多种岗位，对全局和整体有更深入的锻炼。</p><p><strong>中台是平台化的自然演进</strong></p><p><img src="https://img1.baidu.com/it/u=1775402040,4133540010&fm=253&fmt=auto&app=138&f=PNG?w=674&h=333" alt="图片"></p><p>这里比较一下中心化、平台化、中台化。</p><p>中心化类似烟囱式架构，一个中心解决整个技术堆栈。</p><p>平台的目标为高内聚、低耦合、职责边界清晰，是单一团队、部门、系统的效率提升。</p><p>中台的目标是提升效能、数据化运营、更好支持业务发展和创新，是<strong>多领域、多BU、多系统的负责协同</strong>。</p><p>中台是平台的自然演进：这种演进带来“去中心化“的组织模式，突出对<strong>能力复用、协调控制的能力</strong>，以及业务创新的差异化构建能力。</p><p><strong>企业中台化转型</strong></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2F80%2Fv2-60d6ae21eb72c390ea7fa74a3b8f955b_1440w.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669873642&t=90c9dc8d95deb7e65fd891c37b80d3d0" alt="图片"></p><p>传统企业应用中台战略进行互联网化转型，主要需要关注以下6点。</p><p><strong>1、尽可能拆分，共享中心建设</strong></p><p>企业应该尽可能地拆分自己的应用，进行共享服务中心的建设，将核心的业务能力复用和沉淀。</p><p>共享中心的拆分要注意层次。</p><p>首先，可以从<strong>基础主数据和核心共享数据</strong>出发去定义中心，例如客户中心，订单中心，所有功能目的都是围绕客户或订单数据本身。</p><p>第二，可以围绕<strong>核心业务展开进行中心的定义</strong>，比如交易中心，人事共享服务中心，这种中心的强调核心业务能力，而不是针对某特定数据。</p><p>另外，可以以<strong>核心业务规则和逻辑构建的中心</strong>，比如包调度中心，规则中心等，这些都是实现核心业务逻辑处理为主的中心。</p><p><strong>2、去中心化，线性扩展</strong></p><p>企业需要采用去中心化架构，<strong>没有核心流量汇入点，服务中心尽量无状态</strong>，便于水平扩展。这样平均分担压力，负载均衡，对单个中心带来的负载更小，故障影响的范围也更小。</p><p>同时，也要求我们的数据服务也要进行<strong>分布式改造</strong>，使用<strong>分库分表，读写分离</strong>的思想，便于根据实际情况扩索容。</p><p><strong>3、数据化运营</strong></p><p>当然，去中心化也会面对系统运维和管理成本上升的问题。企业需要对自身的运维运营过程进行积累和沉淀，整理出数据化、<strong>自动化运维</strong>的经验，同时增强<strong>监控告警、限流降级、性能分析诊断</strong>等方面的能力，精准定位目前系统中存在的问题，并提出相应的改善方案。</p><p>另外，数据是企业最宝贵的财富，企业可以通过各中心的数据，今而挖掘新的业务机会，快速创新。</p><p><strong>4、异步化，最终一致</strong></p><p>在大量的实践中，大部分业务流程不需要强一致性，而使用最终一致来平衡。</p><p>我们需要使用<strong>异步解耦</strong>，如使用<strong>消息队列</strong>来完成业务逻辑，缩短相应周期。</p><p>以双11为例，一个交易需要200多个系统，假设每个系统需要10毫秒，再加上一些网络和前端延迟，总时长将超过3秒。而在互联网领域，3秒的RT会造成大量的用户流失。使用异步化，缩短服务主链路可以大大缓解这一问题。</p><p><strong>5、尽可能自动化</strong></p><p>企业进行中台改造，会面临很多机器来负载业务，要求企业尽可能提高自动化能力，比如<strong>自动部署、自动弹性扩容、自动升降级、自动限流降级</strong>，降低运营成本，也提高系统的稳定性和业务连续性。比如消息队列中以自动化的形式实现系统的秒级切换和快速恢复，对应用几乎没有影响。</p><p><strong>6、尽可能使用成熟组件</strong></p><p>中台的建设要求企业将重心放在服务中心上，对于底层组件，尤其是中间件层面，尽量使用成熟的组件来提高系统稳定性和性能。</p><p>目前，阿里巴巴中间件已经将多年经双十一购物狂欢节的严苛考验的技术沉淀，以阿里云标准云服务的方式输出给外部客户，其中包括多款阿里云中间件产品（比如EDAS&#x2F;MQ&#x2F;DRDS&#x2F;ARMS&#x2F;PTS），并提供全方位的互联网化转型的架构咨询、技术支持、交付培训等服务。并不仅仅是技术红利的分享，更重要的是整个阿里中台战略思想的传播。</p><p><strong>Takeaways</strong></p><ul><li><p>中台可以帮助传统企业将企业核心能力<strong>以共享服务形式沉淀，供企业快速低成本的进行业务创新</strong>的企业架构。</p></li><li><p><strong>中台是平台化的自然演进</strong>，是一种体系&#x2F;生态&#x2F;方法论。</p></li><li><p>中台的目的是“<strong>提供企业快速低成本创新的能力</strong>”。中台的核心是“<strong>构建企业共享服务中心</strong>”。</p></li><li><p>企业中台化转型中，需要关注<strong>拆分&#x2F;去中心化&#x2F;数字化&#x2F;异步化&#x2F;自动化&#x2F;成熟组件</strong>等方面。</p></li></ul><p><strong>Reference</strong></p><p>《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》— 钟华</p><p><a href="http://www.open-open.com/news/view/1f1f312">http://www.open-open.com/news/view/1f1f312</a></p><p><a href="http://www.sohu.com/a/166699898_413980">http://www.sohu.com/a/166699898_413980</a></p><p>作者简介</p><p><strong>王思轩</strong>，计算机专业博士，阿里巴巴中间件技术架构师。</p><p>获得加拿大卡尔顿大学计算机博士学位，并获得法国波尔多大学和哈尔滨工业大学双硕士，哈尔滨工业大学本科，发表过10余篇国际学术论文。多年从事于云计算和系统架构设计工作，曾就职于华为，Qlik，Honeywell。现就职于阿里，花名宇升，负责并参与Aliware云产品重点项目的设计和交付，以及企业互联网架构的咨询培训工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一篇文章读懂“中台”架构&quot;&gt;&lt;a href=&quot;#一篇文章读懂“中台”架构&quot; class=&quot;headerlink&quot; title=&quot;一篇文章读懂“中台”架构&quot;&gt;&lt;/a&gt;一篇文章读懂“中台”架构&lt;/h1&gt;&lt;p&gt;转载来自微信公众号：  archstudy 架构思轩&lt;/p&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>技术团队的4个难题</title>
    <link href="http://ai.mak.cn/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/"/>
    <id>http://ai.mak.cn/2019/03/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%844%E4%B8%AA%E9%9A%BE%E9%A2%98/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2022-10-27T05:51:10.493Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于阿里巴巴中间件</p><p>从单个应用到多个应用，从百千级别的访问流量到十万、百万级别，从两三个人的创业技术团队到上千人的技术团队矩阵，这些过程中，技术团队都避不开了以下 4 个问题：</p><ul><li><p>如何预测业务峰值时的容量</p></li><li><p>如何提升业务的稳定性</p></li><li><p>如何提高业务的监控能力</p></li><li><p>如何提高开发效率</p></li></ul><p><strong>如何预测业务峰值时的容量</strong></p><hr><p>早期的做法是在开发测试环境进行压测，来评估线上容量，但线下环境的机器规模，和线上差距很大，很难通过线下推导线上。根据经验，将采购的机器加入不同的应用里面，这时候就会遇到一个问题： <strong>最大业务峰值容量是多少？</strong></p><p>这个问题，其实挺难回答的。这个应用多加几台，那个应用少加几台，整体的业务峰值承受能力就会不一样，加减的规则很难通过人的经验来确定，最多只能作为一些辅助判断。另外，核心交易链路的梳理，也是一个体力活，如果依赖人为处理，有可能会漏掉一些看起来不那么重要的”分支”，这是整个容量不确定的地方，可变的因子很多。</p><p>比较有效的方式， <strong>是在生产系统部署全链路压测</strong>，来验证各个生产环节是否能经受住各类流量的访问，让真实的流量来访问生产环境，实现全方位的真实业务场景模拟，确保各个环节的性能、容量和稳定性均可做到万无一失。</p><p><strong>如何提升业务的稳定性</strong></p><hr><p>日常的各种运营活动，都有可能带来巨大的流量高峰，除了通过引入全链路压测来验证各个生产环节是否能经受住各类流量的访问， <strong>构建系统的高可用保障能力也很关键</strong>，涉及多个组件或模块，例如<strong>软负载和配置中心、服务接入和调度编排、消息接收和发送、容器和调度、限流和降级</strong> 等。</p><p>运营一次活动，最大的流量峰值是可以预测的，这就是服务的最大接待能力，比如50万笔的交易创建峰值，那超过的怎么办？这时候，采用限流的方式，被限流的客户在某一段时间内无法进行购物，一旦系统恢复服务能力，就可以继续服务被限流的客户，从而避免因流量超过上限，而影响整个平台的客户。</p><p><strong>如何提高业务的监控能力</strong></p><hr><p>分布式应用系统在协作性，扩展性和一定的容错性方面，体现出了优势，但是<strong>在监控、运维和诊断层面，面临相当大的挑战。</strong></p><p>早期，架构师可以画出整个应用系统的交互架构图，随着业务的发展，当拥有大量的应用、微服务和容器，即便整理了一幅交互架构关系图，也会因为应用系统的变更，新需求的实现，整个应用系统的交互又会发生变化，这种变化无处不在，每天都在发生。因此，随着业务量的增加，需要覆盖面广且深的<strong>全链路跟踪监控系统</strong> ，来诊断调用链的问题。</p><p>越是复杂的业务形态，定位的难度越大，就越需要全方位、360度无死角的监控，因此，建立一个平台化、跨领域和立体化的监控，能极大的缩短业务遇到问题时的恢复时间。</p><p><strong>如何提高开发效率</strong></p><hr><p>开发效率是一个很广泛的话题。不同的开发岗位，不同的使用场景，会有不一样的开发效率工具。这里，我们介绍几款后端工程师经常会用到的效率工具。</p><p>云端部署效率工具：</p><p>Cloud Toolkit 是一款 IDE插件，可以帮助开发者更高效地开发、测试、诊断并部署应用。借助这个工具，开发者能够方便地将本地应用一键部署到任意机器，或 ECS、EDAS、Kubernetes，并支持高效执行终端命令和 SQL 等。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485392&idx=3&sn=113a67be48740443b9a29d172da48b12&chksm=fdeb35b0ca9cbca6f48b61c8c333683b6acbaac4f1e8101ff54546d9256347bff629e0e513c5&scene=21#wechat_redirect">点此了解详情。</a></p><p>MacOS 搜索利器：</p><p>MacOS 自带的聚焦搜索（Spotlight），可以将文稿、邮件、应用等整合在一起，通过关键词匹配来进行搜索。Alfred 可以看作是Spotlight的增强版，是计算机依赖者的效率神器，支持添加自定义网络搜索引擎，指定规则精准定位本地文件，以及在命令框内使用计算器、词典等实用工具。</p><p>画图效率工具：</p><p>系统架构图是为了抽象的表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。通过架构图，可以让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体，所谓一图胜千言。<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&mid=2247485842&idx=2&sn=39bf21a40e810d8993aaeb6054f4cada&chksm=fdeb3bf2ca9cb2e4e40442c80fc833372686f373c3c0e23f5b3cf438d00ebd6586bd4772f36c&scene=21#wechat_redirect">点此了解详情。</a></p><p>JSON 浏览效率插件</p><p>对于 JSON 的数据，如果不编排，格式查看起来会很费劲。JSON-handle 是一款对 JSON 格式的内容进行浏览和编辑，以树形图样式展现 JSON 文档的插件，支持实时编辑。</p><p>Java 代码规约扫描效率插件</p><p>这是一款 Java 代码规约扫描工具，旨在以工具的手段进行代码规约的落地，项目包含三部分：PMD规则实现、IntelliJ IDEA 插件、Eclipse 插件，帮助开发人员在工程研发的多个阶段进行代码规约检查， 降低故障率、提升编码效率和质量。<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDU0MTE0OA==&mid=2661009238&idx=1&sn=3813042bae641ce8cac04ff57bf30ee2&chksm=80feaf65b789267361c560cb2b134e325343a927925b985642cba95210fe9222aaf2f006c90b&token=2107695414&lang=zh_CN&scene=21#wechat_redirect">点此了解详情。</a></p><p>当然，除了这些现成的效率工具，提升整个技术团队的开发效率，需要单独开发或改造一些系统，例如团队协作平台、服务化改造等，当你以实习生的身份加入公司后，若有机会参与到这些提升开发效率的项目过程中。由此形成的效率意识，将会影响到你今后的工作习惯和理念。</p><blockquote><p>本文部分内容来源于阿里巴巴中间件资深产品专家丹臣的内部分享《阿里巴巴中间件上云实践》。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下文章来源于阿里巴巴中间件&lt;/p&gt;
&lt;p&gt;从单个应用到多个应用，从百千级别的访问流量到十万、百万级别，从两三个人的创业技术团队到上千人的技术团队矩阵，这些过程中，技术团队都避不开了以下 4 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何预测业务峰值时的容量&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="开发效率" scheme="http://ai.mak.cn/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
