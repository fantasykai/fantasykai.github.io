<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>10种常见的软件架构模式</title>
    <link href="http://ai.mak.cn/2020/10/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ai.mak.cn/2020/10/06/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2023-01-12T15:15:29.371Z</updated>
    
    <content type="html"><![CDATA[<p>有没有想过要设计多大的企业规模系统？在主要的软件开发开始之前，我们必须选择一个合适的体系结构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，我们应该了解不同的体系结构。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785157/1000" alt="img"></p><p>什么是架构模式？</p><p>根据维基百科中的定义：</p><p>架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。架构模式与软件设计模式类似，但具有更广泛的范围。</p><p>在本文中，将简要地解释以下10种常见的体系架构模式，以及它们的用法、优缺点。</p><p>分层模式</p><p>客户端-服务器模式</p><p>主从设备模式</p><p>管道-过滤器模式</p><p>代理模式</p><p>点对点模式</p><p>事件总线模式</p><p>模型-视图-控制器模式</p><p>黑板模式</p><p>解释器模式</p><p>一. 分层模式</p><p>这种模式也称为多层体系架构模式。它可以用来构造可以分解为子任务组的程序，每个子任务都处于一个特定的抽象级别。每个层都为下一个提供更高层次服务。</p><p>一般信息系统中最常见的是如下所列的4层。</p><p>表示层(也称为UI层)</p><p>应用层(也称为服务层)</p><p>业务逻辑层(也称为领域层)</p><p>数据访问层(也称为持久化层)</p><p>使用场景：</p><p>一般的桌面应用程序</p><p>电子商务Web应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785133/1000" alt="img"></p><p>二. 客户端-服务器模式</p><p>这种模式由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。</p><p>使用场景：</p><p>电子邮件，文件共享和银行等在线应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785144/1000" alt="img"></p><p>三. 主从设备模式</p><p>这种模式由两方组成;主设备和从设备。主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是由从设备返回的结果。</p><p>使用场景：</p><p>在数据库复制中，主数据库被认为是权威的来源，并且要与之同步</p><p>在计算机系统中与总线连接的外围设备(主和从驱动器)</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785136/1000" alt="img"></p><p>四. 管道-过滤器模式</p><p>此模式可用于构造生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。</p><p>使用场景：</p><p>编译器。连续的过滤器执行词法分析、解析、语义分析和代码生成</p><p>生物信息学的工作流</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785139/1000" alt="img"></p><p>五. 代理模式</p><p>此模式用于构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。</p><p>服务器将其功能(服务和特征)发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。</p><p>使用场景：</p><p>消息代理软件，如Apache ActiveMQ，Apache Kafka，RabbitMQ和JBoss Messaging</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785137/1000" alt="img"></p><p>六. 点对点模式</p><p>在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。</p><p>使用场景：</p><p>像Gnutella和G2这样的文件共享网络</p><p>多媒体协议，如P2PTV和PDTP</p><p>像Spotify这样的专有多媒体应用程序</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785140/1000" alt="img"></p><p>七. 事件总线模式</p><p>这种模式主要是处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。消息源将消息发布到事件总线上的特定通道上。侦听器订阅特定的通道。侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。</p><p>使用场景：</p><p>安卓开发</p><p>通知服务</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785148/1000" alt="img"></p><p>八. 模型-视图-控制器模式</p><p>这种模式，也称为MVC模式，把一个交互式应用程序划分为3个部分，</p><p>模型：包含核心功能和数据</p><p>视图：将信息显示给用户(可以定义多个视图)</p><p>控制器：处理用户输入的信息</p><p>这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</p><p>使用场景：</p><p>在主要编程语言中互联网应用程序的体系架构</p><p>像Django和Rails这样的Web框架</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785143/1000" alt="img"></p><p>九. 黑板模式</p><p>这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由3个主要组成部分组成。</p><p>黑板——包含来自解决方案空间的对象的结构化全局内存</p><p>知识源——专门的模块和它们自己的表示</p><p>控制组件——选择、配置和执行模块</p><p>所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。</p><p>使用场景：</p><p>语音识别</p><p>车辆识别和跟踪</p><p>蛋白质结构识别</p><p>声纳信号的解释</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785141/1000" alt="img"></p><p>十. 解释器模式</p><p>这个模式用于设计一个解释用专用语言编写的程序的组件。它主要指定如何评估程序的行数，即以特定的语言编写的句子或表达式。其基本思想是为每种语言的符号都有一个分类。</p><p>使用场景：</p><p>数据库查询语言，比如SQL</p><p>用于描述通信协议的语言</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211785135/1000" alt="img"></p><p>下面给出的表格总结了每种体系架构模式的优缺点。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211787148/1000" alt="img"></p><p><img src="https://inews.gtimg.com/newsapp_bt/0/13211788404/1000" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有没有想过要设计多大的企业规模系统？在主要的软件开发开始之前，我们必须选择一个合适的体系结构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，我们应该了解不同的体系结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://inews.gtimg.co</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>如何利用计划管理提升团队效率和产能</title>
    <link href="http://ai.mak.cn/2020/09/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD/"/>
    <id>http://ai.mak.cn/2020/09/27/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E5%92%8C%E4%BA%A7%E8%83%BD/</id>
    <published>2020-09-26T16:00:00.000Z</published>
    <updated>2023-01-12T15:09:24.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 本文根据沈剑老师在〖deeplus直播第237期〗线上分享演讲内容整理而成。</p></blockquote><p>大家好，我是快狗打车的产品技术设计团队的负责人沈剑，可能很多人通过“架构师之路”认识了我。在这些年里我身上肩负着架构师和团队领导者的身份，完成了不少系统的产品设计，也从一线管理者晋升到现在整个产研团队的总负责人。</p><p>其实在这个过程中需要设定很多目标，包括团队的目标、业务项目的目标和技术项目的目标。今天分享主要集中在让大家了解，作为一个管理者或项目经理可以通过哪些方法和工具去达成既定的目标。</p><p>如果你是一个团队的负责人，或者未来也希望成为团队负责人，又或者你正在带领业务和技术项目、正在参与项目且未来希望能够带领项目，那么我希望通过今天的分享能够帮助大家解决以下三个问题：</p><ul><li>如何达成既定目标；</li><li>如何制定计划；</li><li>实现团队目标。</li></ul><p><strong>前言</strong></p><p>在开始分享前，我在这里先抛出两个问题：</p><ul><li><strong>管理者的职责是什么？</strong></li></ul><p>我的理念是，作为一个管理者在面对上级、同事和下属的时候职责都是不一样的。</p><p>面对老板，我们必须完成给定的业务目标或者项目目标；面对同事，我们就要为队友赋能；而面对下属，我们不仅要帮助他们解决问题，还有帮助他们成长和提升，也就是帮他们搭舞台唱戏。以上是我认为，作为一个管理者要尽到的核心职责。</p><p>然而究其根本，管理者的职责其实是实现自己承诺的目标。面对老板就是要实现承诺的业务目标，对同事是实现对合作的承诺，对下属则是对你实现承诺的方法和资源。管理者并没有拥有很大的权力，多大程度上实现了承诺过的目标才是岗位价值的体现。分层次说的话，CEO要实现自己对业务总体目标的承诺，CTO要实现对产研项目、产品系统交付的承诺，而总监经理要实现对交付质量、技术体系建设、组织能力建设的承诺，员工也要实现对自己在项目、在系统中负责的稳定性、迭代、效率和质量的承诺。</p><p><strong>我们对管理者基本的要求，就是实现自己承诺的目标</strong>。如果目标没有达成，那这个管理者就是不合格的。</p><ul><li><strong>管理者如何实现目标？</strong></li></ul><p>达成目标的要素有老板的支持、清晰的目标、下属的能力、到位的监督等等，可能每个管理者实现自己目标的关键要素都不一样。</p><p>回想一下，我们在做项目的过程，是不是先定下项目目标，然后是项目负责人，接着拆解、监督跟进、风险评估和改进、过程改进？这个流程可能大家没有一个系统的说法，但它就是使用计划管理去实现目标的。整个定目标、做计划、行动、复盘、调整行动、达成目标的过程其实就是计划管理。特别是在效率交付这个方面，对负责的相关研发部门来说，计划管理极其重要。</p><p><strong>一、什么是计划管理</strong></p><p>1、计划管理</p><p>要做计划管理，那就要先说说什么是计划。计划就是目标及一步步实现目标的步骤。想看一个企业做得好不好，带领一个团队带得好不好，我们要重点看其是否养成了做计划的习惯，因为做计划是一个主动规划的过程。</p><p>但是很多人会说：“很多时候我只是被动地被安排工作啊，老板让我做什么我就做什么。”</p><p>被动安排工作，很可能是你的老板在做计划而你只是执行他的计划。很多的时候，业务变复杂了，团队也扩张了，很多管理者就不会做计划了，或者做好的计划就乱套了，这样对项目推进有很大的影响，所以我们必须养成做计划的习惯。</p><p>计划管理是我们做一切管理的基础，是达成目标的一个工具。</p><p>2、流程管理</p><p>我们知道做产研项目的项目流程是提需求、接需求、需求设计和评审、研发设计和评审、研发链条测试上线部署。</p><p>那么流程管理能解决什么问题呢？重点解决的问题不是说哪个人在哪个环节进行审批，而是大家的分工问题。我们要知道整个流程需要哪些岗位来配合工作，借此设置产品、研发、测试和运维的岗位。流程管理是用来确保人人有事做，事事有人做，并且在整个项目、业务流程中，每一个岗位都是明确的。</p><p>3、组织管理</p><p>组织管理的内容是确定权责，它主要解决了负责人必须有权，有权的人必须负责的这个问题。</p><p>在实际落地的管理工作过程中，如果推进流程清晰、岗位分工明确，那么组织管理的工作就会比较少；反之如果推进流程模糊、岗位分工也含糊，那么管理者就需要投入大量精力去解决关于流程的问题，去解决组织上需要权责清晰分明的问题。</p><p>实际工作中，花费在流程管理和组织管理的时间还是比较少的，更多的时间用在计划管理上，需要做好设定和达成目标的工作。计划管理、流程管理、组织管理分别解决不同的问题：</p><ul><li><strong>计划管理，</strong> 解决设计计划、明确目标、合理分解任务和达成目标的问题；</li><li><strong>流程管理，</strong> 解决流程和岗位要清晰，人人有事做，事事有人做的问题；</li><li><strong>组织管理，</strong> 解决权责问题，确保组织合理，做事的人有权、有权的人承担责任。</li></ul><p>这是基础管理最重要的三项内容，如果你要做更高阶的管理，往总监、VP、CTO的方向走的话，那么在管理工作中你还需要思考高阶的管理，比如说战略管理，我们要建设怎样的能力，又比如说文化管理，我们如何能够持续地建设能力并且在各个方向上文化都拥有战斗力。</p><p><strong>计划管理是我们做好一切的基础，是达成目标的方法。</strong>做好计划管理，基本上你就是一个80分的一线或者二线管理者。</p><p><strong>二、计划管理最佳适用范围</strong></p><p>问题：销售的目标是一个需要达成的销售额，销售额按月度考核，有的时候目标达成了而有的时候没有，那么我这个月需要怎样制定怎样销售额度。以上算不算计划管理？</p><p>答案：不算，这个例子更偏向于绩效管理。</p><p>对于直接为业务结果负责的部门，会特别注重绩效管理。但是对于不直接背负绩效管理指标的部门，绩效管理就不是这个部门的管理者最关注的的事情。像是最典型的研发部，它们为交付服务而存在，是一个注重效率的部门，要求快速、高质、高效地交付产品和系统。</p><p><strong>计划管理适合关注效率而非绩效的部门。</strong> 对这样的部门来说，其核心管理方法论就是计划管理。</p><p>还是典型的例子，对技术部门来说，他们的主要职责不是技术驱动业务的部分（少数公司例外），更多的是为交付而负责，确保高质量、高效、安全、低成本地做系统交付，十分注重过程和效率。所以计划管理非常适合像研发这样的团队去做管理。</p><p><strong>三、计划管理也是一个过程管理</strong></p><p>有一些团队拍着胸脯说：“你就不用管啦，我季度末给你结果！”</p><p>这不算过程管理，它虽然有目标有结果，但是却没有关注过程，所以它其实就是绩效管理。像这样“不用管，到时候保证给出结果”的情况在很多公司和团队中都存在，这种管理方式极其容易出现管理失控。</p><p>结果团队，例如销售的KPI管理的review周期比较短，通常以周或者月为维度来review销售结果，这严重依赖个人能力而不是制度或者流程。过程管理运用到研发团队身上的话，绩效考核一般来说粒度更粗，以季或者年为维度review结果，也就不大会出现“拍胸脯”的现象，以避免管理失控。</p><p>既然计划管理是一种方法和工具，想要做好管理就需要去多学习、多练习。那么如何培养好好的管理习惯？大家回想一下自己的编码习惯是怎么培养出来的，应该就是通过不断写代码而训练出来的。所以类比一下，对于计划管理也是一样的，我们需要养成做计划的习惯，刻意训练自己运用这种管理方式的习惯。</p><p>举个例子，比如我负责58到家的技术部，而且在2020年有一个“提效、为效率负责、为项目交付吞吐量负责”目标。首先我会和技术团队解释我们有这样的目标是因为它与我们的职责相关，然后明确目标的内容是“本季度或者本年的交付吞吐量要提升到20%，线上线下bug要降低多少”等等。</p><p>其实这就是要向你带领的团队明确我们<strong>为什么做、做什么和怎么做</strong>，以及其他细节：</p><ul><li><strong>为什么做？</strong> 为了提高效率；</li><li><strong>做什么？</strong> 建设技术体系；</li><li><strong>怎么做？</strong> 讨论现在效率的瓶颈是什么，找出项目流程中的主要矛盾到底是需求评审阶段、项目设计阶段、研发阶段、链条阶段还是上线阶段。哪个过程最耗时间，如果是需求评审阶段很低效，产品没想清楚，那么我们这个季度就会主要抓这个部分来提高效率；如果是上线阶段，我们没有好的工具和平台，都是依赖于人肉，整个过程都是主要矛盾的话就重点抓这一块；</li><li><strong>时间节点？</strong> 季度；</li><li><strong>负责人？</strong> 我，沈剑。</li></ul><p><strong>四、计划管理五要素</strong></p><p>看完之后其实会发现，上面说的<strong>做什么、为什么、怎么做、时间节点、责任人</strong>这些要素，不管是带领团队做产品项目、业务项目还是技术项目，在计划管理中就是最重要的五要素。为了方便大家记忆，计划管理五要素可以记成“他问我为何”，也就是<strong>Target、Why、When、Who、How（TWWWH）</strong>。</p><p>1、 <strong>T（Target）：</strong></p><ul><li>首先设定好目标；</li><li>其次这个目标必须承接战略和部门职责，比如说部门职责是提高效率、高质量、低成本、安全地交付。目标必须和职责相关。为什么要建设技术体系，一定是更高效、更高质量的和交付相关的。</li></ul><p><strong>2、W（Why）：</strong></p><ul><li>项目成立原因，比如研发团队的职责相关，所以要提高效率、建设技术体系、改进上线流程、改进产品协作流程等等；</li><li>这个点是负责人和管理者在做计划、传达的过程中最容易忽略的一个点。很多时候我们只跟大家同步业务目标和结果、项目目标和结果，但是没有传达为什么要做这件事情，这就导致了很多员工执行不到位。是因为他们在做这件事情的时候，本身就不认同这件事情的目标，也不知道为什么要做；</li><li>比如目标是技术体系建设，有些运维人员会觉得自动化运维工具会取代自己的岗位，他不认可这个目标。但是这个工具在平台建设中和部门职责息息相关，是必须要完成的事情。所以，在传达的时候要解释清楚这个工具会帮助运维团队提高工作效率，让他们有时间专注在其他关于自动化的工作上，而不是不断重复上线操作。这样，一旦他们认可你的目标之后，执行计划和配合工作才会更加顺畅。</li></ul><p><strong>3、W（When）：</strong></p><ul><li><p>时间点很重要，比如本季度或者今年要提升多少；</p></li><li><p>如果你说今年要完成5、6个项目，员工听着就会觉得时间粒度非常粗且不可控，会导致他们完成的信心指数非常低。如果把这个时间节点进一步细化和拆解，今年要完成5、6个项目，其中容器化项目实现需要12个步骤，并且每个动作需要1个月来完成。这样将时间点做了细致的拆解，听着相对可控，员工对于完成这个指标的信心指数就会比较高。又比如说这个项目需要2个星期上线，时间粒度粗所以项目风险也高，如果你说项目需要研发几个接口、每个链条和自测需要多长时间，时间拆解越细，老板对你完成这个计划的信心指数就高；</p></li><li><p>对于时间这一块想要强调的是，在做计划时尽可能将时间粒度拆解得细、最大程度明确动作，这样老板看完你的计划之后信心指数比较高，会觉得项目交给你之后他就不需要实时和你同步项目，他可以把精力放在别的项目上。</p></li></ul><p><strong>4、W（Who）：</strong></p><ul><li><p>在计划和管理中，责任人要对整个项目负责；</p></li><li><p>项目成功，就要奖励；项目失败，责任人就需要对项目负责。</p></li></ul><p><strong>5、H（How）：</strong></p><ul><li><p>分解、实施、review、复盘、改进行动计划以达成目标；</p></li><li><p>需要完成计划、明确目标、上传下达、提高老板信心指数；</p></li><li><p>举一个很粗粒度的例子，2019年我负责58到家的技术中心，当时老板向我提了一个要求，就是要提升团队的效率。提升团队的效率是在明确职责的前提下，相同的事情能够让更少的人去做，或者是人数不变的情况下承担更多的职责。我会首先，按季度粗粒度地将计划进行拆解：</p></li><li><p><strong>Q1：</strong> 在架构侧、中台侧、基础服务侧和企业平台侧，可能要做效能的提升；而运维侧和IT侧可能需要成立虚拟的组织，让更少的人能去做更多的事情。Q1要成立一个创新的部门，去做一些创新的事情，Q1可能只完成了一部分，等我把这一块拆解之后，就把这个目标给相关的总监，由他做更细化的拆解；</p></li><li><p><strong>Q2：</strong> 可能有两个部门的人效比较低，有人员的汰换或者质量部、效能部的重组架构调整，那我Q2主要抓这一块的矛盾；</p></li><li><p><strong>Q3：</strong> 有些部门反馈到数据部，觉得效率比较低，那么就要对大数据进行调整。同时创新的方面，又孵化出了一个保险业务；</p></li><li><p><strong>Q4：</strong> 我做了一级的拆解之后递归给下面的总监和经理做二级的拆解，可能最终年效提升了10%，节省40%的人完成过去相同的工作，又或者在人数不变的情况下，我还孵化了两个创新的产品。</p></li><li><p>我必须确保在我的管理范围内，所有人都知道我们的年度总目标是什么、为什么要做、计划是什么、每一块的负责人是谁、初步的规划怎么做。</p></li></ul><p>大家可以想想，你们的团队是否明确了今年整个技术部的目标，或者你们部门是否明确了目标，又或者你们最近一个项目的目标是什么。你的团队人员究竟是清清楚楚，还是简单地被分配和执行工作。</p><p>如果他们对目标不清楚或者不认可这个目标，在执行的过程中就很有可能出现很大的阻力，也会有很多的问题。</p><p>还有就是，你们到底有没有和他们讨论怎么做。很多人会这样说，“人效要提升40%”，那你没有具体拆解过的行动计划，如果没有那最后就是靠天看这个目标能不能达成。</p><p>有没有负责人和明确的时间点，在怎样的时间节点要达成怎样的目标。</p><p>所以TWWWH（他问我为何），目标、为什么、时间节点、负责人、怎么做这五项因素在做计划管理中非常重要。</p><p><strong>五、计划管理核心讨论什么</strong></p><p>1、怎么做很重要</p><p><strong>计划管理最核心应该讨论：怎么做。</strong></p><p>举个具体的例子，比如我所负责的快狗的技术中心的部门，Q2的项目吞吐量中一个效率指标要提升30%。我们初步定的目标是30%，挑战点的目标是50%，其实我们并没有花多大的精力去讨论目标是30%还是50%。但是很多同学在做计划的时候会很精细地计算到，“我要提升15%，我算过了，做A可以提升5%，做B可以提升5%，做C和做D可以提升5%，所以总体可以提升15%。”</p><p>我不知道大家在定OKR的时候是不是这样细算出来的。我们知道，制定OKR的时候要制定有挑战的目标，而且最好50%概率能够完成，也就是跳一跳能够得到的目标。</p><p>所以你要把效能提升30%还是35%还是50%，其实没那么重要。甚至很多业务，你问他的业务增长目标是怎么做出来的，这很有可能就是老大拍板的。</p><p>怎么做非常重要，在做计划管理的过程中我们应该把时间放在讨论怎么做上面，重点应该讨论行动计划的制定。</p><p>我们重点需要花时间去想，执行中可能会有的潜在困难、这些困难的解决方案，再配合定期的执行、校验和行动计划的更新。</p><p>2、如何复盘</p><p>定期的执行和检查，我也不知道大家会不会定期复盘项目，你们的项目复盘会怎么开，重点说什么，但你们想一想是不是下面这个样子：</p><p>首先摆数据，我们订单增长了多少、效能提升了多少、体系化项目进度是多少；然后找原因，解释这个地方为什么没有达成预期，去做各种各样的解释。这是一种非常错误的复盘会。当然找原因是必须的，但是你会发现你找到原因解释，对后续的改进没有任何意义，所以复盘会上要重点讨论什么呢？</p><p><strong>要重点讨论后续的行动计划、潜在风险、解决方案和行动的变更。</strong> 制定计划的时候要讨论行动计划和怎么做，复盘的时候也要重点讨论行动计划。之前做对了的我们要继续做，什么行动要保持，之前做错了什么或者什么没有做对，我们也要纠偏回来。</p><p>但是我参加过很多复盘会，这些会可能都和追责有关。很多复盘会做这样的工作，通篇都在解释为什么这个项目没有达成预期，不是我的原因而是别人的原因。</p><p>我又举个例子，我对Q2产品效能的提升定了一个50%的目标，最终目标完成了80%。Q2过去之后，我们要怎样复盘？</p><p>我们做对了什么？可能是组织架构调整了，目标更清晰了。原来一开会大家都在扯皮，说测试是瓶颈所以要加测试，说前端是瓶颈所以要加前端。我将组织架构调整成相对闭环的部门，业务里有一个研发小组，包含了测试、研发、前端和后端，那么原来沟通的成本就降低了，大家都看齐同一个业务目标，背一个业务指标，扯皮就减少了，沟通就更高效了，这样对项目提升可能有帮助。</p><p>最简单的方法，比如说五、六月份是战略重心，有几个战略项目都要上线。有些老大会说，“这两个技术团队的同学辛苦辛苦，周六来冲个刺。”这样可能团队多工作一天就提升了20%的效能，但我特别反对长期通过这种方式来提升迭代速度。我们还是要通过优化流程和工具去优化、提升速度。</p><p>又像刚刚说到的流程这一块，在项目流程过程中，原来在需求阶段可能存在问题但我没有改进，所以最终只提升了5个点。</p><p>或者说，原来上线都是通过人工，而现在用自动化的上线工具；原来搭建测试环境需要很长时间，现在通过自动化的方式去搭建测试环境，这样对效能的提升是肯定有帮助的。这方面就需要管理者了解当前的主要矛盾，并去解决这些主要矛盾。</p><p>如果你觉得人员技能不到位，那你就能要去做培训；你觉得不靠谱，那你就要做汰换。反正到了季度末我们复盘的时候，做对了的事情在下个季度就继续做，做错了的事情就要停止做，能够继续迭代的空间，我们就要去优化。</p><p>在计划管理的过程中，大家要多花时间去讨论行动计划，在复盘中讨论做对了什么、行动计划要改变什么，而不是单纯的质量和数字，以及解释、推脱或者甩锅，这样对后续达成目标没有什么帮助。所以我想表达的是，花时间的重头戏应该是制定行动计划。</p><p><strong>六、计划管理的两大特点</strong></p><p>1、目标不合理性</p><p>前面提到了怎样的OKR是好的OKR，如果你达成的概率是50%，50%概率不能达成，这个目标跳一跳就可以够得到，那这样的目标是好目标。</p><p>再举一个例子，Q2有一个项目是IDC或者叫集群，快狗侧可能有几百个集群原来做了过度的设计，微服务化拆分出了太多细粒度的服务，导致维护起来成本很高。那我们说Q2可能要做一些集群的合并和架构的优化。</p><p>当时项目有一个负责人，我让他提一个目标，他纠结了很长的时间，说我不知道集群要减少10%，还是15%，还是8%。但其实你会发现，不管这个值是多少，后面重点要花时间去讨论的是行动计划、怎么样合并集群、架构怎样更合理、以什么样的节奏去执行。其实目标是10%还是30%，和后面讨论的行动计划是没有关系的。所以后来我就说，那我定下20%这个值，然后Q2就按照这个目标去走，看Q2能不能达成20%的OKR。</p><p>OKR和KPI不一样。KPI达成与否跟你的涨薪或者跟你的绩效有关，但是OKR指定的是有挑战的OKR，所以你的leader一定要综合实现难度系数去打分。虽然说我拍了一个目标，但是因为我是一个技术专家，所以我在拍的过程中是有所谓的专业手感的，我并不是瞎拍的。</p><p>我实际是想了一下，20%的目标去做工作有一定的挑战，但就是能够实现的。在这个拍目标的过程中，能够体现我的专业手感。在一个专业领域里浸淫久了，拍目标的时候其实能够体现专业手感，IDC减少多少、效能提升多少、订单增长多少更合理，这些都能够体现你的专业手感。</p><p>总之，计划管理有一项特点是目标不合理，因为目标本身是一个预测，目标要符合战略的要求，而且目标更重要的是体现你对某一部分的决心。很多时候项目目标定下来了，团队管理反而简单了。有些团队之所以不出成果，是因为花了大量时间放在目标讨论上，而且在制定目标的过程中往往也提出了很多困难，去强调达成目标非常有挑战，并持续降低自己的目标，直到目标降低到自己有把握的程度。这个不是OKR，也不是计划管理。OKR不是在制定目标的时候有大概率能完成的感觉，而是一个有挑战的目标。</p><p>未来也希望大家在做计划管理的过程中，能够制定一个有50%概率能够完成的目标，这就是一个好的OKR目标。目标在制定的过程中也能够体现你的专业手感，所以如果你让一线的同学来这个事情会更不靠谱，因为一线的同学更多思考自己怎么才能不出错，所以你让他去定目标，一定是自己能够实现的。他们关注的更多是自己，可能不是业务或者公司的压力。</p><p>我们作为leader，有一项非常重要的要求，你要同时具备内外部视角。外部怎么看问题，你的老板希望你能达成什么目标。而很多一线的员工可能缺乏外部视角，他们可能更多思考的是做什么能够不出错，所以我要制定一个我能够完成的目标，这样我就能拿到奖金。这就是典型的KPI或者自我的思维。</p><p>计划管理的第一个特点，也是不必花太多时间精准地制定目标。很多时候大家精准地讨论目标，就会强调这个事情有多难、多有挑战，会持续地降低目标，直到降到一个自己有把握的目标。你想想，这样对团队的发展和对业务的发展，都是非常不利的。</p><p>2、行动计划的合理性</p><p>行动计划必须合理，你要花最多的时间在讨论行动计划上。</p><p>资源匹配要合理，如果你没有给我那么多的预算，我拿不到那么多的市场费用和流量，你也没有足够的研发团队，那你让我在一个月之内干出那么多系统，我做不到。所以行动计划的拆解必须是合理的。</p><p>下面举一个例子，快狗打车在做Q2的容器化项目来提升的自动化程度时有一个负责人，负责人是我们这边运维的总监，目标是Q2整个测试环境容器化全覆盖。</p><p>他就解释给团队听：</p><ul><li>为什么要做这件事情，你要提高效率，跟我们的职责相关；</li><li>时间节点是一个季度，我们要达成测试环境的覆盖，他就进行拆解，总共有200个集群，第一个月要覆盖80个，第一个星期要覆盖哪10个集群完成容器化；</li><li>每一块工作继续拆细，研发和运维团队要负责哪部分；</li><li>在季度初，他就做了一个计划管理，然后在每个月执行的过程中，以月为单位进行review。上个月我计划完成三分之一，那我有没有80个集群测试环境的三分之一Docker容器化覆盖？如果项目delay了，我要发现为什么项目delay了；如果有一块技术方案我们想得简单了，那有什么解决方案？如果我们后续的行动计划可能要改变，我们就得加进人手，让大家更重视或者晚上加一个小时班，这样去不断地调整自己的行动计划，不断复盘之前哪一块工作做得好，做对的要继续做，做错的要停止做，迭代优化要继续改进。</li></ul><p><strong>总结</strong></p><p><strong>1、</strong> <strong>对管理者最基本的要求，是对目标的承诺</strong></p><p>你能够承诺多大的目标，你的岗位就有多大的价值。</p><p>大家想一想，你能跟你的老板举手说我愿意背什么样的指标。你这句话承诺的指标，项目、系统、团队或者业务的一个指标，你都会发现跟你的岗位有关。你的职位越高你承诺的指标和负责的范围会越大。</p><p><strong>2、</strong> <strong>计划管理是一切管理的基础，计划管理也是目标达成的一个工具</strong></p><p>基础管理非常重要的几项：</p><ul><li>计划管理解决的是目标及目标达成工具的问题；</li><li>流程管理要确定核心的业务流程。产研侧的话就是项目流程，确定实现过程中的岗位、解决事事有人做，人人有事做的问题。大家可以去看看，你们的团队是不是缺某些岗位，观察有没有PMO岗等等；</li><li>组织管理确定权责的关系，解决负责的人必须有权，有权的人必须为结果负责的问题。</li></ul><p>流程管理，一旦流程确定岗位确定之后，我们在日常管理的过程中，再改流程的概率就会变小，你花在这个上面的比重也会小。组织管理也是一样的，一旦权责明确，组织架构明确。其实你调整的频率也是很小的，</p><p>所以基本上作为一个管理者，不管你是做项目管理还是团队管理，无论你是做业务项目还是技术项目，绝大部分的工作都应该花在计划管理上。</p><p>设定目标、设定行动计划、追踪行动计划，做好了计划管理就能做一个80分的管理者。</p><p><strong>3、</strong> <strong>计划管理，非常适合关注过程和效能的“非绩效部门”</strong></p><p>研发团队是典型的为交付、产品负责的“非绩效部门”。部门的职责是高效、高质、低成本、安全性地进行交付，这样的部门非常适合计划管理。所以理论上，这种部门的管理者绝大部分做计划管理都是定目标、做行动计划、review和达成。</p><p><strong>4、</strong> <strong>计划管理是一个过程管理</strong></p><p>过程管理对销售部门来说更多的是KPI导向，要完成多少的销售业绩，每个大区有每个大区的玩法，每个城市经理有每个城市经理的玩法，每个团队的执行过程都是不一样的。如果通过拍胸脯的方式，这样的团队review的频率或者是绩效考核频率可能会比较高，会以周或者月为单位。</p><p><strong>5、</strong> <strong>计划管理五要素：他问我为何（TWWWH）</strong></p><ul><li><strong>目标（T）；</strong></li><li><strong>为什么（W）：</strong> 这是Leader在管理的过程中很容易忽略的和下属和团队成员进行沟通的问题。Leader的职责是上传下达，很多时候你只是告诉他们业务目标是这个，项目交付时间是这个，但你没有告诉他，他为什么要做这个业务和项目，这样可能会引发团队成员的归属感或者疑虑。当他不认同这件事情的时候，他可能就会成为达成目标的一个反推力，所以这个部分非常重要；</li><li><strong>时间节点（W）：</strong> SMART法则，要有时间概念；</li><li><strong>责任人（W）：</strong> 责任人很重要。负责的人要有权，有权的人要负责，你有没有授予他协调资源和完成目标的权力也很重要；</li><li><strong>怎么做（H）：</strong> 为什么很多团队的目标无法达成，可能是在制定目标的时候只提到这个季度要提升50%，但是没有提及怎么提升50%。如果就这样做了再说吧，那到了季度末的时候整个管理是会是失控的，整个项目和业务达成也是失控的。整个过程的初期中最核心要讨论的就是怎么达成，而不是你的目标到底是10%还是15%。</li></ul><p><strong>6、</strong> <strong>计划管理中，核心要讨论怎么做</strong></p><p><strong>7、</strong> <strong>计划管理两大特点：</strong></p><ul><li><strong>目标的不合理性：</strong> 不要花太多时间在讨论目标上，定一个50%概率能达成的、跳一跳就能够达成的目标是最合适的；</li><li><strong>行动计划的合理性：</strong> 行动计划和资源匹配必须是合理的，不能是不切实际的。</li></ul><p><strong>团队管得好不好，可以看大家有没有养成“计划管理”的习惯！</strong> 如果你做的不好，大概率是季度初制定了目标，但不做行动计划、不做review复盘，季度末达成还是不达成，就全靠天。所以我也要求我的团队在各块工作都需要做计划管理，初期讨论行动计划，review整个过程，而不是找借口和做推脱，并且季度末也会根据他工作的难度系数给予他应得的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 本文根据沈剑老师在〖deeplus直播第237期〗线上分享演讲内容整理而成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家好，我是快狗打车的产品技术设计团队的负责人沈剑，可能很多人通过“架构师之路”认识了我。在这些年里我身上肩负着架构师和团队领</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>什么是 VLAN、三层交换机、网关、DNS、子网掩码、MAC地址</title>
    <link href="http://ai.mak.cn/2020/08/26/%E7%BD%91%E7%BB%9C/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%20VLAN%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80/"/>
    <id>http://ai.mak.cn/2020/08/26/%E7%BD%91%E7%BB%9C/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%20VLAN%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2023-01-12T05:12:28.948Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、什么是vlan?</strong></p><p>VLAN中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p><p>听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分vlan？</p><p><strong>这里举个例：通俗的了解</strong></p><p>一所高中，新学期高一招了800个学生，这800个学生，如果放在一个班里，那肯定是管理不过来，面对800个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从800份信息中去找，极其麻烦，浪费时间；</p><p>而实际中，也是一样，电脑A要想要与电脑B通信，于是电脑A就需要发送arp请求，而网络中电脑众多，最终ARP请求会被转发到同一网络中的所有电脑，才能找到电脑B，如此一来，为了找到电脑B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。</p><p><strong>那么怎么办呢？</strong></p><p>学校就针对这800个学生，分成了10个班，每个班80人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。</p><p>1101表示一班01号学生。</p><p>1102表示一班02号学生。</p><p>1201表示2班01号学生。</p><p>同一个班的学生编号尾数不同，其它的都相同。</p><p>那么这样老师再管理起来就轻松多了，可以把一班这80人管理的妥妥的，隔壁2班与3班乱成一锅粥也不管一班的事，我就要这一班80人好好上课就行。</p><p>这就是vlan，每个班就相当于一个vlan，而每个班名称，就相当于vlan的名称，而每个学生的编号就是ip地址；同班同学（同一个vlan的ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。</p><p>所以同一个vlan间，可以相互通信；不同vlan，若不做配置，不能相互通信。</p><p>搜索公众号程序员小乐回复关键字“offer”获取算法面试题和答案。</p><p>那么不同vlan如何通通信呢？就需要单臂路由与三层交换机。</p><p><strong>二、单臂路由与三层交换机</strong></p><p>我们知道要实现不同vlan间通信，就必须需要有路由功能，不同VLAN之间相互通信的两种方式（单臂路由、三层交换机）。</p><p><strong>什么是单臂路由？</strong></p><p>单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同vlan间的可以互相通信。</p><p><img src="https://aimak.cn/blog_img/tools/network/danbituopu.jpeg"></p><p><strong>那什么是三层交换机呢？</strong></p><p>对于小型的网络，单臂路由可以应付，但随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。</p><p>为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。</p><p>关于三层交换机的内部结构，可以参照下面的简图。</p><p><img src="https://aimak.cn/blog_img/tools/network/sanceng.png"></p><p>在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。</p><p><strong>三、什么是网关</strong></p><p>在了解了vlan与三层交换机后，能不能通信，还需要看网关是否正确。</p><p><strong>一、什么是网关</strong></p><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p><strong>二、如何来理解网关</strong></p><p>大家都知道，从一个房间走到另一个房间，必然要经过<strong>一扇门</strong>。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“<strong>关口</strong>”。</p><p>按照不同的分类标准，网关也有很多种。TCP&#x2F;IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP&#x2F;IP协议下的网关。</p><p><strong>三、网关的ip地址</strong></p><p><strong>那么网关到底是什么呢？</strong></p><p>网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用<strong>ip中选一个</strong>，不过，一般用的是<strong>第1个和最后一个</strong>。</p><p><strong>例如</strong></p><p>比如有网络A和网络B，</p><p><strong>网络A：</strong>的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p><strong>网络B：</strong>的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p>  <img src="https://aimak.cn/blog_img/tools/network/ipaddr.jpeg"></p><p><strong>四、网关是如何实现通信？</strong></p><p>在没有<strong>路由器</strong>的情况下，不同的两个网络之间是<strong>不能</strong>进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则<strong>必须通过网关</strong>。</p><p>如果<strong>网络A</strong>中的主机发现<strong>数据包</strong>的目的主机<strong>不在</strong>本地网络中，就把数据包转发给它<strong>自己的网关</strong>，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。</p><p>所以说，只有设置好网关的<strong>IP地址</strong>，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。</p><p><strong>五、什么是默认网关？</strong></p><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。<strong>默认网关</strong>的意思是一台主机如果找不到可用的网关，就把数据包发给默认<strong>指定的网关</strong>，由这个网关来处理数据包。现在<strong>主机</strong>使用的网关，一般指的是默认网关。 </p><p><strong>四、什么是DNS</strong></p><p>DNS是域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>搜索公众号程序员小乐回复关键字“Java”获取Java面试题和答案。</p><p>DNS说白了是把域名翻译成IP地址用的，这里面<strong>举个例子</strong>，大家就很容易清楚了。</p><p>例如我们在浏览器里面输入<a href="http://www.baidu.com的时候,机器要跟百度这个网站进行**通信**,机器要往外面**发送**数据包,数据包里面要写百度这台服务器的**ip地址**,我们不知道ip地址是多少,那么就需要主机**问dns服务器**,dns服务器就自动帮我们把www.baidu.com这个域名**翻译成**了ip地址61.135.169.105.然后写到了数据包的目的ip地址里面就可以进行通信./">www.baidu.com的时候，机器要跟百度这个网站进行**通信**，机器要往外面**发送**数据包，数据包里面要写百度这台服务器的**IP地址**，我们不知道IP地址是多少，那么就需要主机**问DNS服务器**，DNS服务器就自动帮我们把www.baidu.com这个域名**翻译成**了IP地址61.135.169.105。然后写到了数据包的目的IP地址里面就可以进行通信。</a></p><p>就跟我们写信一样，你得写个收信人的<strong>地址</strong>邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是DNS的作用，所以你的在本地连接里面写DNS才可以正常浏览网页，如果不设置DNS，是无法正常访问网页的。</p><p><strong>五、MAC地址</strong></p><p>讲到MAC地址，就不得不提ip地址，这里顺便把ip地址也说下。</p><p><strong>IP与MAC</strong></p><p>虽然现在已经ipv6了，但我们基本用的大多数还是ipv4协议，所谓ip就是你电脑整个<strong>网络的编号</strong>。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在<strong>变化</strong>的。唯一不变的是你的MAC地址：<strong>物理地址</strong>。</p><p>MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>做个比喻，你经常搬家，你没搬一次家都有一个地址，XX小区XX单元XX号，这个就是IP。但是你的名字不变，这个就是MAC，不同的是我们的<strong>MAC不允许重名。</strong></p><p><strong><img src="https://aimak.cn/blog_img/tools/network/mac_info.jpeg"></strong></p><p><strong>我们的IP分为两个部分：</strong>如上图分为<strong>网络部分</strong>和<strong>主机部分</strong>。网络部分好比就是你在XX省XX市XX镇，这个是国家固定下来了的。但是XX小区XX单元XX号是开发商自己定的。两个编号<strong>加起来</strong>就是你的ip了。不同的是在现实中两个编号的长度是固定的，在网络上A、B、C、D的ip地址却是变化的，这个在前天有详细讲到。</p><p><strong>六、子网掩码</strong></p><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由<strong>网络部分</strong>和<strong>主机部分。</strong>正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><p><strong>举个例子</strong></p><blockquote><p> <strong>有一个网段</strong>是192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p></blockquote><blockquote><p> <strong>另外有一个网段，</strong>是192.168.0.0——192.168.255.254，我们叫它<strong>安村</strong>，村里有个同样有两个ip地址为92.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？</p></blockquote><blockquote><p> 这个时候就需要<strong>子网掩码</strong>了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是255.255.255.0，<strong>安村</strong>的网段是255.255.0.0。</p></blockquote><blockquote><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、什么是vlan?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VLAN中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。&lt;/p&gt;
&lt;p&gt;听上面的概念</summary>
      
    
    
    
    <category term="网络" scheme="http://ai.mak.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java 工具包Hutool</title>
    <link href="http://ai.mak.cn/2020/08/13/java/Java%20%E5%B7%A5%E5%85%B7%E5%8C%85Hutool/"/>
    <id>http://ai.mak.cn/2020/08/13/java/Java%20%E5%B7%A5%E5%85%B7%E5%8C%85Hutool/</id>
    <published>2020-08-12T16:00:00.000Z</published>
    <updated>2023-01-12T04:58:37.650Z</updated>
    
    <content type="html"><![CDATA[<p>Hutool 谐音 “糊涂”，寓意追求 “万事都作糊涂观，无所谓失，无所谓得” 的境界。</p><p>Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以 “甜甜的”。Hutool 最初是我项目中 “util” 包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。（抄自作者简介）</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一个 Java 基础工具类，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类，同时提供以下组件：</p><ul><li>hutool-aop JDK 动态代理封装，提供非 IOC 下的切面支持</li><li>hutool-bloomFilter 布隆过滤，提供一些 Hash 算法的布隆过滤</li><li>hutool-cache 缓存</li><li>hutool-core 核心，包括 Bean 操作、日期、各种 Util 等</li><li>hutool-cron 定时任务模块，提供类 Crontab 表达式的定时任务</li><li>hutool-crypto 加密解密模块</li><li>hutool-db JDBC 封装后的数据操作，基于 ActiveRecord 思想</li><li>hutool-dfa 基于 DFA 模型的多关键字查找</li><li>hutool-extra 扩展模块，对第三方封装（模板引擎、邮件等）</li><li>hutool-http 基于 HttpUrlConnection 的 Http 客户端封装</li><li>hutool-log 自动识别日志实现的日志门面</li><li>hutool-script 脚本执行封装，例如 Javascript</li><li>hutool-setting 功能更强大的 Setting 配置文件和 Properties 封装</li><li>hutool-system 系统参数调用封装（JVM 信息等）</li><li>hutool-json JSON 实现</li><li>hutool-captcha 图片验证码实现</li></ul><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>这两天使用 Hutool 把 Halo 里面的一些代码给替换掉了，不得不说，用起来十分顺心，下面简单介绍一下我用到的一些 Hutool 的工具类。</p><h3 id="SecureUtil（加密解密工具）"><a href="#SecureUtil（加密解密工具）" class="headerlink" title="SecureUtil（加密解密工具）"></a>SecureUtil（加密解密工具）</h3><p>主要是在登录的时候还有修改密码的时候用到的，因为数据库里面的密码是 md5 加密处理的，所以登录的时候需要先加密之后再到数据库进行查询，使用 Hutool 的话，只需要调用 <code>SecureUtil</code> 中的 md5 方法就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = userService.userLoginByName(loginName,SecureUtil.md5(loginPwd));</span><br></pre></td></tr></table></figure><h3 id="HtmlUtil（HTML-工具类）"><a href="#HtmlUtil（HTML-工具类）" class="headerlink" title="HtmlUtil（HTML 工具类）"></a>HtmlUtil（HTML 工具类）</h3><p>这个工具类就比较厉害了，不过我在 Halo 当中用得最多的还是 <code>HtmlUtil.encode</code>，可以将一些字符转化为安全字符，防止 xss 注入和 SQL 注入，比如下面的评论提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comment.setCommentAuthor(HtmlUtil.encode(comment.getCommentAuthor()));</span><br></pre></td></tr></table></figure><p>这就是防止有小坏蛋故意写一些可执行的 js 代码，然后提交评论，在后台面板就会执行这一段代码，比较危险，使用 encode 方法就可以将 <code>标签给转化成</code>，这样转化之后，js 代码就不会执行了。</p><p>另外，HtmlUtil 还提供了以下方法，有兴趣的可以去试一下。</p><ul><li>HtmlUtil.restoreEscaped 还原被转义的 HTML 特殊字符</li><li>HtmlUtil.encode 转义文本中的 HTML 字符为安全的字符</li><li>HtmlUtil.cleanHtmlTag 清除所有 HTML 标签</li><li>HtmlUtil.removeHtmlTag 清除指定 HTML 标签和被标签包围的内容</li><li>HtmlUtil.unwrapHtmlTag 清除指定 HTML 标签，不包括内容</li><li>HtmlUtil.removeHtmlAttr 去除 HTML 标签中的属性</li><li>HtmlUtil.removeAllHtmlAttr 去除指定标签的所有属性</li><li>HtmlUtil.filter 过滤 HTML 文本，防止 XSS 攻击</li></ul><h3 id="CronUtil（定时任务）"><a href="#CronUtil（定时任务）" class="headerlink" title="CronUtil（定时任务）"></a>CronUtil（定时任务）</h3><p>这个工具就更厉害了，完全不需要类似 <code>quartz</code> 这样的框架来做定时任务，而且 CronUtil 也不需要任何其他依赖，只需要在 resources 下建一个配置文件，然后在程序启动的时候将定时任务开启就行了，如 Halo 的定时备份功能（每天凌晨 1 点备份一次）。</p><p>cron.setting:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupResources = 0 0 1 * * ?</span><br><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupDatabase = 0 0 1 * * ?</span><br><span class="line">cc.ryanc.halo.web.controller.admin.BackupController.backupPosts = 0 0 1 * * ?</span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextRefreshedEvent event)&#123;</span><br><span class="line"> this.loadActiveTheme();</span><br><span class="line"> this.loadOptions();</span><br><span class="line"> this.loadFiles();</span><br><span class="line"> this.loadThemes();</span><br><span class="line"> //启动定时任务</span><br><span class="line"> CronUtil.start();</span><br><span class="line"> log.info(&quot;定时任务启动成功！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用方法请看文档 <a href="http://hutool.mydoc.io/?t=255673">http://hutool.mydoc.io/?t=255673</a></p><blockquote><p>好了，就介绍这三个工具类，有兴趣的可以去试试其他的工具，挺全的，这应该是我用过最好用的一个工具类库了，值得一试。</p></blockquote><p>官网地址：<a href="http://www.hutool.cn/">http://www.hutool.cn/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hutool 谐音 “糊涂”，寓意追求 “万事都作糊涂观，无所谓失，无所谓得” 的境界。&lt;/p&gt;
&lt;p&gt;Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以 “甜甜的”。Hutool 最初是我项目中 “</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>技术管理者管理模板总结</title>
    <link href="http://ai.mak.cn/2020/07/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E7%AE%A1%E7%90%86%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2020/07/20/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E7%AE%A1%E7%90%86%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2023-01-12T04:48:23.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="看方向"><a href="#看方向" class="headerlink" title="看方向"></a><strong>看方向</strong></h2><ul><li>向上级明确团队的职责</li><li>基于职责确定团队的使命、目标</li><li>把职责、使命向团队成员传达清楚</li><li>做好团队规划，包括：规模、分工、梯队、资源盘点等</li><li>建立团队的WIki，包括：职责、使命、目标、团队规划、人员分工、规章制度等</li></ul><h2 id="管事"><a href="#管事" class="headerlink" title="管事"></a><strong>管事</strong></h2><ul><li><p>OKR</p></li><li><ul><li>制定团队OKR，对齐公司和部门OKR</li><li>跟进团队成员的个人OKR制定和进度跟踪</li><li>跟踪OKR进展，识别高绩效人才</li></ul></li><li><p>技术管理</p></li><li><ul><li><p>参与技术方向决策，将研发规范、例会等信息明确传达给团队成员并推进</p></li><li><ul><li>技术评审规范</li><li>代码风格规范</li><li>代码开发规范</li><li>代码管理规范</li><li>CodeReview规范</li></ul></li><li><p>组织技术评审、CodeReview</p></li><li><p>制定学习分享机制并切实推行</p></li><li><p>团队所负责维护的系统的周期巡检</p></li><li><p>公司层面基础技术以及成熟开源项目的引入和推进</p></li></ul></li><li><p>项目管理</p></li><li><ul><li><p>创建并保持项目文档的更新</p></li><li><ul><li>需求文档</li><li>技术调研文档</li><li>方案选型文档</li><li>系统设计文档</li></ul></li><li><p>根据技术评审的结果预估开发工期并做好关键时间点的把控</p></li><li><ul><li>系统、模块、功能的设计以及简述</li><li>参与的研发人员以及分工</li><li>预估工时</li><li>预计完成时间</li><li>关键时间点、里程碑</li><li>确定会议机制：晨会、周会</li></ul></li><li><p>技术方案确定</p></li><li><ul><li>技术选型</li><li>技术架构</li><li>技术难点</li><li>性能瓶颈</li><li>上下游系统</li><li>功能模块</li></ul></li><li><p>项目风险管理</p></li><li><p>项目质量管理，包括代码质量把控和监控告警设施的接入</p></li><li><p>协调资源推进项目进展</p></li></ul></li><li><p>技术产品运营</p></li><li><ul><li>提炼团队项目的公共抽象部分，组件化和平台化</li><li>组件、技术平台的推广</li></ul></li><li><p>成本管理</p></li><li><ul><li>技术选型时把成本做为重要考量项</li><li>提升团队资源的利用率</li><li>关注团队的人力成本和技术成本</li><li>关注团队的产出价值</li></ul></li><li><p>流程改进</p></li><li><ul><li>定位阻碍研发的流程节点，寻找有效的解决方案</li><li>寻求有效工具或者方案提升关键流程效率</li></ul></li><li><p>制度建设</p></li><li><ul><li>明确公司和部门的规章制度并推进实行</li><li>根据团队需要，制定团队规章制度</li><li>制定SOP，保障下限水准</li><li>明确团队例会制度</li></ul></li></ul><h2 id="管人"><a href="#管人" class="headerlink" title="管人"></a><strong>管人</strong></h2><ul><li><p>定期的一对一沟通</p></li><li><ul><li>你所负责业务的完成情况到现在怎么样？目标完成情况怎么样？</li><li>这段时间自我评价绩效如何？什么原因？</li><li>你个人有没有什么你觉得我应该知道的？</li></ul></li><li><p>关注团队成员职业规划和能力成长，给与指导和建议</p></li><li><p>关注团队成员工作状态</p></li><li><p>组织团建，提高团队凝聚力</p></li></ul><h2 id="管理仪表盘"><a href="#管理仪表盘" class="headerlink" title="管理仪表盘"></a><strong>管理仪表盘</strong></h2><p>建立自己的管理仪表盘，关注关键数据</p><ul><li>系统监控数据（QPS、硬件资源使用率、错误数等）-&gt; 提前发现系统瓶颈，消除隐患；提高资源利用率，降低成本</li><li>项目构建报告（单元测试覆盖率报告、代码质量报告、构建失败与成功概况）-&gt; 关注项目研发质量，保障持续交付</li><li>项目&#x2F;任务进度 -&gt; 保证项目&#x2F;任务正常进行</li><li>业务关键数据指标 -&gt; 关注业务价值，提升团队成员成就感</li><li>OKR进度 -&gt; 关注OKR实现状况，识别高绩效人员</li><li>团队成员的每日&#x2F;周的工作状况 -&gt; 关注团队成员状况</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;看方向&quot;&gt;&lt;a href=&quot;#看方向&quot; class=&quot;headerlink&quot; title=&quot;看方向&quot;&gt;&lt;/a&gt;&lt;strong&gt;看方向&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;向上级明确团队的职责&lt;/li&gt;
&lt;li&gt;基于职责确定团队的使命、目标&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
</feed>
