<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2023年中国数字化业务十大预测</title>
    <link href="http://ai.mak.cn/2022/11/10/%E6%9D%82%E8%AE%B0/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1%E5%8D%81%E5%A4%A7%E9%A2%84%E6%B5%8B/"/>
    <id>http://ai.mak.cn/2022/11/10/%E6%9D%82%E8%AE%B0/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E5%AD%97%E5%8C%96%E4%B8%9A%E5%8A%A1%E5%8D%81%E5%A4%A7%E9%A2%84%E6%B5%8B/</id>
    <published>2022-11-09T16:00:00.000Z</published>
    <updated>2023-01-25T02:46:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。</p><p>极不平凡的2022年即将过去，顺风、逆风、侧风的各类风浪演变成了颠覆风暴：疫情仍没有完全过去、俄乌冲突仍在继续、地缘政治风险有增无减、供应链约束仍然存在、人才鸿沟依然严峻、全球经济增长放缓甚至进入衰退。行业领导者为了应对这些风暴的影响，纷纷采用数字化优先策略，开发与运营数字化业务，2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。</p><p>即便有诸多颠覆风暴的挑战，未来5年仍将是数字化发展的黄金时期。</p><p>首先，全球数字化发展的临界点已经到来，数字经济占比、SaaS支出占比、数字化业务支出占比、数字化人才占比等已经或都将在未来5年内超过50%；其次，数字技术投资依然是全球和中国企业高管的核心聚焦点；第三，各国政府出台的政策都在鼓励数字经济发展，中国政府《“十四五”数字经济发展规划》和二十大报告都为数字经济持续高速发展擘划了蓝图；第四，过去的历史数据也展示了数字化转型对企业销售和利润的直接利好。因此，如何在数字化业务时代实现可持续发展是所有组织的诉求。</p><p>2023 IDC FutureScape 研究的重点是未来12到24个月内改变全球业务生态系统的外部驱动因素，以及技术和IT团队在定义、构建和治理数字优先时代蓬勃发展所需的技术时面临的问题。</p><p>基于中国市场的发展特点和趋势并结合IDC对全球数字化业务的预测，2023年中国数字化业务的10大预测如下：</p><p><img src="https://aimak.cn/blog_img/shuzihua/1-yuceshijian.webp"></p><p>预测1和2涵盖了数字化支出与收入，与企业未来的销售、成本与利润直接相关。</p><p>预测3和5涵盖了新生态与价值链，与未来基于生态的创新直接相关。</p><p>预测4、8和10涵盖了数字化技能与人才，与打造奔跑的数字化梦之队直接相关。</p><p>预测6、7和9涵盖了数字化价值与可持续发展，与未来环境、社会责任、治理与企业的市场价值直接相关。</p><p><img src="https://aimak.cn/blog_img/shuzihua/2-1-3.webp"></p><p><img src="https://aimak.cn/blog_img/shuzihua/3-3-7.webp"></p><p><img src="https://aimak.cn/blog_img/shuzihua/4-8-10.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年将成为企业数字化转型的拐点，即企业从数字化转型时代进入到数字化业务时代。&lt;/p&gt;
&lt;p&gt;极不平凡的2022年即将过去，顺风、逆风、侧风的各类风浪演变成了颠覆风暴：疫情仍没有完全过去、俄乌冲突仍在继续、地缘政治风险有增无减、供应链约束仍然存在、人才鸿沟依然严峻、全球</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="报告分享" scheme="http://ai.mak.cn/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>python 的一些日常高频写法总结！</title>
    <link href="http://ai.mak.cn/2022/10/17/python/Python%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E9%AB%98%E9%A2%91%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/10/17/python/Python%20%E7%9A%84%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E9%AB%98%E9%A2%91%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-16T16:00:00.000Z</published>
    <updated>2023-01-24T13:46:31.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：</p><p><a href="https://github.com/jackzhenguo/python-small-example">https://github.com/jackzhenguo/python-small-example</a></p></blockquote><h5 id="今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～"><a href="#今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～" class="headerlink" title="今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～"></a>今天给大家准备了60个python日常高频写法，如果觉得有用，那就点赞收藏起来吧～</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一、-数字"><a href="#一、-数字" class="headerlink" title="一、 数字"></a>一、 数字</h2><h4 id="1-求绝对值"><a href="#1-求绝对值" class="headerlink" title="1 求绝对值"></a>1 求绝对值</h4><p>绝对值或复数的模</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: abs(-6)</span><br><span class="line">Out[1]: 6</span><br></pre></td></tr></table></figure><h4 id="2-进制转化"><a href="#2-进制转化" class="headerlink" title="2 进制转化"></a>2 进制转化</h4><p>十进制转换为二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [2]: bin(10)</span><br><span class="line">Out[2]: &#x27;0b1010&#x27;</span><br></pre></td></tr></table></figure><p>十进制转换为八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [3]: oct(9)</span><br><span class="line">Out[3]: &#x27;0o11&#x27;</span><br></pre></td></tr></table></figure><p>十进制转换为十六进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: hex(15)</span><br><span class="line">Out[4]: &#x27;0xf&#x27;</span><br></pre></td></tr></table></figure><h4 id="3-整数和ASCII互转"><a href="#3-整数和ASCII互转" class="headerlink" title="3 整数和ASCII互转"></a>3 整数和ASCII互转</h4><p>十进制整数对应的<code>ASCII字符</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: chr(65)</span><br><span class="line">Out[1]: &#x27;A&#x27;</span><br></pre></td></tr></table></figure><p>查看某个<code>ASCII字符</code>对应的十进制数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: ord(&#x27;A&#x27;)</span><br><span class="line">Out[1]: 65</span><br></pre></td></tr></table></figure><h4 id="4-元素都为真检查"><a href="#4-元素都为真检查" class="headerlink" title="4 元素都为真检查"></a>4 元素都为真检查</h4><p>所有元素都为真，返回 <code>True</code>，否则为<code>False</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [5]: all([1,0,3,6])</span><br><span class="line">Out[5]: False</span><br><span class="line">In [6]: all([1,2,3])</span><br><span class="line">Out[6]: True</span><br></pre></td></tr></table></figure><h4 id="5-元素至少一个为真检查"><a href="#5-元素至少一个为真检查" class="headerlink" title="5 元素至少一个为真检查"></a>5 元素至少一个为真检查</h4><p>至少有一个元素为真返回<code>True</code>，否则<code>False</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [7]: any([0,0,0,[]])</span><br><span class="line">Out[7]: False</span><br><span class="line">In [8]: any([0,0,1])</span><br><span class="line">Out[8]: True</span><br></pre></td></tr></table></figure><h4 id="6-判断是真是假"><a href="#6-判断是真是假" class="headerlink" title="6 判断是真是假"></a>6 判断是真是假</h4><p>测试一个对象是True, 还是False.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [9]: bool([0,0,0])</span><br><span class="line">Out[9]: True</span><br><span class="line"></span><br><span class="line">In [10]: bool([])</span><br><span class="line">Out[10]: False</span><br><span class="line"></span><br><span class="line">In [11]: bool([1,0,1])</span><br><span class="line">Out[11]: True</span><br></pre></td></tr></table></figure><h4 id="7-创建复数"><a href="#7-创建复数" class="headerlink" title="7 创建复数"></a>7 创建复数</h4><p>创建一个复数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: complex(1,2)</span><br><span class="line">Out[1]: (1+2j)</span><br></pre></td></tr></table></figure><h4 id="8-取商和余数"><a href="#8-取商和余数" class="headerlink" title="8 取商和余数"></a>8 取商和余数</h4><p>分别取商和余数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: divmod(10,3)</span><br><span class="line">Out[1]: (3, 1)</span><br></pre></td></tr></table></figure><h4 id="9-转为浮点类型"><a href="#9-转为浮点类型" class="headerlink" title="9 转为浮点类型"></a>9 转为浮点类型</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">将一个整数或数值型字符串转换为浮点数</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: float(3)</span><br><span class="line">Out[1]: 3.0</span><br></pre></td></tr></table></figure><p>如果不能转化为浮点数，则会报<code>ValueError</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [2]: float(&#x27;a&#x27;)</span><br><span class="line"># ValueError: could not convert string to float: &#x27;a&#x27;</span><br></pre></td></tr></table></figure><h4 id="10-转为整型"><a href="#10-转为整型" class="headerlink" title="10 转为整型"></a>10 转为整型</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">int(x, base &#x3D;10) , x可能为字符串或数值，将x 转换为一个普通整数。如果参数是字符串，那么它可能包含符号和小数点。如果超出了普通整数的表示范围，一个长整数被返回。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: int(&#x27;12&#x27;,16)</span><br><span class="line">Out[1]: 18</span><br></pre></td></tr></table></figure><h4 id="11-次幂"><a href="#11-次幂" class="headerlink" title="11 次幂"></a>11 次幂</h4><p>base为底的exp次幂，如果mod给出，取余</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: pow(3, 2, 4)</span><br><span class="line">Out[1]: 1</span><br></pre></td></tr></table></figure><h4 id="12-四舍五入"><a href="#12-四舍五入" class="headerlink" title="12 四舍五入"></a>12 四舍五入</h4><p>四舍五入，<code>ndigits</code>代表小数点后保留几位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [11]: round(10.0222222, 3)</span><br><span class="line">Out[11]: 10.022</span><br><span class="line"></span><br><span class="line">In [12]: round(10.05,1)</span><br><span class="line">Out[12]: 10.1</span><br></pre></td></tr></table></figure><h4 id="13-链式比较"><a href="#13-链式比较" class="headerlink" title="13 链式比较"></a>13 链式比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 3</span><br><span class="line">print(1 &lt; i &lt; 3)  # False</span><br><span class="line">print(1 &lt; i &lt;= 3)  # True</span><br></pre></td></tr></table></figure><h2 id="二、-字符串"><a href="#二、-字符串" class="headerlink" title="二、 字符串"></a>二、 字符串</h2><h4 id="14-字符串转字节"><a href="#14-字符串转字节" class="headerlink" title="14 字符串转字节"></a>14 字符串转字节</h4><p>字符串转换为字节类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [12]: s = &quot;apple&quot;                                                            </span><br><span class="line"></span><br><span class="line">In [13]: bytes(s,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">Out[13]: b&#x27;apple&#x27;</span><br></pre></td></tr></table></figure><h4 id="15-任意对象转为字符串"><a href="#15-任意对象转为字符串" class="headerlink" title="15 任意对象转为字符串"></a>15 任意对象转为字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [14]: i = 100                                                                </span><br><span class="line"></span><br><span class="line">In [15]: str(i)</span><br><span class="line">Out[15]: &#x27;100&#x27;</span><br><span class="line"></span><br><span class="line">In [16]: str([])</span><br><span class="line">Out[16]: &#x27;[]&#x27;</span><br><span class="line"></span><br><span class="line">In [17]: str(tuple())</span><br><span class="line">Out[17]: &#x27;()&#x27;</span><br></pre></td></tr></table></figure><h4 id="16-执行字符串表示的代码"><a href="#16-执行字符串表示的代码" class="headerlink" title="16 执行字符串表示的代码"></a>16 执行字符串表示的代码</h4><p>将字符串编译成python能识别或可执行的代码，也可以将文字读成字符串再编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s  = &quot;print(&#x27;helloworld&#x27;)&quot;</span><br><span class="line">    </span><br><span class="line">In [2]: r = compile(s,&quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br><span class="line">    </span><br><span class="line">In [3]: r</span><br><span class="line">Out[3]: &lt;code object &lt;module&gt; at 0x0000000005DE75D0, file &quot;&lt;string&gt;&quot;, line 1&gt;</span><br><span class="line">    </span><br><span class="line">In [4]: exec(r)</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h4 id="17-计算表达式"><a href="#17-计算表达式" class="headerlink" title="17 计算表达式"></a>17 计算表达式</h4><p>将字符串str 当成有效的表达式来求值并返回计算结果取出字符串中内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s = &quot;1 + 3 +5&quot;</span><br><span class="line">    ...: eval(s)</span><br><span class="line">    ...:</span><br><span class="line">Out[1]: 9</span><br></pre></td></tr></table></figure><h4 id="18-字符串格式化"><a href="#18-字符串格式化" class="headerlink" title="18 字符串格式化"></a>18 字符串格式化</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">格式化输出字符串，format(value, format_spec)实质上是调用了value的__format__(format_spec)方法。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [104]: print(&quot;i am &#123;0&#125;,age&#123;1&#125;&quot;.format(&quot;tom&quot;,18))</span><br><span class="line">i am tom,age18</span><br></pre></td></tr></table></figure><table><thead><tr><th>3.1415926</th><th>{:.2f}</th><th>3.14</th><th>保留小数点后两位</th></tr></thead><tbody><tr><td>3.1415926</td><td>{:+.2f}</td><td>+3.14</td><td>带符号保留小数点后两位</td></tr><tr><td>-1</td><td>{:+.2f}</td><td>-1.00</td><td>带符号保留小数点后两位</td></tr><tr><td>2.71828</td><td>{:.0f}</td><td>3</td><td>不带小数</td></tr><tr><td>5</td><td>{:0&gt;2d}</td><td>05</td><td>数字补零 (填充左边, 宽度为2)</td></tr><tr><td>5</td><td>{:x&lt;4d}</td><td>5xxx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>10</td><td>{:x&lt;4d}</td><td>10xx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>1000000</td><td>{:,}</td><td>1,000,000</td><td>以逗号分隔的数字格式</td></tr><tr><td>0.25</td><td>{:.2%}</td><td>25.00%</td><td>百分比格式</td></tr><tr><td>1000000000</td><td>{:.2e}</td><td>1.00e+09</td><td>指数记法</td></tr><tr><td>18</td><td>{:&gt;10d}</td><td>‘ 18’</td><td>右对齐 (默认, 宽度为10)</td></tr><tr><td>18</td><td>{:&lt;10d}</td><td>‘18 ‘</td><td>左对齐 (宽度为10)</td></tr><tr><td>18</td><td>{:^10d}</td><td>‘ 18 ‘</td><td>中间对齐 (宽度为10)</td></tr></tbody></table><h2 id="三、-函数"><a href="#三、-函数" class="headerlink" title="三、 函数"></a>三、 函数</h2><h4 id="19-拿来就用的排序函数"><a href="#19-拿来就用的排序函数" class="headerlink" title="19 拿来就用的排序函数"></a>19 拿来就用的排序函数</h4><p>排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [2]: sorted(a,reverse=True)</span><br><span class="line">Out[2]: [4, 3, 2, 1, 1]</span><br><span class="line"></span><br><span class="line">In [3]: a = [&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;male&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;</span><br><span class="line">     ...: xiaohong&#x27;,&#x27;age&#x27;:20,&#x27;gender&#x27;:&#x27;female&#x27;&#125;]</span><br><span class="line">In [4]: sorted(a,key=lambda x: x[&#x27;age&#x27;],reverse=False)</span><br><span class="line">Out[4]:</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;male&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;xiaohong&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;female&#x27;&#125;]</span><br></pre></td></tr></table></figure><h4 id="20-求和函数"><a href="#20-求和函数" class="headerlink" title="20 求和函数"></a>20 求和函数</h4><p>求和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [181]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [182]: sum(a)</span><br><span class="line">Out[182]: 11</span><br><span class="line"></span><br><span class="line">In [185]: sum(a,10) #求和的初始值为10</span><br><span class="line">Out[185]: 21</span><br></pre></td></tr></table></figure><h4 id="21-nonlocal用于内嵌函数中"><a href="#21-nonlocal用于内嵌函数中" class="headerlink" title="21 nonlocal用于内嵌函数中"></a>21 nonlocal用于内嵌函数中</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">关键词<code>nonlocal</code>常用于函数嵌套中，声明变量<code>i</code>为非局部变量；如果不声明，<code>i+=1</code>表明<code>i</code>为函数<code>wrapper</code>内的局部变量，因为在<code>i+=1</code>引用(reference)时,i未被声明，所以会报<code>unreferenced variable</code>的错误。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def excepter(f):</span><br><span class="line">    i = 0</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    def wrapper():</span><br><span class="line">        try:</span><br><span class="line">            f()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            nonlocal i</span><br><span class="line">            i += 1</span><br><span class="line">            print(f&#x27;&#123;e.args[0]&#125;: &#123;i&#125;&#x27;)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            if i == n:</span><br><span class="line">                print(f&#x27;spending time:&#123;round(t2-t1,2)&#125;&#x27;)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h4 id="22-global-声明全局变量"><a href="#22-global-声明全局变量" class="headerlink" title="22 global 声明全局变量"></a>22 global 声明全局变量</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">先回答为什么要有<code>global</code>，一个变量被多个函数引用，想让全局变量被所有函数共享。有的伙伴可能会想这还不简单，这样写：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = 5</span><br><span class="line">def f():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">def g():</span><br><span class="line">    print(i)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">g()</span><br></pre></td></tr></table></figure><p>f和g两个函数都能共享变量<code>i</code>，程序没有报错，所以他们依然不明白为什么要用<code>global</code>.</p><p>但是，如果我想要有个函数对<code>i</code>递增，这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">h()</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">此时执行程序，bang, 出错了！抛出异常：<code>UnboundLocalError</code>，原来编译器在解释<code>i+=1</code>时会把<code>i</code>解析为函数<code>h()</code>内的局部变量，很显然在此函数内，编译器找不到对变量<code>i</code>的定义，所以会报错。</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect"><code>global</code>就是为解决此问题而被提出，在函数h内，显式地告诉编译器<code>i</code>为全局变量，然后编译器会在函数外面寻找<code>i</code>的定义，执行完<code>i+=1</code>后，<code>i</code>还为全局变量，值加1：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">def h():</span><br><span class="line">    global i</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">h()</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><h4 id="23-交换两元素"><a href="#23-交换两元素" class="headerlink" title="23 交换两元素"></a>23 交换两元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def swap(a, b):</span><br><span class="line">    return b, a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(swap(1, 0))  # (0,1)</span><br></pre></td></tr></table></figure><h4 id="24-操作函数对象"><a href="#24-操作函数对象" class="headerlink" title="24 操作函数对象"></a>24 操作函数对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [31]: def f():</span><br><span class="line">    ...:     print(&#x27;i\&#x27;m f&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [32]: def g():</span><br><span class="line">    ...:     print(&#x27;i\&#x27;m g&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [33]: [f,g][1]()</span><br><span class="line">i&#x27;m g</span><br></pre></td></tr></table></figure><p>创建函数对象的list，根据想要调用的index，方便统一调用。</p><h4 id="25-生成逆序序列"><a href="#25-生成逆序序列" class="headerlink" title="25 生成逆序序列"></a>25 生成逆序序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(10,-1,-1)) # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>第三个参数为负时，表示从第一个参数开始递减，终止到第二个参数(不包括此边界)</p><h4 id="26-函数的五类参数使用例子"><a href="#26-函数的五类参数使用例子" class="headerlink" title="26 函数的五类参数使用例子"></a>26 函数的五类参数使用例子</h4><p>python五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(a,*b,c=10,**d):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;,c:&#123;c&#125;,d:&#123;d&#125;&#x27;)</span><br></pre></td></tr></table></figure><p><em>默认参数<code>c</code>不能位于可变关键字参数<code>d</code>后.</em></p><p>调用f:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [10]: f(1,2,5,width=10,height=20)</span><br><span class="line">a:1,b:(2, 5),c:10,d:&#123;&#x27;width&#x27;: 10, &#x27;height&#x27;: 20&#125;</span><br></pre></td></tr></table></figure><p>可变位置参数<code>b</code>实参后被解析为元组<code>(2,5)</code>;而c取得默认值10; d被解析为字典.</p><p>再次调用f:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [11]: f(a=1,c=12)</span><br><span class="line">a:1,b:(),c:12,d:&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">a&#x3D;1传入时a就是关键字参数，b,d都未传值，c被传入12，而非默认值。</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDQ2ODg1OQ==&mid=2247485849&idx=1&sn=e2ee14ab05708767fb69b8e721b5d54f&chksm=fbe25d0dcc95d41bdc365398f925ed3095f60f8e19df45ad72d59bb387427ca851b34b98b351&scene=21&token=616673922&lang=zh_CN#wechat_redirect">注意观察参数<code>a</code>, 既可以<code>f(1)</code>,也可以<code>f(a=1)</code> 其可读性比第一种更好，建议使用f(a&#x3D;1)。如果要强制使用<code>f(a=1)</code>，需要在前面添加一个星号:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(*,a,**b):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>此时f(1)调用，将会报错：<code>TypeError: f() takes 0 positional arguments but 1 was given</code></p><p>只能<code>f(a=1)</code>才能OK.</p><p>说明前面的<code>*</code>发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的类型呢？借助python的<code>inspect</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [22]: for name,val in signature(f).parameters.items():</span><br><span class="line">    ...:     print(name,val.kind)</span><br><span class="line">    ...:</span><br><span class="line">a KEYWORD_ONLY</span><br><span class="line">b VAR_KEYWORD</span><br></pre></td></tr></table></figure><p>可看到参数<code>a</code>的类型为<code>KEYWORD_ONLY</code>，也就是仅仅为关键字参数。</p><p>但是，如果f定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(a,*b):</span><br><span class="line">  print(f&#x27;a:&#123;a&#125;,b:&#123;b&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>查看参数类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [24]: for name,val in signature(f).parameters.items():</span><br><span class="line">    ...:     print(name,val.kind)</span><br><span class="line">    ...:</span><br><span class="line">a POSITIONAL_OR_KEYWORD</span><br><span class="line">b VAR_POSITIONAL</span><br></pre></td></tr></table></figure><p>可以看到参数<code>a</code>既可以是位置参数也可是关键字参数。</p><h4 id="27使用slice对象"><a href="#27使用slice对象" class="headerlink" title="27使用slice对象"></a>27使用slice对象</h4><p>生成关于蛋糕的序列cake1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: cake1 = list(range(5,0,-1))</span><br><span class="line"></span><br><span class="line">In [2]: b = cake1[1:10:2]</span><br><span class="line"></span><br><span class="line">In [3]: b</span><br><span class="line">Out[3]: [4, 2]</span><br><span class="line"></span><br><span class="line">In [4]: cake1</span><br><span class="line">Out[4]: [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><p>再生成一个序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [5]: from random import randint</span><br><span class="line">   ...: cake2 = [randint(1,100) for _ in range(100)]</span><br><span class="line">   ...: # 同样以间隔为2切前10个元素，得到切片d</span><br><span class="line">   ...: d = cake2[1:10:2]</span><br><span class="line">In [6]: d</span><br><span class="line">Out[6]: [75, 33, 63, 93, 15]</span><br></pre></td></tr></table></figure><p>你看，我们使用同一种切法，分别切开两个蛋糕cake1,cake2. 后来发现这种切法<code>极为经典</code>，又拿它去切更多的容器对象。</p><p>那么，为什么不把这种切法封装为一个对象呢？于是就有了slice对象。</p><p>定义slice对象极为简单，如把上面的切法定义成slice对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">perfect_cake_slice_way = slice(1,10,2)</span><br><span class="line">#去切cake1</span><br><span class="line">cake1_slice = cake1[perfect_cake_slice_way]</span><br><span class="line">cake2_slice = cake2[perfect_cake_slice_way]</span><br><span class="line"></span><br><span class="line">In [11]: cake1_slice</span><br><span class="line">Out[11]: [4, 2]</span><br><span class="line"></span><br><span class="line">In [12]: cake2_slice</span><br><span class="line">Out[12]: [75, 33, 63, 93, 15]</span><br></pre></td></tr></table></figure><p>与上面的结果一致。</p><p>对于逆向序列切片，<code>slice</code>对象一样可行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [1,3,5,7,9,0,3,5,7]</span><br><span class="line">a_ = a[5:1:-1]</span><br><span class="line"></span><br><span class="line">named_slice = slice(5,1,-1)</span><br><span class="line">a_slice = a[named_slice]</span><br><span class="line"></span><br><span class="line">In [14]: a_</span><br><span class="line">Out[14]: [0, 9, 7, 5]</span><br><span class="line"></span><br><span class="line">In [15]: a_slice</span><br><span class="line">Out[15]: [0, 9, 7, 5]</span><br></pre></td></tr></table></figure><p>频繁使用同一切片的操作可使用slice对象抽出来，复用的同时还能提高代码可读性。</p><h4 id="28-lambda-函数的动画演示"><a href="#28-lambda-函数的动画演示" class="headerlink" title="28 lambda 函数的动画演示"></a>28 lambda 函数的动画演示</h4><p>有些读者反映，<code>lambda</code>函数不太会用，问我能不能解释一下。</p><p>比如，下面求这个 <code>lambda</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def max_len(*lists):</span><br><span class="line">    return max(*lists, key=lambda v: len(v))</span><br></pre></td></tr></table></figure><p>有两点疑惑：</p><ul><li>参数<code>v</code>的取值？</li><li><code>lambda</code>函数有返回值吗？如果有，返回值是多少？</li></ul><p>调用上面函数，求出以下三个最长的列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = max_len([1, 2, 3], [4, 5, 6, 7], [8])</span><br><span class="line">print(f&#x27;更长的列表是&#123;r&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>程序完整运行过程，动画演示如下：</p><p><img src="https://aimak.cn/blog_img/python/python-lambda.gif"></p><p>结论：</p><ul><li>参数v的可能取值为<code>*lists</code>，也就是 <code>tuple</code> 的一个元素。</li><li><code>lambda</code>函数返回值，等于<code>lambda v</code>冒号后表达式的返回值。</li></ul><h2 id="四、-数据结构"><a href="#四、-数据结构" class="headerlink" title="四、 数据结构"></a>四、 数据结构</h2><h4 id="29-转为字典"><a href="#29-转为字典" class="headerlink" title="29 转为字典"></a>29 转为字典</h4><p>创建数据字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: dict()</span><br><span class="line">Out[1]: &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [2]: dict(a=&#x27;a&#x27;,b=&#x27;b&#x27;)</span><br><span class="line">Out[2]: &#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;&#125;</span><br><span class="line"></span><br><span class="line">In [3]: dict(zip([&#x27;a&#x27;,&#x27;b&#x27;],[1,2]))</span><br><span class="line">Out[3]: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span><br><span class="line"></span><br><span class="line">In [4]: dict([(&#x27;a&#x27;,1),(&#x27;b&#x27;,2)])</span><br><span class="line">Out[4]: &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span><br></pre></td></tr></table></figure><h4 id="30-冻结集合"><a href="#30-冻结集合" class="headerlink" title="30 冻结集合"></a>30 冻结集合</h4><p>创建一个不可修改的集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: frozenset([1,1,3,2,3])</span><br><span class="line">Out[1]: frozenset(&#123;1, 2, 3&#125;)</span><br></pre></td></tr></table></figure><p>因为不可修改，所以没有像<code>set</code>那样的<code>add</code>和<code>pop</code>方法</p><h4 id="31-转为集合类型"><a href="#31-转为集合类型" class="headerlink" title="31 转为集合类型"></a>31 转为集合类型</h4><p>返回一个set对象，集合内不允许有重复元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [159]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [160]: set(a)</span><br><span class="line">Out[160]: &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h4 id="32-转为切片对象"><a href="#32-转为切片对象" class="headerlink" title="32 转为切片对象"></a>32 转为切片对象</h4><p><em>class</em> slice(<em>start</em>, <em>stop</em>[, <em>step</em>])</p><p>返回一个表示由 range(start, stop, step) 所指定索引集的 slice对象，它让代码可读性、可维护性变好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [1,4,2,3,1]</span><br><span class="line"></span><br><span class="line">In [2]: my_slice_meaning = slice(0,5,2)</span><br><span class="line"></span><br><span class="line">In [3]: a[my_slice_meaning]</span><br><span class="line">Out[3]: [1, 2, 1]</span><br></pre></td></tr></table></figure><h4 id="33-转元组"><a href="#33-转元组" class="headerlink" title="33 转元组"></a>33 转元组</h4><p><code>tuple()</code> 将对象转为一个不可变的序列类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [16]: i_am_list = [1,3,5]</span><br><span class="line">In [17]: i_am_tuple = tuple(i_am_list)</span><br><span class="line">In [18]: i_am_tuple</span><br><span class="line">Out[18]: (1, 3, 5)</span><br></pre></td></tr></table></figure><h2 id="五、-类和对象"><a href="#五、-类和对象" class="headerlink" title="五、 类和对象"></a>五、 类和对象</h2><h4 id="34-是否可调用"><a href="#34-是否可调用" class="headerlink" title="34 是否可调用"></a>34 是否可调用</h4><p>检查对象是否可被调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [1]: callable(str)</span><br><span class="line">Out[1]: True</span><br><span class="line"></span><br><span class="line">In [2]: callable(int)</span><br><span class="line">Out[2]: True</span><br><span class="line">In [18]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">In [19]: xiaoming = Student(&#x27;001&#x27;,&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [20]: callable(xiaoming)</span><br><span class="line">Out[20]: False</span><br></pre></td></tr></table></figure><p>如果能调用<code>xiaoming()</code>, 需要重写<code>Student</code>类的<code>__call__</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...:     def __call__(self):</span><br><span class="line">    ...:         print(&#x27;I can be called&#x27;)</span><br><span class="line">    ...:         print(f&#x27;my name is &#123;self.name&#125;&#x27;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [2]: t = Student(&#x27;001&#x27;,&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [3]: t()</span><br><span class="line">I can be called</span><br><span class="line">my name is xiaoming</span><br></pre></td></tr></table></figure><h4 id="35-ascii-展示对象"><a href="#35-ascii-展示对象" class="headerlink" title="35 ascii 展示对象"></a>35 ascii 展示对象</h4><p>调用对象的 <code>__repr__</code> 方法，获得该方法的返回值，如下例子返回值为字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student():</span><br><span class="line">    def __init__(self,id,name):</span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; xiaoming = Student(id=&#x27;1&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">&gt;&gt;&gt; xiaoming</span><br><span class="line">id = 1, name = xiaoming</span><br><span class="line">&gt;&gt;&gt; ascii(xiaoming)</span><br><span class="line">&#x27;id = 1, name = xiaoming&#x27;</span><br></pre></td></tr></table></figure><h4 id="36-类方法"><a href="#36-类方法" class="headerlink" title="36 类方法"></a>36 类方法</h4><p><code>classmethod</code> 装饰器对应的函数不需要实例化，不需要 <code>self </code>参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">    ...:     def __init__(self,id,name):</span><br><span class="line">    ...:         self.id = id</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:     def __repr__(self):</span><br><span class="line">    ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">    ...:     @classmethod</span><br><span class="line">    ...:     def f(cls):</span><br><span class="line">    ...:         print(cls)</span><br></pre></td></tr></table></figure><h4 id="37-动态删除属性"><a href="#37-动态删除属性" class="headerlink" title="37 动态删除属性"></a>37 动态删除属性</h4><p>删除对象的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: delattr(xiaoming,&#x27;id&#x27;)</span><br><span class="line"></span><br><span class="line">In [2]: hasattr(xiaoming,&#x27;id&#x27;)</span><br><span class="line">Out[2]: False</span><br></pre></td></tr></table></figure><h4 id="38-一键查看对象所有方法"><a href="#38-一键查看对象所有方法" class="headerlink" title="38 一键查看对象所有方法"></a>38 一键查看对象所有方法</h4><p>不带参数时返回<code>当前范围</code>内的变量、方法和定义的类型列表；带参数时返回<code>参数</code>的属性，方法列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [96]: dir(xiaoming)</span><br><span class="line">Out[96]:</span><br><span class="line">[&#x27;__class__&#x27;,</span><br><span class="line"> &#x27;__delattr__&#x27;,</span><br><span class="line"> &#x27;__dict__&#x27;,</span><br><span class="line"> &#x27;__dir__&#x27;,</span><br><span class="line"> &#x27;__doc__&#x27;,</span><br><span class="line"> &#x27;__eq__&#x27;,</span><br><span class="line"> &#x27;__format__&#x27;,</span><br><span class="line"> &#x27;__ge__&#x27;,</span><br><span class="line"> &#x27;__getattribute__&#x27;,</span><br><span class="line"> &#x27;__gt__&#x27;,</span><br><span class="line"> &#x27;__hash__&#x27;,</span><br><span class="line"> &#x27;__init__&#x27;,</span><br><span class="line"> &#x27;__init_subclass__&#x27;,</span><br><span class="line"> &#x27;__le__&#x27;,</span><br><span class="line"> &#x27;__lt__&#x27;,</span><br><span class="line"> &#x27;__module__&#x27;,</span><br><span class="line"> &#x27;__ne__&#x27;,</span><br><span class="line"> &#x27;__new__&#x27;,</span><br><span class="line"> &#x27;__reduce__&#x27;,</span><br><span class="line"> &#x27;__reduce_ex__&#x27;,</span><br><span class="line"> &#x27;__repr__&#x27;,</span><br><span class="line"> &#x27;__setattr__&#x27;,</span><br><span class="line"> &#x27;__sizeof__&#x27;,</span><br><span class="line"> &#x27;__str__&#x27;,</span><br><span class="line"> &#x27;__subclasshook__&#x27;,</span><br><span class="line"> &#x27;__weakref__&#x27;,</span><br><span class="line"> </span><br><span class="line"> &#x27;name&#x27;]</span><br></pre></td></tr></table></figure><h4 id="39-动态获取对象属性"><a href="#39-动态获取对象属性" class="headerlink" title="39 动态获取对象属性"></a>39 动态获取对象属性</h4><p>获取对象的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: getattr(xiaoming,&#x27;name&#x27;) # 获取xiaoming这个实例的name属性值</span><br><span class="line">Out[3]: &#x27;xiaoming&#x27;</span><br></pre></td></tr></table></figure><h4 id="40-对象是否有这个属性"><a href="#40-对象是否有这个属性" class="headerlink" title="40 对象是否有这个属性"></a>40 对象是否有这个属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: hasattr(xiaoming,&#x27;name&#x27;)</span><br><span class="line">Out[3]: True</span><br><span class="line"></span><br><span class="line">In [4]: hasattr(xiaoming,&#x27;address&#x27;)</span><br><span class="line">Out[4]: False</span><br></pre></td></tr></table></figure><h4 id="41-对象门牌号"><a href="#41-对象门牌号" class="headerlink" title="41 对象门牌号"></a>41 对象门牌号</h4><p>返回对象的内存地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: id(xiaoming)</span><br><span class="line">Out[1]: 98234208</span><br></pre></td></tr></table></figure><h4 id="42-isinstance"><a href="#42-isinstance" class="headerlink" title="42 isinstance"></a>42 isinstance</h4><p>判断<em>object</em>是否为类<em>classinfo</em>的实例，是返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line"></span><br><span class="line">In [3]: isinstance(xiaoming,Student)</span><br><span class="line">Out[3]: True</span><br></pre></td></tr></table></figure><h4 id="43-父子关系鉴定"><a href="#43-父子关系鉴定" class="headerlink" title="43 父子关系鉴定"></a>43 父子关系鉴定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class undergraduate(Student):</span><br><span class="line">    ...:     def studyClass(self):</span><br><span class="line">    ...:         pass</span><br><span class="line">    ...:     def attendActivity(self):</span><br><span class="line">    ...:         pass</span><br><span class="line"></span><br><span class="line">In [2]: issubclass(undergraduate,Student)</span><br><span class="line">Out[2]: True</span><br><span class="line"></span><br><span class="line">In [3]: issubclass(object,Student)</span><br><span class="line">Out[3]: False</span><br><span class="line"></span><br><span class="line">In [4]: issubclass(Student,object)</span><br><span class="line">Out[4]: True</span><br></pre></td></tr></table></figure><p>如果class是classinfo元组中某个元素的子类，也会返回True</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: issubclass(int,(int,float))</span><br><span class="line">Out[1]: True</span><br></pre></td></tr></table></figure><h4 id="44-所有对象之根"><a href="#44-所有对象之根" class="headerlink" title="44 所有对象之根"></a>44 所有对象之根</h4><p>object 是所有类的基类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: o = object()</span><br><span class="line"></span><br><span class="line">In [2]: type(o)</span><br><span class="line">Out[2]: object</span><br></pre></td></tr></table></figure><h4 id="45-创建属性的两种方式"><a href="#45-创建属性的两种方式" class="headerlink" title="45 创建属性的两种方式"></a>45 创建属性的两种方式</h4><p>返回 property 属性，典型的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"></span><br><span class="line">    def getx(self):</span><br><span class="line">        return self._x</span><br><span class="line"></span><br><span class="line">    def setx(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    def delx(self):</span><br><span class="line">        del self._x</span><br><span class="line">    # 使用property类创建 property 属性</span><br><span class="line">    x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span><br></pre></td></tr></table></figure><p>使用python装饰器，实现与上完全一样的效果代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def x(self):</span><br><span class="line">        return self._x</span><br><span class="line"></span><br><span class="line">    @x.setter</span><br><span class="line">    def x(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    @x.deleter</span><br><span class="line">    def x(self):</span><br><span class="line">        del self._x</span><br></pre></td></tr></table></figure><h4 id="46-查看对象类型"><a href="#46-查看对象类型" class="headerlink" title="46 查看对象类型"></a>46 查看对象类型</h4><p><em>class</em> <code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>)</p><p>传入一个参数时，返回 <em>object</em> 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Student():</span><br><span class="line">   ...:     def __init__(self,id,name):</span><br><span class="line">   ...:         self.id = id</span><br><span class="line">   ...:         self.name = name</span><br><span class="line">   ...:     def __repr__(self):</span><br><span class="line">   ...:         return &#x27;id = &#x27;+self.id +&#x27;, name = &#x27;+self.name</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: xiaoming = Student(id=&#x27;001&#x27;,name=&#x27;xiaoming&#x27;)</span><br><span class="line">In [3]: type(xiaoming)</span><br><span class="line">Out[3]: __main__.Student</span><br><span class="line"></span><br><span class="line">In [4]: type(tuple())</span><br><span class="line">Out[4]: tuple</span><br></pre></td></tr></table></figure><h4 id="47-元类"><a href="#47-元类" class="headerlink" title="47 元类"></a>47 元类</h4><p><code>xiaoming</code>, <code>xiaohong</code>, <code>xiaozhang</code> 都是学生，这类群体叫做 <code>Student</code>.</p><p>Python 定义类的常见方法，使用关键字 <code>class</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [36]: class Student(object):</span><br><span class="line">    ...:     pass</span><br></pre></td></tr></table></figure><p><code>xiaoming</code>, <code>xiaohong</code>, <code>xiaozhang</code> 是类的实例，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Student()</span><br><span class="line">xiaohong = Student()</span><br><span class="line">xiaozhang = Student()</span><br></pre></td></tr></table></figure><p>创建后，xiaoming 的 <code>__class__</code> 属性，返回的便是 <code>Student</code>类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [38]: xiaoming.__class__</span><br><span class="line">Out[38]: __main__.Student</span><br></pre></td></tr></table></figure><p>问题在于，<code>Student</code> 类有 <code>__class__</code>属性，如果有，返回的又是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [39]: xiaoming.__class__.__class__</span><br><span class="line">Out[39]: type</span><br></pre></td></tr></table></figure><p>哇，程序没报错，返回 <code>type</code></p><p>那么，我们不妨猜测：<code>Student</code> 类，类型就是 <code>type</code>，换句话说，<code>Student</code>类就是一个对象，它的类型就是 <code>type</code>，所以，Python 中一切皆对象，类也是对象</p><p>Python 中，将描述 <code>Student</code> 类的类被称为：元类。</p><p>按照此逻辑延伸，描述元类的类被称为：<em>元元类</em>，开玩笑了~ 描述元类的类也被称为元类。</p><p>聪明的朋友会问了，既然 <code>Student</code> 类可创建实例，那么 <code>type</code> 类可创建实例吗？如果能，它创建的实例就叫：类 了。你们真聪明！</p><p>说对了，<code>type</code> 类一定能创建实例，比如 <code>Student</code> 类了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [40]: Student = type(&#x27;Student&#x27;,(),&#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [41]: Student</span><br><span class="line">Out[41]: __main__.Student</span><br></pre></td></tr></table></figure><p>它与使用 <code>class</code> 关键字创建的 <code>Student</code> 类一模一样。</p><p>Python 的类，因为又是对象，所以和 <code>xiaoming</code>，<code>xiaohong</code> 对象操作相似。支持：</p><ul><li>赋值</li><li>拷贝</li><li>添加属性</li><li>作为函数参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [43]: StudentMirror = Student # 类直接赋值 # 类直接赋值</span><br><span class="line">In [44]: Student.class_property = &#x27;class_property&#x27; # 添加类属性</span><br><span class="line">In [46]: hasattr(Student, &#x27;class_property&#x27;)</span><br><span class="line">Out[46]: True</span><br></pre></td></tr></table></figure><p>元类，确实使用不是那么多，也许先了解这些，就能应付一些场合。就连 Python 界的领袖 <code>Tim Peters</code> 都说：</p><p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。</p><h2 id="六、工具"><a href="#六、工具" class="headerlink" title="六、工具"></a>六、工具</h2><h4 id="48-枚举对象"><a href="#48-枚举对象" class="headerlink" title="48 枚举对象"></a>48 枚举对象</h4><p>返回一个可以枚举的对象，该对象的next()方法将返回一个元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">    ...: for i ,v in enumerate(s,1):</span><br><span class="line">    ...:     print(i,v)</span><br><span class="line">    ...:</span><br><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 c</span><br></pre></td></tr></table></figure><h4 id="49-查看变量所占字节数"><a href="#49-查看变量所占字节数" class="headerlink" title="49 查看变量所占字节数"></a>49 查看变量所占字节数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import sys</span><br><span class="line"></span><br><span class="line">In [2]: a = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2.0&#125;</span><br><span class="line"></span><br><span class="line">In [3]: sys.getsizeof(a) # 占用240个字节</span><br><span class="line">Out[3]: 240</span><br></pre></td></tr></table></figure><h4 id="50-过滤器"><a href="#50-过滤器" class="headerlink" title="50 过滤器"></a>50 过滤器</h4><p>在函数中设定过滤条件，迭代元素，保留返回值为<code>True</code>的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: fil = filter(lambda x: x&gt;10,[1,11,2,45,7,6,13])</span><br><span class="line"></span><br><span class="line">In [2]: list(fil)</span><br><span class="line">Out[2]: [11, 45, 13]</span><br></pre></td></tr></table></figure><h4 id="51-返回对象的哈希值"><a href="#51-返回对象的哈希值" class="headerlink" title="51 返回对象的哈希值"></a>51 返回对象的哈希值</h4><p>返回对象的哈希值，值得注意的是自定义的实例都是可哈希的，<code>list</code>, <code>dict</code>, <code>set</code>等可变对象都是不可哈希的(unhashable)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hash(xiaoming)</span><br><span class="line">Out[1]: 6139638</span><br><span class="line"></span><br><span class="line">In [2]: hash([1,2,3])</span><br><span class="line"># TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure><h4 id="52-一键帮助"><a href="#52-一键帮助" class="headerlink" title="52 一键帮助"></a>52 一键帮助</h4><p>返回对象的帮助文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [1]: help(xiaoming)</span><br><span class="line">Help on Student in module __main__ object:</span><br><span class="line"></span><br><span class="line">class Student(builtins.object)</span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __init__(self, id, name)</span><br><span class="line"> |</span><br><span class="line"> |  __repr__(self)</span><br><span class="line"> |</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br></pre></td></tr></table></figure><h3 id="53-获取用户输入"><a href="#53-获取用户输入" class="headerlink" title="53 获取用户输入"></a>53 获取用户输入</h3><p>获取用户输入内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [1]: input()</span><br><span class="line">aa</span><br><span class="line">Out[1]: &#x27;aa&#x27;</span><br></pre></td></tr></table></figure><h4 id="54-创建迭代器类型"><a href="#54-创建迭代器类型" class="headerlink" title="54 创建迭代器类型"></a>54 创建迭代器类型</h4><p>使用<code>iter(obj, sentinel)</code>, 返回一个可迭代对象, sentinel可省略(一旦迭代到此元素，立即终止)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [1]: lst = [1,3,5]</span><br><span class="line"></span><br><span class="line">In [2]: for i in iter(lst):</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">In [1]: class TestIter(object):</span><br><span class="line">    ...:     def __init__(self):</span><br><span class="line">    ...:         self.l=[1,3,2,3,4,5]</span><br><span class="line">    ...:         self.i=iter(self.l)</span><br><span class="line">    ...:     def __call__(self):  #定义了__call__方法的类的实例是可调用的</span><br><span class="line">    ...:         item = next(self.i)</span><br><span class="line">    ...:         print (&quot;__call__ is called,fowhich would return&quot;,item)</span><br><span class="line">    ...:         return item</span><br><span class="line">    ...:     def __iter__(self): #支持迭代协议(即定义有__iter__()函数)</span><br><span class="line">    ...:         print (&quot;__iter__ is called!!&quot;)</span><br><span class="line">    ...:         return iter(self.l)</span><br><span class="line">In [2]: t = TestIter()</span><br><span class="line">In [3]: t() # 因为实现了__call__，所以t实例能被调用</span><br><span class="line">__call__ is called,which would return 1</span><br><span class="line">Out[3]: 1</span><br><span class="line"></span><br><span class="line">In [4]: for e in TestIter(): # 因为实现了__iter__方法，所以t能被迭代</span><br><span class="line">    ...:     print(e)</span><br><span class="line">    ...:</span><br><span class="line">__iter__ is called!!</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="55-打开文件"><a href="#55-打开文件" class="headerlink" title="55 打开文件"></a>55 打开文件</h4><p>返回文件对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: fo = open(&#x27;D:/a.txt&#x27;,mode=&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">In [2]: fo.read()</span><br><span class="line">Out[2]: &#x27;\ufefflife is not so long,\nI use Python to play.&#x27;</span><br></pre></td></tr></table></figure><p>mode取值表：</p><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td><code>&#39;r&#39;</code></td><td>读取（默认）</td></tr><tr><td><code>&#39;w&#39;</code></td><td>写入，并先截断文件</td></tr><tr><td><code>&#39;x&#39;</code></td><td>排它性创建，如果文件已存在则失败</td></tr><tr><td><code>&#39;a&#39;</code></td><td>写入，如果文件存在则在末尾追加</td></tr><tr><td><code>&#39;b&#39;</code></td><td>二进制模式</td></tr><tr><td><code>&#39;t&#39;</code></td><td>文本模式（默认）</td></tr><tr><td><code>&#39;+&#39;</code></td><td>打开用于更新（读取与写入）</td></tr></tbody></table><h4 id="56-创建range序列"><a href="#56-创建range序列" class="headerlink" title="56 创建range序列"></a>56 创建range序列</h4><ol><li>range(stop)</li><li>range(start, stop[,step])</li></ol><p>生成一个不可变序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: range(11)</span><br><span class="line">Out[1]: range(0, 11)</span><br><span class="line"></span><br><span class="line">In [2]: range(0,11,1)</span><br><span class="line">Out[2]: range(0, 11)</span><br></pre></td></tr></table></figure><h4 id="57-反向迭代器"><a href="#57-反向迭代器" class="headerlink" title="57 反向迭代器"></a>57 反向迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: rev = reversed([1,4,2,3,1])</span><br><span class="line"></span><br><span class="line">In [2]: for i in rev:</span><br><span class="line">     ...:     print(i)</span><br><span class="line">     ...:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="58-聚合迭代器"><a href="#58-聚合迭代器" class="headerlink" title="58 聚合迭代器"></a>58 聚合迭代器</h4><p>创建一个聚合了来自每个可迭代对象中的元素的迭代器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: x = [3,2,1]</span><br><span class="line">In [2]: y = [4,5,6]</span><br><span class="line">In [3]: list(zip(y,x))</span><br><span class="line">Out[3]: [(4, 3), (5, 2), (6, 1)]</span><br><span class="line"></span><br><span class="line">In [4]: a = range(5)</span><br><span class="line">In [5]: b = list(&#x27;abcde&#x27;)</span><br><span class="line">In [6]: b</span><br><span class="line">Out[6]: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line">In [7]: [str(y) + str(x) for x,y in zip(a,b)]</span><br><span class="line">Out[7]: [&#x27;a0&#x27;, &#x27;b1&#x27;, &#x27;c2&#x27;, &#x27;d3&#x27;, &#x27;e4&#x27;]</span><br></pre></td></tr></table></figure><h4 id="59-链式操作"><a href="#59-链式操作" class="headerlink" title="59 链式操作"></a>59 链式操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from operator import (add, sub)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_or_sub(a, b, oper):</span><br><span class="line">    return (add if oper == &#x27;+&#x27; else sub)(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_or_sub(1, 2, &#x27;-&#x27;)  # -1</span><br></pre></td></tr></table></figure><h4 id="60-对象序列化"><a href="#60-对象序列化" class="headerlink" title="60 对象序列化"></a>60 对象序列化</h4><p>对象序列化，是指将内存中的对象转化为可存储或传输的过程。很多场景，直接一个类对象，传输不方便。</p><p>但是，当对象序列化后，就会更加方便，因为约定俗成的，接口间的调用或者发起的 web 请求，一般使用 json 串传输。</p><p>实际使用中，一般对类对象序列化。先创建一个 Student 类型，并创建两个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student():</span><br><span class="line">    def __init__(self,**args):</span><br><span class="line">        self.ids = args[&#x27;ids&#x27;]</span><br><span class="line">        self.name = args[&#x27;name&#x27;]</span><br><span class="line">        self.address = args[&#x27;address&#x27;]</span><br><span class="line">xiaoming = Student(ids = 1,name = &#x27;xiaoming&#x27;,address = &#x27;北京&#x27;)</span><br><span class="line">xiaohong = Student(ids = 2,name = &#x27;xiaohong&#x27;,address = &#x27;南京&#x27;)</span><br></pre></td></tr></table></figure><p>导入 json 模块，调用 dump 方法，就会将列表对象 [xiaoming,xiaohong]，序列化到文件 json.txt 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open(&#x27;json.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    json.dump([xiaoming,xiaohong], f, default=lambda obj: obj.__dict__, ensure_ascii=False, indent=2, sort_keys=True)</span><br></pre></td></tr></table></figure><p>生成的文件内容，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;address&quot;:&quot;北京&quot;,</span><br><span class="line">        &quot;ids&quot;:1,</span><br><span class="line">        &quot;name&quot;:&quot;xiaoming&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;address&quot;:&quot;南京&quot;,</span><br><span class="line">        &quot;ids&quot;:2,</span><br><span class="line">        &quot;name&quot;:&quot;xiaohong&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em><strong>*<br>*</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jackzhenguo/python-small-example&quot;&gt;https://github.com/jackzhenguo/python-small-example</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="python" scheme="http://ai.mak.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>保证接口数据安全的10种方案</title>
    <link href="http://ai.mak.cn/2022/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%92%E8%81%94%E7%BD%9150%E5%B9%B4%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%881972-2022%EF%BC%89/"/>
    <id>http://ai.mak.cn/2022/10/07/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BA%92%E8%81%94%E7%BD%9150%E5%B9%B4%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%881972-2022%EF%BC%89/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2023-01-24T08:01:49.401Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让我们花点时间回顾一下50年前的1972年，以及当时的技术和电信环境。</strong></p><h2 id="01"><a href="#01" class="headerlink" title="01"></a><strong>01</strong></h2><h3 id="从1972年开始说起"><a href="#从1972年开始说起" class="headerlink" title="从1972年开始说起"></a><strong>从1972年开始说起</strong></h3><blockquote><p>1972年的世界是由一组规模相对较小且价格昂贵的大型计算机组成的世界，这些计算机由一组全天候工作的计算机操作员操作，他们由专门的程序员指导，将意义不明的符号输入这些计算机的作业控制系统。在当时的普通家庭中，最复杂的家用消费设备是电视机，一个模拟设备。时钟仍然使用发条运行。然而，变化正在发生。载人航天令人着迷的技术成就不仅拓展了整整一代人的想象力，而且让我们得以一窥技术的力量和效用。</p></blockquote><ul><li>1970年代的大型计算机</li></ul><p>在计算领域，摩尔定律在过去的50年里确实让人吃惊。大型计算机变得性能更强、速度更快、也更便宜。与此同时，我们正在制造的计算机不一定更快，也不一定性能更强，但却更小、更便宜。这些小型计算机在尺寸、成本和易用性方面逐渐完善，直至成为个人消费产品。</p><p>与此同时，计算机网络也在发生变化。它们最初的目的是：通过使用远程外围设备来扩展计算机的使用范围。首先是读卡器和打印机，然后是终端。然而，这是一个不稳定的情况，随着网络和外围设备的成本增加，每次更换大型计算机供应商时，就不可能扔掉所有东西。</p><p>而随着小型计算机的引入，我们要讨论的不再仅仅是大型计算机。网络开始用于互连一组计算机和外围设备。我们需要开放标准来驱动这些网络，让网络与外围设备交互，从而使网络在计算环境中扮演更核心的角色。</p><p>1990年代，作为消费产品的计算机市场的发展势头对技术领域的架构产生了影响。我们开始区分大型机服务器和围绕它们的个人计算机客户端集合。计算机通信网络也做出了这种区分，与以相同的方式看待每个用户的电话网络不同（电话网络本质上是一个真正的“点对点”网络），计算机网络开始考虑一种新的网络架构，对客户端和服务器进行根本的区分。计算机网络开始将网络的一些基本服务，例如通用域名服务和路由系统，合并到这个扩大的网络概念中，而客户端则是网络服务的消费者。从某种意义上说，1990年代，计算机网络从电话范式向更接近广播电视的范式转变。</p><ul><li>1990年代的电脑Electronics MK-106，内存为32KB。</li></ul><p>然而，网络模型向客户端&#x2F;服务器模型的变化也给网络环境带来了一系列更根本的挑战。正如计算机现在是消费设备一样，计算机通信此时正在进入公共事业服务领域，挑战电话网络的地位。虽然电话世界希望将其视为集成到现有电话环境中的另一个应用程序，就像传真系统在1970年代和1980年代被吸收到电话空间一样，但计算机世界的服务模式却与电话世界完全不同。</p><p>在电话垂直捆绑业务的世界中，网络容量很大程度上取决于电话机的部署，因此网络配置是一个完全在电话网络运营商控制下的确定性过程。在1990年代新兴的互联网客户端&#x2F;服务器模式的非捆绑模式下，网络的容量需求由消费者市场的行为决定，消费者需求与网络服务的耦合成为互联网市场的功能。</p><p>到2000年代，网络服务器端提供的服务出现了扩大规模的竞争。消费者快速增长的带宽需求与扩展服务基础设施和连接网络容量的相应投资水平不相匹配。由于不存在精细的定价模型，网络服务“包月制”接入资费加剧了这一问题。用户更多的消费并没有伴随更多的经营收入，这反过来意味着更多的基础设施是通过增加服务和基础设施提供商的债务水平来完成的。</p><p>我们已经将通信基础设施的参数从紧密耦合的经济体中转移出来。在通信基础设施这种经济体中，用量的增长直接转化为基础设施提供商的额外收入，进而为建设更多基础设施提供资金。在这种新的非耦合经济模型中，只有更多的用户才能产生更多的收入，而不断升级的带宽只能通过不断增加的新用户（可能是低消费用户）来建设更多的基础设施从而获得更多资金。这听起来很像一个巨大的金字塔计划。</p><p>而这就是1990年代后期的ISP（互联网服务提供商）行业！</p><p>到2000年代，网络服务器端提供的服务出现了扩大规模的竞争。</p><p>这种环境创造了一个反馈循环，扩大了对服务基础设施的需求。不仅仅是金融模型承受着巨大的压力，技术模型也面临着压力。托管在单一平台上的服务不堪重负，连接这些服务的网络基础设施也完全不堪重负。</p><p>解决方案是改变服务基础设施的技术。我们开始利用服务器集群和数据中心、交换机和网关，以及将服务提供商分层。我们再次尝试了多协议标签交换（MPLS）和虚拟专用网络（VPN）形式的虚拟电路，以及其他相关形式的网络划分。同时，由于服务容量的提升往往落后于客户群体的需求，我们尝试了各种各样的方法提升服务质量，以对处于竞争中的网络资源进行选择性配给。</p><p>到2000年代后期，最根本的的变化也许是内容分发网络（CDN）的出现。CDN不是将所有客户端带回单个中心服务器上，而是转向将服务复制到更接近服务客户端的模型。通过这种方式，客户需求仅在接入网络内表达，而网络内部则用于向边缘服务中心提供更新。实际上，互联网已经实现了基于边缘的分发机制，与以前将用户带回服务的通信模型不同，这种机制可以将服务带到更靠近用户的地方。</p><p>这恰逢其时，因为随着2007年苹果iPhone的问世，需求曲线发生了巨大变化。移动互联网行业被迫面临需求的增长，比个人计算机联网的需求高出三到四个数量级。每秒千比特的速度不能满足需求，客户需要数兆比特来完成在移动设备上创建的沉浸式环境。</p><ul><li>2007年苹果iPhone问世</li></ul><p>在过去的50年中，网络基础设施也发生了深刻的演变。我们采用以太网本地网络使用的以数据包为中心的网络模型，并将其推向高速远程基础设施中。几十年来，我们没有构建额外的同步数字体系（SDH）管理电路容量，而如今，互联网的分组交换机直接连接到传输结构。然而，在所有这些转变中，我们仍然使用互联网协议（IP）来操作这些数据包。</p><p>为什么会出现这种情况？这种情况是如何发生的？互联网协议的真正天才之处在于将应用程序和内容服务环境与底层传输结构的特征分开。每次当一种新的传输技术诞生时，我们都可以将互联网协议映射到上面，然后让整个已安装的支持IP的设备群无缝地使用这种新的传输技术。</p><p>从点对点串行线路到以太网系统，再到光纤分布式数据接口（FDDI）、分布式队列双总线（DQDB）和无线电系统等环形系统，每次我们都能够在不改变应用程序或服务环境的情况下，在IP级别快速集成这些技术。这不仅在连续几代通信技术中保持了对基于互联网的技术的投资价值，而且随着互联网的使用和用户的增加，其价值也随之增加。</p><p>现在，这使我们能够展望未来50年的通信技术。50年在某些方面是一段很长的时间，但在其他许多方面可能并没有那么长。而跨越多个世纪的转变往往会摆脱以前的每一处痕迹，营造出全新的环境。但目前尚不清楚关于未来50年的技术预测是否遵循这个规律。</p><p>可以说，当今技术世界的大部分画面都可以在1971年或更早的时候想象。移动电话转变为这些“智能”设备是1970年代初期的一个明显趋势。随着硅处理技术的逐步改进，计算技术发生了变革，诞生了具有数十亿个独立门的集成单芯片处理器，功耗极低，时钟速度极高，而且不需要从根本上重新考虑计算机的内部结构。设计可能已经缩小，但其设计逻辑基本保持不变。</p><p>关键是，在大约50年后成为主导因素的“种子”在1971年的世界里是显而易见的。以同样的思路断言，在这个通信环境中，50年后世界的主导因素“种子”可能就存在于今天的世界里。问题是，我们今天拥有的思想“种子”并不唯一，真正的挑战在于，如何在当前的世界里区分出重要的和次要的东西。</p><p>因此，尝试描绘50年后计算机通信环境的详细图景也许毫无意义。但是，如果我们仔细研究一下细节，也许可以找到塑造未来的驱动因素，并根据塑造当前世界的驱动因素来选择这些因素。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a><strong>02</strong></h2><h3 id="是什么推动了今天的变革？"><a href="#是什么推动了今天的变革？" class="headerlink" title="是什么推动了今天的变革？"></a><strong>是什么推动了今天的变革？</strong></h3><h4 id="更大"><a href="#更大" class="headerlink" title="更大"></a><strong>更大</strong></h4><p>当我们停止运营垂直整合的通信服务提供商，并利用市场力量来松散地耦合供需时，我们成功地释放了一波又一波急剧上升的需求。过去我们使用每秒千比特倍数的语言查看电话通信，今天，对话的单位不是每秒兆比特或千兆比特，而是每秒兆兆比特。</p><p>例如，跨越太平洋海底并连接美国和新加坡的GoogleEcho光缆由12对光纤构成，每对光纤的设计容量为12Tb&#x2F;s，共有144Tb&#x2F;s的总光缆容量。谷歌的Dunant光缆系统在整个大西洋提供250Tbs的总容量，并将由352Tbps的Grace Hopper光缆系统进行扩容。我们竭尽所能构建更大容量的传输系统，包括使用光子放大器、波长多路复用、结合相位&#x2F;振幅&#x2F;偏振调制，并将数字信号处理提升到极致，以显著提高光缆容量。</p><p>摩尔定律可能是惊人的，但坦率地说，消费设备在以更快的速度增长。自2015年以来，消费量每年都在增长。2020年，我们售出了约14亿台移动互联网设备。巨大的消费量和巨大的功能推动了更沉浸式的内容和服务。如何为所有客户提供内容？如今，我们已经成为服务器和内容聚合方面的专家。内容分发网络致力于为客户端提供服务，其规模和速度与这些最后一英里接入网络的容量相匹配。</p><p>当我们考虑“更大”时，重要的考虑因素不仅仅是人类对网络的使用。分组网络是一个计算机网络，使用领域包括物联网这个新兴世界。当我们审视这个世界时，我们有两个问题似乎无法回答，至少不能精确地回答：今天有多少“东西”在使用互联网？明天将有多少人会使用互联网？</p><p>对于当今互联网的设备数量有多种估计。约200到500亿台设备的数字存在一些共识，但这些都依赖于各种估计，而不是更可靠的分析测量。微处理器的年产量达到数十亿台，该行业的增长预期不确定，但总体来说非常高。</p><p>这背后的观察结果是：随着互联网规模的扩大，互联网不再取决于人口数量和使用水平。互联网的发展不再受限于人口增长，也不再受限于人类一天清醒的时间。网络正在改变，以服务于基于充裕模型的计算机设备集合。这些设备具有充裕的处理能力，充裕的存储，充裕的网络容量。我们也许不明白“更大”在需求方面的真正含义，我们能做的最好的事情就是过去几十年里一直在做的：尽可能快地部署资金、专业知识和资源。我们似乎仍处于努力跟上需求的阶段，无论构建多大的网络，使用模式已经证明有能力使其饱和。</p><h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a><strong>更快</strong></h4><p>在构建更大网络的同时，我们希望，无论是连接设备和客户端的数量，还是网络传输的数据量，都能以更快的速度通过网络推送。</p><p>我们一直在部署更大容量的移动边缘网络，对于许多消费者来说，甚至3G现在看起来都慢得无法接受。通信行业正在推动5G系统的部署，该系统据称可以以10Gb&#x2F;s峰值速度将数据传输到端点。但目前这可能只是一个极端环境下的测量结果，与消费者的合理预期不符，即这些移动网络现在可以为连接的设备提供每秒100兆比特的数据。</p><p>在有线世界中，DSL（数字用户线路）技术以及通过传统电信双绞线铜线对的传输形式如今在很大程度上已无关紧要，并且传统铜线基础设施接入技术的持续使用正在减少。我们正在用光纤重新部署有线环境，用来描述这些有线服务容量单位的语言正在从每秒兆比特变成每秒千兆比特。</p><p>但速度不仅仅是传输系统的速度，而是传输本身的速度。在这里，不变的物理定律开始发挥作用，发送方和接收方之间不可避免地存在信号传播延迟。如果“更快”不仅仅是更大的带宽，而且是系统对客户端的“响应”，那么如果想降低延迟和提高容量，实现这一目标的唯一方法是减少每次传输的距离。如果从边缘提供内容和服务，那么双方之间不可避免的延迟就会急剧下降。由于协议对话速度更快，因此系统响应速度更快。</p><p>但是，使网络更快的方法不仅仅是将服务移近客户端。我们一直在研究客户端和网络之间复杂的协议交互，将用户的“点击”转换为可见的网络响应。我们正在努力提高协议的效率，让客户端和服务器之间以更少的交换次数完成传输结果。这意味着一个响应速度更快的网络。</p><p>同时，我们还尝试从网络传输中移除长途传输元素。通过预测内容数据中心交付点的需求和预先配置内容，可以消除与距离相关的不可避免的容量瓶颈。在网络术语中，“更近”对于“更快”至关重要。这并不是“更快”的全部需求，但如果发送者和接收者之间没有紧密的距离，“更快”是不可能的。</p><h4 id="更快的网络的要素"><a href="#更快的网络的要素" class="headerlink" title="更快的网络的要素"></a><strong>更快的网络的要素</strong></h4><p>增加“最后一英里”接入网络的带宽容量。</p><p>将所有形式的内容和服务交付推入高度复制的内容分发网络。</p><p>增加内容分发点的密度，使服务器和服务更靠近用户。</p><p>预先提供内容，以便整个服务交易发生在最后一英里接入网络上。</p><p>设计应用程序环境以提高响应速度。</p><p>提高传输协议的协议性能。</p><h4 id="更好"><a href="#更好" class="headerlink" title="更好"></a><strong>更好</strong></h4><p>这是一种更抽象的品质。但如果“更好”意味着“更值得信赖”和“可验证的真实性”，那么看起来，我们在这项最具挑战性的任务中取得了进展。</p><p>HTTPS或加密和认证内容会话的使用在当今的Web服务环境中几乎无处不在。比如，我们致力于通过在安全传输层协议TLS1.3中的TLS客户端Hello消息中使用加密的服务器名称，来关上TLS协议中最后一个打开的明文字段。我们甚至通过Oblivious DNS（隐蔽式DNS）和Oblivious HTTP（隐蔽式HTTP）协议提出更进一步的方法：任何其他方，甚至是服务运营商，都无法知晓客户端身份和正在执行的交易之间的关联。这意味着除了客户之外没有人事先知道身份和交易的关联。</p><p>内容、应用程序和平台部门都热情地参与了隐私和真实性议程，网络在多大程度上是隐式可信任的问题已经不再重要。如果网络一开始就没有能力获得特权信息，那么网络是否可以信任这些信息的问题就不再重要。这个信任问题包括负载、事务元数据（例如DNS查询），甚至传输协议的控制参数。在当今的网络中，我们采用的所有网络基础设施都被视为不可信的立场，为用户和他们选择使用的服务提供“更好”的结果。</p><p>这很可能是不可撤销的一步，服务、应用程序、内容与底层平台和网络框架之间的隐含式信任将一去不复返。一旦证明这种级别的信任正以各种方式被滥用，应用程序和服务环境就会采取所有必要的措施来密封每一个潜在的暴露点和数据泄漏点。</p><p>这是一个不可后退的立场。“内部偏执狂”的理念出现在协议栈的各个层级，栈的每一层只向其他层公开功能上最小的一组信息，而这些信息是完成请求的事务所必须的。这一概念现在已经牢牢扎根于网络设计运营和应用设计的模式中。</p><h4 id="更便宜"><a href="#更便宜" class="headerlink" title="更便宜"></a><strong>更便宜</strong></h4><p>我们似乎正在过渡到一个拥有充裕通信和计算能力的环境。同时，这些系统具有显著的规模经济。例如，传输系统的转变将传输系统的承载能力提高一百万倍，并没有导致光缆系统的价格上涨一百万倍，在某些情况下，更大系统的资本和运营成本实际上逐年下降。结果是每单位距离的每比特成本因此直线下降。</p><p>这种充裕也导致了每笔交易费率的下降。虽然可以对一封信收取一分钱的邮费，或者为一个电话按分钟收费，但网络交易的单位成本通常非常小，因此不可能生成基于成本的数字服务交易费率模型。</p><p>与此同时，我们缩小了网络，使得越来越多的服务交易是本地的。正如我们已经观察到的，CDN模式的兴起改变了互联网。通过在每个边缘附近预配置内容，服务器到客户端的后续按需事务可以在很短的距离内完成。更短的距离不仅让服务交易的速度更快，而且建设和运营成本也更低。距离越短，耗电越少，并具有超强的信噪比特性。传输效率的提高也意味着更低的成本。</p><p>然而，这不仅仅是降低成本。其中一些服务是间接收费的，对消费者而言，它们的运营没有给用户带来任何可见的成本。例如，在谷歌搜索引擎上进行搜索时没有任何用户付费。它对用户是免费的。显然，这项服务是通过广告收入间接产生效益的。这种广告收入之所以成为可能，是因为谷歌收集了丰富的用户资料，并通过广告活动管理将这些资料信息出售给广告商。如果个人用户试图向广告商推销他们的个人资料，这项业务就会失败。当用户信息被汇聚成一个大的集合时，这个集合就成了非常有价值的资产。</p><p>可以说，互联网的大部分服务环境是由服务提供商提供资金的，这些服务提供商将集体资产资本化，而单独资本化是不可行的。其结果是变革性的，因为以前只有少数特权人员可以使用的奢侈品服务，现在已经转变为面向所有人的大众市场商品服务。它不仅可以提供更低的价格，在许多情况下，它是完全免费的。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a><strong>03</strong></h2><h3 id="更大、更快、更好、更便宜"><a href="#更大、更快、更好、更便宜" class="headerlink" title="更大、更快、更好、更便宜"></a><strong>更大、更快、更好、更便宜</strong></h3><p>人们常说，在通信行业，不可能同时满足所有这些目标：更大、更好、更快、更便宜。不知何故，互联网的数字服务平台却能够提供所有这些参数。它是如何做到的？</p><p>我们构建服务平台以满足越来越大的负载和不断下降的成本参数，不仅仅是通过构建更大的网络，而是通过改变客户访问这些服务的方式。我们已经在很大程度上停止在网络中一路推送内容和交易，而是从边缘提供服务。</p><p>从边缘提供服务减少了数据包里程，降低了网络成本，并提高了响应能力，从而提升了速度。这些似乎是未来几十年的驱动因素。</p><p>这不是一个更华丽、更实用、更“智能”的网络。这不是一个巴洛克式装饰的“新IP”网络，或任何与之接近的网络。这些因素代表了所谓“更智能”网络属性的完全对立面。通过将功能从网络中剥离，我们剔除了常见的成本要素，并将它们推到连接的设备上，而计算行业显然正在用更强大的设备来响应，这些设备可以轻松承担这些功能。通过将服务推向网络边缘，我们进一步边缘化了公共共享网络在提供数字服务方面的作用。</p><p>这些因素似乎是推动计算机通信和数字服务未来50年发展的主要因素。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a><strong>04</strong></h2><h3 id="长期趋势"><a href="#长期趋势" class="headerlink" title="长期趋势"></a><strong>长期趋势</strong></h3><p>这一切将向何处发展？看起来似乎是要构建更大、更快、更好和更便宜的网络，然后将越来越多的网络功能从网络内部传递出去，并将它们以复制的方式转移到网络的所有边缘，通过驻留在与所有客户端相邻的一组位置来实现。</p><p>我们似乎已经将传输和计算从稀缺而昂贵的资源转变为丰富而廉价的商品，这意味着共享公共资源不再是服务交付的重要组成部分。我们积累了如此多的传输、计算和存储，以至于不再有动力使用公共网络将客户带到遥远的服务交付点。相反，我们正在使用预先准备的服务，并将这些服务转移到客户端，内部网络被用于支持这种服务复制，以同步所有边缘服务交付点。</p><p>这反过来又预示着一个更显著的变化，即：应用程序不再是远程操作服务的窗口，应用程序正成为服务本身。将服务定位在离客户更近的位置的愿望最终引出这样一个问题：如果可以直接在客户端的设备上提供服务，为什么要在与客户端相邻的网络点上提供服务？</p><p>而这又引出了关于通信领域未来50年的两个基本问题。</p><h3 id="在这一切结束时，共享网络仍然重要吗？"><a href="#在这一切结束时，共享网络仍然重要吗？" class="headerlink" title="在这一切结束时，共享网络仍然重要吗？"></a><strong>在这一切结束时，共享网络仍然重要吗？</strong></h3><p>我们观察到的趋势是：从网络中剔除成本和功能，然后将它们加载到终端设备上。这为我们提供了更低的成本、更高的速度和更大的服务灵活性。那么，这个趋势什么时候停止呢？当我们将所有东西都推到边缘设备上时会发生什么？网络及其作用还剩下什么？</p><p>更关键的是，虚拟电路、数据包和公共网络的整个概念构成一种认知，即访问共享通信基础设施，比每个应用程序和每个客户端都访问自己专门的基础设施更有效。电路和数据包之间的区别在于如何共享公共资源，但两者都没有从根本上质疑是否需要共享。</p><p>然而，在当今网络基础设施中，共享基础设施看起来似乎有些过时。在海底光缆行业，最大的内容企业正在放弃共享基础设施模式，安装全资光缆。数据中心是另一个例子，其中最大的内容分发企业运营着完全专用的基础设施。</p><p>我们有理由思考这一切将如何发展。共享仍然重要吗？或者，共享是对特定情况的响应，而不是对其他情况的响应？这个问题的答案并不明确。但最初的网络公理，即网络是共享公共传输资源的一种方式，与50年前相比，现在已经不那么明显了。</p><h3 id="互联网呢？"><a href="#互联网呢？" class="headerlink" title="互联网呢？"></a><strong>互联网呢？</strong></h3><p>在这一切中，是什么定义了“互联网”？</p><p>我们曾经声称“互联网”是一个公共网络、一个公共协议和一个公共地址池。任何连接互联网的设备都可以向互联网中任何其他设备发送IP数据包。这就是互联网。如果你使用互联网地址池中的地址，那么你就是互联网的一部分。这个公共地址池从本质上定义了什么是互联网。</p><p>如今，情况却并非如此。随着人们继续破坏网络、协议框架和地址空间，甚至破坏名称空间，还剩下什么来定义“互联网”？可能互联网作为一个统一概念所剩下的，只是对共享通用引用机制的不同服务集合的某种模糊表述。</p><p>但是，我希望接下来的50年也是一段激动人心的旅程，就像互联网在过去50年中的表现一样。我们一次次扩展了对这项技术的认知，并完成了惊人的技术壮举。在接下来的50年中，我希望我们能做到更多！</p><hr><p>作者：杰夫·休斯顿（APNIC首席科学家）<br>来源：APNIC<br>翻译：杨望</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;让我们花点时间回顾一下50年前的1972年，以及当时的技术和电信环境。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;01&quot;&gt;&lt;a href=&quot;#01&quot; class=&quot;headerlink&quot; title=&quot;01&quot;&gt;&lt;/a&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Qunar 酒店基础数据重构DDD落地实践</title>
    <link href="http://ai.mak.cn/2022/09/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Qunar%20%E9%85%92%E5%BA%97%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84DDD%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2022/09/28/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/Qunar%20%E9%85%92%E5%BA%97%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E9%87%8D%E6%9E%84DDD%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2023-01-14T15:32:30.330Z</updated>
    
    <content type="html"><![CDATA[<p>本文作者 ：<strong>李全党</strong></p><blockquote><p> 2021年6月入职去哪儿网，酒店供应链高级技术经理、业务架构SIG成员、公司级内训师，目前负责酒店基础信息业务。主导搭建并落地多个DDD项目，并对高并发、分布式服务高可用，有建设优化经验，2021年落地公司“大主站+微服务”战略，并获得公司“金项奖”技术类三等奖，曾在QCon做过技术分享。</p></blockquote><p><strong>一、案例简述</strong></p><p>随着集团战略方向调整与业务重组，酒店供应链也面临全新的调整。酒店基础数据业务系统是从国际团队接手，属于10年前系统架构，涉及20多个微服务，架构老旧、系统耦合严重及业务边界模糊，加上业务的快速发展，导致系统灵活性不足及无法快速承接产品需求，产研合作出现效率问题。因此，酒店供应链技术侧结合酒店BU及公司相关成功案例，在2022年初主动发起基于DDD思想的技术架构调整，完整落地战略、战术设计及系统实现，本次重点介绍重构落地过程、设计原则及总结，另外阅读本文需要对DDD的基本概念及流程有一定基础，基本概念可以参考往期技术沙龙（链接见文末）。</p><p><strong>二、问题分析</strong></p><p><strong>（一）业务需求复杂</strong></p><p>酒店基础信息业务系统最初是为去哪儿独立业务设计，主要包括酒店聚合、房型聚合、图片及城市等相关信息（见下图），最初业务划分比较清晰。2015年携程战略收购去哪儿网后，业务战略也随之发生变化，但当时并未对系统进行隔离和重构，随着需求迭代的不断演化，业务逻辑变得越来越复杂，加上产品经理的流动性较大，酒店基础数据PM、DEV、QA团队缺少业务专家，大家对于原始需求缺少理解，部分业务不确定能否下线等等。</p><p><img src="https://p3.itc.cn/q_70/images03/20220928/8601c2b3e9b94577875d9ae3b50198ca.png" alt="img"></p><p><strong>（二）系统过度耦合</strong></p><p>酒店基础数据涉及微服务20多个，系统之间耦合严重，模块彼此关联，我们的系统越来越冗杂。有时修改一个很小的产品需求，光回溯该需求涉及需要修改的系统及功能点就需要达到“天”级别，更别提修改带来的不可预知的影响面，无论还是产品、技术需求还是工单问题排查等，都给组内同学带来较高学习成本和开发成本。</p><p>下图是我们酒店基础信息日常开发中的一个常见的系统耦合案例。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/4185d98603e34be7817e07e261b183f8.png" alt="img"></p><p>这个案列是要完成的业务功能是支持运营人员手工添加酒店图片，当时预估工时时长8pd，实际工时11pd。上图看出从运营开始上传到我们最终将图片外网展示，整体流程涉及到了4个系统。</p><p>以下这段话是当时开发这个产品需求的同学的“真情告白”：</p><p>1、需求及系统设计阶段。接到TL的排期并阅读产品PRD，发现涉及4个业务系统，深入系统内部发现业务逻辑复杂及系统耦合严重，熟悉系统及编写设计方案花费3pd；</p><p>2、系统开发阶段。按照设计进行功能开发发现，除正常多业务系统调用外，业务系统内部存在兜底定时任务，需要进一步熟悉其作用、数据存储及影响范围，花费6pd；</p><p>3、系统自测阶段。系统自测涉及多个系统间的耦合及不同的数据库版本，自测花费2pd。</p><p>如果我们的系统经过精心设计，这个案例是不需要8pd，更别说最终上线花费11pd。我们可以看出系统过度耦合，不但降低我们的开发效率，而且对于开发人员不够友好，这种情况对于人员的稳定性也造成很不好的影响，所以我们必须要做出改变。</p><p><strong>三、为什么选择DDD</strong></p><p>DDD有很多优势，我们站在EA角度，可以绑定业务架构和系统架构，作为中间层，将问题域与应用架构相剥离；我们站在软件复杂度角度，可以有效解决业务复杂度和软件复杂度问题；还比如DDD可以有效的从业务视角对软件系统进行拆解，是微服务划分最好的实践等等，作为基础数据重构，结合我们上面提到的业务需求复杂和业务过度耦合问题，我们主要从解决软件复杂度和微服务拆分角度考虑，最终选择DDD作为我们项目落地的指导原则。</p><p><strong>（一）软件复杂****度应对</strong></p><p>Eric Evans 认为“应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务”。因而，领域驱动设计关注的焦点在于领域和领域逻辑，因为软件系统的本质其实是给客户（用户）提供具有业务价值的领域功能。那么DDD是如何应对软件复杂度的呢？我们可以粗略的归为三类，分别是分而治之、关注点分离和统一语言。</p><p>1、分而治之。比起单体架构将所有功能都糅合在一起，DDD通过在其战略设计层面对限界上下文、上下文地图的划分来做到这一点。各个业务领域内关注自身业务能力的内聚，明确分工，不被其他领域业务侵蚀，这不仅符合“高内聚、低耦合”的架构思路，更是与微服务拆分的思想不谋而合；</p><p>2、关注点分离。DDD使得领域模型与存储模型分离，业务复杂度与技术复杂度分离；</p><p>3、统一语言。我们大部分需求是横跨多个团队，需求传递低效，需要反复沟通，方案产出效率低，而统一语言使得产研在业务概念、理解等方面达成一致，降低沟通和理解成本。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/c635686e27384b8ca34b597eb0004c85.png" alt="img"></p><p><strong>（二）微服务架构模式的最佳实践</strong></p><p>微服务有9大特征，我们这里不赘述。由于DDD可以有效的从业务视角对软件系统进行拆解，并且DDD特别契合微服务的一个特征：围绕业务能力构建。所以用DDD拆分出来的微服务是比较合理的而且能够实现高内聚低耦合。我们之前会因为微服务不知如何拆分讨论上好几天，其实根本原因是不知道边界在什么地方，而使用DDD对业务分析的时候：</p><p>1、使用聚合把关联性强的业务概念划分在同一个限界上下文，并限定聚合和聚合之间只能通过聚合根来访问</p><p>2、聚合基础之上根据业务相关性，业务变化频率，组织结构等等约束条件来定义限界上下文。</p><p>DDD的聚合和限界上下文，使得拆分微服务不再困难。</p><p><strong>四、演化式技术改造</strong></p><p>在我们确定使用DDD作为指导进行项目落地，一个难题是我们如何推进多业务系统重构上线，如果采用完全重做的方式，摒弃原有的系统重新开发，虽然可以快速有效摆脱原有系统的历史技术债，但是也会丢失那些细小而繁杂的业务逻辑，为整个系统的改造带来巨大的项目风险，特别是像酒店聚合、房型聚合等涉及多种算法的业务，严重时会导致高额赔付。</p><p>最终我们采用的是 <strong>演化式技术改造</strong>，即利用重构在原有的系统上逐步改造。即在原有系统的基础上，通过一步一步演进式的代码调整，逐步达到技术改造的目标。每一步重构，对于核心业务功能保持外部功能不变，重点调整程序内部结构，通过内部程序结构的优化，业务代码逐渐与各个层次、各种技术解耦。可以看出，演化式技术改造的目标是实现业务代码与技术框架的解耦，通过重构将长周期的改造过程，通过业务域、重要程度等划分成一个短周期的重构，保障每次重构的正确性。</p><p>酒店基础数据重构包含酒店业务、房型业务及图片业务，我们采用分阶段上线，优先上线酒店业务。那么对于酒店业务，其又包含了酒店聚合、酒店静态信息、酒店抓取等多个子业务，为保障重构业务输出正确性及阶段成果，我们将酒店业务又划分两阶段上线和功能验证，正是这样的过程，保障了在改造过程中，虽然修改了既有代码，但没有影响既有功能，使得改造更加平稳的进行下去。经过这一系列改造，系统的业务代码与技术框架解耦了，接口层建立起来，就可以从容地开展真正的技术改造。</p><p><img src="https://p3.itc.cn/q_70/images03/20220928/4215424b2499447e926e741d1cc4ccc1.png" alt="img"></p><p><strong>五、DDD实践及设计原则</strong></p><p><strong>（一）完整的DDD落地流程框架</strong></p><p><img src="https://p3.itc.cn/q_70/images03/20220928/4912980c96ce4d02b5844bd23544b3e2.png" alt="img"></p><p>上图为整体DDD落地流程框架，也是thought works强力推荐的流程，那么我们本篇文章并不打算去讲解流程的每个细节，而是重点介绍我们在酒店基础信息重构过程中，所积累的落地时间经验和原则，希望通过这些经过抽象和总结的经验，能够给各位带来一些收获和思考，具体内容请接着往下看。</p><p><strong>（二）DDD落地实践原则</strong></p><ul><li><strong>产研沟通，定位愿景</strong></li></ul><p>定位愿景的主要目的是对产品的顶层价值设计，对产品目标用户、核心价值、差异化竞争点、痛点等策略层信息在团队层面达成共识，这也是我们做这个事情的根本。而对于部分的DDD分享文章或者我们真正在做项目落地时，缺少关注我们的项目定位、愿景是什么，项目前期没有关注，会导致我们在划分子域时，不清楚如何确定是核心域、支撑域还是通用域等，以及资源安排没有侧重点，愿景的定位非常重要，尤其在我们新项目落地。</p><p>我们常用的定位愿景所使用的方法叫“电梯演讲”， 领域专家与项目团队一起思考，我们做的项目业务范围、目标用户、核心价值和愿景，我们与同类产品的差异和优势在哪里？整个过程是统一项目建设方向和团队思想的过程，当然如果我们的项目是一个纯粹的后端业务系统，并不是所有点都涉及，也可以跳过，比如下图所示的“关键的优点，难以抗拒的使用理由”，对于酒店静态信息而言，我们的使用用户更多是我们公司内部，那么就没有难以抗拒的使用理由了。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/bc5f7d9b34db4a47b016ec295f267deb.png" alt="img"></p><ul><li><strong>产研融合，提炼问题域</strong></li></ul><p>理解一个复杂问题域以便创造简单且有用的模型，需要深入详尽的知识以及深刻的见解，这些需要产、运、研、测共同协作得到。只有通过协作及共享对问题域的理解，才能有效设计领域模型以应对业务的挑战，这样也能具备足够的灵活性应对新出现的需求。初期我们与产运一起，通过线上画板工具（初期推荐使用BeeArt，也可使用ProcessOn）及公司白板，开展事件及命令风暴，一起探讨应用程序的应用场景。这一过程是所有参与者进行花火碰撞，获得领域的深刻见解的催化剂，通过风暴我们提炼出领域知识，重新梳理业务流程，并形成通用语言（可以包括显示的业务规则、领域名词解释等，形成统一的思维地图），达成共识。</p><p>下图右半部分为“酒店静态信息业务流程”，我们本次重构重新对原有“蜘蛛网”式的业务流程进行梳理，明确业务流阶段、价值及相应显式规则，与产运沟通确认20次（微信、邮件、线下会议、腾讯会议等）。通过产研融合，提炼问题域后，确认线上低价值或无用业务占比线上总业务用例的41.9%（原始业务用例：222个，重构后保留业务用例：129个，共下掉93个业务）。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/0173d7d2f63e4cea96b9a9c6612fe713.png" alt="img"></p><ul><li><strong>集中精力，专注核心域</strong></li></ul><p>酒店基础数据涵盖酒店、房型、图片及位置区域等多个问题域，我们需要将问题域分而治之来降低复杂性，因为较小的模型可以在子域的上下文中更容易被理解。并通过划分核心域、通用域及支撑域来决定研发策略（比如：视频、图片及城市等通用域业务简单且需求相对稳定，并未进行重构，保持现状）及资源配备。相信大家在进行项目开发的时候，一定会觉得时间紧、任务重及资源不足等等，那么这个时候我们更要关注要做的项目，他的核心价值是什么（可以参考领域愿景），因为他代表团队或组织的价值所在，所以我们要专注核心领域，安排核心开发人员及做好跟踪，确保核心领域按照预期推进。</p><p><img src="https://p6.itc.cn/q_70/images03/20220928/c205a5c3458e49e49809e1691f3f680a.png" alt="img"></p><ul><li><strong>使用限界上下文保护领域模型完整</strong></li></ul><p>限界上下文拥有从展现层到领域逻辑层，再到持久化，甚至到数据存储功能的垂直切片，那么产品的概念可以存在每个限界上下文中，并且包含仅对该上下文普遍存在的特性和逻辑。任何限界上下文中的变化不再具有对其他有界上下文的影响，因为限界上下文或子域是隔离的。限界上下文具备概念上的独立性，一个限界上下文内的子概念的解释和目的都不应该超出上下文的边界，若出现以下依赖关系，需要思考是否存在未澄清的问题：</p><p>a. 双向依赖:上下文之间缺少一层未被澄清的上下文，或者两个上下文其实可被合为一个；</p><p>b. 循环依赖:任何一个上下文发生变更，依赖链条上的上下文均需要改变；</p><p>c. 过长的依赖:自身依赖的信息不能直接从依赖者获取到，需要通过依赖者从其依赖的上下文获取并传递，依赖链 路过长，依赖链条上的任何一个上下文发生变更，其链条后的任何一个上下文均可能需要改变。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/140bf7f5550b4a4c87124d09fddf3c2d.png" alt="img"></p><p>另外我们要把握好领域职责，领域之外的事不要管，同时领域之间的数据交互，需要通过“防腐层”将领域外的对象转换为领域内对象。举个例子：下图是我们酒店的抓取解析流程，重构前不仅做了抓取和解析，还做了特殊属性处理、视频处理等非自己领域的事情，所以我们重构后，将这两个事情让给了“酒店静态信息上下文”去处理，并形成抓取解析上下文，只做一件事情：从外部抓取数据，并将数据转换为Qunar内部对象。</p><p><img src="https://p5.itc.cn/q_70/images03/20220928/0ed35e9def3248b1afefc34f73466e29.png" alt="img"></p><ul><li><strong>应用程序架构落地COLA</strong></li></ul><p>目前比较流行的应用架构，都会遵循一些共同模式，不管是六边形架构、洋葱圈架构、整洁架构、还是COLA架构，都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。我们最终选择了COLA架构，有几点原因：</p><ul><li><strong>明确的分层架构</strong></li></ul><p>所有的复杂系统都会呈现出层级结构，应用系统处理复杂业务逻辑也应该是分层的，下层对上层屏蔽处理细节，每一层各司其职，分离关注点</p><p>1、适配层：针对不同端、协议的适配，包括酒店基础信息命令执行、查询及适配返回等；</p><p>2、应用服务层：酒店基础信息业务用例识别，并负责调用领域层能力，对用例进行组装、编排及返回结果；</p><p>3、领域服务层：提供酒店基础信息相关业务能力，并针对复杂或跨聚合业务提供领域服务能力，供应用服务层调用；</p><p>4、基础设施层：主要处理技术细节问题的处理，包括领域外部服务访问防腐层实现，数据库DB、缓存等持久化。</p><p><img src="https://p2.itc.cn/q_70/images03/20220928/245c4dd7146a402a894e4a8b61ea4796.png" alt="img"></p><p><img src="https://p2.itc.cn/q_70/images03/20220928/f4bd55b428f6409cbdb9d1859d30f6c9.png" alt="img"></p><p>扩展：我们在整个战术设计的过程中，利用奥卡姆剃刀原理（是指如无必要，勿增实体，即“简单有效原理”）的思想，引入DP（Domain Primitive 是 Value Object 的进阶版，在原始 VO 的基础上要求每个DP拥有概念的整体，而不仅仅是值对象）并把实体属性归类，为 VO 的 Immutable 基础上增加了 Validity 和无状态行为，防止将过多的属性拍平到实体。</p><p><img src="https://p6.itc.cn/q_70/images03/20220928/39e4803f7e174a698cbef7217a93c7fe.png" alt="img"></p><ul><li><strong>符合演进式架构设计</strong></li></ul><p>分层是属于大粒度的职责划分，我们有必要往下再down一层，细化到包结构的粒度，才能更好的指导我们的工作。COLA架构除了有分层规范以外，对每一层内部的包结构也有明确规范，即“聚合分包，功能分类”，这样的设计可以更好的应对未来需求变化的不确定性，符合演进式架构（演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化。那如何判断微服务设计是否合理呢？随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的）。</p><p><img src="https://p9.itc.cn/q_70/images03/20220928/d945717a316e4c04a5d0ed72e8f7a10c.png" alt="img"></p><p><img src="https://p1.itc.cn/q_70/images03/20220928/da0b0cf8a0a44142b0b8169c6a349ce7.png" alt="img"></p><p>COLA架构，本质上没有什么严格的约束，对于业务代码，还是有非常好的指导建议，不一定非要严格的按照框架的要求来执行，但一定要有规范的思想，这才是核心的。实际开发中，我们并没有完全按照CLOA架构的指导要求来，比如扩展组件并没有使用，适合自己的才最重要。相信只要我们做好分模块，分层次，做好命名规范+一定的充血模型，代码就能做到简洁易懂。</p><p><strong>六、案例成果总结</strong></p><p><strong>（一）案例重构成果</strong></p><p>1、业务复杂度方面，我们共梳理222个业务用例，重构后保留129个，共下掉93个，业务平均下掉41.9%，对于降低产运研业务学习带来较大帮助；</p><p>2、瘦身服务及减链路方面，酒店基础信息业务涉及21个应用微服务，通过DDD领域划分后下降到13个，微服务减少33%，对应代码下降情况统计，平均代码下掉58.3%，大大降低研发学习及硬件成本；</p><p>3、业务专家方面，通过事件、命令风暴，对于项目成员对酒店基础信息业务更加有全局观，与产研形成统一语言和知识，减少产、运、测、研沟通成本，在业务专家方面增加2名研发业务专家，让我们更多站在业务视角去思考和解决问题，而不是来了需求首先想到的是工时问题；</p><p>4、效率提升方面，问题处理，工单处理下降50%。</p><p><img src="https://p1.itc.cn/q_70/images03/20220928/a6f39e20892441759c9a1cd7ff3c4f3f.png" alt="img"></p><p><strong>（二）项目重构常见问题</strong></p><ul><li><strong>没有领域专家怎么办？</strong></li></ul><p>我们都知道，业务领域专家和开发团队之间的协作是DDD必不可少的部分，特别是战略、战术设计阶段。不过，寻找到当前业务领域中是专家以及能够为问题域提供深刻见解的人，可谓是少之又少。那么如果没有领域专家怎么办呢？作为替代，可以寻找对于我们当前工作领域具备多年经验和理解的产品所有者、用户、研发或其他任何人，不必在意他们是不是权威，是不是管理者等等。</p><p>以我们当前的重构项目为例，酒店基础信息产品流动率高，没有对应的产品业务专家，最终我们寻找到具有多年工作经验的资深研发和业务QA作为我们的领域专家，最终取得的效果也是非常不错的。我们推荐的业务领域专家顺序为：业务产品团队-&gt;技术负责人-&gt;业务开发负责人-&gt;业务QA。</p><ul><li><strong>简单问题复杂化</strong></li></ul><p>1、DDD的价值在于帮助管理显著优势的复杂问题域，请不要轻视MVC模式，因为并非系统所有的部分都要被精心设计</p><p>我们的酒店基础信息重构项目，有酒店、房型、图片等多个问题子域，以房型子域为例，有房型抓取、落地及房型聚合等多个限界上下文，其中房型聚合业务逻辑简单，清晰明了，所以我们并没有采用DDD分层架构模式进行实现，而是使用MVC模式，不仅缩短工期，且可以快速上线验证效果，所以我们要避免将领域模型应用到每个限界上下文。</p><p>2、解决方案并不总是技术层面</p><p>当遇到项目问题时，我们大部分人的思维是从实现上进行解决，比如技术实现考虑高并发、高可用及高性能，但是真的有必须要吗？这让我想起一句话：业务架构是灵魂，技术架构是容器，脱离灵魂得容器是没有意义的！以我们的重构项目为例，我们在进行事件风暴前的业务用例梳理时，我们把业务进行归类，对于非核心业务我们会找相关业务使用方进行沟通确认，是否可以下线，是否可以合并，是否可以简化操作等等，最终我们在业务复杂度方面下降43%，节省大量的产研沟通和研发成本。</p><ul><li><strong>非核心领域占用大量精力</strong></li></ul><p>我们可能因为没有使用领域愿景来描述我们项目的核心竞争力，导致我们缺乏对项目成败核心是什么的关注，而我们的资源是有限的，时间是有限的，我们只有把有限的资源投入到最重要的区域-核心领域，才能更好的服务于企业战略，实现商业价值。以我们重构项目为例，我们项目开始则高亮我们的愿景，明确核心领域，把资深人员安排在核心的位置，保障核心领域的研发和交付质量。在项目最重要的区域分摊太少的资源就是反模式。</p><ul><li><strong>产品不关注是否使用DDD，只关注需求是否如期上线</strong></li></ul><p>对于产品只关注自己的需求是否如期上线，这种情况非常常见，所以需要我们要付出一些努力来达成我们做DDD重构的目标，我认为可以从以下几个方面入手：</p><p>1、讲清楚系统现状，以及使用DDD重构后所带来的价值，达成价值共识（与产品，必要可能需要跟产品的上级）；</p><p>2、资源紧张情况下，重要需求正常排期，非重要与产品沟通延迟上线；</p><p>3、优先解决系统核心价值域问题，分阶段成果发布；</p><p>4、研发资源闭环和共享模式共存。关于闭环和共享解释如下（摘自“人人都是产品经理”）：</p><p>闭环：就是和业务需求方绑定，专门做此类变化快的需求开发，其他的都不做；而共享则相反，将研发资源共享成一个池，所有的业务需求也汇总在一个或多个优先级队列里，排队开发。</p><p>共享：有利于充分利用研发资源，规模化、专业化，提升吞吐，但可能也降低了平均响应时间，更适合于进入成熟期，稳定渐进发展的业务。闭环，优先考虑专属业务需要的响应，但也失去了规模与专业化效应，更适合快速发展期的创新业务，而过了业务高速期，专属的研发就会形成资源浪费，对个体的成长也有不利因素。</p><p><strong>七、总结</strong></p><p>本文以酒店基础信息DDD重构实践为案例，介绍了我们为什么选择DDD，完整的DDD落地流程框架，以及利用大量篇幅和例子介绍我们项目落地实践的原则，最后介绍了案例成果和项目重构过程中常见的问题及解决方案，相信大家对DDD有了更加清晰的认识，同时在项目落地时也有了一些明确的指导原则，避免踩坑。但是DDD不是灵丹妙药，更不是“银弹”，最后有几点建议送给大家：</p><p>1、DDD是思想，是一种业务领域建模方法论、业务架构设计方法论，是指导开发过程的方法论</p><p>2、DDD是业务+技术的共同深度参与，开发人员需要有思考方式的转变，所以实践能否成功，不仅仅是技术的问题，更是贯彻实施的问题</p><p>3、战略设计阶段属于整个DDD核心阶段，领域边界划分对于团队的抽象能力有一定挑战，请不要为了“省事”，最后做成了“精简版”的DDD</p><p>好了，就写到这里，期待大家都能够有机会利用DDD作为项目指导和落地的方法论，并获得DDD所带来的价值体验~</p><p># 国内酒店交易DDD应用与实践——理论篇</p><p>#</p><p>国内酒店交易DDD应用与实践——代码篇</p><p>#</p><p>基于DDD思想的技术架构战略调整</p><p>#</p><p>坚定推动DDD一年后，去哪儿网如今怎么样了</p><p>#</p><p>听“侃王”讲基于DDD思想的酒店报价引擎重构</p><p>#</p><p>去哪儿网领域驱动设计（DDD）的实践之路</p><p><strong>END</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文作者 ：&lt;strong&gt;李全党&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 2021年6月入职去哪儿网，酒店供应链高级技术经理、业务架构SIG成员、公司级内训师，目前负责酒店基础信息业务。主导搭建并落地多个DDD项目，并对高并发、分布式服务高可用，有建设</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2022年中国数智融合发展洞察</title>
    <link href="http://ai.mak.cn/2022/09/17/%E6%9D%82%E8%AE%B0/2022%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E6%99%BA%E8%9E%8D%E5%90%88%E5%8F%91%E5%B1%95%E6%B4%9E%E5%AF%9F/"/>
    <id>http://ai.mak.cn/2022/09/17/%E6%9D%82%E8%AE%B0/2022%E5%B9%B4%E4%B8%AD%E5%9B%BD%E6%95%B0%E6%99%BA%E8%9E%8D%E5%90%88%E5%8F%91%E5%B1%95%E6%B4%9E%E5%AF%9F/</id>
    <published>2022-09-16T16:00:00.000Z</published>
    <updated>2023-01-25T02:45:50.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VUCA时代，市场变化加速。企业需要基于全量、准确数据的分钟级、敏捷化的数智决策，并且应当由业务人员和数据分析人员任意发起，而非经过复杂流程和多部门配合实现。数据持有成本高、数据治理能力差、开发技术门槛高、数据准备工作复杂难以聚焦业务本身等系列问题让数智融合和企业敏捷决策变得困难。基于存算分离、统一元数据、DataOps与MLOps融合、端到端自动化和智能化的数智融合让企业智能用数和敏捷决策得以实现。</p></blockquote><p><strong>关注公众号：【互联互通社区】，回复【DATA074】获取全部报告内容。</strong></p><p>精彩推荐</p><p>关注互联互通社区公众号，回复以下编号，可快速下载相关专题报告合辑。</p><p>DATA001：大数据平台安全研究报告</p><p>DATA002：数据驱动型企业成长路径研究报告</p><p>DATA003：数据资产化工具</p><p>DATA004：大数据产品和解决方案服务能力目录指引</p><p>DATA005：数据智能趋势报告</p><p>DATA006：2020大数据白皮书</p><p>DATA007：微众银行数据新基建白皮书</p><p>DATA008：数据价值与要素发展报告</p><p>DATA009：数据智能报告</p><p>DATA010：2021数据库行业研究报告</p><p>DATA011：数据中心分析师系列报告</p><p>DATA012：2020年数据治理年度报告</p><p>DATA013：2020数据智能厂商全景报告</p><p>DATA014：2020中国大数据产业发展白皮书</p><p>DATA015：京东大数据技术白皮书</p><p>DATA016：数据资产管理实践白皮书</p><p>DATA017：数据治理研究报告</p><p>DATA018：大数据标准化白皮书</p><p>DATA019：大数据推动全民征信创新</p><p>DATA020：BAT数据洞察报告</p><p>DATA021：非结构化数据管理解决方案白皮书</p><p>DATA022：数据生产力崛起：新动能 新治理</p><p>DATA023：工业大数据分析指南</p><p>DATA024：应用程序接口(API)数据安全研究报告</p><p>DATA025：城市大数据平台白皮书</p><p>DATA026：大数据驱动的消费者洞察</p><p>DATA027：中华人民共和国数据安全法</p><p>DATA028：数据资产管理实践白皮书</p><p>DATA029：2021年数据库发展研究报告</p><p>DATA030：下一代数据存储技术研究报告</p><p>DATA031：重点城市大数据发展指数报告</p><p>DATA032：2021开放数据资产评估白皮书</p><p>DATA033：2021大数据产业发展白皮书</p><p>DATA034：中国大数据区域发展水平评估报告</p><p>DATA035：2021中国城市数据治理工程白皮书</p><p>DATA036：跨境数据流动规则和制度建设白皮书</p><p>DATA037：地球大数据支撑可持续发展目标报告</p><p>DATA038：2021中国大数据产业发展指数白皮书</p><p>DATA039：2021企业数据合规白皮书</p><p>DATA040：商业银行数据资产管理体系建设实践报告</p><p>DATA041：2021数据治理工具图谱研究报告</p><p>DATA042：2021政务数据开发利用研究报告</p><p>DATA043：数据资产化前沿性研究白皮书</p><p>DATA044：数据价值释放与隐私保护计算应用研究报告</p><p>DATA045：2021工业实时数据库行业白皮书</p><p>DATA046：2021数据跨境合规治理实践白皮书</p><p>DATA047：2021大数据白皮书</p><p>DATA048：2021年拥抱数据智能：场景与实践白皮书</p><p>DATA049：2021年数据治理标准化白皮书</p><p>DATA050：“十四五”数据库发展趋势与挑战</p><p>DATA051：2022年数据库云管平台白皮书</p><p>DATA052：数据安全风险分析及应对策略研究</p><p>DATA053：2022可信工业数据空间系统架构</p><p>DATA054：中国双碳大数据指数白皮书（2022）</p><p>DATA055：雄安新区2021年大数据研究报告</p><p>DATA056：中国商业数据智能行业研究</p><p>DATA057：2021年中国数据资产化工具</p><p>DATA058：中国云原生数据湖应用洞察白皮书</p><p>DATA059：公司治理数智未来白皮书</p><p>DATA060：数据中心白皮书（2022年）</p><p>DATA061：典型行业与省市数据法规解读</p><p>DATA062：2022数据智能时代的敏捷BI</p><p>DATA063：中国大数据分析行业研究报告（2022年）</p><p>DATA064：中国公共数据开放图谱</p><p>DATA065：金融大数据平台总体技术要求</p><p>DATA066：金融机构外部数据管理实践白皮书（2022年）</p><p>DATA067：公共数据运营模式研究报告</p><p>DATA068：数据安全治理白皮书 4.0</p><p>DATA069：数字安全产业大数据白皮书</p><p>DATA070：华为数据治理方法论</p><p>DATA071：2021河南省城市活力大数据报告</p><p>DATA072：全域数据治理白皮书（2022年）</p><p>DATA073：数据治理研究报告—数据要素权益配置路径</p><p>DATA074：2022年中国数智融合发展洞察</p><p><strong>以下是报告部分内容</strong></p><p><img src="https://p0.itc.cn/q_70/images03/20220916/6dfe717c5a904d089041c0aca2fc56e1.jpeg" alt="img"></p><p><img src="https://p8.itc.cn/q_70/images03/20220916/58ea2411b1fc48d3a0a1ca809fffcc78.jpeg" alt="img"></p><p><img src="https://p9.itc.cn/q_70/images03/20220916/2e120875d64a4b7b8e44bdc8a8eddf61.jpeg" alt="img"></p><p><img src="https://p0.itc.cn/q_70/images03/20220916/08e03ee010d54203b2f0c28221cc4843.jpeg" alt="img"></p><p><img src="https://p0.itc.cn/q_70/images03/20220916/690f256b5ec1422999fe5a4250320c36.jpeg" alt="img"></p><p><img src="https://p3.itc.cn/q_70/images03/20220916/b5289e20d6f64e1591cda36c1c756177.jpeg" alt="img"></p><p><img src="https://p0.itc.cn/q_70/images03/20220916/65edae15f1ae43f384d04082ed85193f.jpeg" alt="img"></p><p><img src="https://p6.itc.cn/q_70/images03/20220916/b91fffb1553d48ceb445f7295f34c392.jpeg" alt="img"></p><p><img src="https://p8.itc.cn/q_70/images03/20220916/ca51bc00c8a542968d13ca7cb4dce35e.jpeg" alt="img"></p><p><img src="https://p5.itc.cn/q_70/images03/20220916/96348b05204e496a9280f57578677526.jpeg" alt="img"></p><p><img src="https://p5.itc.cn/q_70/images03/20220916/bf5a7fb1839e402998aa28dc6d0b94d6.jpeg" alt="img"></p><p><img src="https://p4.itc.cn/q_70/images03/20220916/f33dca7b30294c53aa890c75668f7cb3.jpeg" alt="img"></p><p><img src="https://p1.itc.cn/q_70/images03/20220916/5e0f98e007b64b07915b2114ba21f794.jpeg" alt="img"></p><p><img src="https://p7.itc.cn/q_70/images03/20220916/14a0d8e4ca914bcd93a23e3232f67e26.jpeg" alt="img"></p><p><img src="https://p7.itc.cn/q_70/images03/20220916/fe1d4bd643ea47e6a942da79be1ad65f.jpeg" alt="img"></p><p><img src="https://p7.itc.cn/q_70/images03/20220916/baa462f925bb44ec8b704fa6d86d7e60.jpeg" alt="img"></p><p><img src="https://p5.itc.cn/q_70/images03/20220916/62babb9aa7ee4889b9417689fd79ae06.jpeg" alt="img"></p><p><img src="https://p2.itc.cn/q_70/images03/20220916/993a75676faf43e382cbf81866faa96d.jpeg" alt="img"></p><p><img src="https://p3.itc.cn/q_70/images03/20220916/c8e2bf455c44464f89150fa5f4a8968e.jpeg" alt="img"></p><p><img src="https://p1.itc.cn/q_70/images03/20220916/f861cd1be27e4e1797f7e05f8232eb87.jpeg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;VUCA时代，市场变化加速。企业需要基于全量、准确数据的分钟级、敏捷化的数智决策，并且应当由业务人员和数据分析人员任意发起，而非经过复杂流程和多部门配合实现。数据持有成本高、数据治理能力差、开发技术门槛高、数据准备工作复杂难以聚焦业务本身等系列问题</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="报告分享" scheme="http://ai.mak.cn/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>老山骑行路线规划</title>
    <link href="http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/"/>
    <id>http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/</id>
    <published>2022-09-07T16:00:00.000Z</published>
    <updated>2023-01-24T07:32:16.283Z</updated>
    
    <content type="html"><![CDATA[<p>老山骑行路线，骑行群规划的路线，收藏，随时查看</p><p><img src="https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老山骑行路线，骑行群规划的路线，收藏，随时查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>都不推荐使用＠Autowired 注解的原因</title>
    <link href="http://ai.mak.cn/2022/08/31/java/%E9%83%BD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%A0Autowired%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://ai.mak.cn/2022/08/31/java/%E9%83%BD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%A0Autowired%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-08-30T16:00:00.000Z</published>
    <updated>2023-01-16T08:10:49.018Z</updated>
    
    <content type="html"><![CDATA[<p>大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解@Autowired后会出现如下警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field injection is not recommended (字段注入是不被推荐的)</span><br></pre></td></tr></table></figure><p>但是使用@Resource却不会出现此提示网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下</p><h2 id="Spring常见的DI方式"><a href="#Spring常见的DI方式" class="headerlink" title="Spring常见的DI方式"></a>Spring常见的DI方式</h2><ul><li><p>构造器注入：利用构造方法的参数注入依赖</p></li><li><p>Setter注入：调用Setter的方法注入依赖</p></li><li><p>字段注入：在字段上使用@Autowired&#x2F;Resource注解</p></li></ul><h3 id="Autowired-VS-Resource"><a href="#Autowired-VS-Resource" class="headerlink" title="@Autowired VS @Resource"></a>@Autowired VS @Resource</h3><p>事实上，他们的基本功能都是通过注解实现依赖注入，只不过 <strong>@Autowired</strong> 是 <strong>Spring</strong> 定义的，而 <strong>@Resource</strong> 是 <strong>JSR-250</strong> 定义的。大致功能基本相同，但是还有一些细节不同：</p><p>依赖识别方式：**@Autowired** 默认是byType可以使用 <strong>@Qualifier</strong> 指定 <strong>Name</strong> ，**@Resource** 默认ByName如果找不到则ByType</p><p>适用对象：**@Autowired** 可以对构造器、方法、参数、字段使用，**@Resource** 只能对方法、字段使用</p><p>提供方： <strong>@Autowired</strong> 是 <strong>Spring</strong> 提供的， <strong>@Resource</strong> 是 <strong>JSR-250</strong> 提供的</p><h2 id="各种DI方式的优缺点"><a href="#各种DI方式的优缺点" class="headerlink" title="各种DI方式的优缺点"></a>各种DI方式的优缺点</h2><p>参考Spring官方文档，建议了如下的使用场景：</p><ul><li><p>构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）</p></li><li><p>Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）</p></li><li><p>Field注入：大多数情况下尽量少使用字段注入，一定要使用的话， @Resource相对@Autowired对IoC容器的耦合更低</p></li></ul><h2 id="Field注入的缺点"><a href="#Field注入的缺点" class="headerlink" title="Field注入的缺点"></a>Field注入的缺点</h2><ul><li><p>不能像构造器那样注入不可变的对象</p></li><li><p>依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</p></li><li><p>会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</p></li><li><p>导致单元测试也必须使用IoC容器，原因同上</p></li><li><p>依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则</p></li></ul><h2 id="为什么IDEA只对-Autowired警告"><a href="#为什么IDEA只对-Autowired警告" class="headerlink" title="为什么IDEA只对@Autowired警告"></a>为什么IDEA只对@Autowired警告</h2><p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p><blockquote><p>那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？</p></blockquote><p>就像我们前面提到过的：@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。而 @Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解@Autowired后会出现如下警告&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用HTTP/3？</title>
    <link href="http://ai.mak.cn/2022/08/20/%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8HTTP:3%EF%BC%9F/"/>
    <id>http://ai.mak.cn/2022/08/20/%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8HTTP:3%EF%BC%9F/</id>
    <published>2022-08-19T16:00:00.000Z</published>
    <updated>2023-01-15T12:19:46.328Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议的第三个主要版本，即 HTTP&#x2F;3， 于 2022 年 6 月 6 日被采纳为 IETF （互联网工程任务组）[1]标准。可能有人也会像我一样，在得知此消息[2]后会感到非常高兴，当然，大家可能对此也不太关心，毕竟现在的网络运行良好，没必要关注新的变化。但是，如果你也好奇发生这种变化的原因，接下来我们将简短地介绍背后的历史，并讨论为何应该采用 HTTP&#x2F;3。</p><p>HTTP&#x2F;3 是超文本传输协议（HTTP）的第三个版本，之前以 HTTP-over-QUIC 被大家熟知。QUIC 最初由谷歌开发，是 HTTP&#x2F;2 的下一代协议。谷歌和 Facebook 等公司已经在使用 QUIC 来加快网络速度。</p><p><em>—</em> <em><strong>1</strong></em> <em>—</em></p><p><strong>HTTP 简史</strong></p><p>过去，有两种互联网协议可以选择。甚至在 Web 出现之前，我们仍然需要通过网络将信息包（或数据报）从一台机器发送到另一台机器。对于游戏开发者来说，一个比较重要的协议是 UDP（用户数据报协议），遵循快速、即发即弃的标准：在网络上发出一个数据包，数据包有可能会被接收，也可能会丢失。</p><p>举一个比较形象的例子，你在游戏中打出的子弹，通过网络传输，显示在目标玩家的机器上，即使个别子弹在传输过程中丢失，也不会对整个游戏产生过多影响。</p><p>但是对于像 Web 这样更稳定的系统，底层协议使用 TCP 协议才是正确之选。这是一个更正式的系统，它保证了数据包传递的可靠性和顺序性。首先创建可靠的连接，然后基于连接传输信息流。在 Web 出现之前，我记得连接到互联网需要使用 Trumpet Winsock ——被称作为“TCP&#x2F;IP 堆栈”。我们曾在一家历史悠久的公司中，使用 Trumpet Winsock 与 CIX（英国在线会议系统）[3]交互。如今，CIX 已是一个韩国男团的名字。</p><p>最终，基于 TCP&#x2F;IP 编写的万维网和 HTTP 接管了互联网，成为主流。另外， TLS（传输层安全）提供了加密能力，并在 HTTP&#x2F;2 就绪时成为事实上的安全标准。</p><p>PC 之间的连接通常是有线的，任何损失都是由于旧铜线上的噪音造成的，TCP 则非常适合收集偶尔出错的数据包。随着网络的发展，UDP 的使用越来越少了。</p><p><em>—</em> <em><strong>2</strong></em> <em>—</em></p><p><strong>QUIC 初探</strong></p><p>今天的互联网环境已大不相同，家中的 PC 有很好的光纤连接和良好的线路，但大多数用户通过手机或笔记本电脑使用互联网。当使用网络的地点发生切换时，网络信号可能会受到墙体的阻挡或反弹，导致网络连接通常会被切断并重连。</p><p>这恰恰是 TCP 不喜欢的场景——如果没有正式的初始化连接和良好的握手，TCP 内心真的不想进行通信。事实上，TCP 对最后一个杂散数据包（stray packet）的严格统计和等待意味着用户必须等待网页加载、新应用程序下载，或者超时后重新建立连接。</p><p>因此，通过利用 UDP 的非正式性，并允许网络可以动态地使用一些智能的能力，新的 QUIC（快速 UDP 互联网连接）形式得到了更多的关注。</p><p>虽然我们不希望在网络本身中看到太多智能化的东西，但如今我们对自动决策机制已越来越适应。QUIC 可以理解一个站点是由多个文件组成的，它不会因为一个文件没有完成加载而破坏整个连接。</p><p>QUIC 遵循的另一个趋势是内置安全性。而之前加密是可选的（即 HTTP 或 HTTPS）QUIC 始终是加密的。尽管开销可能会变大，但当下每个站点都应该加密。这不仅仅是为了确保中间人看不到你点的是什么类型的橙汁，更要确保你是在与真正的橙汁供应商进行交易。</p><p>虽然协议格式一直在改进，但随着时间的推移 QUIC 也在真正解决不同的问题。</p><p><em>—</em> <em><strong>3</strong></em> <em>—</em></p><p><strong>活跃度</strong></p><p>那么 QUIC 现在发展的如何呢？可以从三个方面来考虑：浏览器、云基础设施和用户代码。</p><p>首先是浏览器支持情况。下面的表格来自 Can I Use[4]：</p><p><img src="https://aimak.cn/blog_img/network/QUIC.png"></p><p>显然，谷歌是非常热衷推广 QUIC 的——从 v87（2020 年末）开始的 Chrome 版本已经能够使用 HTTP&#x2F;3 协议。不出意料，鉴于苹果过往在浏览器开发方面的表现，Safari 目前是落后的。</p><p>可以使用下面的网站来检查浏览器是否符合 HTTP&#x2F;3（可能需要重新加载）：</p><ul><li>cloudflare-quic.com</li><li>quic.nginx.org</li><li><a href="https://http3.is/">https://http3.is/</a></li></ul><p>那对于现有的网站来说呢？如果需要测试现有站点是否支持 HTTP&#x2F;3，可以使用 <a href="https://geekflare.com/tools/http3-test">https://geekflare.com/tools/http3-test</a> 进行测试。好消息是，如果你的网站在 HTTP&#x2F;2 下运行良好，那么它在 HTTP&#x2F;3 下也会运行良好，甚至会表现更好。</p><p><em>—</em> <em><strong>4</strong></em> <em>—</em></p><p><strong>谁在推广 HTTP&#x2F;3？</strong></p><p>那么，现在谁在推广 HTTP&#x2F;3 呢？毫无疑问，谷歌是其中之一。还有 CDN 供应商，例如 Cloudflare 和 Fastly，他们吃饭的家伙什儿就是网络响应速度。因此，实现 HTTP&#x2F;3 最简单的方法是通过 CDN，这也是一项让移动用户受益良多的变化。</p><p>目前确实存在使用 QUIC 构建的服务器（例如 Litespeed），但采用率参差不齐。许多服务器依赖于第三方库，复用现有的、经过验证的成果则不再奏效。现有的服务器软件，如 Node.js、NGINX 和 Apache，开始采用新的内部结构时就失去了用户体验优势。相反，如果是新的服务器软件，由于还未经过充分验证和使用，可能更容易采用新的协议。使用 Web 服务器的关键在于它是可靠的、经过良好测试和维护的。</p><p><em>—</em> <em><strong>5</strong></em> <em>—</em></p><p><strong>适配 HTTP&#x2F;3</strong></p><p>在正常情况下，我会深入研究一些代码——但我觉得现阶段这样做有点为时过早。有很多项目可能都在定期变化，所以目前只需要浅尝一下即可。</p><p><img src="https://aimak.cn/blog_img/network/wl-kaifa.jpeg"></p><p>通过一些简单的项目示例（例如，一个简单的服务器和一个简单的客户端），我们可以剖析一下不同的层级。</p><p>首先是连接。更高级别的通道最初会在两个端点之间建立。然后创建连接标识符，连接一旦建立，如果下层的协议发生变化（例如，电话切换 wi-fi），连接仍然存在，以避免重新开始协商。</p><p>连接会开启多个携带各自数据类型的 Stream 流，Stream 流之间相互独立，互不干扰。</p><p>下面仍然是数据包。每个数据包，就像一封地址明了的信件，包含连接和加密信息。信封里面是数据帧。这些就代表正在传输的实际数据。</p><p>正如我之前所说，进步实际上只是反映了不断变化的使用模式。当下，我们重视安全性和速度，因为我们不再将网络视为不可靠的魔法——因此用它来管理个人事务。HTTP&#x2F;3 将有助于解决这些问题。可能 Web3 和新兴的元宇宙世界会更加棘手，也许这些领域的新想法未来会为 HTTP&#x2F;4 的发展做出贡献。</p><p>相关链接：</p><ol><li><a href="https://www.rfc-editor.org/info/rfc9114">https://www.rfc-editor.org/info/rfc9114</a></li><li><a href="https://www.theregister.com/2022/06/07/http3_rfc_9114_published/">https://www.theregister.com/2022/06/07/http3_rfc_9114_published/</a></li><li><a href="https://en.wikipedia.org/wiki/CIX_(website)">https://en.wikipedia.org/wiki/CIX_(website)</a></li><li><a href="https://caniuse.com/">https://caniuse.com/</a></li></ol><p>推荐阅读：</p><ul><li>《<a href="http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&mid=2247552114&idx=1&sn=03ae85e767ddbcb45c7b28925fd32f49&chksm=c03b4661f74ccf77e5cca1996771726b6c66161debb88f77f4c1aefe7fa34432bb15ba7ae339&scene=21#wechat_redirect">你不需要微服务</a>》</li><li>《<a href="http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&mid=2247552340&idx=1&sn=fd7cffa7bdb00a96ff26a43d5e7c8c51&chksm=c03b4747f74cce51f00847fc8e87174c931425bf5ce314c80ce51f383b6c1d94a201185aa121&scene=21#wechat_redirect">Istio vs. Linkerd vs. Consul：服务网格该怎么选择？</a>》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;超文本传输协议的第三个主要版本，即 HTTP&amp;#x2F;3， 于 2022 年 6 月 6 日被采纳为 IETF （互联网工程任务组）[1]标准。可能有人也会像我一样，在得知此消息[2]后会感到非常高兴，当然，大家可能对此也不太关心，毕竟现在的网络运行良好，没必要关注新的变</summary>
      
    
    
    
    <category term="网络" scheme="http://ai.mak.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>保证接口数据安全的10种方案</title>
    <link href="http://ai.mak.cn/2022/08/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%9A%8410%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>http://ai.mak.cn/2022/08/17/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%9A%8410%E7%A7%8D%E6%96%B9%E6%A1%88/</id>
    <published>2022-08-16T16:00:00.000Z</published>
    <updated>2023-01-16T01:17:39.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源于捡田螺的小男孩</p></blockquote><ul><li>前言</li><li>1 数据加密，防止报文明文传输</li><li>2 据加签验签</li><li>3 token授权认证机制</li><li>4 时间戳timestamp超时机制</li><li>5 timestamp+nonce方案防止重放攻击</li><li>6 限流机制</li><li>7 黑名单机制</li><li>8 白名单机制</li><li>9 数据脱敏掩码</li><li>10 数据参数一些合法性校验。</li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们日常开发中，如何保证接口数据的安全性呢？个人觉得，接口数据安全的保证过程，主要体现在这几个方面：一个就是<strong>数据传输</strong> 过程中的安全，还有就是数据到达服务端，如何<strong>识别数据</strong> ，最后一点就是<strong>数据存储的安全性</strong> 。今天跟大家聊聊保证接口数据安全的10个方案。</p><h2 id="1-数据加密，防止报文明文传输。"><a href="#1-数据加密，防止报文明文传输。" class="headerlink" title="1 数据加密，防止报文明文传输。"></a>1 数据加密，防止报文明文传输。</h2><p>我们都知道，数据在网络传输过程中，很容易被抓包。如果使用的是http协议，因为它是明文传输的，用户的数据就很容易被别人获取。所以需要对数据加密。</p><h4 id="1-1-数据如何加密呢？"><a href="#1-1-数据如何加密呢？" class="headerlink" title="1.1 数据如何加密呢？"></a>1.1 数据如何加密呢？</h4><p>常见的实现方式，就是对<strong>关键字段</strong> 加密。比如，你一个登录的接口，你可以对<strong>密码</strong> 加密。一般用什么加密算法呢？简单点可以使用<strong>对称加密算法</strong> （如<code>AES</code>）来加解密，或者哈希算法处理（如<code>MD5</code>）。</p><blockquote><p>什么是<strong>对称加密</strong> ：加密和解密使用相同密钥的加密算法。</p></blockquote><p><img src="https://aimak.cn/blog_img/java/api_safe/aes.png"></p><blockquote><p><strong>非对称加密</strong> ：非对称加密算法需要两个密钥（公开密钥和私有密钥）。<strong>公钥与私钥是成对存在的</strong> ，如果用公钥对数据进行加密，只有对应的私钥才能解密。</p></blockquote><p>更安全的做法，就是用<strong>非对称加密算法</strong> （如<code>RSA</code>或者<code>SM2</code>），公钥加密，私钥解密。</p><p><img src="https://aimak.cn/blog_img/java/api_safe/rsa.png"></p><p>如果你想对所有字段都加密的话，一般都推荐使用<strong>https协议</strong> 。<code>https</code>其实就是在<code>http</code>和<code>tcp</code>之间添加一层加密层SSL。</p><h4 id="1-2-小伙伴们，是否还记得https的原理呢？"><a href="#1-2-小伙伴们，是否还记得https的原理呢？" class="headerlink" title="1.2 小伙伴们，是否还记得https的原理呢？"></a>1.2 小伙伴们，是否还记得https的原理呢？</h4><p>面试也经常问的，如下：</p><p><img src="https://aimak.cn/blog_img/java/api_safe/https.png"></p><ol><li>客户端发起Https请求，连接到服务器的443端口。</li><li>服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li><li>服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li><li>客户端将公钥加密后的密钥发送到服务器。</li><li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li><li>服务器将加密后的密文返回到客户端。</li><li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li></ol><p>日常业务呢，数据传输加密这块的话，用<strong>https</strong> 就可以啦，如果安全性要求较高的，比如登陆注册这些，需要传输密码的，密码就可以使用<code>RSA</code>等非对称加密算法，对密码加密。如果你的业务，安全性要求很高，你可以模拟https这个流程，对报文，再做一次加解密。</p><h2 id="2-数据加签验签"><a href="#2-数据加签验签" class="headerlink" title="2 数据加签验签"></a>2 数据加签验签</h2><p>数据报文加签验签，是<strong>保证数据传输安全的常用手段</strong> ，它可以保证数据在<strong>传输过程中不被篡改</strong> 。以前我做的<strong>企业转账系统</strong> ，就用了加签验签。</p><h4 id="2-1-什么是加签验签呢？"><a href="#2-1-什么是加签验签呢？" class="headerlink" title="2.1 什么是加签验签呢？"></a>2.1 什么是加签验签呢？</h4><ul><li><strong>数据加签</strong> ：用Hash算法（如<code>MD5，或者SHA-256</code>）把原始请求参数生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名<code>sign</code>（这个过程就是<strong>加签</strong> ）。通常来说呢，请求方会把<strong>数字签名和报文原文</strong> 一并发送给接收方。</li></ul><p><img src="https://aimak.cn/blog_img/java/api_safe/hash.png"></p><ul><li><strong>验签</strong> ：接收方拿到原始报文和数字签名（<code>sign</code>）后，用<strong>同一个Hash算法</strong> (比如都用MD5)从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。</li></ul><p><img src="https://aimak.cn/blog_img/java/api_safe/hash2.png"></p><p>其实<strong>加签</strong> ，我的理解的话，就是把请求参数，按照一定规则，利用<code>hash</code>算法+加密算法生成一个<strong>唯一标签</strong> <code>sign</code>。<strong>验签的话</strong> ，就是把请求参数按照相同的规则处理，再用相同的<code>hash</code>算法，和对应的密钥解密处理，以对比这个签名是否一致。</p><blockquote><p>再举个例子，有些小伙伴是这么实现的，将所有非空参数（包含一个包<code>AccessKey</code>，<strong>唯一的开发者标识</strong> ）按照升序，然后再拼接个<code>SecretKey</code>（这个仅作本地加密使用，不参与网络传输，它只是用作签名里面的），得到一个<code>stringSignTemp</code>的值，最后用MD5运算，得到<code>sign</code>。</p><p>服务端收到报文后，会校验，只有拥有合法的身份<code>AccessKey</code>和签名<code>Sign</code>正确，才放行。这样就解决了身份验证和参数篡改问题，如果请求参数被劫持，由于劫持者获取不到<code>SecretKey</code>（仅作本地加密使用，不参与网络传输），他就无法伪造合法的请求啦</p></blockquote><h4 id="2-2-有了https等加密数据，为什么还需要加签验签"><a href="#2-2-有了https等加密数据，为什么还需要加签验签" class="headerlink" title="2.2 有了https等加密数据，为什么还需要加签验签"></a>2.2 有了https等加密数据，为什么还需要加签验签</h4><p>有些小伙伴可能有疑问，加签验签主要是防止数据在传输过程中被篡改，那如果都用了<code>https</code>下协议加密数据了，为什么还会被篡改呢？为什么还需要加签验签呢？</p><blockquote><p>数据在传输过程中被加密了，理论上，即使被抓包，数据也不会被篡改。但是<strong>https不是绝对安全</strong> 的哦，还有一个点：<code>https</code>加密的部分只是在外网，然后有很多服务是内网相互跳转的，加签也可以在<strong>这里保证不被中间人篡改</strong> ，所以一般转账类安全性要求高的接口开发，都需要<strong>加签验签</strong></p></blockquote><h2 id="3-token授权认证机制"><a href="#3-token授权认证机制" class="headerlink" title="3 token授权认证机制"></a>3 token授权认证机制</h2><p>日常开发中，我们的网站或者APP，都是需要<strong>用户登录</strong> 的。那么如果是<strong>非登录接口</strong> ，是如何确保安全，如何确认用户身份的呢？可以使用<strong>token</strong> 授权机制。</p><h4 id="3-1-token的授权认证方案"><a href="#3-1-token的授权认证方案" class="headerlink" title="3.1 token的授权认证方案"></a>3.1 token的授权认证方案</h4><p><strong>token的授权认证方案</strong> ：用户在客户端输入用户名和密码，点击登录后，服务器会校验密码成功，会给客户端返回一个唯一值<code>token</code>，并将<code>token</code>以键值对的形式存放在缓存（一般是Redis）中。后续客户端对需要授权模块的所有操作都要带上这个<code>token</code>，服务器端接收到请求后，先进行<code>token</code>验证，如果<code>token</code>存在，才表明是合法请求。</p><p><strong>token登录授权流程图如下：</strong></p><p><img src="https://aimak.cn/blog_img/java/api_safe/token.png"></p><ol><li>用户输入用户名和密码，发起登录请求</li><li>服务端校验密码，如果校验通过，生成一个全局唯一的<code>token</code>。</li><li>将<code>token</code>存储在<code>redis</code>中，其中<code>key</code>是<code>token</code>，<code>value</code>是<code>userId</code>或者是用户信息，设置一个过期时间。</li><li>把这个<code>token</code>返回给客户端</li><li>用户发起其他业务请求时，需要带上这个<code>token</code></li><li>后台服务会统一拦截接口请求，进行<code>token</code>有效性校验，并从中获取用户信息，供后续业务逻辑使用。如果<code>token</code>不存在，说明请求无效。</li></ol><h4 id="3-2-如何保证token的安全？token被劫持呢？"><a href="#3-2-如何保证token的安全？token被劫持呢？" class="headerlink" title="3.2 如何保证token的安全？token被劫持呢？"></a>3.2 如何保证token的安全？token被劫持呢？</h4><p><strong>我们如何保证token的安全呢？</strong></p><p>比如说，我如果拿到<code>token</code>，是不是就可以调用服务器端的任何接口？可以从这几个方面出发考虑：</p><ul><li>token设置合理的有效期</li><li>使用https协议</li><li>token可以再次加密</li><li>如果访问的是敏感信息，单纯加token是不够的，通常会再配置白名单</li></ul><blockquote><p>说到token，有些小伙伴们可能会想起jwt，即（JSON Web Token），其实它也是token的一种。有兴趣的小伙伴可以去了解一下哈。</p></blockquote><h2 id="4-时间戳timestamp超时机制"><a href="#4-时间戳timestamp超时机制" class="headerlink" title="4 时间戳timestamp超时机制"></a>4 时间戳timestamp超时机制</h2><p>数据是很容易抓包的，假设我们用了<code>https</code>和加签，即使中间人抓到了数据报文，它也看不到真实数据。但是有些不法者，他根本不关心真实的数据，而是直接拿到抓取的数据包，进行恶意请求（比如<strong>DOS攻击</strong> ），以搞垮你的系统。</p><p>我们可以引入<strong>时间戳超时机制</strong> ，来保证接口安全。就是：用户每次请求都带上当前时间的时间戳<code>timestamp</code>，服务端接收到<code>timestamp</code>后，解密，验签通过后，与服务器当前时间进行比对，如果时间差大于一定时间 (比如3分钟)，则认为该请求无效。</p><h2 id="5-timestamp-nonce方案防止重放攻击"><a href="#5-timestamp-nonce方案防止重放攻击" class="headerlink" title="5 timestamp+nonce方案防止重放攻击"></a>5 timestamp+nonce方案防止重放攻击</h2><p>时间戳超时机制也是有漏洞的，如果是在<strong>时间差内</strong> ，黑客进行的重放攻击，那就不好使了。可以使用<code>timestamp+nonce</code>方案。</p><p><code>nonce</code>指唯一的随机字符串，用来标识每个被签名的请求。我们可以将每次请求的<code>nonce</code>参数存储到一个“set集合”中，或者可以json格式存储到数据库或缓存中。每次处理HTTP请求时，首先判断该请求的<code>nonce</code>参数是否在该“集合”中，如果存在则认为是非法请求。</p><p>然而对服务器来说，永久保存<code>nonce</code>的代价是非常大的。可以结合<code>timestamp</code>来优化。因为<code>timstamp</code>参数对于超过<code>3min</code>的请求，都认为非法请求，所以我们只需要存储<code>3min</code>的<code>nonce</code>参数的“集合”即可。</p><h2 id="6-限流机制"><a href="#6-限流机制" class="headerlink" title="6 限流机制"></a>6 限流机制</h2><p>如果用户本来就是就是真实用户，他恶意频繁调用接口，想搞垮你的系统呢？这种情况就需要接入限流了。</p><p>可以使用<code>Guava</code>的<code>RateLimiter</code>单机版限流，也可以使用<code>Redis</code>分布式限流，还可以使用阿里开源组件<code>sentinel</code>限流。比如说，一分钟可以接受多少次请求。</p><h2 id="7-黑名单机制"><a href="#7-黑名单机制" class="headerlink" title="7 黑名单机制"></a>7 黑名单机制</h2><p>如果发现了真实用户恶意请求,你可以搞个黑名单机制，把该用户拉黑。一般情况，会有些竞争对手，或者不坏好意的用户，想搞你的系统的。所以，为了保证安全，一般我们的业务系统，需要有个黑名单机制。对于黑名单发起的请求，直接返回错误码好了。</p><h2 id="8-白名单机制"><a href="#8-白名单机制" class="headerlink" title="8 白名单机制"></a>8 白名单机制</h2><p>有了黑名单机制，也可以搞个白名单机制啦。以前我负责的企业转账系统，如果有外面的商户要接入我们的系统时，是需要提前申请网络白名单的。那时候运维会申请个IP网络白名单，只有白名单里面的请求，才可以访问我们的转账系统。</p><h2 id="9-数据脱敏掩码"><a href="#9-数据脱敏掩码" class="headerlink" title="9 数据脱敏掩码"></a>9 数据脱敏掩码</h2><p>对于密码，或者手机号、身份证这些敏感信息，一般都需要脱敏掩码再展示的，如果是密码，还需要加密再保存到数据库。</p><p>对于手机号、身份证信息这些，日常开发中，在日志排查时，看到的都应该是掩码的。目的就是尽量不泄漏这些用户信息，虽然能看日志的只是开发和运维，但是还是需要防一下，做掩码处理。</p><p>对于密码保存到数据库，我们肯定不能直接明文保存。最简单的也需要<code>MD5</code>处理一下再保存，<code>Spring Security</code>中的 <code>BCryptPasswordEncoder</code>也可以，它的底层是采用<code>SHA-256 +随机盐+密钥</code>对密码进行加密，而<code>SHA和MD</code>系列是一样的，都是<code>hash</code>摘要类的算法。</p><h2 id="10-数据参数一些合法性校验"><a href="#10-数据参数一些合法性校验" class="headerlink" title="10 数据参数一些合法性校验"></a>10 数据参数一些合法性校验</h2><p>接口数据的安全性保证，还需要我们的系统，有个数据合法性校验，简单来说就是<strong>参数校验</strong> ，比如身份证长度，手机号长度，是否是数字等等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章来源于捡田螺的小男孩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;1 数据加密，防止报文明文传输&lt;/li&gt;
&lt;li&gt;2 据加签验签&lt;/li&gt;
&lt;li&gt;3 token授权认证机制&lt;/li&gt;
&lt;li&gt;4 时间戳ti</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
