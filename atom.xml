<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2022-10-09T15:39:16.431Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-09T15:39:16.431Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂技" scheme="http://ai.mak.cn/categories/%E6%9D%82%E6%8A%80/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔记-王阳明</title>
    <link href="http://ai.mak.cn/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/"/>
    <id>http://ai.mak.cn/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2022-10-09T15:53:46.024Z</updated>
    
    <content type="html"><![CDATA[<p>你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-数字化转型核心</title>
    <link href="http://ai.mak.cn/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/"/>
    <id>http://ai.mak.cn/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2022-10-09T15:52:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-小程序带来了什么改变</title>
    <link href="http://ai.mak.cn/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/"/>
    <id>http://ai.mak.cn/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/</id>
    <published>2018-12-04T16:00:00.000Z</published>
    <updated>2022-10-09T15:51:49.910Z</updated>
    
    <content type="html"><![CDATA[<p>小程序带来了什么改变？</p><p>（1）用户缩短了完成操作所需的步骤</p><p>（2）开发者更容易上手，开发难度下降</p><p>（3）新的产品形态：更垂直，更细分，更社交，更具创意</p><p>（4）用户红利：基于微信的巨大流量</p><p>什么适合做小程序</p><p>1.行业</p><p>低频刚需，这一点也已经得到公认，尤其O2O</p><p>低频非刚需：工具类适合小程序</p><p>2.产品规模</p><p>功能复杂业务多：具有大量业务，比较适合小程序，往垂直化来做，如58搬家，生活缴费等。</p><p>功能简单业务多：把核心功能迁移至小程序。</p><p>功能简单业务少：可以完全移植，相对效果不会差。</p><p>功能复杂业务少：简化体验流程。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小程序带来了什么改变？&lt;/p&gt;
&lt;p&gt;（1）用户缩短了完成操作所需的步骤&lt;/p&gt;
&lt;p&gt;（2）开发者更容易上手，开发难度下降&lt;/p&gt;
&lt;p&gt;（3）新的产品形态：更垂直，更细分，更社交，更具创意&lt;/p&gt;
&lt;p&gt;（4）用户红利：基于微信的巨大流量&lt;/p&gt;
&lt;p&gt;什么适合做小程序</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-互联网思维～</title>
    <link href="http://ai.mak.cn/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/"/>
    <id>http://ai.mak.cn/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2022-10-09T15:51:35.494Z</updated>
    
    <content type="html"><![CDATA[<p>前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述，那么，你应该还在每天挤地铁。”</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-张子选《藏地诗篇》</title>
    <link href="http://ai.mak.cn/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/"/>
    <id>http://ai.mak.cn/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:37.470Z</updated>
    
    <content type="html"><![CDATA[<p>向鱼问水，向马问路</p><p>向神佛打听我一生的出处</p><p>而我呀</p><p>我是疼在谁心头的一抔尘土</p><p>一尊佛祖，两世糊涂</p><p>来世的你呀，如何把今生的我一眼认出</p><p>——张子选《藏地诗篇》</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;向鱼问水，向马问路&lt;/p&gt;
&lt;p&gt;向神佛打听我一生的出处&lt;/p&gt;
&lt;p&gt;而我呀&lt;/p&gt;
&lt;p&gt;我是疼在谁心头的一抔尘土&lt;/p&gt;
&lt;p&gt;一尊佛祖，两世糊涂&lt;/p&gt;
&lt;p&gt;来世的你呀，如何把今生的我一眼认出&lt;/p&gt;
&lt;p&gt;——张子选《藏地诗篇》&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-刻意练习</title>
    <link href="http://ai.mak.cn/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/"/>
    <id>http://ai.mak.cn/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:19.178Z</updated>
    
    <content type="html"><![CDATA[<p>1、有目的的练习特点</p><p>定义明确的具体目标，可以有效地用于引导你的练习</p><p>有目的的练习是专注的</p><p>有目的的练习包含反馈</p><p>有目的的练习需要走出舒适区</p><p>总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。还要想办法保持你的动机。</p><p>2、刻意练习的特点</p><p>刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能</p><p>刻意练习发生在舒适区之外，要求不断地尝试那些刚好超出他当前能力范围的事物，需要人们付出最大限度的努力。</p><p>刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进</p><p>刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动</p><p>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。</p><p>如何运用刻意练习原则</p><p>在实践中，这往往归结为带有几个额外步骤的有目的的练习：</p><p>首先辨别杰出人物</p><p>然后推测是什么使他们变得如此杰出</p><p>接着再提出训练方法，这些方法使你也能像他们那样表现卓越</p><p>在自己的工作，仔细思考杰出的表现具有哪些特点，并尝试采用一些方法来度量，即使在你度量时一定存在着某种程度的主观意识也无妨。然后，寻找你所在行业或领域中评分最高、你认为对杰出表现十分关键的人。要记住，理想的情况是找到客观的、可复制的测量指标，以便前后一致地从普通从业者之中挑选出最优异的从业者。</p><p>运用刻意练习原则的人都面临一个重大挑战，那便是：要准确地判断最杰出人物做了些什么，使得他们在普通人中间“鹤立鸡群”。 在IT互联网行业，牛人很多。大多数牛人都有着做出牛逼产品的经历，比如微信之父张小龙、小米创始人雷军。是什么促使他们做出牛逼的产品？到底是什么是他们变得如此杰出？这几个问题其实是不好找到客观的、可复制的测量指标。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、有目的的练习特点&lt;/p&gt;
&lt;p&gt;定义明确的具体目标，可以有效地用于引导你的练习&lt;/p&gt;
&lt;p&gt;有目的的练习是专注的&lt;/p&gt;
&lt;p&gt;有目的的练习包含反馈&lt;/p&gt;
&lt;p&gt;有目的的练习需要走出舒适区&lt;/p&gt;
&lt;p&gt;总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-数据化：一切皆可“量化”</title>
    <link href="http://ai.mak.cn/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/"/>
    <id>http://ai.mak.cn/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/</id>
    <published>2018-11-28T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:00.945Z</updated>
    
    <content type="html"><![CDATA[<p>数据化：一切皆可“量化”</p><p>莫里的导航图，大数据的最早实践之一</p><p>许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。</p><p>数据从最不可能的地方提取出来</p><p>大数据的核心就是挖掘出庞大的数据库独有的价值</p><p>数据化，不是数字化</p><p>数据化，这是指一种把现象转变可制表分析的量化形式的过程。</p><p>量化一切，数据化的核心</p><p>计量和记录一起促成了数据的诞生，它们是数据化最早的根基</p><p>数字化带来了数据化，但是数字化无法取代数据化</p><p>当文字成为数据</p><p>但文字变成数据，它就大显神通了——人可以用之阅读，机器也可以用之分析。</p><p>当方位变成数据</p><p>“现实挖掘”这里指的是通过处理大量来自手机的数据，发现和预测人类行为。</p><p>位置信息一被数据化，新的用途就犹如雨后春笋般涌现出来，而新价值也会随之不断催生。</p><p>当沟通变成数据</p><p>Twitter情绪数据化</p><p>社交图谱  FICO</p><p>twitter情感分析以获得顾客反馈意见的汇总或对营销获得的效果进行判断</p><p>世间万物的数据化</p><p>只要一点想象，万千事物就能转化为数据形式，并一直带给我们惊喜。</p><p>物联网只是一种典型的数据化手段</p><p>有了大数据的帮助，我们不会再将世界看作是一连串wim认为或是自然或是社会现象的时间，我们会意识到本质上世界是由信息构成的。</p><p>将世界看作信息，看作可以理解的数据还有，为我们提供了一个从未有过的审视现实的视角。它是一种可以渗透到所有生活领域的世界观。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据化：一切皆可“量化”&lt;/p&gt;
&lt;p&gt;莫里的导航图，大数据的最早实践之一&lt;/p&gt;
&lt;p&gt;许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。&lt;/p&gt;
&lt;p&gt;数据从最不可能的地方提取出来&lt;/p&gt;
&lt;p&gt;大数据的核心就是挖掘出</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-更多，更杂，更好</title>
    <link href="http://ai.mak.cn/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/"/>
    <id>http://ai.mak.cn/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2022-10-09T15:49:39.261Z</updated>
    
    <content type="html"><![CDATA[<p>更多：不是随机样本，而是全体数据</p><p>样本&#x3D;总体</p><p>更杂：不是精确性，而是混杂性</p><p>允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。</p><p>大数据抵消了错误数据带来的不精确：</p><p>更好：不是因果关系，而是相关关系</p><p>建立在相关关系分析法上的预测是大数据的核心，我们通过大数据分析得到的是“是什么”（相关关系），而得不出“为什么”（因果关系）的结论。</p><p>通过大数据分析，寻找事物、数据之间的关联性来分析现象，而不是揭示其内部机制。往往通过大数据得出的结论只是一个可能性预测，而不知道其背后的原因。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;更多：不是随机样本，而是全体数据&lt;/p&gt;
&lt;p&gt;样本&amp;#x3D;总体&lt;/p&gt;
&lt;p&gt;更杂：不是精确性，而是混杂性&lt;/p&gt;
&lt;p&gt;允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。&lt;/p&gt;
&lt;p&gt;大数据抵消了错误数据带来的不精确：&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java代码优化总结</title>
    <link href="http://ai.mak.cn/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2022-08-05T17:37:13.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java问题排查工具单"><a href="#java问题排查工具单" class="headerlink" title="java问题排查工具单"></a>java问题排查工具单</h2><p>转自 作者：红魔七号<br>链接：<a href="https://yq.aliyun.com/articles/69520?utm_content=m_10360">https://yq.aliyun.com/articles/69520?utm_content=m_10360</a></p><p><em>摘要：</em> # 我的问题排查工具箱 ## 前言 平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。 闲话不多说，开搞。 ## Linux命令类 ###tail 最常用的tail -f tail -3</p><h1 id="我的问题排查工具箱"><a href="#我的问题排查工具箱" class="headerlink" title="我的问题排查工具箱"></a>我的问题排查工具箱</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。</p><p>闲话不多说，开搞。</p><h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>1 基础命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $4,$6&#125;&#x27; f.txt</span><br><span class="line">awk &#x27;&#123;print NR,$0&#125;&#x27; f.txt cpf.txt    </span><br><span class="line">awk &#x27;&#123;print FNR,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FNR,FILENAME,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&#x27; f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: &#x27;&#123;print $1,$2,$3,$4&#125;&#x27;</span><br></pre></td></tr></table></figure><p>2 匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/ldb/ &#123;print&#125;&#x27; f.txt   #匹配ldb</span><br><span class="line">awk &#x27;!/ldb/ &#123;print&#125;&#x27; f.txt  #不匹配ldb</span><br><span class="line">awk &#x27;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&#x27; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#x27;$5 ~ /ldb/ &#123;print&#125;&#x27; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find /usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure><h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgm -A -f vm-shopbase &#x27;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#x27;</span><br></pre></td></tr></table></figure><h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar  ##可以查看最近一天的各项指标</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc25b8f22e53818d5576c5d00dd52618.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar --live ##可以查看实时指标，默认五秒一刷</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b68910c5416fd85a99a49a092fc9ffbb.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aafdbfb515b817a2aceb270d1d470c19.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tsar --mem</span><br><span class="line">tsar --load</span><br><span class="line">tsar --cpu</span><br><span class="line">##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/cb46ef4e374e1502d3b672d04d48099a.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/079f3fa722bfa1991557469eb97c7273.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6dd77351ad4d1ad84cdbfba20c9d4c29.png" alt="screenshot.png"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|awk  &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">#查看当前连接，注意close_wait偏高的情况，比如如下</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/250a027410775cf5990d0db6e87ba927.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/639811da529750064e2f70867d6234e0.png" alt="screenshot.png"></p><h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ol><li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</p><p>@OnMethod(clazz &#x3D; “java.util.ArrayList”, method&#x3D;”add”, location &#x3D; @Location(value &#x3D; Kind.CALL, clazz &#x3D; “&#x2F;.<em>&#x2F;“, method &#x3D; “&#x2F;.</em>&#x2F;“))<br>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123;</span><br><span class="line">    println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod  + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance));</span><br><span class="line">    jstack();</span><br><span class="line">    println();</span><br><span class="line">    println(&quot;===========================&quot;);</span><br><span class="line">    println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><p>监控当前服务方法被调用时返回的值以及请求的参数</p><p>@OnMethod(clazz &#x3D; “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method&#x3D;”nav”, location &#x3D; @Location(value &#x3D; Kind.RETURN))<br>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result);</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。<br><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></p><p>注意:</p><ol><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ol><h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p><p><code>trace class method</code>: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:<a href="http://www.atatech.org/articles/52947">http://www.atatech.org/articles/52947</a>。</p><p>其他功能部分和btrace重合，可以选用，感兴趣的请移步。<br><a href="http://www.atatech.org/articles/26247">http://www.atatech.org/articles/26247</a></p><p>另外相关联的是arthas，他是基于Greys的，感兴趣的再移步<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc">http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc</a></p><h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>可以看看我之前写的一篇javOSize的简介<a href="http://www.atatech.org/articles/38546">http://www.atatech.org/articles/38546</a><br>官网请移步<a href="http://www.javosize.com/">http://www.javosize.com/</a></p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<br>官网请移步<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<br>详情请移步<a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p><h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛<br>详情请移步<a href="http://zprofiler.alibaba-inc.com/">zprofiler.alibaba-inc.com</a></p><h2 id="java三板斧，噢不对，是七把"><a href="#java三板斧，噢不对，是七把" class="headerlink" title="java三板斧，噢不对，是七把"></a>java三板斧，噢不对，是七把</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>我只用一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/jps -mlvV</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b156cb53250bf5f91811900c2575a91.png" alt="screenshot.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>普通用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc501bf424b3d2884e6ec118d14554a3.png" alt="screenshot.png"></p><p>native+java栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4c59dc2971f3d8778e1898d64266266a.png" alt="screenshot.png"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc879145e2994e9a09327407ed88382c.png" alt="screenshot.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p><p>1.查看堆的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/00d9eaef08cdb51263d202d26795036b.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3c08bccf81fef8b7bcae2b321012b503.png" alt="screenshot.png"></p><p>2.dump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</span><br></pre></td></tr></table></figure><p>3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/500ec6709fcd03a4fca2679615d54522.png" alt="screenshot.png"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/05743916a9187535c202fb410d30d50d.png" alt="screenshot.png"></p><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是&#x2F;opt&#x2F;taobao&#x2F;java&#x2F;，远程调试端口是8000.那么<br><code>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000</code>.</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/16332fcd45b20137bffc7a3b9a88b0f1.png" alt="screenshot.png"></p><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<br>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html</a></p><h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</span><br></pre></td></tr></table></figure><p>更详细的可见R大此贴<br><a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/356c11885a95e28736a605aecdc8083e.png" alt="screenshot.png"></p><h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p><h2 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h2><ol><li><p>你的类到底是从哪个文件加载进来的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br><span class="line">结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar]</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>应用挂了输出dump文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof</span><br><span class="line">集团的vm参数里边基本都有这个选项</span><br></pre></td></tr></table></figure></li></ol><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p><h3 id="mvn-dependency-tree-gt-x2F-dependency-txt"><a href="#mvn-dependency-tree-gt-x2F-dependency-txt" class="headerlink" title="mvn dependency:tree &gt; ~&#x2F;dependency.txt"></a>mvn dependency:tree &gt; ~&#x2F;dependency.txt</h3><p>打出所有依赖</p><h3 id="mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId"><a href="#mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId" class="headerlink" title="mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId"></a>mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId</h3><p>只打出指定groupId和artifactId的依赖关系</p><h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="greys-sc"><a href="#greys-sc" class="headerlink" title="greys:sc"></a>greys:sc</h3><p>greys的sc命令也能清晰的看到当前类是从哪里加载过来的</p><h3 id="tomcat-classloader-locate"><a href="#tomcat-classloader-locate" class="headerlink" title="tomcat-classloader-locate"></a>tomcat-classloader-locate</h3><p>通过以下url可以获知当前类是从哪里加载的<br>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a></p><h2 id="ALI-TOMCAT带给我们的惊喜-感谢-务观"><a href="#ALI-TOMCAT带给我们的惊喜-感谢-务观" class="headerlink" title="ALI-TOMCAT带给我们的惊喜(感谢@务观)"></a>ALI-TOMCAT带给我们的惊喜(感谢@务观)</h2><ol><li><p>列出容器加载的jar列表</p><p>curl <a href="http://localhost:8006/classloader/jars">http://localhost:8006/classloader/jars</a></p></li><li><p>列出当前当当前类加载的实际jar包位置，解决类冲突时有用</p><p>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4568b16d3db0daf98e852412b830f1a8.png" alt="screenshot.png"></p></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h3><p><a href="http://www.atatech.org/articles/33317">http://www.atatech.org/articles/33317</a></p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg|grep -i kill|less</span><br></pre></td></tr></table></figure><p>去找关键字oom_killer。找到的结果类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0</span><br><span class="line">[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 </span><br><span class="line">[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 </span><br><span class="line">[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span><br><span class="line">[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span><br></pre></td></tr></table></figure><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式:<br>log实际时间&#x3D;格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1970-01-01 UTC `echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&#x27; &#x27;)+12288812.926194&quot;|bc ` seconds&quot;</span><br></pre></td></tr></table></figure><p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步<a href="http://ifeve.com/guava-ratelimiter/">http://ifeve.com/guava-ratelimiter/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java问题排查工具单&quot;&gt;&lt;a href=&quot;#java问题排查工具单&quot; class=&quot;headerlink&quot; title=&quot;java问题排查工具单&quot;&gt;&lt;/a&gt;java问题排查工具单&lt;/h2&gt;&lt;p&gt;转自 作者：红魔七号&lt;br&gt;链接：&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔记-运营该如何被定义和理解</title>
    <link href="http://ai.mak.cn/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/"/>
    <id>http://ai.mak.cn/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/</id>
    <published>2018-11-09T16:00:00.000Z</published>
    <updated>2022-10-09T15:49:09.566Z</updated>
    
    <content type="html"><![CDATA[<p>运营该如何被定义和理解<br>1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段</p><p>2.运营工作的流程：<br>1）制定策略：根据不同的产品形态及数据变化制定不用的策略</p><p>2）分解指标，规划工作：对目标进行拆解，向内向外的资源争取及分配，制定具体的工作计划</p><p>3）执行落地，达成目标：通过文案、活动、用户维系等具体运营手段来达成我们的目标</p><p>4）监测数据、调整方向：收集、分析数据及用户反馈，评估运营工作调整新的运营策略</p><p>3.运营的四个关键性思维</p><p>1.流程化思维：一个优秀的运营和一个普通人之间存在的一个核心差别，就是优秀的运营拿到一个问题后，会回归流程，先把整个问题流程梳理出来，然后再从流程中去寻找潜在的解决方案。“先有流程，再有解决方案”这一点，不止对运营，对于产品来说也是一样的。</p><p>2.精细化思维：运营做久了会发现，优秀的运营，很多时候是通过大量的细节和琐碎事务堆积出来一个神奇的产品。这就需要运营具备很强的精细化思维和精细化管理，必须要能够把自己关注的一个问题拆解为无数细小的执行细节，并且能够做到对于所有细节的掌控力。</p><p>3.杠杆思维：好的运营是有层次感的，需要先做好一件事情，再以这件事为一个核心杠杆，去撬动更多的事情和成果发生，比如先服务好一批种子用户，给他们制造大量的超出他们预期的体验，以此为杠杆，撬动他们帮我们宣传。</p><p>4.生态化思维：所谓生态，其实就是一个所有角色在其中都可以互为价值、和谐共存、共同驱动器发展和生存的一个大环境，比如一个好几百人的微信群，一个社区。而能否成功搭建起来生态，最重要的，就是你能够梳理清楚并理解一个生态间的各种价值关系。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运营该如何被定义和理解&lt;br&gt;1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段&lt;/p&gt;
&lt;p&gt;2.运营工作的流程：&lt;br&gt;1）制定策略：根据不同的产品形态及数据变化制定不用的策略&lt;/p&gt;
&lt;p&gt;2）分解指标，规划工作：对目标进行拆解，向内向外的资</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java代码优化总结</title>
    <link href="http://ai.mak.cn/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/"/>
    <id>http://ai.mak.cn/2018/11/04/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-1/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2022-08-05T17:37:13.266Z</updated>
    
    <content type="html"><![CDATA[<p>来源：王韵菲 </p><p><a href="http://www.evget.com/article/2015/11/16/22990.html">www.evget.com/article/2015/11/16/22990.html</a></p><p>本文中，小编搜集了7个最有影响的衡量标注，让你可以不依赖日志文件来了解应用程序。现在，让我们看看这些性能指标，并了解如何查看并收集它们：</p><p><strong>1.响应时间和吞吐量</strong></p><p>根据应用程序的响应时间可以知道程序完成传输数据所用的时间。也可以从HTTP请求级别，或者成为数据库级别来看。对那些缓慢的查询你需要做一些优化来缩短时间。吞吐量是另一个角度衡量传输数据的指标，是指单位时间内系统处理的客户请求的数量。</p><p>我们可以使用APMs（例如New Relic或AppDynamics）来衡量这些指标。使用这些工具，你可以在主报告仪表板中将平均响应时间与昨天的甚至上周的直接进行对比。这有助于我们观察新的部署是否会影响到我们的应用程序。你可以看到网络传输的百分比，测量HTTP完成请求需要多长时间。</p><p>推荐工具：</p><ul><li>AppDynamics</li><li>New Relic</li><li>Ruxit</li></ul><p>New Relic报告：Web传输百分比和吞吐量</p><p><strong>2.平均负载</strong></p><p>第二个应用广泛的指标是平均负载。我们习惯上会把平均负载分为这三步测量，分别是第5分钟、第15分钟和最后1分钟。要保证数量低于机器的内核数。一旦超过内核数，机器就会运行在压力状态下。</p><p>除了简单测量CPU使用率，还需要关注每个内核的队列中有多少进程。在内核使用率都是100%的情况下，队列中只有1个任务和有6个任务有很大不同。因此，平均负载不能只考虑CPU使用率。</p><p>推荐工具：</p><ul><li>htop</li></ul><p><strong>3.错误率</strong></p><p>大多数开发人员判断错误率是根据HTTP传输总失败百分比。但是他们忽略了一个更深层的东西：特定传输的错误率。这直接影响到您应用程序的运行状况。这可以显示出代码方法的错误以及错误或异常出现的次数。</p><p>但单纯的错误率数据对我们没有多大帮助。最重要的是我们要找到它们的根源并解决问题。随着Takipi的运行，我们要在日志文件中需找线索。你可以找到所有关于服务器状态的信息，包括堆栈跟踪、源代码和变量值。</p><p>推荐工具：</p><ul><li>Takipi</li></ul><p><strong>4.GC率和暂停时间</strong></p><p>异常行为垃圾收集器应用程序的吞吐量和响应时间采取深潜的主要原因之一。了解GC暂停频率和持续时间的关键是分析GC日志文件。要分析它们，你需要收集GC日志和JVM参数。你要注意观察不同指标之间的数据是如何相互影响的。</p><p>推荐工具：</p><ul><li>jClarity Censum</li><li>GCViewer</li></ul><p><strong>5.业务指标</strong></p><p>应用程序的性能不完全取决于响应时间和错误率。业务指标也是一方面，例如收益、用户数。</p><p>推荐工具：</p><ul><li>Grafana</li><li>The ELK stack</li><li>Datadog</li><li>Librato</li></ul><p><strong>6.正常运行时间和服务运行状态</strong></p><p>这一指标奠定了整个应用程序性能的基础。不仅可以当做一个提醒指标，也可以让你定义一段时间内的SKA。我们可以使用Pingdom的servlet功能进行运行状态检查。我们可以查到应用程序的所有传输，包括数据库和S3。</p><p>推荐工具：</p><ul><li>Pingdom</li></ul><p><strong>7.日志大小</strong></p><p>日志有一个缺点，它是一直在增加的。当您的服务器启动塞满了垃圾，一切都慢下来。因此，我们需要密切的关注日志大小。</p><p>目前通常的解决办法是使用logstash划分使用日志，并将它们发送并存储在Splunk、ELK或其他的日志管理工具中。</p><p>推荐工具：</p><ul><li>Splunk</li><li>Sumo Logic</li><li>Loggly</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源：王韵菲 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.evget.com/article/2015/11/16/22990.html&quot;&gt;www.evget.com/article/2015/11/16/22990.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文中，小编</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>摘要-任何商业模式都来源于用户需求</title>
    <link href="http://ai.mak.cn/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/"/>
    <id>http://ai.mak.cn/2018/10/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01029/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2022-10-09T15:48:55.596Z</updated>
    
    <content type="html"><![CDATA[<p>任何商业模式都来源于用户需求～</p><p>用户需求特点:更快，更多，更便宜，更好玩<br>需求处理:发现，分析，描述<br>产品设计步骤:<br>产品决策:需求是否全面，流程是否打的通，是否战略一致。<br>产品功能设计:基本功能，核心功能<br>用户体验原则:不要强迫用户，不要让用户思考，用户易操作，不破坏用户原则，超出用户预期。</p><p>网络运营<br>网络运营模型:来源量，转化率，活跃度，留存率<br>周期:种子期，爆发期，平台期<br>网络推广:用户互导，资源互换，购买流量</p><p>网络运营总结：<br>1 种子期是产品最难的阶段，留存率是关键，不在乎来多少人，而在乎有多少人留下来。种子期成功，产品成功一半。<br>2 爆发期是产品成功的标志，来源量是关键，产品形成口碑影响力，能成功的产品一定有爆发期。<br>3 平台期是用户爆发增长后有意控制产品节奏的时期，活跃度是关键，重点做好系统稳定和产品用户体验。<br>4 爆发期和平台期交替出现，产品才能不断稳定增长。</p><p>互联网商业模式:<br>循环:做好的产品，吸引用户，产生收入<br>形成比由之路:创造好产品 ，获取海量用户，引导用户消费。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何商业模式都来源于用户需求～&lt;/p&gt;
&lt;p&gt;用户需求特点:更快，更多，更便宜，更好玩&lt;br&gt;需求处理:发现，分析，描述&lt;br&gt;产品设计步骤:&lt;br&gt;产品决策:需求是否全面，流程是否打的通，是否战略一致。&lt;br&gt;产品功能设计:基本功能，核心功能&lt;br&gt;用户体验原则:不要强迫</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>摘要-企业文化三要素</title>
    <link href="http://ai.mak.cn/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/"/>
    <id>http://ai.mak.cn/2018/10/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01028/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2022-10-09T15:48:24.367Z</updated>
    
    <content type="html"><![CDATA[<p>企业文化三要素：</p><p>赋予员工使命：激发员工主人翁意识，从全人类层面考虑问题，打造使命的不可逾越性；</p><p>保障公司透明度：信息共享，给予员工充分信任，会议形成记录，达到有效沟通</p><p>保障员工发声权利：高层权力下放，员工拥有话语权，培养员工独立思考</p><p>谷歌如何招聘人才：</p><p>人才原则：慢工招人才，只招聘比自己优秀的人才</p><p>招聘流程：谷歌求职者调查测试，下属面试，横向面试</p><p>评估工具：采用qDroid, 多人多角度多流程评估面试者</p><p>如何重新定义团队：</p><p>打造“小而美”团队，消除内部地位象征，依据数据做决策，自我职业规划，关注优劣两极员工，保持高期待和高收益；</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;企业文化三要素：&lt;/p&gt;
&lt;p&gt;赋予员工使命：激发员工主人翁意识，从全人类层面考虑问题，打造使命的不可逾越性；&lt;/p&gt;
&lt;p&gt;保障公司透明度：信息共享，给予员工充分信任，会议形成记录，达到有效沟通&lt;/p&gt;
&lt;p&gt;保障员工发声权利：高层权力下放，员工拥有话语权，培养员工独立思</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly 的未来：将逐渐解锁整个“技能树”</title>
    <link href="http://ai.mak.cn/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/"/>
    <id>http://ai.mak.cn/2018/10/25/%E5%89%8D%E7%AB%AF/%20WebAssembly%20%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A%E5%B0%86%E9%80%90%E6%B8%90%E8%A7%A3%E9%94%81%E6%95%B4%E4%B8%AA%E2%80%9C%E6%8A%80%E8%83%BD%E6%A0%91%E2%80%9D/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2022-08-05T17:37:13.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly-的未来：将逐渐解锁整个“技能树”"><a href="#WebAssembly-的未来：将逐渐解锁整个“技能树”" class="headerlink" title="WebAssembly 的未来：将逐渐解锁整个“技能树”"></a>WebAssembly 的未来：将逐渐解锁整个“技能树”</h1><ul><li><a href="https://www.oschina.net/news/101159/the-future-of-webassembly">原文</a></li></ul><p>WebAssembly 在2017年受到主流浏览器的支持，并发布了被 MVP 版本（Minimum Viable Product，最简可行产品）。虽然 WebAssembly 社区组致力于使 WebAssembly 向后相容，让现在开发的 WebAssembly 应用程式，仍可以在未来的浏览器中运作，但这并不代表 WebAssembly 功能已经完整，MVP 绝非最终版本。相反，WebAssembly 还将增加许多新功能，而这些新功能将从根本上颠覆 WebAssembly 所能实现的工作。</p><p>为消除人们对 WebAssembly 的误解，WebAssembly 社区组以 RPG 游戏中人物养成的“技能树”形式，对 <a href="https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/">WebAssembly 的未来发展路径</a>做了非常详细的解释。他们表示目前已经完全掌握这些技能中的前几项，后续需要慢慢解锁整个技能树。</p><p><img src="https://oscimg.oschina.net/oscnet/42ccc510cfd9d1d2670037cba32f3007d47.jpg" alt="img"></p><p>WebAssembly 在 MVP 版本阶段满足 4 个基本技能要求：编译、快速执行、压缩和线性内存分配。使用 WebAssembly 的人知道他们不想只支持 C 和 C ++，而是希望能够将许多不同的语言编译为 WebAssembly 。经 WebAssembly 编译器编译的应用需要能够快速执行，满足需求。而为了加速载入速度，WebAssembly 还需具备压缩能力，减少使用者的等待时间。另外，WebAssembly 需要有别于 JavaScript 使用内存方式，能够直接管理使用的内存，在加上安全因素的考量，WebAssembly 采用线性内存模式。</p><p><img src="https://oscimg.oschina.net/oscnet/48a0162ed0e0f848088cecfa4c9c0d6b5b4.jpg" alt="img"></p><p>社区组表示，WebAssembly 的下一个目标是平滑运行那些更重的应用程序，比如 Photoshop、Gmail 等。为确保此类应用能在浏览器中运行良好，他们需要解锁新一批的“技能”，包括支持多线程、SIMD（单指令流多数据流）、64位寻址、流式编译（在下载的同时编译 WebAssembly 文件）、分层编译器、隐式 HTTP 缓存以及一些其他改进。</p><p><img src="https://oscimg.oschina.net/oscnet/586022e01ab45f31b0d35d223ea932a8827.jpg" alt="img"></p><p>一旦以上功能全部就位，WebAssembly 又将进入下一个阶段 —— 与 JavaScript 互操作，包括 JS 和 WebAssembly 之间的快速调用、简便的数据交换、ES模块集成、工具链集成和向后兼容性。</p><p><img src="https://oscimg.oschina.net/oscnet/5d163b3cfd5ecd82788682365c270636ebe.jpg" alt="img"></p><p>此外，他们还想在 WebAssembly 中重写 JavaScript 框架的大部分内容，并使静态类型的 compile-to-js 语言可编译为 WebAssembly 。想要实现这两个目标，WebAssembly 还需要支持高阶的语言功能，包括垃圾回收、异常处理、调试以及尾调用（Tail calls）。</p><p><img src="https://oscimg.oschina.net/oscnet/c84da0e9a6a4992b6a2219bc3b6f65dc950.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly-的未来：将逐渐解锁整个“技能树”&quot;&gt;&lt;a href=&quot;#WebAssembly-的未来：将逐渐解锁整个“技能树”&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly 的未来：将逐渐解锁整个“技能树”&quot;&gt;&lt;/a&gt;We</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Java代码优化总结</title>
    <link href="http://ai.mak.cn/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/"/>
    <id>http://ai.mak.cn/2018/10/20/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-2/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2022-08-05T17:37:13.294Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率</p><p>本文的内容有些来自网络，有些来自平时工作和学习，当然这不重要，重要的是这些代码优化的细节是否真真正正地有用。那本文会保持长期更新，只要有遇到值得分享的代码优化细节，就会不定时地更新此文。</p><p><strong>代码优化细节</strong></p><p><strong>1、尽量指定类、方法的final修饰符</strong></p><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><p><strong>2、尽量重用对象</strong></p><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>3、尽可能使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><p><strong>4、及时关闭流</strong></p><p>Java编程过程中，进行数据库连接、I&#x2F;O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><p><strong>5、尽量减少对变量的重复计算</strong></p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><blockquote><p>for (int i &#x3D; 0; i &lt; list.size(); i++)</p><p>{…}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>for (int i &#x3D; 0, int length &#x3D; list.size(); i &lt; length; i++)</p><p>{…}</p></blockquote><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><p><strong>6、尽量采用懒加载的策略，即在需要的时候才创建</strong></p><p><strong>例如：</strong></p><blockquote><p>String str &#x3D; “aaa”;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>建议替换为：</strong></p><blockquote><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>　　String str &#x3D; “aaa”;</p><p>　　list.add(str);</p><p>}</p></blockquote><p><strong>7、慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p><p>根据网友们提出的意见，这一点我认为值得商榷</p><p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、</p><p><strong>HashSet等等，以StringBuilder为例：</strong></p><p>（1）StringBuilder()　　　　　　&#x2F;&#x2F; 默认分配16个字符的空间</p><p>（2）StringBuilder(int size)　　&#x2F;&#x2F; 默认分配size个字符的空间</p><p>（3）StringBuilder(String str)　&#x2F;&#x2F; 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><p><strong>10、当复制大量数据时，使用System.arraycopy()命令</strong></p><p><strong>11、乘法和除法使用移位操作</strong></p><p><strong>例如：</strong></p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val * 8;</p><p>　　b &#x3D; val &#x2F; 2;</p><p>}</p></blockquote><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： </p><blockquote><p>for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)</p><p>{</p><p>　　a &#x3D; val &lt;&lt; 3;</p><p>　　b &#x3D; val &gt;&gt; 1;</p><p>}</p></blockquote><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p><strong>12、循环内不要不断创建对象引用</strong></p><p><strong>例如：</strong></p><blockquote><p>for (int i &#x3D; 1; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    Object obj &#x3D; new Object();    </p><p>}</p></blockquote><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><blockquote><p>Object obj &#x3D; null;</p><p>for (int i &#x3D; 0; i &lt;&#x3D; count; i++)</p><p>{</p><p>​    obj &#x3D; new Object();</p><p>}</p></blockquote><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><p><strong>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p><p><strong>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p><p><strong>15、不要将数组声明为public static final</strong></p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><p><strong>16、尽量在合适的场合使用单例</strong></p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><p><strong>17、尽量避免随意使用静态变量</strong></p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><blockquote><p>public class A</p><p>{</p><p>​    private static B b &#x3D; new B();  </p><p>}</p></blockquote><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><p><strong>18、及时清除不再需要的会话</strong></p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><p><strong>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><blockquote><p>if (list instanceof RandomAccess)</p><p>{</p><p>​    for (int i &#x3D; 0; i &lt; list.size(); i++){}</p><p>}</p><p>else</p><p>{</p><p>​    Iterator&lt;?&gt; iterator &#x3D; list.iterable();</p><p>​    while (iterator.hasNext()){iterator.next()}</p><p>}</p></blockquote><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><strong>20、使用同步代码块替代同步方法</strong></p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><strong>21、将常量声明为static final，并以大写命名</strong></p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><p><strong>22、不要创建一些不使用的对象，不要导入一些不使用的类</strong></p><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><p><strong>23、程序运行过程中避免使用反射</strong></p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><strong>24、使用数据库连接池和线程池</strong></p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><p><strong>25、使用带缓冲的输入输出流进行IO操作</strong></p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><p><strong>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</strong></p><p>这个，理解ArrayList和LinkedList的原理就知道了</p><p><strong>27、不要让public方法中有太多的形参</strong></p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><p><strong>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><blockquote><p>String str &#x3D; “123”;</p><p>if (str.equals(“123”))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>String str &#x3D; “123”;</p><p>if (“123”.equals(str))</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这么做主要是可以避免空指针异常</p><p><strong>29、请知道，在java中if (i &#x3D;&#x3D; 1)和if (1 &#x3D;&#x3D; i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p><p>平时有人问，”if (i &#x3D;&#x3D; 1)”和”if (1&#x3D;&#x3D; i)”有没有区别，这就要从C&#x2F;C++讲起。</p><p>在C&#x2F;C++中，”if (i &#x3D;&#x3D; 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D;&#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>C&#x2F;C++判断”i&#x3D;&#x3D;1”不成立，所以以0表示，即false。但是如果：</p><blockquote><p>int i &#x3D; 2;</p><p>if (i &#x3D; 1)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>万一程序员一个不小心，把”if (i &#x3D;&#x3D; 1)”写成”if (i &#x3D; 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C&#x2F;C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><blockquote><p>int i &#x3D; 2;</p><p>if (1 &#x3D;&#x3D; i)</p><p>{</p><p>​    …</p><p>}</p><p>else</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>这样，即使开发者不小心写成了”1 &#x3D; i”，C&#x2F;C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C&#x2F;C++这种”if (i &#x3D; 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i &#x3D;&#x3D; 1)”和”if (1 &#x3D;&#x3D; i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><p><strong>30、不要对数组使用toString()方法</strong></p><p><strong>看一下对数组使用toString()打印出来的是什么：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int[] is &#x3D; new int[]{1, 2, 3};</p><p>​    System.out.println(is.toString());</p><p>}</p></blockquote><p><strong>结果是：</strong></p><blockquote><p>[I@18a992f</p></blockquote><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<E>重写了Object的toString()方法。</p><p><strong>32、不要对超出范围的基本数据类型做向下强制转型</strong></p><p><strong>这绝不会得到想要的结果：</strong></p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    long l &#x3D; 12345678901234L;</p><p>​    int i &#x3D; (int)l;</p><p>​    System.out.println(i);</p><p>}</p></blockquote><p><strong>我们可能期望得到其中的某几位，但是结果却是：</strong></p><blockquote><p><strong>1942892530</strong></p></blockquote><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l &#x3D; 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f &#x3D; 3.5f”</p><p>2、接下来再写一句”int ii &#x3D; l + i;”会报错，因为long + int是一个long，不能赋值给int</p><p><strong>33、公用的集合类中不使用的数据一定要及时remove掉</strong></p><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><p><strong>34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</strong></p><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    int loopTime &#x3D; 50000;</p><p>​    Integer i &#x3D; 0;</p><p>​    long startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; String.valueOf(i);</p><p>​    }    </p><p>​    System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i.toString();</p><p>​    }    </p><p>​    System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>​    startTime &#x3D; System.currentTimeMillis();</p><p>​    for (int j &#x3D; 0; j &lt; loopTime; j++)</p><p>​    {</p><p>​        String str &#x3D; i + “”;</p><p>​    }    </p><p>​    System.out.println(“i + “”：” + (System.currentTimeMillis() - startTime) + “ms”);</p><p>}</p></blockquote><p><strong>运行结果为：</strong></p><blockquote><p>String.valueOf()：11ms</p><p>Integer.toString()：5ms</p><p>i + “”：25ms</p></blockquote><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><p><strong>35、使用最有效率的方式去遍历Map</strong></p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><blockquote><p>public static void main(String[] args)</p><p>{</p><p>​    HashMap&lt;String, String&gt; hm &#x3D; new HashMap&lt;String, String&gt;();</p><p>​    hm.put(“111”, “222”);</p><p>​        </p><p>​    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet &#x3D; hm.entrySet();</p><p>​    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter &#x3D; entrySet.iterator();</p><p>​    while (iter.hasNext())</p><p>​    {</p><p>​        Map.Entry&lt;String, String&gt; entry &#x3D; iter.next();</p><p>​        System.out.println(entry.getKey() + “” + entry.getValue());</p><p>​    }</p><p>}</p></blockquote><p>如果你只是想遍历一下这个Map的key值，那用”Set<String> keySet &#x3D; hm.keySet();”会比较合适一些</p><p><strong>36、对资源的close()建议分开操作</strong></p><blockquote><p>意思是，比如我有这么一段代码：</p><p>try</p><p>{</p><p>​    XXX.close();</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p><strong>建议修改为：</strong></p><blockquote><p>try</p><p>{</p><p>​    XXX.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p><p>try</p><p>{</p><p>​    YYY.close();</p><p>}</p><p>catch (Exception e)</p><p>{</p><p>​    …</p><p>}</p></blockquote><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉</p><p><strong>后记</strong></p><p>优秀的代码来自每一点点小小的优化，关注每一个细节，不仅仅能提升程序运行效率，同样可以规避许多未知的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;代码优化的目标是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、减小代码的体积&lt;/p&gt;
&lt;p&gt;2、提高代码运行的效率&lt;/p&gt;
&lt;p&gt;本文的内容有些来自网络，有些来自平时工作和学习，当然这不重要，重要的是这些代码优化的细节是否真真正正地有用。那本文会保持长期更新，只要</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔记-新零售的本质</title>
    <link href="http://ai.mak.cn/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/"/>
    <id>http://ai.mak.cn/2018/09/16/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B00916/</id>
    <published>2018-09-15T16:00:00.000Z</published>
    <updated>2022-10-09T15:48:02.703Z</updated>
    
    <content type="html"><![CDATA[<p>零售的本质是把人和货连接在一起的场；新零售是一场效率革命。</p><p>1.新零售，是效率更高的零售</p><p>①场的效率</p><p>信息流；资金流；物流。</p><p>②人的效率</p><p>流量革命；转化率；客单价；复购率。</p><p>销售漏斗公式：销售额&#x3D;流量×转化率×客单价×复购率</p><p>该公式可以用来衡量销售额，却无法衡量销售的效率。</p><p>③货的效率</p><p>定倍率：商业世界最基础的逻辑之一，是衡量商业效率的重要指标。定倍率越低，效率越高。</p><p>未来，中国制造的趋势是：</p><p>低质高价和低质低价的商品，存活空间会越来越小，甚至被逐步淘汰；</p><p>高质低价的零售业，将迎来它的时代，而C2M（Customer-to- Manufactory，客对厂）模式是实现高质低价的一个有效手段。</p><p>2.新的商业思维</p><p>① 进化思维</p><p>② 本质思维</p><p>③ 系统思维</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;零售的本质是把人和货连接在一起的场；新零售是一场效率革命。&lt;/p&gt;
&lt;p&gt;1.新零售，是效率更高的零售&lt;/p&gt;
&lt;p&gt;①场的效率&lt;/p&gt;
&lt;p&gt;信息流；资金流；物流。&lt;/p&gt;
&lt;p&gt;②人的效率&lt;/p&gt;
&lt;p&gt;流量革命；转化率；客单价；复购率。&lt;/p&gt;
&lt;p&gt;销售漏斗公式：销</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
