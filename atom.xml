<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java  50+ Spring 常用注解</title>
    <link href="http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-12-10T16:00:00.000Z</published>
    <updated>2022-12-01T07:47:37.199Z</updated>
    
    <content type="html"><![CDATA[<p>使用注解的优势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.采用纯java代码，不在需要配置繁杂的xml文件</span><br><span class="line"></span><br><span class="line">2.在配置中也可享受面向对象带来的好处</span><br><span class="line"></span><br><span class="line">3.类型安全对重构可以提供良好的支持</span><br><span class="line"></span><br><span class="line">4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</span><br></pre></td></tr></table></figure><p><strong>Spring部分</strong></p><p><strong>1、声明bean的注解</strong></p><p>@Component 组件，没有明确的角色</p><p>@Service 在业务逻辑层使用（service层）</p><p>@Repository 在数据访问层使用（dao层）</p><p>@Controller 在展现层使用，控制器的声明（C）</p><p><strong>2、注入bean的注解</strong></p><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><p><strong>3、java配置类相关注解</strong></p><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><p><strong>4、切面（AOP）相关注解</strong></p><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><p><strong>5、@Bean的属性支持</strong></p><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</p><p>Protetype （每次调用新建一个bean）</p><p>Request （web项目中，给每个http request新建一个bean）</p><p>Session （web项目中，给每个http session新建一个bean）</p><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><p><strong>6、@Value注解</strong></p><p>@Value 为属性注入值（属性上）</p><p>支持如下方式的注入：</p><p>》注入普通字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;Michael Jackson&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入操作系统属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;systemPropreties[&#x27;os.name&#x27;]&#125;&quot;)</span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure><p>》注入表达式结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;@&#123; T(java.lang.Math).radom() * 100 &#125;&quot;)</span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><p>》注入其它bean属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入文件资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)</span><br><span class="line">Resource file</span><br></pre></td></tr></table></figure><p>》注入网站资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;http://www.baidu.com&quot;)</span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><p>》注入配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;book.name&#125;&quot;)</span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure><p>注入配置使用方法：</p><p>① 编写配置文件（test.properties）</p><p>book.name&#x3D;《三体》</p><p>② @PropertySource 加载配置文件(类上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</span><br></pre></td></tr></table></figure><p>③ 还需配置一个</p><p>PropertySourcesPlaceholderConfigurer的bean。</p><p><strong>7、环境切换</strong></p><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p><strong>8、异步相关</strong></p><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><p><strong>9、定时任务相关</strong></p><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><p><strong>10、@Enable*注解说明</strong></p><p>这些注解主要用来开启对xxx的支持。</p><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p><p>@EnableAsync 开启异步方法的支持</p><p>@EnableScheduling 开启计划任务的支持</p><p>@EnableWebMvc 开启Web MVC的配置支持</p><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableCaching 开启注解式的缓存支持</p><p><strong>11、测试相关注解</strong></p><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(&quot;SpringJUnit4ClassRunner.classs&quot;)</span><br></pre></td></tr></table></figure><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(&quot;classes=&#123;TestConfig.class&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>SpringMVC部分</strong></p><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>@RequestMapping：@RequestMapping(“&#x2F;path”)表示该控制器处理所有“&#x2F;path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>value:指定请求的实际地址，指定的地址可以是URI</p><p>Template 模式</p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等</p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application&#x2F;json,text&#x2F;html;</p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：用在方法的参数前面。</p><p>@RequestParam</p><p>String a &#x3D;request.getParameter(“a”)。</p><p>@PathVariable:路径变量。如 参数与大括号里的名字一样要相同。</p><p><strong>SpringBoot部分</strong></p><p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：</p><p>@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p><p>@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p><p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p><p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><p>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p><p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>@Import：用来导入其他配置类。</p><p>@ImportResource：用来加载xml配置文件。</p><p>@Autowired：自动导入依赖的bean</p><p>@Service：一般用于修饰service层的组件</p><p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>@Bean：用@Bean标注方法等价于XML中配置的bean。</p><p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p><p>@Inject：等价于默认的@Autowired，只是没有required属性；</p><p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。</p><p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><p>@Resource(name&#x3D;”name”,type&#x3D;”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>二、注解列表如下</p><p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p><p>@ComponentScan：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>@Configuration ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p><p>@EnableAutoConfiguration ：自动配置。</p><p>@ComponentScan ：组件扫描，可自动发现和装配一些Bean。</p><p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p><p>@RestController：注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p><p>@Autowired：自动导入。</p><p>@PathVariable：获取参数。</p><p>@JsonBackReference：解决嵌套外链问题。</p><p>@RepositoryRestResourcepublic：配合spring-boot-starter-data-rest使用。</p><p>三、JPA注解</p><p>@Entity：@Table(name&#x3D;”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p><p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p><p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p><p>@Column：如果字段名与列名相同，则可以省略。</p><p>@Id：表示该属性为主键。</p><p>@GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE,generator &#x3D; “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p><p>@SequenceGeneretor(name &#x3D; “repair_seq”, sequenceName &#x3D; “seq_repair”, allocationSize &#x3D; 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p><p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch&#x3D;FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>@JoinColumn（name&#x3D;”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p><p>五、全局异常处理</p><p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p><p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p><p>六、项目中具体配置解析和使用环境</p><p>@MappedSuperclass： 1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</p><p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p><p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p><p>@Column：</p><p>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p><p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。具体如下：</p><p> 1 name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</p><p> 2 unique属性：unique属性表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table注解中的@UniqueConstraint</p><p> 3 nullable属性：nullable属性表示该字段是否可以为null值，默认为true</p><p> 4 insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</p><p> 5 updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</p><p> 6 insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</p><p> 7 columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</p><p> 8 table属性：table属性定义了包含当前字段的表名</p><p> 9 length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</p><p> 10 precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</p><p>  具体如下：   1.double类型将在数据库中映射为double类型，precision和scale属性无效</p><p>  2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准</p><p>  3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效</p><p>  4.precision和scale属性只在BigDecimal类型中有效</p><p>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p><p>4.@Column标注也可置于属性的getter方法之前</p><p>@Getter和@Setter（Lombok）</p><p>@Setter：注解在属性上；为属性提供 setting 方法</p><p>@Getter：注解在属性上；为属性提供 getting 方法</p><p>@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法  @Setter：注解在属性上；为属性提供 setting 方法  @Getter：注解在属性上；为属性提供 getting 方法  @Log4j2 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似  @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法  @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法</p><p>@EqualsAndHashCode:默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p><p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p><p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，只能自己手写了  @NonNull：注解在属性上，如果注解了，就必须不能为Null  @val:注解在属性上，如果注解了，就是设置为final类型，可查看源码的注释知道</p><p>当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</p><p>@javax.persistence.PostLoad：加载后。</p><p>@javax.persistence.PrePersist：持久化前。</p><p>@javax.persistence.PostPersist：持久化后。</p><p>@javax.persistence.PreUpdate：更新前。</p><p>@javax.persistence.PostUpdate：更新后。</p><p>@javax.persistence.PreRemove：删除前。</p><p>@javax.persistence.PostRemove：删除后。</p><p>1）数据库查询</p><p>@PostLoad事件在下列情况下触发：</p><p>执行EntityManager.find()或getreference()方法载入一个实体后。</p><p>执行JPQL查询后。</p><p>EntityManager.refresh()方法被调用后。</p><p>2）数据库插入</p><p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p><p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p><p>@PostPersist事件在数据已经插入进数据库后发生。</p><p>3）数据库更新</p><p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p><p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p><p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p><p>4）数据库删除</p><p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p><p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p><p>@PostRemove事件在实体从数据库中删除后触发。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40753536/article/details/81285046">https://blog.csdn.net/weixin_40753536/article/details/81285046</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用注解的优势：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>思考错误的工作方式</title>
    <link href="http://ai.mak.cn/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    <id>http://ai.mak.cn/2019/12/02/%E6%9D%82%E8%AE%B0/%E6%80%9D%E8%80%83%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</id>
    <published>2019-12-01T16:00:00.000Z</published>
    <updated>2022-12-01T05:48:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>《浪潮之巅》的作者吴军，在《得到》专栏里，提及了Google刚进中国时候的一件事。</p><p>刚开始，Google总部对中国研发团队的评价非常低，因为“出工不出活儿”，北京的三四个工程师都抵不上Google总部的一个工程师。</p><p>后来吴军帮忙分析了原因，他发现，那些工程师都不善于找到最重要的工作并优先完成它们。</p><blockquote><p>中国研发团队里，所有的工程师都是新人，没有人告诉他们该如何工作；</p><p>而在Google总部，新员工只是一小部分，所以很容易在有经验的员工带动下快速掌握工作技能。</p></blockquote><p>之后两年，Google总部的工程师陆续来中国帮助团队梳理工作方式，而中国团队也会去Google总部交流，这种情况就得到了改善，中国研发团队也最终得到了总部的认可。</p><p>Google工程师这么聪明的一群人，尚且需要学习正确的工作方式，才能有效产出，何况大多数人？</p><p>我们一直都认为，如果一个人智商情商正常、学习和工作意愿高，就一定能出成绩。</p><p>然而，我带过很多人，也招过很多人，却发现一个奇怪的现象：</p><blockquote><p>有一些人，十分有意愿学习，非常努力，智商情商也都正常，然而工作产出却非常低，甚至不如很多资质低于他们的人。</p></blockquote><p>我一直百思不得其解，一度怀疑自己看人不准。直到前阵子看到吴军的这段叙述，才幡然醒悟。</p><p>我仔细回想了这些人的工作方式，将他们与产出高的人相比，发现他们无一例外都存在三个问题。</p><p><strong>一、只关注任务，不关注目标</strong></p><p>假如你的老板正在飞机上，还有1小时落地，下来之后需要给客户做一个重要汇报，而你需要给他做一份PPT。</p><p>但因为你错估了时间，导致PPT草草做完，而且发现其中一些数据没有，你怎么办？</p><p><strong>低效人士</strong>的做法是：疯狂地找数据，最后可能数据有了，然而PPT没有来得及做完，或者质量不高。</p><p><strong>一般人</strong>的做法是：找人帮自己一起找数据。</p><p>而<strong>最高效</strong>的那些人，会根据老板此次汇报的目的，判断这些数据在其中的作用大小：</p><p>如果作用不大，那么就把时间花在完善重要页数、而不是找数据上，如果很关键，那么就找其他人帮忙，或者找一些替代数据。</p><p>这三类人之间的差距，其实就是<strong>任务导向与目标导向的差距</strong>。</p><p>我此前的咨询公司，在做高潜人才研究的时候，有个发现：</p><p>高潜力的人才是有共性的，具备这些共性的人，几乎做什么都能做好，而不具备的，几乎做任何工作都会障碍重重。</p><p>这其中，有一项共性就是<strong>Result-driven</strong>（结果驱动）。</p><p>那些高产出的人，未必动作更快，而是更善于判断，什么事情对结果是最有效的，然后，用尽一切办法保证结果达成，而不是死守着原有的工作任务。</p><p>实际上，<strong>结果驱动不仅仅是一种工作习惯，更是一种思维方式</strong>。</p><p>这种以终为始的思维模式，是我自己刻意训练的最有用的思维模式之一。</p><p>比如思维训练营里，有学员问我：“如何让自己对一个行业有真知灼见？ ”</p><p>想想看，如果是你，会如何回答？ </p><p>我的回答方式，是反问她：“ 具备真知灼见的目的是什么呢？是想让客户更加信任你、还是想让老板看到你的进步？”</p><p>假设你是希望客户信任你，觉得你懂他，那你要做的，就是看这个行业里的客户有什么痛点，然后针对这几个痛点，下功夫研究和分析，有更多洞见，然后借机沟通出去。</p><p>了解一个行业，是一个太大的话题，没有目标，根本无从下手。</p><p>所以，<strong>没有结果驱动的思维，而仅仅死守着工作任务，最终就是，出工不出活儿</strong>。</p><p><strong>二、应激式工作，而非统筹式工作</strong></p><p>如果你观察周围的同事，会发现，整天风风火火、急得上蹿下跳、各种任务来回切换的人，有时候产出并不高。</p><p>看他们工作，就好像打地鼠一样，打完一个，另一个又冒上来，连看的人都跟着焦虑起来。</p><p>而另一类人，他们做事专注、条理清晰、看起来很淡定，但最后，多困难的事儿都默默搞定了。</p><p>两者的差别就在于，第一类人总<strong>是应激式</strong>工作。</p><p>他们每天起来的第一件事，不是规划当天的工作，而是马上投入工作，以至于到了下班之后，发现还有很多事情没做完，而没做完的，可能又是最重要的。</p><p>另外，领导临时给个任务、客户临时有个要求、同事临时要个数据，他们都会停下手里的事情，去忙这些，最终，在任务的切换上花费了巨大的精力。</p><p>我跟公司的运营打过一个比方：</p><blockquote><p>假设你每项工作任务平均半小时可以做完，而任务之间的切换通常也要半小时，如果你经常一项不做完就切换到下一项，就算每个任务中途切换一次吧。</p><p>那就意味着，8小时的工作时间，你至少有4小时都花在任务切换上了。</p></blockquote><p>这种应激式工作方式无疑是低效的。</p><p>那什么才是高效的呢？统筹式工作。</p><p>真正的统筹式工作，有几个特征：</p><p><strong>1.有计划地工作</strong></p><p>我通常周日晚上就会排好下周每天的工作，而每天早上会排好当天的工作。</p><p>而且，任务清单在工作的时候一直开着、实时更新，完成一项删掉一项，临时增加一项就插入相应的时间段，当天完不成的、非紧急的任务，我就改成第二天的日期。</p><p>这种方式，会让自己很有掌控感，多少事情来了，都不会乱了阵脚。</p><p>当然，在做计划的时候，你需要为高价值问题分配最多专门的时间。</p><p>因为，大部分人在80%的时间里都是做无用功，根本原因就是没搞清楚真正要解决的问题。</p><p><strong>2.形成自己固定的时间习惯</strong></p><p>比如我的习惯是：</p><blockquote><p>在上午做需要烧脑的事情、在交通工具上听书、在饭后效率不高的时候集中回复微信消息和留言、在等人的时候构思下篇文章主题、在疲劳的时候刷一下公众号、在傍晚的时候跟团队开会、在晚上做一个简单总结。</p></blockquote><p>这种习惯，一方面把不同难度的工作跟自己的效率波峰波谷相匹配，达到效率最大化；</p><p>另一方面，我会清楚地知道，5分钟、10分钟、30分钟，对我来说分别可以干什么，这样就不会一有碎片时间，就习惯性地刷朋友圈了。</p><p><strong>3.及时记录、每天总结</strong></p><p>当你正在工作的时候，老板布置了一个任务、客户又来了一个问题，你会如何呢？</p><p>很多人就直接扑到临时任务上去了，但真正好的做法是：</p><p>如果不是十万火急，你可以快速用关键词记在笔记本上，不需要任何思考，然后马上回到刚才的任务，做完再看笔记本。</p><p>另外，你在一天当中，学到了什么、犯了什么错误，当时也要记下来，因为过了那个时候，你很快就会忘，然后继续犯这个错误。</p><p>当然，这些记录，晚上都需要进行整理。</p><p>我曾说过，此前8年多的顾问生涯里，成长最快的那半年，我每天都坚持写工作日记。</p><p>另外，记录还有一个好处，就是可以减轻大脑负担。</p><p>每天的例行工作、自己常犯的错误，这些都可以列清单。</p><p><strong>你的大脑是用来思考的，是很宝贵的，别把一支笔就可以做的事情，强加给你的大脑来做。</strong></p><p><strong>三、几乎从不“偷懒”</strong></p><p>“懒癌”是第一生产力。仔细盘点一下，我们哪样创新不是因为懒呢？</p><blockquote><p>不想走路，有了汽车；不想爬楼，有了电梯；不想打扫，有了扫地机器人……</p></blockquote><p>工作中的大部分事情，并不是一次性的，而是持续的，那么就可以在第一次做的时候，搭好框架。</p><p>比如，我让运营每周做一次数据分析，这个事情是重复性的，所以高效的做法是：</p><p>建一张excel表格，把固定需要分析的参数都做好公式，每周只需要把导出来的源数据贴进去，刷新之后参数就出来，然后只需要看参数来得出结论。</p><p>当然，这里所说的“偷懒”，不仅是善用工具，还包括善用他人。</p><blockquote><p>比如，你从来没做过数据分析，那么就先去找找前人怎么做的；</p><p>比如，你有自己的团队或者实习生，那就不要做任何他们就可以做的事情；</p><p>再比如，去运营社群，摸索出一套群主激励机制，比你自己去做群主，要高效得多。</p></blockquote><p>所以，这三个让你Work Smart的工作方式，听起来难吗？一点也不，而且你很可能也听说过。</p><p>但是，为什么很多人做不到呢？我观察下来，有几个障碍：</p><p><strong>1.工作环境所限</strong></p><p>很多人的工作性质，就不是结果导向型的，而是任务导向型的。</p><p>他的工作岗位要求他做的，就是完成任务，至于背后的出发点，不需要知道。而且，领导有可能就是考核努力、考核苦劳，而不是考核产出。</p><p>实际上，工作性质对一个人的思维方式、行为习惯的影响，大到超乎想象。</p><p>你去看，刚毕业的时候，一个学校一个专业的同学，看起来差不多。</p><p>但过了几年，你会发现，只要接触一个人几分钟，听他说几句话，就能大致判断出他的职业。</p><p>再极端一些的，多年前我曾经因为要帮客户设计流程，去他们的产线观察生产过程。</p><p>在噪音极大、灯光昏暗的厂房里，我看着流水线工人机械地盯着机器、等待换箱，几个小时下来，我自己也开始反应迟钝、敏锐度下降了。</p><p><strong>2.没有资深的人辅导</strong></p><p>从开头的案例可以看出，Google工程师那么优秀的一群人，在从校园进入公司之后，也需要有经验的人辅导。</p><p>但很多公司并不像Google那样，重视对新人工作方式的培养，将Work Smart提到非常高的位置。</p><p>他们往往只重视教员工What（需要做哪些事情、用什么工具等等），却没有How（如何聪明地做这些事情）和Why（这些事情对公司、对客户有什么帮助、要达到何种目的），导致员工的聪明才干发挥不出来，没有成就感。</p><p><strong>3.思维方式固化</strong></p><p>一部分人，会在工作多年之后，发现工作性质和工作环境的负面影响，醒悟过来想要改变。</p><p>然而，从学校踏入社会的这几年，是思维和工作方式形成的关键几年，如果任务导向、应激式努力、闷头蛮干的工作方式在大脑中固化了，形成了下意识思维，是很难扭转过来的。</p><p>我带过几个人，此前的工作经历都是任务式、应激式的，在跟他们合作的时候，的确能够感受到他们与自己固有思维作斗争的痛苦与挣扎。</p><p>然而，并不是每个人最终都能挣扎出来、突破自我的。</p><p>所以，<strong>年轻时候的工作选择，你选择的不只是一份工作，而是一种思维习惯、工作方式、价值观甚至生活方式</strong>。</p><p>在初入职场的几年，处于何种工作环境、跟谁一起工作、被谁辅导工作，足以影响你的下半辈子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《浪潮之巅》的作者吴军，在《得到》专栏里，提及了Google刚进中国时候的一件事。&lt;/p&gt;
&lt;p&gt;刚开始，Google总部对中国研发团队的评价非常低，因为“出工不出活儿”，北京的三四个工程师都抵不上Google总部的一个工程师。&lt;/p&gt;
&lt;p&gt;后来吴军帮忙分析了原因，他发现</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>7条高效能的“黄金定律”</title>
    <link href="http://ai.mak.cn/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/"/>
    <id>http://ai.mak.cn/2019/11/16/%E6%9D%82%E8%AE%B0/7%E6%9D%A1%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E5%AE%9A%E5%BE%8B%E2%80%9D/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2022-12-01T04:42:28.683Z</updated>
    
    <content type="html"><![CDATA[<p>作者：洞见Neo</p><p>来源：洞见（ID：DJ00123987）</p><hr><p>听过一个笑话。</p><p>有个人跑去问上司：我都有10年工作经验了，为什么你还是不给我涨工资？</p><p>上司说：你不是有10年工作经验，你是把一年工作经验用了10年。</p><p>我认识一个人就是如此，他经常向人吐槽：“我兢兢业业干了6年，老板交代的事我连一句抱怨都没有，加班加点地做完，到头来还不如刚来一两年的新人。”</p><p>他说得悲愤，我只替他难过。</p><p>他的努力，除了证明自己的低效之外，没有任何用处。</p><p><strong>让人成功的，从不是“work hard”，而是“work smart”。</strong></p><p>掌握高效的方法，远胜过低效的苦熬。</p><p>真正厉害的人，其实都赢在了思维上。</p><p><strong>我接触过许多行业精英，这些人无一例外都掌握了一些高效能的黄金定律。</strong></p><p><strong>总结起来，有7条。</strong></p><p>现在看到还不算晚，学会它，像成功者一样思考。</p><p><strong>01</strong></p><p><strong>蘑菇定律</strong></p><p>我们都想在工作上大展拳脚、一战成名，但实际情况却是，默默坐在座位上，不被关注，只能做点杂事。</p><p><strong>得不到指导和提携，偶尔还会被指责、批评，就像长在阴暗角落里的蘑菇，自生自灭。</strong></p><p><strong>这种现象有个专业名词，叫做蘑菇定律。</strong></p><p>得不到阳光又没有肥料的蘑菇，只有长到足够高、足够壮的时候，才会被人关注。</p><p>而那段在黑暗中结茧的时光，是最最难熬的。</p><p>放弃谁都会，只有懂得蛰伏的人，才会羽化成蝶。</p><p>惠普公司前CEO卡莉·费奥丽娜从斯坦福毕业之后，第一份工作是一家地产公司的电话接线员。</p><p>她每天的任务，是打字、复印、收发文件、整理文件。</p><p>虽都是些杂货，但她穿梭于公司的每个角落，观察学习，渐渐对大部分业务都熟练于心。</p><p>蛰伏很久之后，她终于等来了自己的机会。</p><p>公司经纪人问她是否还愿意干点别的什么，于是她得到了一次撰写文稿的机会。</p><p>也就是这次撰文，改变了她的一生。当你被看作是“蘑菇”时，再怎么拼命强调自己是“灵芝”都没用。</p><p><strong>只有利用环境，尽快成长，从蘑菇堆里脱颖而出，人们才会看见你的价值。</strong></p><p><strong>02</strong></p><p><strong>备份定律</strong></p><p>程序员编程的时候，一定会有一个备份。</p><p>万一硬盘故障、代码丢失，没有备份，损失就会相当惨重。</p><p>备份，就是另一手准备。</p><p>人生也是如此。</p><p><strong>当你只给自己留了一种选择，一旦那扇门被关上，便只能作困兽之斗。</strong></p><p>备份，就是另一种可能。</p><p>西方一位哲人说过：“学习用左手剪指甲，因为你的右手未必永远管用。”</p><p><strong>这就是备份定律：思路清晰的人，凡事都有两手准备，从来不是一根筋走到底。</strong></p><p>早年间，我认识一个人，那时他在一家报社做记者。</p><p>别人都羡慕他稳定，但他不相信什么“铁饭碗”，选择自己出去创业。</p><p>三年下来，买了两套房子。</p><p>大家又羡慕他有钱有闲，下半生可以躺平，但他又决定去找一份正式工作。</p><p>几百人的竞争中，被录取为上市公司高级总监。</p><p>如今，他一边工作，一边做自己的项目。</p><p>他说，我不会再担心自己被淘汰。</p><p>人人都希望岁月静好，可现实往往是大江奔流。</p><p>可怕的不是突然的变故，而是遭遇变故之后，连选择的余地都没有。</p><p>给自己多一份备份，就是给人生多一种可能。</p><p><strong>03</strong></p><p><strong>奥卡姆剃刀定律</strong></p><p>你知道自己一周内，处于高效工作状态的时间有多长吗？</p><p>研究数据表明：人平均每周工作45小时，其中有17个小时是根本没有效率的。</p><p><strong>很多人习惯以“多”取胜，但想做的事越多，能完成的就越少。</strong></p><p><strong>于是，我们每日身心疲惫，又成果寥寥。</strong></p><p>想改变现状，首先要学会简化你的工作。</p><p>14世纪，逻辑学家奥卡姆提出一条“剃刀定律”，拉丁文为lex parsimoniae，意思就是简约法则：</p><p><strong>像拿起剃刀一样，把多余的步骤剃掉，把复杂的事情简单化。</strong></p><p><strong>两步可以做成，就不要三步。</strong></p><p>刘慈欣的科幻小说《三体》中有一段故事让我印象非常深刻。</p><p>来自各国的军事家聚在一起，讨论对付敌方游轮“审判日”号的方案，要消灭所有敌人，又不能毁掉船上的硬盘信息。</p><p>有人说用间谍潜伏，有人说用中子弹，有说用化学毒气，甚至还有说用次声波武器……极尽复杂之能事，却没一个可行方案。</p><p>只有一位办事直接果断的警官，说了一句非常简单的话：“两岸立两根柱子，中间拉上纳米丝，船一经过，就会被切割。”</p><p>在场人无不惊叹。</p><p>高手总喜欢一招制敌，击中要害，决不会啰啰嗦嗦大战300回合再结束。</p><p>能化繁为简的人，都抄“近道”走向了成功。</p><p><strong>04</strong></p><p><strong>沃尔森定律</strong></p><p>我们努力提升专业技能，却常忽略了另一件重要的事情：信息。</p><p><strong>很多人比你厉害，并不是能力比你强，而是知道的比你多。</strong></p><p>美国企业家S·M·沃尔森提出过一条定律：把信息和情报放在第一位，金钱就会滚滚而来。</p><p>终身学习的时代，聪明人都知道什么才是让自己变得重要的“加分项”。</p><p>美国弗洛伦萨州有两个年轻人，一个叫约翰，一个叫哈里，同时应聘进入一家蔬菜贸易公司。</p><p>3个月后，约翰直升组长，工资翻倍，哈里还在原地踏步。</p><p>哈里不满，质问老板，老板没有正面解答他的疑惑，而是说：现在公司准备订一批土豆，你去打听看看。</p><p>半小时后，哈里急匆匆跑回来汇报，“集农蔬菜批发中心”有土豆卖。</p><p>老板问，多少钱一斤？有几家在卖？</p><p>哈里愣了一下，转身跑出去问。</p><p>又过了半小时，他回来向老板一一汇报。</p><p>这次老板问他，库存有多少？质量怎么样？能给多少折扣？</p><p>哈里还是不知道，准备再回去问。</p><p>老板叫住了他，把约翰喊了过来。</p><p>约翰有条不紊地说：“20公里外的‘集农蔬菜批发中心’有3家卖土豆的，其中两家是0.9美元一斤，一家是0.8美元一斤。</p><p>对比发现，0.8美元的不但便宜，质量还要更好。</p><p>我跟他们谈了一下，最低0.7美元可以拿到，他们库存有500吨，有货车，可以免费送货……”</p><p>一个不用临时出门打听，就知道市场的实时动态，把握着咨询和信息的人，无需竞争，就已经赢了。</p><p><strong>想要抓住机会，就先学会发现机会。</strong></p><p><strong>比别人先获得情报，并迅速采取行动，这样的你，想不成功都难。</strong></p><p><strong>05</strong></p><p><strong>苹果定律</strong></p><p>如果一堆苹果，有好有坏，你先吃哪个？</p><p>最明智的答案是，先吃好的，把坏的扔掉。</p><p>因为，如果你先吃坏的，好的也会慢慢变坏，于是你永远也吃不到甘甜的好苹果。</p><p>这条“苹果定律”，在工作中也同样适用。</p><p>有时候，让我们晕头转向的，并不是因为多大的工作量，而是我们分不清轻重缓急，不知道该先做什么。</p><p>其实，<strong>先做哪件事，比做了多少事，更为重要。</strong></p><p>戴尔·卡耐基曾说过一个故事：</p><p>著名的心理治疗专家山德尔博士，用非常简单的方法治愈了一位病人。</p><p>这位病人是芝加哥一家大公司的高级主管。</p><p>当他初次来到山德尔的诊所，整个人都处于紧张、不安的状态，时刻都有崩溃的危险。</p><p>他说，他的办公室有3大张写字台，堆满了报表和文件，事情似乎永远都干不完，快把他逼疯了。</p><p>山德尔听过之后只给了一点建议：回去之后，把办公室全部清理干净，只留下最重要的文件。</p><p>病人照他说的办，清理干净写字台，又把留下的重要文件一一处理完。</p><p>之后，事情一到，立马办完。</p><p>再也没有堆积如山的工作威胁着他，他的身体也渐渐恢复了健康。</p><p>这也是时间管理的第一要义：<strong>永远先做最重要的事。</strong></p><p><strong>否则，空把精力耽误在不甚重要的事上，真正要紧的事只会被拖延到时间的死角，无暇也无力处理。</strong></p><p><strong>06</strong></p><p><strong>标杆定律</strong></p><p>上世纪70年代末80年代初，日本成为世界企业界学习的榜样。</p><p>在美国学习日本的运动中，施乐公司提出了名为“标杆定律”的管理方式：竞争对手的水平，就是改进自己的标杆。</p><p>放在今天，这条定律依然是帮我们接近成功的不二法则：<strong>你憎恶的那些对手，都是你最好的老师，最精准的标杆。</strong></p><p>挪威著名剧作家亨利·易卜生写作的时候，总把与他名气相当的剧作家斯特林堡的画像放在桌上，一边写作，一边看看画像。</p><p>有人不解，他说：“斯特林堡是我的死对头，但我不去伤害他，把他放在桌上，让他激励我写作。”</p><p>正是在斯特林堡“目光”的注视下，易卜生完成了《玩偶之家》《社会支柱》等经典之作。</p><p>哪有那么多“丧”，不过是在面对竞争时，你满嘴都是吐槽、挑刺和嫉妒。</p><p>但不与对手过招，你又如何进步？</p><p>瞄准你身边最优秀的人，把他们当做免费的拔高班。</p><p>正是因为对手的存在，你才会持续不断地变强。</p><p>**07<br>**</p><p><strong>卡贝定律</strong></p><p><strong>有时候，成功需要一点格局，这个格局名叫“放弃”。</strong></p><p>美国电话电报公司前总裁卡贝就给员工提出过一条建议：放弃有时比争取更有意义，它是创新的钥匙。</p><p>这就是后来被奉为经典的“卡贝定律”。</p><p>巴菲特有个私人飞行员叫Mike Flint，曾为美国四任总统开过飞机，但他想在事业上做出更大的成就。</p><p>他去请教巴菲特，巴菲特让他写下想要达成的25个目标。</p><p>写完之后，巴菲特又让他圈出其中最重要的5个。</p><p>巴菲特问：你现在知道该怎么做了吧？</p><p>Flint说：知道了，我马上开始着手于这5个目标，另外20个放在闲暇时间再做。</p><p>巴菲特摇摇头：不，你错了，那些你没有圈出来的目标，正是你应该全力避免的事，不要花任何时间和精力在它们上面。</p><p>如果你空有一腔热血，却始终在无足轻重的事情上摸爬滚打、费尽心思，那不是执着，而是愚蠢。</p><p><strong>当方向错了的时候，停下来也是一种进步。</strong></p><p>弄清自己的擅长，了解自己的力量，只有选对了方向，才有可能看见希望。</p><p>当你紧握双手，里面什么也没有；当你打开双手，世界就在你手中。</p><p>爱因斯坦曾说：“如果给我一个小时，去解答一道关于我生死的问题，我会先花55分钟弄清楚这道题到底在问什么。</p><p>一旦清楚了它到底在问什么，剩下的5分钟足以解答这个问题。”</p><p>你看，想法决定做法，做法决定活法。</p><p>你与高手之间，差的只是思维方式的不同。</p><p>了解并掌握这7条黄金定律，让你懂得在最关键的环节用力。</p><p>高效能，才能事半功倍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：洞见Neo&lt;/p&gt;
&lt;p&gt;来源：洞见（ID：DJ00123987）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;听过一个笑话。&lt;/p&gt;
&lt;p&gt;有个人跑去问上司：我都有10年工作经验了，为什么你还是不给我涨工资？&lt;/p&gt;
&lt;p&gt;上司说：你不是有10年工作经验，你是把一年工作经验用了10年。</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构的缓存、限流、分布式锁、幂等的使用方式</title>
    <link href="http://ai.mak.cn/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://ai.mak.cn/2019/11/15/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2022-12-01T04:33:31.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong></p><hr><p>互联网应用发展到今天，从单体应用架构到 SOA 以及今天的微服务，随着微服务化的不断升级进化，服务和服务之间的稳定性变得越来越重要，分布式系统之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠，微服务很重要的一个特质就是需要保证服务幂等，保证幂等性很重要的前提需要分布式锁控制并发，同时缓存、降级和限流是保护微服务系统运行稳定性的三大利器。</p><p>随着业务不断的发展，按业务域的划分子系统越来越多，每个业务系统都需要缓存、限流、分布式锁、幂等工具组件， distributed-tools 组件(暂未开源)正式包含了上述分布式系统所需要的基础功能组件。</p><p>distributed-tools 组件基于 tair、redis 分别提供了 2 个 springboot starter ，使用起来非常简单。</p><p>以使用缓存使用 redis 为例， application.properties 添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis.extend.hostName=127.0.0.1</span><br><span class="line">redis.extend.port=6379</span><br><span class="line">redis.extend.password=pwdcode</span><br><span class="line">redis.extend.timeout=10000</span><br><span class="line"></span><br><span class="line">redis.idempotent.enabled=true</span><br></pre></td></tr></table></figure><p>接下来的篇幅，重点会介绍一下缓存、限流、分布式锁、幂等的使用方式。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><hr><p>缓存的使用可以说无处不在，从应用请求的访问路径来看，用户 user -&gt; 浏览器缓存 -&gt; 反向代理缓存-&gt; WEB服务器缓存 -&gt; 应用程序缓存 -&gt; 数据库缓存等，几乎每条链路都充斥着缓存的使用，缓存最直白的解释就是“用空间换时间”的算法。缓存就是把一些数据暂时存放于某些地方，可能是内存，也有可能硬盘。总之，目的就是为了避免某些耗时的操作。我们常见的耗时的操作，比如数据库的查询、一些数据的计算结果，或者是为了减轻服务器的压力。其实减轻压力也是因查询或计算，虽然短耗时，但操作很频繁，累加起来也很长，造成严重排队等情况，服务器抗不住。</p><p>distributed-tools 组件提供了一个 CacheEngine 接口，基于 Tair、Redis 分别有不同的实现，具体 CacheEngine 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public String get(String key);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取指定的key对应的对象,异常也会返回null</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param clazz</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T get(String key, Class&lt;T&gt; clz);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据,忽略过期时间</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 存储缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value</span><br><span class="line"> * @param expiredTime</span><br><span class="line"> * @param unit</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public &lt;T extends Serializable&gt; booleanput(String key, T value, int expiredTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于key删除缓存数据</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">publicbooleaninvalid(String key);</span><br></pre></td></tr></table></figure><p>get 方法针对 key 进行查询， put 存储缓存数据， invalid 删除缓存数据。</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a><strong>限流</strong></h1><hr><p>在分布式系统中，尤其面对一些秒杀、瞬时高并发场景，都需要进行一些限流措施，保证系统的高可用。通常来说限流的目的是通过对并发访问&#x2F;请求进行限速，或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以 拒绝服务（定向到错误页或告知资源没有了）、排队 或 等待（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。</p><p>常见的一些限流算法包括固定窗口、滑动窗口、漏桶、令牌桶，distributed-tools 组件目前基于计数器只实现了固定窗口算法，具体使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 指定过期时间自增计数器，默认每次+1，非滑动窗口</span><br><span class="line">    *</span><br><span class="line">    * @param key 计数器自增key</span><br><span class="line">    * @param expireTime 过期时间</span><br><span class="line">    * @param unit  时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publiclongincrCount(String key, int expireTime, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 指定过期时间自增计数器,单位时间内超过最大值rateThreshold返回true，否则返回false</span><br><span class="line">    *</span><br><span class="line">    * @param key 限流key</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param expireTime 固定窗口时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   publicbooleanrateLimit(final String key, finalint rateThreshold, int expireTime, TimeUnit unit);</span><br></pre></td></tr></table></figure><p>基于 CacheEngine 的 rateLimit 方法可以实现限流， expireTime 只能设定固定窗口时间，非滑动窗口时间。</p><p>另外 distributed-tools 组件提供了模板 RateLimitTemplate 可以简化限流的易用性，可以直接调用 RateLimitTemplate 的 execute 方法处理限流问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @param limitKey 限流KEY</span><br><span class="line">    * @param resultSupplier 回调方法</span><br><span class="line">    * @param rateThreshold 限流阈值</span><br><span class="line">    * @param limitTime 限制时间段</span><br><span class="line">    * @param blockDuration 阻塞时间段</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定限流错误码</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public &lt;T&gt; T execute(String limitKey, Supplier&lt;T&gt; resultSupplier, long rateThreshold, long limitTime,</span><br><span class="line">                        long blockDuration, TimeUnit unit, ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       boolean blocked = tryAcquire(limitKey, rateThreshold, limitTime, blockDuration, unit);</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(blocked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return resultSupplier.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外 distributed-tools 组件还提供了注解 @RateLimit 的使用方式，具体注解 RateLimit 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RateLimit &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流KEY</span><br><span class="line">     */</span><br><span class="line">    String limitKey();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许访问的次数，默认值MAX_VALUE</span><br><span class="line">     */</span><br><span class="line">    longlimitCount()default Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间段</span><br><span class="line">     */</span><br><span class="line">    longtimeRange();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞时间段</span><br><span class="line">     */</span><br><span class="line">    longblockDuration();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位，默认为秒</span><br><span class="line">     */</span><br><span class="line">    TimeUnit timeUnit()default TimeUnit.SECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于注解的方式限流使用代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RateLimit(limitKey = &quot;#key&quot;, limitCount = 5, timeRange = 2, blockDuration = 3, timeUnit = TimeUnit.MINUTES)</span><br><span class="line">public String testLimit2(String key)&#123;</span><br><span class="line">    ..........</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何方法添加上述注解具备了一定的限流能力(具体方法需要在 spring aop 指定拦截范围内)，如上代码表示以参数 key 作为限流 key ，每 2 分钟请求次数不超过 5 次，超过限制后阻塞 3 分钟。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h1><hr><p>在 Java 单一进程中通过 synchronized 关键字和 ReentrantLock 可重入锁可以实现在多线程环境中控制对资源的并发访问，通常本地的加锁往往不能满足我们的需要，我们更多的面对场景是分布式系统跨进程的锁，简称为分布式锁。分布式锁实现手段通常是将锁标记存在内存中，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Tair ，至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。分布式锁相对单机进程的锁之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠。</p><p> distributed-tools 组件提供的分布式锁要具备如下特性：</p><ul><li>互斥性:同本地锁一样具有互斥性，但是分布式锁需要保证在不同节点进程的不同线程的互斥。</li><li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li><li>锁超时:和本地锁一样支持锁超时，防止死锁，通过异步心跳 demon 线程刷新过期时间，防止特殊场景(如 FGC 死锁超时)下死锁。</li><li>高性能、高可用:加锁和解锁需要高性能，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li><li>支持阻塞和非阻塞:同 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock ( long timeOut )。</li><li>公平锁和非公平锁(不支持):公平锁是按照请求加锁的顺序获得锁，非公平锁就相反是无序的，目前 distributed-tools 组件提供的分布式锁不支持该特性。</li></ul><p>distributed-tools 组件提供的分布式锁，使用起来非常简单，提供了一个分布式锁模板：DistributedLockTemplate ，可以直接调用模板提供的静态方法(如下)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 分布式锁处理模板执行器</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey 分布式锁key</span><br><span class="line">    * @param resultSupplier 分布式锁处理回调</span><br><span class="line">    * @param waitTime 锁等待时间</span><br><span class="line">    * @param unit 时间单位</span><br><span class="line">    * @param errCodeEnum 指定特殊错误码返回</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static &lt;T&gt; T execute(String lockKey, Supplier&lt;T&gt; resultSupplier, long waitTime, TimeUnit unit,</span><br><span class="line">                               ErrCodeEnum errCodeEnum)&#123;</span><br><span class="line">       AssertUtils.assertTrue(StringUtils.isNotBlank(lockKey), ExceptionEnumType.PARAMETER_ILLEGALL);</span><br><span class="line">       boolean locked = false;</span><br><span class="line">       Lock lock = DistributedReentrantLock.newLock(lockKey);</span><br><span class="line">       try &#123;</span><br><span class="line">           locked = waitTime &gt; 0 ? lock.tryLock(waitTime, unit) : lock.tryLock();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           throw new RuntimeException(String.format(&quot;lock error,lockResource:%s&quot;, lockKey), e);</span><br><span class="line">       &#125;</span><br><span class="line">       if (errCodeEnum != null) &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, errCodeEnum);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           AssertUtils.assertTrue(locked, ExceptionEnumType.ACQUIRE_LOCK_FAIL);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           return resultSupplier.get();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a><strong>幂等</strong></h1><hr><p> 在分布式系统设计中幂等性设计中十分重要的，尤其在复杂的微服务中一套系统中包含了多个子系统服务，而一个子系统服务往往会去调用另一个服务，而服务调用服务无非就是使用 RPC 通信或者 restful ，分布式系统中的网络延时或中断是避免不了的，通常会导致服务的调用层触发重试。具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。</p><p>幂等通常会有两个维度：</p><ol><li>空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易。</li><li>时间维度上的幂等，即幂等的保证时间，是几个小时、几天还是永久性的。</li></ol><p>在实际系统中有很多操作，不管操作多少次，都应该产生一样的效果或返回相同的结果。以下这些应用场景也是通常比较常见的应用场景：</p><ol><li>前端重复提交请求，且请求数据相同时，后台需要返回对应这个请求的相同结果。</li><li>发起一次支付请求，支付中心应该只扣用户账户一次钱，当遇到网络中断或系统异常时，也应该只扣一次钱。</li><li>发送消息，同样内容的短信发给用户只发一次。</li><li>创建业务订单，一次业务请求只能创建一个，重试请求创建多个就会出大问题。</li><li>基于 msgId 的消息幂等处理。</li></ol><p>在正式使用 distributed-tools 组件提供的幂等之前，我们先看下 distributed-tools 幂等组件的设计。</p><p><img src="https://aimak.cn/blog_img/tools/midengliucheng.jpeg"></p><p><strong>幂等 key 提取能力：获取唯一幂等 key</strong></p><p>幂等 key 的提取支持 2 中注解：IdempotentTxId、IdempotentTxIdGetter，任意方法添加以上 2 注解，即可提取到相关幂等 key ，前提条件是需要将 Idempotent 注解添加相关需要幂等的方法上。</p><p>如果单纯使用幂等模板进行业务处理，需要自己设置相关幂等key，且要保证其唯一性。</p><p><strong>分布式锁服务能力：提供全局加锁、解锁的能力</strong></p><p>distributed-tools 幂等组件需要使用自身提供的分布式锁功能，保证其并发唯一性， distributed-tools 提供的分布式锁能够提供其可靠、稳定的加锁、解锁能力。</p><p><strong>高性能的写入、查询能力：针对幂等结果查询与存储</strong></p><p>distributed-tools 幂等组件提供了基于 tair 、 redis 的存储实现，同时支持自定义一级、二级存储通过 spring 依赖注入到 IdempotentService ，建议 distributed-tools 幂等存储结果一级存储 tair mdb ，二级存储ldb或者 tablestore ，一级存储保证其高性能，二级存储保证其可靠性。</p><p>二级存储并行查询会返回查询最快的幂等结果。</p><p>二级存储并行异步写入，进一步提高性能。</p><p><strong>高可用的幂等写入、查询能力：****幂等存储出现异常，不影响业务正常流程，增加容错</strong></p><p>distributed-tools 幂等组件支持二级存储，为了保证其高可用，毕竟二级存储出现故障的概率太低，不会导致业务上不可用，如果二级存储同时出现故障，业务上做了一定的容错，针对不确定性的异常采取重试策略，会执行具体幂等方法。</p><p>一级存储与二级存储的写入与查询处理进行隔离，任何一级存储的异常不会影响整体业务执行。</p><p>在了解了 distributed-tools 组件幂等之后，接下来我们来看下如何去使用幂等组件，首先了解下 common-api 提供的幂等注解,具体幂等注解使用方式如下：</p><p><img src="https://aimak.cn/blog_img/tools/common-api-duibi.png"></p><p>幂等拦截器获取幂等 ID 的优先级：</p><ol><li>首先判断 Idempotent 的 spelKey 的属性是否为空，如果不为空会根据 spelKey 定义的 spring 表达式生成幂等 ID 。</li><li>其次判断参数是否包含 IdempotentTxId 注解，如果有 IdempotentTxId ，会直接获取参数值生成幂等 ID 。</li><li>再次通过反射获取参数对象属性是否包含 IdempotentTxId 注解，如果对象属性包含 IdempotentTxId 注解会获取该参数对象属性生成幂等 ID 。</li><li>最后以上三种情况仍未获取到幂等 ID ，会进一步通过反射获取参数对象的 Method 是否定义 IdempotentTxIdGetter 注解，如果包含该注解则通过反射生成幂等 ID 。</li></ol><p>代码使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Idempotent(spelKey = &quot;#request.requestId&quot;, firstLevelExpireDate = 7，secondLevelExpireDate = 30)</span><br><span class="line">publicvoidexecute(BizFlowRequest request)&#123;</span><br><span class="line">   ..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码表示从 request 获取 requestId 作为幂等 key ，一级存储有效期 7 天，二级存储有效期 30 天。</p><p>distributed-tools 除了可以使用幂等注解外，幂等组件还提供了一个通用幂等模板 IdempotentTemplate ，使用幂等模板的前提必须设置 tair.idempotent.enabled&#x3D;true或者redis.idempotent.enabled&#x3D;true ，默认为 false ，同时需要指定幂等结果一级存储，幂等结果存储为可选项配置。</p><p>具体使用幂等模板 IdempotentTemplate 的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 幂等模板处理器</span><br><span class="line">     *</span><br><span class="line">     * @param request 幂等Request信息</span><br><span class="line">     * @param executeSupplier 幂等处理回调function</span><br><span class="line">     * @param resultPreprocessConsumer 幂等结果回调function 可以对结果做些预处理</span><br><span class="line">     * @param ifResultNeedIdempotence 除了根据异常还需要根据结果判定是否需要幂等性的场景可以提供此参数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public R execute(IdempotentRequest&lt;P&gt; request, Supplier&lt;R&gt; executeSupplier,</span><br><span class="line">                     Consumer&lt;IdempotentResult&lt;P, R&gt;&gt; resultPreprocessConsumer, Predicate&lt;R&gt; ifResultNeedIdempotence)&#123;</span><br><span class="line"></span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>request：</strong><br>幂等参数 IdempotentRequest 组装，可以设置幂等参数和幂等唯一 ID 。</p><p><strong>executeSupplier：</strong><br>具体幂等的方法逻辑，比如针对支付、下单接口，可以通过 JDK8 函数式接口 Supplier Callback 进行处理。</p><p><strong>resultBiConsumer：</strong><br>幂等返回结果的处理，该参数可以为空，如果为空采取默认的处理，根据幂等结果，如果成功、不可重试的异常错误码，直接返回结果，如果失败可重试异常错误码，会进行重试处理。</p><p>如果该参数值不为空，可以针对返回幂等结果进行特殊逻辑处理设置 ResultStatus(ResultStatus 包含三种状态包括成功、失败可重试、失败不可重试)。</p><p><em><strong>作者信息：</strong></em></p><p>孔凡勇，花名云狄，阿里云-开放平台高级技术家，对高并发、高性能、高可用、可伸缩的分布式系统架构设计有丰富经验，Cloud Native坚定拥护者，坚守开发一线打磨匠艺的架构师。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;互联网应用发展到今天，从单体应用架构到 SOA 以及今天的微服务，随着微服务化的不断升级进化，服务和服务之间的稳定性变得越来越重要，分布式系统之所以复杂，主要原因是分布式系统需要考虑到网络的延时和不可靠，微服务</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>美团在全链路压测自动化方面的实践</title>
    <link href="http://ai.mak.cn/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ai.mak.cn/2019/11/04/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E7%BE%8E%E5%9B%A2%E5%9C%A8%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2022-11-26T12:17:18.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美团在全链路压测自动化方面的实践"><a href="#美团在全链路压测自动化方面的实践" class="headerlink" title="美团在全链路压测自动化方面的实践"></a>美团在全链路压测自动化方面的实践</h1><p>境内度假是一个低频、与节假日典型相关的业务，流量在节假日较平日会上涨五到十几倍，会给生产系统带来非常大的风险。因此，在 2018 年春节前，基于美团基础的压测平台 Quake，我们把整个境内度假业务接入了全链路压测，来系统性地评估容量和发现隐患，最终确保了春节期间系统的稳定。</p><p>在整个过程中，我们意识到，全链路压测在整个系统稳定性建设中占有核心重要的位置，也是最有效的方案。结合实际业务节假日的频率（基本平均一个月一次），如果能够把它作为稳定性保障的常规手段，我们的系统质量也能够得到很好的保障。同时，为了解决周期常态化压测过程中人力成本高、多个团队重复工作、压测安全不可控，风险高等痛点，我们提出了全链路压测自动化的设想。</p><p>通过对压测实施的具体动作做统一的梳理，在压测各个阶段推进标准化和自动化，尽力提升全流程的执行效率，最终达到常态化的目标，如图 1 所示：</p><p><img src="https://static001.infoq.cn/resource/image/d1/22/d132f820e00ae26e629b9ac725721c22.jpg" alt="img"></p><p>图 1 自动化落地整体思路</p><p>另外，在全链路压测的整个周期中，压测安全和压测有效性也是需要一直关注的质量属性。基于这些思考，如图 2 所示，我们把压测自动化需要解决的关键问题进行了归类和分解：</p><ul><li>基础流程如何自动化，提高人效；</li><li>如何自动做好压测验证，保障压测安全；</li><li>压测置信度量化如何计算，保证压测有效。</li></ul><p><img src="https://static001.infoq.cn/resource/image/38/c1/386f0c0cbd05a802f916ec0abc9e39c1.png" alt="img"></p><p>图 2 问题分析</p><p>最终，基于美团基础的压测平台 Quake（在整个系统，主要提供流量录制、回放、施压的功能），设计并实现了全链路自动化压测系统，为不同业务实施全链路压测提效，并确保压测安全。该系统：</p><ul><li>提供链路梳理工具，能够自动构建压测入口链路完整的依赖信息，辅助链路梳理；</li><li>支持链路标注和配置功能，对于无需压测触达的依赖接口，可以通过配置化手段，完成相关接口的 Mock 配置，不用在业务代码中嵌入压测判断逻辑；</li><li>提供抽象的数据构造接口，通过平台，用户可以配置任意的数据构造逻辑和流程；</li><li>在压测前&#x2F;压测中，自动对压测服务和流量做多项校验，保障压测安全性；</li><li>在平日，基于压测计划提供周期性小流量的压测校验，使得业务迭代变更带来的压测安全风险被尽早发现；</li><li>提供压测计划管理功能，通过系统自动调度和控制施压过程，解放人力；同时强制前置预压测，也提高了安全性；</li><li>一键压测，自动生成报告，收集链路入口和告警信息，提供问题记录和跟进功能。</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="系统总体设计"><a href="#系统总体设计" class="headerlink" title="系统总体设计"></a>系统总体设计</h3><p><img src="https://static001.infoq.cn/resource/image/93/cb/93f34b102890c1809d6dd8fc507ee0cb.jpg" alt="img"></p><p>图 3 系统总体逻辑架构</p><p>系统的总体逻辑架构，如图 3 所示，主要包括链路构建&#x2F;比对、事件&#x2F;指标收集、链路治理、压测配置管理、压测验证检查、数据构造、压测计划管理、报告输出等功能模块。通过这些模块，为全链路压测的整个流程提供支持，尽力降低业务部门使用全链路压测的门槛和成本。</p><p>链路构建&#x2F;比对：负责服务接口方法调用链路的构建、更新、存储。</p><p>链路治理：基于构建的链路关系，提供链路中核心依赖、出口 Mock 接口等标注、上下游分析、展示，以及出口 Mock 的配置等功能。</p><p>压测配置管理：自动发现注册服务的 Mafka（美团基于 Kafka 开发的一个分布式消息中间件综合解决方案）&#x2F;Cellar（基于 Tair 开发的分布式 KV 存储服务）&#x2F;Squirrel（基于 Redis-Cluster 模式进行二次开发的分布式缓存系统）&#x2F;Zebra（美团数据库访问层中间件）的压测配置，辅助压测方核查和配置相关配置项。</p><p>压测验证检查：确保系统可压测，通过多种校验手段和机制设计，来保证压测的安全性。</p><p>数据构造：为不同业务压测实施准备基础和流量数据。</p><p>压测计划管理：设定压测执行计划，并依赖“压测控制”模块，自动调度整个压测执行过程。</p><p>故障诊断：依据收集的关键业务&#x2F;服务指标、报警等信息，判断分析服务是否异常，以及是否终止压测。</p><p>置信度评估：从数据覆盖、链路覆盖、技术指标等维度评估压测结果的置信度，即与真实流量情况下各评估维度的相似性。</p><p>非功能性需求说明：</p><ul><li>可扩展性</li><li>能够兼容不同业务线数据构造逻辑的差异性。</li><li>能够支持不同的流量录制方式。</li><li>安全性</li><li>集成 SSO，按用户所属团队分组，展示所属的压测服务信息。对关键操作留存操作日志。</li><li>压测验证检查，是确保压测安全的关键。支持周期性压测验证，能发现待压测服务可压测性随时间的退化。</li><li>可重用性</li><li>长远看，链路构建、事件&#x2F;指标收集&#x2F;故障诊断等模块，在稳定性领域是可重用的基础设施，按独立通用模块建设。</li></ul><p>约束说明：</p><ul><li>基于 Quake 搭建，流量的录制、回放、施压等依赖 Quake。</li><li>以下对部分关键模块设计做详细介绍。</li></ul><h2 id="链路治理模块设计"><a href="#链路治理模块设计" class="headerlink" title="链路治理模块设计"></a>链路治理模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/60/89/6060c68e8ee1eb2d6856a59c5b484c89.png" alt="img"></p><p>图 4 链路治理示意图</p><p>链路治理模块是基于链路构建模块实现的。链路构建模块，底层是以闭包表的方式存储两个维度（服务和接口）的链路关系的，会周期自动地构建或更新。</p><p>链路治理模块主要提供链路入口选取、链路标注、服务出口分析、出口 Mock 配置等功能。如图 4 所示，注册压测的服务构成了压测服务的范围，也就确定了各个链路的边界。通过系统自动构建的树结构方式的链路关系，可以辅助压测方对整个链路的梳理，它解决了以往链路梳理靠翻代码等低效手段，缺少全链路视角无法做到完备梳理等问题。</p><p><img src="https://static001.infoq.cn/resource/image/d0/7a/d08f41a776cbe9a9f6141bda4798067a.png" alt="img"></p><p>图 5 出口 Mock 配置化</p><p>同时，针对整个压测范围，依赖接口可以做人工标注。哪些需要 Mock，哪些不需要 Mock，如此压测特有的链路信息能够得到持续的维护。</p><p>对于需要 Mock 的外部接口（如图 4 中的接口 C），待压测系统通过引入专有 SDK 的方式，获得出口配置化 Mock 的能力。如图 5 所示，这里使用了美团酒旅 Mock 平台的基础能力，采用 JVM-Sandbox 作为 AOP 工具，对配置的需要 Mock 的外部接口做动态能力增强。在接口调用时，判断是否是压测流量，是的话走 Mock 逻辑，做模拟时延处理，返回提前配置的响应数据。这样的话，第一，简化了出口 Mock 的操作，业务代码里 Mock 逻辑 0 侵入；第二，把之前本地 Mock 与借助 Mockserver 的两种解决方案用一种方案替代，便于统一管理；第三，在实际压测时，平台还可以通过 SDK 收集 Mock 逻辑执行的数据，自动与后台标注的 Mock 数据对比，来确保应该被 Mock 的出口确实被 Mock 掉。</p><h2 id="数据构造模块设计"><a href="#数据构造模块设计" class="headerlink" title="数据构造模块设计"></a>数据构造模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/f9/20/f9a2e1b507526e109982ecac0359b620.png" alt="img"></p><p>图 6 数据构造</p><p>数据构造模块是为了解决不同业务对于基础数据和流量数据的差异化构造流程。提出了两个关键的概念：数据构造逻辑和数据构造流程。数据构造逻辑，是数据构造的细粒度可复用的基本单元，由一段 Java 代码表示。平台提供统一抽象的数据构造接口，基于 Java 动态编译技术，开发了一个 Java 版的脚本引擎，支持构造逻辑的在线编辑与更新。同时，基于美团 RPC 中间件泛化调用能力，构建了泛化调用工具，帮助用户把外部基础数据构造接口的调用集成到一个数据构造逻辑中。</p><p>数据构造流程，定义了压测基础数据和流量数据生成的整个流程。通过与 Quake 的交互，获取原始真实的线上数据；构建了一个简版的流程引擎，在统一设定的流程中，如图 6 所示，通过在标准扩展槽中，配置不同类型的数据构造逻辑和执行顺序，来定义整个数据构造执行的流程；最后，把构造的流量数据与 Quake 压测场景绑定，作为后续 Quake 压测施压中，场景回放流量的来源。</p><p>通过这样的设计，能够支持任意数据构造逻辑，通用灵活。同时集成了 Quake 已有的流量录制功能，一键执行数据构造流程，大大地提升了效率。</p><h2 id="压测验证模块设计"><a href="#压测验证模块设计" class="headerlink" title="压测验证模块设计"></a>压测验证模块设计</h2><p><img src="https://static001.infoq.cn/resource/image/65/6b/65ba4cd007740cf35772e7ea4633a56b.jpg" alt="img"></p><p>图 7 美团服务压测验证示意</p><p>对于压测安全性的保障，一直是自动化的难点。之前的经验多是在非生产环境压测或预压测过程中，依靠不同服务相关负责人的人工确认。这里针对压测验证，提供两条新的思考角度：一个是从待压测服务系统可压测性的角度看；一个是从压测流量特征的角度看。对于第一个角度，一个服务支持压测需要满足压测数据和流量的隔离。对于不同的系统生态，需要满足的点是不同的，对于美团生态下的服务，可压测的条件包括组件版本支持压测、影子存储配置符合预期等等。</p><p>从这些条件出发，就可以得到下面这些静态的校验项：</p><ul><li>服务依赖中间件版本要求校验；</li><li>Zebra 压测配置校验；</li><li>Cellar&#x2F;Squirrel 压测配置校验；</li><li>Mafka 压测开关同步及校验；</li><li>服务 Mock 逻辑存在性校验。</li></ul><p>而从第二个角度来看，就是关注压测流量下会产生哪些特有的流量特征数据，通过这些特有的数据来确保压测的安全性。这里主要有三类数据：美团分布式追踪系统（MTrace）中调用链路的压测标记数据（正常的压测链路应该是一直带有压测标记，直到压测范围的边界节点，可参考图 4）；标记 Mock 的外部接口被调用时，上报的运行数据；基于监控系统得到的压测流量特有的监控数据。利用这些数据，我们设计了三种动态的校验项，发现压测标记丢失、Mock 出口被调用等异常情况：</p><ul><li>MTrace 链路标记校验，从压测链路入口出发，收集压测链路信息，校验压测标记信息传递是否符合预期。</li></ul><p><img src="https://static001.infoq.cn/resource/image/07/11/07d0100434cec699bfbd7b823d369611.png" alt="img"></p><p>图 8 MTrace 链路标记校验示意</p><ul><li>服务 Mock 逻辑压测标记校验，通过增强的校验逻辑，把执行信息上报到平台，与 Mock 配置时的标注数据对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/42/f4/424b9e7782e721f1524796dbd117a5f4.png" alt="img"></p><p>图 9 服务 Mock 压测校验示意</p><ul><li>压测与真实链路比对校验，利用链路治理模块构建链路的能力，采集压测监控数据重构链路，与真实链路对比验证。</li></ul><p><img src="https://static001.infoq.cn/resource/image/31/91/31d13eba73a566e5075e674ff8661691.png" alt="img"></p><p>图 10 压测与真实链路对比示意</p><p>除了明确静态和动态两类压测校验规则，在具体流程安排上，在压测时和平日两个时期执行这些规则。既能把压测校验的压力分散到平时，也能尽快地发现服务因代码迭代引入的新风险。</p><p>在压测时，通过强制前置预压测的流程设计以及静态&#x2F;动态压测校验项的自动执行，保障安全这个事情。校验不通过，给出告警，甚至在允许的情况下直接终止设定的压测计划。</p><p>在平日，通过执行周期性小流量压测校验，在施压过程中对 QPS 做个位数的精细控制，以尽量小的代价快速发现压测范围内压测安全性的退化。</p><h2 id="压测计划管理模块设计"><a href="#压测计划管理模块设计" class="headerlink" title="压测计划管理模块设计"></a>压测计划管理模块设计</h2><p>压测计划管理模块，提供压测计划的提前设定，然后模块能够自动调度和控制整个施压过程。如图 11 所示，这里的压测计划是多个压测场景的组合，包含 QPS 的增长计划等信息，主要分为预压测和正式压测两个阶段。压测计划的自动实施，能够解决尤其多场景组合压测，操作耗时多、多场景压测 QPS 无法同步变更、压测方无法兼顾操作和观测等问题，提升了效率。同时，在压测计划执行状态机里，预压测正常执行完成，状态才能迁移到正式压测的开始状态，提高了压测安全性。</p><p><img src="https://static001.infoq.cn/resource/image/76/3f/76fd6115851f9b4d5503e7995b4e4d3f.png" alt="img"></p><p>图 11 压测计划执行</p><p>从图 11 可以看到，压测计划模块，是整个自动化压测的核心，协同起了各个模块。通过具体的计划任务执行产生的事件，触发了压测验证检查、压测进展播报、收集压测监控&#x2F;告警等数据，来检测服务是否异常，并根据配置来终止压测，能够故障时及时止损。最后，报告生成模块收到压测终止事件，汇总各种信息，自动生成包括压测基本信息等多维度信息的压测报告，节省了一些压测后分析的时间。</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>以下以实际压测的过程来做个案例分享。</p><p><strong>团队&#x2F;服务注册</strong></p><ul><li>设定实施压测的虚拟团队和压测覆盖范围的应用服务。</li></ul><p><img src="https://static001.infoq.cn/resource/image/9b/ea/9b5572017d1fb136366b80241713adea.jpg" alt="img"></p><p><strong>链路治理</strong></p><ul><li>选定压测链路入口，可以得到入口以下的接口链路关系树，便于梳理。</li><li>明确需要 Mock 的外部接口，并做配置，参考“链路治理模块设计”一节。</li></ul><p><img src="https://static001.infoq.cn/resource/image/f4/e4/f4a172982f91243b0cb410c603536ce4.jpg" alt="img"></p><p><strong>应用改造与压测配置</strong></p><ul><li>对待接入压测应用改造，满足“服务的可压测条件”，参考图 7。</li><li>压测应用依赖中间件配置，系统依据构建的链路信息，能够自动发现。提供统一配置和核对的页面功能。</li><li><img src="https://static001.infoq.cn/resource/image/a4/85/a442826c7c90692248e423c781f5e985.png" alt="img"></li></ul><p><strong>Quake 准备</strong></p><ul><li>压测自动化系统是基于 Quake 构建的，流量录制、回放、施压等依赖于此。因此需要到 Quake 上配置流量录制的“流量任务”和压测执行的“压测场景”。</li></ul><p><img src="https://static001.infoq.cn/resource/image/4a/7e/4a7e7fe8a1d2f3aa98661c3779ef977e.png" alt="img"></p><p><strong>数据构造</strong></p><p>配置数据构造逻辑，当然已有的逻辑都是可复用的单元，可以先查看已有逻辑是否能满足自己的需要。</p><p><img src="https://static001.infoq.cn/resource/image/8c/37/8c44afa725c533ddf446e446d3d84537.jpg" alt="img"></p><ul><li>配置数据构造流程。</li></ul><p><strong>压测实施</strong></p><ul><li>设定压测计划，到启动时间，系统会自动启动压测。</li></ul><p><img src="https://static001.infoq.cn/resource/image/7d/1b/7db495027bea72fc8cd1b7ad0d8f651b.png" alt="img"></p><p>压测中，注意关注压测验证校验的告警信息，及时处理。</p><p><img src="https://static001.infoq.cn/resource/image/29/f7/29c96d574b217c5bca4b50cfe99015f7.png" alt="img"></p><ul><li>压测后，可查看压测报告。记录和跟进发现的问题。</li><li><img src="https://static001.infoq.cn/resource/image/a9/39/a986012a95836b5b44ab064c775d3939.png" alt="img"></li></ul><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>目前，压测自动化系统已经投入使用，美团酒店和境内度假的全部团队已经接入，有效地提升了压测效率。后续会在两个大方向上持续建设升级，一个是把全链路压测放到“容量评估与优化”领域来看，不仅关注整体系统的稳定性，同时也期望兼顾成本的平衡；另一个是与稳定性其他子领域的生态集成，比如故障演练、弹性伸缩等等，在更多场景发挥压测的作用。最后，通过这些努力，使得线上系统的稳定性成为一个确定性的事情。</p><p><strong>作者简介：</strong></p><p>欧龙，美团研发工程师，2013 年加入美团，目前主要负责境内度假交易稳定性建设等工作。</p><p><strong>本文转载自技术琐话公众号。</strong></p><p><strong>原文链接：</strong><a href="https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w">https://mp.weixin.qq.com/s/BfxFGm_RW-qZqZDbWSUp8w</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;美团在全链路压测自动化方面的实践&quot;&gt;&lt;a href=&quot;#美团在全链路压测自动化方面的实践&quot; class=&quot;headerlink&quot; title=&quot;美团在全链路压测自动化方面的实践&quot;&gt;&lt;/a&gt;美团在全链路压测自动化方面的实践&lt;/h1&gt;&lt;p&gt;境内度假是一个低频、与节假日</summary>
      
    
    
    
    <category term="测试" scheme="http://ai.mak.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://ai.mak.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
