<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>老山骑行路线规划</title>
    <link href="http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/"/>
    <id>http://ai.mak.cn/2022/09/08/%E6%9D%82%E8%AE%B0/%E8%80%81%E5%B1%B1%E9%AA%91%E8%A1%8C%E8%B7%AF%E7%BA%BF/</id>
    <published>2022-09-07T16:00:00.000Z</published>
    <updated>2023-01-14T14:30:15.326Z</updated>
    
    <content type="html"><![CDATA[<p>老山骑行路线，骑行群规划的路线，收藏，随时查看</p><p><img src="https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老山骑行路线，骑行群规划的路线，收藏，随时查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/blog_img/life/nj-laoshanqixing.jpg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 使用简介</title>
    <link href="http://ai.mak.cn/2022/08/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/arthas%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://ai.mak.cn/2022/08/01/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/arthas%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2023-01-14T14:22:18.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas 是Alibaba开源的Java诊断工具，动态跟踪Java代码；实时监控JVM状态，可以在不中断程序执行的情况下轻松完成JVM相关问题排查工作 。支持JDK 6+，支持Linux&#x2F;Mac&#x2F;Windows。这个工具真的很好用，而且入门超简单，十分推荐。</p><blockquote><p>基于 Spring Boot + MyBatis Plus + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p><ul><li>项目地址：<a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro">https://gitee.com/zhijiantianya/ruoyi-vue-pro</a></li><li>视频教程：<a href="https://doc.iocoder.cn/video/">https://doc.iocoder.cn/video/</a></li></ul></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li></ol><p>接下来，围绕这6个问题，学习下Arthas的基本用法。</p><blockquote><p>基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p><ul><li>项目地址：<a href="https://gitee.com/zhijiantianya/yudao-cloud">https://gitee.com/zhijiantianya/yudao-cloud</a></li><li>视频教程：<a href="https://doc.iocoder.cn/video/">https://doc.iocoder.cn/video/</a></li></ul></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行下面命令下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure><p>用java -jar的方式启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br><span class="line"></span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 79952 cn.test.MobileApplication</span><br><span class="line">  [2]: 93872 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure><p>然后输入数字，选择你想要监听的应用，回车即可</p><p>也可点此下载arthas相关jar：<code>http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=com.taobao.arthas&amp;a=arthas-packaging&amp;e=zip&amp;c=bin&amp;v=LATEST</code></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="当前版本v3-1-4"><a href="#当前版本v3-1-4" class="headerlink" title="当前版本v3.1.4"></a>当前版本v3.1.4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[arthas@79952]$ version</span><br><span class="line">3.1.4</span><br></pre></td></tr></table></figure><h4 id="1、stack"><a href="#1、stack" class="headerlink" title="1、stack"></a>1、stack</h4><p>输出当前方法被调用的调用路径</p><p>很多时候我们都知道一个方法被执行，但是有很多地方调用了它，你并不知道是谁调用了它，此时你需要的是 stack 命令。</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[arthas@79952]$ stack com.baomidou.mybatisplus.extension.service.IService getOne</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:202 , method-cnt:209) cost in 10761 ms.</span><br><span class="line">ts=2019-11-13 11:49:13;thread_name=http-nio-8801-exec-6;id=2d;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    @com.baomidou.mybatisplus.extension.service.impl.ServiceImpl.getOne()</span><br><span class="line">        at com.baomidou.mybatisplus.extension.service.IService.getOne(IService.java:230)</span><br><span class="line">        ...... ......</span><br><span class="line">        at cn.test.mobile.controller.order.OrderController.getOrderInfo(OrderController.java:500)</span><br></pre></td></tr></table></figure><p>可以看到OrderController.java的第500行调用了这个getOne接口。</p><p><em>注意这个命令需要调用后才会触发日志，相似的还有watch、trace等</em></p><h4 id="2、jad"><a href="#2、jad" class="headerlink" title="2、jad"></a>2、jad</h4><p>反编译指定已加载类的源码</p><p>有时候，版本发布后，代码竟然没有执行，代码是最新的吗，这时可以使用jad反编译相应的class。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad cn.test.mobile.controller.order.OrderController</span><br></pre></td></tr></table></figure><p>仅编译指定的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jad cn.test.mobile.controller.order.OrderController getOrderInfo</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">@RequestMapping(value=&#123;&quot;getOrderInfo&quot;&#125;, method=&#123;RequestMethod.POST&#125;)</span><br><span class="line">public Object getOrderInfo(HttpServletRequest request, @RequestBody Map map) &#123;</span><br><span class="line">    ResponseVo responseVo = new ResponseVo();</span><br><span class="line">    ... ... ...  ...</span><br></pre></td></tr></table></figure><h4 id="3、sc"><a href="#3、sc" class="headerlink" title="3、sc"></a>3、sc</h4><p>“Search-Class” 的简写 ，查看JVM已加载的类信息 有的时候，你只记得类的部分关键词，你可以用sc获取完整名称 当你碰到这个错的时候“ClassNotFoundException”或者“ClassDefNotFoundException”，你可以用这个命令验证下</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left">[d]</td><td align="left">输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。如果一个类被多个ClassLoader所加载，则会出现多次</td></tr></tbody></table><p>模糊搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc *OrderController*</span><br><span class="line">cn.test.mobile.controller.order.OrderController</span><br></pre></td></tr></table></figure><p>打印类的详细信息 sc -d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sc -d cn.test.mobile.controller.order.OrderController</span><br><span class="line"></span><br><span class="line"> class-info        cn.test.mobile.controller.order.OrderController</span><br><span class="line"> code-source       /F:/IDEA-WORKSPACE-TEST-qyb/trunk/BE/mobile/target/classes/</span><br><span class="line"> name              cn.test.mobile.controller.order.OrderController</span><br><span class="line"> isInterface       false</span><br><span class="line"> isAnnotation      false</span><br><span class="line"> isEnum            false</span><br><span class="line"> isAnonymousClass  false</span><br><span class="line"> isArray           false</span><br><span class="line"> isLocalClass      false</span><br><span class="line"> isMemberClass     false</span><br><span class="line"> isPrimitive       false</span><br><span class="line"> isSynthetic       false</span><br><span class="line"> simple-name       OrderController</span><br><span class="line"> modifier          public</span><br><span class="line"> annotation        org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.Requ</span><br><span class="line">                   estMapping</span><br><span class="line"> interfaces</span><br><span class="line"> super-class       +-cn.test.mobile.controller.BaseController</span><br><span class="line">                     +-java.lang.Object</span><br><span class="line"> class-loader      +-sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">                     +-sun.misc.Launcher$ExtClassLoader@480bdb19</span><br><span class="line"> classLoaderHash   18b4aac2</span><br></pre></td></tr></table></figure><h4 id="与之相应的还有sm-“Search-Method”-，查看已加载类的方法信息"><a href="#与之相应的还有sm-“Search-Method”-，查看已加载类的方法信息" class="headerlink" title="与之相应的还有sm( “Search-Method” )，查看已加载类的方法信息"></a>与之相应的还有sm( “Search-Method” )，查看已加载类的方法信息</h4><p>查看String里的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sm java.lang.String</span><br><span class="line">java.lang.String &lt;init&gt;([BII)V</span><br><span class="line">java.lang.String &lt;init&gt;([BLjava/nio/charset/Charset;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BLjava/lang/String;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BIILjava/nio/charset/Charset;)V</span><br><span class="line">java.lang.String &lt;init&gt;([BIILjava/lang/String;)V</span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure><p>查看String中toString的详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.lang.String toString</span><br><span class="line">declaring-class  java.lang.String</span><br><span class="line"> method-name      toString</span><br><span class="line"> modifier         public</span><br><span class="line"> annotation</span><br><span class="line"> parameters</span><br><span class="line"> return           java.lang.String</span><br><span class="line"> exceptions</span><br><span class="line"> classLoaderHash  null</span><br></pre></td></tr></table></figure><h4 id="4、watch"><a href="#4、watch" class="headerlink" title="4、watch"></a>4、watch</h4><p>可以监测一个方法的入参和返回值</p><p>有些问题线上会出现，本地重现不了，这时这个命令就有用了</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left"><em>express</em></td><td align="left">观察表达式</td></tr><tr><td align="left"><em>condition-express</em></td><td align="left">条件表达式</td></tr><tr><td align="left">[b]</td><td align="left">在<strong>「方法调用之前」</strong> 观察</td></tr><tr><td align="left">[e]</td><td align="left">在<strong>「方法异常之后」</strong> 观察</td></tr><tr><td align="left">[s]</td><td align="left">在<strong>「方法返回之后」</strong> 观察</td></tr><tr><td align="left">[f]</td><td align="left">在<strong>「方法结束之后」</strong> (正常返回和异常返回)观察，<strong>「默认选项」</strong></td></tr><tr><td align="left">[E]</td><td align="left">开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td align="left">[x:]</td><td align="left">指定输出结果的属性遍历深度，默认为 1</td></tr></tbody></table><p>观察getOrderInfo的出参和返回值，出参就是方法结束后的入参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">watch cn.test.mobile.controller.order.OrderController getOrderInfo &quot;&#123;params,returnObj&#125;&quot; -x 2</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 456 ms.</span><br><span class="line">ts=2019-11-13 15:30:18; [cost=18.48307ms] result=@ArrayList[</span><br><span class="line">    @Object[][  # 这个就是出参，params</span><br><span class="line">        @RequestFacade[org.apache.catalina.connector.RequestFacade@1d81dbd7],</span><br><span class="line">        @LinkedHashMap[isEmpty=false;size=2], # 把遍历深度x改为3就可以查看map里的值了</span><br><span class="line">    ],</span><br><span class="line">    @ResponseVo[ # 这个就是返回值 returnObj</span><br><span class="line">        log=@Logger[Logger[cn.test.db.common.vo.ResponseVo]],</span><br><span class="line">        success=@Boolean[true],</span><br><span class="line">        message=@String[Ok],</span><br><span class="line">        count=@Integer[0],</span><br><span class="line">        code=@Integer[1000],</span><br><span class="line">        data=@HashMap[isEmpty=false;size=1],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>观察getOrderInfo的入参和返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch cn.test.mobile.controller.order.OrderController getOrderInfo &quot;&#123;params,returnObj&#125;&quot; -x 3 -b</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 93 ms.</span><br><span class="line">ts=2019-11-13 15:37:38; [cost=0.012479ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @RequestFacade[</span><br><span class="line">            request=@Request[org.apache.catalina.connector.Request@d04e652],</span><br><span class="line">            sm=@StringManager[org.apache.tomcat.util.res.StringManager@7ae7a97b],</span><br><span class="line">        ],</span><br><span class="line">        @LinkedHashMap[</span><br><span class="line">            @String[payNo]:@String[190911173713755288],</span><br><span class="line">            @String[catalogId]:@String[6],</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">    null,# -b是方法调用之前观察，所以还没有返回值</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果需要捕捉异常的话，使用throwExp，如{params,returnObj,throwExp}</p><h4 id="5、trace"><a href="#5、trace" class="headerlink" title="5、trace"></a>5、trace</h4><p>输出方法内部调用路径，和路径上每个节点的耗时</p><p>可以通过这个命令，查看哪些方法耗性能，从而找出导致性能缺陷的代码，这个耗时还包含了arthas执行的时间哦。</p><table><thead><tr><th align="left">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="left"><em>class-pattern</em></td><td align="left">类名表达式匹配</td></tr><tr><td align="left"><em>method-pattern</em></td><td align="left">方法名表达式匹配</td></tr><tr><td align="left"><em>condition-express</em></td><td align="left">条件表达式</td></tr><tr><td align="left">[E]</td><td align="left">开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td align="left"><code>[n:]</code></td><td align="left">命令执行次数</td></tr><tr><td align="left"><code>#cost</code></td><td align="left">方法执行耗时</td></tr></tbody></table><p>输出getOrderInfo的调用路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 92 ms.</span><br><span class="line">---ts=2019-11-13 15:46:59;thread_name=http-nio-8801-exec-4;id=2b;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    ---[15.509011ms] cn.test.mobile.controller.order.OrderController:getOrderInfo()</span><br><span class="line">        +---[0.03584ms] cn.test.db.common.vo.ResponseVo:&lt;init&gt;() #472</span><br><span class="line">        +---[0.00992ms] java.util.HashMap:&lt;init&gt;() #473</span><br><span class="line">        +---[0.02176ms] cn.test.mobile.controller.order.OrderController:getUserInfo() #478</span><br><span class="line">        +---[0.024ms] java.util.Map:get() #483</span><br><span class="line">        +---[0.00896ms] java.lang.Object:toString() #483</span><br><span class="line">        +---[0.00864ms] java.lang.Integer:parseInt() #483</span><br><span class="line">        +---[0.019199ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:&lt;init&gt;() #500</span><br><span class="line">        +---[0.135679ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:allEq() #500</span><br><span class="line">        +---[12.476072ms] cn.test.db.service.IOrderMediaService:getOne() #500</span><br><span class="line">        +---[0.0128ms] java.util.HashMap:put() #501</span><br><span class="line">        +---[0.443517ms] cn.test.db.common.vo.ResponseVo:setSuccess() #503</span><br><span class="line">        `---[0.03488ms] java.util.Map:put() #504</span><br></pre></td></tr></table></figure><p>输出getOrderInfo的调用路径，且cost大于10ms，-j是指过滤掉jdk中的方法，可以看到输出少了很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &#x27;#cost &gt; 10&#x27;</span><br><span class="line"></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 96 ms.</span><br><span class="line">---ts=2019-11-13 15:53:42;thread_name=http-nio-8801-exec-2;id=29;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@a6c54c3</span><br><span class="line">    ---[13.803743ms] cn.test.mobile.controller.order.OrderController:getOrderInfo()</span><br><span class="line">        +---[0.01312ms] cn.test.db.common.vo.ResponseVo:&lt;init&gt;() #472</span><br><span class="line">        +---[0.01408ms] cn.test.mobile.controller.order.OrderController:getUserInfo() #478</span><br><span class="line">        +---[0.0128ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:&lt;init&gt;() #500</span><br><span class="line">        +---[0.303998ms] com.baomidou.mybatisplus.core.conditions.query.QueryWrapper:allEq() #500</span><br><span class="line">        +---[12.675431ms] cn.test.db.service.IOrderMediaService:getOne() #500</span><br><span class="line">        `---[0.409917ms] cn.test.db.common.vo.ResponseVo:setSuccess() #503</span><br></pre></td></tr></table></figure><h4 id="6、jobs"><a href="#6、jobs" class="headerlink" title="6、jobs"></a>6、jobs</h4><p>执行后台异步任务</p><p>线上有些问题是偶然发生的，这时就需要使用异步任务，把信息写入文件。</p><p>使用 &amp; 指定命令去后台运行，使用 &gt; 将结果重写到日志文件，以trace为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &gt; test.out &amp;</span><br></pre></td></tr></table></figure><p>jobs——列出所有job</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> jobs</span><br><span class="line">[76]*  </span><br><span class="line">       Running           trace -j cn.test.mobile.controller.order.OrderController getOrderInfo &gt;&gt; test.out &amp;</span><br><span class="line">       execution count : 0</span><br><span class="line">       start time      : Wed Nov 13 16:13:23 CST 2019</span><br><span class="line">       timeout date    : Thu Nov 14 16:13:23 CST 2019</span><br><span class="line">       session         : f4fba846-e90b-4234-959e-e78ad0a5db8c (current)</span><br></pre></td></tr></table></figure><p>job id是76, * 表示此job是当前session创建，状态是Running，execution count是执行次数，timeout date是超时时间</p><p>异步执行时间，默认为1天，如果要修改，使用options命令,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options job-timeout 2d</span><br></pre></td></tr></table></figure><p>options可选参数 1d, 2h, 3m, 25s，分别代表天、小时、分、秒</p><p>kill——强制终止任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill 76</span><br><span class="line">kill job 76 success</span><br></pre></td></tr></table></figure><p>最多同时支持8个命令使用重定向将结果写日志</p><p>请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响</p><h4 id="7、logger"><a href="#7、logger" class="headerlink" title="7、logger"></a>7、logger</h4><p>查看logger信息，更新logger level</p><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logger</span><br><span class="line"> name                ROOT</span><br><span class="line"> class               ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader         sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"> classLoaderHash     18b4aac2 #改日志级别时要用到它</span><br><span class="line"> level               INFO</span><br><span class="line"> effectiveLevel      INFO</span><br><span class="line"> ... ... ... ...</span><br></pre></td></tr></table></figure><p>更新日志级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><p>如果执行这个命令时出错：update logger level fail.</p><p>指定classLoaderHash重试一下试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger -c 18b4aac2 --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><h4 id="8、dashboard"><a href="#8、dashboard" class="headerlink" title="8、dashboard"></a>8、dashboard</h4><p>查看当前系统的实时数据面板 这个命令可以全局的查看jvm运行状态，比如内存和cpu占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br><span class="line">ID        NAME                          GROUP               PRIORITY STATE     %CPU      TIME      INTERRUPT DAEMON</span><br><span class="line">17        Abandoned connection cleanup  main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">1009      AsyncAppender-Worker-arthas-c system              5        WAITING   0         0:0       false     true</span><br><span class="line">5         Attach Listener               system              5        RUNNABLE  0         0:0       false     true</span><br><span class="line">23        ContainerBackgroundProcessor[ main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">55        DestroyJavaVM                 main                5        RUNNABLE  0         0:11      false     false</span><br><span class="line">3         Finalizer                     system              8        WAITING   0         0:0       false     true</span><br><span class="line">18        HikariPool-1 housekeeper      main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">39        NioBlockingSelector.BlockPoll main                5        RUNNABLE  0         0:0       false     true</span><br><span class="line">2         Reference Handler             system              10       WAITING   0         0:0       false     true</span><br><span class="line">4         Signal Dispatcher             system              9        RUNNABLE  0         0:0       false     true</span><br><span class="line">69        System Clock                  main                5        TIMED_WAI 0         0:34      false     true</span><br><span class="line">25        Thread-2                      main                5        TIMED_WAI 0         0:0       false     false</span><br><span class="line">37        Timer-0                       main                5        TIMED_WAI 0         0:0       false     true</span><br><span class="line">Memory                    used    total    max     usage    GC</span><br><span class="line">heap                      216M    415M     3614M   5.99%    gc.ps_scavenge.count          96</span><br><span class="line">ps_eden_space             36M     78M      1276M   2.90%    gc.ps_scavenge.time(ms)       3054</span><br><span class="line">ps_survivor_space         17M     38M      38M     46.53%   gc.ps_marksweep.count         4</span><br><span class="line">ps_old_gen                161M    298M     2711M   5.97%    gc.ps_marksweep.time(ms)      804</span><br><span class="line">nonheap                   175M    180M     -1      97.09%</span><br><span class="line">code_cache                35M     35M      240M    14.85%</span><br></pre></td></tr></table></figure><p>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应 我们可以通过 thread id 查看线程的堆栈 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread 2</span><br><span class="line">&quot;Reference Handler&quot; Id=2 WAITING on java.lang.ref.Reference$Lock@66ad4272</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    -  waiting on java.lang.ref.Reference$Lock@66ad4272</span><br><span class="line">    at java.lang.Object.wait(Object.java:502)</span><br><span class="line">    at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br></pre></td></tr></table></figure><p>NAME: 线程名</p><p>GROUP: 线程组名</p><p>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</p><p>STATE: 线程的状态</p><p>CPU%: 线程消耗的cpu占比，采样100ms，将所有线程在这100ms内的cpu使用量求和，再算出每个线程的cpu使用占比。</p><p>TIME: 线程运行总时间，数据格式为分：秒</p><p>INTERRUPTED: 线程当前的中断位状态</p><p>DAEMON: 是否是daemon线程</p><h4 id="9、redefine"><a href="#9、redefine" class="headerlink" title="9、redefine"></a>9、redefine</h4><p>redefine jvm已加载的类 ，可以在不重启项目的情况下，热更新类。</p><p>这个功能真的很强大，但是命令不一定会成功</p><p>下面我们来模拟：假设我想修改OrderController里的某几行代码，然后热更新至jvm：</p><p>a. 反编译OrderController，默认情况下，反编译结果里会带有ClassLoader信息，通过–source-only选项，可以只打印源代码。方便和mc&#x2F;redefine命令结合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only cn.test.mobile.controller.order.OrderController &gt; OrderController.java</span><br></pre></td></tr></table></figure><p>生成的OrderController.java在哪呢，执行pwd就知道在哪个目录了</p><p>b. 查找加载OrderController的ClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc -d cn.test.mobile.controller.order.OrderController | grep classLoaderHash</span><br><span class="line">classLoaderHash   18b4aac2</span><br></pre></td></tr></table></figure><p>c. 修改保存好OrderController.java之后，使用mc(Memory Compiler)命令来编译成字节码，并且通过-c参数指定ClassLoader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc -c 18b4aac2 OrderController.java -d ./</span><br></pre></td></tr></table></figure><p>d. 热更新刚才修改后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redefine -c 18b4aac2 OrderController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><p>然后代码就更新成功了。</p><p>redefine 我参考了这篇文档<code>https://github.com/alibaba/arthas/issues/537</code>。</p><p>更多高级的功能请移步Arthas官网文档<code>https://alibaba.github.io/arthas/quick-start.html</code>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果java -jar选择启动某个应用的时候，报下面的错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: 3.1.4</span><br><span class="line">[INFO] Process 11544 already using port 3658</span><br><span class="line">[INFO] Process 11544 already using port 8563</span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 11544</span><br><span class="line">  [2]: 119504 cn.test.MobileApplication</span><br><span class="line">  [3]: 136340 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">  [4]: 3068</span><br><span class="line">2 #选择第2个启动</span><br><span class="line">[ERROR] Target process 119504 is not the process using port 3658, you will connect to an unexpected process.</span><br><span class="line">[ERROR] 1. Try to restart arthas-boot, select process 11544, shutdown it first with running the &#x27;shutdown&#x27; command.</span><br><span class="line">[ERROR] 2. Or try to use different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1</span><br></pre></td></tr></table></figure><p>注意提示<code>[ERROR] 1</code>，只需要进入11544这个应用，然后执行shutdown关闭这个应用就可以启动了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas 是Alibaba开源的Java诊断工具，动态跟踪Java代码；实时监控JVM状态，可以在不中断程序执行的情况下轻松完成JVM相</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="PMO" scheme="http://ai.mak.cn/tags/PMO/"/>
    
  </entry>
  
  <entry>
    <title>一个优秀的 Controller 层逻辑</title>
    <link href="http://ai.mak.cn/2022/07/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84Controller%E5%B1%82%E9%80%BB%E8%BE%91/"/>
    <id>http://ai.mak.cn/2022/07/23/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84Controller%E5%B1%82%E9%80%BB%E8%BE%91/</id>
    <published>2022-07-22T16:00:00.000Z</published>
    <updated>2023-01-14T14:45:07.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个优秀的-Controller-层逻辑"><a href="#一个优秀的-Controller-层逻辑" class="headerlink" title="一个优秀的 Controller 层逻辑"></a><strong>一个优秀的 Controller 层逻辑</strong></h2><blockquote><p>说到 Controller，相信大家都不陌生，它可以很方便地对外提供数据接口。它的定位，我认为是「不可或缺的配角」。<br>说它不可或缺是因为无论是传统的三层架构还是现在的 COLA 架构，Controller 层依旧有一席之地，说明他的必要性。<br>说它是配角是因为 Controller 层的代码一般是不负责具体的逻辑业务逻辑实现，但是它负责接收和响应请求。</p></blockquote><p><strong>从现状看问题</strong></p><p>Controller 主要的工作有以下几项：</p><ul><li>接收请求并解析参数</li><li>调用 Service 执行具体的业务代码（可能包含参数校验）</li><li>捕获业务逻辑异常做出反馈</li><li>业务逻辑执行成功做出响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Service</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">service</span><span class="params">(TestDTO testDTO)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getNum() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;输入的数字需要大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getType().equals(<span class="string">&quot;square&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(testDTO.getNum(), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (testDTO.getType().equals(<span class="string">&quot;factorial&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> testDTO.getNum();</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                result = result * num;</span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;未识别的算法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> TestDTO testDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.testService.service(testDTO);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> DTOid <span class="title function_">setTestService</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果真的按照上面所列的工作项来开发 Controller 代码会有几个问题：</p><ul><li>参数校验过多地耦合了业务代码，违背单一职责原则</li><li>可能在多个业务中都抛出同一个异常，导致代码重复</li><li>各种异常反馈和成功响应格式不统一，接口对接不友好</li></ul><h2 id="改造-Controller-层逻辑"><a href="#改造-Controller-层逻辑" class="headerlink" title="改造 Controller 层逻辑"></a><strong>改造 Controller 层逻辑</strong></h2><h4 id="统一返回结构"><a href="#统一返回结构" class="headerlink" title="统一返回结构"></a>统一返回结构</h4><p>统一返回值类型无论项目前后端是否分离都是非常必要的，方便对接接口的开发人员更加清晰地知道这个接口的调用是否成功（不能仅仅简单地看返回值是否为 null 就判断成功与否，因为有些接口的设计就是如此）。</p><p>使用一个状态码、状态信息就能清楚地了解接口调用情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义返回数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line">    Integer <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用结果的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultEnum</span> <span class="keyword">implements</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line">    SUCCESS(<span class="number">2001</span>, <span class="string">&quot;接口调用成功&quot;</span>),</span><br><span class="line">    VALIDATE_FAILED(<span class="number">2002</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line">    COMMON_FAILED(<span class="number">2003</span>, <span class="string">&quot;接口调用失败&quot;</span>),</span><br><span class="line">    FORBIDDEN(<span class="number">2004</span>, <span class="string">&quot;没有权限访问资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set方法和构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一返回数据结构</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(String message, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), message, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.COMMON_FAILED.getCode(), ResultEnum.COMMON_FAILED.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(String message) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.COMMON_FAILED.getCode(), message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(IResult errorResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(errorResult.getCode(), errorResult.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">instance</span><span class="params">(Integer code, String message, T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一返回结构后，在 Controller 中就可以使用了，但是每一个 Controller 都写这么一段最终封装的逻辑，这些都是很重复的工作，所以还要继续想办法进一步处理统一返回结构。</p><h4 id="统一包装处理"><a href="#统一包装处理" class="headerlink" title="统一包装处理"></a>统一包装处理</h4><p>Spring 中提供了一个类 ResponseBodyAdvice ，能帮助我们实现上述需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> T body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResponseBodyAdvice 是对 Controller 返回的内容在 HttpMessageConverter 进行类型转换之前拦截，进行相应的处理操作后，再将结果返回给客户端。</p><p>那这样就可以把统一包装的工作放到这个类里面：</p><ul><li><strong>supports：</strong> 判断是否要交给 beforeBodyWrite 方法执行，ture：需要；false：不需要</li><li><strong>beforeBodyWrite：</strong> 对 response 进行具体的处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果引入了swagger或knife4j的文档生成组件，这里需要仅扫描自己项目的包，否则文档无法正常生成</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.example.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要进行封装的，可以添加一些校验手段，比如添加标记排除的注解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供一定的灵活度，如果body已经被包装了，就不进行包装</span></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Result) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样改造，既能实现对 Controller 返回的数据进行统一包装，又不需要对原有代码进行大量的改动。</p><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>Java API 的规范 JSR303 定义了校验的标准 validation-api ，其中一个比较出名的实现是 hibernate validation。</p><p>spring validation 是对其的二次封装，常用于 SpringMVC 的参数自动校验，参数校验的代码就不需要再与业务逻辑代码进行耦合了。</p><h4 id="①-PathVariable-和-RequestParam-参数校验"><a href="#①-PathVariable-和-RequestParam-参数校验" class="headerlink" title="①@PathVariable 和 @RequestParam 参数校验"></a><strong>①@PathVariable 和 @RequestParam 参数校验</strong></h4><p>Get 请求的参数接收一般依赖这两个注解，但是处于 url 有长度限制和代码的可维护性，超过 5 个参数尽量用实体来传参。</p><p>对 @PathVariable 和 @RequestParam 参数进行校验需要在入参声明约束的注解。</p><p>如果校验失败，会抛出 MethodArgumentNotValidException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(value = &quot;prettyTestController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pretty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;num&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable(&quot;num&quot;)</span> <span class="meta">@Min(1)</span> <span class="meta">@Max(20)</span> Integer num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getByEmail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestDTO <span class="title function_">getByAccount</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@NotBlank</span> <span class="meta">@Email</span> String email)</span> &#123;</span><br><span class="line">        <span class="type">TestDTO</span> <span class="variable">testDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestDTO</span>();</span><br><span class="line">        testDTO.setEmail(email);</span><br><span class="line">        <span class="keyword">return</span> testDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestService</span><span class="params">(TestService prettyTestService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = prettyTestService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a><strong>校验原理</strong></h4><p>在 SpringMVC 中，有一个类是 RequestResponseBodyMethodProcessor，这个类有两个作用（实际上可以从名字上得到一点启发）</p><ul><li>用于解析 @RequestBody 标注的参数</li><li>处理 @ResponseBody 标注方法的返回值</li></ul><p>解析 @RequestBoyd 标注参数的方法是 resolveArgument。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverterMethodProcessor</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment">     * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment">     * converter to read the content with.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">      parameter = parameter.nestedIfOptional();</span><br><span class="line">      <span class="comment">//把请求数据封装成标注的DTO对象</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">        <span class="keyword">if</span> (arg != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//执行数据校验</span></span><br><span class="line">          validateIfApplicable(binder, parameter);</span><br><span class="line">          <span class="comment">//如果校验不通过，就抛出MethodArgumentNotValidException异常</span></span><br><span class="line">          <span class="comment">//如果我们不自己捕获，那么最终会由DefaultHandlerExceptionResolver捕获处理</span></span><br><span class="line">          <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentNotValidException</span>(parameter, binder.getBindingResult());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mavContainer != <span class="literal">null</span>) &#123;</span><br><span class="line">          mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessageConverterMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Validate the binding target if applicable.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation checks for &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.validation.Valid&#125;,</span></span><br><span class="line"><span class="comment">    * Spring&#x27;s &#123;<span class="doctag">@link</span> org.springframework.validation.annotation.Validated&#125;,</span></span><br><span class="line"><span class="comment">    * and custom annotations whose name starts with &quot;Valid&quot;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> binder the DataBinder to be used</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parameter the method parameter descriptor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1.5</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isBindExceptionRequired</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数上的所有注解</span></span><br><span class="line">      Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">      <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">      <span class="comment">//如果注解中包含了@Valid、@Validated或者是名字以Valid开头的注解就进行参数校验</span></span><br><span class="line">         Object[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);</span><br><span class="line">         <span class="keyword">if</span> (validationHints != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//实际校验逻辑，最终会调用Hibernate Validator执行真正的校验</span></span><br><span class="line">        <span class="comment">//所以Spring Validation是对Hibernate Validation的二次封装</span></span><br><span class="line">            binder.validate(validationHints);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-RequestBody-参数校验"><a href="#②-RequestBody-参数校验" class="headerlink" title="②@RequestBody 参数校验"></a><strong>②@RequestBody 参数校验</strong></h4><p>Post、Put 请求的参数推荐使用 @RequestBody 请求体参数。</p><p>对 @RequestBody 参数进行校验需要在 DTO 对象中加入校验条件后，再搭配 @Validated 即可完成自动校验。</p><p>如果校验失败，会抛出 ConstraintViolationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Controller</span></span><br><span class="line"><span class="meta">@RestController(value = &quot;prettyTestController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pretty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test-validation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testValidation</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> TestDTO testDTO)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService.save(testDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestService</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="校验原理-1"><a href="#校验原理-1" class="headerlink" title="校验原理"></a><strong>校验原理</strong></h4><p>声明约束的方式，注解加到了参数上面，可以比较容易猜测到是使用了 AOP 对方法进行增强。</p><p>而实际上 Spring 也是通过 MethodValidationPostProcessor 动态注册 AOP 切面，然后使用 MethodValidationInterceptor 对切点方法进行织入增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定了创建切面的Bean的注解</span></span><br><span class="line">   <span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; validatedAnnotationType = Validated.class;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//为所有@Validated标注的Bean创建切面</span></span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(<span class="built_in">this</span>.validatedAnnotationType, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建Advisor进行增强</span></span><br><span class="line">        <span class="built_in">this</span>.advisor = <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, createMethodValidationAdvice(<span class="built_in">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Advice，本质就是一个方法拦截器</span></span><br><span class="line">    <span class="keyword">protected</span> Advice <span class="title function_">createMethodValidationAdvice</span><span class="params">(<span class="meta">@Nullable</span> Validator validator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">MethodValidationInterceptor</span>(validator) : <span class="keyword">new</span> <span class="title class_">MethodValidationInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//无需增强的方法，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] groups = determineValidationGroups(invocation);</span><br><span class="line">        <span class="type">ExecutableValidator</span> <span class="variable">execVal</span> <span class="operator">=</span> <span class="built_in">this</span>.validator.forExecutables();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodToValidate</span> <span class="operator">=</span> invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//方法入参校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">             <span class="comment">//所以Spring Validation是对Hibernate Validation的二次封装</span></span><br><span class="line">            result = execVal.validateParameters(</span><br><span class="line">                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验不通过抛出ConstraintViolationException异常</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Controller方法调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="comment">//下面是对返回值做校验，流程和上面大概一样</span></span><br><span class="line">        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstraintViolationException</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③自定义校验规则"><a href="#③自定义校验规则" class="headerlink" title="③自定义校验规则"></a><strong>③自定义校验规则</strong></h4><p>有些时候 JSR303 标准中提供的校验规则不满足复杂的业务需求，也可以自定义校验规则。</p><p>自定义校验规则需要做两件事情：</p><ul><li>自定义注解类，定义错误信息和一些其他需要的内容</li><li>注解校验器，定义判定规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义注解类</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = MobileValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Mobile &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验不通过返回的提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;不是一个手机号码格式&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constraint要求的属性，用于分组校验和扩展，留空就好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解校验器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Mobile, CharSequence&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[34578][0-9]&#123;9&#125;$&quot;</span>); <span class="comment">// 验证手机号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在验证开始前调用注解里的方法，从而获取到一些注解里的参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constraintAnnotation annotation instance for a given constraint declaration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Mobile constraintAnnotation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.required = constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断参数是否合法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   object to validate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(CharSequence value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.required) &#123;</span><br><span class="line">            <span class="comment">// 验证</span></span><br><span class="line">            <span class="keyword">return</span> isMobile(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line">            <span class="comment">// 验证</span></span><br><span class="line">            <span class="keyword">return</span> isMobile(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMobile</span><span class="params">(<span class="keyword">final</span> CharSequence str)</span> &#123;</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> pattern.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动校验参数真的是一项非常必要、非常有意义的工作。JSR303 提供了丰富的参数校验规则，再加上复杂业务的自定义校验规则，完全把参数校验和业务逻辑解耦开，代码更加简洁，符合单一职责原则。</p><h4 id="自定义异常与统一拦截异常"><a href="#自定义异常与统一拦截异常" class="headerlink" title="自定义异常与统一拦截异常"></a><strong>自定义异常与统一拦截异常</strong></h4><p>原来的代码中可以看到有几个问题：</p><ul><li>抛出的异常不够具体，只是简单地把错误信息放到了 Exception 中</li><li>抛出异常后，Controller 不能具体地根据异常做出反馈</li><li>虽然做了参数自动校验，但是异常返回结构和正常返回结构不一致</li></ul><p>自定义异常是为了后面统一拦截异常时，对业务中的异常有更加细颗粒度的区分，拦截时针对不同的异常作出不同的响应。</p><p>而统一拦截异常的目的一个是为了可以与前面定义下来的统一包装返回结构能对应上，另一个是我们希望无论系统发生什么异常，Http 的状态码都要是 200 ，尽可能由业务来区分系统的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForbiddenException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForbiddenException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一拦截异常</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.example.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获 &#123;<span class="doctag">@code</span> BusinessException&#125; 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;BusinessException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleBusinessException(BusinessException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获 &#123;<span class="doctag">@code</span> ForbiddenException&#125; 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ForbiddenException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleForbiddenException(ForbiddenException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.FORBIDDEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; 参数校验不通过时抛出的异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> ex.getBindingResult();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;校验失败:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            sb.append(fieldError.getField()).append(<span class="string">&quot;：&quot;</span>).append(fieldError.getDefaultMessage()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(msg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@PathVariable</span>&#125; 和 &#123;<span class="doctag">@code</span> <span class="doctag">@RequestParam</span>&#125; 参数校验不通过时抛出的异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleConstraintViolationException(ConstraintViolationException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(ex.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶级异常捕获并统一处理，当其他异常无法处理时候选择使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handle(Exception ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>做好了这一切改动后，可以发现 Controller 的代码变得非常简洁，可以很清楚地知道每一个参数、每一个 DTO 的校验规则，可以很明确地看到每一个 Controller 方法返回的是什么数据，也可以方便每一个异常应该如何进行反馈。</p><p>这一套操作下来后，我们能更加专注于业务逻辑的开发，代码简介、功能完善，何乐而不为呢？</p><blockquote><p>转自：gelald</p><p>链接：<a href="https://juejin.cn/post/7123091045071454238">https://juejin.cn/post/7123091045071454238</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个优秀的-Controller-层逻辑&quot;&gt;&lt;a href=&quot;#一个优秀的-Controller-层逻辑&quot; class=&quot;headerlink&quot; title=&quot;一个优秀的 Controller 层逻辑&quot;&gt;&lt;/a&gt;&lt;strong&gt;一个优秀的 Controller 层</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>这个MySQL bug 99% 的人会踩坑！</title>
    <link href="http://ai.mak.cn/2022/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20bug%2099%%20%E7%9A%84%E4%BA%BA%E4%BC%9A%E8%B8%A9%E5%9D%91/"/>
    <id>http://ai.mak.cn/2022/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%20MySQL%20bug%2099%%20%E7%9A%84%E4%BA%BA%E4%BC%9A%E8%B8%A9%E5%9D%91/</id>
    <published>2022-07-21T16:00:00.000Z</published>
    <updated>2023-01-14T10:31:21.889Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于码海 ，作者坤哥</p><p>最近收到一个 Sentry 报警，如下 SQL 查询超时了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from order_info where uid = 5837661 order by id asc limit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行 show create table order_info 发现这个表其实是有加索引的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `order_info` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `uid` int(11) unsigned,  `order_status` tinyint(3) DEFAULT NULL,  ... 省略其它字段和索引  PRIMARY KEY (`id`),  KEY `idx_uid_stat` (`uid`,`order_status`),) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理论上执行上述 SQL 会命中 idx_uid_stat 这个索引，但实际执行 explain 查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain select * from order_info where uid = 5837661 order by id asc limit 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到它的 possible_keys（此 SQL 可能涉及到的索引） 是 idx_uid_stat，但实际上（key）用的却是全表扫描。</p><p><img src="https://aimak.cn/blog_img/dbinfo/possible_keys.jpeg"></p><p>我们知道 MySQL 是基于成本来选择是基于全表扫描还是选择某个索引来执行最终的执行计划的，所以看起来是全表扫描的成本小于基于 idx_uid_stat 索引执行的成本。</p><p>不过我的第一感觉很奇怪，这条 SQL 虽然是回表，但它的 limit 是 1。也就是说只选择了满足 uid &#x3D; 5837661 中的其中一条语句，就算回表也只回一条记录，这种成本几乎可以忽略不计，优化器怎么会选择全表扫描呢。</p><p>为了查看 MySQL 优化器为啥选择了全表扫描，我打开了 optimizer_trace 来一探究竟。</p><p>画外音：在MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。</p><p>使用 optimizer_trace 的具体过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;        // 打开 optimizer_traceSELECT * FROM order_info where uid = 5837661 order by id asc limit 1SELECT * FROM information_schema.OPTIMIZER_TRACE;    // 查看执行计划表SET optimizer_trace=&quot;enabled=off&quot;; // 关闭 optimizer_trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MySQL 优化器首先会计算出全表扫描的成本，然后选出该 SQL 可能涉及到的所有索引并且计算索引的成本，然后选出所有成本最小的那个来执行。</p><p>来看下 optimizer trace 给出的关键信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;rows_estimation&quot;: [    &#123;      &quot;table&quot;: &quot;`rebate_order_info`&quot;,      &quot;range_analysis&quot;: &#123;        &quot;table_scan&quot;: &#123;          &quot;rows&quot;: 21155996,          &quot;cost&quot;: 4.45e6    // 全表扫描成本        &#125;      &#125;,      ...      &quot;analyzing_range_alternatives&quot;: &#123;          &quot;range_scan_alternatives&quot;: [          &#123;            &quot;index&quot;: &quot;idx_uid_stat&quot;,            &quot;ranges&quot;: [            &quot;5837661 &lt;= uid &lt;= 5837661&quot;            ],            &quot;index_dives_for_eq_ranges&quot;: true,            &quot;rowid_ordered&quot;: false,            &quot;using_mrr&quot;: false,            &quot;index_only&quot;: false,            &quot;rows&quot;: 255918,            &quot;cost&quot;: 307103,            // 使用idx_uid_stat索引的成本            &quot;chosen&quot;: true            &#125;          ],       &quot;chosen_range_access_summary&quot;: &#123;    // 经过上面的各个成本比较后选择的最终结果         &quot;range_access_plan&quot;: &#123;             &quot;type&quot;: &quot;range_scan&quot;,             &quot;index&quot;: &quot;idx_uid_stat&quot;,  // 可以看到最终选择了idx_uid_stat这个索引来执行             &quot;rows&quot;: 255918,             &quot;ranges&quot;: [             &quot;58376617 &lt;= uid &lt;= 58376617&quot;             ]         &#125;,         &quot;rows_for_plan&quot;: 255918,         &quot;cost_for_plan&quot;: 307103,         &quot;chosen&quot;: true         &#125;         &#125;      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，全表扫描的成本是 <strong>4.45e6</strong>，而选择索引 idx_uid_stat 的成本是 <strong>307103</strong>，远小于全表扫描的成本。而且从最终的选择结果（chosen_range_access_summary）来看，<strong>确实也是选择了 idx_uid_stat 这个索引</strong>。</p><p>但为啥从 explain 看到的选择是执行 PRIMARY 也就是全表扫描呢？难道这个执行计划有误？</p><p>仔细再看了一下这个执行计划，果然发现了猫腻。</p><p>执行计划中有一个 reconsidering_access_paths_for_index_ordering 选择引起了我的注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;    &quot;clause&quot;: &quot;ORDER BY&quot;,    &quot;index_order_summary&quot;: &#123;      &quot;table&quot;: &quot;`rebate_order_info`&quot;,      &quot;index_provides_order&quot;: true,      &quot;order_direction&quot;: &quot;asc&quot;,      &quot;index&quot;: &quot;PRIMARY&quot;,    // 可以看到选择了主键索引      &quot;plan_changed&quot;: true,      &quot;access_type&quot;: &quot;index_scan&quot;        &#125;    &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个选择表示：由于排序的原因<strong>再进行了一次索引选择优化</strong>。</p><p>由于我们的 SQL 使用了 id 排序（order by id asc limit 1），优化器最终选择了 PRIMARY 也就是全表扫描来执行。也就是说这个选择会无视之前的基于索引成本的选择。</p><p>为什么会有这样的一个选项呢？</p><p>主要原因如下：</p><p>The short explanation is that the optimizer thinks — or should I say hopes — that scanning the whole table (which is already sorted by the id field) will find the limited rows quick enough, and that this will avoid a sort operation. So by trying to avoid a sort, the optimizer ends-up losing time scanning the table.</p><p>从这段解释可以看出，主要原因是由于我们使用了 order by id asc 这种基于 id 的排序写法，优化器认为排序是个昂贵的操作，所以为了避免排序，并且它认为 limit n 的 n 如果很小的话即使使用全表扫描也能很快执行完，所以它选择了全表扫描。也就避免了 id 的排序（全表扫描其实就是基于 id 主键的聚簇索引的扫描，本身就是基于 id 排好序的）。</p><p>如果这个选择是对的那也罢了，然而实际上<strong>这个优化却是有 bug 的</strong>！实际选择 idx_uid_stat 执行会快得多（只要 28 ms）！</p><p>网上有不少人反馈这个问题，而且出现这个问题基本只与 SQL 中出现 order by id asc limit n 这种写法有关。如果 n 比较小很大概率会走全表扫描，如果 n 比较大则会选择正确的索引。</p><p>这个 bug 最早追溯到 2014 年，不少人都呼吁官方及时修正这个 bug。可能是实现比较困难，直到 MySQL 5.7，8.0 都还没解决，所以在官方修复前我们要尽量避免这种写法，如果一定要用这种写法，怎么办呢？</p><p><strong>主要有两种方案</strong></p><p><strong>1. 使用 force index 来强制使用指定的索引。</strong></p><p>如下：</p><p>- </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from order_info force index(idx_uid_stat) where uid = 5837661 order by id asc limit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种写法虽然可以，但不够优雅，如果这个索引被废弃了咋办？于是有了第二种比较优雅的方案。</p><ol start="2"><li>使用 order by (id+0) 方案。</li></ol><p>如下：</p><p>- </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from order_info where uid = 5837661 order by (id+0) asc limit 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方案也可以让优化器选择正确的索引，更推荐！</p><p>为什么这个 trick 可以呢？因为此 SQL 虽然是按 id 排序的，但在 id 上作了加法这样耗时的操作（虽然只是加个无用的 0，但足以骗过优化器），优化器认为此时基于全表扫描会更耗性能，于是会选择基于成本大小的方式来选择索引。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下文章来源于码海 ，作者坤哥&lt;/p&gt;
&lt;p&gt;最近收到一个 Sentry 报警，如下 SQL 查询超时了。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="数据库" scheme="http://ai.mak.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="http://ai.mak.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何用更少的内存保存更多的数据？</title>
    <link href="http://ai.mak.cn/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://ai.mak.cn/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%20%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2023-01-14T14:13:49.292Z</updated>
    
    <content type="html"><![CDATA[<p>我们应该从 Redis 是如何保存数据的原理展开，分析键值对的存储结构和原理。</p><p>从而继续延展出每种数据类型底层的数据结构，针对不同场景使用更恰当的数据结构和编码实现更少的内存占用。</p><p>为了保存数据， Redis 需要先申请内存，数据过期或者内存淘汰需要回收内存，从而拓展出内存碎片优化。</p><p>最后，说下 key、value 使用规范和技巧、 Bitmap 等高阶数据类型，运用这些技巧巧妙解决有限内存去存储更多数据难题……</p><p>这一套组合拳下来直接封神。</p><p>主要优化神技如下：</p><ul><li>键值对优化；</li><li>小数据集合的编码优化；</li><li>使用对象共享池；</li><li>使用 Bit 比特位或 byte 级别操作</li><li>使用 hash 类型优化；</li><li>内存碎片优化；</li><li>使用 32 位的 Redis。</li></ul><p>在优化之前，我们先掌握 Redis 是如何存储数据的。</p><p>Redis 如何存储键值对</p><p>Redis 以 redisDb为中心存储，redis 7.0 源码在 <a href="https://github.com/redis/redis/blob/7.0/src/server.h%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/server.h：</a></p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936798/1000"></p><p>redisDb</p><p><strong>dict：</strong> 最重要的属性之一，就是靠这个定义了保存了对象数据键值对，dcit 的底层结构是一个哈希表。</p><p><strong>expires：</strong> 保存着所有 key 的过期信息.</p><p>blocking_keys 和 ready_keys 主要为了实现 BLPOP 等阻塞命令</p><p>watched_keys用于实现watch命令，记录正在被watch的一些key，与事务相关。</p><p>id 为当前数据库的id，redis 支持单个服务多数据库，默认有16个；</p><p>clusterSlotToKeyMapping：cluster 模式下，存储key 与哈希槽映射关系的数组。</p><p>Redis 使用「dict」结构来保存所有的键值对（key-value）数据，这是一个全局哈希表，所以对 key 的查询能以 O(1) 时间得到。</p><p>所谓哈希表，我们可以类比 Java 中的 HashMap，其实就是一个数组，数组的每个元素叫做哈希桶。</p><p><strong>dict 结构如下，源码在 <a href="https://github.com/redis/redis/blob/7.0/src/dict.h%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/dict.h：</a></strong></p><p>struct dict {</p><p>&#x2F;&#x2F; 特定类型的处理函数</p><p>dictType *type;</p><p>&#x2F;&#x2F; 两个全局哈希表指针数组，与渐进式 rehash 有关</p><p>dictEntry **ht_table[2];</p><p>&#x2F;&#x2F; 记录 dict 中现有的数据个数。</p><p>unsigned long ht_used[2];</p><p>&#x2F;&#x2F; 记录渐进式 rehash 进度的标志， -1 表示当前没有执行 rehash</p><p>long rehashidx;</p><p>&#x2F;&#x2F; 小于 0 表示 rehash 暂停</p><p>int16_t pauserehash;</p><p>signed char ht_size_exp[2];</p><p>};</p><p>dictType：存储了hash函数，key和value的复制等函数；</p><p>ht_table：长度为 2 的 数组，正常情况使用 ht_table[0] 存储数据，当执行 rehash 的时候，使用 ht_table[1] 配合完成 。</p><p>key 的哈希值最终会映射到 ht_table 的一个位置，如果发生哈希冲突，则拉出一个哈希链表。</p><p>大家重点关注 dictEntry 类型的 ht_table，ht_table 数组每个位置我们也叫做<strong>哈希桶</strong>，就是这玩意保存了所有键值对。</p><p>❝</p><p>码哥，Redis 支持那么多的数据类型，哈希桶咋保存？</p><p>哈希桶的每个元素的结构由 dictEntry 定义：</p><p>typedef struct dictEntry {</p><p>&#x2F;&#x2F; 指向 key 的指针</p><p>void *key;</p><p>union {</p><p>&#x2F;&#x2F; 指向实际 value 的指针</p><p>void *val;</p><p>uint64_t u64;</p><p>int64_t s64;</p><p>double d;</p><p>} v;</p><p>&#x2F;&#x2F; 哈希冲突拉出的链表</p><p>struct dictEntry *next;</p><p>} dictEntry;</p><p>key 指向键值对的键的指针，key 都是 string 类型。</p><p>value是个 union（联合体）当它的值是 uint64_t、int64_t 或 double 类型时，就不再需要额外的存储，这有利于减少内存碎片。（为了节省内存操碎了心）当然，<strong>val 也可以是 void 指针，指向值的指针，以便能存储任何类型的数据。</strong></p><p>next指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， ht_table 使用链地址法来处理键碰撞：<strong>当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。</strong></p><p><strong>哈希桶并没有保存值本身，而是指向具体值的指针，从而实现了哈希桶能存不同数据类型的需求</strong>。</p><p>而哈希桶中，键值对的值都是由一个叫做 redisObject 的对象定义，源码地址：<a href="https://github.com/redis/redis/blob/7.0/src/server.h%E3%80%82">https://github.com/redis/redis/blob/7.0/src/server.h。</a></p><p>typedef struct redisObject {</p><p>unsigned type:4;</p><p>unsigned encoding:4;</p><p>unsigned lru:LRU_BITS;</p><p>int refcount;</p><p>void *ptr;</p><p>} robj;</p><p><strong>type</strong>：记录了对象的类型，string、set、hash 、Lis、Sorted Set 等，根据该类型才可以确定是哪种数据类型，使用什么样的 API 操作。</p><p><strong>encoding</strong>：编码方式，<strong>表示 ptr 指向的数据类型具体数据结构，即这个对象使用了什么数据结构作为底层实现</strong>保存数据。<strong>同一个对象使用不同编码实现内存占用存在明显差异，内部编码对内存优化非常重要。</strong></p><p>lru:LRU_BITS：LRU 策略下对象最后一次被访问的时间，如果是 LFU 策略，那么低 8 位表示访问频率，高 16 位表示访问时间。</p><p>refcount ：表示引用计数，由于 C 语言并不具备内存回收功能，所以 Redis 在自己的对象系统中添加了这个属性，当一个对象的引用计数为 0 时，则表示该对象已经不被任何对象引用，则可以进行垃圾回收了。</p><p>ptr 指针：指向对象的底层实现数据结构，指向<strong>值的指针</strong>。</p><p>如下图是由 redisDb、dict、dictEntry、redisObejct 关系图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936802/1000" alt="img"></p><p>redis存储结构</p><p>「码哥」再唠叨几句，void *key 和 void *value 指针指向的是<strong>redisObject</strong>，Redis 中每个对象都是用 redisObject 表示。</p><p>知道了 Redis 存储原理以及不同数据类型的存储数据结构后，我们继续看如何做性能优化。</p><ol><li>键值对优化</li></ol><p>当我们执行 set key value 的命令，*key指针指向 SDS 字符串保存 key，而 value 的值保存在 *ptr 指针指向的数据结构，消耗的内存：key + value。</p><p>第一个优化神技：<strong>降低 Redis 内存使用的最粗暴的方式就是缩减键（key）与值（value）的长度。</strong></p><p>在《Redis 很强，不懂使用规范就糟蹋了》中我说过关于键值对的使用规范，对于 key 的命名使用「业务模块名:表名:数据唯一id」这样的方式方便定位问题。</p><p>比如：users:firends:996 表示用户系统中，id &#x3D; 996 的朋友信息。我们可以简写为：u:fs:996</p><p><strong>对于 key 的优化：使用单词简写方式优化内存占用。</strong></p><p>对于 value 的优化那就更多了：</p><p><strong>过滤不必要的数据</strong>：不要大而全的一股脑将所有信息保存，想办法去掉一些不必要的属性，比如缓存登录用户的信息，通常只需要存储昵称、性别、账号等。</p><p><strong>精简数据</strong>：比如用户的会员类型：0 表示「屌丝」、1 表示 「VIP」、2表示「VVIP」。而不是存储 VIP 这个字符串。</p><p><strong>数据压缩：</strong> 对数据的内容进行压缩，比如使用 GZIP、Snappy。</p><p><strong>使用性能好，内存占用小的序列化方式</strong>。比如 Java 内置的序列化不管是速度还是压缩比都不行，我们可以选择 protostuff，kryo等方式。如下图 Java 常见的序列化工具空间压缩比：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936794/1000"></p><p>序列化工具压缩比</p><p>❝</p><p>靓仔们，我们通常使用 json 作为字符串存储在 Redis，用 json 存储与二进制数据存储有什么优缺点呢？</p><p>json 格式的优点：方便调试和跨语言；缺点是：同样的数据相比字节数组占用的空间更大。</p><p>一定要 json 格式的话，那就先通过压缩算法压缩 json，再把压缩后的数据存入 Redis。比如 GZIP 压缩后的 json 可降低约 60% 的空间。</p><ol start="2"><li>小数据集合编码优化</li></ol><p>key 对象都是 string 类型，value 对象主要有五种基本数据类型：String、List、Set、Zset、Hash。</p><p>数据类型与底层数据结构的关系如下所示：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936797/1000" alt="img"></p><p>编码与数据结构</p><p>特别说明下在最新版（非稳定版本，时间 2022-7-3），<strong>ziplist 压缩列表由 quicklist 代替（3.2 版本引入），而双向链表由 listpack 代替。</strong></p><p><strong>另外，同一数据类型会根据键的数量和值的大小也有不同的底层编码类型实现。</strong></p><p>在 Redis 2.2 版本之后，存储集合数据（Hash、List、Set、SortedSet）在满足某些情况下会采用内存压缩技术来实现使用更少的内存存储更多的数据。</p><p><strong>当这些集合中的数据元素数量小于某个值且元素的值占用的字节大小小于某个值的时候，存储的数据会用非常节省内存的方式进行编码，理论上至少节省 10 倍以上内存（平均节省 5 倍以上）。</strong></p><p>比如 Hash 类型里面的数据不是很多，虽然哈希表的时间复杂度是 O(1)，ziplist 的时间复杂度是 O(n)，但是使用 ziplist 保存数据的话会节省了内存，并且在少量数据情况下效率并不会降低很多。</p><p><strong>所以我们需要尽可能地控制集合元素数量和每个元素的内存大小，这样能充分利用紧凑型编码减少内存占用。</strong></p><p>并且，这些编码对用户和 api 是无感知的，当集合数据超过配置文件的配置的最大值， Redis 会自动转成正常编码。</p><p>❝</p><p>数据类型对应的编码规则如下所示</p><p>String 字符串</p><p>int：整数且数字长度小于 20，直接保存在 *ptr 中。</p><p>embstr：开辟一块连续分配的内存（字符串长度小于等于 44 字节）。</p><p>raw：动态字符串（大于 44 字节的字符串，同时字符串小于 512 MB）。</p><p>List 列表</p><p>ziplist：元素个数小于hash-max-ziplist-entries配置，同时所有的元素的值大小都小于 hash-max-ziplist-value配置。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936799/1000" alt="img"></p><p>ziplist</p><p>linkedlist：3.0 版本之前当列表类型无法满足 ziplist 的条件时，Redis会使用 linkedlist 作为列表的内部实现。</p><p><strong>quicklist：Redis 3.2 引入，并作为 List 数据类型的底层实现，不再使用双端链表 linkedlist 和 ziplist 实现。</strong></p><p>Set 集合</p><p>intset 整数集合：元素都是整数，且元素个数小于 set-max-intset-entries配置</p><p>hashtable 哈希表：集合类型无法满足intset的条件时就会使用hashtable 编码。</p><p>Hash 哈希表</p><p>ziplist：元素个数小于 hash-max-ziplist-entries配置，同时任意一个 value 的占用字节大小都小于hash-max-ziplist-value 。</p><p>hashtable：hash 类型无法满足 intset 的条件时就会使用hashtable。</p><p>Sorted Set 有序集合</p><p>ziplist：元素个数小于 zset-max-ziplist-entries 同时每个元素的value小于&#96;&#96;zset-max-ziplist-value&#96;配置。</p><p>skiplist：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现。</p><p>以下是 Redis redis.conf 配置文件默认编码阈值配置：</p><p>hash-max-ziplist-entries 512</p><p>hash-max-ziplist-value 64</p><p>zset-max-ziplist-entries 128</p><p>zset-max-ziplist-value 64</p><p>set-max-intset-entries 512</p><p>下图是 reidsObject 对象的 type 和 encoding 对应关系图：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936804/1000" alt="img"></p><p>type 与编码</p><p>❝</p><p>码哥，为啥对一种数据类型实现多种不同编码方式？</p><p>主要原因是想通过不同编码实现效率和空间的平衡。</p><p>比如当我们的存储只有100个元素的列表，当使用双向链表数据结构时，需要维护大量的内部字段。</p><p>比如每个元素需要：前置指针，后置指针，数据指针等，造成空间浪费。</p><p>如果采用连续内存结构的压缩列表(ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为O(n) 性能也相差不大，因为 n 值小 与 O(1) 并明显差别。</p><p>数据编码优化技巧</p><p>ziplist 存储 list 时每个元素会作为一个 entry，存储 hash 时 key 和 value 会作为相邻的两个 entry。</p><p>存储 zset 时 member 和 score 会作为相邻的两个entry，当不满足上述条件时，ziplist 会升级为 linkedlist, hashtable 或 skiplist 编码。</p><p><strong>由于目前大部分Redis运行的版本都是在3.2以上，所以 List 类型的编码都是quicklist</strong>。</p><p><strong>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。</strong></p><p>考虑了综合平衡空间碎片和读写性能两个维度所以使用了新编码 quicklist。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936803/1000" alt="img"></p><p>ziplist 的不足</p><p>每次修改都可能触发 realloc 和 memcopy, 可能导致连锁更新(数据可能需要挪动)。</p><p>因此修改操作的效率较低，在 ziplist 的元素很多时这个问题更加突出。</p><p>优化手段：</p><p>key 尽量控制在 44 字节以内，走 embstr 编码。</p><p>集合类型的 value 对象的元素个数不要太多太大，充分利用 ziplist 编码实现内存压缩。</p><ol start="3"><li>对象共享池</li></ol><p>整数我们经常在工作中使用，Redis 在启动的时候默认生成一个<strong>0 ~9999 的整数对象共享池用于对象复用，减少内存占用</strong>。</p><p>比如执行set 码哥 18; set 吴彦祖 18; key 等于 「码哥」 和「吴彦祖」的 value 都指向同一个对象。</p><p>如果 value 可以使用整数表示的话尽可能使用整数，这样即使大量键值对的 value 大量保存了 0~9999 范围内的整数，在实例中，其实只有一份数据。</p><p><strong>靓仔们，有两个大坑需要注意，它会导致对象共享池失效。</strong></p><p><strong>Redis 中设置了 maxmemory 限制最大内存占用大小且启用了 LRU 策略（allkeys-lru 或 volatile-lru 策略）。</strong></p><p>❝</p><p>码哥，为啥呀？</p><p>因为 LRU 需要记录每个键值对的访问时间，都共享一个整数 对象，LRU 策略就无法进行统计了。</p><p>集合类型的编码采用 ziplist 编码，并且集合内容是整数，也不能共享一个整数对象。</p><p>❝</p><p>这又是为啥呢？</p><p>使用了 ziplist 紧凑型内存结构存储数据，判断整数对象是否共享的效率很低。</p><p>4.使用 Bit 比特位或 byte 级别操作</p><p>比如在一些「二值状态统计」的场景下使用 Bitmap 实现，对于网页 UV 使用 HyperLogLog 来实现，大大减少内存占用。</p><p>❝</p><p>码哥，什么是二值状态统计呀？</p><p>也就是集合中的元素的值只有 0 和 1 两种，在签到打卡和用户是否登陆的场景中，只需记录签到(1)或 未签到(0)，已登录(1)或未登陆(0)。</p><p>假如我们在判断用户是否登陆的场景中使用 Redis 的 String 类型实现（<strong>key -&gt; userId，value -&gt; 0 表示下线，1 - 登陆</strong>），假如存储 100 万个用户的登陆状态，如果以字符串的形式存储，就需要存储 100 万个字符串，内存开销太大。</p><p>String 类型除了记录实际数据以外，还需要额外的内存记录数据长度、空间使用等信息。</p><p>Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。</p><p>可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。</p><p>为了直观展示，我们可以理解成 buf 数组的每个字节用一行表示，每一行有 8 个 bit 位，8 个格子分别表示这个字节中的 8 个 bit 位，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936795/1000" alt="img"></p><p><strong>8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。</strong> 这就是 Bitmap 的优势。</p><p>关于 Bitmap 的详细解答，大家可移步 -&gt; 《Redis 实战篇：巧用 Bitmap 实现亿级数据统计》。</p><ol start="5"><li>妙用 Hash 类型优化</li></ol><p><strong>尽可能把数据抽象到一个哈希表里。</strong></p><p>比如说系统中有一个用户对象，我们不需要为一个用户的昵称、姓名、邮箱、地址等单独设置一个 key，而是将这个信息存放在一个哈希表里。</p><p>如下所示：</p><p>hset users:深圳:999 姓名 码哥</p><p>hset users:深圳:999 年龄 18</p><p>hset users:深圳:999 爱好 女</p><p>❝</p><p>为啥使用 String 类型，为每个属性设置一个 key 会占用大量内存呢？</p><p>因为 Redis 的数据类型有很多，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）。</p><p>所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，用 *prt 指针指向实际数据。</p><p><strong>当我们为每个属性都创建 key，就会创建大量的 redisObejct 对象占用内存。</strong></p><p>如下所示 redisObject 内存占用：</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15108936796/1000" alt="img"></p><p>redisObejct</p><p>用 Hash 类型的话，每个用户只需要设置一个 key。</p><ol start="6"><li>内存碎片优化</li></ol><p>Redis 释放的内存空间可能并不是连续的，这些不连续的内存空间很有可能处于一种闲置的状态。</p><p>虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。</p><p>比如， Redis 存储一个整形数字集合需要一块占用 32 字节的连续内存空间，当前虽然有 64 字节的空闲，但是他们都是不连续的，导致无法保存。</p><p>❝</p><p>内存碎片是如何形成呢？</p><p>两个层面原因导致：</p><p>操作系统内存分配机制：内存分配策略决定了无法做到按需分配。因为分配器是按照固定大小来分配内存。</p><p>键值对被修改和删除，从而导致内存空间的扩容和释放。</p><p>碎片优化可以降低内存使用率，提高访问效率，在4.0以下版本，我们只能使用重启恢复：重启加载 RDB 或者通过高可用主从切换实现数据的重新加载减少碎片。</p><p>在4.0以上版本，Redis提供了自动和手动的碎片整理功能，原理大致是把数据拷贝到新的内存空间，然后把老的空间释放掉，这个是有一定的性能损耗的。</p><p>因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法处理请求，性能就会降低。</p><p>手动整理碎片</p><p>执行 memory purge命令即可。</p><p>自动整理内存碎片</p><p>使用 config set activedefrag yes 指令或者在 redis.conf 配置 activedefrag yes 将 activedefrag 配置成 yes 表示启动自动清理功能。</p><p>这个配置还不够，至于啥时候清理还需要看下面的两个配置：</p><p>active-defrag-ignore-bytes 200mb：内存碎片的大小达到 200MB，开始清理。</p><p>active-defrag-threshold-lower 6：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 6% 时，开始清理。</p><p>只有满足这两个条件， Redis 才会执行内存碎片自动清理。</p><p>除此之外，Redis 为了防止清理碎片对 Redis 正常处理指令造成影响，有两个参数用于控制清理操作占用 CPU 的时间比例上下限。</p><p>active-defrag-cycle-min 15：自动清理过程所用 CPU 时间的比例不低于 15%，保证清理能有效展开。</p><p>active-defrag-cycle-max 50：表示自动清理过程所用 CPU 时间的比例不能大于 50%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis执行命令。</p><ol start="7"><li>使用 32 位的 Redis</li></ol><p>使用32位的redis，对于每一个key,将使用更少的内存，因为32位程序，指针占用的字节数更少。</p><p>但是32的Redis整个实例使用的内存将被限制在4G以下。我们可以通过 cluster 模式将多个小内存节点构成一个集群，从而保存更多的数据。</p><p>另外小内存的节点 fork 生成 rdb 的速度也更快。</p><p>RDB和AOF文件是不区分32位和64位的（包括字节顺序）,所以你可以使用64位的Redis 恢复32位的RDB备份文件，相反亦然。</p><p>参考文献[1]<a href="https://redis.io/docs/reference/optimization/memory-optimization/[2]%E3%80%8ARedis">https://redis.io/docs/reference/optimization/memory-optimization/[2]《Redis</a> 核心技术与实战》[3] <a href="https://segmentfault.com/a/1190000041771534">https://segmentfault.com/a/1190000041771534</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们应该从 Redis 是如何保存数据的原理展开，分析键值对的存储结构和原理。&lt;/p&gt;
&lt;p&gt;从而继续延展出每种数据类型底层的数据结构，针对不同场景使用更恰当的数据结构和编码实现更少的内存占用。&lt;/p&gt;
&lt;p&gt;为了保存数据， Redis 需要先申请内存，数据过期或者内存淘汰</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="缓存" scheme="http://ai.mak.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
</feed>
