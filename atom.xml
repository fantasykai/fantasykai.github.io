<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2022-10-20T23:00:30.187Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>三大成功定律：荷花定律，竹子定律，金蝉定律</title>
    <link href="http://ai.mak.cn/2019/02/21/%E6%9D%82%E8%AE%B0/%E4%B8%89%E5%A4%A7%E6%88%90%E5%8A%9F%E5%AE%9A%E5%BE%8B%EF%BC%9A%E8%8D%B7%E8%8A%B1%E5%AE%9A%E5%BE%8B%EF%BC%8C%E7%AB%B9%E5%AD%90%E5%AE%9A%E5%BE%8B%EF%BC%8C%E9%87%91%E8%9D%89%E5%AE%9A%E5%BE%8B/"/>
    <id>http://ai.mak.cn/2019/02/21/%E6%9D%82%E8%AE%B0/%E4%B8%89%E5%A4%A7%E6%88%90%E5%8A%9F%E5%AE%9A%E5%BE%8B%EF%BC%9A%E8%8D%B7%E8%8A%B1%E5%AE%9A%E5%BE%8B%EF%BC%8C%E7%AB%B9%E5%AD%90%E5%AE%9A%E5%BE%8B%EF%BC%8C%E9%87%91%E8%9D%89%E5%AE%9A%E5%BE%8B/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2022-10-20T23:11:52.102Z</updated>
    
    <content type="html"><![CDATA[<p>关于成功，有很多定律，比较有名的就是荷花定律、竹子定律和金蝉定律。</p><p>无论是荷花定律、竹子定律，还是金蝉定律，他们都有共同的意义：</p><p><strong>成功，需要厚积薄发</strong></p><p><strong>要忍受煎熬，要耐得住寂寞</strong></p><p><strong>坚持，坚持，再坚持</strong></p><p><strong>直到最后成功的那一刻</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/r5ibYXKmn8p1zaevfiaNExBsv2AMrCGVVQgHSc6EYrsDLVVdSicS8W5Ok6wMDVmqIlXUtpyzdUN93rqajBgPvsgPw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p> <strong>01</strong> </p><p><strong>荷花定律</strong></p><p>一个池塘里的荷花，每一天都会以前一天的2倍数量在开放。</p><p>如果到第30天，荷花就开满了整个池塘。</p><p>请问：<strong>在第几天池塘中的荷花开了一半？</strong></p><p><strong>第15天？错！是第29天。</strong></p><p>这就是荷花定律。</p><p>第一天开放的只是一小部分，第二天，它们会以前一天的两倍速度开放。</p><p>到第29天时荷花仅仅开满了一半，直到最后一天才会开满另一半。</p><p>也就是说：最后一天的速度最快，等于前29天的总和。</p><p>这就是著名的荷花定律。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SL01kv8vjY3HelNJDPP6027TiajaTdazGDFVFtAoua5Ao0Afu8oeVhZ0xImjwa7ibOz7XMrC914ahvibMDFaruRcw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这其中藏着深刻的道理就是：<strong>成功需要厚积薄发，需要积累沉淀。</strong></p><p>这个定律最早是听过马云的一个公开演讲，而透过这个定律去联想人生，你会发生，很多人的一生就像池塘里的荷花，一开始用力地开，玩命地开……</p><p>但渐渐的，人们开始感到枯燥甚至是厌烦，你可能在第9天、第19天甚至第29天的时候放弃了坚持。</p><p><strong>这时，这个时候的放弃，往往离成功只有一步之遥。</strong></p><p>甚至可以说大多时候，人能获得成功，关键在于毅力。</p><p>据说人这一生大概能遇到7次左右的机会，都是可以改变人生的机会，而这样的机会往往都是在前期日复一日的投入和坚持才能遇到这样的机会。</p><p>所以说，如果有梦想就要先动起来，然后坚定不移的去执行下去。</p><p> <strong>02</strong> </p><p><strong>竹子定律</strong></p><p>竹子用了4年的时间，仅仅长了3cm。</p><p>从第五年开始，以每天30cm的速度疯狂地生长，仅仅用了六周的时间，就长到了15米。</p><p>其实，在前面的四年，竹子将根在土壤里延伸了数百平米。</p><p>做人做事亦是如此。</p><p><strong>不要担心你此时此刻的付出得不到回报，因为这些付出都是为了扎根。</strong></p><p>人生需要储备，有多少人，没能熬过那三厘米？</p><p>什么叫价值？同是两根竹子，一支做成了笛子，一支做成了晾衣杠。</p><p>晾衣杠不服气的问笛子：“我们都是同一片山上的竹子，凭什么我天天日晒雨淋，不值一文，而你却价值千金呢？”</p><p>笛子回答说：“<strong>因为你只挨了一刀，而我却经历了千刀万剐，精雕细做。</strong>”</p><p>晾衣杠沉默了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SL01kv8vjY3HelNJDPP6027TiajaTdazGicZibwUm0QKJsE8atp1bEic3V0xtic0uQSag2ItibHJSVN3QfomEiaPibG3Hg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>人生亦是如此，经得起打磨，耐得起寂寞，扛得起责任，肩负起使命，人生才会有价值。</strong></p><p>看见别人辉煌的时候，不要嫉妒，因为别人付出的比你多。</p><blockquote><p>国学大师钱穆说：“古往今来有大成就者，诀窍无他，都是能人肯下笨劲。”</p><p>胡适也说：“这个世界聪明人太多，肯下笨功夫的人太少，所以成功者只是少数人。”</p></blockquote><p>说起钱钟书的满腹经纶，人们往往归功于他的天分高，记忆力强。</p><p>其实，钱钟书学问博大精深，更多来自后天手不释卷的苦功。</p><p>钱钟书大学同窗许振德这样描述：在校时，以一周读中文经典，一周阅欧美名著，交互行之，四年如一日。每赴图书馆借书还书，必怀抱五六巨册，且奔且驰。且阅毕一册，必作札记……</p><p><strong>代表他学术成就的《管锥编》，引述4000多位名家的上万种著作中的数万条书证，汪洋恣肆，博大精深。</strong></p><p>有些人可能不知道，他进入清华后，目标是“横扫清华图书馆”。</p><p>他的治学心得是：越是聪明人，越要懂得下笨功夫。</p><p>“心在一艺，其艺必工，一心在一职，其职必举”。</p><p><strong>成长不是一蹴而就的，哪有什么人生开挂，只不过是厚积薄发。</strong></p><p>这就叫竹子定律。</p><p> <strong>03</strong> </p><p><strong>金蝉定律</strong></p><p>蝉，要先在地下暗无天日的生活三年（有一种美国的蝉，要在地下生活17年），忍受各种寂寞和孤独，依靠树根的汁一点点长大。</p><p>然后在夏天的一个晚上，悄悄爬到树枝上，一夜之间蜕变成知了。</p><p>然后期待太阳升起的那一刻，它就可以飞向天空，冲向自由。</p><p>这就叫金蝉定律。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SL01kv8vjY3HelNJDPP6027TiajaTdazG7OqmoGTrL07cUkNcl1pFk3t9Ok5BcfWNf4Eo3xzBpKB2dQ73EWzKOQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p> <strong>04</strong> </p><p>很多人的一生就像池塘里的荷花，一开始用力盛开，但是总感觉自己绽放的不够，所以渐渐感到厌倦，在第10天、第20天、甚至第29天的时候，选择了放弃。</p><p>很多人的奋斗也像生长的竹子，一开始卯足了劲，但是由于前面的大部分阶段都在打基，所以成效并不那么明显，在第1年、第3年，甚至第4年的时候选择了放弃。</p><p>就更不用提蝉的淡定和坚守了。</p><p><strong>越接近成功越困难，越需要坚持。</strong></p><p>无论是事业还是人生，我们缺少的不是能力、技巧、模式，需要的是坚持和毅力，只有坚持量变，才能最后完成质变，才能突破成功的临界点，取得最后的成功。</p><p>马云曾说：“今天很残酷，明天更残酷，后天很美好，但是大多数人死在明天晚上，看不到后天的太阳。”</p><p>大部分人都是在离成功一步之遥却放弃了。</p><p>中国有句老话“<strong>行百里半九十</strong>”，就是说走一百里路，走九十里才算走了一半，因为很多人坚持到九十里就放弃了。</p><p>这些定律告诉我们这样一个道理：<strong>人拼到最后，拼的不是运气和聪明，而是毅力。</strong></p><p>来源：京博国学(ID: jingboguoxue)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于成功，有很多定律，比较有名的就是荷花定律、竹子定律和金蝉定律。&lt;/p&gt;
&lt;p&gt;无论是荷花定律、竹子定律，还是金蝉定律，他们都有共同的意义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功，需要厚积薄发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要忍受煎熬，要耐得住寂寞&lt;/st</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java性能优化的50个细节</title>
    <link href="http://ai.mak.cn/2019/02/01/java/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8450%E4%B8%AA%E7%BB%86%E8%8A%82/"/>
    <id>http://ai.mak.cn/2019/02/01/java/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8450%E4%B8%AA%E7%BB%86%E8%8A%82/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2022-10-20T11:42:04.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java性能优化的50个细节"><a href="#Java性能优化的50个细节" class="headerlink" title="Java性能优化的50个细节"></a>Java性能优化的50个细节</h3><p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p><h4 id="1-尽量在合适的场合使用单例"><a href="#1-尽量在合适的场合使用单例" class="headerlink" title="1. 尽量在合适的场合使用单例"></a>1. 尽量在合适的场合使用单例</h4><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>第一，控制资源的使用，通过线程同步来控制资源的并发访问；</p><p>第二，控制实例的产生，以达到节约资源的目的；</p><p>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p><h4 id="2-尽量避免随意使用静态变量"><a href="#2-尽量避免随意使用静态变量" class="headerlink" title="2. 尽量避免随意使用静态变量"></a>2. 尽量避免随意使用静态变量</h4><p>当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;private static B b = new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p><h4 id="3-尽量避免过多过常地创建Java对象"><a href="#3-尽量避免过多过常地创建Java对象" class="headerlink" title="3. 尽量避免过多过常地创建Java对象"></a>3. 尽量避免过多过常地创建Java对象</h4><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度地重用对象，最好能用基本的数据类型或数组来替代对象。</p><h4 id="4-尽量使用final修饰符"><a href="#4-尽量使用final修饰符" class="headerlink" title="4. 尽量使用final修饰符"></a>4. 尽量使用final修饰符</h4><p>带有final修饰符的类是不可派生的。在JAVA核心API中，有许多应用final的例子，例如java、lang、String，为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关），此举能够使性能平均提高50%。</p><p>如：让访问实例内变量的getter&#x2F;setter方法变成”final：</p><p>简单的getter&#x2F;setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MAF &#123;</span><br><span class="line">public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br><span class="line">更正</span><br><span class="line">class DAF_fixed &#123;</span><br><span class="line">final public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-尽量使用局部变量"><a href="#5-尽量使用局部变量" class="headerlink" title="5. 尽量使用局部变量"></a>5. 尽量使用局部变量</h4><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快；其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p><h4 id="6-尽量处理好包装类型和基本类型两者的使用场所"><a href="#6-尽量处理好包装类型和基本类型两者的使用场所" class="headerlink" title="6. 尽量处理好包装类型和基本类型两者的使用场所"></a>6. 尽量处理好包装类型和基本类型两者的使用场所</h4><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p><h4 id="7-慎用synchronized，尽量减小synchronize的方法"><a href="#7-慎用synchronized，尽量减小synchronize的方法" class="headerlink" title="7. 慎用synchronized，尽量减小synchronize的方法"></a>7. 慎用synchronized，尽量减小synchronize的方法</h4><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以，synchronize的方法尽量减小，并且应尽量使用方法同步代替代码块同步。</p><h4 id="8-尽量不要使用finalize方法"><a href="#8-尽量不要使用finalize方法" class="headerlink" title="8. 尽量不要使用finalize方法"></a>8. 尽量不要使用finalize方法</h4><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p><h3 id="9-尽量使用基本数据类型代替对象"><a href="#9-尽量使用基本数据类型代替对象" class="headerlink" title="9. 尽量使用基本数据类型代替对象"></a>9. 尽量使用基本数据类型代替对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p><h4 id="10-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList"><a href="#10-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList" class="headerlink" title="10. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList"></a>10. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</h4><p>HashTable、Vector等使用了同步机制，降低了性能。</p><h4 id="11-尽量合理的创建HashMap"><a href="#11-尽量合理的创建HashMap" class="headerlink" title="11. 尽量合理的创建HashMap"></a>11. 尽量合理的创建HashMap</h4><p>当你要创建一个比较大的hashMap时，充分利用这个构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor);</span><br></pre></td></tr></table></figure><p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p><h4 id="12-尽量减少对变量的重复计算"><a href="#12-尽量减少对变量的重复计算" class="headerlink" title="12. 尽量减少对变量的重复计算"></a>12. 尽量减少对变量的重复计算</h4><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size();i++)</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,len=list.size();i&lt;len;i++)</span><br></pre></td></tr></table></figure><p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p><h4 id="13-尽量避免不必要的创建"><a href="#13-尽量避免不必要的创建" class="headerlink" title="13. 尽量避免不必要的创建"></a>13. 尽量避免不必要的创建</h4><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">if(i==1)&#123;</span><br><span class="line">list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(i==1)&#123;</span><br><span class="line">A a = new A();</span><br><span class="line">list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-尽量在finally块中释放资源"><a href="#14-尽量在finally块中释放资源" class="headerlink" title="14. 尽量在finally块中释放资源"></a>14. 尽量在finally块中释放资源</h4><p>程序中使用到的资源应当被释放，以避免资源泄漏，这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><h4 id="15-尽量使用移位来代替’a-x2F-b’的操作"><a href="#15-尽量使用移位来代替’a-x2F-b’的操作" class="headerlink" title="15. 尽量使用移位来代替’a&#x2F;b’的操作"></a>15. 尽量使用移位来代替’a&#x2F;b’的操作</h4><p>“&#x2F;“是一个代价很高的操作，使用移位的操作将会更快和更有效</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a / 4;</span><br><span class="line">int num = a / 8;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a &gt;&gt; 2;</span><br><span class="line">int num = a &gt;&gt; 3;</span><br></pre></td></tr></table></figure><p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解。</p><h4 id="16-尽量使用移位来代替’a-b’的操作"><a href="#16-尽量使用移位来代替’a-b’的操作" class="headerlink" title="16.尽量使用移位来代替’a*b’的操作"></a>16.尽量使用移位来代替’a*b’的操作</h4><p>同样的，对于’*’操作，使用移位的操作将会更快和更有效</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a * 4;</span><br><span class="line">int num = a * 8;</span><br></pre></td></tr></table></figure><p>应该改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = a &lt;&lt; 2;</span><br><span class="line">int num = a &lt;&lt; 3;</span><br></pre></td></tr></table></figure><h4 id="17-尽量确定StringBuffer的容量"><a href="#17-尽量确定StringBuffer的容量" class="headerlink" title="17. 尽量确定StringBuffer的容量"></a>17. 尽量确定StringBuffer的容量</h4><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = new StringBuffer(1000);</span><br></pre></td></tr></table></figure><h4 id="18-尽量早释放无用对象的引用"><a href="#18-尽量早释放无用对象的引用" class="headerlink" title="18. 尽量早释放无用对象的引用"></a>18. 尽量早释放无用对象的引用</h4><p>大部分时，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p><p>例如：</p><p>Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">Object obj = new Object();</span><br><span class="line">……</span><br><span class="line">Obj=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p><p>Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">Object obj = new Object();</span><br><span class="line">……</span><br><span class="line">Obj=null;</span><br><span class="line">//执行耗时，耗内存操作；或调用耗时，耗内存的方法</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p><h4 id="19-尽量避免使用二维数组"><a href="#19-尽量避免使用二维数组" class="headerlink" title="19. 尽量避免使用二维数组"></a>19. 尽量避免使用二维数组</h4><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p><h4 id="20-尽量避免使用split"><a href="#20-尽量避免使用split" class="headerlink" title="20. 尽量避免使用split"></a>20. 尽量避免使用split</h4><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p><h4 id="21-ArrayList-amp-LinkedList"><a href="#21-ArrayList-amp-LinkedList" class="headerlink" title="21. ArrayList &amp; LinkedList"></a>21. ArrayList &amp; LinkedList</h4><p>一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p><h4 id="22-尽量使用System-arraycopy-代替通过来循环复制数组"><a href="#22-尽量使用System-arraycopy-代替通过来循环复制数组" class="headerlink" title="22. 尽量使用System.arraycopy ()代替通过来循环复制数组"></a>22. 尽量使用System.arraycopy ()代替通过来循环复制数组</h4><p>System.arraycopy() 要比通过循环来复制数组快的多。</p><h4 id="23-尽量缓存经常使用的对象"><a href="#23-尽量缓存经常使用的对象" class="headerlink" title="23. 尽量缓存经常使用的对象"></a>23. 尽量缓存经常使用的对象</h4><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO&#x2F;FLU等缓存算法。</p><h4 id="24-尽量避免非常大的内存分配"><a href="#24-尽量避免非常大的内存分配" class="headerlink" title="24. 尽量避免非常大的内存分配"></a>24. 尽量避免非常大的内存分配</h4><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p><h4 id="25-慎用异常"><a href="#25-慎用异常" class="headerlink" title="25. 慎用异常"></a>25. 慎用异常</h4><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p><p>如果您创建一个 Exception ，就得付出代价，好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，你甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p><h4 id="26-尽量重用对象"><a href="#26-尽量重用对象" class="headerlink" title="26. 尽量重用对象"></a>26. 尽量重用对象</h4><p>特别是String对象的使用中，出现字符串连接情况时应使用StringBuffer代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p><h4 id="27-不要重复初始化变量"><a href="#27-不要重复初始化变量" class="headerlink" title="27. 不要重复初始化变量"></a>27. 不要重复初始化变量</h4><p>默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成null，整数变量设置成0，float和double变量设置成0.0，逻辑值设置成false。当一个类从另一个类派生时，这一点尤其应该注意，因为用new关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。</p><p>这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法。比如initXXX()中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：public int state &#x3D; this.getState()。</p><h4 id="28-在java-Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。"><a href="#28-在java-Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。" class="headerlink" title="28. 在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。"></a>28. 在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</h4><h4 id="29-在java编程过程中，进行数据库连接，I-x2F-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。"><a href="#29-在java编程过程中，进行数据库连接，I-x2F-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。" class="headerlink" title="29. 在java编程过程中，进行数据库连接，I&#x2F;O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。"></a>29. 在java编程过程中，进行数据库连接，I&#x2F;O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</h4><h4 id="30-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。"><a href="#30-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。" class="headerlink" title="30. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。"></a>30. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</h4><h4 id="31-在使用同步机制时，应尽量使用方法同步代替代码块同步。"><a href="#31-在使用同步机制时，应尽量使用方法同步代替代码块同步。" class="headerlink" title="31. 在使用同步机制时，应尽量使用方法同步代替代码块同步。"></a>31. 在使用同步机制时，应尽量使用方法同步代替代码块同步。</h4><h4 id="32-不要在循环中使用Try-x2F-Catch语句，应把Try-x2F-Catch放在循环最外层"><a href="#32-不要在循环中使用Try-x2F-Catch语句，应把Try-x2F-Catch放在循环最外层" class="headerlink" title="32. 不要在循环中使用Try&#x2F;Catch语句，应把Try&#x2F;Catch放在循环最外层"></a>32. 不要在循环中使用Try&#x2F;Catch语句，应把Try&#x2F;Catch放在循环最外层</h4><p>Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误Exception都能获取到的，虚拟机报错Exception就获取不到，必须用Error获取。</p><h4 id="33-通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能"><a href="#33-通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能" class="headerlink" title="33. 通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能"></a>33. 通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能</h4><p>StringBuffer的默认容量为16，当StringBuffer的容量达到最大容量时，它会将自身容量增加到当前的2倍+2，也就是2*n+2。无论何时，只要StringBuffer到达它的最大容量，它就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给StringBuffer设置一个合理的初始化容量值，是很有必要的！</p><h4 id="34-合理使用java-util-Vector"><a href="#34-合理使用java-util-Vector" class="headerlink" title="34. 合理使用java.util.Vector"></a>34. 合理使用java.util.Vector</h4><p>Vector与StringBuffer类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector的默认存储能力为10个元素，扩容加倍。</p><p>vector.add(index,obj) 这个方法可以将元素obj插入到index位置，但index以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于remove(int index)方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用removeAllElements()方法。</p><p>如果要删除vector里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如int index &#x3D; indexOf（obj）;vector.remove(index)。</p><h4 id="35-不用new关键字创建对象的实例"><a href="#35-不用new关键字创建对象的实例" class="headerlink" title="35. 不用new关键字创建对象的实例"></a>35. 不用new关键字创建对象的实例</h4><p>用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了Cloneable接口，我们可以调用它的clone()方法。clone()方法不会调用任何类构造函数。</p><p>下面是Factory模式的一个典型实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Credit getNewCredit()</span><br><span class="line">&#123;</span><br><span class="line">return new Credit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的代码使用clone()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Credit BaseCredit = new Credit();</span><br><span class="line">public static Credit getNewCredit()</span><br><span class="line">&#123;</span><br><span class="line">return (Credit)BaseCredit.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="36-不要将数组声明为：public-static-final"><a href="#36-不要将数组声明为：public-static-final" class="headerlink" title="36. 不要将数组声明为：public static final"></a>36. 不要将数组声明为：public static final</h4><h4 id="37-HaspMap的遍历："><a href="#37-HaspMap的遍历：" class="headerlink" title="37. HaspMap的遍历："></a>37. HaspMap的遍历：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String[]&gt; paraMap = new HashMap&lt;String, String[]&gt;();</span><br><span class="line">for( Entry&lt;String, String[]&gt; entry : paraMap.entrySet() )</span><br><span class="line">&#123;</span><br><span class="line">String appFieldDefId = entry.getKey();</span><br><span class="line">String[] values = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用散列值取出相应的Entry做比较得到结果，取得entry的值之后直接取key和value。</p><h4 id="38-array-数组-和ArrayList的使用"><a href="#38-array-数组-和ArrayList的使用" class="headerlink" title="38. array(数组)和ArrayList的使用"></a>38. array(数组)和ArrayList的使用</h4><p>array 数组效率最高，但容量固定，无法动态改变，ArrayList容量可以动态增长，但牺牲了效率。</p><h4 id="39-单线程应尽量使用-HashMap-ArrayList-除非必要，否则不推荐使用HashTable-Vector，它们使用了同步机制，而降低了性能。"><a href="#39-单线程应尽量使用-HashMap-ArrayList-除非必要，否则不推荐使用HashTable-Vector，它们使用了同步机制，而降低了性能。" class="headerlink" title="39. 单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。"></a>39. 单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。</h4><h4 id="40-StringBuffer-StringBuilder的区别在于"><a href="#40-StringBuffer-StringBuilder的区别在于" class="headerlink" title="40. StringBuffer,StringBuilder的区别在于"></a>40. StringBuffer,StringBuilder的区别在于</h4><p>java.lang.StringBuffer 线程安全的可变字符序列。一个类似于String的字符串缓冲区，但不能修改。StringBuilder与该类相比，通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p><p>为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用StringBuffer仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用StringBuffer。</p><h4 id="41-尽量使用基本数据类型代替对象。"><a href="#41-尽量使用基本数据类型代替对象。" class="headerlink" title="41. 尽量使用基本数据类型代替对象。"></a>41. 尽量使用基本数据类型代替对象。</h4><h4 id="42-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。"><a href="#42-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。" class="headerlink" title="42. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。"></a>42. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。</h4><h4 id="43-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。"><a href="#43-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。" class="headerlink" title="43. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。"></a>43. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</h4><h4 id="44-应尽可能避免使用内在的GET-SET方法。"><a href="#44-应尽可能避免使用内在的GET-SET方法。" class="headerlink" title="44. 应尽可能避免使用内在的GET,SET方法。"></a>44. 应尽可能避免使用内在的GET,SET方法。</h4><h4 id="45-避免枚举，浮点数的使用。"><a href="#45-避免枚举，浮点数的使用。" class="headerlink" title="45.避免枚举，浮点数的使用。"></a>45.避免枚举，浮点数的使用。</h4><p>以下举几个实用优化的例子：</p><h4 id="46、避免在循环条件中使用复杂表达式"><a href="#46、避免在循环条件中使用复杂表达式" class="headerlink" title="46、避免在循环条件中使用复杂表达式"></a>46、避免在循环条件中使用复杂表达式</h4><p>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Vector;</span><br><span class="line">class CEL &#123;</span><br><span class="line">void method (Vector vector) &#123;</span><br><span class="line">for (int i = 0; i &lt; vector.size (); i++) // Violation</span><br><span class="line">; // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CEL_fixed &#123;</span><br><span class="line">void method (Vector vector) &#123;</span><br><span class="line">int size = vector.size ()</span><br><span class="line">for (int i = 0; i &lt; size; i++)</span><br><span class="line">; // ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="47、为’Vectors’-和-‘Hashtables’定义初始大小"><a href="#47、为’Vectors’-和-‘Hashtables’定义初始大小" class="headerlink" title="47、为’Vectors’ 和 ‘Hashtables’定义初始大小"></a>47、为’Vectors’ 和 ‘Hashtables’定义初始大小</h4><p>JVM为Vector扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见Vector容量的扩大是一个颇费时间的事。</p><p>通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Vector;</span><br><span class="line">public class DIC &#123;</span><br><span class="line">public void addObjects (Object[] o) &#123;</span><br><span class="line">// if length &gt; 10, Vector needs to expand</span><br><span class="line">for (int i = 0; i&lt; o.length;i++) &#123;</span><br><span class="line">v.add(o); // capacity before it can add more elements.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Vector v = new Vector(); // no initialCapacity.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><p>自己设定初始大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Vector v = new Vector(20);</span><br><span class="line">public Hashtable hash = new Hashtable(10);</span><br></pre></td></tr></table></figure><h4 id="48、在finally块中关闭Stream"><a href="#48、在finally块中关闭Stream" class="headerlink" title="48、在finally块中关闭Stream"></a>48、在finally块中关闭Stream</h4><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><p>四、使用’System.arraycopy ()’代替通过来循环复制数组</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class IRB</span><br><span class="line">&#123;</span><br><span class="line">void method () &#123;</span><br><span class="line">int[] array1 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">array1 [i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int[] array2 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array2.length; i++) &#123;</span><br><span class="line">array2 [i] = array1 [i]; // Violation</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IRB</span><br><span class="line">&#123;</span><br><span class="line">void method () &#123;</span><br><span class="line">int[] array1 = new int [100];</span><br><span class="line">for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">array1 [i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int[] array2 = new int [100];</span><br><span class="line">System.arraycopy(array1, 0, array2, 0, 100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="49、让访问实例内变量的getter-x2F-setter方法变成”final”"><a href="#49、让访问实例内变量的getter-x2F-setter方法变成”final”" class="headerlink" title="49、让访问实例内变量的getter&#x2F;setter方法变成”final”"></a>49、让访问实例内变量的getter&#x2F;setter方法变成”final”</h4><p>简单的getter&#x2F;setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MAF &#123;</span><br><span class="line">public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DAF_fixed &#123;</span><br><span class="line">final public void setSize (int size) &#123;</span><br><span class="line">_size = size;</span><br><span class="line">&#125;</span><br><span class="line">private int _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="50、对于常量字符串，用’String’-代替-‘StringBuffer’"><a href="#50、对于常量字符串，用’String’-代替-‘StringBuffer’" class="headerlink" title="50、对于常量字符串，用’String’ 代替 ‘StringBuffer’"></a>50、对于常量字符串，用’String’ 代替 ‘StringBuffer’</h4><p>常量字符串并不需要动态改变长度。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class USC &#123;</span><br><span class="line">String method () &#123;</span><br><span class="line">StringBuffer s = new StringBuffer (&quot;Hello&quot;);</span><br><span class="line">String t = s + &quot;World!&quot;;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。</p><h4 id="51、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话"><a href="#51、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话" class="headerlink" title="51、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话"></a>51、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话</h4><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class STR &#123;</span><br><span class="line">public void method(String s) &#123;</span><br><span class="line">String string = s + &quot;d&quot; // violation.</span><br><span class="line">string = &quot;abc&quot; + &quot;d&quot; // violation.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更正：</p><p>将一个字符的字符串替换成’ ‘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class STR &#123;</span><br><span class="line">public void method(String s) &#123;</span><br><span class="line">String string = s + &#x27;d&#x27;</span><br><span class="line">string = &quot;abc&quot; + &#x27;d&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍，活学活用，变通为宜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Java性能优化的50个细节&quot;&gt;&lt;a href=&quot;#Java性能优化的50个细节&quot; class=&quot;headerlink&quot; title=&quot;Java性能优化的50个细节&quot;&gt;&lt;/a&gt;Java性能优化的50个细节&lt;/h3&gt;&lt;p&gt;在JAVA程序中，性能问题的大部分原因并不在</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔记-王阳明</title>
    <link href="http://ai.mak.cn/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/"/>
    <id>http://ai.mak.cn/2018/12/24/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01224/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2022-10-09T15:53:46.024Z</updated>
    
    <content type="html"><![CDATA[<p>你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你未看此花时，此花与汝心同归于寂；你来看此花时，则此花颜色一时明白起来。-王阳明&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-数字化转型核心</title>
    <link href="http://ai.mak.cn/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/"/>
    <id>http://ai.mak.cn/2018/12/21/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01221/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2022-10-09T15:52:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数字化转型最核心的就是怎么去真正以用户为中心，打造完全生命周期的、全渠道的、对全价值链数据的运用。&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-小程序带来了什么改变</title>
    <link href="http://ai.mak.cn/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/"/>
    <id>http://ai.mak.cn/2018/12/05/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01205/</id>
    <published>2018-12-04T16:00:00.000Z</published>
    <updated>2022-10-09T15:51:49.910Z</updated>
    
    <content type="html"><![CDATA[<p>小程序带来了什么改变？</p><p>（1）用户缩短了完成操作所需的步骤</p><p>（2）开发者更容易上手，开发难度下降</p><p>（3）新的产品形态：更垂直，更细分，更社交，更具创意</p><p>（4）用户红利：基于微信的巨大流量</p><p>什么适合做小程序</p><p>1.行业</p><p>低频刚需，这一点也已经得到公认，尤其O2O</p><p>低频非刚需：工具类适合小程序</p><p>2.产品规模</p><p>功能复杂业务多：具有大量业务，比较适合小程序，往垂直化来做，如58搬家，生活缴费等。</p><p>功能简单业务多：把核心功能迁移至小程序。</p><p>功能简单业务少：可以完全移植，相对效果不会差。</p><p>功能复杂业务少：简化体验流程。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小程序带来了什么改变？&lt;/p&gt;
&lt;p&gt;（1）用户缩短了完成操作所需的步骤&lt;/p&gt;
&lt;p&gt;（2）开发者更容易上手，开发难度下降&lt;/p&gt;
&lt;p&gt;（3）新的产品形态：更垂直，更细分，更社交，更具创意&lt;/p&gt;
&lt;p&gt;（4）用户红利：基于微信的巨大流量&lt;/p&gt;
&lt;p&gt;什么适合做小程序</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-互联网思维～</title>
    <link href="http://ai.mak.cn/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/"/>
    <id>http://ai.mak.cn/2018/12/04/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01204/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2022-10-09T15:51:35.494Z</updated>
    
    <content type="html"><![CDATA[<p>前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述，那么，你应该还在每天挤地铁。”</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几年，网上有这么个段子，嘲笑那些狂热的年轻创业者，说他们“用小米手机，穿凡客T恤，泡贝塔咖啡，听创业讲座，宅在家里看耶鲁公开课，知乎果壳关注无数，BAT公司大格局了如指掌。肉夹馍只吃西少爷，煎饼果子必须黄太吉，约饭局去雕爷牛腩，逢人便谈互联网思维等等——如果你符合以上描述</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-张子选《藏地诗篇》</title>
    <link href="http://ai.mak.cn/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/"/>
    <id>http://ai.mak.cn/2018/12/03/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01203/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:37.470Z</updated>
    
    <content type="html"><![CDATA[<p>向鱼问水，向马问路</p><p>向神佛打听我一生的出处</p><p>而我呀</p><p>我是疼在谁心头的一抔尘土</p><p>一尊佛祖，两世糊涂</p><p>来世的你呀，如何把今生的我一眼认出</p><p>——张子选《藏地诗篇》</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;向鱼问水，向马问路&lt;/p&gt;
&lt;p&gt;向神佛打听我一生的出处&lt;/p&gt;
&lt;p&gt;而我呀&lt;/p&gt;
&lt;p&gt;我是疼在谁心头的一抔尘土&lt;/p&gt;
&lt;p&gt;一尊佛祖，两世糊涂&lt;/p&gt;
&lt;p&gt;来世的你呀，如何把今生的我一眼认出&lt;/p&gt;
&lt;p&gt;——张子选《藏地诗篇》&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-刻意练习</title>
    <link href="http://ai.mak.cn/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/"/>
    <id>http://ai.mak.cn/2018/12/02/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01202/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:19.178Z</updated>
    
    <content type="html"><![CDATA[<p>1、有目的的练习特点</p><p>定义明确的具体目标，可以有效地用于引导你的练习</p><p>有目的的练习是专注的</p><p>有目的的练习包含反馈</p><p>有目的的练习需要走出舒适区</p><p>总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。还要想办法保持你的动机。</p><p>2、刻意练习的特点</p><p>刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能</p><p>刻意练习发生在舒适区之外，要求不断地尝试那些刚好超出他当前能力范围的事物，需要人们付出最大限度的努力。</p><p>刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进</p><p>刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动</p><p>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。</p><p>如何运用刻意练习原则</p><p>在实践中，这往往归结为带有几个额外步骤的有目的的练习：</p><p>首先辨别杰出人物</p><p>然后推测是什么使他们变得如此杰出</p><p>接着再提出训练方法，这些方法使你也能像他们那样表现卓越</p><p>在自己的工作，仔细思考杰出的表现具有哪些特点，并尝试采用一些方法来度量，即使在你度量时一定存在着某种程度的主观意识也无妨。然后，寻找你所在行业或领域中评分最高、你认为对杰出表现十分关键的人。要记住，理想的情况是找到客观的、可复制的测量指标，以便前后一致地从普通从业者之中挑选出最优异的从业者。</p><p>运用刻意练习原则的人都面临一个重大挑战，那便是：要准确地判断最杰出人物做了些什么，使得他们在普通人中间“鹤立鸡群”。 在IT互联网行业，牛人很多。大多数牛人都有着做出牛逼产品的经历，比如微信之父张小龙、小米创始人雷军。是什么促使他们做出牛逼的产品？到底是什么是他们变得如此杰出？这几个问题其实是不好找到客观的、可复制的测量指标。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、有目的的练习特点&lt;/p&gt;
&lt;p&gt;定义明确的具体目标，可以有效地用于引导你的练习&lt;/p&gt;
&lt;p&gt;有目的的练习是专注的&lt;/p&gt;
&lt;p&gt;有目的的练习包含反馈&lt;/p&gt;
&lt;p&gt;有目的的练习需要走出舒适区&lt;/p&gt;
&lt;p&gt;总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-数据化：一切皆可“量化”</title>
    <link href="http://ai.mak.cn/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/"/>
    <id>http://ai.mak.cn/2018/11/29/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01129/</id>
    <published>2018-11-28T16:00:00.000Z</published>
    <updated>2022-10-09T15:50:00.945Z</updated>
    
    <content type="html"><![CDATA[<p>数据化：一切皆可“量化”</p><p>莫里的导航图，大数据的最早实践之一</p><p>许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。</p><p>数据从最不可能的地方提取出来</p><p>大数据的核心就是挖掘出庞大的数据库独有的价值</p><p>数据化，不是数字化</p><p>数据化，这是指一种把现象转变可制表分析的量化形式的过程。</p><p>量化一切，数据化的核心</p><p>计量和记录一起促成了数据的诞生，它们是数据化最早的根基</p><p>数字化带来了数据化，但是数字化无法取代数据化</p><p>当文字成为数据</p><p>但文字变成数据，它就大显神通了——人可以用之阅读，机器也可以用之分析。</p><p>当方位变成数据</p><p>“现实挖掘”这里指的是通过处理大量来自手机的数据，发现和预测人类行为。</p><p>位置信息一被数据化，新的用途就犹如雨后春笋般涌现出来，而新价值也会随之不断催生。</p><p>当沟通变成数据</p><p>Twitter情绪数据化</p><p>社交图谱  FICO</p><p>twitter情感分析以获得顾客反馈意见的汇总或对营销获得的效果进行判断</p><p>世间万物的数据化</p><p>只要一点想象，万千事物就能转化为数据形式，并一直带给我们惊喜。</p><p>物联网只是一种典型的数据化手段</p><p>有了大数据的帮助，我们不会再将世界看作是一连串wim认为或是自然或是社会现象的时间，我们会意识到本质上世界是由信息构成的。</p><p>将世界看作信息，看作可以理解的数据还有，为我们提供了一个从未有过的审视现实的视角。它是一种可以渗透到所有生活领域的世界观。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据化：一切皆可“量化”&lt;/p&gt;
&lt;p&gt;莫里的导航图，大数据的最早实践之一&lt;/p&gt;
&lt;p&gt;许多船挂了一面特殊的旗帜，表明它参与了这个信息交流计划。这些旗帜就是出现在一些网站上的友情链接的前身。&lt;/p&gt;
&lt;p&gt;数据从最不可能的地方提取出来&lt;/p&gt;
&lt;p&gt;大数据的核心就是挖掘出</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记-更多，更杂，更好</title>
    <link href="http://ai.mak.cn/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/"/>
    <id>http://ai.mak.cn/2018/11/28/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01128/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2022-10-09T15:49:39.261Z</updated>
    
    <content type="html"><![CDATA[<p>更多：不是随机样本，而是全体数据</p><p>样本&#x3D;总体</p><p>更杂：不是精确性，而是混杂性</p><p>允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。</p><p>大数据抵消了错误数据带来的不精确：</p><p>更好：不是因果关系，而是相关关系</p><p>建立在相关关系分析法上的预测是大数据的核心，我们通过大数据分析得到的是“是什么”（相关关系），而得不出“为什么”（因果关系）的结论。</p><p>通过大数据分析，寻找事物、数据之间的关联性来分析现象，而不是揭示其内部机制。往往通过大数据得出的结论只是一个可能性预测，而不知道其背后的原因。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;更多：不是随机样本，而是全体数据&lt;/p&gt;
&lt;p&gt;样本&amp;#x3D;总体&lt;/p&gt;
&lt;p&gt;更杂：不是精确性，而是混杂性&lt;/p&gt;
&lt;p&gt;允许不精确，放松了容错标准，提高了容错能力：允许有噪声数据、对非格式化的数据进行数据清洗等。&lt;/p&gt;
&lt;p&gt;大数据抵消了错误数据带来的不精确：&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java代码优化总结</title>
    <link href="http://ai.mak.cn/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2018/11/25/java/%20Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2022-08-05T17:37:13.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java问题排查工具单"><a href="#java问题排查工具单" class="headerlink" title="java问题排查工具单"></a>java问题排查工具单</h2><p>转自 作者：红魔七号<br>链接：<a href="https://yq.aliyun.com/articles/69520?utm_content=m_10360">https://yq.aliyun.com/articles/69520?utm_content=m_10360</a></p><p><em>摘要：</em> # 我的问题排查工具箱 ## 前言 平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。 闲话不多说，开搞。 ## Linux命令类 ###tail 最常用的tail -f tail -3</p><h1 id="我的问题排查工具箱"><a href="#我的问题排查工具箱" class="headerlink" title="我的问题排查工具箱"></a>我的问题排查工具箱</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。</p><p>闲话不多说，开搞。</p><h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep forest f.txt     #文件查找</span><br><span class="line">grep forest f.txt cpf.txt #多文件查找</span><br><span class="line">grep &#x27;log&#x27; /home/admin -r -n #目录下查找所有符合关键字的文件</span><br><span class="line">cat f.txt | grep -i shopbase    </span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀</span><br><span class="line">grep &#x27;shopbase&#x27; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配</span><br><span class="line">seq 10 | grep 5 -A 3    #上匹配</span><br><span class="line">seq 10 | grep 5 -B 3    #下匹配</span><br><span class="line">seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了</span><br><span class="line">cat f.txt | grep -c &#x27;SHOPBASE&#x27;</span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>1 基础命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $4,$6&#125;&#x27; f.txt</span><br><span class="line">awk &#x27;&#123;print NR,$0&#125;&#x27; f.txt cpf.txt    </span><br><span class="line">awk &#x27;&#123;print FNR,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FNR,FILENAME,$0&#125;&#x27; f.txt cpf.txt</span><br><span class="line">awk &#x27;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&#x27; f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: &#x27;&#123;print $1,$2,$3,$4&#125;&#x27;</span><br></pre></td></tr></table></figure><p>2 匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/ldb/ &#123;print&#125;&#x27; f.txt   #匹配ldb</span><br><span class="line">awk &#x27;!/ldb/ &#123;print&#125;&#x27; f.txt  #不匹配ldb</span><br><span class="line">awk &#x27;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&#x27; f.txt   #匹配ldb和LISTEN</span><br><span class="line">awk &#x27;$5 ~ /ldb/ &#123;print&#125;&#x27; f.txt #第五列匹配ldb</span><br></pre></td></tr></table></figure><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -type d(当前目录下的所有子目录)</span><br><span class="line">find /usr -type l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></table></figure><h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgm -A -f vm-shopbase &#x27;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&#x27;</span><br></pre></td></tr></table></figure><h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar  ##可以查看最近一天的各项指标</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc25b8f22e53818d5576c5d00dd52618.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar --live ##可以查看实时指标，默认五秒一刷</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b68910c5416fd85a99a49a092fc9ffbb.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aafdbfb515b817a2aceb270d1d470c19.png" alt="screenshot.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tsar --mem</span><br><span class="line">tsar --load</span><br><span class="line">tsar --cpu</span><br><span class="line">##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/cb46ef4e374e1502d3b672d04d48099a.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/079f3fa722bfa1991557469eb97c7273.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6dd77351ad4d1ad84cdbfba20c9d4c29.png" alt="screenshot.png"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">top -H -p pid</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|awk  &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c|sort -rn </span><br><span class="line">#查看当前连接，注意close_wait偏高的情况，比如如下</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/250a027410775cf5990d0db6e87ba927.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/639811da529750064e2f70867d6234e0.png" alt="screenshot.png"></p><h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ol><li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</p><p>@OnMethod(clazz &#x3D; “java.util.ArrayList”, method&#x3D;”add”, location &#x3D; @Location(value &#x3D; Kind.CALL, clazz &#x3D; “&#x2F;.<em>&#x2F;“, method &#x3D; “&#x2F;.</em>&#x2F;“))<br>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123;</span><br><span class="line">    println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod  + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance));</span><br><span class="line">    jstack();</span><br><span class="line">    println();</span><br><span class="line">    println(&quot;===========================&quot;);</span><br><span class="line">    println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><p>监控当前服务方法被调用时返回的值以及请求的参数</p><p>@OnMethod(clazz &#x3D; “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method&#x3D;”nav”, location &#x3D; @Location(value &#x3D; Kind.RETURN))<br>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result);</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。<br><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></p><p>注意:</p><ol><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ol><h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p><p><code>trace class method</code>: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:<a href="http://www.atatech.org/articles/52947">http://www.atatech.org/articles/52947</a>。</p><p>其他功能部分和btrace重合，可以选用，感兴趣的请移步。<br><a href="http://www.atatech.org/articles/26247">http://www.atatech.org/articles/26247</a></p><p>另外相关联的是arthas，他是基于Greys的，感兴趣的再移步<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc">http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc</a></p><h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>可以看看我之前写的一篇javOSize的简介<a href="http://www.atatech.org/articles/38546">http://www.atatech.org/articles/38546</a><br>官网请移步<a href="http://www.javosize.com/">http://www.javosize.com/</a></p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<br>官网请移步<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<br>详情请移步<a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a></p><h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛<br>详情请移步<a href="http://zprofiler.alibaba-inc.com/">zprofiler.alibaba-inc.com</a></p><h2 id="java三板斧，噢不对，是七把"><a href="#java三板斧，噢不对，是七把" class="headerlink" title="java三板斧，噢不对，是七把"></a>java三板斧，噢不对，是七把</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>我只用一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/jps -mlvV</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b156cb53250bf5f91811900c2575a91.png" alt="screenshot.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>普通用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc501bf424b3d2884e6ec118d14554a3.png" alt="screenshot.png"></p><p>native+java栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4c59dc2971f3d8778e1898d64266266a.png" alt="screenshot.png"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc879145e2994e9a09327407ed88382c.png" alt="screenshot.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p><p>1.查看堆的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/00d9eaef08cdb51263d202d26795036b.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3c08bccf81fef8b7bcae2b321012b503.png" alt="screenshot.png"></p><p>2.dump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</span><br></pre></td></tr></table></figure><p>3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10</span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/500ec6709fcd03a4fca2679615d54522.png" alt="screenshot.png"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/05743916a9187535c202fb410d30d50d.png" alt="screenshot.png"></p><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是&#x2F;opt&#x2F;taobao&#x2F;java&#x2F;，远程调试端口是8000.那么<br><code>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000</code>.</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/16332fcd45b20137bffc7a3b9a88b0f1.png" alt="screenshot.png"></p><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<br>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html</a></p><h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</span><br></pre></td></tr></table></figure><p>更详细的可见R大此贴<br><a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/356c11885a95e28736a605aecdc8083e.png" alt="screenshot.png"></p><h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p><h2 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h2><ol><li><p>你的类到底是从哪个文件加载进来的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br><span class="line">结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar]</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>应用挂了输出dump文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof</span><br><span class="line">集团的vm参数里边基本都有这个选项</span><br></pre></td></tr></table></figure></li></ol><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p><h3 id="mvn-dependency-tree-gt-x2F-dependency-txt"><a href="#mvn-dependency-tree-gt-x2F-dependency-txt" class="headerlink" title="mvn dependency:tree &gt; ~&#x2F;dependency.txt"></a>mvn dependency:tree &gt; ~&#x2F;dependency.txt</h3><p>打出所有依赖</p><h3 id="mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId"><a href="#mvn-dependency-tree-Dverbose-Dincludes-x3D-groupId-artifactId" class="headerlink" title="mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId"></a>mvn dependency:tree -Dverbose -Dincludes&#x3D;groupId:artifactId</h3><p>只打出指定groupId和artifactId的依赖关系</p><h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="greys-sc"><a href="#greys-sc" class="headerlink" title="greys:sc"></a>greys:sc</h3><p>greys的sc命令也能清晰的看到当前类是从哪里加载过来的</p><h3 id="tomcat-classloader-locate"><a href="#tomcat-classloader-locate" class="headerlink" title="tomcat-classloader-locate"></a>tomcat-classloader-locate</h3><p>通过以下url可以获知当前类是从哪里加载的<br>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a></p><h2 id="ALI-TOMCAT带给我们的惊喜-感谢-务观"><a href="#ALI-TOMCAT带给我们的惊喜-感谢-务观" class="headerlink" title="ALI-TOMCAT带给我们的惊喜(感谢@务观)"></a>ALI-TOMCAT带给我们的惊喜(感谢@务观)</h2><ol><li><p>列出容器加载的jar列表</p><p>curl <a href="http://localhost:8006/classloader/jars">http://localhost:8006/classloader/jars</a></p></li><li><p>列出当前当当前类加载的实际jar包位置，解决类冲突时有用</p><p>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4568b16d3db0daf98e852412b830f1a8.png" alt="screenshot.png"></p></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h3><p><a href="http://www.atatech.org/articles/33317">http://www.atatech.org/articles/33317</a></p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg|grep -i kill|less</span><br></pre></td></tr></table></figure><p>去找关键字oom_killer。找到的结果类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0</span><br><span class="line">[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 </span><br><span class="line">[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 </span><br><span class="line">[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child </span><br><span class="line">[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</span><br></pre></td></tr></table></figure><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式:<br>log实际时间&#x3D;格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1970-01-01 UTC `echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&#x27; &#x27;)+12288812.926194&quot;|bc ` seconds&quot;</span><br></pre></td></tr></table></figure><p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步<a href="http://ifeve.com/guava-ratelimiter/">http://ifeve.com/guava-ratelimiter/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java问题排查工具单&quot;&gt;&lt;a href=&quot;#java问题排查工具单&quot; class=&quot;headerlink&quot; title=&quot;java问题排查工具单&quot;&gt;&lt;/a&gt;java问题排查工具单&lt;/h2&gt;&lt;p&gt;转自 作者：红魔七号&lt;br&gt;链接：&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔记-运营该如何被定义和理解</title>
    <link href="http://ai.mak.cn/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/"/>
    <id>http://ai.mak.cn/2018/11/10/%E6%9D%82%E8%AE%B0/%E7%AC%94%E8%AE%B01110/</id>
    <published>2018-11-09T16:00:00.000Z</published>
    <updated>2022-10-09T15:49:09.566Z</updated>
    
    <content type="html"><![CDATA[<p>运营该如何被定义和理解<br>1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段</p><p>2.运营工作的流程：<br>1）制定策略：根据不同的产品形态及数据变化制定不用的策略</p><p>2）分解指标，规划工作：对目标进行拆解，向内向外的资源争取及分配，制定具体的工作计划</p><p>3）执行落地，达成目标：通过文案、活动、用户维系等具体运营手段来达成我们的目标</p><p>4）监测数据、调整方向：收集、分析数据及用户反馈，评估运营工作调整新的运营策略</p><p>3.运营的四个关键性思维</p><p>1.流程化思维：一个优秀的运营和一个普通人之间存在的一个核心差别，就是优秀的运营拿到一个问题后，会回归流程，先把整个问题流程梳理出来，然后再从流程中去寻找潜在的解决方案。“先有流程，再有解决方案”这一点，不止对运营，对于产品来说也是一样的。</p><p>2.精细化思维：运营做久了会发现，优秀的运营，很多时候是通过大量的细节和琐碎事务堆积出来一个神奇的产品。这就需要运营具备很强的精细化思维和精细化管理，必须要能够把自己关注的一个问题拆解为无数细小的执行细节，并且能够做到对于所有细节的掌控力。</p><p>3.杠杆思维：好的运营是有层次感的，需要先做好一件事情，再以这件事为一个核心杠杆，去撬动更多的事情和成果发生，比如先服务好一批种子用户，给他们制造大量的超出他们预期的体验，以此为杠杆，撬动他们帮我们宣传。</p><p>4.生态化思维：所谓生态，其实就是一个所有角色在其中都可以互为价值、和谐共存、共同驱动器发展和生存的一个大环境，比如一个好几百人的微信群，一个社区。而能否成功搭建起来生态，最重要的，就是你能够梳理清楚并理解一个生态间的各种价值关系。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运营该如何被定义和理解&lt;br&gt;1.运营，就是帮助产品和用户之间更好的建立起来关系，所需要使用的一切干预手段&lt;/p&gt;
&lt;p&gt;2.运营工作的流程：&lt;br&gt;1）制定策略：根据不同的产品形态及数据变化制定不用的策略&lt;/p&gt;
&lt;p&gt;2）分解指标，规划工作：对目标进行拆解，向内向外的资</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
