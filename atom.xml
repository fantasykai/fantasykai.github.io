<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫哲&#39;s文栖小筑</title>
  
  <subtitle>君子终日乾乾，夕惕若厉，无咎</subtitle>
  <link href="http://ai.mak.cn/atom.xml" rel="self"/>
  
  <link href="http://ai.mak.cn/"/>
  <updated>2023-01-05T02:29:27.633Z</updated>
  <id>http://ai.mak.cn/</id>
  
  <author>
    <name>fantasykai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识图谱编辑器帮助文档</title>
    <link href="http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://ai.mak.cn/2023/01/05/ai/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-01-05T02:29:27.633Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">知识图谱编辑器(KG-Editor)</h1><div align="center"><p>基于 <a href="https://cn.vuejs.org/v2/guide/">Vue 2.x</a> +  <a href="https://g6.antv.vision/zh">G6 3.8</a>  + <a href="https://vuetifyjs.com/en/">Vuetify</a> 的可视化知识图谱编辑器(KG-Editor)</p></div><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持切换多种布局模式</li><li><input checked="" disabled="" type="checkbox"> 添加节点—双击画布空白处添加节点</li><li><input checked="" disabled="" type="checkbox"> 编辑节点—点击节点后可在右侧配置器进行编辑节点</li><li><input checked="" disabled="" type="checkbox"> 添加连线—鼠标移入节点后显示锚点，点击锚点后便作为起始节点，点击其它节点实现连线</li><li><input checked="" disabled="" type="checkbox"> 编辑连线—点击连线后可在右侧配置器进行编辑连线</li><li><input checked="" disabled="" type="checkbox"> 缩略图&amp;emsp;—右侧导航器实现缩略图</li><li><input checked="" disabled="" type="checkbox"> 撤销功能(对节点和连线添加或者删除的撤销)<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮撤销</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Z撤销</li></ul></li><li><input checked="" disabled="" type="checkbox"> 重做功能</li><li><input checked="" disabled="" type="checkbox"> 复制节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮复制</li><li><input checked="" disabled="" type="checkbox"> Ctrl + C复制</li></ul></li><li><input checked="" disabled="" type="checkbox"> 粘贴节点功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮粘贴</li><li><input checked="" disabled="" type="checkbox"> Ctrl + V粘贴</li></ul></li><li><input checked="" disabled="" type="checkbox"> 删除节点、连线功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮删除</li><li><input checked="" disabled="" type="checkbox"> Ctrl + Backspace删除</li></ul></li><li><input checked="" disabled="" type="checkbox"> 置于顶层功能</li><li><input checked="" disabled="" type="checkbox"> 置于底层功能</li><li><input checked="" disabled="" type="checkbox"> 放大画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮放大</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮上滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 缩小画布功能<ul><li><input checked="" disabled="" type="checkbox"> 点击按钮缩小</li><li><input checked="" disabled="" type="checkbox"> 鼠标滚轮下滑</li></ul></li><li><input checked="" disabled="" type="checkbox"> 适应画布</li><li><input checked="" disabled="" type="checkbox"> 上传数据文件生成知识图谱功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件数据格式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nodes&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;luffy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;24岁&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;62kg&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;edges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node2&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;年龄&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;node1&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;node3&quot;</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;体重&quot;</span>&#125;</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 导出图片功能</li><li><input checked="" disabled="" type="checkbox"> 导出JSON数据功能</li><li><input checked="" disabled="" type="checkbox"> 帮助</li></ul><p>感谢作者：<br>git：<a href="https://github.com/qiaolufei/kg_editor">https://github.com/qiaolufei/kg_editor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;知识图谱编辑器(KG-Editor)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;基于 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/&quot;&gt;Vue 2.x&lt;/a&gt; +  &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="AI" scheme="http://ai.mak.cn/categories/AI/"/>
    
    
    <category term="AI" scheme="http://ai.mak.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>八然</title>
    <link href="http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/"/>
    <id>http://ai.mak.cn/2022/12/09/%E6%9D%82%E8%AE%B0/%E6%9D%8E%E5%8F%94%E5%90%8C%E5%85%AB%E7%84%B6/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-12T12:25:49.560Z</updated>
    
    <content type="html"><![CDATA[<p>不知是不是李叔同写的，但还是记录一下～</p><p>每个人的人生都有“八然”：</p><p>来是偶然，去是必然；<br>得之坦然，失之淡然<br>争取必然，近其当然<br>忙时井然，闲时自然；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知是不是李叔同写的，但还是记录一下～&lt;/p&gt;
&lt;p&gt;每个人的人生都有“八然”：&lt;/p&gt;
&lt;p&gt;来是偶然，去是必然；&lt;br&gt;得之坦然，失之淡然&lt;br&gt;争取必然，近其当然&lt;br&gt;忙时井然，闲时自然；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是追求极致</title>
    <link href="http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/"/>
    <id>http://ai.mak.cn/2022/12/06/%E6%9D%82%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4/</id>
    <published>2022-12-05T16:00:00.000Z</published>
    <updated>2022-12-12T12:09:23.951Z</updated>
    
    <content type="html"><![CDATA[<p>在《小米创业思考》中看到雷军对 追求极致的理解</p><p>雷军：到底啥叫追求极致<br>按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，</p><p>实际上“追求极致”是有标准的，这个标准就是：</p><p><strong>找到现有技术条件下的唯一最优解</strong></p><p>在每一个技术世代，在产品设计方面，对应每一个品类，每一种需求，都存在一个最优解。如果你专注的领域中还没有发现公认的最优解，那么恭喜，你还有非常大的机会不断接近它，直到找到它，并建立起强大的竞争优势。<br>当你撸起袖子准备一头扎进去“追求极致”的时候，一定要问自己三个问题：</p><ul><li>第一，我追求的极致是不是用户真正需要的？ </li><li>第二，我追求的极致是不是能成为产品的核心竞争力？ </li><li>第三，我追求的极致是不是能形成长期可持续的竞争壁垒？<br>只有当这三个问题的答案是肯定的，你追求的极致才值得去做 从本质上说，追求极致并不是在讲情怀，而是在投资明天的竞争力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《小米创业思考》中看到雷军对 追求极致的理解&lt;/p&gt;
&lt;p&gt;雷军：到底啥叫追求极致&lt;br&gt;按通常理解，追求极致差不多等于“玩命死磕”“不惜代价投入”“做到超乎想象” 雷军说，这样的理解太浅了，缺少可以衡量的客观标准，就很容易陷入自嗨，&lt;/p&gt;
&lt;p&gt;实际上“追求极致”是有</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>qs.stringify的使用</title>
    <link href="http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ai.mak.cn/2022/11/11/%E5%89%8D%E7%AB%AF/qs.stringify%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-10T16:00:00.000Z</published>
    <updated>2022-11-14T03:31:10.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发过程中， get 方式请求可能遇到以下场景</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、get请求中存在数组对象</span><br><span class="line">2、get请求中存在对象嵌套的情况</span><br><span class="line">3、既有数组，又有子对象的情况 </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query: &#123;</span><br><span class="line">  pageNum: 1,</span><br><span class="line">  pageSize: 10,</span><br><span class="line">  user:&#123;</span><br><span class="line">    name: &#x27;kalami&#x27;,</span><br><span class="line">    age: &#x27;15&#x27;,</span><br><span class="line">    classNo: &#x27;122&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   taste: [&#x27;篮球&#x27;,&#x27;足球&#x27;,&#x27;音乐&#x27;],</span><br><span class="line">   remarks: null,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时可以使用qs来进行简化解析过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url = qs.stringify(params, &#123;allowDots: true,skipNulls: true&#125;);</span><br></pre></td></tr></table></figure><p><strong>通过使用 skipNulls： true ，可以过滤掉没有值的参数还</strong></p><p>接下来对qs做个详细的记录</p><ul><li>qs是什么？</li></ul><ol><li><p>qs.stringify()作用是将对象或者数组序列化成URL的格式。</p></li><li><p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装（axios 自带qs , &#x2F;&#x2F; import qs from ‘qs’）</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>qs.parse()将URL解析成对象的形式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;user=mak&amp;pwd=123456&#x27;</span><br><span class="line">qs.parse(url)</span><br><span class="line">console.log(qs.parse(url)) </span><br><span class="line">// &#123;user:&#x27;mak&#x27;,pwd:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li></ol><blockquote><p>qs.stringify 是把一个参数对象格式化为一个字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj= &#123;</span><br><span class="line">    user:&#x27;mak&#x27;,</span><br><span class="line">    pwd:&#x27;123&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">console.log(qs.stringify(obj)) </span><br><span class="line">// &#x27;user=mak&amp;pwd=123&#x27;</span><br></pre></td></tr></table></figure><h3 id="指定数组编码格式"><a href="#指定数组编码格式" class="headerlink" title="指定数组编码格式"></a>指定数组编码格式</h3><blockquote><p>当我们需要传递数组的时候，我们就可以通过下面方式进行处理： 默认情况下，它们给出明确的索引，如下代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;);</span><br><span class="line">   // &#x27;a[0]=b&amp;a[1]=c&amp;a[2]=d&#x27;</span><br><span class="line">```   </span><br><span class="line">   也可以进行重写这种默认方式为false</span><br></pre></td></tr></table></figure><p>   qs.stringify({ a: [‘b’, ‘c’, ‘d’] }, { indices: false });<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以通过arrayFormat 选项进行格式化输出，如下代码所示：</span><br></pre></td></tr></table></figure><p>   &#x2F;&#x2F; indices（默认）<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘indices’ })<br>   &#x2F;&#x2F; ‘a[0]&#x3D;b&amp;a[1]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘brackets’ })<br>   &#x2F;&#x2F; ‘a[]&#x3D;b&amp;a[]&#x3D;c’<br>   qs.stringify({ a: [‘b’, ‘c’] }, { arrayFormat: ‘repeat’ })<br>   &#x2F;&#x2F; ‘a&#x3D;b&amp;a&#x3D;c’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt; 需要注意的是，JSON中同样存在stringify方法，但是两者之间的区别是很明显的，如下所示：</span><br><span class="line"></span><br><span class="line">```   &#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;</span><br><span class="line">   uid=cs11&amp;pwd=000000als&amp;username=cs11&amp;password=000000als</span><br><span class="line">```  </span><br><span class="line">   如上所示，前者是采用JSON.stringify(param)进行处理，后者是采用Qs.stringify(param)进行处理的。</span><br><span class="line"></span><br><span class="line">   qs库是用来发送formdata数据的，并且可以改变数据格式，同时他还可以去掉options预请求。</span><br><span class="line"></span><br><span class="line">### 处理json格式的参数</span><br><span class="line">   在默认情况下，json格式的参数会用 [] 方式编码，</span><br></pre></td></tr></table></figure><p>   let json &#x3D; { a: { b: { c: ‘d’, e: ‘f’ } } };</p><p>   qs.stringify(json);<br>   &#x2F;&#x2F;结果 ‘a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是某些服务端框架，并不能很好的处理这种格式，所以需要转为下面的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   qs.stringify(json, {allowDots: true});<br>   &#x2F;&#x2F;结果 ‘a.b.c&#x3D;d&amp;a.b.e&#x3D;f’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###    qs.stringify详解</span><br><span class="line">   默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，可以使用以下选项之一。</span><br></pre></td></tr></table></figure><p>   const qs &#x3D; require(‘qs’);<br>   axios.post(‘&#x2F;foo’, qs.stringify({ ‘bar’: 123 }));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一种方式（ES6）</span><br></pre></td></tr></table></figure><p>   import qs from ‘qs’;<br>   const data &#x3D; { ‘bar’: 123 };<br>   const options &#x3D; {<br>     method: ‘POST’,<br>     headers: { ‘content-type’: ‘application&#x2F;x-www-form-urlencoded’ },<br>     data: qs.stringify(data),<br>     url,<br>   };<br>   axios(options);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 详解： axios默认的content-type是application/json 也就是java后端经常让你把参数放在body中的那种格式 传输的样式是 requestbody</span><br></pre></td></tr></table></figure><p>   {<br>       name:xxx,<br>       age:xxx<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的qs进行序列化 那么content-type就是application/x-www-form-urlencoded 也就是常说的表单提交 传输的样式是 formdata</span><br></pre></td></tr></table></figure><p>   name:xxx,<br>   age:xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; urlencoding后是 name=xxx&amp;age=xxx</span><br><span class="line"></span><br><span class="line">所以,实际上是否需要用qs去序列化参数完全取决于后端要怎么接受数据</span><br><span class="line"></span><br><span class="line">qs.stringify()与JSON.stringify()区别</span><br><span class="line">qs.stringify、JSON.stringify虽然都是序列化，但他俩却不是一个东西。</span><br><span class="line"></span><br><span class="line">qs是nodejs的一个模块</span><br><span class="line"></span><br><span class="line">JSON.stringify是js自带的方法，是将json对象转换为json字符串</span><br></pre></td></tr></table></figure><p>   var a&#x3D;{“a1”: “hello”, “a2”: “hi”}<br>   qs.stringify(a);<br>   &#x2F;&#x2F; 结果是：a1&#x3D;hello&amp;a2&#x3D;hi<br>   JSON.stringify(a);<br>   &#x2F;&#x2F; 结果是：‘{“a1”: “hello”, “a2”: “hi”}’</p><pre><code>   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开发过程中， get 方式请求可能遇到以下场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="http://ai.mak.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="http://ai.mak.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图看二十大报告</title>
    <link href="http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/"/>
    <id>http://ai.mak.cn/2022/10/19/%E8%AF%AD%E5%BD%95/%E5%9B%BE%E7%9C%8B%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-20T23:00:30.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”</p></blockquote><h4 id="二十大报告中的9个数字"><a href="#二十大报告中的9个数字" class="headerlink" title="二十大报告中的9个数字"></a>二十大报告中的9个数字</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E4%B8%AD%E7%9A%849%E4%B8%AA%E6%95%B0%E5%AD%97.png" alt="9"></p><h4 id="党的二十大报告关键词"><a href="#党的二十大报告关键词" class="headerlink" title="党的二十大报告关键词"></a>党的二十大报告关键词</h4><p><img src="https://aimak.cn/20D/%E5%85%9A%E7%9A%84%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E5%85%B3%E9%94%AE%E8%AF%8D.png" alt="keys"></p><h4 id="二十大报告擘画中国发展蓝图"><a href="#二十大报告擘画中国发展蓝图" class="headerlink" title="二十大报告擘画中国发展蓝图"></a>二十大报告擘画中国发展蓝图</h4><p><img src="https://aimak.cn/20D/%E4%BA%8C%E5%8D%81%E5%A4%A7%E6%8A%A5%E5%91%8A%E6%93%98%E7%94%BB%E4%B8%AD%E5%9B%BD%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE.png" alt="future"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;媒体总结的二十大报告，收集一下，来自，“人民日报”，“新华网”，“央视新闻”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二十大报告中的9个数字&quot;&gt;&lt;a href=&quot;#二十大报告中的9个数字&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cherry键盘 win键无效</title>
    <link href="http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/"/>
    <id>http://ai.mak.cn/2022/10/18/%E5%B7%A5%E5%85%B7/Cherry%E9%94%AE%E7%9B%98%20win%E9%94%AE%E6%97%A0%E6%95%88/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-18T05:10:14.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱桃图标，好吧，用这么久，才知道，这是锁定win键的</p></blockquote><p>最终正解：</p><p><strong>FUN+F9解锁，这是为了防止误触把个键给锁定了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这两天，发现shiftlt 的快捷键无效了，不能自由的分屏了，以为是新安装的软件有快捷键冲突，今天中午排查了一下，发现是win键（option）无效，但Mac自己的键盘可以，又以为是我的cherry 的这个键坏了，认真看了一下键盘，发现F9 有个樱</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>二十大手帐</title>
    <link href="http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://ai.mak.cn/2022/10/18/%E8%AF%AD%E5%BD%95/%E4%BA%8C%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2022-10-17T16:00:00.000Z</published>
    <updated>2022-10-21T00:18:24.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>党的二十大学习手帐，来自人民日报</p></blockquote><p><img src="https://aimak.cn/20D/report/0.jpg"><br><img src="https://aimak.cn/20D/report/1.jpg"><br><img src="https://aimak.cn/20D/report/2.jpg"><br><img src="https://aimak.cn/20D/report/3.jpg"><br><img src="https://aimak.cn/20D/report/4.jpeg"><br><img src="https://aimak.cn/20D/report/5.jpeg"><br><img src="https://aimak.cn/20D/report/6.jpeg"><br><img src="https://aimak.cn/20D/report/7.jpeg"><br><img src="https://aimak.cn/20D/report/8.jpeg"><br><img src="https://aimak.cn/20D/report/9.jpeg"><br><img src="https://aimak.cn/20D/report/10.jpeg"><br><img src="https://aimak.cn/20D/report/11.jpeg"><br><img src="https://aimak.cn/20D/report/12.jpeg"><br><img src="https://aimak.cn/20D/report/13.jpeg"></p><p>　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;党的二十大学习手帐，来自人民日报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://aimak.cn/20D/report/0.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://aimak.cn/20D/report</summary>
      
    
    
    
    <category term="语录" scheme="http://ai.mak.cn/categories/%E8%AF%AD%E5%BD%95/"/>
    
    
    <category term="语录" scheme="http://ai.mak.cn/tags/%E8%AF%AD%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是成长</title>
    <link href="http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/"/>
    <id>http://ai.mak.cn/2022/10/07/%E8%AF%AD%E5%BD%95/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E9%95%BF/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-12-28T09:41:32.236Z</updated>
    
    <content type="html"><![CDATA[<p>抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：</p><blockquote><p>  成长是一个逐渐被经验捆缚的过程，<br>    经验让人们不容易被蛊惑，<br>    也让人们逐渐认清自己的边界，<br>    知道自己不是无所不能，<br>    知道一腔热情并不值钱，<br>    但也知道世界上有比理想主义<br>    更重要、更基本的东西。<br>    一边狼狈着，一边温柔着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音刷到一个北大的3个85后聊中年危机的视频，文末的话值得随手摘一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  成长是一个逐渐被经验捆缚的过程，&lt;br&gt;    经验让人们不容易被蛊惑，&lt;br&gt;    也让人们逐渐认清自己的边界，&lt;br&gt;    知道自己不是无所不能，&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎么让猫吃辣椒</title>
    <link href="http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/"/>
    <id>http://ai.mak.cn/2022/09/20/%E6%9D%82%E8%AE%B0/%E6%80%8E%E4%B9%88%E8%AE%A9%E7%8C%AB%E5%90%83%E8%BE%A3%E6%A4%92/</id>
    <published>2022-09-19T16:00:00.000Z</published>
    <updated>2022-12-12T12:31:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看毛泽东传</p><p>记录这样有一个故事：</p><p>一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”<br>刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当自觉自愿的。”</p><p>周恩来回答说：“我首先让猫饿三天，然后，把辣椒裹在一片肉里，如果猫非常饿的话，它会囫囵吞枣般地全吞下去。”毛主席不赞成这种手法。</p><p>那么，毛主席的策略是什么呢?<br>毛主席笑着说：“这很容易，你可以把辣椒擦在猫背&#x2F;屁股上，当它感到火辣辣的时候，它就会自己去舔掉辣椒，并为能这样做而感到兴奋不已。” 　　 　　</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看毛泽东传&lt;/p&gt;
&lt;p&gt;记录这样有一个故事：&lt;/p&gt;
&lt;p&gt;一天，毛主席向刘少奇和周恩来提了一个问题：“你们怎样才能使猫吃辣椒？”&lt;br&gt;刘少奇首先说：“那还不容易，你让人抓住猫，把辣椒塞进猫嘴里，然后用筷子捅下去。”对于这种解决方法，毛主席摆了摆手说：“每件事应当</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac上用trash命令代替rm</title>
    <link href="http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/"/>
    <id>http://ai.mak.cn/2022/08/16/%E5%B7%A5%E5%85%B7/mac%E4%B8%8A%E7%9A%84trash%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-19T07:32:23.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文件找到也打不开了，PS，之前2太Mac 做备份，但目前就一台了，刚想着把资料备份到移动硬盘，出现这档子事儿。好在找回来一些资料，博客也只能重新搭建，资料一点一点找回来。</p></blockquote><p>于是决定替换掉rm命令</p><p>1、安装 trash</p><blockquote><p>brew install trash</p></blockquote><p>2、删除文件时候，使用trash -F代替rm，是把文件移动到“废纸筐”；</p><blockquote><p>trash -l，查看“废纸筐”；<br>trash -e，清空“废纸筐”。</p></blockquote><p>3、在环境配置中，把rm 命令替换掉，或者逐步习惯用trash，毕竟rm 不是友好的</p><blockquote><p>alias rm&#x3D;”trash”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在Downloads目录下发现很多word文档的临时文件，~$xxx.doc，强迫症，刚好在iTerm2下，就像直接删除，然后没过脑子执行了, rm -rf ~$* ！！！ 哇日，根目录被清空了，用磁盘恢复软件 + 移动硬盘，恢复了一个周末，好多文</summary>
      
    
    
    
    <category term="工具" scheme="http://ai.mak.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="mac" scheme="http://ai.mak.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>平凡日子里的挣扎</title>
    <link href="http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/"/>
    <id>http://ai.mak.cn/2022/08/14/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E5%87%A1%E6%97%A5%E5%AD%90%E9%87%8C%E7%9A%84%E6%8C%A3%E6%89%8E/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-10-20T23:12:28.063Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1970331106&amp;auto=1&amp;height=66"></iframe><p>关注曾抖抖，是之前听过跟他女儿合唱的 <strong>人间</strong></p><p>这首原创歌词，还是很贴合，从北京回来的地铁上～</p><blockquote><p>我知道 认真生活的人总是百般滋味 也知道 成年人的世界会在瞬间崩溃 我们都再平凡的日子里拼命挣扎 拼命想活成别人期待的人呐 就算四海为家 就算风吹雨打 也要微笑着说我还好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Openflow总结</title>
    <link href="http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/"/>
    <id>http://ai.mak.cn/2022/08/11/%E7%BD%91%E7%BB%9C/Openflow%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-10T16:00:00.000Z</published>
    <updated>2022-10-09T15:40:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Openflow详解"><a href="#Openflow详解" class="headerlink" title="Openflow详解"></a>Openflow详解</h2><p>　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而Openflow是一个具体的协议，这个协议实现了SDN这个框架中的一部分（南向接口），而且除了Openflow也存在别的同样功能的协议来完成相似的工作，Openflow的维护者是ONF组织。</p><p>　　Openflow被Controller用来控制网络设备，网络设备通过Openflow来反馈信息给Controller。</p><p>　　并且Openflow还规定了网络设备对报文的转发和编辑方式（flowtable），而是不同于传统的路由器和交换机设备。</p><p>　　Openflow协议涉及两个网络元素：<strong>Openflow Controller</strong>和<strong>Openflow Switch</strong>。Openflow协议有一部分运行在Controller上，另一部分运行在Switch上。</p><p>　　Openflow交换机转发面内部可以认为在逻辑上由两部分组成： Port 和 FlowTable。</p><p>　　<strong>FlowTable</strong>：流表就是芯片中一张张的转发表，每张流表都有很多条流表项组成。</p><p>　　<strong>FlowEntry</strong>: 流表项是流表中最小单位，每条流表项对应了网络中传输的一条流。流表项是Openflow中最核心的元素，根据Openflow标准，每条流表项由以下6个组成部分：</p><p>　　　　1、Match Field</p><p>　　　　2、Priority</p><p>　　　　3、Counter</p><p>　　　　4、Instruction</p><p>　　　　5、Timeout</p><p>　　　　6、Cookie</p><p>　　Controller和Switch之间的3种消息：</p><p>　　　　1、Controller-to-Switch消息： 这种类型的消息是从Controller发往Switch的，它包含以下几种子类型；</p><p>　　　　　　Features、Configuration、Modify-State、Read-State、Packet-out、Barrier、Role-Request、Asynchronous-Configuration</p><p>　　　　2、Asynchronous消息：用于交换机向Controller发送消息；目前定义了以下四种子类型;</p><p>　　　　　　Packet-in、Flow-removed、Port-status、Error</p><p>　　　　3、Symmetric消息：对称消息可以由任何一方发起；目前定义了如下三种子类型；</p><p>　　　　　　Hello（启动时通告）、Echo（获取reply确认连接状态）、Experimenter</p><ul><li>Openflow的系统性能指标：</li></ul><p>　　1、交换机处理带宽</p><p>　　2、流表项数量</p><p>　　3、流表项下发能力</p><p>　　4、To-Controller报文转发</p><h2 id="OF-Config介绍"><a href="#OF-Config介绍" class="headerlink" title="OF-Config介绍"></a>OF-Config介绍</h2><p>　　OF-Config是Openflow的一个伴侣协议，Openflow仅仅实现Flow的match-action相关的行为，但是Flow所依赖的很多资源，Openflow并不负责去管理。OF-Config需要去支持的工作范畴如下：</p><p>　　1、配置Openflow Controller地址</p><p>　　2、队列和物理端口的配置管理</p><p>　　3、逻辑端口的创建和管理</p><p>　　4、Controller和交换机之间通信通道的创建和配置，包括安全认证</p><p>　　5、交换机的能力发现</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>　　Controller是一个运行在独立的服务器上的软件程序，可以用各种不同的语言来实现，可以运行在不同的操作系统上。</p><p>　　一类是广义的Controller，也叫SDN Controller，这种Controller支持多种协议，Openflow只是其中的一种，目前OpenDayLight组织开发的就是SDN Controller。</p><p>　　一类是狭义的Controller，也叫Openflow Controller，Openflow是它唯一支持的协议。</p><p>　　Controller有很多个属性： 北向接口、集成的服务和应用、南向接口、控制方式、对物理和虚拟设备的通用管理、支持的Openflow标准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Openflow详解&quot;&gt;&lt;a href=&quot;#Openflow详解&quot; class=&quot;headerlink&quot; title=&quot;Openflow详解&quot;&gt;&lt;/a&gt;Openflow详解&lt;/h2&gt;&lt;p&gt;　　SDN是一种网络架构的理念，是一个框架，他不规定任何具体的技术实现。而O</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="网络" scheme="http://ai.mak.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nacos以mysql为数据源进行持久化，报“No DataSource set”错误</title>
    <link href="http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/"/>
    <id>http://ai.mak.cn/2022/08/09/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%20nacos%E4%BB%A5mysql%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E6%8A%A5%E2%80%9CNo%20DataSource%20set%E2%80%9D%E9%94%99%E8%AF%AF/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-10-08T14:48:08.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"><a href="#本机docker环境启动nacos，nacos以mysql为数据源进行持久化" class="headerlink" title="本机docker环境启动nacos，nacos以mysql为数据源进行持久化"></a>本机docker环境启动nacos，nacos以mysql为数据源进行持久化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nacos -p 8848:8848 -p 9848:9848 -p 9849:9849  --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql  -e MYSQL_SERVICE_HOST=192.168.1.123 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=ry-config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=mysql2017 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot; nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="启动时报错："><a href="#启动时报错：" class="headerlink" title="启动时报错："></a>启动时报错：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;memoryMonitor&#x27; defined in URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-2.1.0.jar!/com/alibaba/nacos/config/server/monitor/MemoryMonitor.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;asyncNotifyService&#x27;: Unsatisfied dependency expressed through field &#x27;dumpService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;externalDumpService&#x27;: Invocation of init method failed; nested exception is ErrCode:500, ErrMsg:Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1338)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1185)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:554)</span><br></pre></td></tr></table></figure><h3 id="查看nacos-log-报错"><a href="#查看nacos-log-报错" class="headerlink" title="查看nacos.log 报错"></a>查看nacos.log 报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#x27;root&#x27;@&#x27;192.168.1.123&#x27; (using password: YES)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61)</span><br><span class="line">at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>all privileges on <em>.</em> to root@’%’ identified by ‘123456’ with grant option;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot;&gt;&lt;a href=&quot;#本机docker环境启动nacos，nacos以mysql为数据源进行持久化&quot; class=&quot;headerlink&quot; title=&quot;本机docker环境启动naco</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>八卦</title>
    <link href="http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/"/>
    <id>http://ai.mak.cn/2022/02/02/%E6%9D%82%E8%AE%B0/%E5%85%AB%E5%8D%A6/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-12-12T12:24:34.785Z</updated>
    
    <content type="html"><![CDATA[<p>乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断</p><p>先天八卦又称为伏羲八卦。</p><p>乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乾三连坤六断，震仰盂艮覆碗，离中虚坎中满，兑上缺巽下断&lt;/p&gt;
&lt;p&gt;先天八卦又称为伏羲八卦。&lt;/p&gt;
&lt;p&gt;乾一、兑二、离三、震四、巽五、坎六、艮七、坤八。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java 日志规范</title>
    <link href="http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/"/>
    <id>http://ai.mak.cn/2022/01/27/java/java%20%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-10-08T14:20:52.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-开发日志规范"><a href="#java-开发日志规范" class="headerlink" title="java 开发日志规范"></a>java 开发日志规范</h1><h2 id="一-日志"><a href="#一-日志" class="headerlink" title="一. 日志"></a>一. 日志</h2><p>日志的作用：记录用户操作、系统运行状态，好的日志输出可以帮助研发和运维快速的定位问题以及系统瓶颈</p><h2 id="二-日志级别"><a href="#二-日志级别" class="headerlink" title="二. 日志级别"></a>二. 日志级别</h2><p>常见的日志级别有5种，分别是DEBUG，INFO，WARN，ERROR，FATAL，日常开发中，我们需要选择合适的日志级别</p><ul><li>DEBUG：调试问题使用，日常开发记得一定要打印出输入、输出、关键逻辑里面的运行时数据; </li><li>INFO：打印程序运行信息，启动信息等 </li><li>WARN：警告日志，打印一些警告信息，比如参数校验错误等等，需要<strong>开发关注</strong>； </li><li>ERROR：打印程序错误信息，对正常业务有影响，需要<strong>监控的</strong>，必须要打印上下文信息，方便查找问题 </li><li>FATAL：重大灾难信息，比如数据库无法连接等需要立即处理的问题</li></ul><h2 id="三-统一日志管理"><a href="#三-统一日志管理" class="headerlink" title="三. 统一日志管理"></a>三. 统一日志管理</h2><p>使用统一日志管理平台组件</p><h2 id="四-日志打印规范"><a href="#四-日志打印规范" class="headerlink" title="四. 日志打印规范"></a>四. 日志打印规范</h2><p>开发过程中，应遵循以下日志打印规范</p><h3 id="1-打印出方法的入参、出参"><a href="#1-打印出方法的入参、出参" class="headerlink" title="1. 打印出方法的入参、出参"></a>1. 打印出方法的入参、出参</h3><p>原则：不需要打印很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>如：方法进来的时候，打印<strong>入参</strong>，在方法返回的时候，就是<strong>打印出参，返回值</strong>。</p><h3 id="2-选择合适的日志格式"><a href="#2-选择合适的日志格式" class="headerlink" title="2. 选择合适的日志格式"></a>2. 选择合适的日志格式</h3><p>日志格式，应当包含以下基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等，</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;EagleEye-TraceID&#125;] [%thread] %-5level %logger&#123;36&#125;- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-if…else…或switch等条件时，每个分支首行都尽量打印日志"><a href="#3-if…else…或switch等条件时，每个分支首行都尽量打印日志" class="headerlink" title="3. if…else…或switch等条件时，每个分支首行都尽量打印日志"></a>3. if…else…或switch等条件时，每个分支首行都尽量打印日志</h3><p><strong>if…else…或者switch</strong>这样的条件判断，可以在分支的首行打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><h3 id="4-日志级别比较低时，进行日志开关判断"><a href="#4-日志级别比较低时，进行日志开关判断" class="headerlink" title="4.日志级别比较低时，进行日志开关判断"></a>4.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10000L</span>, <span class="string">&quot;hello树&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前有如下的日志代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>如果<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"><a href="#5-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok" class="headerlink" title="5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用Lombok提供的快速日志记录方式，日志打印统一使用Lombok"></a>5. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API，推荐使用<strong>Lombok</strong>提供的快速日志记录方式，日志打印统一使用Lombok</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换，建议直接类添加<code>@Slf4j</code>注解，直接使用<code>log</code>调用对应级别的方法即可</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UscApiServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UscApiService</span></span><br></pre></td></tr></table></figure><h3 id="6-建议使用参数占位-，而不是用-拼接。"><a href="#6-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="6. 建议使用参数占位{}，而不是用+拼接。"></a>6. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.info(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;UserApiServiceImpl | queryRateByPayType | payType:&#123;&#125;&quot;</span>,payType);</span><br></pre></td></tr></table></figure><p>使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以提升性能。</p><p>开发环境、测试环境日志级别可以根据需要配置成info或debug级别，线上环境需要配置成info级别。</p><h3 id="7-使用异步的方式来输出日志。"><a href="#7-使用异步的方式来输出日志。" class="headerlink" title="7. 使用异步的方式来输出日志。"></a>7. 使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>使用异步的方式来输出日志。以logback为例，要配置异步，使用AsyncAppender</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-不要使用e-printStackTrace"><a href="#8-不要使用e-printStackTrace" class="headerlink" title="8. 不要使用e.printStackTrace()"></a>8. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。 </li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了。</li></ul><h3 id="9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密"><a href="#9-异常日志不要只打一半，要输出全部错误信息-日志打印时要将敏感字段脱敏或加密" class="headerlink" title="9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密"></a>9. 异常日志不要只打一半，要输出全部错误信息,日志打印时要将敏感字段脱敏或加密</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;程序有异常啦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</p><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    LOG.error(<span class="string">&#x27;你的程序有异常啦&#x27;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-禁止在线上环境开启-debug"><a href="#10-禁止在线上环境开启-debug" class="headerlink" title="10. 禁止在线上环境开启 debug"></a>10. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug相当占用磁盘资源，影响业务系统的正常运行。</p><h3 id="11-不要记录了异常，又抛出异常"><a href="#11-不要记录了异常，又抛出异常" class="headerlink" title="11.不要记录了异常，又抛出异常"></a>11.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;IO exception&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(e);</span><br></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="12-避免重复打印日志"><a href="#12-避免重复打印日志" class="headerlink" title="12.避免重复打印日志"></a>12.避免重复打印日志</h3><p>避免重复打印日志，如果已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-日志文件分离"><a href="#13-日志文件分离" class="headerlink" title="13.日志文件分离"></a>13.日志文件分离</h3><ul><li>可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：将不同级别的日志分别打印到不同的日志文件中$&#123;log.moduleName&#125;-error.log、$&#123;log.moduleName&#125;-warn.log、$&#123;log.moduleName&#125;-info.log、$&#123;log.moduleName&#125;-debug.log等</span><br></pre></td></tr></table></figure><ul><li>也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便。</li></ul><h3 id="14-核心功能模块，建议打印较完整的日志"><a href="#14-核心功能模块，建议打印较完整的日志" class="headerlink" title="14. 核心功能模块，建议打印较完整的日志"></a>14. 核心功能模块，建议打印较完整的日志</h3><ul><li>日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>多详细？如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以。</li></ul><h3 id="15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"><a href="#15-系统对外的接口-或者调用其他系统的接口入参、出参必须打印出来，日志级别为info" class="headerlink" title="15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info"></a>15. 系统对外的接口,或者调用其他系统的接口入参、出参必须打印出来，日志级别为info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;RPC | snt-upc | AppPayApiService | queryPayResult | start | appPayQueryDTO:&#123;&#125;&quot;</span>, JSON.toJSONString(appPayQueryDTO));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-开发日志规范&quot;&gt;&lt;a href=&quot;#java-开发日志规范&quot; class=&quot;headerlink&quot; title=&quot;java 开发日志规范&quot;&gt;&lt;/a&gt;java 开发日志规范&lt;/h1&gt;&lt;h2 id=&quot;一-日志&quot;&gt;&lt;a href=&quot;#一-日志&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="java" scheme="http://ai.mak.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java  架构设计全攻略</title>
    <link href="http://ai.mak.cn/2019/12/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://ai.mak.cn/2019/12/29/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%A8%E6%94%BB%E7%95%A5/</id>
    <published>2019-12-28T16:00:00.000Z</published>
    <updated>2023-01-09T06:00:35.945Z</updated>
    
    <content type="html"><![CDATA[<p>正文开始前，先花大量笔墨推荐几个我工作中常用的思考框架、实践框架，后续文章中会使用这几种思考框架作为工具来描述、拆解、分析问题。当然你也可以使用到其它工作内容中，掌握几种利器，比无头苍蝇样做事效率会高很多。</p><h2 id="一-几个思考、实践框架"><a href="#一-几个思考、实践框架" class="headerlink" title="一. 几个思考、实践框架"></a>一. 几个思考、实践框架</h2><h3 id="1、目标驱动、可量测的行动框架"><a href="#1、目标驱动、可量测的行动框架" class="headerlink" title="1、目标驱动、可量测的行动框架"></a><strong>1、目标驱动、可量测的行动框架</strong></h3><p>OGSM 是 Objective（目的）、Goal（目标）、Strategy（策略）、Measurement（测量）的英文首字母组成。一种实践策略的手段，以达成理想的目的与目标。</p><p>学术界一个研究方向快速进展的关键，是清晰地定义了问题的目标函数。当年 Google 和雅虎的几位大师把广告清晰地定义为一个优化问题，这个领域的进展才日新月异。按照某前辈的话说，管理一个工程团队，只需要做好两件事：一是 <strong>定义好目标</strong>，二是建立一个 <strong>评测系统</strong>。 可见目标、可量测不是神秘职务，在各个领域都有案例。</p><p>当我们做事情时候，可以按照以下流程来实践：</p><ul><li><p>目的：明白领导意图。通常这个目的是领导层或上层给予执行层面、部门、团队的任务。通常比较含糊或者宏大，一方面不容易快速达到，另一方面这个目的，对于执行者来说，很不容易测量。</p></li><li><p>目标：当我们面临一项任务或目的时候，都会把目的拆分为 <strong>易执行</strong>、 <strong>可量测的小目标</strong>。 可以拆解成小目标、小任务，排优先、定重点、分配给下属、并制定 KPI 或 OKR 关键性指标。</p></li><li><p>策略：执行层面考究团队执行力，可以针对小目标或可量测指标，做很多 TIP 或工作策略。例如：写代码时，对代码的测试覆盖、结对编程、Code Review 等。具体到不同时期，有不同方法论，这里暂不展开。</p></li><li><p>量测：拆解的目标必须是可量测、可量化，有指标可以衡量任务是否完成、完成度等。如果特别特别放到量测指标，其实算过度 KPI， 对我们架构创造性事情，需要更深层次考虑。毕竟，软件不是富士康计件类型工作。</p></li><li><p>不断迭代：通过量测指标，不断调整执行策略，甚至调整拆解目标。小步快进，达成目的，良好的完成上游给予的任务。</p></li></ul><p>业内实践或很多书籍，从不同角度验证该工作方法的适用：</p><ul><li>很多运营方面，尤其是增长黑客、数字营销方面工作，特别强调数字指标设定、运营方法、迭代运营。比如：《增长黑客》中海盗模型转化漏斗，以及衍生出来一些列案例；《运营之光》提到的“优秀的运营要以目标为导向，主动行事。”</li><li>目标驱动、数字衡量的新型运营手段：大数据时代，数据带给决策更加丰富、准确的素材或理由。改变了企业运营、运作的传统方法。个人认为传统运营偏文科一些，需要更多活动策划、文案文字相关工作。而有些领域，如计算广告中，广告优化师，需要很强的数据能力。市面上运营两类书，一类一看就是文科写的，增加很多数据指标之类问题，不深入，但写的很好看。后一类一看理科生写的，很多数据模型，但是看得很头大。</li><li>测试先行的敏捷实践：当项目足够复杂的时候，想要保证尽可能的减少 Bug，有两种有效的方式分别是代码审核和测试先行。我们完成正式逻辑前，先编写测试用例，就是编写量测方法。</li><li>ABTest 的产品衡量手段：ABTest 在互联网公司广泛使用，并在各个领域发扬光大。比如：拆分用户，针对不同用户界面功能使用投票等。推荐系统中评估体系的建设。广告优化师，通过不断的调整素材、定向等优化投放姿势。甚至抖音这类 App，整体产品逻辑，就是“ABTest ”。</li><li>机器学习算法中，假设空间、优化目标、寻解算法三角中，优化目标的设计是为了设定衡量标准。可以说机器学习、深度学习背后的理论，跟测试用例编写是很像的。注：例子还可以很多，前面例子可以当成一个职业方向去学习研究，这里点到为止，也可以留言沟通交流。</li></ul><h3 id="2、互联网思维-迭代思维"><a href="#2、互联网思维-迭代思维" class="headerlink" title="2、互联网思维-迭代思维"></a><strong>2、互联网思维-迭代思维</strong></h3><p>“迭代思维”是互联网产品开发的典型方法论。“天下武功，唯快不破”，只有快速地对消费者需求做出反映，产品才更容易贴近消费者。这里暂且不说这个“快字”，按照我们传统思维方式，我已经足够了解产品需求了，我直接设计满足用户需求的产品不就可以了嘛？答案是否定的！</p><p>互联网产品是迭代而成的，（无数案例证实这点，这里不展开篇幅）！那么我们为这些产品设计的后台、前台、数据架构，也必定是迭代而成的！按照达尔文进化论来解释的话，物种是迭代进化而来的。人这个物种对外界的需求、诉求、主动变革，都在不停地迭代。那么软件产品、架构也肯定需要迭代。</p><p>产品生命周期理论如图1所示（PLC 模型）是由美国经济学家 Raymond Vernon 提出的，即一种新产品从开始进入市场到被市场淘汰的整个过程。用户、产品、人、事都存在生命周期。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20191228/3b00282cd1b0483493847748ebcf8e84.jpeg" alt="img"></p><p>图 1 PLC模型</p><p>从另一方面来看，我们看待用户、产品、人、事，绝对不能是静态思维，我们制定计划、制定目标时候，不可能是不变的。举个例子：笔者原来在北大方正工作，每年集团都会制定***战略目标，等落实到各个子公司、子部门时候，整体外部环境都已经改变，这些“战略目标”很可能不合适了，但是由于集团最大，也没法反驳。造成整个集团、公司 运转效率、努力方向、同业竞争都产生很大的问题。</p><p>这个问题摊开讲，会很复杂，回到软件架构这一领域，一定要明白架构是从简单合适，通过业务需求推进，再到复杂的演进过程。近一年挺火的中台概念，阿里需要中台，难道小创业公司也需要中台战略吗？不了解中台演进或推进中台的业务需求痛点，根本了解不了中台，更不可能架构好。</p><h3 id="3、5W1H-认识、分析一件事物时的思维方法"><a href="#3、5W1H-认识、分析一件事物时的思维方法" class="headerlink" title="3、5W1H-认识、分析一件事物时的思维方法"></a><strong>3、5W1H-认识、分析一件事物时的思维方法</strong></h3><p>IT 从业者要不断面临新的语言、新的技术、新的框架，如何才能快速学习、认知一门新技术呢？5W1H（WWWWWH）分析法也叫六何分析法，是一种思考方法，也可以说是一种创造技法。在企业管理、日常工作生活和学习中得到广泛的应用。</p><p>5W+1H：是对选定的项目、工序或操作，都要从原因（何因 Why）、对象（何事 What）、地点（何地 Where）、时间（何时 When）、人员（何人 Who）、方法（何法 How）等六个方面提出问题进行思考。</p><p><strong>实践案例：</strong></p><p>认识 Redis、认识微服务、认识 Docker、Kubernetes、认识机器学习、认识深度学习，让我们面临新的技术或概念时候，都会需要学习。我是怎么学习的呢？</p><p>以 Redis 为例，不一定强调内容全面或完全正确，主要体会思考学习方法：</p><ul><li>What： 基于内存实现的 K-V 存储系统； 内存数据库； NoSQL； 支持 sting、list、set、hashmap、zset 五种数据结构。</li><li>Why： 在分布式系统中，本地缓存不能满足需求。 分布式缓存系统，类似框架 Memacache、基于 SSD 低磁盘的成本分布式缓存系统。</li><li>Where：相当于使用场景。如果系统按照 App-&gt;Gateway-&gt;Service-&gt;Dao-&gt;持久层来分的话。Dao 与持久层（MySQL）之间使用，减少与持久化数据访问频率，提高 QPS；Service 层可以使用，例如：做一些业务缓存；Gateway 层，也可以把鉴权 token 放到 Redis 中。</li><li>When：性能、QPS需要提升时，缓存是第一时间想到的解决手段。当然 Redis 扩展出很多其它用法，例如：分布式锁、分布式优先队列、布隆过滤器、set 交集等较为高级用法。</li><li>Who：通常架构师、后端工程师使用。</li><li>How：API 查阅文档，看看例子就能明白。</li><li>类似比较学习：当我们认识新事物时候，类比法也是特别好的使用方法。假如我么使用过本地缓存 Ehcache、Guava，再去学习 Redis 会简单很多。</li></ul><p>近几年我很少看源码，不是源码不重要，而是你了解了初衷后，对框架本身兴趣点会降低，而会思考生态，思考思维路径。摘录一段如下，期望有启发：</p><blockquote><p>建议大家观看一个视频，伟大领袖如何激励行动 TED 演讲：伟大的领袖如何激励行动_腾讯视频 ；里面提到一个非常有意思的认知“三环”,绝大多数人是由外而内（What&#x3D;&gt;How&#x3D;&gt;why），但伟大的公司或领导者，思考的路径通常是由内而外（why&#x3D;&gt;How&#x3D;&gt;what），团队或者客户认可的常常是你的理念&#x2F;信念即“为什么”，从而愿意接受你的产品或服务。</p></blockquote><h3 id="4、多元视角看问题"><a href="#4、多元视角看问题" class="headerlink" title="4、多元视角看问题"></a><strong>4、多元视角看问题</strong></h3><p>著名的大文豪苏轼的《题西林壁》</p><blockquote><p>横看成岭侧成峰，远近高低各不同。</p></blockquote><blockquote><p>不识庐山真面目，只缘身在此山中。</p></blockquote><p>猎豹 CEO 傅盛曾说：</p><blockquote><p>一个创业者想要成功，首先要用多种视角看事情。</p></blockquote><blockquote></blockquote><blockquote><p>在看待问题时候，既将自己深入其中，能敏锐感受内里变化；抽身其外，又能让自己变成一个旁观者，观察很多事情的发生和结果。</p></blockquote><blockquote></blockquote><p>如果看问题的视角只有一种，即从自己出发的视角，我们看到的世界就会过于局限。笔者传统 i 行业转型互联网创业过程中，对这点深有体会。以前都是站在技术角度看问题或个人视角看问题，根本不会站在用户角度思考。</p><blockquote><p>“微信之父”张小龙就曾说，乔布斯最厉害的地方是什么？“乔布斯最厉害的地方是他 1 秒钟就能变成傻瓜，而马化腾大概需要 5 秒钟，而我差不多需要 10 秒钟。”</p></blockquote><blockquote><p>所以，更重要的是思维观念上的通达，越聪明的人越可以“大道至简”</p></blockquote><blockquote><p>周鸿祎喜欢用“一分钟变小白”来作为评价产品经理能力的一个要素。而张小龙，据传私下里说过“我可以在五分钟内变成小白，而马化腾立即就可以”这样的话。无论真假，可以看出“变小白”这种能力在这几位产品大拿眼里是极其重要的，以至于变小白的时间的长短决定了产品能力的段位。</p></blockquote><blockquote></blockquote><blockquote><p>这三位所说的“变小白”，其实是“变用户”，也就是从“产品设计人员”或“产品经理”的角色切换为“用户”角色。只不过由于这三位所掌控的产品面向的用户以“小白”为主，所以有了“变小白”一说。</p></blockquote><p>一个人有足够的视角或多维视角观察能力，总是能认清楚要解决的问题，找准目标、确定方向，执行上如何错误，至少是在进步。如果不能全面的掌握问题，使劲的方向都不对，可能会事半功倍。</p><p>前几天跟群里几个同学聊起中台，有的同学拿起微服务说事，有的拿起标准说事，有的说是什么新的框架技术，有的转发了微信的几篇中台文章，我感觉都不是全面或准备。为什么，因为视角不对，中台战略最终受益者是谁呢？我觉得站在最终受益者（用户）视角考虑整个问题可能会全面些！</p><blockquote><p>据说连马云都带人去北欧 Supercell 学习所谓的“大中台架构”，据此调整阿里巴巴的组织结构，以 <strong>避免了大公司常见的部门与部门争夺资源</strong>，不同的小组做同样的事情。</p></blockquote><p>如果以上为真的话，按照 OGSM 框架分析一下。马教主为了避免“大公司常见的部门与部门争夺资源，不同的小组做同样的事情” ，提出大中台架构的目的。各个执行部门针对教主提出的目的，制定自己职权内的目的、目标。技术部门或事业群接收到任务不同，拆分出业务中台、数据中台的概念。我们换个视角思考， 公司的组织结构需要调整吗？考核标准需要调整？奖金激励手段需要调整吗？权利责任各个组织结构节点变了吗？个人在创业公司，这辈子有可能不会做中台相关工作，理解不深，展开也说不清楚（憨笑）。如果我们理解一个新的概念时候，可以换多个视角或提升视角，站在更高的角度看这个问题，可能会更加全面，那么处理手头面临的问题时，会很容易。</p><p><strong>分享几个视角：</strong></p><p><strong>宇宙视角：</strong>宇宙视角能将我们禁锢已久的国与国、区域与区域、地区与地区、公司与公司、个人与个人的界限彻底打破，从而带给我们更为广博的胸怀以及更加宽阔的视野。 说白了，自己能跳出利益，看清楚利益相关方的嘴脸，灵魂附体后再争取利益时，会更有优势（汗一下自己）。</p><p><strong>利益相关方视角：</strong>做商业产品或撮合交易系统，尤其需要有这方面能力。当然要站在不同利益相关方看问题，需要有同理心、换位思考等等更方面的训练。可以看一些产品方面的书籍。</p><p><strong>用户视角：</strong>产品经理需要经常用用户视角来思考。当我们做系统、架构时，必须了解是谁使用它。可以确定的是，肯定不是自己使用，所以切勿以自我为中心的思考、设计等。</p><p><strong>时间线视角：</strong></p><ul><li>你可以让自己退后一步，离开正在进行的一切，站在时间线的后面，注视它，感受它。 眼前这根时间线代表的正是你的一生，它像是一条不断奔涌向前的河，不论你是否正在其中，还是已经退后一步，它的奔涌都从不止息。</li><li>你也可以试着站在未来某一时点上看问题，它能让我们从此时此刻的纠结中抽离出去，站到更远一点的地方回望。</li><li>当我们不知道自己真正想要什么、真正在乎什么的时候，可以尝试时间线临终视角。 它能帮我们滤尽铅华，看清内心真实渴望，甚至是我们的核心价值观。</li></ul><h2 id="二-这些模型如何在架构设计中使用？"><a href="#二-这些模型如何在架构设计中使用？" class="headerlink" title="二. 这些模型如何在架构设计中使用？"></a><strong>二. 这些模型如何在架构设计中使用？</strong></h2><p><strong>第一、</strong> 使用目标驱动的行动框架。 明确我们要去哪里？知道架构设计的目的、阶段性目标， 才能有针对性的少走弯路。</p><p><strong>第二、</strong> 我们怎么才能知道我们现在在哪？ 明白评价架构、系统的常见评价体系，才能针对目标，一步一个台阶的走下去。评价指标通常是与数据相关的，但是容易评估的目的，往往是简单容易实现或案例很多的。</p><p><strong>第三、</strong> 无论我们面对的需求或目标多么高大，路要一步一步走，饭要一口一口吃。 零零散散各个目标指标，只能有侧重、有优先不断迭代、夯实、拔高的达到目标。</p><p><strong>第四、</strong> 如何理解大厂、书籍、国外传播的最佳实践呢？ 我们需要明白，任何最佳都是迭代出来的，而不是一蹴而就的。</p><p><strong>第五、</strong> 针对架构设计目的，常用的有哪些手段呢？ 我们如何建立自己的武器库，常见的解决问题的手段呢，通过 5W1H 来了解梳理。</p><p><strong>第六、</strong> 架构师岗位是与其他岗位高度协同的岗位，了解业务、了解其它岗位、协同人职责视角很重要。 多元视角不光可以让自己更深刻理解架构本身，还可以了解业务、了解场景，更有效的协同工作。</p><p>注：文章只是抛砖引玉，笔者也是在其它岗位的一些经验，反哺总结到架构岗位上。不一定正确，适合自己的才是最好的。</p><h2 id="三-架构定义"><a href="#三-架构定义" class="headerlink" title="三. 架构定义"></a><strong>三. 架构定义</strong></h2><p>软件架构（Software Architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。其实我们把架构当成一个技能、工种、职位、岗位，<strong>核心还是为了应对软件设计、构建中的复杂度，降低成本、提升效率。</strong></p><p>对我们常见系统做一下分类。如果按照行业分，篇幅不够、积累也少，无法全面分类。这里尝试按照时间线分类，后面阅读会更加顺畅一些。</p><p><strong>事中业务</strong></p><p>常见的业务系统。如：电商、交易系统等等大多属于这类。实际业务中，对业务反馈需要越实时，实现难度相对越高，比如：共享单车APP、股票交易等，需要实时的提示、预警、交互。除了传统型业务型架构外，对大数据流计算架构要求逐步提高。</p><p><strong>事后业务</strong></p><p>事后肯定有数据沉淀，有数据肯定可以对未来决策做指导。自然而然查询统计、报表决策、数据挖掘、事后总结等数据应用类系统。</p><p><strong>事前业务</strong></p><p>事前基本为业务预测、分类、推荐、决策辅助灯业务。随着机器学习、深度学习的火热，这部分应用越来越广泛。例如：量化投资、广告点击率预测、短视频推荐、电商推荐等。</p><p><strong>趋势</strong></p><p>人类欲望膨胀，业务需求无止境，从而推进技术、架构发展。人工智能、流计算、大数据发展，离线&#x2F;在线、事后&#x2F;事前&#x2F;事中、人工决策&#x2F;机器预测 等界限已经很模糊。也是我个人认为的技术方向， 大数据、流计算、推荐系统、广告系统。（机器学习、深度学习等业务系统）。</p><h2 id="四-架构目的有哪些？"><a href="#四-架构目的有哪些？" class="headerlink" title="四. 架构目的有哪些？"></a><strong>四. 架构目的有哪些？</strong></h2><p>架构的目的其实每个架构师、程序员都很清楚，或日常工作中自然而然都会面对。但是我们很容易迷失自我。如果你是个架构师，现在闭上眼睛，回想三十秒，想想当天工作内容的解决了什么问题？达成什么目的？晚上加餐学习内容的目的是什么？是在熬时间等工资？是在踢皮球推卸责任？还是为了少干点活？还是学习新的知识为了提升个人价值，升职跳槽？</p><p>面试时，面试官通常会从项目经验中考察以下几点：<strong>业务复杂引起的复杂度</strong>、 <strong>数据量引起的复杂度</strong>、 <strong>用户数引起的复杂度</strong>。 比如，做过什么项目，是否了解电商交易系统？你们用户数有多少，峰值 QPS 多少？你们一天产生多少数据？如何存储处理等？</p><p>面临架构设计 Case 时候，无论是架构升级、还是构建架构地基，主要目的肯定只有一到两个。比如：用户规模扩大，原有架构在并发、性能上无法容忍；又如：业务快速发展，7*24 小时运转下，升级迭代新功能太麻烦， 是否可以考虑微服务架构等。</p><p>如果从客观来说，架构需求肯定包含在以下需求之列：<strong>高并发、高性能、高可用、安全性、规模扩展性、规模成本</strong>。 书籍、网上都是这样说的，因为这样说都没错。</p><p>小节：基本很多书上、文章都有讲解，下面来点很少地方能看到的知识点！就算我们设计的架构，都能满足需求，达到目的，算合格的架构吗？答案是不算！为啥，回到前面 OGSM， 能够明确量测方式、可量化任务的目的、目标，其实都不是难事。我们做很多事情时，尤其是探索性架构师，可量测性其实是很模糊的。<strong>举个例子：****当初 MapReduce 框架刚出来时，谁有说它慢呢？是否直到 Spark 在更短时间完成相同任务，才发现 MapReduce 框架如此之慢！</strong></p><p><strong>所以是否有个结论，可量测方法、量化指标都是在实践后的结果</strong>。 当然，不是说目标的评测不重要，对于初学者肯定是重要的， 但是用这些评价架构或评判事物，可能陷入自欺欺人的境地。</p><h2 id="五-如何评测这些目标？"><a href="#五-如何评测这些目标？" class="headerlink" title="五. 如何评测这些目标？"></a><strong>五. 如何评测这些目标？</strong></h2><p>SLA 服务等级协议(Service-Level Agreement)，指的是系统服务提供者（Provider）对客户（Customer）的一个服务承诺。这是衡量一个大型分布式系统是否“健康”的常见方法。SLA 设定一些指标，来考核、衡量系统。</p><p><strong>1. 系统可用性：</strong>也就是常说的 4 个 9、5 个 9 指标。</p><p><strong>2. 准确性或错误率：</strong>可以简单理解为 错误请求数&#x2F;全部请求数&#x3D;错误率。</p><p><strong>3. 系统容量&#x2F;吞吐量&#x2F;预期负载：</strong>也就是常说的 QPS&#x2F;TPS 等， 每秒可处理的查询数或事务数。</p><p><strong>4. 延迟或 RT 等：</strong>系统响应时间。</p><p>注：关于这部分概念，上网查询即可，不展开描述。</p><p>当系统架构在不停迭代的时候，有了一个明确的 SLA，我们可以知道下一个版本架构的改进目标以及优化好的系统架构是否比上一代的系统 SLA 更加优秀。当然评测系统还有很多其它指标，比如：可扩展性，随着云计算的发展，硬件层面扩展性基本不用考虑，我们通常考虑业务需求的扩展性即可， 但这个需求、业务扩展往往无法衡量，而架构师又容易过渡设计，是个考验架构师火候的指标之一。还比如分布式系统数据一致性、持久性、数据可靠性能，这里不展开阐述。</p><p>当架构搭建基础较好的时候，这些指标其实比较容易提升。从另外一方面说，真正架构难度，不是业务架构，而是 <strong>支撑核心业务稳定运行的点点滴滴</strong>，以微服务为例来看：</p><ul><li>冗余部署是提高系统可用性唯一法宝。服务的冗余部署，是为了提升系统可用性。另外使用微服务架构，有个很重要目标，就是要无感知升级系统模块。汽车的备用轮胎也可以提升汽车可用性，但汽车爆胎后，需要换轮胎的时间，这个可用级别上不去。而微服务，把功能拆分成小服务，可以通过技术手段，无感知的升级。</li><li>服务治理都会包含服务监测、预警功能。当服务错误率达到一定阈值， 很可以报警或开启限流、服务降级、熔断等策略，把影响降低到最小。</li><li>微服务架构中，通常会在在 Gateway 层，甚至 Service、Dao 层 设置限流措施。当流量大于预期时，开启防御手段。也有一些弹性扩容的设定，当流量大于阈值时，自动扩展服务，应对突发流量，这个过程甚至不用人工参与。</li><li>系统延迟或相应时间，也会在服务监测平台设置相应指标，超过阈值时，启动相关服务降级、限流、熔断等策略。</li></ul><p>注：个人理解，其实微服务、Kubernetes 等，很大一部分功能都是为了应对 SLA 的智能化扩展。</p><h2 id="六-架构设计常用手段"><a href="#六-架构设计常用手段" class="headerlink" title="六. 架构设计常用手段"></a><strong>六. 架构设计常用手段</strong></h2><p>相信大多数人都认同，与其说架构是设计出来的， <strong>不如是说抄袭或拼装而成的</strong>。 所以我们需要熟悉常用的手段或成熟的框架来解决日常工作中的问题。每个架构师工作经历不同、应对过的业务系统不同、兴趣点不同，手头的弹药库也不同。我列举一些自己认为重要的知识点或框架。（前端太久没接触，只列举后端，大多以微服务为例，后续文章有机会展开探讨）</p><p>业务处理相关技术点和框架</p><p><strong>单机：****高性能、高并发手段相关</strong></p><p><strong>1. 单机高性能手段：</strong> 可以上网查询 C10K 问题，获取相关文章。 把进程、线程、池、IO 多路复用相关知识点弄清楚。</p><p><strong>2. 分清楚 IO 密集型和 CPU 密集型场景：</strong> 一般互联网应用多为 IO 密集型。 但是类似：滴滴出行、股市量化投资、在线游戏之类，属于 IO 密集型和 CPU 密集型并存的场景，甚至对响应时间要求也很高。幸好大多数 CPU 密集型应用也是多租户、区域独立性架构，容易扩展拆分。</p><p><strong>3. 程序访问存储介质或链路快慢：</strong> 程序肯定要与存储进行消息交换。 一定明白，CPU 高速存储器、内存、SSD 硬盘、机械硬盘、同交换机网络、同机房网络、同城网络、同运营商网络等。细节展开很多内容，包含缓存、CDN、多机房等，从细节编程到部署架构的知识点。</p><p><strong>集群：****高性能、高并发相关</strong></p><p><strong>1. 负载均衡反向代理：</strong> 其实把 Nginx 了解就可以了。 如果是初创小公司，基本使用云上 SLB 负载均衡(Server LoadBalancer)就可以， 如果需要自建机房，有专门运维负责这些工作，到时候补补 LVS、F5 相关技术即可。</p><p><strong>2. 服务无状态：</strong> 以微服务为例来说，服务无状态会带来太多的好处，扩展冗余部署服务会很方便。 不谈微服务，就说前后端分离，鉴权这块 token 的实现，其实根本目的也是把用户状态剥离出来，实现服务的无状态化。（提个小插曲，估计老人才了解 J2EE EJB 规范，当初居然专门设计了一个 sessionBean 有状态的服务规范）。</p><p><strong>3. 任务（服务）拆分：</strong> 可以理解为服务拆解、功能拆解。 其实拆分准则很多，可以按照实际需求来权衡。比如：按照人头分、按照功能划分、按照数据库表划分、按照功能重要性划分、按照功能访问频度划分。不过，水平按照 Gateway、逻辑层、数据层、存储层算基本规范了。</p><p><strong>4. 常用的语言及框架：</strong> 了解语言特性，如 Node 语言的快速开发、前后端语言一致带来的便利、多路复用回调的原生支持等； go 语言 “goroutines”特性带来的编程便利；Java 优秀的生态及开源框架；C++性能优势等。当然技术选型，跟团队及业务成熟度很大关系。</p><p><strong>5. 缓存：</strong> 分布式缓存是提升系统性能利器。基本掌握 Redis 即可，需要知晓 Codis 和 Redis 官方集群部署方式。</p><p><strong>6. 消息队列：</strong> 消息队列也是常用提升系统性能利器，如业务逻辑异步化、削峰、解耦等。 熟悉 Kafka、RocketMQ即可。</p><p><strong>高可用手段（集群）：</strong></p><p>高可用手段核心解决思路是冗余部署，同样的服务冗余多份，会带来服务出错通知、服务自动切换、容错等一系列问题。高可用的实现更有技术含量，现在微服务框架服务治理组件，很多在高可用上做创新突破。（高性能冗余部署为了扩展节点，带来更高的处理性能）</p><p><strong>1. 服务无状态：</strong> 当某个服务故障时，自动切换到新的服务，不用产生状态丢失等问题。</p><p><strong>2. 调用方支持超时、重试配置：</strong>由于网络抖动等原因，某个服务可能某次调用不可用，调用方需要重试重新调用。 当然超时是调用方通用遇到的故障之一，也会有在其它故障发生，然后发起重试的配置。</p><p><strong>3. 被调用方需要幂等支持：</strong> 显而易见，无论是重试、还是调用方自动切换到的新的服务， 被调用方服务幂等支持的必备的。</p><p><strong>4. 服务状态监测：</strong> 所有服务都可用，那是理想情况。 当某个服务发生故障时，整个体系必须知道这个服务有问题了，重试调用多少次也不会成功了。按照微服务框架来说，需要两方知道这个信息：1、服务注册组件。2、服务上游调用方。当然报警让运维技术恢复是常规。</p><p><strong>5. 服务状态通知：</strong> 按照微服务架构，服务的状态 在注册中心都会体现。 但是注册中心跟服务之间一般是通过心跳来检测的，有时间延时。另外，服务调用方会缓存注册中心数据，其中就包含服务状态。所以说，从注册中心获取服务状态，是有延时，可能会造成很多无效的请求。高效的服务状态机制，很难组件化框架化， 所以这块需要高性能、较实时的自研通信机制或高性能集中存储机制保证。具体可以留言讨论或后续文章探讨。</p><p><strong>6. 调用方智能路由：</strong> 除了负载均衡以外，当调用方 A1 知晓下游服务 C1 故障后，可以自动切换到 C2 等服务上。 另外，通过服务状态通知机制，最好可以告诉 A2、A3，C1 服务故障了，你们别去尝试了。</p><p><strong>7. 服务故障恢复有，状态通知机制：</strong> 这部分就比较简单了。 注册中心状态变化后，调用方会慢慢更新注册中心元数据，来获取最新状态。当时，如果有更实时的消息机制，时效性会更高。</p><p>系统可靠性（牺牲少部分可容忍体验，降低问题到最低）</p><p><strong>8. 服务（功能）分类</strong>： 不管是微服务框架也好，单体框架也好，架构师必须对功能、服务进行分类。分类维度很多，比如：重要程度、QPS 量级、是否可以降级停止等等。</p><p><strong>9. 应用限流：</strong> 对于一般规模的应用，在 Gateway 层做即可，从源头保护整个应用。 对于超大应用（个人没经验），我觉得架构会更加复杂，可能 Gateway 会分为很多层或多个，甚至有业务中台，层次会更复杂。</p><p><strong>10. 服务降级：</strong> 服务是在服务分类的基础上的。 比如：百度贴吧的发帖功能，信息流广告功能，紧急情况下是可以降级处理的。可以人工或自动执行。其实 限流也是一种特殊的服务降级。（服务可以是个功能、也可以是接口，就看团队内如何达成一致）</p><p><strong>11.</strong> <strong>接口熔断：</strong> 熔断一般在接口方法级别，因为调用链路很长，容易引起调用雪崩。 让某个接口方法出现问题，我们可以按照预定配置处理业务，快速返回预设结果，防止整个链路的奔溃。</p><p><strong>12. 弹性扩容：</strong> 弹性扩容是理想的智能运维，但是具体操作也做大厂才会做相关工作。 例如新年红包业务，双十一电商业务，秒杀业务，明星结婚对新浪微博的影响等，这些可以预知或未知的突发流量，如果系统可以自动扩容，那将很是完美。其实很多当前 Docker + kubernetes 的使用案例，还只是方便运维工作量，对弹性扩容这块实践感觉不是很好。</p><p><strong>存储相关：</strong></p><p><strong>1. 关系型数据库：</strong> 传统的 MySQL 数据需要掌握。 如果做互联网业务，对分库分表肯定有需求，关注 NewSQL，如 TiDB，可以避免分库分表的麻烦。</p><p><strong>2. NoSQL 存储：</strong> Elasticsearch、MongoDB至少掌握一个。 笔者对 Elasticsearch 还是比较看好，综合性 文档数据、列式存储、反向索引 都支持，社区生态也很不错。</p><p><strong>3. 大数据数据库：</strong> 强烈建议熟悉 HDFS + HBase + openTSDB。 如果熟悉时序数据库 openTSDB 设计以后，对了解各个监控系统如 OpenFalcon 有很大的帮助。基本自研监控系统也难度不是特别大了。</p><p><strong>4. 内存数据库：</strong> 有些特殊应用使用内存数据会事半功倍。 Redis 提供丰富的数据结构及良好特性，并且有很多插件，巧妙使用可以降低业务代码复杂度。</p><p><strong>5. 消息队列：</strong> 消息队列也有存储机制，使用得当，也可以当成存储介质使用。 例如：kappa 架构、RocketMQ 事务消息支持等。</p><p>注：存储相关其实只是中间件的学习，自研或改造几率机会还是比较少。</p><p><strong>最佳实践：</strong></p><p>笔者强烈建议架构师研究商业化广告系统的架构，有心得也可以与我交流。广告系统涵盖知识点很多，如：高并发、高性能的广告引擎；倒排索引的广告定向召回；流计算计费系统；批处理反作弊大数据处理系统；大数据DMP用户设备画像系统；点击率预测机器学习、深度学习方向；adx + ssp + dsp 之间跨公司、跨系统间通信调用；频次控制等需要的缓存系统设计；交易相关资金方面的处理等等。</p><h2 id="七-提升认知"><a href="#七-提升认知" class="headerlink" title="七. 提升认知"></a><strong>七. 提升认知</strong></h2><p>每个架构师都梦想架构世界，设计未来。可惜当你真正有能力或有义务为社会做点贡献时候，往往忘了初心或体力有限。所以年轻时候，精力充沛时候，往往经验能力有限，年轻时候过度设计都会经历，为了可扩展性、可重用、预防需求变更做这样那样的设计。前文互联网思维-迭代思维中也讲到，世事万物都是在变化的。无论我们如何封装变化、兼容变化，都有个刻度。变化始终要面对，一劳永逸是不可能的， 好的设计模式本身就是封装变化、应对变化的最佳实践。</p><p>笔者在多元视角看问题章节也提到过，学会用时间线眼光看待问题。这里很是适用，刻意练习自己多元视角思维，可能会找到事物发展的趋势或固有轨迹。如果你能够把我企业内部、业内流行架构趋势，或推动架构演进的企业内部业务发展趋势， 做架构方面取舍时，可能会有更加全面的考虑，从而设计出扩展性更好的架构。</p><p>注：当然，做任何事情也是如此，顺势而为。</p><h2 id="八-THIS-IS-NOT-THE-END"><a href="#八-THIS-IS-NOT-THE-END" class="headerlink" title="八. THIS IS NOT THE END"></a><strong>八. THIS IS NOT THE END</strong></h2><p>《道生一，一生二，二生三，三生万物》出自老子的《道德经》第四十二章，是老子的宇宙生成论。这里老子说到“一”、“二”、“三”，乃是指“道”创生万物的过程。主要讲述了一、二、三这几个数字，并不把一、二、三看作具体的事物和具体数量。它们只是表示“道”生万物从少到多，从简单到复杂的一个过程。</p><p><strong>我们对任何事物的认知，尤其用文字表达出来，都是“一”、“二”、“三”这几个数字，而它们不代表具体事物和数量，就和这篇文章一样，只是思考的开始或过程，无法代表特定结论。</strong></p><p>作者介绍：张凯江，低调的骨灰级架构师。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正文开始前，先花大量笔墨推荐几个我工作中常用的思考框架、实践框架，后续文章中会使用这几种思考框架作为工具来描述、拆解、分析问题。当然你也可以使用到其它工作内容中，掌握几种利器，比无头苍蝇样做事效率会高很多。&lt;/p&gt;
&lt;h2 id=&quot;一-几个思考、实践框架&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="架构" scheme="http://ai.mak.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>张勇：经营的核心是突破，管理的核心是效率</title>
    <link href="http://ai.mak.cn/2019/12/28/%E6%9D%82%E8%AE%B0/%E5%BC%A0%E5%8B%87%EF%BC%9A%E7%BB%8F%E8%90%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E7%AA%81%E7%A0%B4%EF%BC%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E6%95%88%E7%8E%87/"/>
    <id>http://ai.mak.cn/2019/12/28/%E6%9D%82%E8%AE%B0/%E5%BC%A0%E5%8B%87%EF%BC%9A%E7%BB%8F%E8%90%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E7%AA%81%E7%A0%B4%EF%BC%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E6%95%88%E7%8E%87/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2023-01-09T06:38:50.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>张勇 | 作者</strong></p><p><strong>虎嗅APP(ID:huxiu_com) | 来源</strong></p><p>2019年12月17日，阿里巴巴集团董事局主席兼首席执行官张勇和湖畔大学第四期学员进行了最新年度分享。今年年初，他曾经提出，商业设计和组织设计是企业一号位不可推卸的两大责任。最新分享中，他对于聚焦客户价值选择赛道、纵横分合的组织设计、让不确定性不同意见变为确定性的一致意见、领导者如何“落子无悔”等进行了更全面深入的延展和阐释。</p><p><strong>以下是核心观点：</strong></p><blockquote><p>第一天就想做平台的人，基本上都没做成。</p><p>选赛道通常两种方式：一种是垂直整合，另一种是水平延展。</p><p>所谓“落子无悔”，有些决定别人不可能替你做，只有一号位责无旁贷。 </p><p>企图通过共创会解决企业战略发展问题的，是领导者无能的表现。</p><p>以解决信息不对称性而创造的业务，未来终将消失。</p><p>市场是动态的，要在动态中防止焦虑，保持战略定力。地球是圆的，往东坚持到最后，只要你还活着，就是往西。</p><p>最大的确定性就是不确定性，真正的业务一号位，一定是在高度的不确定性当中去寻找确定性。</p><p>要把能努力的都努力好之后，最终等待命运垂青。</p><p>领导者不是万能的，领导者注定孤独。面向未来，不仅要看未来的机会，同时也看未来的问题。</p><p>当一个机会变成广泛共识的时候，是最需要小心的时候。绝望当中都是机会，冲动当中都是陷阱。</p><p>绝大多数的协同问题都不是态度问题，而是生产关系没设计到位。</p><p>要在一个扭曲的生产关系下，希望大家一起合作，本身就违反人性。</p><p>中台是沉淀出来的，不是从底下长起来的，底下长不起来中台。</p><p>经营核心是突破，管理核心是效率。经营和管理永远是“科学+艺术”。留白是一种艺术，必须给客观世界留一些空间。</p><p>有时候要付出一些代价，针对不确定性的不同意见，就会变成确定性的一致意见。</p><p>做取舍的过程，就是建立信用和消费信用的过程。</p><p>老板是封的，是任命的，老大是发自团队内心的。</p><p>领导者就是要敢做别人不敢做的决定；承担不能让团队承担，团队也承担不起的责任；搞定团队搞定不了的资源。</p></blockquote><p><strong>以下是张勇演讲全文：</strong></p><h3 id="1、第一天想做平台的人，基本上都没做成"><a href="#1、第一天想做平台的人，基本上都没做成" class="headerlink" title="1、第一天想做平台的人，基本上都没做成"></a>1、第一天想做平台的人，基本上都没做成</h3><p>首先要考虑客户是谁，你能为他们带来什么价值。这是定义一个新业务时非常要考虑的问题。定义得越具体，业务落地就越顺畅，不然客户画像都不清楚，就很难讨论问题。做平台做久了，反而容易迷失自己，忘掉初心。第一天想做平台的人，基本上都没做成。</p><p>讨论商业设计，无非考虑三个方面，才能真正为企业选好赛道——</p><p>(1)必须聚焦客户价值，同时看客户价值的普适性有多广。这是最关键的问题。一旦入了行，一旦企业定了赛道，一旦开足马力往前走之后，很难换赛道。至少在一个周期里边，做汽车的就做汽车，做装修的就做装修，做教育的就做教育，做环保的就做环保，慢慢它有演化的可能性，但首先要明确主业，主业的客户有多广，取决于你在解决多少人的问题，背后就有多少市场潜力。</p><p>(2)讨论客户是谁的时候，既要明确客户是谁，又要明确能提供的服务和价值是什么，以及对客户覆盖的范围是不是够广。马老师那句名言讲过多次：痛点越大，机会越大。商业设计里找赛道，首先要对痛点进行深度挖掘和研究，换句话说，痛点够不够痛？如果只是表象的痛，解决门槛也会很低，给客户建立不了什么核心价值。紧接着思考这些痛点是不是有普遍性，有没有足够多的人有这样的痛苦？我能不能解决他的问题？这是商业设计的关键之关键。</p><p>(3)除了要看我和我的团队能不能找到不一样的方式去解决客户问题——或者用技术变革，或者用商业变革，或者两者结合——还要看市场上还有没有别人能解决客户同样的痛点，如果有同样的人在解决，或者人家已经解决了一部分，甚至解决得很好了，再去做这件事情意义不大。说白了，是不是有足够的市场优势。哪怕你的商业规划、业务策略的PPT发得满世界都是，别人虽然都听明白了，但不能做。这就是足够的市场优势。</p><p>选赛道通常两种方式：</p><p>一种是垂直整合，上下游产业链打通。做了一点，然后做上游和供应链做到生产资料，下游做到市场终端；</p><p>另一种是水平延展。一个省做完做下一个省，一个国家市场做完做下一个国家的市场。这些都是关键节点的重大选择，这些选择基本上决定了企业的命运。</p><p>比如阿里把员工派去东南亚，这典型是全球化水平延展的做法。你要考虑一些中国员工到东南亚去，他的个体命运就被改变了，他的生活方式、小孩读书，甚至个人发展都改变了。这样的决定团队是没法做的。</p><p>所谓“落子无悔”，一定是作为负责人的首要责任，“此时此刻、非我莫属”。别人不可能替你做，只有一号位责无旁贷。 过程之中，要在动态中保持战略定力。市场是动态的，这就是为什么不仅要看自己，也要看市场中老的新的各种角色，大家在做什么动作，发生什么变化，这些变化也一定会影响到我们自己的判断，影响我们对赛道的选择，影响我们的商业设计。</p><p>可能性格使然。在阿里内部我强调比较多的，就是防止焦虑，保持战略定力。选赛道也好，定义客户痛点也好，寻找客户规模也好，所有这些问题其实不是静态，而是一个动态变化、不断演进的过程。这个过程当中，整个世界也在动态演变，每天都在发生很多事情，这个市场上不只你一个人在玩，别人也在玩。如何避免受到市场因素的干扰或影响？怎么能够真正找到属于你的独特的东西？特别重要的是战略定力。</p><p>我跟我们团队三天两头敲警钟，当业务找不到战略方向、彷徨、要讨论未来突破点或竞争等各种问题的时候，千万不要希望以共创会的形式解决问题。共创会不是来解决战略问题的，共创会是咱们不认识，坐下来谈谈前世今生，我以前干过啥、我的经历、性格是什么，是让人能够产生连接。 </p><p>我原话说得更极端——企图通过共创会解决企业战略发展问题的，是团队一号位无能的表现。如果一号位都想不清楚往哪走，怎么打，怎么选择赛道，怎么定义用户价值，怎么设计商业模式，而想要团队坐下来共创，忆苦思甜，讨论一下前世今生，基本上聊的时候很爽，但是冷静下来什么也没发生。大家宣泄了情绪，没有解决实际问题。</p><p>实际问题的解决，是靠冷静的思考、判断和抉择，是基于领导者的决心和远见。当然这里边有没有孤注一掷的成分？一定有。我的经历和体会告诉我，做一个大的决定，有一些理性成分，但离不开最后决定企业命运的那个选择，也只有企业领军者才能做出这样的决定。这又是一个“落子无悔”，你做的决定就决定了企业的命运。</p><p>早年刚开始做淘宝的时候，eBay在中国是按上传商品数量收费，放一个商品，不知道卖不卖得掉，一天还要付几分钱，大家就不愿意发了。当时马老师做了决定，凡是eBay认为正确的，我们都反对，凡是eBay认为错误的，我们都支持。</p><p>这句话大家不要笑，我认为这句话是面对一个强大竞争市场的时候，非常好的思考方式。也许真理在少数人手里，但有的时候，你找到路就是真理，你找不到路就不是真理。你要在市场参与竞争，对手朝东，你就要往西，核心因为东边这条路已经被占掉了，只有往西才可能找到路，但并不代表西面一定有路。</p><p>在激烈的市场竞争下做商业设计，反过来要有一个相对论——相对于对手，你有什么差异化的策略。如果没有差异化，你再辛苦、再努力也没效果。你不能默认别人比你跑得慢，别人比你懒惰，你要想别人比你更聪明、更勤奋，执行力更强，想得更远，这个时候你该怎么做？只有做得不一样。</p><h3 id="2、商业设计的“两个可持续”"><a href="#2、商业设计的“两个可持续”" class="headerlink" title="2、商业设计的“两个可持续”"></a>2、商业设计的“两个可持续”</h3><p>从历史周期看，当一个企业做了一段后，我们要考虑：随着时间推移，随着世界的发展，随着技术的进步，它定义的用户价值是不是会趋弱，这非常有可能发生。</p><p>过程中切忌用“想当年我多有效”来讨论问题，我经常用这句话刺激阿里的团队——这个世界上，如果第一天是以解决信息不对称性而创造的业务，未来终将消失。今天不是信息稀缺时代，是信息爆炸甚至过度的时代，只解决信息不对称的业务模式终将消逝。潜台词是什么？ 消逝之前还有一个时间窗口，能够找到机会重新定义你对客户的价值——是重新开张，走极端的休克疗法？还是顺着走，活着总比死了强？</p><p>整个业务演进中，你要不断挖掘客户价值。最怕一直认为，第一天做业务时的价值就是客户价值。业务第一天就这么做，今天还要这么做。我个人坚决反对这点，业务都是人创造出来的，它第一天被创造出来有生命力，因为解决了客户的一部分问题。它今天要继续保持生命力，就必须做新的东西。要看时间序列上，你的价值有没有可持续性。作为领导者，我们要不停地去关注、判断，而不是只看我创造的业务很好，规模很大，同比增长也很好，危机就在这其中。</p><p>第二个可持续性跟烧钱相关，就是成本效率的可持续性。用户价值的可持续性，是找到客户痛点，创造可持续的用户价值。而要实现解决方案，提供服务，要看你的成本效率是不是可持续，这是大家普遍关心的问题，也是市场常见的问题。</p><p>我很喜欢看战争史、二战史。我开玩笑说，攻打西西里的战略，难道是在某年某月某日某个地方的哪块门板上画出来的？它充满偶然性，这正是我们的乐趣，也是不确定性带来的各种可能变化。</p><p>如果你只靠亏钱拿到一个市场规模，再融钱继续，这不可持续。东南亚现在满地都是这样的业务模式，各个行业都这么搞，包括国内现在很多业务。我每次看那些数据，真的看不懂，当然也存在看不懂也要学习。但有很多业务，第一天你就可以知道它的未来结局，是能够预判出来的。</p><p>我的观点是，尽最大努力，最终等待命运垂青。不能说所有业务都是算出来的，但如果你不算，光等命运垂青，这也不行。“尽人事、听天命”，这是商业设计中必须要考虑的问题。 </p><h3 id="3、领导者不是万能的，领导者注定孤独"><a href="#3、领导者不是万能的，领导者注定孤独" class="headerlink" title="3、领导者不是万能的，领导者注定孤独"></a>3、领导者不是万能的，领导者注定孤独</h3><p>领导者也不是万能的，领导者注定孤独。你做一个企业，有些事情可以跟人商量，有些事情是你一个人要去做决定的。做企业最痛苦的时候，有的事没人可商量。为什么不能？要去商量的几个人，哥们、姐们全是利益相关方。只有你自己可以跳出来想。</p><p>说实话，马老师对我个人影响非常大，我从他身上看到和体会他怎么去看问题——一个真正的领导人，应该始终面向未来。</p><p>面向未来，不仅是看未来的机会，同时也看未来的问题。其实我们说的客户痛点和客户价值，不一定解决今天的问题。相反，对未来的问题判断越准确，越及早准备，成就可能越大。这世界不缺聪明人，很多人都能看到未来。你如何判断未来这个世界的演进，会出现什么问题，带来什么机会？</p><p>有的时候我们很容易看重现在的机会，包括特别在意错失现在的机会。我有个“头班车末班车”的理论——人们讲要赶上风口：当年无线互联网来了，现在物联网来了，自动驾驶的风真的来了，至少在进行或还在早期。但有些风口已经不是风口了，我们已经在风里边了。</p><p>一个企业在某个领域没有抓住一个大机会的时候，会集体性陷入焦虑，认为它是命根子，不抓住它就可能被别人干趴下了。但有时候跳出来看看，这世界永远是轮回，你错过了这趟，永远会有下一趟。能活着很重要。</p><p>不是矫情，其实每天要考虑的真的是“活着”的问题，不是说做大了就没有这个问题。各种新商业模式也好、创新也好、社会问题也好，萤火虫般的火点都可能分分钟带来“活着”的问题。</p><p>活着的基础上，才能等到下一个风口的到来，并且做好坐上头班车的准备。这就是“头班车末班车”的理论。</p><p>我们通常说，4G来了短视频会超过长视频，必须抓住机遇。但当时哪几个人坚信短视频一定比长视频更好的？没几个人。从最初的各持己见到变成广泛共识的时候，是最需要小心的时候。</p><p>绝望当中都是机会，冲动当中都是陷阱，历史上无数次重复这样的过程。</p><p>这个过程中，怎么把握市场的脉搏？怎么看风口，看未来的机会？我只分享一些个人体会和做法。我非常喜欢聊天，其实我话不多，基本听人家聊，听别人讲有很多的输入，所以跟我聊天挺吃亏的。我提醒自己，做事情必须有对市场的脉搏，这个脉搏来自于体感，这是任何的人工智能数据分析，各种美妙的PPT都解决不了的。团队给我们的输入，客户给我们的输入，永远代替不了我们自己对市场的敏锐度。</p><p>春江水暖鸭先知。所有商业设计的源泉，都来自对市场的敏锐度。敏捷对一个组织很重要，对领导者也至关重要，你有没有敏锐度、敏捷度，能不能洞察市场的反应变化，哪怕是一些微妙变化。</p><p>这是一个企业保持独特生命力的源泉。</p><p>今天阿里那么大，我又在掌勺，要保持一个独特的方法去倾听和了解市场。不是为了挑毛病，而是找感觉。有时团队也会给我很多输入，这时候我的做法就是要反着听。</p><p>最近我讲，PPT是数字时代的八股文。同样要表达一个内容，用PPT的方式，无论你是什么样的高手，花的时间比写下来讲出来要多N倍。我有个习惯，团队和我交流，开会前PPT发到钉钉给我，然后他们开始讲。我是倒过来看PPT，看最后一页写什么，一般是他需要的帮助，前面都是成绩。难得见老板，还不让人显摆，看看有多努力，多有成就。团队难得见我一次，他也肯定有所希望。</p><p>这是人性，不是说把这些全砍掉，要尊重人性。我们都是从小朋友做起的，从练习生出身的，老板就是高高在上。尽管有的老板发自内心说我不是你老板，我们是一样的，但员工并不这么想，员工觉得我好不容易跟你有次见面机会，我得让你记住我，这是最朴素的人性。他能让你记住他，这就是他很大的成就了，他最惦记你帮他解决了什么问题。基本上团队开始讲五分钟、十分钟，PPT我就都翻完了。 </p><p>不同的人做法不同，很难说好坏。我的做法是耐着性子听他讲，除非万不得已去打断。为什么会迅速看完？其实你是在看他没讲的东西，甚至没写的东西。大概有个概念后，最重要的不是他跟你讲了什么，而是他没跟你讲什么。</p><p>其实我讲这些，并不是说这是一个心存杂念、心理阴暗的同学。世界上很多时候就是这样，一群好人，只讲他愿意让你听的话，最后你感受很差。他只表述了一个他想让你知道的世界，而真实世界更立体广阔。他没讲的才是最重要的东西，甚至，没讲的跟他讲的东西合在一起，才是最重要的。语言最奇妙的是，一句话可以用不同方法表达，在不同语境来表达，会产生不一样的效果。</p><p>一些人说，逍遥子你一看就是思考力很严谨、很缜密。其实最难的，就是把一个严谨的人搞成不严谨。这是我一直在努力折磨自己的地方。你明明很有逻辑，但是你必须要放弃一些逻辑，或者说，有些时候你大胆预见到这件事情干了以后，也许就是个悲剧，但是你还是让它发生。</p><p>有多种原因，一要培养人。就跟小孩一样，火是烫手的，小孩还是要碰，你让他碰过一次，他不会碰第二次。第二，面对很多不同意见，有时候你要付出一些代价，让一些不确定性变成确定性。针对不确定性的不同意见，就会变成确定性的一致意见。这句话有点拗口，你们体会一下，当有不确定性的时候，企业内部上上下下、前后左右会有很多观点，你也有观点，不管你有多自信，你有多想，都说服不了别人。</p><p>唯一的方法，是让这件事情发生一下，发生完了，所有人都达成共识。大家会说，这是不是又变上帝了。我们要有敬畏心，我们真不是上帝，真不是每件事情都能算清楚。我想讲的是，要给商业设计的演化留白，要给它一些自然演化的空间，给它一些团队创造的空间。你要相信你的团队，相信这个市场，我们不是万能的，不可能把所有问题都想到，要给市场留下一点空间，让它自然演进。</p><p>世界的发展不是靠策划出来的。最终，经营和管理永远是“科学+艺术”。留白是一种艺术，它必须给客观世界留一些空间。</p><p>大概十年前，当时我刚刚转到业务没多久，很多人问我，做财务和做业务最大不同是什么？ 我说最大的不同是你要敢做不完美的决定。</p><p>做业务一定要敢于做不完美的决定，不完美的决定背后是什么？是取舍。这是我们在商业设计里最难的东西。团队是没有办法做取舍的。 从战略上“既要又要”永远是对的，一到战役组织策略和策略安排执行上，如果“既要又要还要”，一定是错的。 </p><p>一个高级指挥员最重要的事情，是真正能够给下面非常简单的方向和决定，又能把下面的不同方向和决定组合起来，让他们的不同方向、决定发生化学反应后，能达到你的战略目标。</p><h3 id="4、生产关系不对，再好的商业设计都是空中楼阁"><a href="#4、生产关系不对，再好的商业设计都是空中楼阁" class="headerlink" title="4、生产关系不对，再好的商业设计都是空中楼阁"></a>4、生产关系不对，再好的商业设计都是空中楼阁</h3><p>前面一部分我们讲商业设计，如何创造生产力，激发生产力，如何为未来的生产力发展留白，希望有些意想不到的收获。</p><p>任何生产力的创造，回到商业基本原理，都离不开生产关系。合适的生产关系会激发和创造生产力，反过来再好的战略途径、业务策略、竞争打法，最终如果生产关系不对，基本上都是空中楼阁，就是内耗，一号位天天号召大家协同。</p><p>在阿里，我们旗帜鲜明地号召大家要协同，但是我认为，绝大多数的协同问题不是态度问题，不是团队愿不愿意协同，而是生产关系到没到位。要在一个扭曲的生产关系下，希望大家一起合作，本身就违反人性。</p><p>讨论生产关系，企业中就是组织设计。在一个战略方向明确、赛道选择明确，要进行阵型排布的时候，要考虑这个企业处于什么阶段，要解决的主要问题和主要矛盾是什么。从大的层面来讲，组织设计解决的主要矛盾是突破的问题，还是整体效率的问题？两者不同。</p><p>兵无常势，水无常形。组织怎么排，组织设计怎么做，本质反映了企业在特定阶段要解决的特定问题，并且从现在更好地走向下一步，走向未来，如何做好一个铺路石，铺垫好。这里叫“下一步”，而不是广义的未来。为什么？因为组织可以调整，可以一步一步调，当你既定战略目标达到，发觉原来的设计成为走向下一步未来的瓶颈时，就到了该调组织的时候。</p><p>阿里这几年，特别2015年以后我当CEO后，每年双11之后，就是我们调组织的时候。我们马上一轮正在进行，确保全阿里数字经济体能“一张图、一颗心、一场仗”，实现更加完美的战略一体化。</p><h3 id="5、经营核心是突破，管理核心是效率"><a href="#5、经营核心是突破，管理核心是效率" class="headerlink" title="5、经营核心是突破，管理核心是效率"></a>5、经营核心是突破，管理核心是效率</h3><p>“经营“和“管理”是两件事。经营核心是突破。用盒马举例，它能够满足基本需求，又不断创新产品和服务，给用户带来意想不到的惊喜，这是经营问题。</p><p>管理是效率问题。组织运行是不是高效，是不是人浮于事，包括阿里很多团队应该有全国性的组织，地区性的组织、分公司、城市，层层下去能不能管住，这些统称为管理问题。</p><p>其实经营问题、管理问题都有特定阶段的特征。两个问题的效果，基本上符合木桶原理，一定是由最短板决定的。你有再好的想法，再好的商品创新，管理不好，企业也是一团糟，但在特定阶段，作为一号位，要对大的局有判断。组织设计中，如何考虑阶段性的焦点问题和当前首要矛盾，或者说在经营上要解决什么具体问题，管理上要解决什么具体问题，并且经营和管理之间如何微妙地动态平衡，是向左偏一点还是向右偏一点。</p><p>动态平衡最重要。任何企业不论大小一号位，任何的左倾和右倾，哪怕只有五度，在一线就是180度大转弯。我们讲任何问题，只要态度上有鲜明表达，哪怕随口说的，也很容易被断章取义。</p><p>组织设计核心就是几个关键字——纵或者横、分或者合。通常来讲，纵和分是对应的。什么时候纵向，团队需要单兵突进的时候，需要打开一条血路，拓展一个市场，就需要组织敏捷、快速推进，甚至不惜犯错、不惜损耗。有的时候单纯的管理者很容易把效率损耗看成天大的问题，这也是我不断提醒自己的，因为我背景是CFO。我一直在想，马老师以前讲CFO不能干CEO，他的道理是什么？他到今天还是坚持这个观点，只不过说张勇是个例外。他一定是有道理的，所以任何东西不能绝对。</p><p>管理是个保健因子，没有管理不行、没有效率不行，人浮于事不行，重复岗位设计不行，但它不是一个激励因子，企业要创造未来，靠管，把灯都关上是不行的；考勤再严格，也考不出一个面向未来的企业。工厂化管理容易把人管成机器，管成零件，互联网公司不是这样，数字化运营也不是这样，管理哲学上要发挥人的主观能动性，而不是把人变成机器。</p><p>过程中，怎么把握纵和横、分和合。纵的时候，业务要突破，要快速、锋利，横的怎么样都不能锋利，只会敦实厚重。马步扎得稳，但要锋利，一定是纵来得好。企业最终都会有很多职能性设计，是放在一个团队里，还是做成共享，也就是我们叫的中台？</p><p>每个团队都是麻雀虽小、五脏俱全，它自己一定跑得快。当中没有对错，要分清当前主要矛盾。没有任何人可以替我做决定。我会反反复复考虑这些问题。这些问题都是在日常通过不断观察各种现象、情况，最后你发觉不动不行，必须做个选择。</p><p>插一点题外话。对于一个大组织，很多问题不是先来先到。最重要的是，我的Calendar是我自己排。很多人习惯说，我跟你约，找你秘书，其实我想说没用的，我写下来，进入挂号名单，但不代表先挂号的先看病。他没来找我挂号，说不定我盯着他要开会。他找我开会，我可能拖他一个月。为什么？还有比这更重要的。我习惯永远掌握自己的Calendar，时间管理是我的最重要工作。如果我的时间不由自己决定，那就出了大问题。</p><p>我自己手机上会写好，谁找过我，我没答应他。很长一个List，有的我知道他等得很急，我就是不找他，因为我有更重要的事情要办。不是说他的事情不重要。重要不重要，紧急不紧急，永远是相对的。</p><p>回到“分”这个话题。阿里后来立一些新业务的时候，包括钉钉也好，盒马也好、零售通也好，天猫精灵也好，我跟大家可以直截了当地分享，新业务起来必须另立番号，没有番号不成军，不成军就是乌合之众。大家凑一凑，干赢了也不知道算谁的，干输了没人担责任，这肯定不行，你必须要独立成军去打一个山头，尽量减少协同。</p><p>反过来，两个团队做同样的事情，要让两个团队都具备资源，至少有要赢的心，你不能说你跟它对冲，那肯定不行，你还是让每个团队都要全力去赢，所以要纵向和分开。最怕是在新业务、新战场，由职能部门协作，这太麻烦，业务Leader说了不算，财务怎么说、法务、投资、技术、物流、外部协作都怎么说，而最终自己都不管。 </p><p>如果这样，要你这个一号位干嘛？所有人都是提问题的，不是解决问题的。你要不要输赢，要不要把命交给他，这样人家输了也服气。我自己做的决定最后没搞成，我为此买单，而不是说最后一肚子冤屈。这些事情都不是我决定的，结果要我买单，这就完了。</p><h3 id="6、做取舍的过程，也是建立和消费信用的过程"><a href="#6、做取舍的过程，也是建立和消费信用的过程" class="headerlink" title="6、做取舍的过程，也是建立和消费信用的过程"></a>6、做取舍的过程，也是建立和消费信用的过程</h3><p>大家听中台战略很多。中台是阿里非常独特的战略。在独立业务拓展期、突破期，一定用独立团、独立师、独立旅建制来做。反过来管理到一定阶段，出现太多独立师、独立旅，大家各自建小煤窑，每个人都觉得自己能够建成现代化的煤炭产业。这时候要统一搞、要关停并转、要合并同类项。横的问题是你问管理要效率，取消重复性建设。</p><p>我们说，如果第一天奔着平台来创业，基本上都是死。同样，如果一个企业内部奔着中台做中台，也是死。所有平台都是从实战当中打出来的，没有实战当中的经历和建设，你都不知道客户需求是什么，凭什么说我是上帝，能够为所有人服务，这是不可能的。</p><p>这时中台做得不好就会变成瓶颈。做得好的中台都是依托一个大业务，就是这个业务的一部分，做着做着，我们发觉它已经足够茁壮，而且能支持其它业务场景，我们把它中台化。中台是沉淀出来的，不是从底下长起来的。底下长不起来中台。</p><p>我强烈建议大家看一下自己的组织。一号位最难的一点，就是既是商业架构师，又是技术架构师。这对于人的综合要求太高了。我肯定不是技术架构师，我可能成为一个产品架构师，但一个企业最终是一个好的商业架构师，和一个心灵相通的技术架构师呼应合一，这跟职位无关、跟汇报关系无关。在座可能有技术出身的，如果你做的不是纯技术研发类业务，最终还是要把自己变成一个商业架构师，不然很难变成企业的一号位。</p><p>横过来就是当出现多业务发展，中间越来越雷同，你就开始进行抽象沉淀，并通过抽象沉淀以后的平台或中台，来支撑一部分新业务发展。支撑里面的局部模块，这是我自己体会的纵和横、分和合的过程。</p><p>最终回到管理哲学，天下分久必合、合久必分，做企业也一样，分分合合。这是马老师的原话，我最早听没有感触，现在有了心灵感应。最终就是搭积木一样，合久了就分分开，分久了就合起来。</p><p>排阵型离不开一个关键因素，人。</p><p>我自己是个深度足球迷，我最喜欢类型的球队或者教练，都是因地制宜变化阵型。有些教练到哪儿都踢352，或者现在流行4231，两个中场，前面单箭头，高的把制空权掌握，把球过渡下来，左边一个、右边一个，两边总要两匹飞马，左边锋、右边锋，可以往下移。前腰是组织，后面两个防守型后腰，一个可以前后动，一个可以左右动。而有些教练则是到了球队，先看有什么菜，就排什么阵型。比如352就需要两个边后卫很厉害，攻的时候需要像左右前锋一样，守的时候变成两个边后卫，有这样的材料才能做325这盘菜。</p><p>企业管理、组织设计一样。理想的画组织结构图，我认为不成立。我们永远面临的是在特定历史阶段，看有没有合适的人。没有合适的人是常态，完全合适非常难。永远要根据手里有几张牌，你有几个王、你有几个K，就怎么打，怎么布局。这当中一定根据你有的“将”来排布。</p><p>我一直说我比较喜欢用“主将”这样的词，而不看总裁们有几个D。我有时跟总裁聊天，往往问你的左膀右臂是谁，你的干将是谁，不一定是你的D，可能是你的DD。一个企业、一个领军者一定有一个核心团队，这是客观的，不然就变成了孤胆英雄。当中怎么选择主将，要考虑不同阶段的不同问题。</p><p>真正的业务一号位，一定是在高度的不确定性当中去寻找确定性。不确定性是最大的确定性。怎么从各种现象表现，来看到这个人是否有主将特质。最普通的一点，这个人要有观点。我们开会讨论经常发生，只要位置比较高的人说了后，这个事情就变成你定了调，基本上团队就朝那边走了。</p><p>这是人性。在一个快速发展的创新业务里面，最怕人没观点，并且不能坚持和捍卫自己的观点。这样的人几乎不可能成为主将，他只是个manager。manager是个管理者。经营和管理是两件事，他也许是好的一个house keeper，管家，这在企业里也需要。一个企业做得好，也需要一些管家型的人物，但业务要有突破，一定要有主将。在此基础上，怎么样找到这些人的特质，并且看他怎么看待这个组织和机会，这非常重要。</p><p>最终对所有企业一号位来讲，最重要的时间要花在选人，其实就是定战略、定组织、选主将，这几件事情决定了企业的命运。我花很多时间跟同事聊天，正式的、非正式的，开会是最无效的一种，但没办法，有些形式还是要走。我认为这个无效，可能团队觉得很重要，跟逍遥子开会，得到他的认可，或者你讲几句，这个团队就获得很多资源，经常很多变成了CEO工程，必须理解这个。</p><p>要通过合适的方式去倾听这个人的思考。要看这个人正不正，再聪明的人，如果心术不正，在任何企业都会引发灾难。人总有一点自己的小九九，不能完全说大公无私。这是个过程，你给他多大的信任，给他多大的责任，他就越来越大公无私，同时他自己要有独特观点。他必须能够在不确定性当中表达自己清晰的选择。观点是取舍。一个没有取舍的主将、一个没有取舍的组织很难做好，必须在“既要又要还要”下面，在战略思想下面，承受巨大的痛苦和压力、挑战，做关键取舍。做取舍的过程，也是一个建立信用、消费信用的过程。你做对了就建立了信用，老做错，错两次、三次以后，就没有人信你了。</p><p>另一个观点是，一定要搏，所有事情没有那么面面俱到。最终到零秒，总要有人按Button，说朝这边走。这么多年下来，我也在挑战原有的性格。一般到我这儿的决定，下面已经没法做决定了。</p><p>第二，一旦决定以后，就要坚持，地球是圆的，坚持到最后，往东了，只要你还活着，就是往西。最怕来回折腾，最消耗、最没有成果，而且最让团队崩溃。产业终局一定不是一段路可以走到的，我的工作就是在产业终局和现在之间，找到一条歪歪斜斜的路，今天偏五度，后天要往回十度，那边有个坑要跨过去，有时要背道而驰。</p><h3 id="7、业务1号位要有杀伐决断、影响力和气质"><a href="#7、业务1号位要有杀伐决断、影响力和气质" class="headerlink" title="7、业务1号位要有杀伐决断、影响力和气质"></a>7、业务1号位要有杀伐决断、影响力和气质</h3><p>组织阵型最后还是回到人。</p><p>作为业务一号位，他的观点、杀伐决断，他的影响力和气质很关键。有些东西是天生的，只不过需要被激发。现在很多时候，包括马老师，包括Lucy（彭蕾）跟我开玩笑，说你跟以前不一样，没想到你是这么一个人。人是靠被激发出来的，到那个位置上，你自然调动所有潜能去做一件事。</p><p>一号位需要的特质是决断和担当，这非常重要。因为我们面对高度的不确定性。一个好的领导者，一定不是一个manager。一个好的领导者的特质，我把它总结为三句话，都跟担当有关系——</p><p>第一，就是敢做别人不敢做的决定。</p><p>第二，承担不能让团队承担、团队也承担不起的责任。</p><p>第三，就是搞定团队搞定不了的资源。</p><p>第三点特别体现我的特色。前面两个大家都容易想，肯定要做决定，肯定要担责任，但如果只有这两个，你不帮团队解决一些实际问题也没用，你讲得很好，我们必须干这个，责任我来担。但怎么干，要有条件，要有技术资源，人的资源，钱的资源。所以你要搞定一些资源，这是必须的。最终永远缺的是资源，广义的“资源”，因为机会总比资源多。</p><p>反过来，如果跟团队有共同的战斗、共同的经历、共同的体验，才能看出在团队眼中，这个人只是你的老板还是你的老大。我认为，老大是正向的描述，如果一个大组织里面，一个团队里面没有老大的感觉，这个团队没有真正的凝聚力。老板是封的，是任命的，老大是发自团队内心的。</p><p>这个过程要靠共同战斗经历，荣辱与共、彼此担当，甚至为团队承担一些东西。我经常问自己，到底大家认我这个人，还是认我的官衔？人要有自知之明，我当然希望认我这个人。我也理解过程中，如果没有亲密接触、没有共同经历战斗，可能认的就是官衔。但一个组织要健康发展，就要能荣辱与共，共同战斗，成为战友。</p><p>我以前经常跟团队讲，没有一起打过仗的只能叫同事，不能叫战友，一起打过仗就是战友，你才会知道，要死的心是什么，一起共同在海底淹死之前求生，彼此拉，也拉不住谁，都要往下沉的感觉，这是生死与共的感觉，这是一个企业最宝贵的。一个企业真的成功，所谓敢于把后背交给对方、敢于互相信任，无条件支持，就来自这种胜过同事的感觉。</p><p>锦上添花容易，雪中送炭最难。真到抉择时刻，能不能同舟共济，真的到企业有危难的时候，才知道什么是真正的友谊、什么是真正的支持。平时鼓掌、笑脸、问候不差一个，但到那个时候，能不能帮人家一下，哪怕慰问一下，最后用实际行动做些事情，这是真正的友谊，同时才能建立更紧密的信任。</p><p>阿里叫“因为信任、所以简单”，信任是很高阶段的事情，首先人要互相认识、熟悉，有很多交往，经历一些事情，慢慢累积一些信任，你没有办法要求两个不认识的人因为信任、所以简单，听了以后没有感觉的。</p><p>首先要自己感动，才能感动别人，才能真的发自内心让团队、让主将、让员工有机会变成更好的自己。这是阿里文化的主题。还是要用心。这跟做业务一样，最终做一个企业领导者，是智商、情商，最后是爱商，这也是我们的坚信。我总结阿里巴巴的文化内核，就是相信人和社会的美好。尽管世界有很多丑恶的事情，但是你还是愿意相信美好，并且愿意去相信别人。</p><p>碰到问题的时候，你敢不敢首先相信别人，哪怕有时候会被骗，哪怕有时候不顺利，但是你愿不愿意做这个事情，这是企业的DNA，也是阿里的DNA。</p><p>这次阿里的新六脉神剑，我给提的观点是，不是传承，不是我传给你，是寻找共鸣，找到同路人。每个人心里都有这样一部分，你能把他激发出来，原来大家都信这个，都觉得这样世界会更美好，为什么我们不一起努力一下？这才是真正把文化和业务融在一起，只有这样才能走向一个更健康的组织。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;张勇 | 作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虎嗅APP(ID:huxiu_com) | 来源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2019年12月17日，阿里巴巴集团董事局主席兼首席执行官张勇和湖畔大学第四期学员进行了最新年度分享。今年年初，</summary>
      
    
    
    
    <category term="杂记" scheme="http://ai.mak.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java  如何做好团队的目标和技术规划</title>
    <link href="http://ai.mak.cn/2019/12/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%9B%A2%E9%98%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
    <id>http://ai.mak.cn/2019/12/16/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%9B%A2%E9%98%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/</id>
    <published>2019-12-15T16:00:00.000Z</published>
    <updated>2023-01-09T04:48:09.250Z</updated>
    
    <content type="html"><![CDATA[<p>管理规划有四个相互关联的要素：职能、目标、团队和路径。在上一篇文章中，我们已经探讨了第一个要素，也就是如何界定团队职能。我想现在你应该很清楚自己团队该承担什么样的基本职责，以及希望背负什么样的使命了。</p><p>接下来的一个问题就是，未来的一段时间里，三个月、六个月也好，一年也好，你希望带着你的团队抵达一个什么样的目的地呢？这就是我们通常所说的“目标”。</p><p>今天这篇文章我们就一起来看看目标到底该如何设定，包括如下三个方面：</p><blockquote><p>你会更加清楚目标都意味着什么，它可不是让团队有事儿干那么简单。</p><p>你会掌握目标设定的要点，即使你之前没做过目标管理，你也可以实际操作了。</p><p>一起探讨在团队频繁调整，公司战略都不稳定的情况下，如何管理团队目标。</p></blockquote><p><strong>1.为什么目标会那么重要？</strong></p><p>我希望你做目标设定的时候，是基于你自己的动力，而不是被惯性推着走。那么，目标对于团队管理到底都意味着什么呢？</p><p><strong>第一，最基本的，目标包含着你和上级的诉求</strong>，即你们希望收获的东西。</p><p><strong>第二，目标意味着资源的有效配置</strong></p><p>明确的目标可以让你把资源投注在有效的方向上，从“该做什么”去调配资源，而不是“能干什么”。</p><p><strong>第三，目标意味着执行力</strong></p><p>很多管理者都把执行力和目标分开来谈，其实在我的访谈和观察中，技术管理者在任务执行上大多是很强的，并不是短板；而表现出“执行力不够”的最大的原因，都在于目标的不清晰或多变。我让他们回想自己做的执行力最棒的项目是不是都具有精确的目标，结果无一例外都是肯定的答案。显然，清晰的目标是高效执行的必要条件。</p><p><strong>第四，目标意味着凝聚力</strong></p><p>很多管理者问我到底该如何提升团队的凝聚力，我都会告诉他们：明确的团队目标和愿景，就是提升团队凝聚力的重要手段之一。大家因为相同的目标而并肩作战，在一起取得成就的过程中建立起深厚的“革命友情”，这对凝聚力有莫大帮助。</p><p><strong>第五，目标也意味着激励</strong></p><p>在提升员工自驱力的要素中，员工在工作中产生沉浸其中、物我两忘的“心流”状态，就需要有清晰的目标为前提。而且，团队目标感带给员工对工作的意义感和使命感，也是提升自驱力的重要来源。</p><p><strong>2.什么样的目标才是合理的目标呢？</strong></p><p>这就涉及到目标设定的原则，即“SMART”原则。分别对应着 5 个英文单词，即 Specific、Measurable、Attainable、Relevant 和 Time-bound，用中文来说就是目标的明确性、可衡量性、可达性、相关性和时限性。</p><p><strong>关于<strong><strong>目标的</strong></strong>可达性原则：</strong></p><p>你也许听很多人说过，“踮起脚尖能够到的目标最合适”，只是强调了其中的可达性原则，即，不能定一个完全实现不了的很高的目标，也不能定一个不需要努力就能实现的很低的目标。作为团队负责人，你会不会认为，定一个肯定能实现的相对保守的目标，对于向上级交差非常有利？</p><p>如果你真的这么想，那你就忽略了关于目标的一个重要的原则：<strong>目标是设定给团队的，而不是设定给上级的，其目的是为了让团队集中资源做出有效的成绩。当你为了容易交差而给团队设定一个没有挑战的目标时，团队成员是得不到激励的，也无法让员工进入“心流”状态。</strong></p><p><strong>另外，一个非常常见的情况是，如果你总让员工做没有挑战的工作，他很可能会因为没有成长而跟你提离职。所以，一个有挑战且努力能达到的目标，才是恰当的。</strong></p><p><strong>关于目标的明确性和可衡量性原则</strong></p><p>我认为这两个原则是分不开的。“目标要明确”这句话，我相信你听得耳朵都磨出茧子了。那么究竟什么叫“明确”呢？我觉得你可以简单地理解为，把目标设定到可以衡量的程度，就叫做明确了。</p><p>比如，下面两组目标说法的对比。</p><p>第一组：</p><p>a)“我们的目标是提升某个服务的性能。”这不是一个明确的可以衡量的目标。</p><p>b)“我们的目标是把某个服务的单机性能从 300qps 提升到 500qps。”这就是一个可以明确衡量的目标。</p><p>第二组：</p><p>a）“我们的目标是发布 BI 系统 1.0。”这看似是一个可以衡量的目标，但是 BI 系统 1.0 如何衡量是否完成了呢？又比较模糊。</p><p>b）“我们的目标是发布 BI 系统 1.0，支持 KPI 数据统计、全量数据导出功能。”这样就清楚 BI 系统 1.0 如何衡量了，要支持这样两项核心功</p><p>能才行。</p><p><strong>关于目标的相关性原则</strong></p><p>对于技术团队来说很难跑偏，因为技术这个角色决定了其工作内容必定是和上、下游及上级目标相关联的。所以，在这儿我就不展开细讲了。</p><p><strong>关于目标的时限性原则</strong></p><p>所有的目标都是基于一定时限的，缺少时间限制的目标没有意义。比如前面我们提到的“提升单机性能”的目标或“发布 BI 系统 1.0”的目标，如果没有限定一个时间，就不清楚该什么时候去衡量，也就无所谓是否有挑战和是否完成。</p><p>所以，一定要有个明确的时间点，比如“到 9 月底，把单机性能从 300qps 提升到 500qps”“到 12 月底，发布 BI 系统 1.0，支持 KPI 数据统计、全量数据导出分析功能”，就是两个完整且合理的目标描述了。</p><p>所以，当你要评判一个目标是否合理时，需要从 SMART 这五个原则去逐个审视，如果都符合了，说明你这个目标是清晰可行的。</p><p><strong>3.目标的形式是怎样的？</strong></p><p>目标的描述形式，大体分为两类：一类是可以量化的指标，就是大家常说的 KPI（Key Performance Indicator，关键绩效指标）；</p><p>另外一类是不可量化的目标，用关键结果来衡量，就是我们常说的 KRA(Key Result Areas) 或 OKR(Objectives &amp; Key Results)，总之就是对关键结果的一种描述。</p><p>它们大体上的描述形式是：</p><p>KPI：到某时间点，什么指标达到什么数字；</p><p>KRA R：到某时间点，完成什么工作，该工作实现了哪些功能或达到了哪些效果。</p><p><strong>4.目标制定经常遇到的坑</strong></p><p>新经理在目标设定上，常常会踩一些坑，面临诸多挑战，如下四类问题和挑战是最为常见的。</p><p><strong>第一类问题是基于现有资源做目标，而不是基于远方的目标往前推</strong>。</p><p>这类问题常见的说法就是，“我们团队只能做到个程度”“这些项目能做完就不错了”等。其实，更为合理的做法应该是，从上级的角度来讲，你的团队需要保证哪几项重要的结果，然后再看看如何调配和补充资源。面对这类问题和挑战的钥匙叫做“以终为始的出发点”。</p><p><strong>第二类问题是目标不明确。</strong></p><p>你可能会说，“从上面你说的来看，一个明确的目标很容易制定啊！”但问题在于，新管理者很少会因为“目标笼统或太大”导致不明确；不过，倒是常常会因为“过程化描述”而引发目标不明确的情况出现。</p><p>常见的说法是，“我们要在 10 月底，完成架构改造”“我们要在 12 月底，上线反作弊系统 1.0”等等。这类描述的问题在于，主要强调“我做了什么”，而没有交代做完这些工作后，“取得了什么效果”。 因此，面对这类问题和挑战的钥匙叫做“结果导向的描述”。</p><p><strong>第三类问题是目标设定好之后，自己和自己的上级都很清楚了，但是没有刻意地向团队成员来传达，只是按照目标拆解去安排大家的工作。</strong></p><p>这样的做法，导致团队成员对于整个团队的方向感不清晰，那么前面我提到的那些目标能带来的效果就无法显现，比如起不到对团队的凝聚和激励的效果。面对这类问题和挑战的钥匙叫做“目标的向下同步”。</p><p><strong>第四类问题，也是大家最头疼的一个问题，就是目标总是被迫变来变去。互联网领域很少有非常稳定的公司，业务总是在调整，自己的上级也时不时就换个新的，甚至于公司的战略也每隔一段时间就变一次。</strong></p><p>显然，之前为团队设定的目标，也得跟着变来变去。于是，目标慢慢变得形同虚设。面对这类问题和挑战的钥匙叫做“设定专业目标”，用专业目标来增强团队的内在定力。</p><p>团队和人是一样的，如果总是被外在需求牵着走，内心必然会充满焦虑，所以还需要弄清楚自己的内在追求。而专业目标，就是为团队树立明确的内在追求。</p><p>说到这里，你可能又会问：什么是“专业目标”呢？</p><p>要解释“专业目标”，我们就得先来谈谈“业务目标”。“业务目标”简单来说就是需要完成的业务业绩目标，也就是我们常说的 KPI 和 KRA，是公司和上级对你团队的业绩要求，这类目标一般是自上而下拆解下来的，所以来自于外部，一般不容易被忽略。</p><p>和“业务目标”来自外部要求相对应，“专业目标”来自你团队的内在要求，一般是由你和团队自己设定的，属于自我要求，所以新的管理者往往会忽略不做，有的是想不到，有的是懒得做。而恰恰是这个内在目标的设定，最能体现你的管理价值，因为这是最能展示你的自主性的地方。</p><p>专业目标设定的核心步骤就两步：第一，选择你要提升的关键维度；第二，设定目标，可以是量化的 KPI，也可以是非量化的 KRA。</p><p>关于团队的关键维度，上篇文章中我提到，就好像每个人都有自己的价值观一样，每个团队也都有自己最核心的评价维度，这是由团队职能决定的，比如服务端团队的稳定性和性能，数据团队的准确性和安全性，功能迭代团队的高效和质量，等等，这些维度是最能体现团队核心能力及价值的。</p><p>因此，即使上级没有提出要求，团队负责人也要为团队基于这些专业维度来设定目标，比如作为服务端团队，可以把“半年内提升 40% 的并发性能”作为团队的专业目标，以此来不断修炼团队的内功，并作为团队的内在追求。</p><p>如此，当外部的业务目标不稳定时，相对稳定的专业目标可以让团队内部一直有个“指南针”，从而降低目标频繁调整引起的员工焦虑，而且还避免了目标变来变去导致的“瞎忙”或“白忙”。</p><p>你可能会说，内在的专业目标还没有达成的时候，上级的业务目标又压下来了怎么办？这类冲突的处理办法和“重要紧急”四象限的权衡思路是一致的，内在的专业目标属于重要的事情，而外部压过来的目标，属于紧急的事情。重要紧急的权衡和决策是管理者的日常工作内容，慢慢你会有自己的心得体会的，现在我们先探讨的是“团队定力”的问题。</p><p>最后，你是否可以制定出自己团队的目标了呢？除了业务目标，你制定专业目标了吗？如果你已经有自己的团队目标，他们符合 SMART 原则吗？如果你都做得非常到位，你把这个非常棒的目标周知到团队每个成员了吗?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管理规划有四个相互关联的要素：职能、目标、团队和路径。在上一篇文章中，我们已经探讨了第一个要素，也就是如何界定团队职能。我想现在你应该很清楚自己团队该承担什么样的基本职责，以及希望背负什么样的使命了。&lt;/p&gt;
&lt;p&gt;接下来的一个问题就是，未来的一段时间里，三个月、六个月也好</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="杂记" scheme="http://ai.mak.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java  高并发下的接口幂等性</title>
    <link href="http://ai.mak.cn/2019/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>http://ai.mak.cn/2019/12/13/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2023-01-09T04:42:48.362Z</updated>
    
    <content type="html"><![CDATA[<p>作者 | 抽离的心</p><h2 id="来源-blog-csdn-net-x2F-u011635492-x2F-article-x2F-details-x2F-81058153"><a href="#来源-blog-csdn-net-x2F-u011635492-x2F-article-x2F-details-x2F-81058153" class="headerlink" title="来源 | blog.csdn.net&#x2F;u011635492&#x2F;article&#x2F;details&#x2F;81058153"></a>来源 | blog.csdn.net&#x2F;u011635492&#x2F;article&#x2F;details&#x2F;81058153</h2><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。</p><p>例如：</p><ol><li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li><li>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；</li><li>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。</li></ol><p>等等很多重要的情况，这些逻辑都需要幂等的特性来支持。</p><h1 id="二、幂等性概念"><a href="#二、幂等性概念" class="headerlink" title="二、幂等性概念"></a>二、幂等性概念</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p><p>这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.</p><p>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</p><h1 id="三、技术方案"><a href="#三、技术方案" class="headerlink" title="三、技术方案"></a>三、技术方案</h1><p><strong>1. 查询操作</strong> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p><p><strong>2. 删除操作</strong> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p><p><strong>3.唯一索引，防止新增脏数据</strong> 比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p><p><strong>要点：</strong> 唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</p><p><strong>4. token机制，防止页面重复提交</strong></p><p>业务要求：</p><p>页面的数据只能被点击提交一次</p><p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p><p>解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） 单JVM环境：采用token加redis或token加jvm内存</p><p>处理流程：</p><ol><li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li><li>提交后后台校验token，同时删除token，生成新的token返回</li></ol><p>token特点：</p><p>要申请，一次有效性，可以限流</p><p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p><p><strong>5. 悲观锁</strong> 获取数据的时候加锁获取</p><p>select * from table_xxx where id&#x3D;’xxx’ for update;</p><p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p><p><strong>6. 乐观锁</strong> 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p><p>1、通过版本号实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_xxx set name=#name#,version=version+1 where version=#version#</span><br></pre></td></tr></table></figure><p>如下图(来自网上)：</p><p><img src="https://aimak.cn/blog_img/java/version_mideng.png" alt="图片"></p><p>2、通过条件限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p>要求：quality-#subQuality# &gt;&#x3D; ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</p><p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set name=#name#,version=version+1 where id=#id# and version=#version#</span><br><span class="line"></span><br><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p><strong>7. 分布式锁</strong> 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定</p><p>这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁</p><p>这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p><p><strong>8. select + insert</strong> 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p><p>注意：核心高并发流程不要用这种方法</p><p><strong>9. 状态机幂等</strong> 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机</p><p>如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p><p><strong>10. 对外提供接口的api如何保证幂等</strong></p><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</p><p>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p><p><strong>重点</strong>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引</p><p>这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p><p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者 | 抽离的心&lt;/p&gt;
&lt;h2 id=&quot;来源-blog-csdn-net-x2F-u011635492-x2F-article-x2F-details-x2F-81058153&quot;&gt;&lt;a href=&quot;#来源-blog-csdn-net-x2F-u011635492-x2F</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="高并发" scheme="http://ai.mak.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java  50+ Spring 常用注解</title>
    <link href="http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://ai.mak.cn/2019/12/11/java/Java%20%2050+%20Spring%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-12-10T16:00:00.000Z</published>
    <updated>2022-12-01T07:47:37.199Z</updated>
    
    <content type="html"><![CDATA[<p>使用注解的优势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.采用纯java代码，不在需要配置繁杂的xml文件</span><br><span class="line"></span><br><span class="line">2.在配置中也可享受面向对象带来的好处</span><br><span class="line"></span><br><span class="line">3.类型安全对重构可以提供良好的支持</span><br><span class="line"></span><br><span class="line">4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</span><br></pre></td></tr></table></figure><p><strong>Spring部分</strong></p><p><strong>1、声明bean的注解</strong></p><p>@Component 组件，没有明确的角色</p><p>@Service 在业务逻辑层使用（service层）</p><p>@Repository 在数据访问层使用（dao层）</p><p>@Controller 在展现层使用，控制器的声明（C）</p><p><strong>2、注入bean的注解</strong></p><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><p><strong>3、java配置类相关注解</strong></p><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><p><strong>4、切面（AOP）相关注解</strong></p><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><p><strong>5、@Bean的属性支持</strong></p><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</p><p>Protetype （每次调用新建一个bean）</p><p>Request （web项目中，给每个http request新建一个bean）</p><p>Session （web项目中，给每个http session新建一个bean）</p><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><p><strong>6、@Value注解</strong></p><p>@Value 为属性注入值（属性上）</p><p>支持如下方式的注入：</p><p>》注入普通字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;Michael Jackson&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入操作系统属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;systemPropreties[&#x27;os.name&#x27;]&#125;&quot;)</span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure><p>》注入表达式结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;@&#123; T(java.lang.Math).radom() * 100 &#125;&quot;)</span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><p>》注入其它bean属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><p>》注入文件资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)</span><br><span class="line">Resource file</span><br></pre></td></tr></table></figure><p>》注入网站资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;http://www.baidu.com&quot;)</span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><p>》注入配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;book.name&#125;&quot;)</span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure><p>注入配置使用方法：</p><p>① 编写配置文件（test.properties）</p><p>book.name&#x3D;《三体》</p><p>② @PropertySource 加载配置文件(类上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</span><br></pre></td></tr></table></figure><p>③ 还需配置一个</p><p>PropertySourcesPlaceholderConfigurer的bean。</p><p><strong>7、环境切换</strong></p><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p><strong>8、异步相关</strong></p><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><p><strong>9、定时任务相关</strong></p><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><p><strong>10、@Enable*注解说明</strong></p><p>这些注解主要用来开启对xxx的支持。</p><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p><p>@EnableAsync 开启异步方法的支持</p><p>@EnableScheduling 开启计划任务的支持</p><p>@EnableWebMvc 开启Web MVC的配置支持</p><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableCaching 开启注解式的缓存支持</p><p><strong>11、测试相关注解</strong></p><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(&quot;SpringJUnit4ClassRunner.classs&quot;)</span><br></pre></td></tr></table></figure><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(&quot;classes=&#123;TestConfig.class&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>SpringMVC部分</strong></p><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>@RequestMapping：@RequestMapping(“&#x2F;path”)表示该控制器处理所有“&#x2F;path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params:指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>value:指定请求的实际地址，指定的地址可以是URI</p><p>Template 模式</p><p>method:指定请求的method类型， GET、POST、PUT、DELETE等</p><p>consumes:指定处理请求的提交内容类型（Content-Type），如application&#x2F;json,text&#x2F;html;</p><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：用在方法的参数前面。</p><p>@RequestParam</p><p>String a &#x3D;request.getParameter(“a”)。</p><p>@PathVariable:路径变量。如 参数与大括号里的名字一样要相同。</p><p><strong>SpringBoot部分</strong></p><p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：</p><p>@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p><p>@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p><p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p><p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><p>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p><p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p><p>@Import：用来导入其他配置类。</p><p>@ImportResource：用来加载xml配置文件。</p><p>@Autowired：自动导入依赖的bean</p><p>@Service：一般用于修饰service层的组件</p><p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><p>@Bean：用@Bean标注方法等价于XML中配置的bean。</p><p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p><p>@Inject：等价于默认的@Autowired，只是没有required属性；</p><p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。</p><p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><p>@Resource(name&#x3D;”name”,type&#x3D;”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>二、注解列表如下</p><p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p><p>@ComponentScan：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p><p>@Configuration ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p><p>@EnableAutoConfiguration ：自动配置。</p><p>@ComponentScan ：组件扫描，可自动发现和装配一些Bean。</p><p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p><p>@RestController：注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p><p>@Autowired：自动导入。</p><p>@PathVariable：获取参数。</p><p>@JsonBackReference：解决嵌套外链问题。</p><p>@RepositoryRestResourcepublic：配合spring-boot-starter-data-rest使用。</p><p>三、JPA注解</p><p>@Entity：@Table(name&#x3D;”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p><p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p><p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p><p>@Column：如果字段名与列名相同，则可以省略。</p><p>@Id：表示该属性为主键。</p><p>@GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE,generator &#x3D; “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p><p>@SequenceGeneretor(name &#x3D; “repair_seq”, sequenceName &#x3D; “seq_repair”, allocationSize &#x3D; 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p><p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch&#x3D;FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>@JoinColumn（name&#x3D;”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p><p>五、全局异常处理</p><p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p><p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p><p>六、项目中具体配置解析和使用环境</p><p>@MappedSuperclass： 1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</p><p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p><p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p><p>@Column：</p><p>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p><p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。具体如下：</p><p> 1 name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</p><p> 2 unique属性：unique属性表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table注解中的@UniqueConstraint</p><p> 3 nullable属性：nullable属性表示该字段是否可以为null值，默认为true</p><p> 4 insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</p><p> 5 updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</p><p> 6 insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</p><p> 7 columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</p><p> 8 table属性：table属性定义了包含当前字段的表名</p><p> 9 length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</p><p> 10 precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</p><p>  具体如下：   1.double类型将在数据库中映射为double类型，precision和scale属性无效</p><p>  2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准</p><p>  3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效</p><p>  4.precision和scale属性只在BigDecimal类型中有效</p><p>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p><p>4.@Column标注也可置于属性的getter方法之前</p><p>@Getter和@Setter（Lombok）</p><p>@Setter：注解在属性上；为属性提供 setting 方法</p><p>@Getter：注解在属性上；为属性提供 getting 方法</p><p>@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法  @Setter：注解在属性上；为属性提供 setting 方法  @Getter：注解在属性上；为属性提供 getting 方法  @Log4j2 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似  @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法  @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法</p><p>@EqualsAndHashCode:默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p><p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p><p>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，只能自己手写了  @NonNull：注解在属性上，如果注解了，就必须不能为Null  @val:注解在属性上，如果注解了，就是设置为final类型，可查看源码的注释知道</p><p>当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</p><p>@javax.persistence.PostLoad：加载后。</p><p>@javax.persistence.PrePersist：持久化前。</p><p>@javax.persistence.PostPersist：持久化后。</p><p>@javax.persistence.PreUpdate：更新前。</p><p>@javax.persistence.PostUpdate：更新后。</p><p>@javax.persistence.PreRemove：删除前。</p><p>@javax.persistence.PostRemove：删除后。</p><p>1）数据库查询</p><p>@PostLoad事件在下列情况下触发：</p><p>执行EntityManager.find()或getreference()方法载入一个实体后。</p><p>执行JPQL查询后。</p><p>EntityManager.refresh()方法被调用后。</p><p>2）数据库插入</p><p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p><p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p><p>@PostPersist事件在数据已经插入进数据库后发生。</p><p>3）数据库更新</p><p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p><p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p><p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p><p>4）数据库删除</p><p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p><p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p><p>@PostRemove事件在实体从数据库中删除后触发。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40753536/article/details/81285046">https://blog.csdn.net/weixin_40753536/article/details/81285046</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用注解的优势：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    <category term="技术小栈" scheme="http://ai.mak.cn/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/"/>
    
    
    <category term="Spring" scheme="http://ai.mak.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
