<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="fantasykai`blog"><title>对一致性Hash算法，java实现的研究 | 枫哲's文栖小筑</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2bb92548008bd1f1f88213efd40c8dad';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">对一致性Hash算法，java实现的研究</h1><a id="logo" href="/.">枫哲's文栖小筑</a><p class="description">君子终日乾乾，夕惕若厉，无咎</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/blogroll/"><i class="fa fa-external-link"> 收藏链接</i></a><a href="/2048/"><i class="fa fa-gamepad"> 放松下</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">对一致性Hash算法，java实现的研究</h1><div class="post-meta">2016-12-17<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a></span></div><a class="disqus-comment-count" href="/posts/59897/#vcomment"><span class="waline-comment-count" id="/posts/59897/"></span><span> 条评论</span></a><div class="post-content"><blockquote>
<p>转载：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xrq730/p/5186728.html">http://www.cnblogs.com/xrq730/p/5186728.html</a></p>
</blockquote>
<p><strong>一致性Hash算法</strong></p>
<p>关于一致性Hash算法，在我之前的博文中已经有多次提到了，<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xrq730/p/4948707.html">MemCache超详细解读</a>一文中”一致性Hash算法”部分，对于为什么要使用一致性Hash算法、一致性Hash算法的算法原理做了详细的解读。</p>
<p>算法的具体原理这里再次贴上：</p>
<p><strong>先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</strong></p>
<p>这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。</p>
<p>当然，万事不可能十全十美，一致性Hash算法比普通的余数Hash算法更具有伸缩性，但是同时其算法实现也更为复杂，本文就来研究一下，如何利用Java代码实现一致性Hash算法。在开始之前，先对一致性Hash算法中的几个核心问题进行一些探究。</p>
<p><strong>数据结构的选取</strong></p>
<p>一致性Hash算法最先要考虑的一个问题是：构造出一个长度为232的整数环，根据节点名称的Hash值将服务器节点放置在这个Hash环上。</p>
<p>那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：</p>
<p><strong>O(1) &lt; O(log2N) &lt; O(N) &lt; O(N * log2N) &lt; O(N2) &lt; O(N3)  &lt; O(N!)</strong></p>
<p>一般来说，前四个效率比较高，中间两个差强人意，最后一个后比较差（只要N比较大，这个算法就动不了了）。OK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。</p>
<p><strong>1、解决方案一：排序+List</strong></p>
<p>我想到的第一种思路是：算出所有待加入数据结构的节点名称的Hash值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，最后将排序后的数据放入List中，采用List而不是数组是为了结点的扩展考虑。</p>
<p><strong>之后，待路由的结点，只需要在List中找到第一个Hash值比它大的服务器节点就可以了</strong>，比如服务器节点的Hash值是[0,2,4,6,8,10]，带路由的结点是7，只需要找到第一个比7大的整数，也就是8，就是我们最终需要路由过去的服务器节点。</p>
<p>如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：</p>
<p>（1）最好的情况是第一次就找到，时间复杂度为O(1)</p>
<p>（2）最坏的情况是最后一次才找到，时间复杂度为O(N)</p>
<p>平均下来时间复杂度为O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为O(N)。</p>
<p>但是如果考虑到之前的排序，我在网上找了张图，提供了各种排序算法的时间复杂度：</p>
<p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212222344573-933837136.jpg" alt="img"></p>
<p>看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，看起来最好的归并排序法的时间复杂度仍然有O(N * logN)，稍微耗费性能了一些。</p>
<p><strong>2、解决方案二：遍历+List</strong></p>
<p>既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。</p>
<p>解决方案使用List不变，不过可以采用遍历的方式：</p>
<p>（1）服务器节点不排序，其Hash值全部直接放入一个List中</p>
<p>（2）带路由的节点，算出其Hash值，由于指明了”顺时针”，因此遍历List，比待路由的节点Hash值大的算出差值并记录，比待路由节点Hash值小的忽略</p>
<p>（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点</p>
<p>在这个算法中，看一下时间复杂度：</p>
<p>1、最好情况是只有一个服务器节点的Hash值大于带路由结点的Hash值，其时间复杂度是O(N)+O(1)&#x3D;O(N+1)，忽略常数项，即O(N)</p>
<p>2、最坏情况是所有服务器节点的Hash值都大于带路由结点的Hash值，其时间复杂度是O(N)+O(N)&#x3D;O(2N)，忽略首项系数，即O(N)</p>
<p>所以，总的时间复杂度就是O(N)。其实算法还能更改进一些：给一个位置变量X，如果新的差值比原差值小，X替换为新的位置，否则X不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为O(N)。</p>
<p>总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。</p>
<p><strong>3、解决方案三：二叉查找树</strong></p>
<p>抛开List这种数据结构，另一种数据结构则是使用<strong>二叉查找树</strong>。对于树不是很清楚的朋友可以简单看一下这篇文章<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xrq730/p/5187032.html">树形结构</a>。</p>
<p>当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有AVL树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：</p>
<p>1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高</p>
<p>2、JDK里面提供了红黑树的代码实现TreeMap和TreeSet</p>
<p>另外，以TreeMap为例，TreeMap本身提供了一个tailMap(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构。</p>
<p>使用红黑树，可以使得查找的时间复杂度降低为O(logN)，比上面两种解决方案，效率大大提升。</p>
<p>为了验证这个说法，我做了一次测试，从大量数据中查找第一个大于其中间值的那个数据，比如10000数据就找第一个大于5000的数据（模拟平均的情况）。看一下O(N)时间复杂度和O(logN)时间复杂度运行效率的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>50000</strong></th>
<th><strong>100000</strong></th>
<th><strong>500000</strong></th>
<th><strong>1000000</strong></th>
<th><strong>4000000</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayList</strong></td>
<td><strong>1ms</strong></td>
<td><strong>1ms</strong></td>
<td><strong>4ms</strong></td>
<td><strong>4ms</strong></td>
<td><strong>5ms</strong></td>
</tr>
<tr>
<td><strong>LinkedList</strong></td>
<td><strong>4ms</strong></td>
<td><strong>7ms</strong></td>
<td><strong>11ms</strong></td>
<td><strong>13ms</strong></td>
<td><strong>17ms</strong></td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td><strong>0ms</strong></td>
<td><strong>0ms</strong></td>
<td><strong>0ms</strong></td>
<td><strong>0ms</strong></td>
<td><strong>0ms</strong></td>
</tr>
</tbody></table>
<p>因为再大就内存溢出了，所以只测试到4000000数据。可以看到，数据查找的效率，TreeMap是完胜的，其实再增大数据测试也是一样的，红黑树的数据结构决定了任何一个大于N的最小数据，它都只需要几次至几十次查找就可以查到。</p>
<p>当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，<strong>为了维护红黑树，数据插入效率TreeMap在三种数据结构里面是最差的，且插入要慢上5~10倍</strong>。</p>
<p><strong>Hash值重新计算</strong></p>
<p>服务器节点我们肯定用字符串来表示，比如”192.168.1.1”、”192.168.1.2”，根据字符串得到其Hash值，那么另外一个重要的问题就是Hash值要重新计算，这个问题是我在测试String的hashCode()方法的时候发现的，不妨来看一下为什么要重新计算Hash值：</p>
<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * String的hashCode()方法运算结果查看</span><br><span class="line"> * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StringHashCodeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;192.168.0.0:111的哈希值：&quot; + &quot;192.168.0.0:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.1:111的哈希值：&quot; + &quot;192.168.0.1:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.2:111的哈希值：&quot; + &quot;192.168.0.2:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.3:111的哈希值：&quot; + &quot;192.168.0.3:1111&quot;.hashCode());</span><br><span class="line">        System.out.println(&quot;192.168.0.4:111的哈希值：&quot; + &quot;192.168.0.4:1111&quot;.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>我们在做集群的时候，集群点的IP以这种连续的形式存在是很正常的。看一下运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.0:111的哈希值：1845870087</span><br><span class="line">192.168.0.1:111的哈希值：1874499238</span><br><span class="line">192.168.0.2:111的哈希值：1903128389</span><br><span class="line">192.168.0.3:111的哈希值：1931757540</span><br><span class="line">192.168.0.4:111的哈希值：1960386691</span><br></pre></td></tr></table></figure>

<p>这个就问题大了，[0,232-1]的区间之中，5个HashCode值却只分布在这么小小的一个区间，什么概念？[0,232-1]中有4294967296个数字，而我们的区间只有114516604，从概率学上讲这将导致97%待路由的服务器都被路由到”192.168.0.0”这个集群点上，简直是糟糕透了！</p>
<p>另外还有一个不好的地方：规定的区间是非负数，String的hashCode()方法却会产生负数（不信用”192.168.1.0:1111”试试看就知道了）。不过这个问题好解决，取绝对值就是一种解决的办法。</p>
<p>综上，String重写的hashCode()方法在一致性Hash算法中没有任何实用价值，得找个算法重新计算HashCode。这种重新计算Hash值的算法有很多，比如CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等，其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法，用别的Hash算法也可以，比如FNV1_32_HASH算法的计算效率就会高一些。</p>
<p><strong>一致性Hash算法实现版本1：不带虚拟节点</strong></p>
<p>使用一致性Hash算法，尽管增强了系统的伸缩性，但是也有可能导致负载分布不均匀，解决办法就是使用<strong>虚拟节点代替真实节点</strong>，第一个代码版本，先来个简单的，不带虚拟节点。</p>
<p>下面来看一下不带虚拟节点的一致性Hash算法的Java代码实现：</p>
<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 不带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  *</span><br><span class="line"> 5  */</span><br><span class="line"> 6 public class ConsistentHashingWithoutVirtualNode</span><br><span class="line"> 7 &#123;</span><br><span class="line"> 8     /**</span><br><span class="line"> 9      * 待添加入Hash环的服务器列表</span><br><span class="line">10      */</span><br><span class="line">11     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">12             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">13     </span><br><span class="line">14     /**</span><br><span class="line">15      * key表示服务器的hash值，value表示服务器的名称</span><br><span class="line">16      */</span><br><span class="line">17     private static SortedMap&lt;Integer, String&gt; sortedMap = </span><br><span class="line">18             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">19     </span><br><span class="line">20     /**</span><br><span class="line">21      * 程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">22      */</span><br><span class="line">23     static</span><br><span class="line">24     &#123;</span><br><span class="line">25         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">26         &#123;</span><br><span class="line">27             int hash = getHash(servers[i]);</span><br><span class="line">28             System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">29             sortedMap.put(hash, servers[i]);</span><br><span class="line">30         &#125;</span><br><span class="line">31         System.out.println();</span><br><span class="line">32     &#125;</span><br><span class="line">33     </span><br><span class="line">34     /**</span><br><span class="line">35      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">36      */</span><br><span class="line">37     private static int getHash(String str)</span><br><span class="line">38     &#123;</span><br><span class="line">39         final int p = 16777619;</span><br><span class="line">40         int hash = (int)2166136261L;</span><br><span class="line">41         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">42             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">43         hash += hash &lt;&lt; 13;</span><br><span class="line">44         hash ^= hash &gt;&gt; 7;</span><br><span class="line">45         hash += hash &lt;&lt; 3;</span><br><span class="line">46         hash ^= hash &gt;&gt; 17;</span><br><span class="line">47         hash += hash &lt;&lt; 5;</span><br><span class="line">48         </span><br><span class="line">49         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">50         if (hash &lt; 0)</span><br><span class="line">51             hash = Math.abs(hash);</span><br><span class="line">52         return hash;</span><br><span class="line">53     &#125;</span><br><span class="line">54     </span><br><span class="line">55     /**</span><br><span class="line">56      * 得到应当路由到的结点</span><br><span class="line">57      */</span><br><span class="line">58     private static String getServer(String node)</span><br><span class="line">59     &#123;</span><br><span class="line">60         // 得到带路由的结点的Hash值</span><br><span class="line">61         int hash = getHash(node);</span><br><span class="line">62         // 得到大于该Hash值的所有Map</span><br><span class="line">63         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">64                 sortedMap.tailMap(hash);</span><br><span class="line">65         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">66         Integer i = subMap.firstKey();</span><br><span class="line">67         // 返回对应的服务器名称</span><br><span class="line">68         return subMap.get(i);</span><br><span class="line">69     &#125;</span><br><span class="line">70     </span><br><span class="line">71     public static void main(String[] args)</span><br><span class="line">72     &#123;</span><br><span class="line">73         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">74         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">75             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">76                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">77     &#125;</span><br><span class="line">78 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>可以运行一下看一下结果：</p>
<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.0:111]加入集合中, 其Hash值为575774686</span><br><span class="line">[192.168.0.1:111]加入集合中, 其Hash值为8518713</span><br><span class="line">[192.168.0.2:111]加入集合中, 其Hash值为1361847097</span><br><span class="line">[192.168.0.3:111]加入集合中, 其Hash值为1171828661</span><br><span class="line">[192.168.0.4:111]加入集合中, 其Hash值为1764547046</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.4:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.4:111]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>看到经过FNV1_32_HASH算法重新计算过后的Hash值，就比原来String的hashCode()方法好多了。从运行结果来看，也没有问题，三个点路由到的都是顺时针离他们Hash值最近的那台服务器上。</p>
<p><strong>使用虚拟节点来改善一致性Hash算法</strong></p>
<p>上面的一致性Hash算法实现，可以在很大程度上解决很多分布式环境下不好的路由算法导致系统伸缩性差的问题，但是会带来另外一个问题：负载不均。</p>
<p>比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。<strong>某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求</strong>。</p>
<p>解决这个问题的办法是引入虚拟节点，其工作原理是：<strong>将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上</strong>。采取这样的方式，就可以有效地解决增加或减少节点时候的负载不均衡的问题。</p>
<p>至于一个物理节点应该拆分为多少虚拟节点，下面可以先看一张图：</p>
<p><img src="https://images2015.cnblogs.com/blog/801753/201602/801753-20160212234143027-642938706.png" alt="img"></p>
<p>横轴表示需要为每台福利服务器扩展的虚拟节点倍数，纵轴表示的是实际物理服务器数。可以看出，物理服务器很少，需要更大的虚拟节点；反之物理服务器比较多，虚拟节点就可以少一些。比如有10台物理服务器，那么差不多需要为每台服务器增加100~200个虚拟节点才可以达到真正的负载均衡。</p>
<p><strong>一致性Hash算法实现版本2：带虚拟节点</strong></p>
<p>在理解了使用虚拟节点来改善一致性Hash算法的理论基础之后，就可以尝试开发代码了。编程方面需要考虑的问题是：</p>
<p>1、一个真实结点如何对应成为多个虚拟节点？</p>
<p>2、虚拟节点找到后如何还原为真实结点？</p>
<p>这两个问题其实有很多解决办法，我这里使用了一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如”192.168.0.0:111”就把它变成”192.168.0.0:111&amp;&amp;VN0”到”192.168.0.0:111&amp;&amp;VN4”，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到”&amp;&amp;”的位置就可以了。</p>
<p>下面来看一下带虚拟节点的一致性Hash算法的Java代码实现：</p>
<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * 带虚拟节点的一致性Hash算法</span><br><span class="line"> 3  * @author 五月的仓颉 http://www.cnblogs.com/xrq730/</span><br><span class="line"> 4  */</span><br><span class="line"> 5 public class ConsistentHashingWithVirtualNode</span><br><span class="line"> 6 &#123;</span><br><span class="line"> 7     /**</span><br><span class="line"> 8      * 待添加入Hash环的服务器列表</span><br><span class="line"> 9      */</span><br><span class="line">10     private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">11             &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line">12     </span><br><span class="line">13     /**</span><br><span class="line">14      * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span><br><span class="line">15      */</span><br><span class="line">16     private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;();</span><br><span class="line">17     </span><br><span class="line">18     /**</span><br><span class="line">19      * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</span><br><span class="line">20      */</span><br><span class="line">21     private static SortedMap&lt;Integer, String&gt; virtualNodes = </span><br><span class="line">22             new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">23     </span><br><span class="line">24     /**</span><br><span class="line">25      * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span><br><span class="line">26      */</span><br><span class="line">27     private static final int VIRTUAL_NODES = 5;</span><br><span class="line">28     </span><br><span class="line">29     static</span><br><span class="line">30     &#123;</span><br><span class="line">31         // 先把原始的服务器添加到真实结点列表中</span><br><span class="line">32         for (int i = 0; i &lt; servers.length; i++)</span><br><span class="line">33             realNodes.add(servers[i]);</span><br><span class="line">34         </span><br><span class="line">35         // 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span><br><span class="line">36         for (String str : realNodes)</span><br><span class="line">37         &#123;</span><br><span class="line">38             for (int i = 0; i &lt; VIRTUAL_NODES; i++)</span><br><span class="line">39             &#123;</span><br><span class="line">40                 String virtualNodeName = str + &quot;&amp;&amp;VN&quot; + String.valueOf(i);</span><br><span class="line">41                 int hash = getHash(virtualNodeName);</span><br><span class="line">42                 System.out.println(&quot;虚拟节点[&quot; + virtualNodeName + &quot;]被添加, hash值为&quot; + hash);</span><br><span class="line">43                 virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">44             &#125;</span><br><span class="line">45         &#125;</span><br><span class="line">46         System.out.println();</span><br><span class="line">47     &#125;</span><br><span class="line">48     </span><br><span class="line">49     /**</span><br><span class="line">50      * 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 </span><br><span class="line">51      */</span><br><span class="line">52     private static int getHash(String str)</span><br><span class="line">53     &#123;</span><br><span class="line">54         final int p = 16777619;</span><br><span class="line">55         int hash = (int)2166136261L;</span><br><span class="line">56         for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">57             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">58         hash += hash &lt;&lt; 13;</span><br><span class="line">59         hash ^= hash &gt;&gt; 7;</span><br><span class="line">60         hash += hash &lt;&lt; 3;</span><br><span class="line">61         hash ^= hash &gt;&gt; 17;</span><br><span class="line">62         hash += hash &lt;&lt; 5;</span><br><span class="line">63         </span><br><span class="line">64         // 如果算出来的值为负数则取其绝对值</span><br><span class="line">65         if (hash &lt; 0)</span><br><span class="line">66             hash = Math.abs(hash);</span><br><span class="line">67         return hash;</span><br><span class="line">68     &#125;</span><br><span class="line">69     </span><br><span class="line">70     /**</span><br><span class="line">71      * 得到应当路由到的结点</span><br><span class="line">72      */</span><br><span class="line">73     private static String getServer(String node)</span><br><span class="line">74     &#123;</span><br><span class="line">75         // 得到带路由的结点的Hash值</span><br><span class="line">76         int hash = getHash(node);</span><br><span class="line">77         // 得到大于该Hash值的所有Map</span><br><span class="line">78         SortedMap&lt;Integer, String&gt; subMap = </span><br><span class="line">79                 virtualNodes.tailMap(hash);</span><br><span class="line">80         // 第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">81         Integer i = subMap.firstKey();</span><br><span class="line">82         // 返回对应的虚拟节点名称，这里字符串稍微截取一下</span><br><span class="line">83         String virtualNode = subMap.get(i);</span><br><span class="line">84         return virtualNode.substring(0, virtualNode.indexOf(&quot;&amp;&amp;&quot;));</span><br><span class="line">85     &#125;</span><br><span class="line">86     </span><br><span class="line">87     public static void main(String[] args)</span><br><span class="line">88     &#123;</span><br><span class="line">89         String[] nodes = &#123;&quot;127.0.0.1:1111&quot;, &quot;221.226.0.1:2222&quot;, &quot;10.211.0.1:3333&quot;&#125;;</span><br><span class="line">90         for (int i = 0; i &lt; nodes.length; i++)</span><br><span class="line">91             System.out.println(&quot;[&quot; + nodes[i] + &quot;]的hash值为&quot; + </span><br><span class="line">92                     getHash(nodes[i]) + &quot;, 被路由到结点[&quot; + getServer(nodes[i]) + &quot;]&quot;);</span><br><span class="line">93     &#125;</span><br><span class="line">94 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>关注一下运行结果：</p>
<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN0]被添加, hash值为1686427075</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN1]被添加, hash值为354859081</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN2]被添加, hash值为1306497370</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN3]被添加, hash值为817889914</span><br><span class="line">虚拟节点[192.168.0.0:111&amp;&amp;VN4]被添加, hash值为396663629</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN0]被添加, hash值为1032739288</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN1]被添加, hash值为707592309</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN2]被添加, hash值为302114528</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN3]被添加, hash值为36526861</span><br><span class="line">虚拟节点[192.168.0.1:111&amp;&amp;VN4]被添加, hash值为848442551</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN0]被添加, hash值为1452694222</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN1]被添加, hash值为2023612840</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN2]被添加, hash值为697907480</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN3]被添加, hash值为790847074</span><br><span class="line">虚拟节点[192.168.0.2:111&amp;&amp;VN4]被添加, hash值为2010506136</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN0]被添加, hash值为891084251</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN1]被添加, hash值为1725031739</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN2]被添加, hash值为1127720370</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN3]被添加, hash值为676720500</span><br><span class="line">虚拟节点[192.168.0.3:111&amp;&amp;VN4]被添加, hash值为2050578780</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN0]被添加, hash值为586921010</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN1]被添加, hash值为184078390</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN2]被添加, hash值为1331645117</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN3]被添加, hash值为918790803</span><br><span class="line">虚拟节点[192.168.0.4:111&amp;&amp;VN4]被添加, hash值为1232193678</span><br><span class="line"></span><br><span class="line">[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.0:111]</span><br><span class="line">[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.2:111]</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>从代码运行结果看，每个点路由到的服务器都是Hash值顺时针离它最近的那个服务器节点，没有任何问题。</p>
<p>通过采取虚拟节点的方法，一个真实结点不再固定在Hash换上的某个点，而是大量地分布在整个Hash环上，这样即使上线、下线服务器，也不会造成整体的负载不均衡。</p>
</div><div class="tags"><a href="/tags/java"><i class="fa fa-tag">java</i></a></div><div class="post-nav"><a class="pre" href="/posts/17892/">collections 数据复制</a><a class="next" href="/posts/51543/">nginx配置反向代理</a></div><div id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://comment.aimak.cn',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.png"/></a><p>认真生活.</p><a class="info-icon" href="https://twitter.com/fantasykaicc" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:makren@126.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/fantasykai" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/AI-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">AI, 网络运维</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a><span class="category-list-count">117</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%93%E5%AD%98/">缓存</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E5%BD%95/">语录</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a> <a href="/tags/PMO/" style="font-size: 15px;">PMO</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/" style="font-size: 15px;">技术团队</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/" style="font-size: 15px;">开发效率</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 15px;">人工智能</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF-%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/" style="font-size: 15px;">人工智能, 技术趋势, 行业动态</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">深度学习</a> <a href="/tags/AI-%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 15px;">AI 智能体</a> <a href="/tags/Deepseek-%E8%87%AA%E6%99%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%90%A5%E5%95%86-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">Deepseek, 自智网络, 运营商, 网络运维</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 15px;">知识图谱</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/thymeleaf/" style="font-size: 15px;">thymeleaf</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Chrome-%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">Chrome 效率插件</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 15px;">缓存</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">测试</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/IPv6/" style="font-size: 15px;">IPv6</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/SDN/" style="font-size: 15px;">SDN</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/restful/" style="font-size: 15px;">restful</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/" style="font-size: 15px;">技术小栈</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">高并发</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 15px;">日志</a> <a href="/tags/%E8%AF%AD%E5%BD%95/" style="font-size: 15px;">语录</a> <a href="/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/" style="font-size: 15px;">报告分享</a> <a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 15px;">马拉松</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 15px;">健康</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/63208/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/46858/">2025年2月AI领域月度回顾：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63207/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/61225/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63206/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63205/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63204/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63203/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2337ee66/">AI 在通信领域的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63202/">每日资讯</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://comment.aimak.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://landscape.cncf.io/" title="CNCF" target="_blank">CNCF</a><ul></ul><a href="https://segmentfault.com/" title="SegmentFault" target="_blank">SegmentFault</a><ul></ul><a href="https://blog.csdn.net/junbaozi/category_11649936_3.html" title="CloudNative" target="_blank">CloudNative</a><ul></ul><a href="https://excalidraw.com/" title="excalidraw" target="_blank">excalidraw</a><ul></ul><a href="https://tudan.blog.csdn.net/?type=lately" title="王坦" target="_blank">王坦</a><ul></ul><a href="https://aspoem.com/zh-Hans" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">枫哲's文栖小筑.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">｜苏ICP备18013756号-1</a><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>