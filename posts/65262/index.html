<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="fantasykai`blog"><title>Java多线程总结 | 枫哲's文栖小筑</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2bb92548008bd1f1f88213efd40c8dad';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java多线程总结</h1><a id="logo" href="/.">枫哲's文栖小筑</a><p class="description">君子终日乾乾，夕惕若厉，无咎</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/blogroll/"><i class="fa fa-external-link"> 收藏链接</i></a><a href="/2048/"><i class="fa fa-gamepad"> 放松下</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java多线程总结</h1><div class="post-meta">2019-09-23<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a></span></div><a class="disqus-comment-count" href="/posts/65262/#vcomment"><span class="waline-comment-count" id="/posts/65262/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">一、多线程为什么会有并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">二、Java 内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">3.</span> <span class="toc-text">三、并发三要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%89%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">四、怎么做，才能解决并发问题？（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81volatile"><span class="toc-number">4.1.</span> <span class="toc-text">一、volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-volatile-%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 volatile 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8D%95%E4%BE%8B%E5%8F%8C%E9%87%8D%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0volatile%EF%BC%9F"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 单例双重锁为什么要用到volatile？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-volatile-%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 volatile 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-volatile-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">4.1.5.</span> <span class="toc-text">1.5 volatile 的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Synchronized"><span class="toc-number">4.2.</span> <span class="toc-text">二、Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Synchronized-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 Synchronized 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Synchronized-%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 Synchronized 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Synchronized-%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 Synchronized 锁的升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Synchronized-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4  Synchronized 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock"><span class="toc-number">4.3.</span> <span class="toc-text">三、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-ReentrantLock-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 ReentrantLock 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Condition-%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 Condition 条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 公平锁与非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-ReentrantLock-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.4 ReentrantLock  注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E5%8C%85"><span class="toc-number">4.4.</span> <span class="toc-text">四、并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-ConcurrentHashMap"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.1 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-LinkBlockingQueue"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.2 LinkBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%9AAtomicInteger"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.3  原子操作类：AtomicInteger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">五、总结</span></a></li></ol></div></div><div class="post-content"><p>这篇文章将总结多线程并发的各种处理方式，希望对大家有所帮助。</p>
<h2 id="一、多线程为什么会有并发问题"><a href="#一、多线程为什么会有并发问题" class="headerlink" title="一、多线程为什么会有并发问题"></a>一、多线程为什么会有并发问题</h2><p>为什么多线程同时访问（读写）同个变量，会有并发问题？</p>
<blockquote>
<ol>
<li>Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。</li>
<li>线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</li>
<li>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</li>
<li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ol>
</blockquote>
<h2 id="二、Java-内存模型（JMM）"><a href="#二、Java-内存模型（JMM）" class="headerlink" title="二、Java 内存模型（JMM）"></a>二、Java 内存模型（JMM）</h2><p>Java 内存模型(JMM) 作用于工作内存（本地内存）和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步，如下图。</p>
<p><img src="https://aimak.cn/blog_img/java/jmm-model.jpg" alt="JMM"></p>
<h2 id="三、并发三要素"><a href="#三、并发三要素" class="headerlink" title="三、并发三要素"></a>三、并发三要素</h2><p><strong>原子性</strong>：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</p>
<p><strong>可见性</strong>：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="四、怎么做，才能解决并发问题？（重点）"><a href="#四、怎么做，才能解决并发问题？（重点）" class="headerlink" title="四、怎么做，才能解决并发问题？（重点）"></a>四、怎么做，才能解决并发问题？（重点）</h2><p>下面结合不同场景分析解决并发问题的处理方式。</p>
<h3 id="一、volatile"><a href="#一、volatile" class="headerlink" title="一、volatile"></a>一、volatile</h3><h4 id="1-1-volatile-特性"><a href="#1-1-volatile-特性" class="headerlink" title="1.1 volatile 特性"></a>1.1 volatile 特性</h4><p><strong>保证可见性，不保证原子性</strong></p>
<blockquote>
<ol>
<li>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</li>
<li>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。</li>
</ol>
</blockquote>
<p><strong>禁止指令重排序</strong> 指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则：</p>
<blockquote>
<ol>
<li>不会对存在依赖关系的指令重排序，例如 a &#x3D; 1;b &#x3D; a;  a 和b存在依赖关系，不会被重排序</li>
<li>不能影响单线程下的执行结果。比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作,前两个操作可以重排序，但是c&#x3D;a+b不会被重排序，因为要保证结果是3</li>
</ol>
</blockquote>
<h4 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h4><p>对于一个变量，只有一个线程执行写操作，其它线程都是读操作，这时候可以用 volatile 修饰这个变量。</p>
<h4 id="1-3-单例双重锁为什么要用到volatile？"><a href="#1-3-单例双重锁为什么要用到volatile？" class="headerlink" title="1.3 单例双重锁为什么要用到volatile？"></a>1.3 单例双重锁为什么要用到volatile？</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestInstance</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TestInstance mInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestInstance <span class="title">getInstance</span>()</span>&#123;       <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;                     <span class="comment">//2</span></span><br><span class="line">        synchronized (TestInstance.<span class="keyword">class</span>)&#123;      <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)&#123;             <span class="comment">//4</span></span><br><span class="line">                mInstance = <span class="keyword">new</span> TestInstance(); <span class="comment">//5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>假如没有用volatile，并发情况下会出现问题，线程A执行到注释5 <code>new TestInstance()</code> 的时候，分为如下几个几步操作：</p>
<ol>
<li>分配内存</li>
<li>初始化对象</li>
<li>mInstance 指向内存</li>
</ol>
<p>这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断mInstance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。</p>
<h4 id="1-4-volatile-原理"><a href="#1-4-volatile-原理" class="headerlink" title="1.4 volatile 原理"></a>1.4 volatile 原理</h4><p>在JVM底层volatile是采用<strong>内存屏障</strong>来实现的，内存屏障会提供3个功能：</p>
<blockquote>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将缓存的修改操作立即写到主内存</li>
<li>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</li>
</ol>
</blockquote>
<h4 id="1-5-volatile-的局限性"><a href="#1-5-volatile-的局限性" class="headerlink" title="1.5 volatile 的局限性"></a>1.5 volatile 的局限性</h4><p><strong>volatile 只能保证可见性，不能保证原子性</strong>写操作对其它线程可见，但是不能解决多个线程同时写的问题。</p>
<h3 id="二、Synchronized"><a href="#二、Synchronized" class="headerlink" title="二、Synchronized"></a>二、Synchronized</h3><h4 id="2-1-Synchronized-使用场景"><a href="#2-1-Synchronized-使用场景" class="headerlink" title="2.1 Synchronized 使用场景"></a>2.1 Synchronized 使用场景</h4><p>多个线程同时写一个变量。</p>
<p>例如售票，余票是100张，窗口A和窗口B同时各卖出一张票， 假如余票变量用 volatile 修饰，是有问题的。<br> A窗口获取余票是100，B窗口获取余票也是100，A卖出一张变成99，刷新回主内存，同时B卖出一张变成99，也刷新回主内存，会导致最终主内存余票是99而不是98。</p>
<p>前面说到 volatile 的局限性，就是多个线程同时写的情况，这种情况一般可以使用<strong>Synchronized</strong>。</p>
<p><strong>Synchronized 可以保证同一时刻，只有一个线程可执行某个方法或某个代码块。</strong></p>
<h4 id="2-2-Synchronized-原理"><a href="#2-2-Synchronized-原理" class="headerlink" title="2.2 Synchronized 原理"></a>2.2 Synchronized 原理</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    synchronized (SynchronizedTest.<span class="keyword">class</span>) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>将这段代码先用<code>javac</code>命令编译，再<code>java p -v SynchronizedTest.class</code>命令查看字节码，部分字节码如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line"><span class="attr">descriptor:</span> <span class="string">([Ljava/lang/String;)V</span></span><br><span class="line"><span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_STATIC</span></span><br><span class="line"><span class="attr">Code:</span></span><br><span class="line">  <span class="string">stack=2,</span> <span class="string">locals=3,</span> <span class="string">args_size=1</span></span><br><span class="line">     <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // class com/lanshifu/opengldemo/test/SynchronizedTest</span></span><br><span class="line">     <span class="attr">2:</span> <span class="string">dup</span></span><br><span class="line">     <span class="attr">3:</span> <span class="string">astore_1</span></span><br><span class="line">     <span class="attr">4:</span> <span class="string">monitorenter</span></span><br><span class="line">     <span class="attr">5:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">     <span class="attr">8:</span> <span class="string">ldc</span>           <span class="comment">#4                  // String 123</span></span><br><span class="line">    <span class="attr">10:</span> <span class="string">invokevirtual</span> <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">    <span class="attr">13:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">14:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">15:</span> <span class="string">goto</span>          <span class="number">23</span></span><br><span class="line">    <span class="attr">18:</span> <span class="string">astore_2</span></span><br><span class="line">    <span class="attr">19:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">20:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attr">21:</span> <span class="string">aload_2</span></span><br><span class="line">    <span class="attr">22:</span> <span class="string">athrow</span></span><br><span class="line">    <span class="attr">23:</span> <span class="string">invokestatic</span>  <span class="comment">#6                  // Method method:()V</span></span><br><span class="line">    <span class="attr">26:</span> <span class="string">return</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>4: monitorenter</code> 和 <code>14: monitorexit</code>，中间是打印的语句。</p>
<p>执行同步代码块，首先会执行<code>monitorenter</code>指令，然后执行同步代码块中的代码，退出同步代码块的时候会执行<code>monitorexit</code>指令 。</p>
<blockquote>
<p>使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就进入同步队列，线程状态变成BLOCK，同一时刻只有一个线程能够获取到monitor，当监听到monitorexit被调用，队列里就有一个线程出队，获取monitor。详情参考：<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/d53bf830fa09">www.jianshu.com/p/d53bf830f…</a></p>
</blockquote>
<p>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一，所以只要这个锁的计数器大于0，其它线程访问就只能等待。</p>
<h4 id="2-3-Synchronized-锁的升级"><a href="#2-3-Synchronized-锁的升级" class="headerlink" title="2.3 Synchronized 锁的升级"></a>2.3 Synchronized 锁的升级</h4><p>大家对Synchronized的理解可能就是重量级锁，但是Java1.6对 Synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p>
<p><strong>偏向锁：</strong> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<blockquote>
<p>当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。</p>
</blockquote>
<p><strong>轻量级锁：</strong> 在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。</p>
<p><strong>重量级锁：</strong> 如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p>
<h4 id="2-4-Synchronized-缺点"><a href="#2-4-Synchronized-缺点" class="headerlink" title="2.4  Synchronized 缺点"></a>2.4  Synchronized 缺点</h4><ol>
<li>不能设置锁超时时间</li>
<li>不能通过代码释放锁</li>
<li>容易造成死锁</li>
</ol>
<h3 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h3><p>上面说到<code>Synchronized</code>的缺点，不能设置锁超时时间和不能通过代码释放锁，<code>ReentranLock</code>就可以解决这个问题。</p>
<p><strong>在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适</strong>，ReentrantLock还提供了<code>Condition</code>，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</p>
<h4 id="3-1-ReentrantLock-的使用"><a href="#3-1-ReentrantLock-的使用" class="headerlink" title="3.1 ReentrantLock 的使用"></a>3.1 ReentrantLock 的使用</h4><p><strong>lock 和 unlock</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;lock&quot;</span>);</span><br><span class="line">        reentrantLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;睡眠2秒...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;reentrantLock-&gt;unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>实现可定时的锁请求：tryLock</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    public static void <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        ReentrantLock reentrantLock = new <span class="built_in">ReentrantLock</span>();</span><br><span class="line">        Thread thread1 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread1<span class="selector-class">.setName</span>(&quot;thread1&quot;);</span><br><span class="line">        thread1<span class="selector-class">.start</span>();</span><br><span class="line">        Thread thread2 = new <span class="built_in">Thread_tryLock</span>(reentrantLock);</span><br><span class="line">        thread2<span class="selector-class">.setName</span>(&quot;thread2&quot;);</span><br><span class="line">        thread2<span class="selector-class">.start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class Thread_tryLock extends Thread &#123;</span><br><span class="line">        ReentrantLock reentrantLock;</span><br><span class="line"></span><br><span class="line">        public <span class="built_in">Thread_tryLock</span>(ReentrantLock reentrantLock) &#123;</span><br><span class="line">            this<span class="selector-class">.reentrantLock</span> = reentrantLock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                boolean tryLock = reentrantLock<span class="selector-class">.tryLock</span>(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                if (tryLock) &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock success :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;睡眠一下：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                    Thread<span class="selector-class">.sleep</span>(<span class="number">5000</span>);</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;醒了：&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;try lock 超时 :&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;unlock:&quot; + Thread.currentThread()<span class="selector-class">.getName</span>());</span><br><span class="line">                reentrantLock<span class="selector-class">.unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>打印的日志：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> lock:thread1</span><br><span class="line"><span class="keyword">try</span> lock:thread2</span><br><span class="line"><span class="keyword">try</span> lock success :thread2</span><br><span class="line">睡眠一下：thread2</span><br><span class="line"><span class="keyword">try</span> lock 超时 :thread1</span><br><span class="line">unlock:thread1</span><br><span class="line"><span class="built_in">Exception</span> in thread <span class="string">&quot;thread1&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock<span class="variable">$Sync</span>.<span class="title function_ invoke__">tryRelease</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">151</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.<span class="title function_ invoke__">release</span>(AbstractQueuedSynchronizer.<span class="attr">java</span>:<span class="number">1261</span>)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.<span class="title function_ invoke__">unlock</span>(ReentrantLock.<span class="attr">java</span>:<span class="number">457</span>)</span><br><span class="line">	at com.lanshifu.demo_module.test.lock.ReentranLockTest<span class="variable">$Thread_tryLock</span>.<span class="title function_ invoke__">run</span>(ReentranLockTest.<span class="attr">java</span>:<span class="number">60</span>)</span><br><span class="line">醒了：thread2</span><br><span class="line">unlock:thread2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面演示了<code>trtLock</code>的使用，<code>trtLock</code>设置获取锁的等待时间，超过3秒直接返回失败，可以从日志中看到结果。 有异常是因为thread1获取锁失败，不应该调用unlock。</p>
<h4 id="3-2-Condition-条件"><a href="#3-2-Condition-条件" class="headerlink" title="3.2 Condition 条件"></a>3.2 Condition 条件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Thread_Condition thread_condition = <span class="keyword">new</span> Thread_Condition();</span><br><span class="line">        thread_condition.setName(<span class="string">&quot;测试Condition的线程&quot;</span>);</span><br><span class="line">        thread_condition.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread_condition.singal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Thread_Condition</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">await</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">public</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:我在等待通知的到来...&quot;</span>);</span><br><span class="line">                condition.<span class="keyword">await</span>();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                <span class="comment">//condition.await(2, TimeUnit.SECONDS); //设置等待超时时间</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot;:等到通知了，我继续执行&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singal</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;我要通知在等待的线程，condition.signal()&quot;</span>);</span><br><span class="line">                condition.signal();<span class="comment">//await 和 signal 对应</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;unlock&quot;</span>);</span><br><span class="line">                <span class="keyword">lock</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>运行打印日志</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span></span><br><span class="line">测试Condition的线程:我在等待通知的到来...</span><br><span class="line"><span class="keyword">lock</span></span><br><span class="line">我要通知在等待的线程，condition.signal()</span><br><span class="line">unlock</span><br><span class="line">测试Condition的线程:等到通知了，我继续执行&gt;&gt;&gt;</span><br><span class="line">unlock</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面演示了<code>Condition的 await 和 signal</code> 使用，前提要先lock。</p>
<h4 id="3-3-公平锁与非公平锁"><a href="#3-3-公平锁与非公平锁" class="headerlink" title="3.3 公平锁与非公平锁"></a>3.3 公平锁与非公平锁</h4><p>ReentrantLock 构造函数传true表示公平锁。</p>
<p>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的顺序。而非公平锁就是一种锁的抢占机制，是随机获得锁的，可能会导致某些线程一致拿不到锁，所以是不公平的。</p>
<h4 id="3-4-ReentrantLock-注意点"><a href="#3-4-ReentrantLock-注意点" class="headerlink" title="3.4 ReentrantLock  注意点"></a>3.4 ReentrantLock  注意点</h4><ol>
<li>ReentrantLock使用lock和unlock来获得锁和释放锁</li>
<li>unlock要放在finally中，这样正常运行或者异常都会释放锁</li>
<li>使用condition的await和signal方法之前，必须调用lock方法获得对象监视器</li>
</ol>
<h3 id="四、并发包"><a href="#四、并发包" class="headerlink" title="四、并发包"></a>四、并发包</h3><p>通过上面分析，并发严重的情况下，使用锁显然效率低下，因为同一时刻只能有一个线程可以获得锁，其它线程只能乖乖等待。</p>
<p>Java提供了并发包解决这个问题，接下来介绍并发包里一些常用的数据结构。</p>
<h4 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h4><p>我们都知道HashMap是线程不安全的数据结构，HashTable则在HashMap基础上，get方法和put方法加上Synchronized修饰变成线程安全，不过在高并发情况下效率底下，最终被<code>ConcurrentHashMap</code>替代。</p>
<p>ConcurrentHashMap 采用分段锁，内部默认有16个桶，get和put操作，首先将key计算hashcode，然后跟16取余，落到16个桶中的一个，然后每个桶中都加了锁（ReentrantLock），桶中是HashMap结构（数组加链表，链表过长转红黑树）。</p>
<p>所以理论上最多支持16个线程同时访问。</p>
<h4 id="4-2-LinkBlockingQueue"><a href="#4-2-LinkBlockingQueue" class="headerlink" title="4.2 LinkBlockingQueue"></a>4.2 LinkBlockingQueue</h4><p>链表结构的阻塞队列，内部使用多个ReentrantLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>源码不贴太多，简单说一下<code>LinkBlockingQueue</code> 的逻辑：</p>
<blockquote>
<ol>
<li>从队列获取数据，如果队列中没有数据，会调用<code>notEmpty.await();</code>进入等待。</li>
<li>在放数据进去队列的时候会调用<code>notEmpty.signal();</code>，通知消费者，1中的等待结束，唤醒继续执行。</li>
<li>从队列里取到数据的时候会调用<code>notFull.signal();</code>，通知生产者继续生产。</li>
<li>在put数据进入队列的时候，如果判断队列中的数据达到最大值，那么会调用<code>notFull.await();</code>，等待消费者消费掉，也就是等待3去取数据并且发出<code>notFull.signal();</code>，这时候生产者才能继续生产。</li>
</ol>
</blockquote>
<p><code>LinkBlockingQueue</code> 是典型的生产者消费者模式，源码细节就不多说。</p>
<h4 id="4-3-原子操作类：AtomicInteger"><a href="#4-3-原子操作类：AtomicInteger" class="headerlink" title="4.3  原子操作类：AtomicInteger"></a>4.3  原子操作类：AtomicInteger</h4><p>内部采用CAS（compare and swap）保证原子性</p>
<p>举一个int自增的例子</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        AtomicInteger <span class="attr">atomicInteger</span> = new AtomicInteger(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">        atomicInteger.incrementAndGet()<span class="comment">;//自增</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>源码看一下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>U 是 Unsafe，看下 <code>Unsafe#getAndAddInt</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过<code>compareAndSwapInt</code>保证原子性。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>面试中问到多线程并发问题，可以这么答：</p>
<blockquote>
<ol>
<li>当只有一个线程写，其它线程都是读的时候，可以用<code>volatile</code>修饰变量</li>
<li>当多个线程写，那么一般情况下并发不严重的话可以用<code>Synchronized</code>，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。</li>
<li><code>ReentranLock</code> 可以通过代码释放锁，可以设置锁超时。</li>
<li>高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如<code>ConcurrentHashMap</code>，<code>LinkBlockingQueue</code>，以及原子性的数据结构如：<code>AtomicInteger</code>。</li>
</ol>
</blockquote>
<p>面试的时候按照上面总结的这个思路回答基本就ok了。既然说到并发包，那么除了<code>ConcurrentHashMap</code>，其它一些常用的数据结构的原理也需要去了解下，例如<code>HashMap、HashTable、TreeMap</code>原理，<code>ArrayList、LinkedList</code>对比，这些都是老生常谈的，自己去看源码或者一些博客。</p>
</div><div class="tags"><a href="/tags/并发"><i class="fa fa-tag">并发</i></a></div><div class="post-nav"><a class="pre" href="/posts/8104/">技术管理者应该管些什么？</a><a class="next" href="/posts/16471/">阿里毕玄：系统架构师如何做好系统设计？</a></div><div id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://comment.aimak.cn',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.png"/></a><p>认真生活.</p><a class="info-icon" href="https://twitter.com/fantasykaicc" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:makren@126.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/fantasykai" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/AI-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">AI, 网络运维</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a><span class="category-list-count">117</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%93%E5%AD%98/">缓存</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E5%BD%95/">语录</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a> <a href="/tags/PMO/" style="font-size: 15px;">PMO</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/" style="font-size: 15px;">技术团队</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/" style="font-size: 15px;">开发效率</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/thymeleaf/" style="font-size: 15px;">thymeleaf</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 15px;">人工智能</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 15px;">人工智能,</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">深度学习</a> <a href="/tags/AI-%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 15px;">AI 智能体</a> <a href="/tags/Deepseek-%E8%87%AA%E6%99%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%90%A5%E5%95%86-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">Deepseek, 自智网络, 运营商, 网络运维</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 15px;">知识图谱</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF-%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/" style="font-size: 15px;">人工智能, 技术趋势, 行业动态</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 15px;">缓存</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">测试</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/" style="font-size: 15px;">报告分享</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/IPv6/" style="font-size: 15px;">IPv6</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/SDN/" style="font-size: 15px;">SDN</a> <a href="/tags/%E8%AF%AD%E5%BD%95/" style="font-size: 15px;">语录</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Chrome-%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">Chrome 效率插件</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 15px;">马拉松</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 15px;">健康</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/restful/" style="font-size: 15px;">restful</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/" style="font-size: 15px;">技术小栈</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">高并发</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 15px;">日志</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/11185/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11183/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11182/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11181/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11180/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11179/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11178/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11177/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11176/">AI领域最新资讯：突破、趋势与展望</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17953/">2025年3月16日南京半程马拉松赛前训练、饮食及成绩预测</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://comment.aimak.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://landscape.cncf.io/" title="CNCF" target="_blank">CNCF</a><ul></ul><a href="https://segmentfault.com/" title="SegmentFault" target="_blank">SegmentFault</a><ul></ul><a href="https://blog.csdn.net/junbaozi/category_11649936_3.html" title="CloudNative" target="_blank">CloudNative</a><ul></ul><a href="https://excalidraw.com/" title="excalidraw" target="_blank">excalidraw</a><ul></ul><a href="https://tudan.blog.csdn.net/?type=lately" title="王坦" target="_blank">王坦</a><ul></ul><a href="https://aspoem.com/zh-Hans" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">枫哲's文栖小筑.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">｜苏ICP备18013756号-1</a><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>