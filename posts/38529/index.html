<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="fantasykai`blog"><title>Redis 总结 | 枫哲's文栖小筑</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2bb92548008bd1f1f88213efd40c8dad';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis 总结</h1><a id="logo" href="/.">枫哲's文栖小筑</a><p class="description">君子终日乾乾，夕惕若厉，无咎</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/blogroll/"><i class="fa fa-external-link"> 收藏链接</i></a><a href="/2048/"><i class="fa fa-gamepad"> 放松下</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis 总结</h1><div class="post-meta">2018-01-06<span> | </span><span class="category"><a href="/categories/%E7%BC%93%E5%AD%98/">缓存</a></span></div><a class="disqus-comment-count" href="/posts/38529/#vcomment"><span class="waline-comment-count" id="/posts/38529/"></span><span> 条评论</span></a><div class="post-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后在性能调优等方面进行更深入的介绍和指导。</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>概述</strong></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Redis 是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。</p>
<p>Redis 支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs 等。</p>
<p>Redis 具备 LRU 淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过 Redis Sentinel 实现的高可用方案，同时还支持通过 Redis Cluster 实现的数据自动分片能力。</p>
<p>Redis 的主要功能都基于单线程模型实现，也就是说 Redis 使用一个线程来服务所有的客户端请求，同时 Redis 采用了非阻塞式 IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<blockquote>
<ul>
<li>Redis 是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis 的速度非常快（因为使用非阻塞式 IO，且大部分命令的算法时间复杂度都是 O(1))</li>
<li>使用高耗时的 Redis 命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为 O(N) 的 KEYS 命令，严格禁止在生产环境中使用）</li>
</ul>
</blockquote>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="Redis-的数据结构和相关常用命令"><a href="#Redis-的数据结构和相关常用命令" class="headerlink" title="Redis 的数据结构和相关常用命令"></a>Redis 的数据结构和相关常用命令</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>本节中将介绍 Redis 支持的主要数据结构，以及相关的常用 Redis 命令。本节只对 Redis 命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的 Redis 命令集，或了解某个命令的详细使用方法，请参考官方文档：<a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands</a></p>
<h3 id="常用命令一、Key"><a href="#常用命令一、Key" class="headerlink" title="常用命令一、Key"></a><strong>常用命令一、Key</strong></h3><p>Redis 采用 Key-Value 型的基本数据结构，任何二进制序列都可以作为 Redis 的 Key 使用（例如普通的字符串或一张 JPEG 图片）<br><strong>关于 Key 的一些注意事项：</strong></p>
<p>不要使用过长的 Key。例如使用一个 1024 字节的 key 就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</p>
<p>Key 短到缺失了可读性也是不好的，例如”u1000flw” 比起”user:1000:followers” 来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</p>
<p>最好使用统一的规范来设计 Key，比如”object-type:id:attr”，以这一规范设计出的 Key 可能是”user:1000” 或”comment:1234:reply-to”</p>
<p>Redis 允许的最大 Key 长度是 512MB（对 Value 的长度限制也是 512MB）</p>
<h3 id="常用命令二、String"><a href="#常用命令二、String" class="headerlink" title="常用命令二、String"></a><strong>常用命令二、String</strong></h3><p>String 是 Redis 的基础数据类型，Redis 没有 Int、Float、Boolean 等数据类型的概念，所有的基本类型在 Redis 中都以 String 体现。</p>
<p>与 String 相关的常用命令：</p>
<blockquote>
<ul>
<li>SET：为一个 key 设置 value，可以配合 EX&#x2F;PX 参数指定 key 的有效期，通过 NX&#x2F;XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li>
<li>GET：获取某个 key 对应的 value，时间复杂度 O(1)</li>
<li>GETSET：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li>
<li>MSET：为多个 key 设置 value，时间复杂度 O(N)</li>
<li>MSETNX：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li>
<li>MGET：获取多个 key 对应的 value，时间复杂度 O(N)</li>
</ul>
</blockquote>
<p>上文提到过，Redis 的基本数据类型只有 String，但 Redis 可以把 String 作为整型或浮点型数字来使用，主要体现在 INCR、DECR 类的命令上：</p>
<blockquote>
<ul>
<li>INCR：将 key 对应的 value 值自增 1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li>INCRBY：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li>DECR&#x2F;DECRBY：同 INCR&#x2F;INCRBY，自增改为自减。</li>
</ul>
</blockquote>
<p>INCR&#x2F;DECR 系列命令要求操作的 value 类型为 String，并可以转换为 64 位带符号的整型数字，否则会返回错误。</p>
<p>也就是说，进行 INCR&#x2F;DECR 系列命令的 value，必须在 [-2^63 ~ 2^63 - 1] 范围内。</p>
<p>前文提到过，Redis 采用单线程模型，天然是线程安全的，这使得 INCR&#x2F;DECR 命令可以非常便利的实现高并发场景下的精确控制。</p>
<ul>
<li><p><strong>例 1：库存控制</strong></p>
<p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。</p>
<p>设置库存总量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET inv:remain &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>库存扣减 + 余量校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR inv:remain</span><br></pre></td></tr></table></figure>

<p>当 DECR 命令返回值大于等于 0 时，说明库存余量校验通过，如果返回小于 0 的值，则说明库存已耗尽。</p>
<p>假设同时有 300 个并发请求进行库存扣减，Redis 能够确保这 300 个请求分别得到 99 到 - 200 的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
</li>
<li><p><strong>例 2：自增序列生成</strong></p>
<p>实现类似于 RDBMS 的 Sequence 功能，生成一系列唯一的序列号</p>
<p>设置序列起始值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET sequence &quot;10000&quot;</span><br></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR sequence</span><br></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。</p>
<p>获取一批（如 100 个）序列值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY sequence 100</span><br></pre></td></tr></table></figure>

<p>假设返回值为 N，那么 [N - 99 ~ N] 的数值都是可用的序列值。</p>
<p>当多个客户端同时向 Redis 申请自增序列时，Redis 能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
</li>
</ul>
<h3 id="常用命令三、List"><a href="#常用命令三、List" class="headerlink" title="常用命令三、List"></a><strong>常用命令三、List</strong></h3><p>Redis 的 List 是链表型的数据结构，可以使用 LPUSH&#x2F;RPUSH&#x2F;LPOP&#x2F;RPOP 等命令在 List 的两端执行插入元素和弹出元素的操作。虽然 List 也支持在特定 index 上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。</p>
<p>与 List 相关的常用命令：</p>
<blockquote>
<ul>
<li>LPUSH：向指定 List 的左侧（即头部）插入 1 个或多个元素，返回插入后的 List 长度。时间复杂度 O(N)，N 为插入元素的数量</li>
<li>RPUSH：同 LPUSH，向指定 List 的右侧（即尾部）插入 1 或多个元素</li>
<li>LPOP：从指定 List 的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li>
<li>RPOP：同 LPOP，从指定 List 的右侧（即尾部）移除 1 个元素并返回</li>
<li>LPUSHX&#x2F;RPUSHX：与 LPUSH&#x2F;RPUSH 类似，区别在于，LPUSHX&#x2F;RPUSHX 操作的 key 如果不存在，则不会进行任何操作</li>
<li>LLEN：返回指定 List 的长度，时间复杂度 O(1)</li>
<li>LRANGE：返回指定 List 中指定范围的元素（双端包含，即 LRANGE key 0 10 会返回 11 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List，避免使用 LRANGE key 0 -1 这样的完整遍历操作。</li>
</ul>
</blockquote>
<p>应谨慎使用的 List 相关命令：</p>
<blockquote>
<ul>
<li>LINDEX：返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 - 1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度 O(N)</li>
<li>LSET：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度 O(N)，如果操作的是头 &#x2F; 尾部的元素，则时间复杂度为 O(1)</li>
<li>LINSERT：向指定 List 中指定元素之前 &#x2F; 之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 - 1。如果指定 key 不存在，不会进行任何操作，时间复杂度 O(N)</li>
</ul>
</blockquote>
<p>由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 List 进行遍历，命令的耗时无法预估，在 List 长度大的情况下耗时会明显增加，应谨慎使用。</p>
<p>换句话说，Redis 的 List 实际是设计来用于实现队列，而不是用于实现类似 ArrayList 这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用 Redis 的 List 数据结构。</p>
<p>为了更好支持队列的特性，Redis 还提供了一系列阻塞式的操作命令，如 BLPOP&#x2F;BRPOP 等，能够实现类似于 BlockingQueue 的能力，即在 List 为空时，阻塞该连接，直到 List 中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（<a target="_blank" rel="noopener" href="https://redis.io/topics/data-types-intro%EF%BC%89">https://redis.io/topics/data-types-intro）</a> 中”Blocking operations on lists” 一节。</p>
<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h2 id="常用命令四、Hash"><a href="#常用命令四、Hash" class="headerlink" title="常用命令四、Hash"></a>常用命令四、Hash</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>Hash 即哈希表，Redis 的 Hash 和传统的哈希表一样，是一种 field-value 型的数据结构，可以理解成将 HashMap 搬入 Redis。</p>
<p>Hash 非常适合用于表现对象类型的数据，用 Hash 中的 field 对应对象的 field 即可。</p>
<p>Hash 的优点包括：</p>
<blockquote>
<ul>
<li>可以实现二元查找，如” 查找 ID 为 1000 的用户的年龄”</li>
<li>比起将整个对象序列化后作为 String 存储的方法，Hash 能够有效地减少网络传输的消耗</li>
<li>当使用 Hash 维护一个集合时，提供了比 List 效率高得多的随机访问命令</li>
</ul>
</blockquote>
<p>与 Hash 相关的常用命令：</p>
<blockquote>
<ul>
<li>HSET：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li>
<li>HGET：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li>
<li>HMSET&#x2F;HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N 为一次操作的 field 数量</li>
<li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li>
<li>HEXISTS：判断指定 Hash 中 field 是否存在，存在返回 1，不存在返回 0，时间复杂度 O(1)</li>
<li>HDEL：删除指定 Hash 中的 field（1 个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li>
<li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li>
</ul>
</blockquote>
<p>应谨慎使用的 Hash 相关命令：</p>
<blockquote>
<ul>
<li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li>
<li>HKEYS&#x2F;HVALS：返回指定 Hash 中所有的 field&#x2F;value，时间复杂度 O(N)</li>
</ul>
</blockquote>
<p>上述三个命令都会对 Hash 进行完整遍历，Hash 中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历，具体请见 <a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h2 id="常用命令五、Set"><a href="#常用命令五、Set" class="headerlink" title="常用命令五、Set"></a>常用命令五、Set</h2><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><p>Redis Set 是无序的，不可重复的 String 集合。</p>
<p>与 Set 相关的常用命令：</p>
<blockquote>
<ul>
<li>SADD：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li>
<li>SREM：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li>SRANDMEMBER：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li>
<li>SPOP：从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li>SCARD：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li>
<li>SISMEMBER：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li>
<li>SMOVE：将指定 member 从一个 Set 移至另一个 Set</li>
</ul>
</blockquote>
<p>慎用的 Set 相关命令：</p>
<blockquote>
<ul>
<li>SMEMBERS：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li>
<li>SUNION&#x2F;SUNIONSTORE：计算多个 Set 的并集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li>SINTER&#x2F;SINTERSTORE：计算多个 Set 的交集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li>SDIFF&#x2F;SDIFFSTORE：计算 1 个 Set 与 1 或多个 Set 的差集并返回 &#x2F; 存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数。</li>
</ul>
</blockquote>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member（具体请见 <a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），如果需要做并集 &#x2F; 交集 &#x2F; 差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行。</p>
<h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h2 id="常用命令六、Sorted-Set"><a href="#常用命令六、Sorted-Set" class="headerlink" title="常用命令六、Sorted Set"></a>常用命令六、Sorted Set</h2><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><p>Redis Sorted Set 是有序的、不可重复的 String 集合。Sorted Set 中的每个元素都需要指派一个分数 (score)，Sorted Set 会根据 score 对元素进行升序排序。如果多个 member 拥有相同的 score，则以字典序进行升序排序。</p>
<p>Sorted Set 非常适合用于实现排名。</p>
<p>Sorted Set 的主要命令：</p>
<blockquote>
<ul>
<li>ZADD：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li>ZREM：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li>ZCOUNT：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li>
<li>ZCARD：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li>
<li>ZSCORE：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li>
<li>ZRANK&#x2F;ZREVRANK：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li>
<li>ZINCRBY：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li>
</ul>
</blockquote>
<p>慎用的 Sorted Set 相关命令：</p>
<blockquote>
<ul>
<li>ZRANGE&#x2F;ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M 为本次返回的 member 数</li>
<li>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序 &#x2F; 降序排序，min 和 max 可以指定为 - inf 和 + inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li>
<li>ZREMRANGEBYRANK&#x2F;ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围 &#x2F; 指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li>
</ul>
</blockquote>
<p>上述几个命令，应尽量避免传递 [0 -1] 或 [-inf +inf] 这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历（具体请见 <a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p>
<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h2 id="常用命令七、Bitmap-和-HyperLogLog"><a href="#常用命令七、Bitmap-和-HyperLogLog" class="headerlink" title="常用命令七、Bitmap 和 HyperLogLog"></a>常用命令七、Bitmap 和 HyperLogLog</h2><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><p>Redis 的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令，请参考官方文档 <a target="_blank" rel="noopener" href="https://redis.io/topics/data-types-intro">https://redis.io/topics/data-types-intro</a> 中的相关章节</p>
<p>Bitmap 在 Redis 中不是一种实际的数据类型，而是一种将 String 作为 Bitmap 使用的方法。可以理解为将 String 转换为 bit 数组。使用 Bitmap 来存储 true&#x2F;false 类型的简单数据极为节省空间。</p>
<p>HyperLogLogs 是一种主要用于数量统计的数据结构，它和 Set 类似，维护一个不可重复的 String 集合，但是 HyperLogLogs 并不维护具体的 member 内容，只维护 member 的个数。也就是说，HyperLogLogs 只能用于计算一个集合中不重复的元素数量，所以它比 Set 要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><blockquote>
<ul>
<li>EXISTS：判断指定的 key 是否存在，返回 1 代表存在，0 代表不存在，时间复杂度 O(1)</li>
<li>DEL：删除指定的 key 及其对应的 value，时间复杂度 O(N)，N 为删除的 key 数量</li>
<li>EXPIRE&#x2F;PEXPIRE：为一个 key 设置有效期，单位为秒或毫秒，时间复杂度 O(1)</li>
<li>TTL&#x2F;PTTL：返回一个 key 剩余的有效时间，单位为秒或毫秒，时间复杂度 O(1)</li>
<li>RENAME&#x2F;RENAMENX：将 key 重命名为 newkey。使用 RENAME 时，如果 newkey 已经存在，其值会被覆盖；使用 RENAMENX 时，如果 newkey 已经存在，则不会进行任何操作，时间复杂度 O(1)</li>
<li>TYPE：返回指定 key 的类型，string, list, set, zset, hash。时间复杂度 O(1)</li>
<li>CONFIG GET：获得 Redis 某配置项的当前值，可以使用 * 通配符，时间复杂度 O(1)</li>
<li>CONFIG SET：为 Redis 某个配置项设置新值，时间复杂度 O(1)</li>
<li>CONFIG REWRITE：让 Redis 重新加载 redis.conf 中的配置</li>
</ul>
</blockquote>
<h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h2 id="Redis-性能调优"><a href="#Redis-性能调优" class="headerlink" title="Redis 性能调优"></a>Redis 性能调优</h2><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><p>尽管 Redis 是一个非常快速的内存数据存储媒介，也并不代表 Redis 不会产生性能问题。<br>前文中提到过，Redis 采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得 Redis 对每个任务的执行效率更加敏感。</p>
<p>针对 Redis 的性能优化，主要从下面几个层面入手：</p>
<blockquote>
<ul>
<li><p>最初的也是最重要的，确保没有让 Redis 执行耗时长的命令</p>
</li>
<li><p>使用 pipelining 将连续执行的命令组合执行</p>
</li>
<li><p>操作系统的 Transparent huge pages 功能必须关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在虚拟机中运行 Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过.&#x2F;redis-cli —intrinsic-latency 100 命令查看固有延迟。同时如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis。</p>
</li>
<li><p>检查数据持久化策略</p>
</li>
<li><p>考虑引入读写分离机制</p>
</li>
</ul>
</blockquote>
<h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h2><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在文本和官方文档中均对每个命令的时间复杂度有说明。</p>
<p>通常来说，O(1) 的命令是安全的，O(N) 命令在使用时需要注意，如果 N 的数量级不可预知，则应避免使用。例如对一个 field 数未知的 Hash 数据执行 HGETALL&#x2F;HKEYS&#x2F;HVALS 命令，通常来说这些命令执行的很快，但如果这个 Hash 中的 field 数量极多，耗时就会成倍增长。</p>
<p>又如使用 SUNION 对两个 Set 执行 Union 操作，或使用 SORT 对 List&#x2F;Set 执行排序操作等时，都应该严加注意。</p>
<p>避免在使用这些 O(N) 命令时发生问题主要有几个办法：</p>
<blockquote>
<ul>
<li>不要把 List 当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制 Hash、Set、Sorted Set 的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用 KEYS 命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用 SCAN 类的命令进行分批的，游标式的遍历</li>
</ul>
</blockquote>
<p>Redis 提供了 SCAN 命令，可以对 Redis 中存储的所有 key 进行游标式的遍历，避免使用 KEYS 命令带来的性能问题。同时还有 SSCAN&#x2F;HSCAN&#x2F;ZSCAN 等命令，分别用于对 Set&#x2F;Hash&#x2F;Sorted Set 中的元素进行游标式遍历。SCAN 类命令的使用请参考官方文档：<a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<p>Redis 提供了 Slow Log 功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than xxxms  #执行时间慢于xxx毫秒的命令计入Slow Logslowlog-max-len xxx  #Slow Log的长度，即最大纪录多少条Slow Log</span><br></pre></td></tr></table></figure>

<p>使用** SLOWLOG GET [number]** 命令，可以输出最近进入 Slow Log 的 number 条命令。<br>使用** SLOWLOG RESET** 命令，可以重置 Slow Log</p>
<h3 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h3><blockquote>
<ul>
<li><p>尽可能使用长连接或连接池，避免频繁创建销毁连接</p>
</li>
<li><p>客户端进行的批量数据操作，应使用 Pipeline 特性在一次交互中完成。具体请参照本文的 Pipelining 章节</p>
<p>​</p>
</li>
</ul>
</blockquote>
<h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a><strong>数据持久化引发的延迟</strong></h3><p>Redis 的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<blockquote>
<ul>
<li>AOF + fsync always 的设置虽然能够绝对确保数据安全，但每个操作都会触发一次 fsync，会对 Redis 的性能有比较明显的影响</li>
<li>AOF + fsync every second 是比较好的折中方案，每秒 fsync 一次</li>
<li>AOF + fsync never 会提供 AOF 持久化方案下的最优性能<br>使用 RDB 持久化通常会提供比使用 AOF 更高的性能，但需要注意 RDB 的策略配置</li>
<li>每一次 RDB 快照和 AOF Rewrite 都需要 Redis 主进程进行 fork 操作。fork 操作本身可能会产生较高的耗时，与 CPU 和 Redis 占用的内存大小有关。根据具体的情况合理配置 RDB 快照和 AOF Rewrite 时机，避免过于频繁的 fork 带来的延迟</li>
</ul>
</blockquote>
<blockquote>
<p>Redis 在 fork 子进程时需要将内存分页表拷贝至子进程，以占用了 24GB 内存的 Redis 实例为例，共需要拷贝 24GB &#x2F; 4kB * 8 &#x3D; 48MB 的数据。在使用单 Xeon 2.27Ghz 的物理机上，这一 fork 操作耗时 216ms。</p>
<p>可以通过 INFO 命令返回的 latest_fork_usec 字段查看上一次 fork 操作的耗时（微秒）</p>
</blockquote>
<h3 id="Swap-引发的延迟"><a href="#Swap-引发的延迟" class="headerlink" title="Swap 引发的延迟"></a><strong>Swap 引发的延迟</strong></h3><p>当 Linux 将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现不正常的延迟。Swap 通常在物理内存不足或一些进程在进行大量 I&#x2F;O 操作时发生，应尽可能避免上述两种情况的出现。</p>
<p>&#x2F;proc&#x2F;&#x2F;smaps 文件中会保存进程的 swap 记录，通过查看这个文件，能够判断 Redis 的延迟是否由 Swap 产生。如果这个文件中记录了较大的 Swap size，则说明延迟很有可能是 Swap 造成的。</p>
<h3 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h3><p>当同一秒内有大量 key 过期时，也会引发 Redis 的延迟。在使用时应尽量将 key 的失效时间错开。</p>
<h3 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a>引入读写分离机制</h3><p>Redis 的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。</p>
<p>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。</p>
<p>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<p>关于读写分离的具体说明，请参见后续章节</p>
<h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h2 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a>主从复制与集群分片</h2><h2 id="-19"><a href="#-19" class="headerlink" title=""></a></h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis 支持一主多从的主从复制架构。一个 Master 实例负责处理所有的写请求，Master 将写操作同步至所有 Slave。</p>
<p>借助 Redis 的主从复制，可以实现读写分离和高可用：</p>
<blockquote>
<ul>
<li>实时性要求不是特别高的读请求，可以在 Slave 上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的 Redis 命令，可以专门规划出 1 个或几个 Slave 用于服务这些统计任务</li>
<li>借助 Redis Sentinel 可以实现高可用，当 Master crash 后，Redis Sentinel 能够自动将一个 Slave 晋升为 Master，继续提供服务</li>
</ul>
</blockquote>
<p>启用主从复制非常简单，只需要配置多个 Redis 实例，在作为 Slave 的 Redis 实例中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379  #指定Master的IP和端口</span><br></pre></td></tr></table></figure>

<p>当 Slave 启动后，会从 Master 进行一次冷启动数据同步，由 Master 触发 BGSAVE 生成 RDB 文件推送给 Slave 进行导入，导入完成后 Master 再将增量数据通过 Redis Protocol 同步给 Slave。之后主从之间的数据便一直以 Redis Protocol 进行同步</p>
<h3 id="使用-Sentinel-做自动-failover"><a href="#使用-Sentinel-做自动-failover" class="headerlink" title="使用 Sentinel 做自动 failover"></a><strong>使用 Sentinel 做自动 failover</strong></h3><hr>
<p>Redis 的主从复制功能本身只是做数据同步，并不提供监控和自动 failover 能力，要通过主从复制功能来实现 Redis 的高可用，还需要引入一个组件：Redis Sentinel</p>
<p>Redis Sentinel 是 Redis 官方开发的监控组件，可以监控 Redis 实例的状态，通过 Master 节点自动发现 Slave 节点，并在监测到 Master 节点失效时选举出一个新的 Master，并向所有 Redis 实例推送新的主从配置。</p>
<p>Redis Sentinel 需要至少部署 3 个实例才能形成选举关系。</p>
<p>关键配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  #Master实例的IP、端口，以及选举需要的赞成票数sentinel down-after-milliseconds mymaster 60000  #多长时间没有响应视为Master失效sentinel failover-timeout mymaster 180000  #两次failover尝试间的间隔时长sentinel parallel-syncs mymaster 1  #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel 实现的自动 failover 不是在同一个 IP 和端口上完成的，也就是说自动 failover 产生的新 Master 提供服务的 IP 和端口与之前的 Master 是不一样的，所以要实现 HA，还要求客户端必须支持 Sentinel，能够与 Sentinel 交互获得新 Master 的信息才行。</p>
<h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h2><h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><p>为何要做集群分片：</p>
<blockquote>
<ul>
<li>Redis 中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis 的写请求并发量大，一个 Redis 实例以无法承载</li>
</ul>
</blockquote>
<p>当上述两个问题出现时，就必须要对 Redis 进行分片了。</p>
<p>Redis 的分片方案有很多种，例如很多 Redis 的客户端都自行实现了分片功能，也有向 Twemproxy 这样的以代理方式实现的 Redis 分片方案。然而首选的方案还应该是 Redis 官方在 3.0 版本中推出的 Redis Cluster 分片方案。</p>
<p>本文不会对 Redis Cluster 的具体安装和部署细节进行介绍，重点介绍 Redis Cluster 带来的好处与弊端。</p>
<h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-的能力"><a href="#Redis-Cluster-的能力" class="headerlink" title="Redis Cluster 的能力"></a>Redis Cluster 的能力</h2><blockquote>
<ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的 key 不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
</blockquote>
<p>其中第三点是基于主从复制来实现的，Redis Cluster 的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了 Redis Sentinel 这一额外的组件，由 Redis Cluster 负责进行一个分片内部的节点监控和自动 failover。</p>
<h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><h2 id="Redis-Cluster-分片原理"><a href="#Redis-Cluster-分片原理" class="headerlink" title="Redis Cluster 分片原理"></a>Redis Cluster 分片原理</h2><p>Redis Cluster 中共有 16384 个 hash slot，Redis 会计算每个 key 的 CRC16，将结果与 16384 取模，来决定该 key 存储在哪一个 hash slot 中，同时需要指定 Redis Cluster 中每个数据分片负责的 Slot 数。Slot 的分配在任何时间点都可以进行重新分配。</p>
<p>客户端在对 key 进行读写操作时，可以连接 Cluster 中的任意一个分片，如果操作的 key 不在此分片负责的 Slot 范围内，Redis Cluster 会自动将请求重定向到正确的分片上。</p>
<h3 id="-24"><a href="#-24" class="headerlink" title=""></a></h3><h2 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h2><p>在基础的分片原则上，Redis 还支持 hash tags 功能，以 hash tags 要求的格式明明的 key，将会确保进入同一个 Slot 中。例如：{uiv}user:1000 和 {uiv}user:1001 拥有同样的 hash tag {uiv}，会保存在同一个 Slot 中。</p>
<p>使用 Redis Cluster 时，pipelining、事务和 LUA Script 功能涉及的 key 必须在同一个数据分片上，否则将会返回错误。如要在 Redis Cluster 中使用上述功能，就必须通过 hash tags 来确保一个 pipeline 或一个事务中操作的所有 key 都位于同一个 Slot 中。</p>
<blockquote>
<p>有一些客户端（如 Redisson）实现了集群化的 pipelining 操作，可以自动将一个 pipeline 里的命令按 key 所在的分片进行分组，分别发到不同的分片上执行。但是 Redis 不支持跨分片的事务，事务和 LUA Script 还是必须遵循所有 key 在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a>主从复制 vs 集群分片</h2><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？</p>
<p>从各个方面看，Redis Cluster 都是优于主从复制的方案</p>
<blockquote>
<ul>
<li>Redis Cluster 能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster 能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster 包含了主从复制的能力</li>
</ul>
</blockquote>
<p>那是不是代表 Redis Cluster 永远是优于主从复制的选择呢？</p>
<p>并不是。</p>
<p>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用 Redis Cluster 的弊端包括：</p>
<blockquote>
<ul>
<li>维护难度增加。在使用 Redis Cluster 时，需要维护的 Redis 实例数倍增，需要监控的主机数量也相应增加，数据备份 &#x2F; 持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行 reshard 操作，远比主从模式下增加一个 Slave 的复杂度要高。</li>
<li>客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</li>
<li>性能优化难度增加。你可能需要在多个分片上查看 Slow Log 和 Swap 日志才能定位性能问题。</li>
<li>事务和 LUA Script 的使用成本增加。在 Redis Cluster 中使用事务和 LUA Script 特性有严格的限制条件，事务和 Script 中操作的 key 必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的 key 进行额外的规划和规范要求。如果应用的场景中大量涉及事务和 Script 的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</li>
</ul>
</blockquote>
<p>所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用 Redis Cluster。<br>下面是一些建议：</p>
<p>需要在 Redis 中存储的数据有多大？未来 2 年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用 LRU 算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出 Redis 需要使用的物理内存。</p>
<p>用于部署 Redis 的主机物理内存有多大？有多少可以分配给 Redis 使用？对比 (1) 中的内存需求评估，是否足够用？</p>
<p>Redis 面临的并发写压力会有多大？在不使用 pipelining 时，Redis 的写性能可以超过 10 万次 &#x2F; 秒（更多的 benchmark 可以参考 <a target="_blank" rel="noopener" href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a> ）</p>
<p>在使用 Redis 时，是否会使用到 pipelining 和事务功能？使用的场景多不多？<br>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对 Redis 的容量需求，且 Redis 面临的并发写压力距离 Benchmark 值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用 pipelining 和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
</div><div class="tags"><a href="/tags/Redis"><i class="fa fa-tag">Redis</i></a></div><div class="post-nav"><a class="pre" href="/posts/24195/">Redis相关总结2</a><a class="next" href="/posts/8312/">java性能优化</a></div><div id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://comment.aimak.cn',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.png"/></a><p>认真生活.</p><a class="info-icon" href="https://twitter.com/fantasykaicc" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:makren@126.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/fantasykai" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/AI-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">AI, 网络运维</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a><span class="category-list-count">117</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%93%E5%AD%98/">缓存</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E5%BD%95/">语录</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a> <a href="/tags/PMO/" style="font-size: 15px;">PMO</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/" style="font-size: 15px;">技术团队</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/" style="font-size: 15px;">开发效率</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 15px;">人工智能</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">深度学习</a> <a href="/tags/AI-%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 15px;">AI 智能体</a> <a href="/tags/Deepseek-%E8%87%AA%E6%99%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%90%A5%E5%95%86-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">Deepseek, 自智网络, 运营商, 网络运维</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 15px;">知识图谱</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF-%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/" style="font-size: 15px;">人工智能, 技术趋势, 行业动态</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/thymeleaf/" style="font-size: 15px;">thymeleaf</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Chrome-%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">Chrome 效率插件</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/restful/" style="font-size: 15px;">restful</a> <a href="/tags/IPv6/" style="font-size: 15px;">IPv6</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/" style="font-size: 15px;">技术小栈</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 15px;">缓存</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">高并发</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">测试</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 15px;">日志</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/SDN/" style="font-size: 15px;">SDN</a> <a href="/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/" style="font-size: 15px;">报告分享</a> <a href="/tags/%E8%AF%AD%E5%BD%95/" style="font-size: 15px;">语录</a> <a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 15px;">马拉松</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 15px;">健康</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/63208/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63207/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/61225/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63206/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63205/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63204/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63203/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2337ee66/">AI 在通信领域的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63202/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63201/">每日资讯</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://comment.aimak.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://landscape.cncf.io/" title="CNCF" target="_blank">CNCF</a><ul></ul><a href="https://segmentfault.com/" title="SegmentFault" target="_blank">SegmentFault</a><ul></ul><a href="https://blog.csdn.net/junbaozi/category_11649936_3.html" title="CloudNative" target="_blank">CloudNative</a><ul></ul><a href="https://excalidraw.com/" title="excalidraw" target="_blank">excalidraw</a><ul></ul><a href="https://tudan.blog.csdn.net/?type=lately" title="王坦" target="_blank">王坦</a><ul></ul><a href="https://aspoem.com/zh-Hans" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">枫哲's文栖小筑.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">｜苏ICP备18013756号-1</a><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>