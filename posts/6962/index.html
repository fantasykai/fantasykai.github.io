<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="fantasykai`blog"><title>AWK总结 | 枫哲's文栖小筑</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '2bb92548008bd1f1f88213efd40c8dad';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AWK总结</h1><a id="logo" href="/.">枫哲's文栖小筑</a><p class="description">君子终日乾乾，夕惕若厉，无咎</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/blogroll/"><i class="fa fa-external-link"> 收藏链接</i></a><a href="/2048/"><i class="fa fa-gamepad"> 放松下</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">AWK总结</h1><div class="post-meta">2017-12-09<span> | </span><span class="category"><a href="/categories/linux/">linux</a></span></div><a class="disqus-comment-count" href="/posts/6962/#vcomment"><span class="waline-comment-count" id="/posts/6962/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Awk%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">Awk是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">命令行语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">总结如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%EF%BC%88Record%EF%BC%89%E4%B8%8E%E5%AD%97%E6%AE%B5%EF%BC%88Field"><span class="toc-number">3.</span> <span class="toc-text">记录（Record）与字段（Field)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%EF%BC%88Script%EF%BC%89%E7%BB%84%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">脚本（Script）组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%88Pattern%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">模式（Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Regular-Expression%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">正则表达式（Regular Expression）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Expressions%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">表达式（Expressions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">内置变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ARGV%E4%B8%8EARGC"><span class="toc-number">9.0.1.</span> <span class="toc-text">ARGV与ARGC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9ARGV%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">更改ARGV元素的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4ARGV%E5%85%83%E7%B4%A0"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">删除ARGV元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0ARGV%E5%85%83%E7%B4%A0"><span class="toc-number">9.0.1.3.</span> <span class="toc-text">增加ARGV元素</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CONVFMT%E4%B8%8EOFMT"><span class="toc-number">9.0.2.</span> <span class="toc-text">CONVFMT与OFMT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENVIRON"><span class="toc-number">9.0.3.</span> <span class="toc-text">ENVIRON</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RLENGTH%E4%B8%8ERSTART"><span class="toc-number">9.0.4.</span> <span class="toc-text">RLENGTH与RSTART</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%EF%BC%88Statement%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">语句（Statement）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sub"><span class="toc-number">13.0.1.</span> <span class="toc-text">sub</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gsub"><span class="toc-number">13.0.2.</span> <span class="toc-text">gsub</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#index"><span class="toc-number">13.0.3.</span> <span class="toc-text">index</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#length"><span class="toc-number">13.0.4.</span> <span class="toc-text">length</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#match"><span class="toc-number">13.0.5.</span> <span class="toc-text">match</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#split"><span class="toc-number">13.0.6.</span> <span class="toc-text">split</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sprintf"><span class="toc-number">13.0.7.</span> <span class="toc-text">sprintf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#substr"><span class="toc-number">13.0.8.</span> <span class="toc-text">substr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tolower"><span class="toc-number">13.0.9.</span> <span class="toc-text">tolower</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toupper"><span class="toc-number">13.0.10.</span> <span class="toc-text">toupper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">I&#x2F;O处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getline"><span class="toc-number">14.0.1.</span> <span class="toc-text">getline</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#expression-getline-var"><span class="toc-number">14.0.1.1.</span> <span class="toc-text">expression | getline [var]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getline-var"><span class="toc-number">14.0.1.2.</span> <span class="toc-text">getline [var]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getline-var-lt-expression"><span class="toc-number">14.0.1.3.</span> <span class="toc-text">getline [var] &lt; expression</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#close"><span class="toc-number">14.0.2.</span> <span class="toc-text">close</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#system"><span class="toc-number">14.0.3.</span> <span class="toc-text">system</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-number">15.</span> <span class="toc-text">结束语</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>awk的总结文字，转载之</p>
</blockquote>
<hr>
<h3 id="Awk是什么"><a href="#Awk是什么" class="headerlink" title="Awk是什么"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#whatisawk">Awk是什么</a></h3><p>Awk、sed与grep，俗称Linux下的三剑客，它们之前有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交互式且面向字符流的编辑器（a “non-interactive” stream-oriented editor），而awk则是一门模式匹配的编程语言，因为它的主要功能是用于匹配文本并处理，同时它有一些编程语言才有的语法，例如函数、分支循环语句、变量等等，当然比起我们常见的编程语言，Awk相对比较简单。</p>
<p>使用Awk，我们可以做以下事情：</p>
<ul>
<li>将文本文件视为由字段和记录组成的文本数据库；</li>
<li>在操作文本数据库的过程中能够使用变量；</li>
<li>能够使用数学运算和字符串操作；</li>
<li>能够使用常见的编程结构，例如条件分支与循环；</li>
<li>能够格式化输出；</li>
<li>能够自定义函数；</li>
<li>能够在awk脚本中执行UNIX命令；</li>
<li>能够处理UNIX命令的输出结果；</li>
</ul>
<p>装备以上功能，awk能够做得事情非常多。但千里之行，始于足下，我们首先从最基本的命令行语法开始，一步一步得走入awk的编程世界。</p>
<hr>
<h3 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#commandusing">命令行语法</a></h3><p>同sed一样，awk的命令行语法也有两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [-F ERE] [-v assignment] ... program [argument ...]</span><br><span class="line">awk [-F ERE] -f progfile ...  [-v assignment] ...[argument ...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的program类似sed中的script，因为我们一直强调awk是一门编程语言，所以将awk的脚本视为一段代码。而awk的脚本同样可以写到一个文件中，并通过-f参数指定，这一点和sed是一样的。program一般多个pattern和action序列组成，当读入的记录匹配pattern时，才会执行相应的action命令。这里有一点要注意，在第一种形式中，除去命令行选项外，program参数一定要位于第一个位置。</p>
<p>Awk的输入被解析成多个记录（Record），默认情况下，记录的分隔符是\n，因此可以认为一行就是一个记录，记录的分隔符可以通过内置变量RS更改。当记录匹配某个pattern时，才会执行后续的action命令。</p>
<p>而每个记录由进一步地被分隔成多个字段（Field），默认情况下字段的分隔符是空白符，例如空格、制表符等等，也可以通过-F ERE选项或者内置变量FS更改。在awk中，可以通过$1，$2…来访问对应位置的字段，同时$0存放整个记录，这一点有点类似shell下的命令行位置参数。关于这些内容，我们会在下面详细介绍，这里你只要知道有这些东西就好。</p>
<p>标准的awk命令行参数主要由以下三个：</p>
<ul>
<li>-F ERE：定义字段分隔符，该选项的值可以是扩展的正则表达式（ERE）；</li>
<li>-f progfile：指定awk脚本，可以同时指定多个脚本，它们会按照在命令行中出现的顺序连接在一起；</li>
<li>-v assignment：定义awk变量，形式同awk中的变量赋值，即name&#x3D;value，赋值发生在awk处理文本之前；</li>
</ul>
<p>为了便于理解，这里举几个简单的例子。通过-F参数设置冒号:为分隔符，并打印各个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1:2:3&quot; | awk -F: &#x27;&#123;print $1 &quot; and &quot; $2 &quot; and &quot; $3&#125;&#x27;</span><br><span class="line">1 and 2 and 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在awk的脚本中访问通过-v选项设置的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo | awk -v a=1 &#x27;BEGIN &#123;print a&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看到，通过-v选项设置的变量在BEGIN的位置就可以访问了。BEGIN是一个特殊的pattern，它在awk处理输入之前就会执行，可以认为是一个初始化语句，与此对应的还有END。</p>
<p>好像还没介绍如何指定处理的文件，是不是最后的argument就是指定的文件？在看我这本书之前，我也是这样认为的，但是实际上arguemnt有两种形式，它们分别是输入文件（file）和变量赋值（assignment）。</p>
<p>awk可以同时指定多个输入文件，如果输入文件的文件名为’-‘，表示从标准输入读取内容。</p>
<p>变量赋值类似-v选项，它的形式为name&#x3D;value。awk中的变量名同一般的编程语言无太多区别，但是不能同awk的保留关键字重名，可以查看awk的man手册查询哪些是保留关键字。而变量值只有两种形式：字符串和数值。变量赋值必须位于脚本参数的后面，与文件名参数无先后顺序的要求，但是位于不同位置的赋值它的执行时机是不同的。</p>
<p>我们用实际的例子来解释这个区别，假设有两个文件：a和b，它们的内容分别如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat a</span><br><span class="line">file a</span><br><span class="line">cat b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了说明赋值操作发生的时机，我们在BEGIN，正常处理，END三个地方都打印变量的值。</p>
<p>第一种情况： 变量赋值位于所有文件名参数之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; var=1 a</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：赋值操作发生在正常处理之前，BEGIN动作之后。</p>
<p>第二种情况：变量赋值位于所有文件名之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1  </span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：赋值操作发生在正常处理之后，END动作之前。</p>
<p>第三种情况：变量赋值位于文件名之间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125; &#123;print &quot;PROCESS: &quot; var&#125; END &#123;print &quot;END: &quot; var &#125;&#x27; a var=1 b</span><br><span class="line">BEGIN: </span><br><span class="line">PROCESS: </span><br><span class="line">PROCESS: 1</span><br><span class="line">END: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>结果：赋值操作发生在处理前面的文件之后，并且位于处理后面的文件之前；</em></p>
<h5 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h5><ul>
<li>如果变量赋值在第一个文件参数之前，在BEGIN动作之后执行，影响到正常处理和END动作；</li>
<li>如果变量赋值在最后一个文件参数之后，在END动作之前执行，仅影响END动作；</li>
<li>如果文件参数不存在，情况同1所述；</li>
<li>如果变量赋值位于多个文件参数之间，在变量赋值前面的文件被处理后执行，影响到后续文件的处理和END动作；</li>
</ul>
<p>所以变量赋值一定要考虑清楚用途，否则比较容易出错，不过一般情况下也不会用到变量赋值。</p>
<p>自然地大家会将变量赋值与-v assignment选项进行比较，赋值的形式是一致的，但是-v选项的执行时机比变量赋值要早：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v var=a &#x27;BEGIN &#123;print &quot;BEGIN: &quot; var&#125;&#x27;</span><br><span class="line">BEGIN: a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见，-v选项的赋值操作在BEGIN动作之前就执行了。</p>
<p>变量赋值一定要小心不要与保留关键字重名，否则会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk -v BEGIN=1 &#x27;BEGIN &#123;print &quot;BEGIN: &quot; BEGIN&#125;&#x27;</span><br><span class="line">awk: fatal: cannot use gawk builtin `BEGIN&#x27; as variable name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="记录（Record）与字段（Field"><a href="#记录（Record）与字段（Field" class="headerlink" title="记录（Record）与字段（Field)"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/recordandfield">记录（Record）与字段（Field)</a></h3><p>对于数据库来说，一个数据库表是由多条记录组成的，每一行表示一条记录（Record）。每条记录由多列组成，每一列表示一个字段（Field)。Awk将一个文本文件视为一个文本数据库，因此它也有记录和字段的概念。默认情况下，记录的分隔符是回车，字段的分隔符是空白符，所以文本文件的每一行表示一个记录，而每一行中的内容被空白分隔成多个字段。利用字段和记录，awk就可以非常灵活地处理文件的内容。</p>
<p>可以通过-F选项来修改默认的字段分隔符，例如&#x2F;etc&#x2F;passwd的每一行都是由冒号分隔成多个字段的，所以这里就需要将分隔符设置成冒号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过$1引用第一人字段，类似地$2表示第二个字段，$3表示第三个字段…. $0则表示整个记录。内置变量NF记录着字段的个数，所以$NF表示最后一个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd | head -3</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/false</span><br><span class="line">/bin/false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，$(NF-1)表示倒数第二个。</p>
<p>内置变量FS也可以用于更改字段分隔符，它记录着当前的字段分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &#x27;&#123;print FS&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">:</span><br><span class="line">awk -v FS=: &#x27;&#123;print $1&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录的分隔符可以通过内置变量RS更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -v RS=: &#x27;&#123;print $0&#125;&#x27; /etc/passwd | head -1</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果将RS设置成空，行为有就一点怪异了，它会将连续不为空行的所有行（一个段落）当作一个记录，而且强制回车为字段分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat awk_man.txt </span><br><span class="line">The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">which is specialized for textual data manipulation. An awk program is a sequence</span><br><span class="line">of patterns and corresponding actions.  When  input  is  read  that matches a </span><br><span class="line">pattern, the action associated with that pattern is carried out.</span><br><span class="line"></span><br><span class="line">Input shall be interpreted as a sequence of records. By default, a record is a line, </span><br><span class="line">less its terminating &lt;newline&gt;, but this can be changed by using the RS built-in </span><br><span class="line">variable. Each record of input shall be matched in turn against each pattern in the </span><br><span class="line">program. For each pattern matched, the associated action shall be executed.</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN &#123;RS=&quot;&quot;;FS=&quot;:&quot;&#125; &#123;print &quot;First line: &quot; $1&#125;&#x27; awk_man.txt </span><br><span class="line">First line: The awk utility shall execute programs written in the awk programming language,</span><br><span class="line">First line: Input shall be interpreted as a sequence of records. By default, a record is a line,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，我们将变量赋值放到BEGIN动作中执行，因为BEGIN动作是在文件处理之前执行的，专门用于放初始化的语句。FS的赋值在这里是无效的，awk依然使用回车符来分隔字段。</p>
<hr>
<h3 id="脚本（Script）组成"><a href="#脚本（Script）组成" class="headerlink" title="脚本（Script）组成"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#script">脚本（Script）组成</a></h3><p>命令行中的program部分，可以称为awk代码,也可以称为awk脚本。一段awk脚本是由多个’pattern { action }‘序列组成的。action是一个或者多个语句，它在输入行匹配pattern的时候被执行。如果pattern为空，表明这个action会在每一行处理时都会被执行。下面的例子简单地打印文件的每一行，这里不带任何参数的print语句打印的是整个记录，类似’print $0‘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;line1\nline2&#x27; | awk &#x27;&#123;print&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了pattern { action }，还可以在脚本中定义自定义的函数，函数定义格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function name(parameter list) &#123; statements &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数列表用逗号分隔，参数默认是局部变量，无法在函数之外访问，而在函数中定义的变量为全局变量，可以在函数之外访问，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo line1 | awk &#x27;</span><br><span class="line">function t(a) &#123;</span><br><span class="line">    b=a;</span><br><span class="line">    print a;</span><br><span class="line">&#125; </span><br><span class="line">&#123;</span><br><span class="line">    print b;</span><br><span class="line">    t(&quot;kodango.me&quot;); </span><br><span class="line">    print b;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Awk脚本中的语句使用空行或者分号分隔，使用分号可以放在同一行，不过有时候会影响可读性，尤其是分支或循环结构中，很容易出错。</p>
<p>如果Awk中的一个语句太长，要分成多行，可以在行为使用反斜杠’’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat test.awk</span><br><span class="line">function t(a)</span><br><span class="line">&#123;</span><br><span class="line">        b=a</span><br><span class="line">        print &quot;This is a very long line, so use backslash to escape the newline then we will print the variable a: a=&quot; a</span><br><span class="line">&#125; </span><br><span class="line">&#123; print b; t(&quot;kodango.me&quot;); print b;&#125;</span><br><span class="line">echo 1 | awk -f test.awk</span><br><span class="line"></span><br><span class="line">This is a very long line, so use backslash to escape the newline then we will print the variable a: a=kodango.me</span><br><span class="line">kodango.me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>这里我们将脚本写到文件中，并通过-f参数来指定。但是，在一些特殊符号之后，是可以直接换行的，例如”, { &amp;&amp;</th>
<th></th>
<th>”。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="模式（Pattern）"><a href="#模式（Pattern）" class="headerlink" title="模式（Pattern）"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#pattern">模式（Pattern）</a></h3><p>模式是awk中比较重要的一部分，它有以下几种情况：</p>
<ul>
<li>&#x2F;regular expression&#x2F;： 扩展的正则表达式（Extended Regular Expression）， 关于ERE可以参考 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">这篇文章</a>；</li>
<li>relational expression： 关系表达式，例如大于、小于、等于，关系表达式结果为true表示匹配；</li>
<li>BEGIN： 特殊的模式，在第一个记录处理之前被执行，常用于初始化语句的执行；</li>
<li>END： 特殊的模式，在最后一个记录处理之前被执行，常用于输出汇总信息；</li>
<li>pattern, pattern：模式对，匹配两者之间的所有记录，类似sed的地址对；</li>
</ul>
<p>例如查找匹配数字3的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 20 | awk &#x27;/3/ &#123;print&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">13</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相反地，可以在在正则表达式之前加上’!’表示不匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;!/3/ &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>除了BEGIN和END这两个特殊的模式外，其余的模式都可以使用’&amp;&amp;’或者’</th>
<th></th>
<th>’运算符组合，前者表示逻辑与，后者表示逻辑或：</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq 1 50 | awk &#x27;/3/ &amp;&amp; /1/ &#123;print&#125;&#x27;</span><br><span class="line">13</span><br><span class="line">31</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面的正则都是整行匹配，有时候仅仅需要匹配某个字符，这样我们可以用表达式$n ~ &#x2F;ere&#x2F;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;$1 ~ /xi/ &#123;print&#125;&#x27; /etc/passwd</span><br><span class="line">xingming:x:1000:1000::/home/xingming:/bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时候我们只想显示特定和行，例如显示第一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq 1 5 | awk &#x27;NR==1 &#123;print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="正则表达式（Regular-Expression）"><a href="#正则表达式（Regular-Expression）" class="headerlink" title="正则表达式（Regular Expression）"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#regex">正则表达式（Regular Expression）</a></h3><p>正则表达式的内容介绍起来太麻烦，还是推荐同学阅读现有的文章（如 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux&#x2F;Unix工具与正则表达式的POSIX规范</a>），里面对各个流派的正则表达式归纳地很清楚了。</p>
<hr>
<h3 id="表达式（Expressions）"><a href="#表达式（Expressions）" class="headerlink" title="表达式（Expressions）"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#expressions">表达式（Expressions）</a></h3><p>表达式可以由常量、变量、运算符和函数组成，常数和变量的值可以为字符串和数值。</p>
<p>Awk中的变量有三种类型：用户定义的变量，内置变量和字段变量。其中，内置变量名都是大写的。变量并不非一定要被声明或者被初始化，未初始化的字符串变量的值为””，未初始化的数值变量的值为0。字段变量可以用$n来引用，n的取值范围为[0,NF]。n可以为一个变量，例如$NF代码最后一个字段，而$(NF-1)表示倒数第二个字段。</p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#array">数组</a></h3><p>数组是一种特殊的变量，在awk中，比较特殊地是，数组的下标可以为数字或者字符串。数组的赋值很简单，下面将value赋值给数组下标为index的元素：<code>array[index]=value</code></p>
<p>可以用for..in..语法遍历数组元素，其中item是数组元素对应的下标：<code>for (item in array)</code></p>
<p>当然也可以在if分支判断中使用in操作符：<code>if (item in array)</code></p>
<p>一个完整的例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2 3&quot; | awk &#x27;&#123;</span><br><span class="line">    for (i=0;i&lt;NF;i++)</span><br><span class="line">          a[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">END &#123;</span><br><span class="line">    print 3 in a</span><br><span class="line">        for (i in a)</span><br><span class="line">               printf &quot;%s: %s\n&quot;, i, a[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">0</span><br><span class="line">0: 0</span><br><span class="line">1: 1</span><br><span class="line">2: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#innervalue">内置变量</a></h3><p>Awk在内部维护了许多内置变量，或者称为系统变量，例如之前提到的FS、RS等等。常见的内置变量如下表所示</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARGC</td>
<td>命令行参数的各个，即ARGV数组的长度</td>
</tr>
<tr>
<td>ARGV</td>
<td>存放命令行参数</td>
</tr>
<tr>
<td>CONVFMT</td>
<td>定义awk内部数值转换成字符串的格式，默认值为”%.6g”</td>
</tr>
<tr>
<td>OFMT</td>
<td>定义输出时数值转换成字符串的格式，默认值为”%.6g”</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>存放系统环境变量的关联数组</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前被处理的文件名</td>
</tr>
<tr>
<td>NR</td>
<td>记录的总个数</td>
</tr>
<tr>
<td>FNR</td>
<td>当前文件中的记录的总个数</td>
</tr>
<tr>
<td>FS</td>
<td>字段分隔符，默认为空白</td>
</tr>
<tr>
<td>NF</td>
<td>每个记录中字段的个数</td>
</tr>
<tr>
<td>RS</td>
<td>记录的分隔符，默认为回车</td>
</tr>
<tr>
<td>OFS</td>
<td>输出时字段的分隔符，默认为空白</td>
</tr>
<tr>
<td>ORS</td>
<td>输出时记录的分隔符，默认为回车</td>
</tr>
<tr>
<td>RLENGTH</td>
<td>被match函数匹配的子串长度</td>
</tr>
<tr>
<td>RSTART</td>
<td>被match函数匹配的子串位于目标字符串的起始下标</td>
</tr>
</tbody></table>
<p>下面主要介绍几个比较难理解的内置变量：</p>
<h5 id="ARGV与ARGC"><a href="#ARGV与ARGC" class="headerlink" title="ARGV与ARGC"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#argvargc">ARGV与ARGC</a></h5><p>ARGV与ARGC的意思比较好理解，就像C语言 <code>main(int argc, char **argv)</code>。ARGV数组的下标从0开始到ARGC-1，它存放的是命令行参数，并且排除命令行选项（例如-v&#x2F;-f）以及program部分。因此事实上ARGV只是存储argument的部分，即文件名（file）以及命令行变量赋值两部分的内容。</p>
<p>通过下面的例子可以大概了解ARGC与ARGV的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    for (i = 0; i &lt; ARGC; i++)</span><br><span class="line">        print ARGV[i]</span><br><span class="line">&#125;&#x27; inventory-shipped BBS-list</span><br><span class="line">awk</span><br><span class="line">inventory-shipped</span><br><span class="line">BBS-list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ARGV的用法不仅限于此，它是可以修改的，可以更改数组元素的值，可以增加数组元素或者删除数组元素。</p>
<h6 id="更改ARGV元素的值"><a href="#更改ARGV元素的值" class="headerlink" title="更改ARGV元素的值"></a>更改ARGV元素的值</h6><p>假设我们有a, b两个文件，它们各有一行内容：file a和file b。现在利用ARGV，我们可以做到偷梁换柱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;b&quot;&#125; &#123;print&#125;&#x27; a</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里要注意ARGV[1]&#x3D;”b”的引号不能缺少，否则ARGV[1]&#x3D;b会将变量b的值赋值给ARGV[1]。</p>
<p>当awk处理完一个文件之后，它会从ARGV的下一个元素获取参数，如果是一个文件则继续处理，如果是一个变量赋值则执行赋值操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;var=1&quot;&#125; &#123;print var&#125;&#x27; a b</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当下一个元素为空时，则跳过不处理，这样可以避开处理某个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中a这个文件就被跳过了。</p>
<p>而当下一个元素的值为”-”时，表明从标准输入读取内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGV[1]=&quot;-&quot;&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">a</span><br><span class="line">a    # --&gt; 这里按下CTRL+D停止输入</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="删除ARGV元素"><a href="#删除ARGV元素" class="headerlink" title="删除ARGV元素"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#deleteargv">删除ARGV元素</a></h6><p>删除ARGV元素和将元素的值赋值为空的效果是一样的，它们都会跳转对某个参数的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;delete ARGV[1]&#125; &#123;print&#125;&#x27; a b</span><br><span class="line">file b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除数组元素可以用delete语句。</p>
<h6 id="增加ARGV元素"><a href="#增加ARGV元素" class="headerlink" title="增加ARGV元素"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#addingargv">增加ARGV元素</a></h6><p>我第一次看到ARGV变量的时候就在想，能不能利用ARGV变量避免提供命令行参数，就像这样: <code>awk &#39;BEGIN&#123;ARGV[1]=&quot;a&quot;;&#125; &#123;print&#125;&#39;</code></p>
<p>但是事实上这样不行，awk会依然从标准输入中获取内容。下面的方法倒是可以，首先增加ARGC的值，再增加ARGV元素，我到现在也没搞懂这两者的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;ARGC+=1;ARGV[1]=&quot;a&quot;&#125; &#123;print&#125;&#x27;</span><br><span class="line">file a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="CONVFMT与OFMT"><a href="#CONVFMT与OFMT" class="headerlink" title="CONVFMT与OFMT"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#convfmtofmt">CONVFMT与OFMT</a></h5><p>Awk中允许数值到字符串相互转换，其中内置变量CONVFMT定义了awk内部数值到字符串转换的格式，它的默认值为”%.6g”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11</span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%.6g, num=12.110000, str=12.11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过更改CONVFMT，我们可以定义自己的转换格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    CONVFMT=&quot;%d&quot;;</span><br><span class="line">    printf &quot;CONVFMT=%s, num=%f, str=%s\n&quot;, CONVFMT, 12.11, 12.11 </span><br><span class="line">&#125;&#x27;</span><br><span class="line">CONVFMT=%d, num=12.110000, str=12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与此对应地还有一个内置变量 <em>OFMT</em>，它与CONVFMT的作用是类似的，只不过是影响输出的时候数字转换成字符串的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; OFMT=&quot;%d&quot;;print 12.11 &#125;&#x27; </span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ENVIRON"><a href="#ENVIRON" class="headerlink" title="ENVIRON"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#environ">ENVIRON</a></h5><p>ENVIRON是一个存放系统环境变量的关联数组，它的下标是环境变量名称，值是相应环境变量的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print ENVIRON[&quot;USER&quot;] &#125;&#x27; </span><br><span class="line">xingming</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用环境变量也可以将值传递给awk：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">U=hello awk &#x27;BEGIN &#123; print ENVIRON[&quot;U&quot;] &#125;&#x27; </span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以利用for..in循环遍历ENVIRON数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; </span><br><span class="line">    for (env in ENVIRON) </span><br><span class="line">        printf &quot;%s=%s\n&quot;, env, ENVIRON[env]; </span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="RLENGTH与RSTART"><a href="#RLENGTH与RSTART" class="headerlink" title="RLENGTH与RSTART"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#rlengthrstart">RLENGTH与RSTART</a></h5><p>RLENGTH与RSTART都是与match函数相关的，前者表示匹配的子串长度，后者表示匹配的子串位于目标字符串的起始下标。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;match(&quot;hello,world&quot;, /llo/); print RSTART,RLENGTH&#125;&#x27;</span><br><span class="line">3 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#yunsuanfu">运算符</a></h3><p>表达式中必然少不了运算符，awk支持的运算符可以参见man手册中的“Expressions in awk”一小节内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man awk | grep &quot;^ *Table: Expressions in&quot; -A 42 | sed &#x27;s/^ *//&#x27;</span><br><span class="line">Table: Expressions in Decreasing Precedence in awk</span><br><span class="line"> </span><br><span class="line">Syntax                Name                      Type of Result   Associativity</span><br><span class="line">( expr )              Grouping                  Type of expr     N/A</span><br><span class="line">$expr                 Field reference           String           N/A</span><br><span class="line">++ lvalue             Pre-increment             Numeric          N/A</span><br><span class="line">-- lvalue             Pre-decrement             Numeric          N/A</span><br><span class="line">lvalue ++             Post-increment            Numeric          N/A</span><br><span class="line">lvalue --             Post-decrement            Numeric          N/A</span><br><span class="line">expr ^ expr           Exponentiation            Numeric          Right</span><br><span class="line">! expr                Logical not               Numeric          N/A</span><br><span class="line"> </span><br><span class="line">+ expr                Unary plus                Numeric          N/A</span><br><span class="line">- expr                Unary minus               Numeric          N/A</span><br><span class="line">expr * expr           Multiplication            Numeric          Left</span><br><span class="line"> </span><br><span class="line">...以下省略...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="语句（Statement）"><a href="#语句（Statement）" class="headerlink" title="语句（Statement）"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#statement">语句（Statement）</a></h3><p>到目前为止，用得比较多的语句就是print，其它的还有printf、delete、break、continue、exit、next等等。这些语句与函数不同的是，它们不会使用带括号的参数，并且没有返回值。不过也有意外，比如printf就可以像函数一样的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 | awk &#x27;&#123;printf(&quot;%s\n&quot;, &quot;abc&quot;)&#125;&#x27;</span><br><span class="line">abc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>break和continue语句，大家应该比较了解，分别用于跳出循环和跳到下一个循环。</p>
<p>delete用于删除数组中的某个元素，这个我们在上面介绍ARGV的时候也使用过。</p>
<p>exit的用法顾名思义，就是退出awk的处理，然后会执行END部分的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;print;exit&#125; END &#123;print &quot;exit..&quot;&#125;&#x27;</span><br><span class="line">line1</span><br><span class="line">exit..</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>next语句类似sed的n命令，它会读取下一条记录，并重新回到脚本的最开始处执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo $&#x27;line1\nline2&#x27; | awk &#x27;&#123;</span><br><span class="line">    print &quot;Before next..&quot;</span><br><span class="line">    print $0 </span><br><span class="line">    next</span><br><span class="line">    print &quot;After next..&quot;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">Before next..</span><br><span class="line">line1</span><br><span class="line">Before next..</span><br><span class="line">line2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出next后面的print语句不会执行。</p>
<p>print与printf语句是使用最多的，它们将内容输出到标准输出。注意在print语句中，输出的变量之间带不带逗号是有区别的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1, $2&#125;&#x27;</span><br><span class="line">1 2</span><br><span class="line">echo &quot;1 2&quot; | awk &#x27;&#123;print $1 $2&#125;&#x27;</span><br><span class="line">12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>print输出时，字段之间的分隔符可以由OFS重新定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1 2&quot; | awk &#x27;&#123;OFS=&quot;;&quot;;print $1,$2&#125;&#x27;</span><br><span class="line">1;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除此之外，print的输出还可以重定向到某个文件中或者某个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print items &gt; output-file</span><br><span class="line">print items &gt;&gt; output-file</span><br><span class="line">print items | command</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设有这一样一个文件，第一列是语句名称，第二列是对应的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat column.txt </span><br><span class="line">statement|description</span><br><span class="line">delete|delete item from an array</span><br><span class="line">exit|exit from the awk process</span><br><span class="line">next|read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们要将两列的内容分别输出到statement.txt和description.txt两个文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&#x27;|&#x27; &#x27;&#123;</span><br><span class="line">    print $1 &gt; &quot;statement.txt&quot;;</span><br><span class="line">    print $2 &gt; &quot;description.txt&quot;</span><br><span class="line">&#125;&#x27; column.txt </span><br><span class="line">[kodango@devops awk_temp]$ cat statement.txt </span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line">[kodango@devops awk_temp]$ cat description.txt </span><br><span class="line">description</span><br><span class="line">delete item from an array</span><br><span class="line">exit from the awk process</span><br><span class="line">read next input record and process</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是一个重定向到命令的例子，假设我们要对下面的文件进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat num.list </span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以通过将print的内容重定向到”sort -n”命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;print | &quot;sort -n&quot;&#125;&#x27; num.list </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>printf命令的用法与print类似，也可以重定向到文件或者输出，只不过printf比print多了格式化字符串的功能。printf的语法也大多数语言包括bash的printf命令类似，这里就不多介绍了。</p>
<hr>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#mathfunction">数学函数</a></h3><p>awk中支持以下数学函数：</p>
<ul>
<li>atan2(y,x)：反正切函数；</li>
<li>cos(x)：余弦函数；</li>
<li>sin(x)：正弦函数；</li>
<li>exp(x)：以自然对数e为底指数函数；</li>
<li>log(x)：计算以e 为底的对数值；</li>
<li>sqrt(x)：开平方函数；</li>
<li>int(x)：将数值转换成整数（绝对值）；</li>
<li>rand()：返回0到1的一个随机数值，不包含1；</li>
<li>srand([expr])：设置随机种子，一般与rand函数配合使用，如果参数为空，默认使用当前时间为种子；</li>
</ul>
<p>例如，我们使用rand()函数生成一个随机数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line">$ awk &#x27;BEGIN &#123;print rand(),rand();&#125;&#x27;</span><br><span class="line">0.237788 0.291066</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是你会发现，每次awk执行都会生成同样的随机数，但是在一次执行过程中产生的随机数又是不同的。因为每次awk执行都使用了同样的种子，所以我们可以用srand()函数来设置种子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.171625 0.00692412</span><br><span class="line">$ awk &#x27;BEGIN &#123;srand();print rand(),rand();&#125;&#x27;</span><br><span class="line">0.43269 0.782984</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样每次生成的随机数就不一样了。</p>
<p>利用rand()函数我们也可以生成1到n的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;</span><br><span class="line">    function randint(n) &#123; return int(n*rand()); &#125;</span><br><span class="line">    BEGIN &#123; srand(); print randint(10);</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#string">字符串函数</a></h3><p>awk中包含大多数常见的字符串操作函数。</p>
<h5 id="sub"><a href="#sub" class="headerlink" title="sub"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#sub">sub</a></h5><p><em>sub(ere, repl[, in])</em></p>
<p>描述：简单地说，就是将in中匹配ere的部分替换成repl，返回值是替换的次数。如果in参数省略，默认使用$0。替换的动作会直接修改变量的值。</p>
<p>下面是一个简单的替换的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello, world&quot; | awk &#x27;&#123;print sub(/ello/, &quot;i&quot;); print&#125;&#x27;</span><br><span class="line">1</span><br><span class="line">hi, world</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在repl参数中&amp;是一个元字符，它表示匹配的内容，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;var=&quot;kodango&quot;; sub(/kodango/, &quot;hello, &amp;&quot;, var); print var&#125;&#x27;</span><br><span class="line">hello, kodango</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="gsub"><a href="#gsub" class="headerlink" title="gsub"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#gsub">gsub</a></h5><p><em>gsub(ere, repl[, in])</em></p>
<p>描述：同sub()函数功能类似，只不过是gsub()是全局替换，即替换所有匹配的内容。</p>
<h5 id="index"><a href="#index" class="headerlink" title="index"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#index">index</a></h5><p><em>index(s, t)</em></p>
<p>描述：返回字符串t在s中出现的位置，注意这里位置是从1开始计算的，如果没有找到则返回0。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;n&quot;)&#125;&#x27;</span><br><span class="line">2</span><br><span class="line">$ awk &#x27;BEGIN &#123;print index(&quot;xingming&quot;, &quot;w&quot;)&#125;&#x27;</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="length"><a href="#length" class="headerlink" title="length"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#length">length</a></h5><p><em>length[([s])]</em></p>
<p>描述：返回字符串的长度，如果参数s没有指定，则默认使用$0作为参数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;print length(&#x27;xingming&#x27;);&#125;&#x27;</span><br><span class="line">8</span><br><span class="line">$ echo &quot;first line&quot; | awk &#x27;&#123;print length();&#125;&#x27;</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="match"><a href="#match" class="headerlink" title="match"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#match">match</a></h5><p><em>match(s, ere)</em></p>
<p>描述： 返回字符串s匹配ere的起始位置，如果不匹配则返回0。该函数会定义RSTART和RLENGTH两个内置变量。RSTART与返回值相同，RLENGTH记录匹配子串的长度，如果不匹配则为-1。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">print match(&quot;xingming&quot;, /ngmin/);</span><br><span class="line">printf &quot;Matched at: %d, Matched substr length: %d\n&quot;, RSTART, RLENGTH;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">3</span><br><span class="line">Matched at: 3, Matched substr length: 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="split"><a href="#split" class="headerlink" title="split"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#split">split</a></h5><p><em>split(s, a[, fs])</em></p>
<p>描述：将字符串按照分隔符fs，分隔成多个部分，并存到数组a中。注意，存放的位置是从第1个数组元素开始的。如果fs为空，则默认使用FS分隔。函数返回值分隔的个数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i in arr)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有一个奇怪的地方是for..in..输出的数组不是按顺序输出的，如果要按顺序输出可以用常规的for循环:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;</span><br><span class="line">    n=split(&quot;1;2;3;4;5&quot;, arr, &quot;;&quot;)</span><br><span class="line">    for (i=1; i&lt;=n; i++)</span><br><span class="line">        printf &quot;arr[%d]=%d\n&quot;, i, arr[i];</span><br><span class="line">&#125;&#x27;</span><br><span class="line">arr[1]=1</span><br><span class="line">arr[2]=2</span><br><span class="line">arr[3]=3</span><br><span class="line">arr[4]=4</span><br><span class="line">arr[5]=5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#sprintf">sprintf</a></h5><p><em>sprintf(fmt, expr, expr, …)</em></p>
<p>描述：类似printf，只不过不会将格式化后的内容输出到标准输出，而是当作返回值返回。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    var=sprintf(&quot;%s=%s&quot;, &quot;name&quot;, &quot;value&quot;)</span><br><span class="line">    print var</span><br><span class="line">&#125;&#x27;</span><br><span class="line">name=value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="substr"><a href="#substr" class="headerlink" title="substr"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#substr">substr</a></h5><p><em>substr(s, m[, n])</em></p>
<p>描述：返回从位置m开始的，长度为n的子串，其中位置从1开始计算，如果未指定n或者n值大于剩余的字符个数，则子串一直到字符串末尾为止。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2, 3); &#125;&#x27;</span><br><span class="line">iao</span><br><span class="line">awk &#x27;BEGIN &#123; print substr(&quot;xiaoh.me&quot;, 2); &#125;&#x27;</span><br><span class="line">iaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#tolower">tolower</a></h5><p><em>tolower(s)</em></p>
<p>描述：将字符串转换成小写字符。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print tolower(&quot;XIAOH.ME&quot;);&#125;&#x27;</span><br><span class="line">xiaoh.me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="toupper"><a href="#toupper" class="headerlink" title="toupper"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#toupper">toupper</a></h5><p><em>toupper(s)</em></p>
<p>描述：将字符串转换成大写字符。</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;print toupper(&#x27;xiaoh.me&#x27;)&#125;&#x27;</span><br><span class="line">XIAOH.ME</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="I-x2F-O处理函数"><a href="#I-x2F-O处理函数" class="headerlink" title="I&#x2F;O处理函数"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#io">I&#x2F;O处理函数</a></h3><h5 id="getline"><a href="#getline" class="headerlink" title="getline"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#getline">getline</a></h5><p>getline的用法相对比较复杂，它有几种不同的形式。不过它的主要作用就是从输入中每次获取一行输入。</p>
<h6 id="expression-getline-var"><a href="#expression-getline-var" class="headerlink" title="expression | getline [var]"></a><code>expression | getline [var]</code></h6><p>这种形式将前面管道前命令输出的结果作为getline的输入，每次读取一行。如果后面跟有var，则将读取的内容保存到var变量中，否则会重新设置$0和NF。</p>
<p>例如，我们将上面的statement.txt文件的内容显示作为getline的输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline var) print var&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">delete</span><br><span class="line">exit</span><br><span class="line">next</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中命令要用双引号，<code>cat statement.txt</code>，这一点同print&#x2F;printf是一样的。</p>
<p>如果不加var，则直接写到$0中，注意NF值也会被更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; while(&quot;cat statement.txt&quot; | getline) print $0,NF&#125;&#x27;</span><br><span class="line">statement 1</span><br><span class="line">delete 1</span><br><span class="line">exit 1</span><br><span class="line">next 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="getline-var"><a href="#getline-var" class="headerlink" title="getline [var]"></a><code>getline [var]</code></h6><p>第二种形式是直接使用getline，它会从处理的文件中读取输入。同样地，如果var没有，则会设置$0，并且这时候会更新NF, NR和FNR：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;</span><br><span class="line">    while (getline) </span><br><span class="line">       print NF, NR, FNR, $0;</span><br><span class="line">&#125;&#x27; statement.txt</span><br><span class="line">1 2 2 delete</span><br><span class="line">1 3 3 exit</span><br><span class="line">1 4 4 next</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="getline-var-lt-expression"><a href="#getline-var-lt-expression" class="headerlink" title="getline [var] &lt; expression"></a><code>getline [var] &lt; expression</code></h6><p>第三种形式从expression中重定向输入，与第一种方法类似，这里就不加赘述了。</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#close">close</a></h5><p>close函数可以用于关闭已经打开的文件或者管道，例如getline函数的第一种形式用到管道，我们可以用close函数把这个管道关闭，close函数的参数与管道的命令一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;</span><br><span class="line">    while(&quot;cat statement.txt&quot; | getline) &#123;</span><br><span class="line">        print $0;</span><br><span class="line">        close(&quot;cat statement.txt&quot;);</span><br><span class="line">&#125;&#125;&#x27;</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line">statement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是每次读了一行后，关闭管道，然后重新打开又重新读取第一行就死循环了。所以要慎用，一般情况下也很少会用到close函数。</p>
<h5 id="system"><a href="#system" class="headerlink" title="system"></a><a target="_blank" rel="noopener" href="http://xiaoh.me/2016/03/23/awk-more/#system">system</a></h5><p>这个函数很简单，就是用于执行外部命令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123;system(&quot;uname -r&quot;);&#125;&#x27;</span><br><span class="line">3.6.2-1-ARCH</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>快速了解Awk系列的几篇文章相对比较粗糙，我是参考Awk的man手册以及《Sed &amp; Awk》附录B总结而成的，但是应该可以让大家对awk有一个大致的了解，欢迎大家一起交流。</p>
</div><div class="tags"><a href="/tags/Linux"><i class="fa fa-tag">Linux</i></a></div><div class="post-nav"><a class="pre" href="/posts/15972/">Nginx相关状态码总结</a><a class="next" href="/posts/54405/">js常用函数总结</a></div><div id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://comment.aimak.cn',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/avatar.png"/></a><p>认真生活.</p><a class="info-icon" href="https://twitter.com/fantasykaicc" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:makren@126.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/fantasykai" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/AI-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">AI, 网络运维</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/">技术小栈</a><span class="category-list-count">117</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a><span class="category-list-count">72</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%93%E5%AD%98/">缓存</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E5%BD%95/">语录</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF-%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/" style="font-size: 15px;">人工智能, 技术趋势, 行业动态</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 15px;">人工智能</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">深度学习</a> <a href="/tags/AI-%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 15px;">AI 智能体</a> <a href="/tags/Deepseek-%E8%87%AA%E6%99%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%90%A5%E5%95%86-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">Deepseek, 自智网络, 运营商, 网络运维</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 15px;">知识图谱</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a> <a href="/tags/PMO/" style="font-size: 15px;">PMO</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/" style="font-size: 15px;">技术团队</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/" style="font-size: 15px;">开发效率</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/thymeleaf/" style="font-size: 15px;">thymeleaf</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Chrome-%E6%95%88%E7%8E%87%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">Chrome 效率插件</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 15px;">缓存</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">测试</a> <a href="/tags/%E8%AF%AD%E5%BD%95/" style="font-size: 15px;">语录</a> <a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 15px;">马拉松</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 15px;">健康</a> <a href="/tags/%E6%8A%A5%E5%91%8A%E5%88%86%E4%BA%AB/" style="font-size: 15px;">报告分享</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/IPv6/" style="font-size: 15px;">IPv6</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/SDN/" style="font-size: 15px;">SDN</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/restful/" style="font-size: 15px;">restful</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%A0%88/" style="font-size: 15px;">技术小栈</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">高并发</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 15px;">日志</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/329fa19e/">每日资讯-0225</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/411b54c4/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2337ee66/">AI 在通信领域的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/411b54c4/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1767db6e/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/411b54c4/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/42f55511/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63200/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63199/">每日资讯</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/63198/">每日资讯</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://comment.aimak.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://landscape.cncf.io/" title="CNCF" target="_blank">CNCF</a><ul></ul><a href="https://segmentfault.com/" title="SegmentFault" target="_blank">SegmentFault</a><ul></ul><a href="https://blog.csdn.net/junbaozi/category_11649936_3.html" title="CloudNative" target="_blank">CloudNative</a><ul></ul><a href="https://excalidraw.com/" title="excalidraw" target="_blank">excalidraw</a><ul></ul><a href="https://tudan.blog.csdn.net/?type=lately" title="王坦" target="_blank">王坦</a><ul></ul><a href="https://aspoem.com/zh-Hans" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">枫哲's文栖小筑.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">｜苏ICP备18013756号-1</a><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>